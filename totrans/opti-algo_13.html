<html><head></head><body>
  <h1 class="tochead" id="heading_id_2">10 <a id="idTextAnchor000"/>Other swarm intelligence algorithms to explore</h1>

  <p class="co-summary-head">This chapter covers<a id="idIndexMarker000"/></p>

  <ul class="calibre5">
    <li class="co-summary-bullet">Getting familiar with ant colony optimization metaheuristics</li>

    <li class="co-summary-bullet">Understanding different variants of ant colony optimization</li>

    <li class="co-summary-bullet">Understanding artificial bee colony</li>

    <li class="co-summary-bullet">Applying these swarm intelligence algorithms to solve continuous and discrete optimization problems</li>
  </ul>

  <p class="body"><a id="marker-362"/>In the previous chapter, we looked at the particle swarm optimiz<a id="idTextAnchor001"/>ation (PSO) algorithm, but ant colony optimization (ACO) and artificial bee colony (ABC) are other widely used swarm intelligence algorithms, drawing inspiration from ants and bees to tackle diverse optimization problems. Let’s revisit the treasure hunting mission and assume you still want to follow a cooperative and iterative approach to find the treasure (which is the best solution in the case of an optimization problem). You and your friends are divided into two groups: the ant group and the bee group. Each group has its own unique way of finding the treasure, using ant colony optimization or the artificial bee colony algorithm. You can join either of these two groups. <a id="idIndexMarker001"/><a id="idIndexMarker002"/><a id="idIndexMarker003"/></p>

  <p class="body">As treasure-hunting ants, you and some of your friends will start at the base camp and explore different paths to find the treasure. As you explore, each of you leaves a trail of special chalk (pheromones) behind. The more promising the path, the more chalk you leave on that path. When your friends find your chalk trail, they can decide to follow it or to explore a new path. Over time, the most promising paths will have the strongest chalk trails, and eventually the whole group will converge on the path that leads to the treasure.</p>

  <p class="body">As treasure-hunting bees, you’ll use a different approach. You have forager bees and scout bees. Forager bees concentrate on searching nearby areas, while scout bees fly out and randomly explore the island, searching for clues leading to the treasure. When a bee finds a promising clue, it returns to the base camp and performs a “waggle dance” to communicate the location and quality of the clue to the other friends (onlooker bees). This process continues until the group finds the best path to the treasure.</p>

  <p class="body">This chapter presents ant colony optimization and artificial bee colony as swarm intelligence algorithms. The open traveling salesman problem, function optimization, routing problem, pump design, and a supply-demand problem are discussed in this chapter and its supplementary exercises in appendix C.</p>

  <h2 class="fm-head" id="heading_id_3">10.1 Nature’s tiny problem-solvers</h2>

  <p class="body"><a id="marker-363"/>Ants are tiny creatures that can solve complex problems better than some humans. Ants may be small, but when they work together in a colony, they can accomplish some incredible feats. During foraging, they can find the shortest path to a food source, build intricate tunnels, and even take down prey much larger than themselves! During nest construction, some ants cut leaves from plants and trees, others forage for leaves hundreds of meters away from their nest to construct highways to and from their foraging sites, and yet other ants form chains of their own bodies, allowing them to cross wide gaps and pull stiff leaves together to form a nest. In the latter case, the worker ants form a chain along the edge of the leaf and pull the edges together by shortening the chain one ant at a time. Once the leaf edges are in place, weaver ants hold one larva each in their mandibles and gently squeeze the larva to produce silk, which is used to glue the leaf edges together.<a id="idIndexMarker004"/><a id="idIndexMarker005"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Fascinating facts about the mighty ant</p>

    <ul class="calibre5">
      <li class="fm-list-bullet2">
        <p class="list-s">Ants appeared on earth some 100 million years ago, making them one of the oldest groups of insects on the planet.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Ants have a current total population estimated at <span class="times">10<sup class="fm-superscript">16</sup></span> individuals. It is estimated that the total weight of ants is in the same order of magnitude as the total weight of human beings.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Ants are incredibly strong for their size. Some species can carry objects that are 50 times their body weight! To put that in perspective, this is like a human carrying a car!</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">About 2% of all insects are social. There are around 12,000 different types of ants, and most ants are social insects.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Ants are considered the densest population in the world. They live in colonies of 30 to millions of individuals. Some colonies like Formica Yesensis have approximately 1,080,000 queens and 306,000,000 workers and live in 45,000 nests connected to each other over an area of 2.7 square kilometers.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Ants use pheromones as their primary medium of stigmergic communication. However, ants also use other forms of communication, including visual, auditory, and tactile communication. For example, some species of ants use sound to communicate with each other. These sounds can range from simple clicks and pops to more complex signals that convey information about food sources, nest locations, and other important information. Some species of ants produce sounds in the audible range of humans (20Hz to 20kHz). For example, leafcutter ants are known to produce a clicking sound when they communicate with each other. The frequency of these clicks can range from 1 to 10 kilohertz. Other species of ants produce sounds that are beyond the range of human hearing. For example, some species of army ants produce ultrasonic sounds that can be used to locate prey or communicate with each other. If you’re interested, take a look at the “What Sound Does an Ant Make?” video on YouTube (<a class="url" href="http://mng.bz/aEKo">http://mng.bz/aEKo</a>).</p>
      </li>
    </ul>
  </div>

  <p class="body">An ant is a simple stimulus-response creature that is incapable of achieving complex tasks alone. However, as a colony, ants show an amazing capability to perform complex tasks without any planning, a central controller, centralized supervision, or direct communication. Ants employ an indirect communication mechanism known as stigmergic communication. <i class="fm-italics">Stigmergy</i> is a concept introduced by the French biologist Pierre-Paul Grassé in 1959 as an indirect method of communication among social insects involving environmental modifications. These environmental modifications serve as external or shared memory between the insects. <a id="idIndexMarker006"/><a id="marker-364"/></p>

  <p class="body">Ants use pheromones as their primary medium of stigmergic communication. As they travel to and from a food source, they deposit pheromones along their path. Other ants can detect these pheromones, which influences their decision-making when choosing a path. This allows ants to work together as a cohesive unit and accomplish complex tasks such as finding the shortest path from the nest to a food source and vice versa. The absence of direct communication or a central controller makes the actions of ants seem almost as if they are coordinated by some form of collective intelligence. In essence, the phenomenon of stigmergic communication allows social insects like ants to use their collective knowledge and behavior to achieve tasks beyond their individual abilities.</p>

  <p class="body">Ant colony optimization (ACO) is inspired by the foraging behavior of ants. As they forage for food, ants initially explore randomly around the nest area. Once an ant discovers a food source, it carries some of the food back to the nest while laying a pheromone trail along its path. Other ants then follow the pheromone trail to the food source, as illustrated in figure 10.1. As more and more ants follow the pheromone trail to the food source, the intensity of the pheromone trail increases, making it more attractive to other ants. In contrast, because pheromone trails are not fixed and will gradually evaporate over time, the pheromone trail on the longer path will evaporate. Eventually, a single pheromone trail becomes dominant, and most of the ants follow this trail to and from the food source. In this way, ants can find the shortest path between the nest and the food source through a process of collective or swarm intelligence.<a id="idIndexMarker007"/><a id="marker-365"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F01_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.1 Ant foregoing process. A foraging ant deposits a pheromone trail along the path it takes on its way back to the nest. Other ants will likely follow the path with a stronger pheromone trail to reach the discovered food source.</p>
  </div>

  <p class="body">As I explained in the previous chapter, the majority of the research carried out on swarm intelligence algorithms was initially based on experimental observations. To understand the collective behavior of ants during food foraging and to derive heuristics for the ACO algorithm, two famous experiments were conducted: the binary bridge experiment and the bridges with non-equal lengths experiment.</p>

  <p class="body">The binary bridge experiment was designed to observe the behavior of ants when presented with two equal-length bridges connecting their nest to a food source (figure 10.2a). The experiment aimed to investigate how ants determine the best path to use and how they adapt their behavior over time. Initially, the ants chose one of the two bridges randomly. As the ants traveled back and forth between the nest and the food source, they deposited pheromones along the path they took. As time progressed, more ants followed the path with the higher concentration of pheromones, which made the path even more attractive to other ants. Eventually, one of the two bridges became dominant, and most of the ants used it to travel between the nest and the food source. The ants’ decision-making process was based on the principle of positive feedback, where the ants reinforced the path with the highest pheromone concentration, making it even more attractive to other ants.<a id="idIndexMarker008"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F02_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.2 a) Binary bridge experiment; b) bridges with non-equal lengths experiment</p>
  </div>

  <p class="body"><a id="marker-366"/>The bridges with non-equal lengths experiment (figure 10.2b) is an extension of the binary bridge experiment with one branch of the bridge being longer than the other. The goal of this experiment was to observe how ants adapted their behavior when presented with two paths of different lengths. The experiment showed that ants tended to select the shorter path over the longer one. This was because ants traveling on the shorter path returned to the nest earlier than those on the longer path. As a result, the pheromone trail on the shorter path was reinforced sooner than that on the longer path, making it more attractive to other ants. This reinforcement behavior is called <i class="fm-italics">autocatalytic behavior</i>.<a id="idIndexMarker009"/><a id="idIndexMarker010"/></p>

  <p class="body">The role of pheromones in the collective behavior of ants can be summarized in the following key points:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">The pheromone trail acts as a collective memory for the ants to communicate through by sensing and recording their foraging experience.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The pheromone trail evaporates over time, introducing changes in the environment that can influence the ants’ behavior.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The concentration of pheromones on the trail represents a feedback signal that influences the ants’ decision-making process.</p>
    </li>
  </ul>

  <p class="body">Let’s now dive deep into ACO metaheuristics.<a id="idIndexMarker011"/><a id="idIndexMarker012"/></p>

  <h2 class="fm-head" id="heading_id_4">10.2 ACO metaheuristics</h2>

  <p class="body">Ant colony optimization (ACO) mimics the behavior of real ant colonies by having a group of “artificial ants” search for the best solution to a problem. These artificial ants leave “pheromone trails” to communicate with each other, just like real ants do, and eventually converge on the best solution. <a id="idIndexMarker013"/><a id="idIndexMarker014"/></p>

  <p class="body">To simulate the behavior of ants, let’s assume we have a nest and a food source connected through two paths with different lengths <i class="timesitalic">L<sub class="fm-subscript">1</sub></i> and <i class="timesitalic">L<sub class="fm-subscript">2</sub></i>, as in the case of the bridges with non-equal lengths. Let’s now assign a computational parameter <i class="timesitalic">τ</i> to represent the pheromone deposited by the ants. We’ll initially assign equal values of pheromones to each path: <i class="timesitalic">τ<sub class="fm-subscript">1</sub></i> = <i class="timesitalic">τ<sub class="fm-subscript">2</sub></i> as shown in figure 10.3. We then start by placing <i class="timesitalic">m</i> ants at the nest. Let’s assume that these artificial ants exactly mimic the real ants and take decisions based on the pheromone concentration, but without any knowledge of the lengths of the paths. For each ant <i class="timesitalic">k</i>, this ant traverses path 1 with probability</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F02_Khamis-EQ01.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.1</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-367"/>This ant thus traverses path 2 with a probability <span class="times"><i class="fm-italics">p</i><sub class="fm-subscript">2</sub> = 1 – <i class="fm-italics">p</i><sub class="fm-subscript">1</sub></span>.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F03_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.3 ACO simulation</p>
  </div>

  <p class="body">As <span class="times"><i class="fm-italics">τ<sub class="fm-subscript">1</sub></i> = <i class="fm-italics">τ<sub class="fm-subscript">2</sub></i></span>, the ant <i class="timesitalic">k</i> will randomly pick one of the two paths, as both have same probability to of being traversed. After traversing the selected paths, pheromone concentration on each path needs to be updated. This pheromone update includes two phases: evaporation and deposit. During the evaporation phase, the pheromone concentration <span class="cambria">τ</span> is decremented as follows:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F03_Khamis-EQ02.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.2</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where <span class="cambria">ρ</span> specifies the rate of evaporation. Figure 10.4 shows the effect of the pheromone evaporation rate during the foraging process based on a NetLogo simulation. NetLogo is a multi-agent programmable modeling environment used to simulate natural and social phenomena. It allows users to create, experiment with, and analyze simulations of complex systems, such as ecosystems, economies, and social networks. The foraging behavior of ants is shown in NetLogo’s Ants model (<a class="url" href="https://ccl.northwestern.edu/netlogo/models/Ants">https://ccl.northwestern.edu/netlogo/models/Ants</a>).<a id="idIndexMarker015"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F04_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.4 Effect of evaporation rate during the food foraging process. In the simulation, the ants initiate their search for food from the central nest, which is surrounded by three food sources shown as blobs. The pheromone trails are shown in white. Upon discovering a food item, an ant transports it back to the nest, leaving behind a chemical trail. This trail is then followed by other ants that pick up the scent, directing them toward the food source. As more ants continue to retrieve food, they strengthen the chemical trail.</p>
  </div>

  <p class="body"><a id="marker-368"/>As you can see, if the evaporation rate is set to 0, the pheromone trail will never evaporate, and the ants will follow the same path repeatedly. This will cause the ants to become trapped in a local optimum, and they will not be able to explore other paths or find a better solution. On the other hand, if the evaporation rate is set to 1, the pheromone trail will evaporate at the maximum rate, which means the ants will not be able to follow any trail, and they will be forced to explore the environment randomly. This can result in slow convergence to the optimal solution.</p>

  <p class="body">During the deposit phase, each ant leaves more pheromones on its traversed path. Figure 10.5 shows the different methods used for pheromone updates:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Online step-by-step pheromone update</i>—Each ant deposits a certain amount of pheromones on the path it has traversed. This will increase the probability of another ant choosing the same edge:</p>
    </li>
  </ul>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F04_Khamis-EQ03.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.3</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-ind">There are different approaches for choosing the value of <span class="times">Δ<i class="fm-italics">τ</i></span>. Following the <i class="fm-italics">ant density model</i>, the ant adds a constant amount <i class="timesitalic">Q</i> to each traversed edge. This means that the final pheromone added to the edge will be proportional to the number of ants choosing it. The higher the density of the traffic on the edge, the more desirable that edge becomes as a component of the final solution. This method does not take the quality of the solution (i.e., the edge length) into account. In the <i class="fm-italics">ant quantity model</i>, the amount of pheromones deposited is proportional to the quality of the solution obtained by the ant. For example, an ant traversing between node <i class="timesitalic">i</i> and <i class="timesitalic">j</i> will deposit a quantity <span class="times"><i class="fm-italics">Q</i>/<i class="fm-italics">d<sub class="fm-subscript">ij</sub></i></span>, where <i class="timesitalic">d<sub class="fm-subscript">ij</sub></i> is the distance between <i class="timesitalic">i</i> and <i class="timesitalic">j</i>. In this case, only local information, <i class="timesitalic">d<sub class="fm-subscript">ij</sub></i>, is used to update pheromone concentrations. Lower cost edges are made more desirable.<a id="idIndexMarker016"/><a id="idIndexMarker017"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Online delayed pheromone update (or ant cycle model)</i>–Once the ant constructs the solution, it retraces its steps and updates the pheromones trails on the edges it has traversed based on the quality of the solution. The amount of pheromones deposited is determined by the quality of the solution obtained by the ant as follows:<a id="idIndexMarker018"/><a id="idIndexMarker019"/></p>
    </li>
  </ul>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F04_Khamis-EQ04.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.4</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-ind">where <i class="fm-italics">Q</i> is a constant and <i class="timesitalic">L<sup class="fm-superscript">k</sup></i> is the length of the path constructed by ant <i class="timesitalic">k</i>. For each edge (<span class="times"><i class="timesitalic">i</i>,<i class="fm-italics">j</i></span>) of the corresponding path, and after all the ants have completed their tours, the total amount of pheromones deposited will be</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F04_Khamis-EQ05.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.5</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-ind">where <i class="timesitalic">m</i> is the number of ants.</p>

  <div class="figure">
    <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F05_Khamis.png"/></p>

    <p class="figurecaptiond">Figure 10.5 Pheromone update methods</p>
  </div>

  <p class="body"><a id="marker-369"/>In summary, with online step-by-step pheromone update, the ant updates the pheromone trail <i class="timesitalic">τ<sub class="fm-subscript">ij</sub></i> on the edge (<span class="times"><i class="timesitalic">i</i>,<i class="fm-italics">j</i></span>) when moving from node <i class="timesitalic">i</i> to node <i class="timesitalic">j</i>. In online delayed pheromone update, once a path is constructed, the ant can retrace the same path backward and update the pheromone trails on the traversed edges. Which method you choose depends on the specific problem being solved. Any combination of online step-by-step pheromone updates and online delayed pheromone updates is also possible.<a id="idIndexMarker020"/><a id="idIndexMarker021"/></p>

  <h2 class="fm-head" id="heading_id_5">10.3 ACO variants</h2>

  <p class="body">ACO has been used to solve a wide range of optimization problems, such as vehicle routing problems, scheduling problems, and optimal assignment problems. Over the years, several variants of the algorithm have been developed, as shown in figure 10.6.<a id="idIndexMarker022"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F06_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.6 Examples of ACO variants</p>
  </div>

  <p class="body">These variants have different strengths and weaknesses, and the choice of variant depends on the specific problem being solved. In the following subsections, we will discuss some of these variants.</p>

  <h3 class="fm-head1" id="heading_id_6">10.3.1 Simple ACO</h3>

  <p class="body"><a id="marker-370"/>Simple ACO (SACO) is an algorithmic implementation of the double bridge experiment. Consider the problem of finding the shortest path between two nodes on a graph, as shown in figure 10.7.<a id="idIndexMarker023"/><a id="idIndexMarker024"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F07_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.7 Shortest path problem</p>
  </div>

  <p class="body">Let’s solve this problem using SACO. On each edge, we’ll assign a small random value to indicate the initial pheromone concentration, <span class="times"><i class="fm-italics">τ<sub class="fm-subscript">ij</sub></i>(0)</span>. Then we’ll place a number of ants, <span class="times"><i class="fm-italics">k</i> = 1,…,<i class="fm-italics">m</i></span> on the source node.</p>

  <p class="body">For each iteration of SACO, each ant will incrementally construct a path (solution) to the destination node. Initially, an ant will randomly select which edge to follow next. Later, each ant will execute a decision policy to determine the next edge of the path. At each node <i class="timesitalic">i</i>, the ant has a choice to move to any of the <i class="timesitalic">j</i> nodes connected to it, based on the following transition probability:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F07_Khamis-EQ06.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.6</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="timesitalic">N<sub class="fm-subscript">i</sub><sup class="fm-superscript">k</sup></i> is the set of feasible nodes connected to node <i class="timesitalic">i</i>, with respect to ant <i class="timesitalic">k</i>.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="timesitalic">τ<sub class="fm-subscript">ij</sub></i> is the amount of pheromones deposited for transition from state <i class="timesitalic">i</i> to <i class="timesitalic">j</i>.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="timesitalic">η<sub class="fm-subscript">ij</sub></i> is a heuristic value that represents the desirability of state transition <i class="timesitalic">ij</i> (a priori knowledge, typically <span class="times">1/<i class="fm-italics">d<sub class="fm-subscript">ij</sub></i></span>, where <i class="timesitalic">d</i> is the distance).</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><span class="times"><i class="fm-italics">α</i> ≥ 0</span> is a parameter that controls the influence of <i class="timesitalic">τ<sub class="fm-subscript">ij</sub></i>. <i class="timesitalic">α</i> is used to amplify the influence of the pheromone. Large values of <i class="timesitalic">α</i> give excessive importance to the pheromone, especially the initial random pheromones, which may lead to rapid convergence to suboptimal paths.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><span class="times"><i class="fm-italics">β</i> ≤ 1</span> is a parameter that controls the influence of the desirability of the edge <i class="timesitalic">η<sub class="fm-subscript">ij</sub></i>.</p>
    </li>
  </ul>

  <p class="body"><a id="marker-371"/>In the shortest path problem, assume that we use five ants, an initial pheromone value of 0.5, and <span class="times"><i class="fm-italics">α</i> = <i class="fm-italics">β</i> = 1</span>. The first ant (<span class="times"><i class="fm-italics">k</i> = 1</span>), placed at the source node, has two neighboring nodes {2,3}, as shown in figure 10.8.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F08_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.8 The first ant is at source node 1 with neighbors 2 and 3. There are two numbers on each edge separated by a colon. The first number represents the length of the edge, and the second represents the current pheromone concentration on the edge.</p>
  </div>

  <p class="body">Considering the inverse of the edge length as edge desirability, this ant needs to choose between nodes 2 and 3 by applying the transition probability as follows:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F08_Khamis-EQ07.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.7</p>
        </td>
      </tr>
    </tbody>
  </table>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F08_Khamis-EQ08.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.8</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where <span class="times"><i class="fm-italics">p</i><sub class="fm-subscript">12</sub><sup class="fm-superscript">1</sup></span> is the probability of node 2 being selected by ant 1 at node 1, and <span class="times"><i class="fm-italics">p</i><sub class="fm-subscript">13</sub><sup class="fm-superscript">1</sup></span> is the probability of node 3 being selected. We then generate a random number <i class="timesitalic">r</i> between 0 and 1. If <span class="times"><i class="fm-italics">p</i><sub class="fm-subscript">13</sub><sup class="fm-superscript">1</sup> ≥ <i class="fm-italics">r</i></span>, we select node 3; otherwise, we select 2. As node 3 has the highest probability of being selected, it will most likely be selected.<a id="marker-372"/></p>

  <p class="body">Moving forward, the first ant is now at node 3 and needs to decide between the adjacent nodes 2 and 4 following the same transition probability, which results in <span class="times"><i class="fm-italics">p<sub class="fm-subscript">32</sub></i><sup class="fm-superscript">1</sup> = 0.29</span> and <span class="times"><i class="fm-italics">p<sub class="fm-subscript">34</sub></i><sup class="fm-superscript">1</sup> = 0.71</span>. Let’s assume that node 4 is selected. The ant is now at node 4 and needs to decide between the adjacent nodes 2 and 5 following the same transition probability, which results in <span class="times"><i class="fm-italics">p</i><sub class="fm-subscript">42</sub><sup class="fm-superscript">1</sup> = 0.6</span> and <span class="times"><i class="fm-italics">p</i><sub class="fm-subscript">45</sub><sup class="fm-superscript">1</sup> = 0.4</span>. Let’s assume that node 5 is selected, based on the generated random number. Figure 10.9 shows the path completed by the first ant in the first iteration with length <span class="times"><i class="fm-italics">L</i><sup class="fm-superscript">1</sup>(<i class="fm-italics">t</i> = 1) = 3 + 2 + 6 = 11</span>. Each ant will generate its own path following the same steps.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F09_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.9 The path constructed by the first ant. Each of the other four ants will similarly construct a path.</p>
  </div>

  <p class="body">Before starting a new iteration, the pheromones need to be updated. Following equation 10.2 and assuming that the evaporation rate <span class="cambria">ρ</span> is 0.7, the new pheromone value will be</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F09_Khamis-EQ09.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.9</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Pheromones are also deposited. If the first ant <span class="times"><i class="fm-italics">k</i> = 1</span> is selected to deposit pheromones based on the costs of the paths found by each ant, it enforces the edges <span class="times">{1,3), {3,4}</span>, and <span class="times">{4,5}</span> with the value <span class="times"><i class="fm-italics">Q</i>/<i class="fm-italics">L</i><sup class="fm-superscript">1</sup> = 1/11</span> following the online delayed pheromone update model. Figure 10.10 shows the updated pheromone values on each edge.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F10_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.10 Updated pheromone concentrations</p>
  </div>

  <p class="body">In this simple example, over three iterations, the ants find the shortest path <span class="times">1 → 3 → 4 → 5</span>. In the following sections, we’ll discuss the ant system (AS) algorithm, ant colony system (ACS) algorithm, and max–min ant system (MMAS) algorithm as ACO variants proposed to deal with SACO limitations.</p>

  <h3 class="fm-head1" id="heading_id_7">10.3.2 Ant system</h3>

  <p class="body"><a id="marker-373"/>The ant system (AS) algorithm improves on SACO by adding a memory capability via a tabu list. This list, or ant memory, identifies the already-visited nodes. The transition probability used in AS is the same as in equation 10.6. As an ant visits a new node, that node is added to the ant’s tabu list for a predefined number of iterations. And as in SACO, after an ant completes a path, the pheromone on each edge is updated. The ant density, ant quantity, and ant cycle models can be used to update the pheromones. As previously explained, in the ant density and ant quantity models, ants deposit pheromones while building, whereas in the ant cycle model, ants deposit pheromones after they have built a complete path.<a id="idIndexMarker025"/></p>

  <h3 class="fm-head1" id="heading_id_8">10.3.3 Ant colony system</h3>

  <p class="body">The ant colony system (ACS) algorithm is an extension of the AS algorithm with a modified transition rule that utilizes an elitist strategy. This strategy, known as the <i class="fm-italics">pseudo-random proportional action rule</i>, is designed to improve the efficiency and effectiveness of the algorithm. The pseudo-random proportional action rule used in ACS is based on the idea that the best solutions found by the ants should be given more weight in the decision-making process. In ACS, a random number <i class="timesitalic">r</i> is generated, and the parameter <span class="times"><i class="fm-italics">r</i><sub class="fm-subscript">o</sub> <span class="cambria">∈</span></span> [0,1] is predefined. An ant <i class="timesitalic">k</i>, located at node <i class="timesitalic">i</i>, selects the next node <i class="timesitalic">j</i> to move to using the following decision rule with a double function:<a id="idIndexMarker026"/><a id="idIndexMarker027"/><a id="idIndexMarker028"/><a id="idIndexMarker029"/><a id="marker-374"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">If <span class="times"><i class="fm-italics">r</i> ≤ <i class="fm-italics">r<sub class="fm-subscript">o</sub></i></span>, the ant selects node <i class="timesitalic">j</i></p>
    </li>
  </ul>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F10_Khamis-EQ10.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.10</p>
        </td>
      </tr>
    </tbody>
  </table>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">Else, a node is probabilistically selected (using a roulette wheel method, for example, which you learned about in chapter 7) according to the following transition probability:</p>
    </li>
  </ul>

  <div class="figure">
    <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F10_Khamis-EQ11.png"/></p>
  </div>

  <p class="body">Notice that compared to the transition probability of SACO (equation 10.6), the parameter that controls the influence of the pheromone concentration is <span class="times"><i class="fm-italics">α</i> = 1</span> in ACS. The parameter <i class="timesitalic">r<sub class="fm-subscript">0</sub></i> is used to balance the exploration–exploitation trade-off. When <span class="times"><i class="fm-italics">r</i> ≤ <i class="fm-italics">r</i><sub class="fm-subscript">0</sub></span>, the decision rule exploits the knowledge available about the problem by favoring the best edge, and when <span class="times"><i class="fm-italics">r</i> &gt; <i class="fm-italics">r</i><sub class="fm-subscript">0</sub></span>, the algorithm explores. Properly tuning <i class="timesitalic">r<sub class="fm-subscript">0</sub></i> allows us to strike a balance between exploration and exploitation.</p>

  <p class="body">In the previous shortest path example, assume that the ant is at node 4 and needs to choose node 2 or 5 following the ACS decision rule (figure 10.11). Let’s assume that we have the values <span class="times"><i class="fm-italics">r<sub class="fm-subscript">o</sub></i> = 0.5</span>, <span class="times"><i class="fm-italics">β</i> = 1</span>, and <span class="times"><i class="fm-italics">η<sub class="fm-subscript">ij</sub></i> = 1 / <i class="fm-italics">d<sub class="fm-subscript">ij</sub></i></span>. Let’s now generate a random number <i class="timesitalic">r</i>.</p>

  <p class="body">If <span class="times"><i class="fm-italics">r</i> ≤ <i class="fm-italics">r<sub class="fm-subscript">o</sub></i></span>, the ant will select node</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F10_Khamis-EQ12.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.11</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">If <span class="times"><i class="fm-italics">r</i> &gt; <i class="fm-italics">r<sub class="fm-subscript">o</sub></i></span>, the ant will select a node with maximum transition probability: <span class="times"><i class="fm-italics">p</i><sub class="fm-subscript">45</sub><sup class="fm-superscript">1</sup> = 0.6</span> and <span class="times"><i class="fm-italics">p</i><sub class="fm-subscript">42</sub><sup class="fm-superscript">1</sup> = 0.4</span> as calculated before in section 10.3.1 with <span class="times"><i class="fm-italics">α</i> = 1</span>. Using the roulette wheel method, node 2 or node 5 may be selected.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F11_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.11 The ant at node 4 selects the next node (2 or 5) following the ACS elitist strategy.</p>
  </div>

  <p class="body">Unlike in AS, the pheromone reinforcement process in ACS is exclusively performed by the ant with the global-best solution, which corresponds to the best path found so far. However, relying solely on the global-best solution to dictate pheromone deposition may cause the search to converge too rapidly around the global-best solution to date, hindering exploration of other potentially better solutions. The max–min ant system (MMAS) algorithm was developed to address this issue.<a id="idIndexMarker030"/></p>

  <h3 class="fm-head1" id="heading_id_9">10.3.4 Max–min ant system</h3>

  <p class="body"><a id="marker-375"/>ACS can experience premature stagnation, which occurs when all ants follow the same path and little exploration is done. This issue is especially prevalent in complex problems, where the search space is large and the optimal solution is difficult to find. To overcome this problem, the max–min ant system (MMAS) was proposed.<a id="idIndexMarker031"/><a id="idIndexMarker032"/><a id="idIndexMarker033"/></p>

  <p class="body">MMAS employs the iteration-best path instead of the global-best path for pheromone updates. Pheromone trails are only updated using the online delayed pheromone update model, where the edges that were traversed by the best ant in the current iteration receive additional pheromones. Since the best paths can vary significantly between iterations, this approach promotes a higher degree of exploration throughout the search space compared to ACS. Hybrid strategies can also be implemented, in which the iteration-best path is primarily utilized to encourage exploration, while the global-best path is incorporated periodically.</p>

  <p class="body">In MMAS, the pheromone concentrations are constrained within an upper bound (<i class="timesitalic">τ<sub class="fm-subscript">max</sub></i>) and lower bound (<i class="timesitalic">τ<sub class="fm-subscript">min</sub></i>), ensuring that the search remains focused yet flexible. The pheromone trails are initialized to their maximum value <i class="timesitalic">τ<sub class="fm-subscript">max</sub></i>, and if the algorithm reaches a stagnation point, all pheromone concentrations are reset to the maximum value. Following this reset, the iteration-best path is exclusively used for a limited number of iterations. The values for <i class="timesitalic">τ<sub class="fm-subscript">min</sub></i> and <i class="timesitalic">τ<sub class="fm-subscript">max</sub></i> are typically determined through experimentation, although they could also be computed analytically if the optimal solution is known.</p>

  <h3 class="fm-head1" id="heading_id_10">10.3.5 Solving open TSP with ACO</h3>

  <p class="body"><a id="marker-376"/>Let’s now implement the ACO algorithm to solve open TSP, considering the 20 major US cities. Our objective is to find the shortest route that a salesperson can follow to visit each of these 20 cities once, starting from New York City and without returning to the home city.<a id="idIndexMarker034"/><a id="idIndexMarker035"/><a id="idIndexMarker036"/></p>

  <p class="body">We’ll start by defining a <code class="fm-code-in-text">cities</code> dictionary that contains the names of the 20 US cities and their latitude and longitude coordinates. We’ll then use a nested loop to calculate the distance between each pair of cities using the <code class="fm-code-in-text">haversine</code> distance formula, storing the results in the <code class="fm-code-in-text">distance_matrix</code> dictionary. The <code class="fm-code-in-text">haversine</code> distance is used because it takes into account the earth’s curvature, providing accurate distance measurements between two points on the earth’s surface (see the “Haversine distance” sidebar in section 4.3.3 for more details). The <code class="fm-code-in-text">cost_function</code> is defined to calculate the total distance of a path. It takes a list of city indices (<code class="fm-code-in-text">path</code>) and a distance matrix (<code class="fm-code-in-text">distances</code>) as input arguments. The function then iterates through the path, summing the distance between each consecutive pair of cities. The total path distance is then returned. This code is shown in the next listing.<a id="idIndexMarker037"/><a id="idIndexMarker038"/><a id="idIndexMarker039"/><a id="idIndexMarker040"/></p>

  <p class="fm-code-listing-caption">Listing 10.1 Solving shortest path problem using ACO</p>
  <pre class="programlisting">import numpy as np
import pandas as pd
from collections import defaultdict
from haversine import haversine
import networkx as nx
import matplotlib.pyplot as plt
import random
from tqdm import tqdm
  
cities = {
    'New York City': (40.72, -74.00),
    'Philadelphia': (39.95, -75.17),       
    'Baltimore': (39.28, -76.62),
    'Charlotte': (35.23, -80.85),
    'Memphis': (35.12, -89.97),
    'Jacksonville': (30.32, -81.70),
    'Houston': (29.77, -95.38),
    'Austin': (30.27, -97.77),
    'San Antonio': (29.53, -98.47),
    'Fort Worth': (32.75, -97.33),
    'Dallas': (32.78, -96.80),
    'San Diego': (32.78, -117.15),
    'Los Angeles': (34.05, -118.25),
    'San Jose': (37.30, -121.87),
    'San Francisco': (37.78, -122.42),    
    'Indianapolis': (39.78, -86.15),
    'Phoenix': (33.45, -112.07),       
    'Columbus': (39.98, -82.98), 
    'Chicago': (41.88, -87.63),
    'Detroit': (42.33, -83.05)
}                                                                        <span class="fm-combinumeral">①</span>
  
distance_matrix = defaultdict(dict)                                      <span class="fm-combinumeral">②</span>
for ka, va in cities.items():                                            <span class="fm-combinumeral">②</span>
    for kb, vb in cities.items():                                        <span class="fm-combinumeral">②</span>
        distance_matrix[ka][kb] = 0.0 if kb == ka else haversine((va[0], <span class="fm-combinumeral">②</span>
<span class="fm-code-continuation-arrow">➥</span>  va[1]), (vb[0], vb[1]))                                              <span class="fm-combinumeral">②</span>
                                                                         <span class="fm-combinumeral">②</span>
distances = pd.DataFrame(distance_matrix)                                <span class="fm-combinumeral">③</span>
city_names=list(distances.columns)                                       <span class="fm-combinumeral">④</span>
city_indices = {city: idx for idx, city in enumerate(city_names)}
city_count = len(city_names)
  
def cost_function(path):                                                 <span class="fm-combinumeral">⑤</span>
    distance = 0
    for i in range(len(path) - 1):
        city1, city2 = city_names[path[i]], city_names[path[i + 1]]
        distance += haversine(cities[city1], cities[city2])
    return distance</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define latitude and longitude for 20 major US cities.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Create a haversine distance matrix based on latitude and longitude coordinates.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Inter-city values</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> City names</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Define the cost function that represents the path length.</p>

  <p class="body"><a id="marker-377"/>As a continuation of listing 10.1, the next code snippet presents a function called <code class="fm-code-in-text">ant_tour</code> that takes two arguments: <code class="fm-code-in-text">pheromones</code>, representing the pheromone levels between cities, and <code class="fm-code-in-text">distances</code>, representing the distances between cities. It initializes a <code class="fm-code-in-text">paths</code> array to store paths for each ant, and it iterates over each ant in the specified range of ants. For each ant, it initializes a path starting from New York City. It enters a <code class="fm-code-in-text">while</code> loop that continues until all cities are visited. Within the <code class="fm-code-in-text">while</code> loop, it selects the current city as the last city in the path. It then calculates the probabilities for choosing the next city based on the pheromone levels and the inverse of the distances between the current city and unvisited cities. The probabilities are calculated using equation 10.6. The next city is chosen using the <code class="fm-code-in-text">random.choices</code> function, based on the normalized probabilities. The chosen next city is removed from the list of unvisited cities, and it is appended to the path:<a id="idIndexMarker041"/><a id="idIndexMarker042"/></p>
  <pre class="programlisting">def ant_tour(pheromones): 
    paths = np.empty((ants, city_count), dtype=int)                <span class="fm-combinumeral">①</span>
    for ant in range(ants):
        path = [city_indices['New York City']]                     <span class="fm-combinumeral">②</span>
        unvisited_cities = set(range(city_count))                  <span class="fm-combinumeral">③</span>
        unvisited_cities.remove(path[0])                           <span class="fm-combinumeral">④</span>
  
        while unvisited_cities:                                    <span class="fm-combinumeral">⑤</span>
            current_city = path[-1]
            probabilities = []
  
            for city in unvisited_cities:                          <span class="fm-combinumeral">⑥</span>
                tau = pheromones[current_city, city] 
                eta = (1 / distances[current_city, city])
                probabilities.append((tau** alpha)*(eta ** beta))
  
            probabilities /= sum(probabilities)                    <span class="fm-combinumeral">⑦</span>
            next_city = np.random.choice(list(unvisited_cities),   <span class="fm-combinumeral">⑧</span>
p=probabilities) 
            unvisited_cities.remove(next_city)                     <span class="fm-combinumeral">⑨</span>
            unvisited_cities.remove(next_city)                     <span class="fm-combinumeral">⑩</span>
            path.append(next_city)                                 <span class="fm-combinumeral">⑪</span>
  
        paths[ant] = path
    
    return paths</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Initialize an array to store paths for each ant.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Start each ant's path from New York City.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Initialize a set of unvisited cities.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Remove New York City from unvisited cities.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Continue building the path until all cities are visited.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Calculate the probabilities for moving to each unvisited city.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Normalize the probabilities.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Choose the next city based on probabilities.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑨</span> Remove the chosen city from the set of unvisited cities.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑩</span> Add the chosen city to the path.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑪</span> Store the completed path for the current ant.</p>

  <p class="body"><a id="marker-378"/>Once all the cities have been visited, the path for the current ant is stored in the <code class="fm-code-in-text">paths</code> array. After all the ants have completed their paths, the function returns the <code class="fm-code-in-text">paths</code> array containing the optimal tours found by each ant.<a id="idIndexMarker043"/></p>

  <p class="body">The following <code class="fm-code-in-text">update_pheromones</code> function is used to update the pheromone levels based on the distances and paths of the ants: <a id="idIndexMarker044"/></p>
  <pre class="programlisting">def update_pheromones(paths, pheromones):
    delta_pheromones = np.zeros_like(pheromones)                    <span class="fm-combinumeral">①</span>
  
    for i in range(ants):                                           <span class="fm-combinumeral">②</span>
        for j in range(city_count - 1):
            city1_idx, city2_idx = paths[i, j], paths[i, j + 1]     <span class="fm-combinumeral">③</span>
            delta_pheromones[city1_idx, city2_idx] += Q / cost_     <span class="fm-combinumeral">④</span>
function(paths[i]) 
  
    return (1 - evaporation_rate) * pheromones + delta_pheromones   <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Initialize a matrix to store the changes in pheromone levels.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Update pheromones based on the paths taken by the ants.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Get the indices of the cities in the current path.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Update the pheromone level between the current and next city.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Evaporate existing pheromones, add the changes in pheromones, and return the updated pheromones.</p>

  <p class="body">This function takes two arguments: <code class="fm-code-in-text">paths</code>, representing the paths taken by ants, and <code class="fm-code-in-text">pheromones</code>, representing the current pheromone levels on edges between cities. It initializes a matrix <code class="fm-code-in-text">delta_pheromones</code> to store the changes in pheromone levels. This matrix has the same shape as the <code class="fm-code-in-text">pheromones</code> matrix. It iterates over each ant in the specified range of ants. Within the loop, it iterates over each city in the ant's path (except the last city). For each pair of consecutive cities, it updates the <code class="fm-code-in-text">delta_pheromones</code> matrix by adding a value based on the inverse of the cost of the ant's path. After the inner loop, it calculates the updated pheromones by combining the existing pheromones, considering evaporation, and adding the changes stored in <code class="fm-code-in-text">delta_pheromones</code>. Finally, it returns the matrix of updated pheromones. <a id="idIndexMarker045"/></p>

  <p class="body">As a continuation, the following code snippet shows the <code class="fm-code-in-text">run_ACO</code> function, which takes the following inputs:<a id="idIndexMarker046"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">distances</code>—A 2D array (matrix) that stores the distances between cities</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">ants</code>—The number of ants to use in the algorithm</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">iterations</code>—The number of iterations</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">alpha</code>—A parameter that controls the influence of the pheromone trail on the ant’s decision</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">beta</code>—A parameter that controls the influence of the distance to the next city on the ant’s decision</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">evaporation_rate</code>—The rate at which pheromones evaporate from the paths</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">Q</code>—A constant used in the calculation of the amount of pheromones deposited by the ants</p>
    </li>
  </ul>

  <p class="body"><a id="marker-379"/>This function returns the <code class="fm-code-in-text">best_path</code> and <code class="fm-code-in-text">best_distance</code>, representing the optimal solution found by the ACO algorithm:</p>
  <pre class="programlisting">def run_ACO(distances, ants, iterations, alpha, beta, evaporation_rate, Q):
    pheromones = np.ones((city_count, city_count))                          <span class="fm-combinumeral">①</span>
    best_path = None
    best_distance = float('inf')
  
    for _ in tqdm(range(iterations), desc="Running ACO", unit="iteration"):
        paths =ant_tour(pheromones, distances)                              <span class="fm-combinumeral">②</span>
  
        distances_paths = np.array([cost_function(path) for path in paths]) <span class="fm-combinumeral">③</span>
        min_idx = distances_paths.argmin()
        min_distance = distances_paths[min_idx]
  
        if min_distance &lt; best_distance:                                    <span class="fm-combinumeral">④</span>
            best_distance = min_distance
            best_path = paths[min_idx]
 
        pheromones = update_pheromones(paths, pheromones)                   <span class="fm-combinumeral">⑤</span>
  
    return best_path, best_distance                                         <span class="fm-combinumeral">⑥</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Initialize the pheromones array.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Generate paths for each ant.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Calculate the total distance for each path.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Find the index of the path with the minimum distance.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Update the pheromones.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Return the best path and distance found during the iterations.</p>

  <p class="body">Let’s now apply ACO to solve the shortest path problem using the following parameters:</p>
  <pre class="programlisting">ants = 30                        <span class="fm-combinumeral">①</span>
iterations = 100                 <span class="fm-combinumeral">①</span>
alpha = 1                        <span class="fm-combinumeral">①</span>
beta = 0.9                       <span class="fm-combinumeral">①</span>
evaporation_rate = 0.5           <span class="fm-combinumeral">①</span>
Q = 100                          <span class="fm-combinumeral">①</span>
  
best_path, best_distance = run_ACO(distances.values, ants, iterations, alpha, beta,
<span class="fm-code-continuation-arrow">➥</span> evaporation_rate, Q)          <span class="fm-combinumeral">②</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Set ACO parameters.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Run ACO with the defined parameters.</p>

  <p class="body">Given the randomness included in the algorithm, your solution may vary. The following path is what was generated when I ran the solver:</p>
  <pre class="programlisting">Route: New York City → Philadelphia → Baltimore → Detroit → Chicago → Indianapolis → Columbus → Charlotte → Jacksonville → Memphis → Fort Worth → Dallas → Houston → Austin → San Antonio → Phoenix → San Diego → Los Angeles → San Jose → San Francisco
Route length: 7937.115</pre>

  <p class="body">The preceding path is shown in figure 10.12. The complete version of listing 10.1 is available in the book’s GitHub repo, which also contains the code to generate this visualization.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F12_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.12 Shortest path obtained by ACO</p>
  </div>

  <p class="body"><a id="marker-380"/>Unlike genetic algorithms and particle swarm optimization algorithms, there are no well-developed and comprehensive Python packages for ACO metaheuristics. The ACOpy project (https://acopy.readthedocs.io/en/latest/index.html) provides an implementation of ACO and can be installed using pip as follows: <code class="fm-code-in-text">pip install acopy</code>. As a continuation of listing 10.1, let’s use ACOpy to solve the shortest path problem.</p>

  <p class="body">We’ll start by importing the <code class="fm-code-in-text">acopy</code> and <code class="fm-code-in-text">networkx</code> libraries. A graph, <code class="fm-code-in-text">G</code>, is created where the nodes represent cities and the edges represent the distances between them. The <code class="fm-code-in-text">distance_matrix</code> contains the distances between each pair of cities. The loops iterate over all pairs of cities, adding an edge between each pair of cities to the graph, with the weight of the edge being the distance between the cities. Self-loop edges (edges that connect a node to itself) are then removed from the graph:<a id="idIndexMarker047"/><a id="idIndexMarker048"/></p>
  <pre class="programlisting">import acopy
import networkx as nx
  
G=nx.Graph()
  
for ka, va in cities.items():
    for kb, vb in cities.items():
        G.add_weighted_edges_from({(ka,kb, distance_matrix[ka][kb])})
G.remove_edges_from(nx.selfloop_edges(G))</pre>

  <p class="body"><a id="marker-381"/>The parameters for the ACO algorithm are then defined: <code class="fm-code-in-text">evaporation_rate</code>, <code class="fm-code-in-text">iterations</code>, and <code class="fm-code-in-text">Q</code>, as explained previously. An ACO solver is created with the specified <code class="fm-code-in-text">evaporation_rate</code> and <code class="fm-code-in-text">Q</code>. The <code class="fm-code-in-text">acopy.Colony</code> object is initialized with <code class="fm-code-in-text">alpha</code> and <code class="fm-code-in-text">beta</code> parameters. The algorithm then iterates for the specified number of iterations. In each iteration, the solver’s <code class="fm-code-in-text">solve</code> method is used to find a tour whose path is a list of edges. For each edge in the path, the code determines the city that hasn’t been added to the <code class="fm-code-in-text">path_indices</code> list yet and adds it. Finally, the path of the tour is updated to be the <code class="fm-code-in-text">path_indices</code> list, which is a list of city names instead of edges:<a id="idIndexMarker049"/><a id="idIndexMarker050"/><a id="idIndexMarker051"/></p>
  <pre class="programlisting">evaporation_rate = 0.5                                                  <span class="fm-combinumeral">①</span>
iterations = 100                                                        <span class="fm-combinumeral">①</span>
Q = 100                                                                 <span class="fm-combinumeral">①</span>
  
solver = acopy.Solver(rho=evaporation_rate, q=Q)                        <span class="fm-combinumeral">②</span>
  
colony = acopy.Colony(alpha=1, beta=0.9)                                <span class="fm-combinumeral">③</span>
  
for n_iter in range(iterations):                                        <span class="fm-combinumeral">④</span>
    tour = solver.solve(G, colony, limit=4)
    path_indices = ['New York City']                                    <span class="fm-combinumeral">⑤</span>
    for edge in tour.path:
        next_city = edge[0] if edge[1] == path_indices[-1] else edge[1] <span class="fm-combinumeral">⑥</span>
        if next_city not in path_indices:                               <span class="fm-combinumeral">⑥</span>
            path_indices.append(next_city)                              <span class="fm-combinumeral">⑥</span>
  
tour.path=path_indices                                                  <span class="fm-combinumeral">⑦</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> ACO parameters</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Set up the ACO solver.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Set up the ACO colony with alpha and beta parameters.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Run the ACO algorithm.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Start with city 0 (New York City).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Add the other node from the edge that is not already in the path.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Return the ordered list of city names included in the path.</p>

  <p class="body">Let’s now print the obtained path and its length as follows:</p>
  <pre class="programlisting">best_path = tour.path
best_distance = tour.cost
Route = " → ".join(best_path)
print("Route:", Route)
print("Route length:", np.round(best_distance, 3))</pre>

  <p class="body">The <code class="fm-code-in-text">best_path</code> variable is set to the <code class="fm-code-in-text">path</code> property of the <code class="fm-code-in-text">tour</code> object obtained by the <code class="fm-code-in-text">acopy</code> solver. This path is a list of cities that represents the shortest route found. The <code class="fm-code-in-text">best_distance</code> variable is set to the <code class="fm-code-in-text">cost</code> property of the <code class="fm-code-in-text">tour</code> object, which is the total distance (or cost) of the best path. The <code class="fm-code-in-text">Route</code> variable is a string that joins all the cities in <code class="fm-code-in-text">best_path</code> with an arrow (<code class="fm-code-in-text">→</code>) in between, representing the sequence of cities to visit in the optimal tour. Finally, the <code class="fm-code-in-text">print</code> statements display the best route and its total distance. A path like the following will be generated after running the solver:<a id="idIndexMarker052"/><a id="idIndexMarker053"/><a id="idIndexMarker054"/><a id="idIndexMarker055"/><a id="idIndexMarker056"/><a id="idIndexMarker057"/></p>
  <pre class="programlisting">Route: New York City → Columbus → Detroit → Philadelphia → Baltimore → Charlotte → Jacksonville → Memphis → Houston → Dallas → Fort Worth → Austin → San Antonio → Phoenix → San Diego → Los Angeles → San Jose → San Francisco → Chicago → Indianapolis
Route length: 11058.541 </pre>

  <p class="body"><a id="marker-382"/>The obtained path is shown in figure 10.13. The complete version of listing 10.1 available in the book’s GitHub repo contains the code to generate this visualization.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F13_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.13 Shortest path obtained by ACOpy</p>
  </div>

  <p class="body">It’s worth mentioning that ACO, like many other stochastic optimization algorithms, contains elements of randomness. The randomness in ACO comes from two main sources:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Initial conditions</i>—At the start of the algorithm, the ants are usually placed at random positions unless the start position is predefined, such as in the case of TSP where ants start from a predetermined home city. This means that in scenarios where random positions are used, each ant starts exploring from a different city, leading to diverse paths.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Path selection</i>—As the ants move from city to city, they probabilistically choose which city to visit next. This choice is influenced by the amount of pheromones on the path to a city and the distance to the city. Even if two ants are in the same city and have the same information, they might still choose different cities to visit next due to this probabilistic choice.</p>
    </li>
  </ul>

  <p class="body">This inherent randomness means that each run of the ACO algorithm can produce different results. However, over multiple runs, ACO should consistently find near-optimal solutions, even if they are not always the exact same solution.</p>

  <p class="body">In the following section, we will delve into another fascinating algorithm that is a product of swarm intelligence. This algorithm again takes its inspiration from the natural world, specifically the food-seeking behavior of honeybees. You’ll soon understand how this bee-inspired algorithm operates and how it can be applied in a computational context.</p>

  <h2 class="fm-head" id="heading_id_11">10.4 From hive to optimization</h2>

  <p class="body">Honeybees are remarkable social insects known for their extraordinary cooperation. They build hives capable of accommodating approximately 30,000 bees, all working together harmoniously. Each bee has a designated task, such as producing wax, creating honey, making bee-bread, forming combs, or bringing water to the cells and mixing it with honey. Young bees typically handle tasks outside the hive, while elder bees focus on indoor duties.<a id="idIndexMarker058"/><a id="idIndexMarker059"/><a id="marker-383"/></p>

  <p class="body">Honeybee colonies operate as goal-oriented decision-making systems, with their functions directed by the decentralized control and actions of individual bees. The cooperation between honeybees during the foraging process leads to advantageous behaviors that optimize the hive’s overall fitness. By using individual foragers, honeybee colonies aim to minimize the cost/benefit ratio, rather than expending energy searching in all directions indiscriminately. They concentrate their foraging efforts on the most rewarding patches, while disregarding those of lesser quality.</p>

  <p class="body">Observations have shown that when colony food resources are scarce, foragers exhibit increased recruitment behaviors, characterized by changes in their dance patterns upon returning to the hive. This enhanced recruitment serves to mobilize more nestmates to exploit available food sources. In addition to foraging, honeybees also cooperate in various other tasks, such as hive construction, hive thermoregulation, and colony defense, showcasing their exceptional teamwork skills.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Discover the fascinating world of honeybees</p>

    <ul class="calibre5">
      <li class="fm-list-bullet2">
        <p class="list-s">Honeybees are the most well-known and important insects that produce food consumed by humans.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Honeybee colonies consist of a single queen, hundreds of male drones, and 20,000 to 80,000 female worker bees.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">A single worker bee may visit 50 to 1,000 flowers per day. Bees from the same hive can visit up to 225,000 flowers in one day. Honeybees can fly at speeds of 21 to 28 km/h (13–17 mph) and can have a foraging area up to 70 km<sup class="fm-superscript">2</sup> (27 mi<sup class="fm-superscript">2</sup>).</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Honeybees can maintain a constant temperature of about 33°C (91°F) in their hive, regardless of the outside temperature.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Honeybees choose the hexagonal shape for their honeycomb cells to hold the queen bee’s eggs and store the pollen and honey the worker bees bring to the hive.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">The hexagonal structure has several advantages, such as efficient use of space (creating the maximum number of cells that can be built in a given area), structural strength (it’s strong and stable), material efficiency (it uses less beeswax), and optimal angle (a slight tilt, ~13 degrees from horizontal, to prevent honey from spilling out of the cells while still allowing bees to move around easily).</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Honeybees communicate with each other through complex dance moves called “waggle dances,” explained in “The Waggle Dance of the Honeybee,” a video from Georgia Tech College of Computing (<a class="url" href="http://mng.bz/gvxx">http://mng.bz/gvxx</a>).</p>
      </li>
    </ul>
  </div>

  <p class="body"><a id="marker-384"/>The artificial bee colony (ABC) algorithm is a swarm intelligence algorithm based on the foraging behavior of honeybees. Specifically, it is inspired by the way honeybees search for food sources and communicate their findings to optimize the gathering of resources. Let’s first look at how honeybees forage for food. Figure 10.14 illustrates the steps of their foraging behavior. <a id="idIndexMarker060"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F14_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.14 Foraging behavior of honeybees</p>
  </div>

  <p class="body">The foraging behavior can be summarized in the following steps:</p>

  <ol class="calibre7">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Initialization</i>—Forager bees (employed bees) and scout bees begin their foraging for food sources. Forager bees usually gather resources from known sources around the hive to meet the colony’s immediate needs. Scout bees locate new food sources to ensure the colony’s long-term survival, especially if the food sources around the hive start to deplete. Scout bees only represent a small percentage of colony members, but they save the colony many wasted miles of flight trying to locate abundant new food sources. It is worth noting that forager bees and scout bees are both worker bees (female bees). A worker bee can switch roles from being a forager to a scout, depending on the colony’s needs and food source availability. In summary, forager bees concentrate on exploiting the available resources while scout bees focus on exploring to discover new resources.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Exploration</i>—Forager bees leave the hive and start searching for food sources, such as flowers with nectar and pollen, in the surrounding area. Scout bees explore areas farther away to discover new food sources.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Detection</i>—When a suitable food source is found, the worker bee lands on the flower and begins to collect nectar in her honey stomach or gathers pollen on her hind legs.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Memorization</i>—The bee takes note of the food source’s location, including its distance and direction from the hive, as well as the flower type and quality.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Return to the hive</i>—Once the worker bee has collected enough resources or her honey stomach is full, she flies back to the hive. Upon reaching the hive, the forager bee transfers the nectar to a house bee, who then processes and stores it as honey. Pollen is similarly offloaded to other bees for storage and later use as food.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Communication</i>—The worker bee performs a waggle dance on the hive’s dance floor to share the location information with her nestmates (aka <i class="fm-italics">onlooker bees</i>). The dance communicates the direction, distance, and quality of the food source.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Recruitment</i>—Onlooker bees observe the waggle dance and decode the information about the food source’s location. These bees then fly out to collect the resources.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Repeat</i>—The worker bee continues to visit the same food source until it is depleted or another bee recruits her to a more promising source. In either case, she repeats the foraging process to ensure the colony’s needs are met.</p>
    </li>
  </ol>

  <p class="body"><a id="marker-385"/>Now let’s look at the ABC algorithm in more detail.<a id="idIndexMarker061"/><a id="idIndexMarker062"/></p>

  <h2 class="fm-head" id="heading_id_12">10.5 Exploring the artificial bee colony algorithm</h2>

  <p class="body">The artificial bee colony (ABC) algorithm, proposed by Dervis Karaboga in 2005 [1], simulates the roles of three types of bees: employed bees (foragers), onlooker bees, and scout bees. Algorithm 10.1 shows the steps of the ABC algorithm.<a id="idIndexMarker063"/><a id="idIndexMarker064"/><a id="idIndexMarker065"/></p>

  <p class="fm-code-listing-caption">Algorithm 10.1 Artificial bee colony algorithm</p>
  <pre class="programlisting">Initialization Phase: population of candidate solutions (food sources) are initialized 
REPEAT
   Forager Bee Phase: Each forager bee goes to a food source in her memory and determines a closest source, then evaluates its nectar amount and dances in the hive
   Onlooker Bee Phase: Each onlooker bee watches the dance of forager bees and chooses one of their sources depending on the dances, and then goes to that source. After choosing a neighbor around that, she evaluates its nectar amount.
   Scout Bee Phase: Abandoned food sources are determined and are replaced with the new food sources discovered by scout bees.
   Memorize the best food source (solution) achieved so far.
UNTIL (termination criteria are met)</pre>

  <p class="body">As you can see, the ABC algorithm simulates the honeybee foraging behaviors to explore and exploit the search space, balancing global exploration (diversity) and local exploitation (convergence) to efficiently solve optimization problems. In the ABC algorithm, the three types of bees have the following complementary roles:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Employed bees (foragers)—</i>These bees exploit the current food sources, meaning they search around their current position (searching the neighborhood) to find better solutions. These bees perform a local search (intensification), which refines the current best solutions.<a id="idIndexMarker066"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Onlooker bees</i>—These bees also contribute to exploitation. They probabilistically choose food sources depending on the fitness of the solutions found by the employed bees. They are more likely to choose better solutions (food sources with more nectar) for further exploitation.<a id="idIndexMarker067"/><a id="marker-386"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Scout bees</i>—These bees perform the exploration. If a food source is exhausted (if the solution cannot be improved after a certain number of iterations), the employed bee associated with that food source becomes a scout bee. Scout bees perform a global search (diversification) by abandoning the exhausted food source and randomly searching for new food sources in the problem space. This process prevents the algorithm from getting stuck in local optima by exploring new regions of the search space.<a id="idIndexMarker068"/></p>
    </li>
  </ul>

  <p class="body">In the ABC algorithm, communication between the bees is simulated by sharing the fitness values of solutions among employed and onlooker bees, guiding them toward better solutions. The ABC algorithm adopts a fitness-proportionate selection process inspired by how bees choose food sources based on their quality. In the algorithm, employed bees and onlooker bees select solutions with a probability proportional to their fitness, prom<a id="idTextAnchor002"/>oting better solutions to be explored more frequently.</p>

  <p class="body">To understand how we can use ABC to solve optimization problems, let’s consider minimizing the Rosenbrock function using ABC. The Rosenbrock function, also referred to as the <i class="fm-italics">valley</i> or <i class="fm-italics">banana function</i>, is a popular test problem for gradient-based optimization algorithms. This function has <i class="timesitalic">n</i> dimensions and takes the following general form:<a id="idIndexMarker069"/><a id="idIndexMarker070"/></p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F14_Khamis-EQ13.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.12</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">The function is usually evaluated on the hypercube <span class="times">x<i class="fm-italics"><sub class="fm-subscript">i</sub></i> <span class="cambria">∈</span> [–5, 10]</span> for all <span class="times"><i class="fm-italics">i</i> = 1,...,<i class="fm-italics">n</i></span>, but the domain may be restricted to <span class="times">x<i class="fm-italics"><sub class="fm-subscript">i</sub></i> <span class="cambria">∈</span> [–2.048, 2.048]</span> for all <span class="times"><i class="fm-italics">i</i> = 1,...,<i class="fm-italics">n</i></span>. This function has a global minimum at <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i><sup class="fm-superscript">*</sup>) = 0.0</span> located at (1,...,1).</p>

  <p class="body">Let’s consider the 2D Rosenbrock function that takes the following form:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F14_Khamis-EQ14.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.13</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-387"/>Figure 10.15 shows the 2D surface of Rosenbrock function.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F15_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.15 The 2D surface plot of the Rosenbrock function. The dot indicates the global minimum of this function.</p>
  </div>

  <p class="body">Let’s look at how we can minimize this function using ABC:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Initialization phase</i>—Let’s assume that we have a swarm of <span class="times"><i class="fm-italics">N</i> = 6 bees</span>. Each bee tries to find a candidate solution, and each solution <i class="timesitalic">i</i> in the population consists of a position vector <span class="times"><i class="fm-italics">X<sub class="fm-subscript">mi</sub></i> = {<i class="fm-italics">x<sub class="fm-subscript">mi</sub>, y<sub class="fm-subscript">mi</sub></i>}</span> where <span class="times"><i class="fm-italics">X<sub class="fm-subscript">mi</sub></i> <span class="cambria">∈</span> [–2.048, 2.048]</span> and <span class="times"><i class="fm-italics">m</i> = 1,…,<i class="fm-italics">N</i></span>. <i class="timesitalic">X<sub class="fm-subscript">mi</sub></i> represents a potential solution to the optimization problem. The position of the employed bees is randomly determined within the boundaries. These initial solutions can be generated using the following formula:</p>
    </li>
  </ul>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F15_Khamis-EQ15.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.14</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-ind">where <i class="timesitalic">l<sub class="fm-subscript">i</sub></i> and <i class="timesitalic">u<sub class="fm-subscript">i</sub></i> are the lower and upper bounds of the decision variables. Let’s assume the initial positions (represented as <span class="times">(<i class="fm-italics">x, y</i>)</span>) shown in table 10.1.<a id="marker-388"/></p>

  <p class="fm-table-caption">Table 10.1 Initial food sources</p>

  <table border="1" class="contenttable-1-table" id="table001" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="50%"/>
      <col class="contenttable-0-col" span="1" width="50%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solution <i class="timesitalic">X<sub class="fm-subscript">m</sub></i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times"><i class="fm-italics">f<sub class="fm-subscript">m</sub>(</i><i class="timesitalic">X<sub class="fm-subscript">m</sub></i></span><i class="timesitalic">)</i></p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">1</sub> = (–1.04,0.11)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">98.56</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">2</sub> = (–1.61,–1.98)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2097.22</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">3</sub> = (1.82,1.22)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">438.49</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">4</sub> = (–1.64,1.92)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">66.20</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">5</sub> = (0.77,0.04)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">30.62</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">6</sub> = (–0.66,1.59)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">136.02</p>
        </td>
      </tr>
    </tbody>
  </table>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Employed bee phase</i>—In the employed bee phase, each bee generates a new solution in the neighborhood of its current solution using the following formula:</p>
    </li>
  </ul>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F15_Khamis-EQ16.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.15</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-ind">where <i class="timesitalic">v<sub class="fm-subscript">mj</sub></i> is the new solution, <i class="timesitalic">x<sub class="fm-subscript">mi</sub></i> is the current solution, <i class="timesitalic">ϕ<sub class="fm-subscript">mi</sub></i> is a random number between –1 and 1, and <i class="timesitalic">x<sub class="fm-subscript">ki</sub></i> is a randomly chosen solution different from the current solution. Let’s assume that all <i class="timesitalic">ϕ<sub class="fm-subscript">mi</sub></i> are <span class="times">–0.9</span> for simplicity, and for each bee, we choose the solution of bee 1 to calculate the new solutions. The best bee, in the initial population (table 10.1), bee 5, can also be used. We then calculate the new fitness values shown in table 10.2.</p>

  <p class="fm-table-caption">Table 10.2 New food sources</p>

  <table border="1" class="contenttable-1-table" id="table002" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="50%"/>
      <col class="contenttable-0-col" span="1" width="50%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solution <i class="timesitalic">X<sub class="fm-subscript">m</sub></i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times"><i class="fm-italics">f<sub class="fm-subscript">m</sub></i>(<i class="fm-italics">X<sub class="fm-subscript">m</sub></i>)</span></p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">1</sub> = (–1.04,0.11)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">98.56</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">2</sub> = (–1.10,–0.10)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">174.02</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">3</sub> = (–0.75,0.22)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">15.15</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">4</sub> = (–1.10,0.29)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">88.87</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">5</sub> = (–0.86,0.10)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">43.76</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">X</i><sub class="fm-subscript">6</sub> = (–1.00,0.26)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">59.66</p>
        </td>
      </tr>
    </tbody>
  </table>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Onlooker bee phase</i>—The onlooker bees observe the dance of the employed bees and choose a food source depending on the nectar amount (the <i class="fm-italics">fitness value</i>). If the new solution has a better fitness value, it is remembered as a global variable, and the position is updated. Otherwise, the old position is retained. The probability value <i class="timesitalic">p<sub class="fm-subscript">m</sub></i>, with which <i class="timesitalic">X<sub class="fm-subscript">m</sub></i> is chosen by an onlooker bee, can be calculated by using the following formula:</p>
    </li>
  </ul>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F15_Khamis-EQ17.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.16</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-ind">where <span class="times"><i class="fm-italics">fit<sub class="fm-subscript">m</sub></i>(<i class="fm-italics">X<sub class="fm-subscript">m</sub></i>)</span> is the fitness value of the solution, which can be calculated using the following expression:<a id="marker-389"/></p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH10_F15_Khamis-EQ18.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">10.17</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-ind">where <span class="times"><i class="fm-italics">f<sub class="fm-subscript">m</sub></i>(<i class="fm-italics">X<sub class="fm-subscript">m</sub></i>)</span> is the objective function of solution <i class="timesitalic">X<sub class="fm-subscript">m</sub></i>. Table 10.3 shows the solution fitness calculations.</p>

  <p class="fm-table-caption">Table 10.3 Solution fitness calculations</p>

  <table border="1" class="contenttable-1-table" id="table003" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solution <i class="timesitalic">X<sub class="fm-subscript">m</sub></i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times"><i class="fm-italics">f<sub class="fm-subscript">m</sub></i>(<i class="fm-italics">X<sub class="fm-subscript">m</sub></i><i class="fm-italics">)</i></span></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Fitness <span class="times"><i class="fm-italics">fit<sub class="fm-subscript">m</sub></i>(<i class="fm-italics">X<sub class="fm-subscript">m</sub></i>)</span></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Probability of selection <i class="timesitalic">p<sub class="fm-subscript">m</sub></i></p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><i class="timesitalic">X</i><sub class="fm-subscript">1</sub> = (–1.04,0.11)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">98.56</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.010</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.08</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><i class="timesitalic">X</i><sub class="fm-subscript">2</sub> = (–1.10,–0.10)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">174.02</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.006</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.04</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><i class="timesitalic">X</i><sub class="fm-subscript">3</sub> = (–0.75,0.22)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">15.15</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.062</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.49</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><i class="timesitalic">X</i><sub class="fm-subscript">4</sub> = (–1.10,0.29)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">88.87</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.09</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><i class="timesitalic">X</i><sub class="fm-subscript">5</sub> = (–0.86,0.10)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">43.76</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.022</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.18</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><i class="timesitalic">X</i><sub class="fm-subscript">6</sub> = (–1.00,0.26)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">59.66</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.016</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.13</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-ind">In this example, the food source discovered by bee 3 is most likely to be chosen. After a food source <i class="timesitalic">X<sub class="fm-subscript">m</sub></i> for an onlooker bee is probabilistically chosen, a neighborhood source <i class="timesitalic">v<sub class="fm-subscript">m</sub></i> is determined by using equation 10.15, and its fitness value is computed.</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Scout bee phase</i>—If a position cannot be improved further through a predetermined number of cycles or trials (called the <i class="fm-italics">limit</i>), that position is abandoned and the bee becomes a scout, searching for a new random position, which can be generated by equation 10.14.</p>
    </li>
  </ul>

  <p class="body">Let’s now see how we can implement ABC in Python to solve this problem. In the next listing, we start by importing the libraries we’ll use and defining the <code class="fm-code-in-text">rosenbrock_function</code>. This function takes as an argument a candidate solution (x, y) to the Rosenbrock function and returns its value.<a id="idIndexMarker071"/></p>

  <p class="fm-code-listing-caption">Listing 10.2 Solving Rosenbrock function optimization using ABC</p>
  <pre class="programlisting">import numpy as np
import random
import matplotlib.pyplot as plt
  
def rosenbrock_function(cand_soln):
    return (1 - cand_soln[0]) ** 2 + 100 * (cand_soln[1] - cand_soln[0] ** 2) ** 2</pre>

  <p class="body"><a id="marker-390"/>As a continuation of listing 10.2, we’ll create a <code class="fm-code-in-text">Bee</code> that contains the following attributes:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">position</code>—The position of the bee in the search space (solution)</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">fitness</code>—The fitness of the bee’s current position (the value of the Rosenbrock function at the current position)</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">counter</code>—A counter to track the number of unsuccessful trials (iterations without improvement in the bee’s fitness):</p>
    </li>
  </ul>
  <pre class="programlisting">class Bee:
    def __init__(self, position, fitness):
        self.position = position
        self.fitness = fitness
        self.counter = 0</pre>

  <p class="body">Now we need a function to generate a <code class="fm-code-in-text">Bee</code> with a random position and calculate its fitness using the Rosenbrock function:</p>
  <pre class="programlisting">def generate_bee(dimensions):
    position = np.array([random.uniform(-5, 5) for _ in range(dimensions)])
    fitness = rosenbrock_function(position)
    return Bee(position, fitness)</pre>

  <p class="body">The following function will update the position of a given bee using the position of a partner bee. If the new position has a better fitness value, the bee’s position, fitness, and counter are updated. Otherwise, the counter is incremented:</p>
  <pre class="programlisting">def update_position(bee, partner, dimensions):
    index = random.randrange(dimensions)             <span class="fm-combinumeral">①</span>
    phi = random.uniform(-1, 1)
    new_position = bee.position.copy()
    new_position[index] += phi * (bee.position[index] - partner.position[index])
    new_position = np.clip(new_position, -5, 5)      <span class="fm-combinumeral">②</span>
    new_fitness = rosenbrock_function(new_position)
    if new_fitness &lt; bee.fitness:
        bee.position = new_position
        bee.fitness = new_fitness
        bee.counter = 0
    else:
        bee.counter += 1</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Determine which element of the bee’s position will be updated.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Clip to ensure it stays within a specified range.</p>

  <p class="body">Next, we’ll define an <code class="fm-code-in-text">abc_algorithm</code> function to implement the ABC algorithm with the following input parameters:<a id="idIndexMarker072"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">dimensions</code>—The number of dimensions of the problem, which is 2 for the Rosenbrock function</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">num_bees</code>—The total number of bees in the colony</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">max_iter</code>—The maximum number of iterations the algorithm should run</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">max_trials</code>—The maximum number of unsuccessful cycles or trials (iterations without improvement) allowed before a bee becomes a scout bee:</p>
    </li>
  </ul>
  <pre class="programlisting">def abc_algorithm(dimensions, num_bees, max_iter, max_trials):
  
    bees = [generate_bee(dimensions) for _ in range(num_bees)]               <span class="fm-combinumeral">①</span>
    best_bee = min(bees, key=lambda bee: bee.fitness)                        <span class="fm-combinumeral">②</span>
  
    for _ in range(max_iter):
        for i in range(num_bees // 2):                                       <span class="fm-combinumeral">③</span>
            employed_bee = bees[i]
            partner_bee = random.choice(bees)
            update_position(employed_bee, partner_bee, dimensions)
  
        total_fitness = sum(1 / (1 + bee.fitness) if bee.fitness &gt;= 0 else 1 <span class="fm-combinumeral">④</span>
<span class="fm-code-continuation-arrow">➥</span> + abs(bee.fitness) for bee in bees)                                       <span class="fm-combinumeral">④</span>
        probabilities = [(1 / (1 + bee.fitness)) / total_fitness if bee.     <span class="fm-combinumeral">④</span>
<span class="fm-code-continuation-arrow">➥</span> fitness &gt;= 0 else (1 + abs(bee.fitness)) / total_fitness for bee in bees] <span class="fm-combinumeral">④</span>
   
        for i in range(num_bees // 2, num_bees):                             <span class="fm-combinumeral">⑤</span>
            onlooker_bee = random.choices(bees, weights=probabilities)[0]
            partner_bee = min(bees[:num_bees // 2], key=lambda bee: bee.fitness)
            update_position(onlooker_bee, partner_bee, dimensions)
  
        for bee in bees:                                                     <span class="fm-combinumeral">⑥</span>
            if bee.counter &gt; max_trials:                                     <span class="fm-combinumeral">⑦</span>
                new_bee = generate_bee(dimensions)
                bee.position = new_bee.position
                bee.fitness = new_bee.fitness
                bee.counter = 0
  
        best_iter_bee = min(bees, key=lambda bee: bee.fitness)               <span class="fm-combinumeral">⑧</span>
        if best_iter_bee.fitness &lt; best_bee.fitness:                         <span class="fm-combinumeral">⑧</span>
            best_bee = best_iter_bee                                         <span class="fm-combinumeral">⑧</span>
  
    return best_bee                                                          <span class="fm-combinumeral">⑨</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Generate an initial population of bees.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Find the bee with the best fitness value.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Perform the employed bees phase.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Perform the onlooker bees phase.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Calculate the selection probability according equations 16 and 17.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Perform the scout bees phase.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Check if each bee’s counter exceeds max_trials.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Update best_bee with the new best bee.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑨</span> Return best_bee, which represents the optimal solution.</p>

  <p class="body"><a id="marker-391"/>Now we can set up the parameters of the ABC algorithm and apply it to solve the problem:</p>
  <pre class="programlisting">dimensions = 2                                                         <span class="fm-combinumeral">①</span>
num_bees = 50                                                          <span class="fm-combinumeral">②</span>
max_iter = 1000                                                        <span class="fm-combinumeral">③</span>
max_trials = 100                                                       <span class="fm-combinumeral">④</span>
  
best_bee = abc_algorithm(dimensions, num_bees, max_iter, max_trials)   <span class="fm-combinumeral">⑤</span>
print(f"Best solution: {best_bee.position}")                           <span class="fm-combinumeral">⑥</span>
print(f"Best fitness: {best_bee.fitness}")                             <span class="fm-combinumeral">⑥</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define the problem dimensions.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Set the number of bees.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Set the maximum number of iterations used as a stopping criterion.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Set the maximum number of unsuccessful trials (iterations without improvement) allowed before a bee becomes a scout bee.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Run the ABC algorithm with the parameters specified and store the best bee (the one with the minimum fitness value) in the best_bee variable.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Print the position of best_bee, which represents the solution and its fitness, which is the value of the Rosenbrock function at the best solution.</p>

  <p class="body">This code will produce output like the following:</p>
  <pre class="programlisting">Best solution: [0.99766117 0.99542949]
Best fitness: 6.50385257086524e-06</pre>

  <p class="body"><a id="marker-392"/>In contrast to genetic algorithms and particle swarm optimization algorithms, the availability of well-established and comprehensive Python packages specifically designed for the ABC algorithm is relatively limited. However, there is a Python library called MEALPY that offers implementations of population-based metaheuristic algorithms, including ABC. You can install MEALPY using <code class="fm-code-in-text">pip install mealpy</code>. <a id="idIndexMarker073"/></p>

  <p class="body">As a continuation of listing 10.2, the following code snippet demonstrates using the <code class="fm-code-in-text">OriginalABC</code> class from the MEALPY library to minimize the Rosenbrock function:<a id="idIndexMarker074"/></p>
  <pre class="programlisting">from mealpy.swarm_based.ABC import OriginalABC                        <span class="fm-combinumeral">①</span>
  
problem_dict = {
    "fit_func": rosenbrock_function,
    "lb": [-5, -5],
    "ub": [5, 5],
    "minmax": "min",
}                                                                     <span class="fm-combinumeral">②</span>
 
epoch = 200                                                           <span class="fm-combinumeral">③</span>
pop_size = 50                                                         <span class="fm-combinumeral">④</span>
n_limits = 15                                                         <span class="fm-combinumeral">⑤</span>
  
model = OriginalABC(epoch, pop_size, n_limits)                        <span class="fm-combinumeral">⑥</span>
  
best_position_mealpy, best_fitness_mealpy = model.solve(problem_dict) <span class="fm-combinumeral">⑦</span>
  
print(f"Best solution: {best_position_mealpy}")                       <span class="fm-combinumeral">⑧</span>
print(f"Best fitness: {best_fitness_mealpy}")                         <span class="fm-combinumeral">⑧</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import the solver from MEALPY library.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Define the problem using dictionary.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Set the number of epochs (iterations).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Set the population size.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Set the limit on the number of unsuccessful trials before a scout bee is triggered.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Create an instance of the algorithm class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Run the algorithm.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Print the results.</p>

  <p class="body">We start by importing the <code class="fm-code-in-text">OriginalABC</code> class from the <code class="fm-code-in-text">mealpy.swarm_based.ABC</code> module, which is the implementation of the ABC algorithm provided by the MEALPY library. We then define the problem dictionary, which contains the cost function (<code class="fm-code-in-text">fit_func</code>), lower bound (<code class="fm-code-in-text">lb</code>), upper bound (<code class="fm-code-in-text">ub</code>), and whether this is a minimization or maximization problem (<code class="fm-code-in-text">minmax</code>). The number of epochs (iterations), population size, and the limit on the number of unsuccessful trials before a scout bee is triggered are set. We then create an instance of the <code class="fm-code-in-text">OriginalABC</code> class, initialized with the specified parameters. The <code class="fm-code-in-text">solve()</code> method is called on the <code class="fm-code-in-text">model</code> object, passing the <code class="fm-code-in-text">problem_dict</code> as an argument. It performs the ABC algorithm optimization process on the defined problem and returns the best solution and fitness value.<a id="idIndexMarker075"/><a id="idIndexMarker076"/><a id="idIndexMarker077"/><a id="idIndexMarker078"/><a id="idIndexMarker079"/></p>

  <p class="body">Running this code will produce a solution like the following:</p>
  <pre class="programlisting">Best solution: [1.07313697 1.04914444]
Cost at best solution: 0.0009197449137428784 </pre>

  <p class="body">Figure 10.16 shows the solution obtained by the ABC solver, ABC MEALPLY, and the ACO solver implemented as part of the complete listing 10.2.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH10_F16_Khamis.png"/></p>

    <p class="figurecaption">Figure 10.16 The Rosenbrock function contour and solutions using the ABC and ACO algorithms</p>
  </div>

  <p class="body"><a id="marker-393"/>As you can see, the ABC, ABC MEALPY, and ACO solutions are all close to the optimal solution of this function. With parameter tuning, an optimal solution can be reached by these algorithms. You can use the code in listing 10.2 to experiment with different algorithm parameter settings and different problem dimensions.</p>

  <p class="body">This chapter concludes the fourth part of this book. In this part, we’ve delved deep into the fascinating world of swarm intelligence, exploring how simple entities, like birds in particle swarm optimization (PSO), ants in ant colony optimization (ACO), and bees in the artificial bee colony (ABC) algorithm, can collectively perform complex tasks. These nature-inspired algorithms elegantly balance exploration and exploitation to find optimal or near-optimal solutions to complex optimization problems. <a id="idIndexMarker080"/><a id="idIndexMarker081"/></p>

  <p class="body">As we move forward, we’ll transition to the domain of machine learning. In the last part of this book, we’ll look at machine learning methods specifically tailored for search and optimization. We’ll explore cutting-edge techniques, such as graph neural networks, attention mechanisms, self-organizing maps, and reinforcement learning, and investigate their applications in search and optimization.<a id="marker-394"/></p>

  <h2 class="fm-head" id="heading_id_13">Summary</h2>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">Ant colony optimization (ACO) is a population-based algorithm inspired by the foraging behavior of ants. Simple ACO (SACO), ant system (AS), ant colony system (ACS), and max–min ant system (MMAS) are examples of ACO metaheuristics algorithms.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">During foraging, ants discover good solutions, which influence the decisions of other ants. Over time, the pheromone trails intensify along the paths of better solutions, attracting more ants to explore those paths. This is called autocatalytic behavior.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Pheromone updates include two phases: evaporation and deposit. During the evaporation phase, the pheromone concentration is decreased. Ants can deposit pheromones during the construction of a solution, using the online step-by-step pheromone update method, or after the solution has been built, by revisiting all the states visited during the construction process, using the online delayed pheromone update method. In some cases, both methods can be used together.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Ant system (AS) improves on simple ACO by adding a memory capability in the form of a tabu list.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The ant colony system (ACS) algorithm is an extension of the AS algorithm with a modified transition rule that utilizes an elitist strategy.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The max–min ant system (MMAS) addresses the limitations of AS and ACS by using the iteration-best path for pheromone updates, encouraging exploration and constraining pheromone values between minimum and maximum values. This approach reduces the risk of premature stagnation and improves performance by balancing exploration and exploitation.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The artificial bee colony (ABC) algorithm is a population-based search algorithm inspired by the foraging behavior of honeybees. The ABC algorithm manages the balance between exploration and exploitation through its three types of bees (employed bees, onlooker bees, and scout bees), each of which perform different complementary roles.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The inherent randomness in stochastic optimization algorithms due to initial conditions and the probabilistic decision-making process is not necessarily a bad thing. It can help the algorithm avoid getting stuck in local optima—solutions that are the best in their immediate vicinity but are not the best overall. By occasionally taking less promising paths, the algorithm can explore more of the solution space and has a better chance of finding the global optimum—the best possible solution.</p>
    </li>
  </ul>
</body></html>