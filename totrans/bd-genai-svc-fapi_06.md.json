["```py\nfrom datetime import datetime\n\ndef timestamp_to_isostring(date: int) -> str:\n    return datetime.fromtimestamp(date).isoformat()\n\nprint(timestamp_to_isostring(1736680773))\n# 2025-01-12T11:19:52.876758\n\nprint(timestamp_to_isostring(\"27 Jan 2025 14:48:00\"))\n# error: Argument 1 to \"timestamp_to_isostring\" has incompatible type \"str\";\n# expected \"int\" [arg-type]\n```", "```py\n$ pip install loguru\n```", "```py`L['esempio 4-2](#type_annotation) mostra diversi esempi di annotazione del tipo.    ##### Esempio 4-2\\. Utilizzo dell'annotazione del tipo per ridurre i bug futuri in caso di modifiche al codice    ```", "```py    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO1-1)      Utilizza il modulo `Literal` di Python `typing` incluso nella libreria standard.^([1](ch04.html#id749)) Dichiara i letterali `gpt-3.5` e `gpt-4` e assegnali all'*alias di tipo* `SupportedModel`. Anche `PriceTable` è un alias di tipo semplice che definisce un dizionario con chiavi limitate ai letterali `SupportedModel` e con valori di tipo `float`.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO1-2)      Contrassegnare gli alias di tipo con `TypeAlias` per indicare esplicitamente che non si tratta di un normale assegnamento di variabile. I tipi sono anche dichiarati normalmente utilizzando CamelCase come migliore pratica per differenziarli dalle variabili. Ora puoi riutilizzare l'alias di tipo `PriceTable` in un secondo momento.      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO1-3)      Dichiara il dizionario della tabella dei prezzi e assegna il tipo `PriceTable` per limitare esplicitamente le chiavi e i valori consentiti nel dizionario della tabella dei prezzi.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO1-4)      La funzione `count_tokens` deve accettare stringhe o `None` tipi e restituire sempre un intero. Implementa la gestione delle eccezioni nel caso in cui qualcuno tenti di passare qualcosa di diverso da stringhe o `None` tipi. Quando definisci `count_tokens`, l'editor di codice e i controllori statici solleveranno avvisi se `count_tokens` non restituisce un intero anche se riceve un `None` e sollevano errori se qualsiasi altro tipo diverso da stringa o `None`.      [![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO1-5)      Restituisce `0` anche se viene passato un tipo `None` per garantire il rispetto della tipizzazione delle funzioni.      [![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO1-6)      Tokenizza il testo dato utilizzando la libreria `tiktoken` di OpenAI, usando la stessa codifica utilizzata per il modello `gpt-4o`.^([2](ch04.html#id750))      [![7](assets/7.png)](#co_implementing_type_safe_ai_services_CO1-7)      Digita la funzione `calculate_usage_costs` in modo che accetti sempre un prompt di testo e i letterali prestabiliti per il parametro `model`. Passa il parametro `price_table` con l'alias di tipo `PriceTable` dichiarato in precedenza. La funzione deve restituire una tupla di tre float.      [![8](assets/8.png)](#co_implementing_type_safe_ai_services_CO1-8)      I controllori di tipo emettono avvertimenti quando viene passato un letterale di modello inaspettato, ma dovresti sempre controllare che non ci siano input errati alle funzioni e sollevare errori in runtime se viene passato un parametro di modello inaspettato.      [![9](assets/9.png)](#co_implementing_type_safe_ai_services_CO1-9)      Non c'è bisogno di preoccuparsi della gestione delle eccezioni, in quanto non c'è la possibilità che venga sollevato un `KeyError` se viene passato un modello non supportato. Se la tabella dei prezzi non viene aggiornata, la funzione solleva subito un `ValueError`. Cattura il `KeyError`, emette un avviso che la tabella dei prezzi deve essere aggiornata e poi solleva di nuovo il `KeyError`in modo che tutti i dettagli del problema vengano stampati sul terminale, in quanto non si possono fare supposizioni sui prezzi.      [![10](assets/10.png)](#co_implementing_type_safe_ai_services_CO1-10)      Usa la funzione `count_tokens` per calcolare i costi della richiesta e della risposta dell'LLM. Se per qualche motivo l'LLM non restituisce una risposta (restituisce `None`), `count_tokens` può gestirla e assumere zero gettoni.      [![11](assets/11.png)](#co_implementing_type_safe_ai_services_CO1-11)      Restituisce una tupla di tre float come da digitazione della funzione.      In una base di codice complessa, può essere difficile indovinare quali tipi di dati vengono passati, soprattutto se si apportano molte modifiche ovunque. Con le funzioni tipizzate, puoi essere sicuro che i parametri inaspettati non vengano passati a funzioni che non li supportano ancora.    Come puoi vedere dall'[Esempio 4-2](#type_annotation), la digitazione del codice ti aiuta a individuare bug imprevisti durante gli aggiornamenti del codice. Ad esempio, se inizi a utilizzare un nuovo modello LLM, non puoi ancora calcolare i costi per il nuovo modello. Per supportare il calcolo dei costi per altri modelli LLM, devi prima aggiornare la tabella dei prezzi, la relativa digitazione e qualsiasi logica di gestione delle eccezioni. Una volta fatto, puoi essere abbastanza sicuro che la tua logica di calcolo sia ora estesa per funzionare con i nuovi tipi di modello.```", "```py`## Utilizzo di Annotated    Nell'[Esempio 4-2](#type_annotation), puoi utilizzare `Annotated` al posto degli alias di tipo.`Annotated` è una funzionalità del modulo `typing`, introdotto in Python 3.9, ed è simile agli alias di tipo per riutilizzare i tipi, ma ti permette di definire anche *i metadati* per i tuoi tipi.    I metadati non influiscono sui controllori di tipo, ma sono utili per la documentazione del codice, l'analisi e le ispezioni in runtime.    Dalla sua introduzione in Python 3.9, puoi usare `Annotated` come mostrato nell'[Esempio 4-3](#annotated_usage).    ##### Esempio 4-3\\. Utilizzo di `Annotated` per dichiarare tipi personalizzati con metadati    ```", "```py    La [documentazione di FastAPI](https://oreil.ly/mtGcY) consiglia l'uso di`Annotated` al posto degli alias di tipo per la riusabilità, per un migliore controllo dei tipi nell'editor di codice e per individuare i problemi durante il runtime.    ###### Avvertenze    Tieni presente che la funzione `Annotated` richiede almeno due argomenti per funzionare: il primo deve essere il tipo passato e gli altri argomenti sono le annotazioni o i metadati che vuoi allegare al tipo, come ad esempio una descrizione, una regola di convalida o altri metadati, come mostrato nell'[Esempio 4-3](#annotated_usage).    La tipizzazione, pur essendo vantaggiosa di per sé, non risolve tutti gli aspetti della gestione e della strutturazione dei dati. Per fortuna, le *classi di dati* di Python della libreria standard aiutano a estendere il sistema di tipizzazione.    Vediamo come puoi sfruttare le classi di dati per migliorare la digitazione nelle tue applicazioni.    ## Classi di dati    Le classi di dati sono state introdotte in Python 3.7 come parte della libreria standard. Se hai bisogno di strutture di dati personalizzate, puoi usare le classi di dati per organizzare, memorizzare e trasferire i dati nella tua applicazione.    Possono aiutare a evitare \"odori\" di codice come il bloat dei parametri delle funzioni, in cui una funzione è difficile da usare perché richiede più di una manciata di parametri. Avere una classe di dati ti permette di organizzare i tuoi dati in una struttura definita su misura e di passarli come un unico elemento alle funzioni che richiedono dati da luoghi diversi.    Puoi aggiornare l'[esempio 4-2](#type_annotation) per sfruttare le classi di dati, come mostrato nell'[esempio 4-4](#dataclasses).    ##### Esempio 4-4\\. Utilizzo delle classi di dati per garantire la sicurezza dei tipi    ```", "```py    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO2-1)      Utilizza le classi dataclass per decorare le classi `Message` e `MessageCost` come classi speciali per contenere i dati.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO2-2)      Digita l'attributo `response` in modo che sia un `str` o un `None`. Questo è simile all'utilizzo di `Optional[str]` dal modulo `typing`. Questa nuova sintassi è disponibile in Python 3.10 e successivi, utilizzando il nuovo operatore union: `|`.      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO2-3)      Modifica la firma della funzione `calculate_usage_costs` per utilizzare le classi di dati predefinite. Questa modifica semplifica la firma della funzione.      Dovresti puntare a sfruttare le classi di dati quando il tuo codice accumula odori di codice e diventa difficile da leggere.    Il vantaggio principale dell'utilizzo delle classi di dati nell'[Esempio 4-4](#dataclasses) è stato quello di raggruppare parametri correlati per semplificare la firma della funzione. In altri scenari, puoi utilizzare le classi di dati per:    *   Eliminare la duplicazione del codice           *   Ridurre l'eccesso di codice (classi o funzioni di grandi dimensioni)           *   Refactoring dei cluster di dati (variabili comunemente utilizzate insieme)           *   Prevenire la mutazione involontaria dei dati           *   Promuovere l'organizzazione dei dati           *   Promuovere l'incapsulamento           *   Applicare la convalida dei dati              Possono anche essere utilizzati per implementare molti altri miglioramenti del codice.    Le classi di dati sono uno strumento eccellente per migliorare l'organizzazione e lo scambio dei dati in qualsiasi punto della tua applicazione. Tuttavia, non supportano in modo nativo diverse funzionalità nella creazione di servizi API:    Parsing automatico dei dati      Parsing di stringhe ISO formattate con datetime in oggetti datetime su assegnazione      Convalida del campo      Eseguire controlli complessi sull'assegnazione dei valori ai campi, come ad esempio verificare se una stringa è troppo lunga      Serializzazione e deserializzazione      Conversione tra JSON e strutture di dati Python, in particolare quando si utilizzano tipi non comuni      Filtraggio del campo      Rimuovere i campi degli oggetti che non sono impostati o che contengono valori `None`      Nessuna delle limitazioni menzionate ti costringerà ad abbandonare l'uso delle classi di dati. Dovresti usare le classi di dati piuttosto che le classi normali quando hai bisogno di creare classi incentrate sui dati con un codice boilerplate minimo, in quanto generano automaticamente metodi speciali, annotazioni sul tipo e supporto per i valori predefiniti, riducendo i potenziali errori. Tuttavia, librerie come `pydantic` supportano queste caratteristiche se non vuoi implementare la tua logica personalizzata (ad esempio, la serializzazione degli oggetti datetime).    ###### Suggerimento    FastAPI supporta anche le classi di dati attraverso Pydantic, che implementa la propria versione delle classi di dati con il supporto delle caratteristiche sopra citate, consentendoti di migrare le basi di codice che utilizzano pesantemente le classi di dati .    Diamo ora un'occhiata a Pydantic e a ciò che lo rende ideale per la creazione di servizi GenAI.```", "```py```", "````py````", "```py` # Modelli Pydantic    Pydantic è la libreria di validazione dei dati più diffusa e supporta validatori e serializzatori personalizzati. La logica di base di Pydantic è controllata da annotazioni di tipo in Python e può emettere dati in formato JSON, consentendo una perfetta integrazione con qualsiasi altro strumento.    Inoltre, la logica di convalida dei dati di Pydantic V2 è stata riscritta in Rust per massimizzarne la velocità e le prestazioni, posizionandola come una delle librerie di convalida dei dati più veloci in Python. Di conseguenza, Pydantic ha influenzato pesantemente FastAPI e altri 8.000 pacchetti dell'ecosistema Python, tra cui Hugging Face, Django e LangChain. Si tratta di un toolkit collaudato e utilizzato dalle principali aziende tecnologiche, con 141 milioni di download al mese al momento della stesura di questo articolo, il che lo rende un candidato adatto all'adozione nei tuoi progetti in sostituzione delle dataclass.    Pydantic fornisce un ampio set di strumenti per la convalida e l'elaborazione dei dati utilizzando la propria implementazione di `BaseModel`. I modelli di Pydantic condividono molte somiglianze con le classi di dati, ma differiscono in alcune aree sottili. Quando crei i modelli di Pydantic, vengono richiamati una serie di hook di inizializzazione che aggiungono ai modelli funzioni di convalida dei dati, serializzazione e generazione di schemi JSON che mancano alle classi di dati vanilla.    FastAPI si integra strettamente con Pydantic e sfrutta il suo ricco set di funzionalità per l'elaborazione dei dati. I verificatori di tipo e gli editor di codice possono anche leggere i modelli di Pydantic in modo simile alle classi di dati per eseguire controlli e fornire autocompletamenti.    ## Come usare Pydantic    Puoi installare Pydantic nel tuo progetto utilizzando il seguente metodo:    ```", "```py   ```", "```py from typing import Literal from pydantic import BaseModel  class TextModelRequest(BaseModel): ![1](assets/1.png)     model: Literal[\"gpt-3.5-turbo\", \"gpt-4o\"]     prompt: str     temperature: float = 0.0 ![2](assets/2.png) ```", "```py`  ```", "```py```", "````py````", "```py # schemas.py  from datetime import datetime from typing import Annotated, Literal from pydantic import BaseModel  class ModelRequest(BaseModel): ![1](assets/1.png)     prompt: str  class ModelResponse(BaseModel): ![2](assets/2.png)     request_id: str     ip: str | None     content: str | None     created_at: datetime = datetime.now()  class TextModelRequest(ModelRequest):     model: Literal[\"gpt-3.5-turbo\", \"gpt-4o\"]     temperature: float = 0.0  class TextModelResponse(ModelResponse):     tokens: int  ImageSize = Annotated[tuple[int, int], \"Width and height of an image in pixels\"]  class ImageModelRequest(ModelRequest): ![3](assets/3.png)     model: Literal[\"tinysd\", \"sd1.5\"]     output_size: ImageSize     num_inference_steps: int = 200  class ImageModelResponse(ModelResponse): ![4](assets/4.png)     size: ImageSize     url: str ```", "```py # schemas.py  from datetime import datetime from typing import Annotated, Literal from uuid import uuid4 from pydantic import BaseModel, Field, HttpUrl, IPvAnyAddress, PositiveInt  class ModelRequest(BaseModel):     prompt: Annotated[str, Field(min_length=1, max_length=10000)] ![1](assets/1.png)  class ModelResponse(BaseModel):     request_id: Annotated[str, Field(default_factory=lambda: uuid4().hex)] ![2](assets/2.png)     # no defaults set for ip field     # raise ValidationError if a valid IP address or None is not provided     ip: Annotated[str, IPvAnyAddress] | None ![3](assets/3.png)     content: Annotated[str | None, Field(min_length=0, max_length=10000)] ![4](assets/4.png)     created_at: datetime = datetime.now()  class TextModelRequest(ModelRequest):     model: Literal[\"gpt-3.5-turbo\", \"gpt-4o\"]     temperature: Annotated[float, Field(ge=0.0, le=1.0, default=0.0)] ![5](assets/5.png)  class TextModelResponse(ModelResponse):     tokens: Annotated[int, Field(ge=0)]  ImageSize = Annotated[ ![6](assets/6.png)     tuple[PositiveInt, PositiveInt], \"Width and height of an image in pixels\" ]  class ImageModelRequest(ModelRequest):     model: Literal[\"tinysd\", \"sd1.5\"]     output_size: ImageSize ![6](assets/6.png)     num_inference_steps: Annotated[int, Field(ge=0, le=2000)] = 200 ![7](assets/7.png)  class ImageModelResponse(ModelResponse):     size: ImageSize ![6](assets/6.png)     url: Annotated[str, HttpUrl] | None = None ![8](assets/8.png) ```", "```py $ curl -X 'POST' \\   'http://127.0.0.1:8000/validation/failure' \\   -H 'accept: application/json' \\   -H 'Content-Type: application/json' \\   -d '{  \"prompt\": \"string\",  \"model\": \"gpt-4o\",  \"temperature\": 0 }' `{` ```", "```py```", "````py``` `\"detail\"`: `[` ````", "```````py`` `{` ``````py```````", "``````py``````", "``````py``````", "```py```", "````py` `\"model\"` ````", "```` `]`, ```py````", "```py```", "```py```", "```py```", "````` `}` ```py` `}` ``` `]` `` `}` `` ```py ```` ```py`` `````", "``````py` ``````", "``````py``` ``````", "```` ```py````", "```py` ```", "```py```", "``` ```", "```````py``` ``````py```````", "``````py``````", "``````py``````", "``` ```", "```py```", "```py```", "````` ## Validatori di campi e modelli personalizzati    Un'altra eccellente caratteristica di Pydantic per eseguire controlli di convalida dei dati è rappresentata dai *validatori di campo personalizzati*. L ['esempio 4-9](#field_validators) mostra come entrambi i tipi di validatori personalizzati possono essere implementati su `ImageModelRequest`.    ##### Esempio 4-9\\. Implementazione di validatori di campi e modelli personalizzati per `ImageModelRequest`    ```py # schemas.py  from typing import Annotated, Literal from pydantic import (     AfterValidator,     BaseModel,     Field,     PositiveInt,     validate_call, )  ImageSize = Annotated[     tuple[PositiveInt, PositiveInt], \"Width and height of an image in pixels\" ] SupportedModels = Annotated[     Literal[\"tinysd\", \"sd1.5\"], \"Supported Image Generation Models\" ]  @validate_call ![1](assets/1.png) def is_square_image(value: ImageSize) -> ImageSize: ![2](assets/2.png)     if value[0] / value[1] != 1:         raise ValueError(\"Only square images are supported\")     if value[0] not in [512, 1024]:         raise ValueError(f\"Invalid output size: {value} - expected 512 or 1024\")     return value  @validate_call ![1](assets/1.png) def is_valid_inference_step(     num_inference_steps: int, model: SupportedModels ) -> int:     if model == \"tinysd\" and num_inference_steps > 2000: ![3](assets/3.png)         raise ValueError(             \"TinySD model cannot have more than 2000 inference steps\"         )     return num_inference_steps  OutputSize = Annotated[ImageSize, AfterValidator(is_square_image)] ![4](assets/4.png) InferenceSteps = Annotated[ ![4](assets/4.png)     int,     AfterValidator(         lambda v, values: is_valid_inference_step(v, values[\"model\"])     ), ]  class ModelRequest(BaseModel):     prompt: Annotated[str, Field(min_length=1, max_length=4000)]  class ImageModelRequest(ModelRequest):     model: SupportedModels     output_size: OutputSize ![5](assets/5.png)     num_inference_steps: InferenceSteps = 200 ![6](assets/6.png) ```    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO6-1)      Oltre ai controlli di tipo statico, solleva un errore di validazione in runtime se sono stati passati parametri errati alle funzioni `is_square_image` e `is_valid_​infer⁠ence_step`.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO6-2)      Il modello `tinysd` è in grado di generare immagini quadrate solo in determinate dimensioni. La richiesta di un'immagine di dimensioni non quadrate (un rapporto d'aspetto diverso da `1`) dovrebbe generare un `ValueError`.      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO6-4)      Solleva un `ValueError` se l'utente richiede un numero elevato di passi di inferenza per il modello `tinysd`.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO6-5)      Crea validatori riutilizzabili e più leggibili utilizzando il modello annotato sia per `OutputSize` che per `InferenceSteps`.      [![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO6-7)      Collega il validatore del campo `OutputSize` al campo `output_size` per verificare la presenza di valori errati dopo l'inizializzazione del modello.      [![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO6-8)      Allega il validatore `InferenceSteps` al modello `ImageModelRequest` per eseguire controlli sui valori dei campi del modello *dopo che* questo è stato inizializzato.      Con i validatori di campo personalizzati, come mostrato nell'[Esempio 4-9](#field_validators), puoi essere sicuro che i tuoi endpoint di generazione delle immagini saranno protetti dalle configurazioni errate fornite dagli utenti.    ###### Nota    Puoi anche utilizzare lo schema del decoratore per convalidare i campi del modello. Si possono associare metodispeciali ai campi del modello per eseguire controlli condizionati sui dati utilizzando il decoratore `@field_validator` o `@model_validator`.    Mentre `@field_validator` accede al valore di un singolo campo per effettuare i controlli, il decoratore `@model_validator` permette di effettuare controlli che coinvolgono più campi.    Con i validatori di `after` puoi eseguire controlli aggiuntivi o modificare i dati dopo che Pydantic ha completato il parsing e la validazione.    ## Campi calcolati    Analogamente alle classi di dati, Pydantic ti permette anche di implementare metodi per calcolare campi derivati da altri campi.    Puoi utilizzare il decoratore `@computed_field` per implementare un campo calcolato per calcolare il conteggio dei token e il costo, come mostrato nell'[Esempio 4-10](#computed_fields).    ##### Esempio 4-10\\. Utilizzo di campi calcolati per contare automaticamente il numero totale di token    ```py # schemas.py  from typing import Annotated from pydantic import computed_field, Field from utils import count_tokens  ...  class TextModelResponse(ModelResponse):     model: SupportedModels     price: Annotated[float, Field(ge=0, default=0.01)]     temperature: Annotated[float, Field(ge=0.0, le=1.0, default=0.0)]      @property     @computed_field     def tokens(self) -> int:         return count_tokens(self.content)      @property     @computed_field     def cost(self) -> float:         return self.price * self.tokens ```    I campi computati sono utili per incapsulare la logica di calcolo dei campi all'interno dei tuoi modelli Pydantic per mantenere il codice organizzato. Tieni presente che i campi computati sono accessibili solo quando converti un modello Pydantic in un dizionario usando `.model_dump()` o tramite serializzazione quando un gestore dell'API FastAPI restituisce una risposta.    ## Esportazione e serializzazione del modello    Poiché i modelli di Python possono essere serializzati in JSON, i modelli definiti nell'[Esempio 4-7](#pydantic_constrained_fields) possono anche essere scaricati (o caricati) in stringhe JSON o in dizionari Python mantenendo tutti gli schemi composti, come mostrato nell'[Esempio 4-11](#model_export).    ##### Esempio 4-11\\. Esportazione e serializzazione del modello `TextModelResponse`    ```py >> response = TextModelResponse(content=\"FastAPI Generative AI Service\", ip=None) >> response.model_dump(exclude_none=True) {'content': 'FastAPI Generative AI Service',  'cost': 0.06,  'created_at': datetime.datetime(2024, 3, 7, 20, 42, 38, 729410),  'price': 0.01,  'request_id': 'a3f18d85dcb442baa887a505ae8d2cd7',  'tokens': 6}  >> response.model_dump_json(exclude_unset=True) '{\"ip\":null,\"content\":\"FastAPI Generative AI Service\",\"tokens\":6,\"cost\":0.06}' ```    ## Analizzare le variabili d'ambiente con Pydantic    Oltre a `BaseModel`, Pydantic implementa anche una classe `Base` per l'analisi delle impostazioni e dei segreti dai file. Questa funzione è fornita in un pacchetto opzionale di Pydantic chiamato`pydantic-settings`, che puoi installare come dipendenza:    ```py $ pip install pydantic-settings ```   ```py` La classe `BaseSettings` fornisce funzioni opzionali di Pydantic per caricare una classe di impostazioni o di configurazione da variabili d'ambiente o da file segreti. Utilizzando questa funzione, i valori delle impostazioni possono essere impostati nel codice o sovrascritti da variabili d'ambiente.    Questo è utile in produzione, dove non vuoi esporre segreti all'interno del codice o dell'ambiente del container.    Quando crei un modello che eredita da `BaseSettings`, l'inizializzatore del modello cercherà di impostare i valori di ogni campo utilizzando i valori predefiniti forniti. Se non ci riesce, l'inizializzatore leggerà i valori dei campi non impostati dalle variabili d'ambiente.    Dato un file di ambiente dotenv (ENV):    ``` APP_SECRET=asdlkajdlkajdklaslkldjkasldjkasdjaslk DATABASE_URL=postgres://sa:password@localhost:5432/cms CORS_WHITELIST=[\"https://xyz.azurewebsites.net\",\"http://localhost:3000\"] ```py    Un ENV è un file di variabili d'ambiente che può utilizzare la sintassi di uno script di shell per le coppie chiave-valore.    L['esempio 4-12](#pydantic_settings) mostra l'analisi delle variabili d'ambiente con `BaseSettings` in azione.    ##### Esempio 4-12\\. Utilizzo di Pydantic `BaseSettings` per analizzare le variabili d'ambiente    ``` # settings.py  from typing import Annotated from pydantic import Field, HttpUrl, PostgresDsn from pydantic_settings import BaseSettings, SettingsConfigDict  class AppSettings(BaseSettings): ![1](assets/1.png)     model_config = SettingsConfigDict(         env_file=\".env\", env_file_encoding=\"utf-8\" ![2](assets/2.png)     )      port: Annotated[int, Field(default=8000)]     app_secret: Annotated[str, Field(min_length=32)]     pg_dsn: Annotated[         PostgresDsn,         Field(             alias=\"DATABASE_URL\",             default=\"postgres://user:pass@localhost:5432/database\",         ),     ] ![3](assets/3.png)     cors_whitelist_domains: Annotated[         set[HttpUrl],         Field(alias=\"CORS_WHITELIST\", default=[\"http://localhost:3000\"]),     ] ![4](assets/4.png)   settings = AppSettings() print(settings.model_dump()) ![5](assets/5.png) \"\"\" {'port': 8000  'app_secret': 'asdlkajdlkajdklaslkldjkasldjkasdjaslk',  'pg_dsn': MultiHostUrl('postgres://sa:password@localhost:5432/cms'),  'cors_whitelist_domains': {Url('http://localhost:3000/'),                             Url('https://xyz.azurewebsites.net/')}, } \"\"\" ```py    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO7-1)      Dichiara `AppSettings` ereditando dalla classe `BaseSettings` del pacchetto`pydantic_settings` pacchetto.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO7-2)      Configura `AppSettings` per leggere le variabili d'ambiente dal file ENV nella radice di un progetto con la codifica `UTF-8`. Per impostazione predefinita, i nomi dei campi snake_case corrispondono ai nomi delle variabili d'ambiente che sono una versione maiuscola di quei nomi. Per esempio, `app_secret` diventa `APP_SECRET`.      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO7-3)      Convalida che la variabile d'ambiente `DATABASE_URL` abbia un formato di stringa di connessione Postgres valido. Se non viene fornito, imposta il valore predefinito.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO7-4)      Controlla che la variabile d'ambiente `CORS_WHITELIST` abbia un elenco unico di URL validi con hostname e TLD. Se non viene fornita, imposta il default su un set con un unico valore di `http://localhost:3000`.      [![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO7-5)      Possiamo verificare che la classe `AppSettings` funzioni stampando un dump del modello.      ###### Nota    puoi cambiare i file di ambiente quando usi l'argomento `_env_file`:    ``` test_settings = AppSettings(_env_file=\"test.env\") ```py ````  ```py`## Classi di dati o modelli pidantici in FastAPI    Anche se le classi di dati supportano la serializzazione solo dei tipi più comuni (ad esempio, `int`, `str`, `list`, ecc.) e non eseguono la convalida dei campi a runtime, FastAPI può comunque lavorare sia con i modelli di Python che con le classi di dati di Python. Per la convalida dei campi e le funzioni aggiuntive, dovresti usare i modelli di Python. L['esempio 4-13](#dataclass_fastaspi) mostra come le classi di dati possono essere utilizzate nei gestori di rotte di FastAPI.    ##### Esempio 4-13\\. Utilizzo delle classi di dati in FastAPI    ``` # schemas.py  from dataclasses import dataclass from typing import Literal  @dataclass class TextModelRequest: ![1](assets/1.png)     model: Literal[\"tinyLlama\", \"gemma2b\"]     prompt: str     temperature: float  @dataclass class TextModelResponse: ![1](assets/1.png)     response: str     tokens: int  # main.py  from fastapi import Body, FastAPI, HTTPException, status from models import generate_text, load_text_model from schemas import TextModelRequest, TextModelResponse from utils import count_tokens  # load lifespan ...  app = FastAPI(lifespan=lifespan)  @app.post(\"/generate/text\") def serve_text_to_text_controller(     body: TextModelRequest = Body(...), ) -> TextModelResponse: ![2](assets/2.png) ![4](assets/4.png)     if body.model not in [\"tinyLlama\", \"gemma2b\"]: ![3](assets/3.png)         raise HTTPException(             detail=f\"Model {body.model} is not supported\",             status_code=status.HTTP_400_BAD_REQUEST,         )     output = generate_text(models[\"text\"], body.prompt, body.temperature)     tokens = count_tokens(body.prompt) + count_tokens(output)     return TextModelResponse(response=output, tokens=tokens) ![4](assets/4.png) ```py    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO8-1)      Definire i modelli per gli schemi di richiesta e risposta dei modelli di testo.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO8-3)      Convertire il gestore per servire le richieste di `POST` con un corpo. Quindi, dichiarare il corpo della richiesta come `TextModelRequest` e la risposta come `TextModelResponse`. I controllori statici del codice come `mypy` leggeranno le annotazioni di tipo e solleveranno avvisi se il controllore non restituisce il modello di risposta previsto.      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO8-5)      Verifica esplicitamente se il servizio supporta il parametro `model` fornito nella richiesta `body`. In caso contrario, restituisce al client una risposta di eccezione HTTP di richiesta errata.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO8-4)      FastAPI converte le classi di dati vanilla in classi di dati Pydantic per serializzare/deserializzare e validare i dati di richiesta e risposta.      Nell'[esempio 4-13](#dataclass_fastaspi), hai sfruttato le annotazioni di tipo facendo un refactoring del controller del modello di testo per renderlo resistente alle nuove modifiche e agli input errati dell'utente. I controllori statici di tipo possono ora aiutarti a individuare eventuali problemi relativi ai dati durante le modifiche. Inoltre, FastAPI ha usato le annotazioni di tipo per convalidare le richieste e le risposte insieme alla generazione automatica di una pagina di documentazione OpenAPI, come mostrato nella [Figura 4-2](#fastapi_dataclasses_docs).    Ora vedi che FastAPI sfrutta i modelli Pydantic per la gestione e la validazione dei dati, anche se utilizzi delle classi di dati vanilla. FastAPI converte le tue classi di dati vanilla in classi di dati Pydantic per utilizzare le sue funzioni di validazione dei dati. Questo comportamento è intenzionale perché se hai dei progetti con diverse annotazioni preesistenti sul tipo di classe di dati, puoi migrarle senza doverle riscrivere in modelli Pydantic per sfruttare le funzioni di convalida dei dati. Tuttavia, se stai iniziando un nuovo progetto, è consigliabile utilizzare direttamente i modelli Pydantic in sostituzione delle classi di dati integrate di Python.  ![bgai 0402](assets/bgai_0402.png)  ###### Figura 4-2\\. Generazione automatica di schemi di convalida utilizzando classi di dati vanilla    Vediamo ora come sostituire le classi di dati con Pydantic nella tua applicazione FastAPI. Vedi l'[Esempio 4-14](#pydantic_fastapi).    ##### Esempio 4-14\\. Utilizzo di Pydantic per modellare gli schemi di richiesta e risposta    ``` # main.py  from fastapi import Body, FastAPI, HTTPException, Request, status from models import generate_text from schemas import TextModelRequest, TextModelResponse ![1](assets/1.png)  # load lifespan ...  app = FastAPI(lifespan=lifespan)  @app.post(\"/generate/text\") ![2](assets/2.png) def serve_text_to_text_controller(     request: Request, body: TextModelRequest = Body(...) ) -> TextModelResponse:     if body.model not in [\"tinyLlama\", \"gemma2b\"]: ![3](assets/3.png)         raise HTTPException(             detail=f\"Model {body.model} is not supported\",             status_code=status.HTTP_400_BAD_REQUEST,         )     output = generate_text(models[\"text\"], body.prompt, body.temperature)     return TextModelResponse(content=output, ip=request.client.host) ![4](assets/4.png) ```py    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO9-1)      Importa i modelli Pydantic per gli schemi di richiesta e risposta dei modelli di testo.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO9-2)      Convertire il gestore per servire le richieste di `POST` con un corpo. Quindi, dichiarare il corpo della richiesta come `TextModelRequest` e la risposta come `TextModelResponse`. I controllori statici del codice come `mypy` leggeranno le annotazioni di tipo e solleveranno avvisi se il controllore non restituisce il modello di risposta previsto.      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO9-3)      Verifica esplicitamente se il servizio supporta il parametro `model` fornito nella richiesta `body`. In caso contrario, restituisce al client una risposta di eccezione HTTP di richiesta errata.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO9-4)      Restituire il modello `TextModelResponse` Pydantic come da digitazione della funzione. Accedere all'indirizzo IP del cliente utilizzando l'oggetto request tramite `request.client.host`. FastAPI si occuperà di serializzare il modello utilizzando `.model_dump()`. Dato che hai implementato anche i campi calcolati per le proprietà `tokens` e `cost`, questi saranno automaticamente inclusi nella risposta dell'API senza alcun lavoro aggiuntivo.      ###### Nota    Come mostrato nell'[Esempio 4-13](#dataclass_fastaspi), se utilizzi le classi di dati invece dei modelli Pydantic, FastAPI le convertirà in classi di dati Pydantic per serializzare/deserializzare e convalidare i dati della richiesta e della risposta. Tuttavia, potresti non essere in grado di sfruttare funzioni avanzate come i vincoli di campo e i campi calcolati con le classi di dati.    Come puoi vedere nell'[Esempio 4-14](#pydantic_fastapi), Pydantic può offrire un'esperienza eccezionale allo sviluppatore, aiutandolo nei controlli di tipo, nella convalida dei dati, nella serializzazione, nel completamento automatico dell'editor di codice e negli attributi calcolati.    FastAPI può anche utilizzare i tuoi modelli Pydantic per generare automaticamente una pagina di specifiche e documentazione OpenAPI, in modo che tu possa testare manualmente i tuoi endpointsenza problemi.    Una volta avviato il server, dovresti vedere una pagina di documentazione aggiornata con i nuovi modelli Pydantic e i campi vincolati aggiornati, come mostrato nella [Figura 4-3](#fastapi_pydnatic_models).  ![bgai 0403](assets/bgai_0403.png)  ###### Figura 4-3\\. Generazione automatica di documenti FastAPI utilizzando i modelli Pydantic    Se invii una richiesta all'endpoint `/generate/text`, dovresti vedere i campiprecompilati attraverso il modello Pydantic di `TextModelResponse`, come mostrato nell'[esempio 4-15](#fastapi_pydnatic_docs).    ##### Esempio 4-15\\. Popolamento automatico dei campi di risposta tramite il modello `TextModelResponse` Pydantic    ``` Request  curl -X 'POST' \\     'http://localhost:8000/generate/text' \\     -H 'accept: application/json' \\     -H 'Content-Type: application/json' \\     -d '{     \"prompt\": \"What is your name?\",     \"model\": \"tinyllama\",     \"temperature\": 0.01 }'  http://localhost:8000/generate/text  >> Response body {     \"request_id\": \"7541204d5c684f429fe43ccf360fЗ3dc\",     \"ip\": \"127.0.0.1\"     \"content\": \"I am not a person. However, I can provide you with information         about my name. My name is fastapi bot.\",     \"created_at\": \"2024-03-07T16:06:57.492039\",     \"price\": 0.01,     \"tokens\": 25,     \"cost\": 0.25 }  >> Response headers  content-length: 259 content-type: application/json date: Thu, 07 Mar 2024 16:07:01 GMT server: uvicorn x-response-time: 22.9243 ```py    Le caratteristiche del modello Pydantic che ho trattato in questo capitolo rappresentano solo una parte degli strumenti a tua disposizione per costruire servizi GenAI. Dovresti ora sentirti più sicuro nello sfruttare Pydantic per annotare i tuoi servizi per migliorare la loro affidabilità e la tua esperienza di sviluppatore .```` ```py`` `````", "``````py` ``````", "```````py````  ```py` ``` ``# Riassunto    In questo capitolo hai appreso l'importanza di creare servizi completamente tipizzati per i modelli GenAI. Ora sai come implementare la sicurezza dei tipi con tipi standard e vincolati, come utilizzare i modelli Pydantic per la convalida dei dati e come implementare i tuoi validatori di dati personalizzati nel tuo servizio GenAI. Hai anche scoperto le strategie per convalidare i contenuti delle richieste e delle risposte e per gestire le impostazioni dell'applicazione con Pydantic per prevenire i bug e migliorare l'esperienza di sviluppo. Nel complesso, seguendo gli esempi pratici, hai imparato come implementare un servizio GenAI robusto e meno soggetto a errori.    Il capitolo successivo tratta la programmazione asincrona nei carichi di lavoro dell'intelligenza artificiale, discutendo le prestazioni e le operazioni parallele. Imparerai a conoscere meglio i task legati all'I/O e quelli legati alla CPU e capirai il ruolo e i limiti dei task in background di FastAPI con i flussi di lavoro concorrenti.    ^([1](ch04.html#id749-marker)) Un [tipo`Literal`](https://oreil.ly/69Pmn) può essere utilizzato per indicare ai verificatori di tipo che l'oggetto annotato ha un valore equivalente a uno dei letterali forniti.    ^([2](ch04.html#id750-marker)) Il sito `tiktoken` di OpenAI utilizza l'[algoritmo*Byte-Pair Encoding* (BPE)](https://oreil.ly/l67GS) per tokenizzare il testo. Modelli diversi utilizzano codifiche diverse per convertire il testo in token.    ^([3](ch04.html#id762-marker)) Anche le strutture nei linguaggi simili al C e le classi di dati in Python possono essere utilizzate per raggruppare e passare i dati.`` ```py ```` ```py```````", "```````"]