- en: 3 Blind search algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 盲搜索算法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Applying different graph types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用不同的图类型
- en: Graph search algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图搜索算法
- en: Using graph traversal algorithms to find a path between two nodes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图遍历算法在两个节点之间找到路径
- en: Using blind search algorithms to find the shortest path between two nodes in
    a graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用盲搜索算法在图中的两个节点之间找到最短路径
- en: Solving a real-world routing problem using graph search algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图搜索算法解决现实世界的路由问题
- en: You were introduced to deterministic and stochastic algorithms in chapter 2\.
    In this chapter, we will focus on deterministic algorithms, specifically blind
    search algorithms, and their applications in exploring tree or graph structures
    and finding the shortest path between nodes. Using these algorithms, you can explore
    a maze from an initial state to a goal state, solve *n*-puzzle problems, figure
    out the distance between you and any other person on a social media graph, search
    a family tree to determine the exact relationship between any two related people,
    or find the shortest path between any origin (e.g., your home) and any destination.
    Blind search algorithms are important, as they are often more efficient and practical
    to use when dealing with simple, well-defined problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，您已经介绍了确定性和随机性算法。在本章中，我们将重点关注确定性算法，特别是盲搜索算法，以及它们在探索树或图结构以及找到节点之间最短路径中的应用。使用这些算法，您可以从一个初始状态探索迷宫到目标状态，解决*n*-拼图问题，确定社交媒体图中您与其他任何人的距离，搜索家谱以确定任何两个相关人员的确切关系，或者找到任何起点（例如，您的家）和任何目的地之间的最短路径。盲搜索算法很重要，因为当处理简单、定义明确的问题时，它们通常更高效且实用。
- en: 3.1 Introduction to graphs
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 图的介绍
- en: A *graph* is a nonlinear data structure composed of entities known as *vertices*
    (or nodes) and the relationships between them, known as *edges* (or *arcs* or
    *links*). This data structure does not follow a sequential pattern, making it
    *nonlinear*, unlike arrays, stacks, or queues, which are linear structures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*图*是一个由称为*顶点*（或节点）和它们之间的关系组成的非线性数据结构，称为*边*（或*弧*或*链接*）。这种数据结构不遵循顺序模式，因此是非线性的，与数组、栈或队列等线性结构不同。
- en: A graph can be represented mathematically by *G*, where *G* = (*V, E*). *V*
    represents the set of nodes or vertices, and *E* represents the set of edges or
    links. Various attributes can also be added as components to the edge tuple, such
    as edge length, capacity, or any other unique properties (e.g., road material).
    Graphs can be classified as undirected, directed, multigraph, acyclic, and hypergraphs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图可以用数学上的*G*表示，其中*G* = (*V, E*)。*V*表示节点或顶点的集合，*E*表示边或链接的集合。还可以将各种属性作为组件添加到边元组中，例如边长、容量或任何其他独特属性（例如，道路材料）。图可以分为无向、有向、多重图、无环和超图。
- en: An *undirected graph* is one where a set of nodes are connected using bidirectional
    edges. This means that the order of two connected nodes is not essential.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*无向图*是一个使用双向边连接节点集的图。这意味着两个连接节点的顺序不是必要的。
- en: NetworkX is a commonly used Python library for creating, manipulating, and studying
    the structure, dynamics, and functions of graphs and complex networks (see appendix
    A for more information about graph libraries). The following listing shows how
    you can use NetworkX to create an undirected graph.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX是一个常用的Python库，用于创建、操作和研究图和复杂网络的结构、动态和功能（有关图库的更多信息，请参阅附录A）。以下列表显示了如何使用NetworkX创建无向图。
- en: Listing 3.1 Creating an undirected graph using NetworkX
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 使用NetworkX创建无向图
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Generate a list of nodes from 0 to 4.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从0到4生成节点列表。
- en: ② Define a list of edges.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义边列表。
- en: The output of this code is shown in figure 3.1\. The actual layout you get might
    be different, but the connections among the vertices will be the same as shown
    here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的输出显示在图3.1中。您实际得到的布局可能不同，但顶点之间的连接将与这里显示的相同。
- en: '![](../Images/CH03_F01_Khamis.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F01_Khamis.png)'
- en: Figure 3.1 An undirected graph
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 无向图
- en: A *directed graph* is a graph in which a set of nodes are connected using directional
    edges. Directed graphs have many applications, such as representing flow constraints
    (e.g., one-way streets), relations (e.g., causal relationships), and dependencies
    (e.g., tasks that depend on the completion of other tasks). The following listing
    shows how to use NetworkX to create a directed graph.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**有向图**是一种使用方向边连接节点集的图。有向图有许多应用，例如表示流量约束（例如单向街道）、关系（例如因果关系）和依赖关系（例如依赖于其他任务完成的任务）。以下列表展示了如何使用NetworkX创建有向图。'
- en: Listing 3.2 Creating a directed graph using NetworkX
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 使用NetworkX创建有向图
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① DiGraph allows for directed edges.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ① DiGraph允许有向边。
- en: The code output is shown in figure 3.2\. Note the arrows indicating the edge
    directions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码输出显示在图3.2中。注意指示边方向的箭头。
- en: '![](../Images/CH03_F02_Khamis.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02_Khamis.png)'
- en: Figure 3.2 A directed graph
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 一个有向图
- en: A *multigraph* is a graph in which multiple edges may connect the same pair
    of vertices. These edges are called *parallel edges*. Multigraphs can be used
    to represent complex relationships between nodes, such as multiple parallel roads
    between two locations in traffic routing, multiple capacities and demands in resource
    allocation problems, and multiple relationships between individuals in social
    networks, to name just a few. Unfortunately, NetworkX is not particularly good
    at visualizing multigraphs with parallel edges. This listing shows how you can
    use NetworkX in conjunction with the Matplotlib library to create a multigraph.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**多图**是一种可能连接相同顶点对的多条边的图。这些边称为**平行边**。多图可以用来表示节点之间的复杂关系，例如交通路由中两个位置之间的多条并行道路、资源分配问题中的多个容量和需求，以及社交网络中个人之间的多个关系，仅举几例。不幸的是，NetworkX在可视化具有平行边的多图方面并不特别擅长。以下列表展示了如何结合使用NetworkX和Matplotlib库创建多图。'
- en: Listing 3.3 Creating a multigraph using NetworkX
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 使用NetworkX创建多图
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Node positions are generated using the Kamada-Kawai path-length cost function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用Kamada-Kawai路径长度成本函数生成节点位置。
- en: ② Draw each edge one at a time, modifying the curvature of the edge based on
    its index (i.e., the second edge between nodes 0 and 1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ② 逐个绘制每条边，根据其索引（即节点0和1之间的第二条边）修改边的曲率。
- en: ③ Draw nodes and node labels.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 绘制节点和节点标签。
- en: It is worth noting that `kamada_kawai_layout` attempts to position nodes on
    the space so that the geometric (Euclidean) distance between them is as close
    as possible to the graph-theoretic (path) distance between them. Figure 3.3 shows
    an example of a multigraph generated by this code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`kamada_kawai_layout`试图在空间中定位节点，使得它们之间的几何（欧几里得）距离尽可能接近它们之间的图论（路径）距离。图3.3展示了由该代码生成的多图示例。
- en: '![](../Images/CH03_F03_Khamis.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Khamis.png)'
- en: Figure 3.3 Example of a multigraph. Notice the three parallel edges connecting
    nodes 0 and 1, as well as the two edges connecting nodes 3 and 4.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 多图示例。注意连接节点0和1的三条平行边，以及连接节点3和4的两条边。
- en: As the name implies, an *acyclic graph* is a graph without cycles. A *tree*,
    as a specialized case of a graph, is a connected graph with no cycles or self-loops.
    In graph theory, a connected graph is a type of graph in which there is a path
    between every pair of vertices. A *cycle*, also called a *self-loop* or a *circuit*,
    is an edge in a graph that connects a vertex (or node) to itself. In task scheduling,
    acyclic graphs can be used to represent the relationships between tasks where
    each node represents a task and each directed edge represents a precedence constraint.
    This constraint means that the task represented by the end node cannot start until
    the task represented by the start node is completed. We’ll discuss the assembly
    line balancing problem in chapter 6 as an example of scheduling problems.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，一个**无环图**是一个没有环的图。**树**作为图的特例，是一个没有环或自环的连通图。在图论中，一个连通图是一种图中每对顶点之间都存在路径的图。**环**，也称为**自环**或**回路**，是图中连接一个顶点（或节点）到自身的边。在任务调度中，无环图可以用来表示任务之间的关系，其中每个节点代表一个任务，每条有向边代表一个优先约束。这种约束意味着表示终点节点的任务不能开始，直到表示起点节点的任务完成。我们将在第6章中以装配线平衡问题作为调度问题的例子进行讨论。
- en: The following listing shows how you can use NetworkX to create and verify an
    acyclic graph. An example of an acyclic graph is shown in figure 3.4
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使用NetworkX创建和验证无环图。图3.4展示了无环图的一个示例。
- en: Listing 3.4 Creating an acyclic graph using NetworkX
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 使用NetworkX创建无环图
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Check if the graph is acyclic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ① 检查图是否无环。
- en: '![](../Images/CH03_F04_Khamis.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F04_Khamis.png)'
- en: Figure 3.4 An acyclic graph—no path cycles back to any starting node.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4无环图——没有路径会回到任何起始节点。
- en: A *hypergraph* is a generalization of a graph in which the generalized edges
    (called *hyperedges*) can join any number of nodes. Hypergraphs are used to represent
    complex networks because they can capture higher-order many-to-many relationships.
    They’re used in domains such as social media, information systems, computational
    geometry, computational pathology, and neuroscience. For example, a group of people
    working on a project can be represented by a hypergraph. Each person is represented
    by a node, and the project is represented by a hyperedge. The hyperedge connects
    all the people working on the project, regardless of how many people are involved.
    The hyperedge can also contain other attributes, such as the project’s name, the
    start and end dates, the budget, etc.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*超图*是图的推广，其中推广的边（称为*超边*）可以连接任意数量的节点。超图用于表示复杂网络，因为它们可以捕捉更高阶的多对多关系。它们被用于社交媒体、信息系统、计算几何、计算病理学和神经科学等领域。例如，一个在项目上工作的团队可以用超图来表示。每个人由一个节点表示，项目由一个超边表示。超边连接所有参与项目的人，无论涉及多少人。超边还可以包含其他属性，如项目的名称、开始和结束日期、预算等。'
- en: The following listing shows how you can use HyperNetX (HNX) to create a hypergraph.
    HNX is a Python library that enables us to model the entities and relationships
    found in complex networks as hypergraphs. Figure 3.5 shows an example of a hypergraph.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何使用HyperNetX（HNX）来创建超图。HNX是一个Python库，它使我们能够将复杂网络中发现的实体和关系建模为超图。图3.5展示了超图的一个示例。
- en: Listing 3.5 Creating a hypergraph using HyperNetX
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 使用HyperNetX创建超图
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① The data for the hypergraph comes as key-value pairs of hyperedge name/hyperedge
    node groups.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ① 超图的数据以超边名称/超边节点组的键值对形式提供。
- en: ② Create a hypergraph for the provided data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为提供的数据创建超图。
- en: ③ Visualize the hypergraph.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 可视化超图。
- en: '![](../Images/CH03_F05_Khamis.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F05_Khamis.png)'
- en: Figure 3.5 An example of a hypergraph. Hyperedges can connect more than two
    nodes, such as hyperedge 0, which links nodes A, B, and G.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5超图的示例。超边可以连接超过两个节点，例如超边0，它连接节点A、B和G。
- en: Graphs can also be weighted or unweighted. In a *weighted graph*, a weight,
    or value, is assigned to each edge. For example, in the case of road networks,
    the edges could have weights that represent the cost of traversing the road. This
    weight could represent distance, time, or any other metric. In telecommunications
    networks, the weight might represent the cost of utilizing that edge or the strength
    of the connections between the communication devices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图也可以是有权或无权的。在*加权图*中，每个边都分配一个权重或值。例如，在道路网络的情况下，边可以有代表穿越道路成本的权重。这个权重可以代表距离、时间或任何其他度量。在电信网络中，权重可能代表使用该边的成本或通信设备之间连接的强度。
- en: Listing 3.6 shows how you could create and visualize a weighted graph between
    telecommunication devices. The weights in this example represent the speed of
    connections between the devices in Mbps. Running this code generated the weighted
    graph in figure 3.6.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6展示了如何创建和可视化电信设备之间的加权图。在这个例子中，权重代表设备之间连接的速度，单位为Mbps。运行此代码生成了图3.6所示的加权图。
- en: Listing 3.6 Creating a weighted graph using NetworkX
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 使用NetworkX创建加权图
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Create an empty weighted graph.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个空的加权图。
- en: ② Add nodes to the graph (representing devices).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ② 向图中添加节点（代表设备）。
- en: ③ Add weighted edges to the graph (representing connections).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 向图中添加加权边（代表连接）。
- en: ④ Get node position attributes from the graph.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 从图中获取节点位置属性。
- en: ⑤ Draw the graph.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 绘制图。
- en: '![](../Images/CH03_F06_Khamis.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F06_Khamis.png)'
- en: Figure 3.6 Example of a weighted graph
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6加权图的示例
- en: Graphs are everywhere. Search engines like Google see the internet as a giant
    graph where each web page is a node, and two pages are joined by an edge if there
    is a link from one page to the other. A social media platform like Facebook treats
    each user profile as a node on a social graph, and two nodes are said to be connected
    if they are each other’s friends or have social ties. The concept of “following”
    a user, such as on a platform like X (previously Twitter), can be represented
    by a directional edge, where user *A* can follow user *B*, but the reverse is
    not necessarily true. Table 3.1 shows the meanings of nodes and edges on different
    social media platforms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图无处不在。搜索引擎如谷歌将互联网视为一个巨大的图，其中每个网页都是一个节点，如果从一个页面有链接指向另一个页面，则两个页面通过边连接。社交媒体平台如Facebook将每个用户资料视为社交图上的一个节点，如果两个节点互为好友或存在社交联系，则称它们是连接的。在像X（以前是Twitter）这样的平台上“关注”用户的概念可以通过一个有向边表示，其中用户*A*可以关注用户*B*，但反之不一定成立。表3.1显示了不同社交媒体平台上节点和边的含义。
- en: Table 3.1 Examples of graphs in the context of social media
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 社交媒体背景下的图示例
- en: '| Social media platform | Nodes | Edges | Type of edge |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 社交媒体平台 | 节点 | 边 | 边的类型 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Facebook | Users, groups, posts, and events | Friendship, group membership,
    messages, creation of posts, and reactions on posts | Undirected: a like, or react,
    or commentDirected: a friend request |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Facebook | 用户、群组、帖子以及活动 | 友谊、群组成员、消息、发帖以及帖子上的反应 | 无向：点赞、评论或反应；有向：好友请求 |'
- en: '| X (previously Twitter) | Users, groups, unregistered persons, and posts |
    Following, group membership, messages, creation of posts, and reactions on posts
    | Undirected: a mention or a retweetDirected: the following relationship (when
    you follow a person, they do not automatically follow you back) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| X（以前是Twitter） | 用户、群组、未注册人员和帖子 | 关注、群组成员、消息、发帖以及帖子上的反应 | 无向：提及或转发；有向：关注关系（当你关注一个人时，他们不会自动回关你）
    |'
- en: '| LinkedIn | Users, groups, unregistered persons, posts, skills, and jobs |
    Connections, group membership, posting, reactions on posts, messages, endorsements,
    invitations, recommending jobs | Undirected: an endorsement or recommendationDirected:
    a connection |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 领英 | 用户、群组、未注册人员、帖子、技能和职位 | 联系、群组成员、发帖、帖子上的反应、消息、推荐、邀请、推荐职位 | 无向：推荐或推荐；有向：一个联系
    |'
- en: '| Instagram | Users, comments, containers for publishing posts, hashtags, media
    (e.g., photo, video, story, or album), and pages (Facebook page) | Relationships
    between users such as following, liking, and commenting | Undirected: a like or
    a commentDirected: a follow relationship |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Instagram | 用户、评论、发布帖子的容器、标签、媒体（例如，照片、视频、故事或专辑）以及页面（Facebook页面） | 用户之间的关系，如关注、点赞和评论
    | 无向：点赞或评论；有向：关注关系 |'
- en: '| TikTok | Users, videos, hashtags, locations, and keywords | Relationships
    between users such as following, liking, and commenting | Undirected: a like or
    commentDirected: a follow relationship |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| TikTok | 用户、视频、标签、位置和关键词 | 用户之间的关系，如关注、点赞和评论 | 无向：点赞或评论；有向：关注关系 |'
- en: In a road network graph, the nodes represent landmarks such as intersections
    and points of interest (POI), and the edges represent the roads. In such a graph,
    most of the edges are directed, meaning that they have specific directions, and
    they may have additional information such as length, speed limit, capacity, etc.
    Each edge is a two-endpoint connection between two nodes, where the direction
    of the edge represents the direction of traffic flow. A *route* is a sequence
    of edges connecting the origin node to the destination node.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在道路网络图中，节点代表地标，如交叉口和兴趣点（POI），边代表道路。在这样的图中，大多数边都是有向的，这意味着它们有特定的方向，并且可能包含额外的信息，如长度、速度限制、容量等。每条边是两个节点之间的两端点连接，其中边的方向代表交通流的方向。*路线*是一系列连接起点节点和终点节点的边。
- en: OSMnx is a Python library developed to simplify the retrieving and manipulating
    of data from OpenStreetMap (OSM; openstreetmap.org). OSM is a crowdsourced geographic
    database of the world (see appendix B for more information about how to fetch
    data from open geospatial data sources). OSMnx lets you download filtered data
    from OSM and returns the network as a NetworkX graph data structure. It can also
    convert a text descriptor of a place into a NetworkX graph (see appendix A for
    more information about graph and mapping libraries). The following listing uses
    the University of Toronto as an example.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: OSMnx 是一个 Python 库，旨在简化从 OpenStreetMap (OSM; openstreetmap.org) 获取和操作数据。OSM
    是一个全球性的众包地理数据库（有关如何从开放地理空间数据源获取数据的更多信息，请参阅附录 B）。OSMnx 允许您从 OSM 下载过滤后的数据，并以 NetworkX
    图数据结构返回网络。它还可以将地点的文本描述符转换为 NetworkX 图（有关图和映射库的更多信息，请参阅附录 A）。以下列表以多伦多大学为例。
- en: Listing 3.7 University of Toronto example
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 多伦多大学示例
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① A graph_from_address can also take city names and mailing addresses as input.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ① graph_from_address 也可以接受城市名称和邮寄地址作为输入。
- en: Figure 3.7 shows an OSM map of the area around the St. George campus of the
    University of Toronto. The graph shows the edges and nodes of the road network
    surrounding the campus in downtown Toronto.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 显示了多伦多大学圣乔治校园周边的 OSM 地图。图中显示了多伦多市中心校园周边的道路网络节点和边。
- en: '![](../Images/CH03_F07_Khamis.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F07_Khamis.png)'
- en: Figure 3.7 St. George campus, University of Toronto
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 多伦多大学圣乔治校园
- en: While the map may look visually interesting, it lacks the context of surrounding
    geographic features. Let’s use the folium library (see appendix A) to create a
    base layer map with street names, neighborhood names, and even building footprints.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然地图可能看起来在视觉上很有趣，但它缺乏周围地理特征的上下文。让我们使用 folium 库（请参阅附录 A）创建一个带有街道名称、社区名称甚至建筑足迹的基础层地图。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Figure 3.8 shows the road network surrounding the St. George campus.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 显示了圣乔治校园周边的道路网络。
- en: '![](../Images/CH03_F08_Khamis.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F08_Khamis.png)'
- en: Figure 3.8 Road network around St. George campus, University of Toronto
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 显示了多伦多大学圣乔治校园周边的道路网络。
- en: Suppose you want to get from one location to another on this campus. For example,
    imagine you’re starting at the King Edward VII equestrian statue near Queen’s
    Park in Toronto, and you need to cross the campus to attend a lecture at the Bahen
    Centre for Information Technology. Later in this chapter, you will see how you
    can calculate the shortest path between these two points.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在这所校园内从一个地点到另一个地点。例如，想象您从多伦多皇后公园附近的国王爱德华七世骑马雕像出发，需要穿越校园去巴嫩信息技术中心参加讲座。在本章的后面部分，您将看到如何计算这两个点之间的最短路径。
- en: For now, let’s just plot these two locations on the map using the folium library.
    Figure 3.9 shows the folium map and markers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们仅使用 folium 库将这些两个地点绘制在地图上。图 3.9 显示了 folium 地图和标记。
- en: Listing 3.8 Plotting with folium
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 使用 folium 绘图
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① The GPS coordinates (latitude and longitude) of the University of Toronto
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ① 多伦多大学的 GPS 坐标（纬度和经度）
- en: ② The GPS coordinates of the equestrian statue as a source point
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ② 骑马雕像的 GPS 坐标作为源点
- en: ③ The GPS coordinates of the Bahen Centre for Information Technology as the
    destination
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 巴嫩信息技术中心的 GPS 坐标作为目的地
- en: ④ Create a map centered around a specified point.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建以指定点为中心的地图。
- en: ⑤ Add markers wih icons.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 添加带有图标的标记。
- en: '![](../Images/CH03_F09_Khamis.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F09_Khamis.png)'
- en: Figure 3.9 Visualizing points of interest using folium markers
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 使用 folium 标记可视化兴趣点
- en: The output of the code is interactive and allows for features such as zooming,
    panning, and even layer filtering (when enabled). Appendix A provides more details
    about map visualization libraries in Python.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出是交互式的，允许进行缩放、平移甚至图层过滤（当启用时）。附录 A 提供了有关 Python 中地图可视化库的更多详细信息。
- en: 3.2 Graph search
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 图搜索
- en: As I mentioned in chapter 2, search algorithms can be broadly classified into
    deterministic and stochastic algorithms. In *deterministic search*, the search
    algorithm follows a rigorous procedure, and its path and the values of both the
    design variables and the functions are repeatable. The algorithm will follow the
    same path for the same starting point whenever you run the program, whether it’s
    today or ten years in the future. In *stochastic search*, on the other hand, the
    algorithm always has some randomness, and the solution is not exactly repeatable.
    Each time you run the algorithm, you may get slightly different results.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在第二章中提到的，搜索算法可以广泛分为确定性和随机性算法。在*确定性搜索*中，搜索算法遵循严格的程序，其路径以及设计变量和函数的值是可重复的。无论您今天运行程序还是十年后运行，只要起始点相同，算法都会遵循相同的路径。另一方面，在*随机搜索*中，算法总是存在一些随机性，解决方案并不完全可重复。每次运行算法时，您可能会得到略微不同的结果。
- en: Based on the availability of information about the search space or domain knowledge
    (e.g., the distance from the current state to the goal), deterministic search
    algorithms can be broadly classified into *blind* (or *uninformed*) search and
    *informed* search, as illustrated in figure 3.10\. Some of these algorithms, such
    as Kruskal’s minimum spanning tree (MST) algorithm, will be covered in the next
    chapter. This chapter focuses on blind search algorithms. Blind search is a search
    approach where no information about the search space is needed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据搜索空间或领域知识（例如，从当前状态到目标的状态距离）的可用性，确定性搜索算法可以广泛分为*盲目*（或*无信息*）搜索和*信息*搜索，如图3.10所示。其中一些算法，如Kruskal的最小生成树（MST）算法，将在下一章中介绍。本章重点介绍盲目搜索算法。盲目搜索是一种不需要关于搜索空间信息的搜索方法。
- en: '![](../Images/CH03_F10_Khamis.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F10_Khamis.png)'
- en: Figure 3.10 Graph search methods
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 图搜索方法
- en: A blind search may conclude upon discovering the first solution, depending on
    the algorithm’s termination criteria. However, the search space may contain numerous
    valid but non-optimal solutions, so a blind search may return a solution that
    meets all the requirements but does so in a non-optimal way. An optimal solution
    can be found by running a blind search following an exhaustive search or brute-force
    strategy to find all the feasible solutions, which can then be compared to select
    the best one. This is similar to applying the British Museum algorithm, which
    finds a solution by checking all possibilities one by one. Given the fact that
    blind search treats every node in the graph or tree equally, this search approach
    is often referred to as a *uniform search*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 盲目搜索可能在发现第一个解决方案时结束，这取决于算法的终止条件。然而，搜索空间可能包含许多有效但非最优的解决方案，因此盲目搜索可能会返回一个满足所有要求但以非最优方式实现的解决方案。可以通过运行一个盲搜索，在穷举搜索或暴力搜索策略之后找到所有可行的解决方案，然后进行比较以选择最佳方案。这类似于应用大英博物馆算法，该算法通过逐一检查所有可能性来找到解决方案。鉴于盲目搜索对待图或树中的每个节点都是平等的，这种搜索方法通常被称为*均匀搜索*。
- en: 'Examples of blind search algorithms include, but are not limited to, the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 盲目搜索算法的例子包括但不限于以下内容：
- en: '*Breadth-first search* (BFS) is a graph traversal algorithm that builds the
    search tree by levels.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*广度优先搜索*（BFS）是一种图遍历算法，通过层次结构构建搜索树。'
- en: '*Depth-first search* (DFS) is a graph traversal algorithm that first explores
    nodes going through one adjacent to the root, then the next adjacent, until it
    finds a solution or it reaches a dead end.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深度优先搜索*（DFS）是一种图遍历算法，首先探索通过根节点的一个相邻节点，然后是下一个相邻节点，直到找到解决方案或达到死胡同。'
- en: '*Depth-limited search* (DLS) is a DFS with a predetermined depth limit.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深度限制搜索*（DLS）是一种具有预定深度限制的DFS。'
- en: '*Iterative deepening search* (IDS), or *iterative deepening depth-first search*
    (IDDFS), combines DFS’s space efficiency and BFS’s fast search by incrementing
    the depth limit until the goal is reached.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代加深搜索*（IDS），或*迭代加深深度优先搜索*（IDDFS），结合了DFS的空间效率和 BFS的快速搜索，通过增加深度限制直到达到目标。'
- en: '*Dijkstra’s algorithm* solves the single-source shortest-path problem for a
    weighted graph with non-negative edge costs.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dijkstra算法*用于解决具有非负边成本的加权图的单源最短路径问题。'
- en: '*Uniform-cost* search (UCS) is a variant of Dijkstra’s algorithm that uses
    the lowest cumulative cost to find a path from the source to the destination.
    It is equivalent to the BFS algorithm if the path cost of all edges is the same.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致代价*搜索（UCS）是迪杰斯特拉算法的一种变体，它使用最低的累积代价来找到从源到目的地的路径。如果所有边的路径代价相同，则它与BFS算法等价。'
- en: '*Bidirectional* search (BS) is a combination of forward and backward search.
    It searches forward from the start and backward from the goal simultaneously.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双向*搜索（BS）是正向搜索和反向搜索的结合。它同时从起点向前搜索，从目标向后搜索。'
- en: The following sections discuss graph traversal algorithms and shortest path
    algorithms, focusing on BFS, DFS, Dijkstra’s algorithm, UCS, and BS as examples
    of blind search approaches.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节讨论图遍历算法和最短路径算法，重点关注BFS、DFS、迪杰斯特拉算法、UCS和BS作为盲目搜索方法的例子。
- en: 3.3 Graph traversal algorithms
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 图遍历算法
- en: Graph traversal is the process of exploring the structure of a tree or a graph
    by visiting the nodes following a specific, well-defined rule. This category of
    graph search algorithms only seeks to find a path between two nodes without optimizing
    for the length of the final route.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图遍历是通过访问节点并遵循特定的、明确定义规则来探索树或图结构的过程。这类图搜索算法仅寻求找到两个节点之间的路径，而不优化最终路径的长度。
- en: 3.3.1 Breadth-first search
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 广度优先搜索
- en: Breadth-first search (BFS) is an algorithm where the traversal starts at a specified
    node (the source or starting node) and follows the graph layerwise, thus exploring
    all of the current node’s neighboring nodes (those directly connected to the current
    node). Then, if a result has not been found, the algorithm searches the next-level
    neighbor nodes. This algorithm finds a solution if one exists, assuming that a
    finite number of successors, or branches, always follow any node. Algorithm 3.1
    shows the BFS steps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）是一种算法，其遍历从指定的节点（源或起始节点）开始，逐层遍历图，从而探索当前节点的所有相邻节点（与当前节点直接相连的节点）。然后，如果没有找到结果，算法将搜索下一级相邻节点。如果存在解决方案，此算法可以找到解决方案，假设任何节点总是有有限数量的后继者或分支。算法3.1显示了BFS步骤。
- en: Algorithm 3.1 Breadth-first search (BFS)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 算法3.1 广度优先搜索（BFS）
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: BFS uses the queue as a data structure to maintain the states to be explored.
    A queue is a first in, first out (FIFO) data structure, where the node that has
    been sitting on the queue for the longest time is the next node to be expanded.
    BFS dequeues a state off the queue and then enqueues its successors back on the
    queue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: BFS使用队列作为数据结构来维护要探索的状态。队列是一种先进先出（FIFO）数据结构，其中在队列上等待时间最长的节点是下一个要扩展的节点。BFS从队列中删除一个状态，然后将其后继者重新入队到队列中。
- en: 'Let’s consider the 8-puzzle problem (sometimes called the *sliding-block problem*
    or *tile-puzzle problem*). The puzzle consists of an area divided into a 3 × 3
    grid. The tiles are numbered 1 through 8, except for an empty (or blank) tile.
    The blank tile can be moved by swapping its position with any tile directly adjacent
    (up, down, left, right). The puzzle’s goal is to place the tiles so that they
    are arranged in order. Variations of the puzzle allow the empty tile to end up
    either at the first or last position. This problem is an example of a well-structured
    problem (WSP) with the following well-defined components:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑8数码问题（有时称为*滑动块问题*或*拼图问题*）。这个拼图由一个分成3×3网格的区域组成。瓷砖编号为1到8，除了一个空（或空白）瓷砖。空白瓷砖可以通过与其直接相邻的任何瓷砖交换位置来移动（上、下、左、右）。拼图的目的是将瓷砖排列成顺序。拼图的变体允许空白瓷砖最终位于第一个或最后一个位置。这个问题是一个具有以下明确定义组件的良好结构问题（WSP）的例子：
- en: States—Location of the blank and location of the eight tiles
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态—空白瓷砖的位置和八个瓷砖的位置
- en: Operator (successor)—Blank moves left, right, up, and down
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符（后继者）—空白瓷砖向左、右、上、下移动
- en: Goal—Match the state given by the goal state
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标—匹配给定的目标状态
- en: Solution/path—Sequence through state space
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案/路径—通过状态空间的状态序列
- en: Stopping criteria—An ordered puzzle (reaching the Goal state)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止标准—有序拼图（达到目标状态）
- en: Evaluation criteria—Number of steps or path cost (the path length)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估标准—步数或路径成本（路径长度）
- en: Figure 3.11 illustrates the BFS steps for solving the 8-puzzle problem and the
    search tree traversal order. In this figure, the state represents the physical
    configuration of the 8-puzzle problem, and each node in the search tree is a data
    structure that includes information about its parent, children, depth, and the
    cost of the path from the initial state to this node. Level 1 nodes are generated
    from left to right by moving the blank title left, up, and right respectively.
    Moving forward, level 2 nodes are generated by expanding the previously generated
    nodes in level 1, avoiding the previously explored nodes. We keep repeating this
    procedure to traverse all the possible nodes or until we hit the goal (the shaded
    grid). The number of steps to reach the goal will depend mainly on the initial
    state of the 8-puzzle board. The highlighted numbers show the order of traverse.
    As you can see, BFS progresses horizontally before it proceeds vertically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11展示了使用BFS解决8个拼图问题的步骤和搜索树遍历顺序。在这个图中，状态代表8个拼图问题的物理配置，搜索树中的每个节点都是一个包含其父节点、子节点、深度和从初始状态到该节点的路径成本的数据结构。第1层节点通过分别向左、上、右移动空白标题从左到右生成。向前移动，第2层节点通过扩展第1层中先前生成的节点生成，避免先前探索的节点。我们重复执行此程序以遍历所有可能的节点或直到达到目标（阴影网格）。达到目标所需的步数主要取决于8个拼图板的初始状态。突出显示的数字显示了遍历的顺序。如您所见，BFS在垂直之前先水平前进。
- en: '![](../Images/CH03_F11_Khamis.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F11_Khamis.png)'
- en: Figure 3.11 Using BFS to solve the 8-puzzle problem
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 使用BFS解决8个拼图问题
- en: Listing 3.9 utilizes a generic BFS algorithm developed for this book, which
    can be found in the Optimization Algorithm Tools (optalgotools) Python package
    (see appendix A for installation instructions). The algorithm takes starting and
    goal states as inputs and returns a `solution` object. This `solution` object
    contains the actual result and some performance metrics, such as processing time,
    maximum space used, and the number of solution states explored. The `State` class
    and `visualize` function are defined in the complete listing available in the
    book’s GitHub repo. The `State` class helps manage some data structures and utility
    functions, and it will allow us to reuse this problem’s structure later with different
    algorithms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9使用了为本书开发的通用BFS算法，该算法可在Optimization Algorithm Tools (optalgotools) Python包中找到（安装说明见附录A）。该算法以起始状态和目标状态作为输入，并返回一个`solution`对象。这个`solution`对象包含实际结果和一些性能指标，例如处理时间、最大空间使用量和已探索的解决方案状态数量。`State`类和`visualize`函数定义在书中GitHub仓库中可用的完整列表中。`State`类帮助管理一些数据结构和实用函数，并允许我们以后使用不同的算法重用此问题的结构。
- en: Listing 3.9 Solving the 8-puzzle problem using BFS
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 使用BFS解决8个拼图问题
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① The BFS algorithm is imported from a library called optalgotools.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从名为optalgotools的库中导入BFS算法。
- en: ② See the State class in the complete listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ② 请参阅完整列表中的State类。
- en: ③ Some boards are not solvable
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 有些拼图板是无法解决的
- en: ④ See the visualize function in the complete listing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 请参阅完整列表中的可视化函数。
- en: 'This is an example solution, given the preceding inputs:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例解决方案，基于前面的输入：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Figure 3.12 shows the state changes following the BFS algorithm.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12显示了BFS算法后的状态变化。
- en: '![](../Images/CH03_F12_Khamis.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F12_Khamis.png)'
- en: Figure 3.12 The step-by-step BFS solution using Python. BFS searches for a solution
    but does not consider optimality.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 使用Python逐步BFS解决方案。BFS寻找解决方案但不考虑最优性。
- en: To really understand how BFS works, let’s look at the steps involved in a simple
    path-planning problem. This problem finds a collision-free path for a mobile robot
    or autonomous vehicle from a start position to a given destination amidst a collection
    of obstacles.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解BFS是如何工作的，让我们看看简单路径规划问题中涉及的步骤。这个问题在障碍物中找到一个移动机器人或自主车辆从起始位置到指定目的地的无碰撞路径。
- en: 1\. Add the source node to the queue (figure 3.13).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将源节点添加到队列中（图3.13）。
- en: '![](../Images/CH03_F13_Khamis.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F13_Khamis.png)'
- en: Figure 3.13 Solving the path-planning problem using BFS—step 1
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 使用BFS解决路径规划问题——步骤1
- en: 2\. The robot can only move to the south (S) node, as the east (E) and southeast
    (SE) nodes are obstructed (figure 3.14).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 机器人只能移动到南（S）节点，因为东（E）和东南（SE）节点被阻挡（图3.14）。
- en: '![](../Images/CH03_F14_Khamis.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F14_Khamis.png)'
- en: Figure 3.14 Solving the path-planning problem using BFS—step 2
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 使用BFS解决路径规划问题——步骤2
- en: 3\. Take S out (FIFO), and explore its neighboring nodes, S and SE, with E being
    an obstructed node (figure 3.15).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F15_Khamis.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 Solving the path-planning problem using BFS—step 3
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Take S out (FIFO), and explore its neighboring nodes, S and SE (figure 3.16).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F16_Khamis.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 Solving the path-planning problem using BFS—step 4
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Take SE out (FIFO), and explore its neighboring nodes, E and NE (figure
    3.17).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F17_Khamis.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 Solving the path-planning problem using BFS—step 5
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 6\. The FIFO queue continues until the destination node is found (figure 3.18).
    For simplicity, assuming that the robot wants to reach node E shown in figure
    3.18, we can trace back up the tree to find the path from the source node to the
    goal, which will be Start-S-SE-E.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F18_Khamis.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 Solving the path-planning problem using BFS—final routes for an
    intermediate goal node E and the final destination
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In BFS, every node generated must remain in memory. The number of nodes generated
    is at most *O*(*b^d*), where *b* represents the maximum branching factor for each
    node (i.e., the number of children the node has) and *d* is the depth one must
    expand to reach the goal. In the previous example, with E as a goal node (*b*=2,
    *d*=3), the total number of traversed nodes is 2³=8, including the start node.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the algorithm’s ability to solve the problem at hand, algorithm efficiency
    is evaluated based on run time (time complexity), memory requirements, and the
    number of primitive operations required to solve the problem in the worst case.
    Examples of these primitive operations include, but are not limited to, expression
    evaluation, variable value assignment, array indexing, and method or function
    calls.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Big *O* notation
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Big *O* notation describes the performance or complexity of an algorithm, usually
    under the worst-case scenario. Big *O* notation helps us answer the question,
    “Will the algorithm scale?”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the big *O* notation for a function f(*x*), if f(*x*) is a sum of
    several terms, the one with the largest growth rate is kept, and all others are
    omitted. Moreover, if f(*x*) is a product of several factors, any constants (terms
    in the product that do not depend on *x*) are omitted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s look at the ticket pricing problem presented in chapter
    1: *f*(*x*) = –20*x*² + 6200*x* – 350000. Assume that *x* is a vector with size
    *n* that represents *n* different ticket prices. This function is the sum of three
    terms, of which the one with the highest growth rate is the one with the largest
    exponent as a function of *x*, namely –20*x*². We can now apply the second rule:
    –20*x*² is a product of –20 and *x*², in which the first factor does not depend
    on *x*. Dropping this factor results in the simplified form *x*². Thus, we say
    that *f*(*x*) is a big *O* of *n*², where *n* is the size of the decision variable
    *x*. Mathematically we can write *f*(*x*) ∈ *O*(*n*²) (pronounced “order *n* squared”
    or “*O* of *n* squared”), which represents a quadratic complexity (i.e., the growth
    rate is proportional to the square of the size of the ticket price vector).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.2 shows examples of algorithm complexities, and figure 3.19 shows examples
    of big *O* notations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.2 Algorithm complexity
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '| Notation | Name | Effectiveness | Description | Examples |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| *O*(1) | Constant | Excellent | Running time does not depend on the input
    size. As the input size grows, the number of operations is not affected. | Variable
    declarationAccessing an array elementRetrieving information from a hash-table
    lookupInserting and removing from a queuePushing and popping on a stack |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| *O*(log *n*) | Logarithmic | High | As the input size grows, the number of
    operations grows very slowly. Whenever *n* doubles or triples, etc., the running
    time increases by a constant. | Binary search |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| O(*n^c*),0 < *c* < 1 | Fractional power or sublinear | High | As the input
    size grows, the number of operations is replicated in multiplication. | Testing
    graph connectednessApproximating the number of connected components in a graphApproximating
    the weight of the minimum spanning tree (MST) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n*) | Linear | Medium | As the input size grows, the number of operations
    increases linearly. Whenever *n* doubles, the running time doubles. | Printing
    out an array’s elementsSimple searchKadane’s algorithm |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n* log *n*) = *O*(log *n*!) | Linearithmic, loglinear, or quasilinear
    | Medium | As the input size grows, the number of operations increases slightly
    faster than linear. | Merge sortHeapsortTimsort |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n^c*),*c* > 1 | Polynomial or algebraic | Low | As the input size grows,
    the number of operations increases as the exponent increases. | Minimum spanning
    tree (MST)Matrix determinant |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n*²) | Quadratic | Low | Whenever *n* doubles, the running time increases
    fourfold. The quadratic function is practical for use only on small problems.
    | Selection sortBubble sortInsertion sort |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n*³) | Cubic | Low | Whenever *n* doubles, the running time increases
    eightfold. The cubic function is practical for use only on small problems. | Matrix
    multiplication |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| *O*(*c^n*),*c* > 1 | Exponential | Very low | As the input size grows, the
    number of operations increases exponentially. It is slow and usually not appropriate
    for practical use. | Power setTower of HanoiPassword crackingBrute force search
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n*!) | Factorial | Extremely low | Extremely slow, as all possible permutations
    of the input data need to be checked. The factorial algorithm is even worse than
    the exponential function. | Traveling salesman problemPermutations of a string
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '![](../Images/CH03_F19_Khamis.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 Examples of big *O* notations
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Assume a computer with a processor speed of one million operations per second
    is used to handle a problem of size *n* = 20,000. Table 3.3 shows the running
    time according to the big *O* notation of the algorithm used to solve this problem.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.3 Algorithm complexity and the running time
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '| Big *O* | Running time |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| *O*(1) | 10^(-6) seconds |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| *O*(log *n*) | 14 × 10^(-6) seconds |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n*) | 0.02 seconds |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n* log *n*) = *O*(log *n*!) | 0.028 seconds |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n*²) | 6.66 minutes |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n*³) | 92.6 days |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| *O*(*c^n*), *c* = 2 | 1262.137 × 10^(6015) years |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| *O*(*n*!) | 5768.665 × 10^(77331) years (this is many orders of magnitude
    larger than the age of the universe, which is around 13.7 billion years) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: For a huge workspace where the goal is deep, the number of nodes could expand
    exponentially and demand a large memory requirement. In terms of time complexity,
    for a graph G = (V, E), BFS has a running time of *O*(|*V*| + |*E*|), since each
    vertex is enqueued at most once and each edge is checked either once (for a directed
    graph) or at most twice (for an undirected graph). The time and space complexity
    of BFS is also defined in terms of a branching factor *b* and the depth of the
    shallowest goal *d*. Time complexity is *O*(*b^d*), and space complexity is also
    *O*(*b^d*).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a graph with a constant branching factor *b* = 5, nodes of size
    1 KB, and a limit of 1,000 nodes scanned per second. The total number of nodes
    *N* is given by the following equation:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F19_Khamis-EQ01.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: '| 3.1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: Table 3.4 shows the time and memory requirements to traverse this graph using
    BFS.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.4 BFS time and space complexity
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '| Depth *d* | Nodes *N* | Time | Memory |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| 2 | 31 | 31 ms | 31 KB |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| 4 | 781 | 0.781 second | 0.78 MB |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| 6 | 19,531 | 5.43 hours | 19.5 MB |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| 8 | 488,281 | 56.5 days | 488 MB |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| 10 | 12,207,031 | 3.87 years | 12.2 GB |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| 12 | 305,175,781 | 96.77 years | 305 GB |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| 14 | 7,629,394,531 | 2,419.26 years | 7.63 TB |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: Next, we’ll take a look at the counterpart to the BFS algorithm, which searches
    deep into a graph first, rather than breadth-wise.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 Depth-first search
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depth-first search (DFS) is a recursive algorithm that uses the idea of backtracking.
    It involves exhaustive searches of all the nodes by first going as deep as possible
    into the graph. Then, when it reaches the last layer with no result (i.e., when
    a dead end is reached), it backtracks up a layer and continues the search. In
    DFS, the deepest nodes are expanded first, and nodes of equal depth are ordered
    arbitrarily. Algorithm 3.2 shows the DFS steps.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 3.2 Depth-first search (DFS)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you may have noticed, the only difference between DFS and BFS is in how the
    data structure works. Rather than working down layer by layer (FIFO), DFS drills
    down to the bottommost layer and moves its way back to the starting node, using
    a last in, first out (LIFO) data structure known as a *stack*. The stack contains
    the list of discovered nodes. The most recently discovered node is pushed onto
    the top of the LIFO stack. Subsequently, the next node to be expanded is popped
    from the top of the stack, and all of its successors are then added to the stack.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 shows the DFS solution for the 8-puzzle problem we looked at before,
    based on moving the blank tile. As you can see, when the algorithm reaches a dead
    end or terminal node (such as node 7), it goes back to the last decision point
    (node 3) and proceeds with another alternative (node 8 and so on). In this example,
    a depth bound of 5 is placed to constrain the node expansion. This depth bound
    makes nodes 6, 7, 10, 11, 13, 14, 16, 17, 22, 23, 26, and 27 terminal nodes in
    the search tree (i.e., they have no successors).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F20_Khamis.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 Using DFS to solve the 8-puzzle problem
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in listing 3.10, we only need to change the algorithm in the
    code to use DFS. I’ve also omitted the solution visualization, the reason for
    which you’ll see shortly. The `State` class is defined in the complete listing
    available in the book’s GitHub repo.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.10 Solving the 8-puzzle problem using DFS
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Some puzzles are not
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: ② The inputs for DFS are the same as for BFS.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of this code run with the preceding inputs:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, DFS is not great when dealing with very deep graphs, where
    the solution may be located closer to the top. You can also see why I opted not
    to visualize the final solution: there are a lot more steps in the solution than
    we had in BFS! Because the solution to this problem is closer to the root node,
    the solution generated by DFS is a lot more convoluted (30 steps) than with BFS.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting the path-planning problem, DFS can be used to generate an obstacle-free
    path from the start location to the destination as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Add the source node to the stack (figure 3.21).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F21_Khamis.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 Solving the path-planning problem using DFS—step 1
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Explore the S node, as the E and SE nodes are obstructed (figure 3.22).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F22_Khamis.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 Solving the path-planning problem using DFS—step 2
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Take S out (LIFO), and explore its neighboring nodes, S and SE, as E is
    an obstructed node (figure 3.23).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F23_Khamis.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 Solving the path-planning problem using DFS—step 3
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Take SE out (LIFO), and explore its neighboring nodes, SW, S, E, and NE
    (figure 3.24).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F24_Khamis.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 Solving the path-planning problem using DFS—step 4
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 5\. The next node to be expanded would be NE, and its successors would be added
    to the stack. The LIFO stack continues until the goal node is found. Once the
    goal is found, you can then trace back through the tree to obtain the path for
    the vehicle to follow (figure 3.25).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F25_Khamis.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 Solving the path-planning problem using DFS—step 5
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: DFS usually requires considerably less memory than BFS. This is mainly because
    DFS does not always expand every single node at each depth. However, DFS could
    continue down an unbounded branch forever in the case of a search tree with infinite
    depth, even if the goal is not located on that branch.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: One way to handle this problem is to use *constrained depth-first search*, where
    the search stops after reaching a certain depth. Time complexity of DFS is *O*(*b^d*)
    where *b* is the branching factor and *d* is the maximum depth of the search tree.
    This is terrible if *d* is much larger than *b*, but if solutions are found deep
    in the tree, it may be much faster than BFS. The space complexity of DFS is *O*(*bd*),
    which is linear space! This space complexity represents the maximum number of
    nodes to be stored in memory.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.5 summarizes the differences between BFS and DFS.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.5 BFS versus DFS
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Breadth-first search (BFS) | Depth-first search (DFS) |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| Space complexity | More expensive | Less expensive. Requires only *O*(*d*)
    space, irrespective of the number of children per node. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| Time complexity | More time efficient. A vertex at a lower level (closer
    to the root) is visited first before visiting a vertex that is at a higher level
    (far away from the root). | Less time efficient |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| When it is preferred |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: If the tree is very deep
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the branching factor is not excessive
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the solution appears at a relatively shallow level (i.e., the solution is
    near the starting point in the tree)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Search the British royal family tree for someone who died a long time
    ago, as they would be closer to the top of the tree (e.g., King George VI).'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: If the graph or tree is very wide with too many adjacent nodes
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no path is excessively deep
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If solutions occur deeply in the tree (i.e., the target is far from the source)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Search the British royal family tree for someone who is still alive,
    as they would be near the bottom of the tree (e.g., Prince William).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: In applications where the weights of the edges in a graph are all equal (e.g.,
    all length 1), the BFS and DFS algorithms outperform shortest path algorithms
    like Dijkstra’s in terms of time. Shortest path algorithms will be explained in
    the next section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Shortest path algorithms
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose that you were looking for the quickest way to go from your home to work.
    Graph traversal algorithms like BFS and DFS may eventually get you to your destination,
    but they certainly do not optimize for the distance traveled. We’ll discuss Dijkstra’s
    algorithm, uniform-cost search (UCS), and bidirectional Dijkstra's search as examples
    of blind search algorithms that try to find the shortest path between a source
    node and a destination node.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1 Dijkstra’s search
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm is a graph search algorithm that solves the single-source
    shortest path problem for a fully connected graph with non-negative edge path
    costs, producing a shortest-path tree. Dijkstra’s algorithm was published in 1959,
    and it’s named after Dutch computer scientist Edsger Dijkstra. This algorithm
    is the base of several other graph search algorithms that are commonly used to
    solve routing problems in popular navigation apps, as illustrated in figure 3.26\.
    The algorithm follows dynamic programming approaches where the problem is recursively
    divided into simple subproblems. Dijkstra’s algorithm is uninformed, meaning it
    does not need to know the target node beforehand and doesn’t use heuristic information.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F26_Khamis.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 Dijkstra’s algorithm and examples of its variants and extensions
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 3.3 shows the steps of the original version of Dijkstra’s algorithm
    for finding the shortest path between a known single source node to all other
    nodes in the graph or tree.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 3.3 Dijkstra’s algorithm
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dijkstra’s algorithm and its variants presented in the code for this book are
    all modified to require a target node. This improves the processing time when
    working with large graphs (e.g., road networks).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how Dijkstra’s algorithm finds the shortest path between any two
    nodes in a graph. The priority queue is used to pop the element of the queue with
    the highest priority according to some ordering function (in this case, the shortest
    distance between the node and the source node).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '0\. Initial list, no predecessors: priority queue = {} (figure 3.27).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F27_Khamis.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: Figure 3.27 Finding the shortest path using Dijkstra’s algorithm—step 0
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The closest node to the source node is S, so add it to the priority queue.
    Update the cumulative distances (i.e., distances from the source node *S* to get
    to the node) and predecessors for A, C, and D. Priority queue = {S} (figure 3.28).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F28_Khamis.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: Figure 3.28 Finding the shortest path using Dijkstra’s algorithm—step 1
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The next closest node is C, so add it to the priority queue. Update the
    distances and predecessors for A and D. Priority queue = {S, C} (figure 3.29).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F29_Khamis.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Figure 3.29 Finding the shortest path using Dijkstra’s algorithm—step 2
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The next closest node is D, so add it to the priority queue. Update the
    distances and predecessor for B. Priority queue = {S, C, D} (figure 3.30).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F30_Khamis.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: Figure 3.30 Finding the shortest path using Dijkstra’s algorithm—step 3
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The next closest node to the source node is A, so add it to the priority
    queue. Priority queue = {S, C, D, A} (figure 3.31).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F31_Khamis.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: Figure 3.31 Finding the shortest path using Dijkstra’s algorithm—step 4
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 5\. The next step is to add the remaining node B to complete the search (figure
    3.32). Priority queue = {S, C, D, A, B}. All nodes are now added.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F32_Khamis.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: Figure 3.32 Finding the shortest path using Dijkstra’s algorithm—step 5
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Once the search is complete, you can choose your goal node and find the shortest
    path from the table. For example, if the goal node is A, the shortest path between
    S and A is S-C-A with length 9\. Likewise, if the goal node is B, the shortest
    path between S and B is S-C-D-B with a distance of 10.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can’t use Dijkstra's search on our 8-puzzle problem as Dijkstra's
    search requires knowledge of the entire problem space beforehand. While the problem
    has a finite number of possible states (exactly 9!/2), the scale of that solution
    space makes the Dijkstra's search not very feasible.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2 Uniform-cost search (UCS)
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The uniform-cost search (UCS) algorithm is a blind search algorithm that uses
    the lowest cumulative cost to find a path from the origin to the destination.
    Essentially, the algorithm organizes nodes to be explored either by their cost
    (with the lowest cost as the highest priority) for minimization problems, or by
    their utility (with the highest utility as the highest priority) in the case of
    maximization problems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: As nodes are popped from the queue, we add the node’s children to the queue.
    If a child already exists in the priority queue, the priorities of both copies
    of the child are compared, and the lowest cost (the highest priority) in a minimization
    problem is accepted. This ensures that the path to each child is the shortest
    one available. We also maintain a visited list so we can avoid revisiting nodes
    that have already been popped from the queue. UCS behaves like BFS when all the
    edge costs in the graph are equal or identical. In this case, UCS will expand
    nodes in the same order as BFS—level by level or breadth-first. Algorithm 3.4
    shows the steps of the UCS algorithm.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 3.4 Uniform-cost search (UCS)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: UCS is a variant of Dijkstra’s algorithm that is useful for large graphs because
    it is less time-consuming and has fewer space requirements. Whereas Dijkstra's
    adds all nodes to the queue at the start with an infinite cost, UCS fills the
    priority queue gradually. For example, consider the problem of finding the shortest
    path between every node pair in a graph. As a graph’s size and complexity grows,
    it quickly becomes apparent that UCS is more efficient, as it does not require
    knowing the entire graph beforehand. Table 3.6 shows the difference in processing
    time between Dijkstra's and UCS on graphs of different sizes. These numbers were
    collected using the code in Comparison.ipynb, available in the book’s GitHub repo,
    on an Intel Core i9-9900K at 3.60 GHz without multiprocessing or multithreading.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.6 UCS versus Dijkstra's
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '| Graph size = &#124;V&#124; + &#124;E&#124; | Dijkstra time | Uniform-Cost
    Search (UCS) time |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| 108 | 0.25 s | 0.14 s |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| 628 | 84.61 s | 58.23 s |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| 1,514 | 2,082.97 s | 1,360.98 s |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: Note that running UCS on our 8-puzzle problem requires a distance property for
    each state (this defaults to 1), and it generates decent results overall (around
    6.2 KB of space used and 789 states explored). It is important to note that because
    the edge lengths are all equal, UCS cannot prioritize new nodes to explore. Thus,
    the solution loses the advantage of shortest path algorithms, namely, the ability
    to optimize for a more compact solution. In the next chapter, you’ll see ways
    of calculating artificial distances between these states, ultimately generating
    solutions quickly and minimizing the number of steps required.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3 Bidirectional Dijkstra's search
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bidirectional search simultaneously applies forward search and backward search.
    As illustrated in figure 3.33, it runs a search forward from the initial source
    state S→G and backward from the final goal state G→S until they meet.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F33_Khamis.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: Figure 3.33 Bidirectional Dijkstra
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: As shown in figure 3.33, the Dijkstra's search space is *C*[1] = 4*πr*², and
    the bidirectional Dijkstra's search space is represented by *C*[2] + *C*[3] =
    2*πr*². This means that we reduce the search space by about a factor of two. The
    following algorithm shows the steps of the bidirectional Dijkstra's algorithm.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 3.5 Bidirectional Dijkstra's
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This approach is more efficient because of the time complexities involved. For
    example, a BFS search with a constant branching factor *b* and depth *d* would
    have an overall *O*(*b^d*) space complexity. However, by running two BFS searches
    in opposite directions with only half the depth (*d*/2), the space complexity
    becomes *O*(*b^d*^(/2) + *b^d*^(/2)) or simply O(*b^d*^(/2)), which is significantly
    lower.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.34 shows the difference between the Dijkstra's and bidirectional Dijkstra's
    algorithms in exploring 50,841 nodes in the City of Toronto.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F34_Khamis.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: Figure 3.34 Dijkstra's vs. bidirectional Dijkstra's—forward exploration from
    the left and backward exploration from the right
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Applying blind search to the routing problem
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Puzzle games and simple grid routing problems are nice for understanding how
    an algorithm works. However, it’s time we look at some real-world examples and
    outcomes of using these algorithms. For example, imagine that you are visiting
    the King Edward VII equestrian statue at Queen’s Park in Toronto when you suddenly
    remember you have a meeting at the Bahen Centre for Information Technology at
    the University of Toronto. I initially presented this problem when we first discussed
    road network graphs at the beginning of this chapter. There are a couple of assumptions
    we’ll make when considering this problem:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: You aren’t able to open a navigation app or call a friend for help, as your
    phone is out of battery power.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know your destination is somewhere in Toronto, but you have no clue where
    it is with reference to your starting location. (In later chapters, you’ll learn
    how knowing your destination’s direction can help generate near-optimal solutions
    in a very short amount of time.)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you start using a rule for routing to your destination, you’ll stick to
    that rule.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at how we might be able to simulate our pathfinding skills using
    BFS, DFS, Dijkstra's, UCS, and bidirectional Dijkstra's. The code for this example
    is located in the book’s GitHub repo (Comparison.ipynb). Figures 3.35 to 3.37
    show the routes generated by these blind search algorithms.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F35_Khamis.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: Figure 3.35 Shortest path generated using BFS. BFS searches each layer first
    before moving to the next. This works best for graphs that are not very broad
    and that have a solution near the root node.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F36_Khamis.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Figure 3.36 Shortest path generated using DFS. DFS searches as deep in the graph
    as possible before backtracking. This works best when the graph is not very deep
    and solutions are located further away from the root node.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F37_Khamis.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: Figure 3.37 Shortest path generated using Dijkstra’s, UCS, and bidirectional
    Dijkstra’s. All three of these algorithms will produce the same solution (the
    optimal routing) but will handle memory use and node exploration differently.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that the `dijkstra_path` function in NetworkX uses Dijkstra’s
    method to compute the shortest weighted path between two nodes in a graph. Our
    optalgo- tools package also provides an implementation for different graph search
    algorithms such as BFS, DFS, Dijkstra's, UCS, and bidirectional Dijkstra's. The
    implementation of Dijkstra’s algorithm in optalgotools has been modified to work
    with our OSM data because graphs generated from maps will naturally have self-loops
    and parallel edges. Parallel edges may result in a route that is not the shortest
    available, as the route length depends heavily on which parallel edge was chosen
    when a particular path was generated. In figure 3.38, the shortest path from 0
    to 2 may be returned as having a length of 7 if the top edge connecting 0 and
    1 is chosen when calculating that path, versus a length of 3 when selecting the
    bottom edge.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F38_Khamis.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: Figure 3.38 Parallel edges may be problematic because finding the shortest path
    depends on which parallel edge is selected during graph exploration.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Self-loops also cause trouble for the original Dijkstra’s algorithm. If a graph
    contains a self-loop, the shortest path to a node might come from itself. At that
    point, we would be unable to generate a route (figure 3.39).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F39_Khamis.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: Figure 3.39 Self-loops may disrupt the chain of parent-child nodes, which prevents
    us from retracing the route after a solution has been found.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: These two problems are generally easy but nontrivial to avoid. For parallel
    edges, we select the edge with the lowest weight (shortest length) and discard
    any other parallel edge. With self-loops, we can ignore the loop entirely, as
    negative-weight loops do not exist in most routing problems (a road cannot have
    a negative length), and positive-weight loops cannot be part of the shortest path.
    Additionally, the version of Dijkstra’s algorithm used in this book terminates
    upon finding the target node, as opposed to the traditional implementation, which
    ends only when the shortest path from the root node to all other nodes is found.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.7 compares BFS, DFS, Dijkstra's, and UCS with regards to path length,
    process time, space required, and the number of explored nodes. As you can see
    from these results, Dijkstra’s, UCS, and the bidirectional Dijkstra’s algorithms
    produce optimal results, with varying degrees of time and space cost. While both
    BFS and DFS find feasible solutions in the shortest time, the solutions delivered
    are not optimal and, in the case of DFS, are not even plausible. On the other
    hand, DFS requires knowing the entire graph beforehand, which is costly and sometimes
    not very practical. Much of selecting an appropriate search algorithm for a specific
    problem involves determining the ideal balance between processing time and space
    requirements. In later chapters, we’ll look at algorithms that produce near-optimal
    solutions and that are often used when optimal solutions are either impossible
    or impractical to find. Note that all these solutions are feasible; they all produce
    a valid (if sometimes convoluted) path from point A to point B.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.7 Comparing BFS, DFS, Dijkstra's, and UCS, where *b* is the branching
    factor, *m* is the maximum depth of the search tree, *d* is the shallowest graph
    depth, *E* is the number of edges, and *V* is the number of vertices.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithm | Cost (meters) | Process time (s) | Space (bytes) | Explored nodes
    | Worst-case time | Worst-case space | Optimality |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| BFS | 955.962 | 0.015625 | 1,152 | 278 | *O*(*b^d*) | *O*(*b^d*) | No |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| DFS | 3347.482 | 0.015625 | 1,152 | 153 | *O*(*b^m*) | *O*(*bm*) | No |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| Dijkstra’s | 806.892 | 0.0625 | 3,752 | 393 | *O*(&#124;*E*&#124; + &#124;*V*&#124;
    log &#124;*V*&#124;) | *O*(&#124;*V*&#124;) | Yes |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| UCS | 0.03125 | 592 | 393 | *O*((*b* + &#124;*E*&#124;) * *d*) | *O*(*b^d*)
    | Yes |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| Bidirectional Dijkstra’s | 0.046875 | 3,752 | 282 | *O*(*b^d*^(/2)) | *O*(*b^d*^(/2))
    | Yes |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: In the next chapter, we will look at how search can be optimized if we utilize
    domain-specific knowledge instead of searching blindly. We’ll dive right into
    informed search methods and see how we can use these algorithms to solve minimum
    spanning tree and shortest path problems.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conventional graph search algorithms (blind and informed search algorithms)
    are deterministic search algorithms that explore a graph either for general discovery
    or for explicit search.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A graph is a nonlinear data structure consisting of vertices and edges.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blind (uninformed) search is a search approach where no information about the
    search space is used.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadth-first search (BFS) is a graph traversal algorithm that examines all
    the nodes in a search tree on one level before considering any of the nodes on
    the next level.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth-first search (DFS) is a graph traversal algorithm that starts at the root
    or an initial node or vertex, follows one branch as far as possible, and then
    backtracks to explore other branches until a solution is found or all paths are
    exhausted.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth-limited search (DLS) is a constrained version of DFS with a predetermined
    depth limit, preventing it from exploring paths beyond a certain depth.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterative deepening search (IDS), or iterative deepening depth-first search
    (IDDFS), combines DFS’s space efficiency and BFS’s fast search by incrementing
    the depth limit until the goal is reached.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm solves the single-source shortest path problem for a weighted
    graph with non-negative edge costs.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform-cost search (UCS) is a variant of Dijkstra’s algorithm that uses the
    lowest cumulative cost to find a path from the source to the destination. It is
    equivalent to the BFS algorithm if the path costs of all edges are the same.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional search (BS) is a combination of forward and backward search. It
    searches forward from the start and backward from the goal simultaneously.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a search algorithm involves determining the target balance between
    time complexity, space complexity, and prior knowledge of the search space, among
    other factors.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
