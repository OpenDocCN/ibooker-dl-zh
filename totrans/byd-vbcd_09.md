# 第七章\. 使用 AI 构建 Web 应用程序

本章将重点从提示快速原型转向使用 AI 辅助开发完整的 Web 应用程序。Web 应用程序通常涉及前端（通常使用 React、Angular 或 Vue 等框架编写）、后端（API、数据库、服务器）以及连接一切的粘合剂。Vibe 编码可以加速每一层。

我将向您展示一个端到端的工作流程，使用 AI 配对程序员构建 Web 应用程序，包括：

+   设置项目和其脚手架

+   编写前端 UI 代码

+   实现后端逻辑

+   集成数据库

+   测试和验证整个堆栈

在这个过程中，我将突出前端（例如，通过描述生成 React 或 Vue 组件）和后端（通过自然语言提示编写路由、业务逻辑和数据库查询）的 AI 开发模式。我还会介绍如何在全栈项目中优化人类与 AI 之间的协作，确保每一方都能贡献其最强的工作。到本章结束时，你应该对使用 AI 不仅用于孤立的编码任务，而且高效有效地管理整个 Web 开发工作流程有一个清晰的路线图。

# 设置项目：使用 AI 进行脚手架搭建

每个 Web 应用程序都从一些*脚手架*开始——构建工具、文件结构、依赖等的初始设置。AI 可以自动化创建大量样板代码。现代 Web 框架通常带有命令行界面（CLI）工具，可以生成基础项目，但你可能仍然需要配置某些事情或集成额外的库。AI 助手可以通过引导你通过这些 CLI 工具或在需要时设置自定义项目结构来提供帮助。

例如，假设你想使用 React 作为前端和 Express 作为后端开始一个新的应用程序项目。这个任务在 AI 之前的流程可能看起来像这样：

1.  运行 CLI 工具或 Vite 设置 React 项目。

1.  初始化一个 Express 应用（可能使用`npm init`并安装 Express）。

1.  为开发设置代理或配置[跨源资源共享（CORS）](https://oreil.ly/bgw1V)，以便 React 前端可以与 Express 后端通信。

1.  可能集成 MongoDB 数据库或为简单使用设置 SQLite 文件。

使用 AI 编码环境如 Cursor 或 Cline，你可以一次性描述你想要的设置：

> 使用 Vite 创建一个新的 React 前端项目（后端使用 Express）。后端应提供待办事项列表的 REST API，并使用内存数组开始。配置前端在开发中将 API 请求代理到后端。

一个高级 AI IDE 可以接受这个指令并执行以下操作：

+   创建两个目录（前端和后端）。

+   运行`npm create vite@latest`（如果具有 shell 访问权限）或模板化一个基本的 React 应用。

+   在后端初始化一个基本的 Express 服务器文件，例如带有/api/to-dos 端点（返回一些示例数据）。

+   在每个目录中包含一个*package.json*文件，并包含相关的脚本（如`start both`）。

+   通过在 React 开发服务器中配置代理或提供实现 CORS 头部的说明来设置前后端之间的通信。

几分钟内，你将拥有一个全栈 Web 应用的骨架。即使 AI 没有自动完成所有工作，它也可能提供你需要来完成它的代码和说明（例如，“将此代理设置添加到你的 React *package.json* 文件中”）。这节省了大量无意义的设置时间，并允许你立即专注于功能。

如果你没有使用 AI IDE，你仍然可以在进行过程中逐步使用 ChatGPT 或其他助手；例如：

> 我想创建一个新的 React 应用。我应该运行哪些命令？

AI 可以引导你完成步骤或推荐更新的替代方案，如 Vite 或 Next.js：

> 现在设置一个带有/api/to-dos 路由的 Express 服务器。

它可以生成 Express 服务器的代码，你可以将其复制到文件中：

> 我如何在开发期间将我的 React 应用连接到这个 API？

它可能会建议配置代理或告诉你如何调用 API（包括完整的 URL，如果未使用代理）。

这样，即使是设置基本的基础设施也变成了一场对话，而不是在文档中搜索。正如前面章节中提到的，“按意图编程”意味着你告诉 AI 你想要的结果，然后它找出步骤。设置项目是一个完美的场景。

在这个阶段，重要的是要明确你的架构决策。AI 会跟随你的领导。人类在架构和高层次决策中至关重要，所以自己决定栈和主要模式：你想要一个单仓库还是前后端分开的仓库？你会使用 REST 还是 GraphQL？哪个数据库？

一旦你有了这些想法，你可以相应地指导 AI：

> 还为 SQLite 数据库设置一个基本的 Prisma 模式。

或者：

> 使用 GraphQL 服务器而不是 REST。

AI 可能无法完美执行复杂的设置，但它会完成大部分工作，然后你可以在此基础上进行细化。

许多经验丰富的开发者将这些步骤集成到项目模板中或使用样板生成器，但 AI 提供了一种更灵活的方法：你可以使用自然语言即时自定义。这意味着如果你的项目略有不同（可能需要三个服务而不是通常的两个层级，或者你想要预配置特定的库，如 Tailwind CSS），只需让 AI 包含你想要的内容。

## 使用 AI 进行前端开发模式

一旦搭建好脚手架，开发一个 Web 应用的前端就是主要的工作部分。本节将探讨如何利用 AI 代码伙伴来辅助你的前端代码开发。

### 根据描述实现组件

你可以要求 AI 通过描述其功能和外观来创建组件；例如：

> 创建一个名为 TodoList 的 React 组件，它接受待办事项列表并显示它们。每个项目应显示其标题和一个复选框以标记它已完成。

AI 应该以功能组件的形式生成代码，根据需要包含属性和状态：

> 创建一个带有用户名和密码输入的登录表单的 Vue 组件，并在提交表单时发出包含表单数据的事件。

AI 将相应地输出 `<template>`、`<script>` 和 `<style>` 部分。作为开发者，你可以跳过编写样板代码，直接获取所需的架构。如果需要，很容易进行调整。通常，如果提示暗示需要，AI 甚至会包括基本的验证或状态处理。

在这个阶段确保一致性很重要。如果你独立生成多个组件，可能需要调整它们以便它们可以一起工作。例如，如果 TodoList 期望项目以特定的属性形状，确保任何使用 TodoList 的组件都提供该属性。你可以在一个提示中生成组件（这样 AI 就会了解所有内容），或者简单地自己连接它们并要求 AI 修复任何不匹配。

### 样式和布局

CSS 和样式可能很繁琐。描述你想要的样式，让 AI 处理 CSS 的细节：

+   设计待办事项列表组件：使用 flex 列表，添加一些间距，并将已完成项的文本颜色改为灰色并划掉。

+   对于登录表单组件，将其在页面上居中，并将输入字段的大小调整为更大的圆角边框。

根据上下文，助手可以输出 CSS-in-JS、纯 CSS 或内联样式。如果你使用 Tailwind CSS 这样的框架，甚至可以要求它输出适当的类（但请注意，并非所有模型都完全了解 Tailwind）。

重点在于：你可以在不手动调整 CSS 值的情况下迭代设计。这使你的关注点保持在更高层次的抽象——指定“看起来怎么样”而不是编写每个 `margin` 和 `color`。

### 集成 API 和状态管理

网络前端通常需要从后端获取数据，并使用 Redux、context 或简单的组件状态来管理状态。AI 可以帮助编写这些集成部分；例如：

+   在 TodoList 组件挂载时添加代码以从 /api/to-dos 获取待办事项列表，并将其存储在状态中。

+   在 TodoList 中实现一个函数，当复选框切换时，向 */api/to-dos/{id}/complete* 发送 `POST` 请求，然后相应地更新状态。

AI 可以在 React 中生成 `useEffect` 钩子以执行获取操作或在 Vue 中生成 `mounted()` 钩子。它还可以模拟 HTTP 调用（使用 `fetch` 或 Axios 等）。你将想要确认 API 端点和有效负载与你的后端期望的一致（如果你已经构建了后端或对其有规范）。

如果你还没有构建后端，你可能同时在使用 AI 来创建它——我们很快就会讨论这一点。但你可以使用 AI 辅助并行处理前端和后端，因为它们可以相对独立地指定和生成，只要你保持对它们之间接口的跟踪。

### 在 AI 指导下处理复杂性

如果你的前端有复杂的逻辑，例如动态表单验证规则、条件渲染或复杂的用户交互，你可以使用 AI 逐步实现这些功能。一个好的做法是将问题分解：

> 添加一个功能：当用户在待办事项上勾选“完成”复选框时，使用 CSS 过渡效果使该列表项淡出，然后在 1 秒后将它从列表中移除。

AI 可能会生成在勾选时添加 CSS 类和使用超时移除项的代码，包括必要的 CSS 以实现淡出效果：

> 表单有一个可选的“笔记”字段。只有当“添加笔记”复选框被勾选时才显示笔记文本区域。

AI 可以修改组件状态和 JSX 以条件渲染笔记字段。

每个这些都可以是一个迭代提示。本质上，你描述 UX 行为，AI 编写代码。在每次添加后都要进行测试，以确保其按预期行为。

### 框架特定的技巧

不同的框架有不同的惯例：

+   在 React 中，AI 可能会使用钩子（如`useState`、`useEffect`）。请确保它遵循最佳实践（例如，`useEffect`中的依赖项数组是正确的）。

+   在 Vue 中，AI 可能会根据其所见输出选项 API 风格或组合 API 风格。如果你更喜欢其中一种，你应该指定它（例如，“使用 Vue 3 组合 API”）。

+   在 Angular 中，AI 可以生成组件，但 Angular 的学习曲线较陡。AI 可能会在请求时生成模板、TypeScript 类和基本的服务注入，但你可能需要做更多手动工作或使用 Angular CLI 来构建结构，然后让 AI 填写特定的部分（如表单验证逻辑）。

## 使用 AI 的后端/API 开发模式

现在让我们转向后端。使用 AI 构建 Web 应用的服务器端遵循类似的范式：你描述你想要的端点、数据模型和逻辑，然后 AI 生成代码。常见的后端组件包括路由处理程序、业务逻辑、数据库交互和验证。AI 可以帮助完成所有这些。

### 实现 API 端点

假设你正在为待办事项应用构建 RESTful API。你可能会有`GET /to-dos`、`POST /to-dos`、`PUT /to-dos/:id`、`DELETE /to-dos/:id`这样的端点。你可以逐个端点进行：

+   在 Express 应用中，添加一个`GET /api/to-dos`路由，该路由返回待办事项列表（现在只需使用存储在内存中的数组即可）。

+   添加一个`POST /api/to-dos`路由，该路由接受 JSON 主体并将新的待办事项添加到列表中。返回带有 ID 的新待办事项。

AI 将相应地编写 Express 路由处理程序，可能使用类似`app.get('/api/to-dos', ...)`的东西。如果你已经表明你正在使用带有 JSON 的 Express，它可能会包括必要的中间件，如果它尚未存在的话：

```py
app.use(express.json())
```

随着后端的增长，你可以要求 AI 进行重构：

> 将 Express 路由重构为单独的路由模块。

它可能会将路由拆分到单独的文件中，这对于维护性来说是一个好习惯。

### 数据库集成

你可能可以使用内存数据来制作原型，但对于更完整的应用程序，你将需要一个数据库。假设你选择了 MongoDB 或 PostgreSQL。你可以提示：

> 使用 Mongoose 将 MongoDB 集成到 Express 应用中。创建一个待办事项模型，包含字段：标题（字符串），完成状态（布尔值）。修改 GET/POST 路由，使用数据库而不是内存中的数组。

AI 可能会输出 Mongoose 模型定义，并调整路由处理程序以查询数据库（例如`Todo.find()`用于`GET`和`Todo.create()`用于`POST`）。类似地，对于 SQL，你可以要求它设置一个[*对象关系映射*（ORM）](https://oreil.ly/AoWDL)如 Prisma 或 Sequelize。请记住，你可能需要提供配置细节（如连接字符串）。AI 可能不知道你的数据库 URI；你将不得不将其插入。但它会处理通用代码。

### 业务逻辑和验证

如果你的后端有特定的规则（例如，用户不能删除标记为重要的待办事项，或者列表标题必须是唯一的），你可以通过 AI 来编码这些规则：

> 在`POST /api/to-dos`路由中添加验证：如果标题为空或超过 100 个字符，则拒绝，并返回 400 状态。

AI 将包括检查并发送适当的响应。

> 添加逻辑：当待办事项被标记为完成（例如通过`PUT /api/to-dos/:id`），如果所有待办事项都已完成，记录消息“全部完成！”

它可以在`PUT`处理程序中插入这个逻辑。

你可以用简单的术语描述这些需求，AI 会相应地修改代码。你仍然需要测试代码是否按预期工作。

### 使用框架或模板

许多 Web 后端使用比原始 Express 更广泛的框架（如 Node 的 NestJS 或 Python 的 Django）。AI 也可以与这些框架一起工作，尽管你可能需要分解更复杂的任务：

+   对于 Django（Python），你可能提示：

    > 为待办事项创建一个 Django 模型，包含字段 X，以及相应的列表和创建视图。

+   如果 AI 知道这个上下文，它可能会输出模型代码和一个通用的视图或 DRF（Django REST Framework）序列化器/视图集。

+   对于 Ruby on Rails，你可以获得帮助生成模型和控制器。（在那个阶段，你可能会直接使用 Rails 脚手架，但 AI 可以通过添加验证或调整路由来补充）。

AI 模型在不同编程语言和技术堆栈中的熟练程度各不相同，这主要取决于这些技术在训练数据中的普及程度。虽然模型可以处理他们在训练期间遇到的任何语言，但他们的有效性差异很大。像 JavaScript、Python 和 Java 这样的流行语言通常由于在开源存储库、文档和教育材料中的丰富表示而得到更强的支持，这些材料构成了训练语料库的一部分。

确定模型在您选择的堆栈中的熟练程度需要实际评估。首先，用您目标语言中的基本任务测试模型，然后逐步增加复杂性以评估其能力。注意模型是否生成遵循语言特定约定的地道代码，是否能够无需详细解释就识别常见的框架和库，以及是否为该生态系统建议适当的设计模式。熟练程度强的表现是上下文适当的建议，而较弱的支持通常会导致通用的或过时的代码模式。

许多 AI 提供商发布了关于其模型能力的文档，尽管这些很少包括详细的语言特定基准。最可靠的方法是使用您实际的技术堆栈进行小实验。例如，如果您使用 Ruby on Rails，测试模型是否理解 Rails 约定，如 ActiveRecord 模式，或能否生成适当的 RSpec 测试。同样，对于较新的框架或不太常见的语言，预期会有更多可变的结果，并准备好在提示中提供更多上下文以弥补模型训练中的潜在差距。

### 协调多步骤操作

一些端点可能涉及多个步骤，例如在一个表中创建条目，然后是另一个，或者调用外部 API。您可以概述顺序，并让人工智能起草：

> 当新用户注册（`POST /api/users`）时，创建用户记录并通过 SendGrid API 发送欢迎邮件。

人工智能可以编写代码来保存用户（可能使用对象关系映射器，或 ORM）以及向 SendGrid 的 API 发送带有适当有效载荷的 HTTP 请求。您将填写实际的 API 密钥或调整内容，但大部分模板代码已经完成：

> 实施事务：在转账时（`POST /api/transfer`），从账户 A 扣除并添加到账户 B，确保它是原子性的（全部或无）。

如果您使用支持事务的 ORM 或数据库，人工智能可能会使用这些功能（如 SQL 事务块或 ORM 的事务方法）。谨慎审查此类代码的正确性——特别是事务逻辑，可能会很复杂。但人工智能可能知道常见的陷阱，并包括检查。例如，当被提示处理货币转账端点时，人工智能生成了以下代码结构：

```py
```

async function transferMoney(fromAccountId, toAccountId, amount) {

const session = await db.startSession();

try {

await session.startTransaction();

// 从源账户扣除

const sourceAccount = await Account.findByIdAndUpdate(

fromAccountId,

{ $inc: { balance: -amount } },

{ session, new: true }

);

if (sourceAccount.balance < 0) {

throw new Error('Insufficient funds');

}

// 添加到目标账户

await Account.findByIdAndUpdate(

toAccountId,

{ $inc: { balance: amount } },

{ session }

);

await session.commitTransaction();

return { success: true };

} catch (error) {

await session.abortTransaction();

throw error;

} finally {

session.endSession();

}

}

```py
```

AI 正确地将数据库操作包装在事务中，包括对资金不足的验证，并在任何错误发生时正确处理回滚。虽然你仍然需要审查边缘情况并添加适当的日志记录，但基本的事务结构展示了对原子操作的理解。

### API 文档和测试

在构建 API 时，AI 也可以生成文档。例如，“为/api/to-dos 端点编写简要文档。”它可能会生成如下内容：

```py
GET /api/to-dos - returns list of to-dos.
POST /api/to-dos - create a new to-do. Expects JSON: {title: string}. Returns the created to-do.
...
```

这对于快速参考和与前端开发者（如果你在一个团队中工作）分享都很有用。此外，你可以使用 AI 为你的 API 端点编写测试，使用像 Jest 或 Mocha 这样的测试框架（用于 Node）或 PyTest（用于 Python API）。使用提示“为待办事项 API 生成测试（一个用于列出，一个用于创建，一个用于验证错误）”，AI 将输出你可以运行和验证的测试代码。

# 数据库设计和集成

在设计数据库模式时，人类对业务领域的知识至关重要，但 AI 可以帮助将设计转换为代码（如迁移脚本或 ORM 模型）。此外，如果你不确定你的模式，你可以与 AI 一起头脑风暴。

例如，如果你的应用程序正在从待办事项列表扩展到成为完整的项目管理工具，你需要设计几个表：项目、任务、用户等。你可能想知道：“对于一个简单的项目管理应用程序，我需要哪些数据模型，包括用户、项目和任务？包括关系。”AI 可能会这样回答：

+   用户（id, name, email 等）

+   项目（id, name, owner_id 引用用户）

+   任务（id, description, project_id, assigned_to（用户），状态等）

这可能不是你想要的，但它为你提供了一个起点。你确认或调整这些设计想法，然后实施它们。

## 使用 ORM

如果你使用 Prisma、Entity Framework 或 SQLAlchemy 这样的 ORM，你可以让 AI 生成模型类或模式定义：

> 使用 Sequelize（用于 Node），定义用户、项目、任务模型及其关联：一个用户有多个项目，项目属于用户；项目有多个任务，任务属于项目；任务可以被分配给一个用户（多对一）。

然后 AI 将编写 JS/TS 代码来定义这些 Sequelize 模型和关联，你可以将其集成到你的代码库中。如果它熟悉这些，它还可能建议外键或级联规则。

如果你没有使用 ORM 并且正在编写原始 SQL 迁移，AI 甚至可以起草迁移脚本：

> 编写一个 SQL 脚本以创建用户、项目、任务表，并包含适当的外键。

它将输出一个 SQL DDL 脚本，你可以审查其正确性并运行。

## 数据库查询

当在代码中集成数据库时，你可能需要比简单的 CRUD 更复杂的查询。假设你想要获取所有项目，包括它们的任务以及每个任务分配的用户——这是一个跨越 Project、Task、User 的连接。你可以提示：

> 编写一个 SQL 查询以检索包含其任务以及每个任务分配的用户名的项目。

AI 可以为你生成一个 SQL 连接查询。

或者如果你使用 ORM：

> 使用 Sequelize，获取所有包含相关任务及其每个任务的用户的全部项目。

你可能期望代码中包含一些用于加载相关数据的操作，例如：

```py
include: [Task, { model: User, as: 'assignedUser' }]
```

## 检查 AI 生成的查询

数据库操作需要仔细验证以确保 AI 生成的代码与你的实际模式相匹配并保持数据完整性。AI 无法自动知道你的特定表名、字段名或关系，除非你在提示中明确提供这些信息。即使模型具有对话记忆，你也应在每个复杂的数据库相关提示中包含模式细节以确保准确性。这种明确的方法可以防止 AI 生成的查询引用通用的字段名，如 `user_id`，而你的模式实际上使用 `userId` 或 `customer_ref`。

性能考虑通常需要人工监督。虽然 AI 模型理解基本数据库概念，如主键和连接，但它们可能不会自动建议性能优化，例如在频繁查询的字段上添加索引或考虑查询执行计划。审查生成的查询以检查效率，特别是对于将频繁运行或针对大型数据集的操作。

数据一致性规则代表另一个需要明确指定的关键领域。在实施删除操作时，明确定义你期望的级联行为。例如，当删除一个 `Project` 记录时，你必须决定数据库是否应该自动通过级联删除删除相关的 `Task` 记录，或者是否由你的应用程序逻辑处理此清理。向 AI 明确传达这些业务规则：

> 当项目被删除时，配置数据库以级联删除所有相关任务。

或者：

> 当删除项目时，首先检查是否存在现有任务，并在存在任何任务时阻止删除。

当给出明确的指示时，AI 可以有效地实施任何一种方法。对于级联删除，它可能会生成带有`ON DELETE CASCADE`的外键约束。对于应用级别的处理，它可能生成在允许删除之前查询相关记录的代码。关键在于明确地说明你的数据完整性要求，而不是假设 AI 会推断出适合你特定领域的适当行为。

# 全栈集成：将前端和后端结合

现在你已经使用 AI 的帮助构建了前端和后端，下一个挑战是将它们集成到一个无缝的 Web 应用中。这包括确保从前端正确调用 API 端点，数据正确流动，以及整个系统的一致性。

## 对齐前端和后端合约

这非常重要：前端期望以特定的形状接收数据，因此后端发送的数据应与这种期望相匹配。如果你让 AI 在两端独立工作，可能会出现小的不匹配（比如后端返回`{ success: true, data: [...] }`，但前端期望直接接收数组）。为了避免这种情况，你可以明确指示 AI 在编码两端时使用的响应格式。或者，一旦完成，进行端到端调用测试：例如，打开 Web 应用并查看列表是否加载。如果没有加载，请检查浏览器控制台与服务器日志。

我经常使用 AI 来调整一边以匹配另一边：

+   如果后端返回的 JSON 键名与前端期望的略有不同，并且你注意到一个错误，你可以对 AI（任一端）说：

    > 修改代码，在 JSON 中使用复数形式的“tasks”而不是单数形式的“taskList”。

+   如果前端以表单编码的形式发送表单数据，但后端期望 JSON 格式，你可以要求 AI 进行转换，比如在前端使用`JSON.stringify`或在后端添加`body-parser`。

## 与 AI 实时协作

拥有整个项目上下文的 AI 增强 IDE，如 Cline 或 Cursor，在集成阶段特别有帮助。你可以在基于 IDE 的工具中并排打开前端和后端文件，并提示：

> 确保前端从/api/to-dos 获取的数据与 Express 路由预期的请求/响应匹配。修复任何差异。

然后，AI 可能会使内容和谐（例如，如果前端缺少`await response.json()`，则添加或在 JSON 结构中调整）。

### 状态管理和同步

在全栈应用中，考虑在前端实现加载状态和错误处理等功能，以应对失败的 API 调用，从而得到专业的结果。你可能需要使用以下提示：

> 添加加载指示器：当 React 组件正在获取任务时，显示“加载中...”文本，直到数据加载完成。

或者：

> 处理错误：如果 API 调用失败（非 200 响应），在 UI 上显示错误消息。

这将添加`isLoading`状态和条件渲染，或者在`fetch`周围实现 try/catch 来捕获错误并显示消息。这种润色让你的应用*感觉*更稳健。

### WebSockets 和高级集成

如果你的应用需要实时更新（如使用 WebSockets 或 SSE），你可能需要提示如下内容：

> 使用 Socket.io 设置 WebSocket。当服务器上创建新任务时，将其广播给所有已连接的客户端。修改前端以监听新任务并在实时将其添加到列表中。

这很复杂，但 AI 可能会生成服务器端 Socket.io 设置（如添加`io.on('connection', ...)`并在创建新任务时触发事件），以及客户端代码来连接并监听该事件。你需要仔细集成这些代码，但令人惊讶的是，这些描述可以引导生成实际的工作实时代码。如果一开始不完美，迭代提示和测试可以使其达到预期效果。

### 示例：使用 AI 的全栈流程

为了说明，让我们想象你正在构建一个简单的联系人管理器 Web 应用：

+   你搭建 React 前端和 Node/Express 后端，就像你在本章前面所做的那样。

+   首先，对于前端，提示`ContactList`和`ContactForm`组件。然后提示添加 API 调用：

    > 在 ContactList 中，在挂载时从*/api/contacts*获取联系人。
    > 
    > 在 ContactForm 中，提交时，将表单数据通过`POST`发送到*/api/contacts*，然后在成功后更新联系人列表。

+   对于后端，你可能想先使用内存数组或集成数据库。然后提示 Express 路由`GET /api/contacts`（返回列表）和`POST /api/contacts`（将联系人添加到数据库或内存中）。

+   尝试通过 UI 添加联系人。如果它在列表中显示，那就太好了。如果没有，进行调试。可能是`POST`路由没有正确返回新联系人，或者表单代码没有刷新列表。确定差距，并提示 AI 修复它：

    > 添加联系人后，后端应在响应中返回新的联系人对象，并且前端应将其附加到列表中，无需完全重新加载。

    这可能会导致 AI 调整后端响应和前端状态逻辑，以推送新联系人（可能使用 React 状态更新）。

+   类似地实现编辑和删除功能，每次都让 AI 处理常规部分，并将你的输入集中在*功能应该做什么*上。

如果手动完成所有这些工作，对于一个初级开发者来说可能需要一周或两周的时间，但使用 AI 代码开发者可以在一天或两天内完成，因为许多模板代码和连接都是自动化的。

### 优化全栈开发中的 AI-人类协作

当与 AI 助手一起处理整个堆栈时，建立高效的工作节奏很有用。以下是一些优化协作的策略：

使用 AI 处理模板代码；自己编写任何自定义逻辑

识别代码中哪些部分是平凡的，哪些是独特的核心逻辑。让 AI 生成 CRUD API 或标准组件——但如果有一段特别棘手的逻辑，可能是专有算法或特定的业务规则，直接实现可能更容易，那么手动完成这部分，然后让 AI 进行审查或测试。将其视为将重复性任务委托给 AI，而你处理新颖的任务。

使用 AI 逐项处理你的待办事项列表

在开发过程中，跟踪任务（如要添加的功能和要修复的错误）。然后逐一向 AI 解释每个任务，并让它提出解决方案。例如，假设你有一个笔记写着“在用户注册时实现密码散列。”尝试这样的提示：

> 在将用户保存之前，在`POST /api/register`路由中使用 bcrypt 添加密码散列。

这种有针对性的、系统性的方法有助于确保你不会忘记任何东西。

随着你改进代码质量，提示 AI

在实现功能后，你可以提示“重构此代码以提高可读性”或“优化此函数”。AI 通常可以使代码更干净或提出性能改进，就像助手在你的监督下进行第二次润色一样。务必验证任何更改是否仍然通过你的测试。

使用 AI 进行交叉检查

如果你对自己的设计方法不确定，请询问 AI：

> 使用数组在内存中存储联系人是否可以，或者我应该使用数据库？有哪些优缺点？

虽然你可能知道答案（使用数据库进行持久化），但这就像与同事讨论想法一样。有时 AI 可能会提到你未曾考虑过的考虑因素：

> 如果有多个服务器实例，内存存储无法在它们之间同步。

使用 AI 与你的团队协调

如果你在一个团队中工作，可能不是每个人都直接使用 AI。在这种情况下，请确保让 AI 记录你所做的工作。此外，向团队传达你的方法也是好的：“我使用 AI 快速生成这些控制器。我已经检查过它们，但请注意任何不寻常的模式。”鼓励代码审查文化，让每个人都像审查其他代码一样审查 AI 编写的代码，以捕捉任何怪癖。

采用 AI 的现实世界团队（如[Snyk](https://oreil.ly/8Dmn7)的团队）报告称，它可以提高生产力，但他们也强调在验证过程中保持人类参与。在 GitHub 于 2024 年进行的一项[调查](https://oreil.ly/oivAx)中，97%的开发者报告称在工作中以某种形式使用 AI 编码工具。

# 对 AI 生成的 Web 应用程序进行测试和验证

在使用 AI 帮助构建你的 Web 应用程序后，彻底测试以确保一切按预期工作，并捕捉到你或 AI 可能引入的问题。以下是在这种 AI 辅助环境中进行测试的方法：

单元测试

对于后端逻辑，为关键函数（如计算某些内容的函数或验证输入的函数）编写单元测试。如果 AI 编写了该函数，为其编写测试可以揭示任何隐藏的错误。你甚至可以让 AI 生成这些测试，如前所述。但请注意：AI 生成的测试有时可能是微不足道的或假设了实现，因此你可能需要引导它测试边缘情况：

> 为密码强度函数编写测试，包括空密码、非常长的密码、包含特殊字符的密码等边缘情况。

集成测试

使用类似 Supertest（用于 Node）或直接 HTTP 调用的工具测试 API 端点。检查每个端点是否返回预期的结果。AI 可以帮助你构建这些：

> 使用 Jest 和 Supertest 为 `/api/to-dos` 端点编写集成测试。

它可能会生成启动应用、击中端点并对响应进行断言的测试。

前端测试

Web UI 测试可以使用 Jest（用于组件逻辑）和 Cypress 或 Playwright 进行端到端 UI 测试。你当然可以要求 AI 生成一个 Cypress 测试场景：

> 编写一个 Cypress 测试，加载应用，通过表单添加一个新的待办事项，并检查它是否出现在列表中。

你将获得一个测试脚本，可以运行。这非常强大——通过利用 AI 编写用户交互，你可以快速获得端到端测试覆盖率。

手动测试

无论你运行什么自动化测试，都要进行一些手动探索性测试。亲自点击网页应用（或者如果你在一个团队中工作，让 QA 做这件事）。AI 可能无法预见每一个现实世界场景：例如，可能使用浏览器的后退按钮会破坏某些状态，或者特定的动作序列会导致故障。当你发现错误时，修复它们或要求 AI 帮助修复。手动测试对于 UI/UX 判断也很重要——应用是否易于使用？是否存在任何不自然的流程？AI 无法判断这些主观的 UX 问题，因此人类反馈至关重要。

代码审查

如果你与他人合作，让他们审查 AI 生成的代码。新视角可能会发现你可能忽略的事情——他们可能会发现安全疏忽，或者只是建议一种更符合习惯的编写方式。使用 AI 的团队通常保持正常的代码审查流程，只是更加关注审查 AI 可能无意中引入的微妙错误或安全问题。

安全审计

第八章 将深入探讨安全，但即使在开发时间，扫描代码以查找已知漏洞模式也是值得的。你可以运行自动化工具，如代码检查器和 [静态应用程序安全测试](https://oreil.ly/T531z)（SAST）工具，或者你可以提示 AI：

> 审查 Express 应用代码，并列出任何潜在的安全漏洞或最佳实践违规。

AI 可能会标记一些令人惊讶的事情，比如“你在这里没有对用户输入进行清理”或“你应该正确设置 CORS。”将这些用作加固应用程序的清单。

使用 AI 的一个有趣的效果是，你可能会编写你原本不会编写的测试，因为 AI 使创建它们变得如此简单。这实际上可能导致最终代码的*更*健壮。如果你在生成功能后立即生成测试（本质上是一种 AI 辅助的测试驱动开发，或者至少是事后测试），你确保了快速开发不会影响质量。想想看：既然 AI 帮你节省了编写代码的时间，就把这部分节省的时间投资到编写和运行测试上。

如果用户不小心，AI 可能会建议不安全的代码。例如，早期的 AI 版本可能会生成易受注入攻击的 SQL 查询，除非特别提示避免这种情况。通过测试和审查，你可以捕捉到这些问题。[一项研究](https://oreil.ly/U3b8H)发现，使用 AI 辅助的开发者往往对自己的代码安全性过于自信，即使它们比手动编写的代码更差。

不要因为代码是由 AI 编写的就跳过验证。假设它可能存在错误，就像任何由人类编写的代码一样。

# 成功的 AI 构建网络项目示例

让我们突出一些例子（从各种报告中抽取的复合例子），在这些例子中，AI 辅助在交付真实网络应用中发挥了重要作用。

由独立开发者创建的电子商务网站

一个独立开发者想创建一个小的电子商务网络应用来销售定制 T 恤，但时间有限。他通过 IDE 扩展使用了 GPT 来构建整个堆栈。他提示 AI 生成一个具有产品列表、购物车和结账页面的 React 前端，以及一个具有产品和订单端点的 Node.js 后端。他使用 Stripe 进行支付，并通过请求 AI 帮助集成 Stripe 的 API 来集成它。在连续两周的晚上工作后，他拥有了一个功能齐全的网站。

该开发者报告称，AI 可能完成了大约 70%的编码工作，特别是重复的 UI 部分和表单处理，而他则专注于正确配置 Stripe 和微调 UI 以适应品牌。最终，客户可以在一个主要通过 vibe 编码构建的系统内浏览产品、将它们添加到购物车并购买——所有这些都在一个系统中完成。这也突出了，在外部服务集成（如 Stripe）方面，只要有模型可以从中获取的文档或你提供它，AI 指导是可行的。

内部公司仪表板

一位具备一些编码技能的产品经理使用人工智能配对程序员为她团队创建了一个内部分析仪表板。通常，她需要等待工程资源，但通过在 Web 项目中使用 Replit 的 Ghostwriter 或 GitHub Copilot 这样的工具，她设法自己构建了一个基本的 Web 应用程序。人工智能帮助设置了简单的 Flask 后端来查询他们的数据库（使用安全的只读凭证）和一个 Vue.js 前端来显示图表（使用图表库）。她描述了每个图表应该显示的内容（“随时间推移的总注册量”，“按地区活跃用户”），然后人工智能编写了 SQL 查询和图表代码。

整个过程花费了几个星期的调试和测试，但最终她交付了一个可工作的仪表板。代码质量不是企业级，但由于它是内部的，所以没问题。更重要的是，她用极短的时间为团队提供了一种工具。这个例子说明了人工智能工具如何使非专业程序员能够制作出有用的 Web 应用程序，解开可能否则会积压在待办事项中的任务。这是一个“程序员解绑”的例子，我将在第十章中讨论，该章节全部关于个人或团队如何更容易地创建个人或特定团队的软件。

创业最小可行产品（MVP）

一个小型创业公司（只有两个联合创始人：一个业务，一个技术）需要一个 MVP Web 应用程序向投资者展示。技术联合创始人广泛使用 vibe 编码在创纪录的时间内构建了一个 MVP。使用人工智能助手，他使用 Next.js 构建了一个现代 Web 应用程序，用于 SSR React 前端和一个简单的 Node API。他利用人工智能实现了社交登录（人工智能编写了 OAuth 流程）、图片上传（人工智能与云存储 API 集成）以及产品本身中的基于人工智能的功能。他们甚至使用人工智能帮助集成来自 API 的自然语言处理模型。在几个月内，一位开发者完成了通常需要一个小团队四到六个月才能完成的工作。结果是虽然有些简陋但功能齐全的产品，他们可以进行演示，甚至可以将测试用户引入平台。

当联合创始人后来雇佣更多开发者来完善产品时，新开发者发现人工智能编写的代码大部分是可以理解的，尽管他们确实重构了很大一部分代码以提高可扩展性。这表明人工智能可以帮助你快速达到第一阶段，但当你进入下一阶段时，你可能需要投资于质量。

这些故事虽然只是轶事，但与行业中的新兴模式相吻合。特别是在网络开发领域，这通常涉及将许多组件连接起来，生产力的提升是非常明显的。[微软](https://oreil.ly/QLunu)和[其他人](https://oreil.ly/BNVrB)报告的研究发现，使用人工智能的开发者能够比没有使用人工智能的开发者更快地完成任务。

然而，也有一些警示故事。例如，一个开发者可能因为不完全理解代码而部署了一个存在安全漏洞的人工智能生成的 Web 应用程序。这种风险强化了为什么测试和审查至关重要的原因。

总之，在人工智能辅助下构建 Web 应用程序正成为一种主流方法。这并不是要消除对熟练开发者的需求；相反，它是增强他们的能力。开发者仍然负责规划架构、确保正确性，并处理代码的复杂或新颖方面，而人工智能则处理将一切粘合在一起的重复性模板代码。我们走过的端到端工作流程——从脚手架到前端再到后端到测试——证明了只要你在过程中应用你的判断力和专业知识，实际上 Web 开发的每一步都可以通过人工智能来加速。

# 摘要及下一步行动

在本章中，您已经看到了 vibe 编码如何扩展到全规模 Web 应用程序开发。通过将人工智能视为始终可用的配对程序员，您可以并行处理前端和后端任务，从自然描述中生成组件和 API，并迭代地改进原型应用程序以达到生产质量。成功的关键包括清楚地传达您的意图（以便人工智能知道每一步您想要什么），仔细验证（以捕捉人工智能输出中的问题），并利用人工智能不仅生成代码，还用于诸如头脑风暴架构设计、编写测试等活动。

本章还探讨了开发者如何通过人工智能来有效地成为全栈工程师，人工智能通过在开发者不太熟悉的部分建议代码来弥合他们的知识差距。这大大减少了常见功能的开发生命周期，并在某些方面实现了开发的民主化，使人们能够在没有大型团队的情况下创建定制的 Web 解决方案（我将在第十章中再次探讨这一主题）。

人工智能并不能取代理解需求或确保质量；它加速了执行。

现在您的 Web 应用程序已经上线并运行，接下来的关注点是确保它是安全的、可靠的和可维护的。第八章深入探讨了人工智能生成代码库中的安全和可靠性挑战，确定了可能遗漏的常见漏洞，如何审计和修复它们，以及最佳实践（如我们在这里开始应用的测试和审查），以确保快速使用人工智能不会破坏事物。本质上，我们将从构建转向加固——确保您的 vibe 编码软件能够经受住现实世界的条件和威胁。
