["```py\nimport secrets\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import HTTPBasic, HTTPBasicCredentials\n\napp = FastAPI()\nsecurity = HTTPBasic() ![1](assets/1.png)\nusername_bytes = b\"ali\"\npassword_bytes = b\"secretpassword\"\n\ndef authenticate_user(\n    credentials: Annotated[HTTPBasicCredentials, Depends(security)]\n) -> str:\n    is_correct_username = secrets.compare_digest(\n        credentials.username.encode(\"UTF-8\"), username_bytes ![2](assets/2.png)\n    )\n    is_correct_password = secrets.compare_digest(\n        credentials.password.encode(\"UTF-8\"), password_bytes ![2](assets/2.png)\n    )\n    if not (is_correct_username and is_correct_password):\n        raise HTTPException( ![3](assets/3.png)\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect credentials\",\n            headers={\"WWW-Authenticate\": \"Basic\"},\n        )\n    return credentials.username\n\nAuthenticatedUserDep = Annotated[str, Depends(authenticate_user)] ![4](assets/4.png)\n\n@app.get(\"/users/me\")\ndef get_current_user_controller(username: AuthenticatedUserDep): ![4](assets/4.png)\n    return {\"message\": f\"Current user is {username}\"}\n```", "```py\n$ pip install passlib python-jose\n```", "```py\n# entities.py\n\nimport uuid\nfrom datetime import UTC, datetime\nfrom sqlalchemy import Index, String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)\n    email: Mapped[str] = mapped_column(String(length=255), unique=True)\n    hashed_password: Mapped[str] = mapped_column(String(length=255))\n    is_active: Mapped[bool] = mapped_column(default=True)\n    role: Mapped[str] = mapped_column(default=\"USER\")\n    created_at: Mapped[datetime] = mapped_column(default=datetime.now(UTC))\n    updated_at: Mapped[datetime] = mapped_column(\n        default=datetime.now(UTC), onupdate=datetime.now(UTC)\n    )\n\n    __table_args__ = (Index(\"ix_users_email\", \"email\"),)\n```", "```py\n# schemas.py\n\nfrom datetime import datetime\nfrom typing import Annotated\nfrom pydantic import (UUID4, AfterValidator, BaseModel, ConfigDict, Field,\n                      validate_call)\n\n@validate_call\ndef validate_username(value: str) -> str: ![1](assets/1.png)\n    if not value.isalnum():\n        raise ValueError(\"Username must be alphanumeric\")\n    return value\n\n@validate_call\ndef validate_password(value: str) -> str: ![1](assets/1.png)\n    validations = [\n        (\n            lambda v: any(char.isdigit() for char in v),\n            \"Password must contain at least one digit\",\n        ),\n        (\n            lambda v: any(char.isupper() for char in v),\n            \"Password must contain at least one uppercase letter\",\n        ),\n        (\n            lambda v: any(char.islower() for char in v),\n            \"Password must contain at least one lowercase letter\",\n        ),\n    ]\n    for condition, error_message in validations:\n        if not condition(value):\n            raise ValueError(error_message)\n    return value\n\nValidUsername = Annotated[\n    str, Field(min_length=3, max_length=20), AfterValidator(validate_username)\n]\nValidPassword = Annotated[\n    str, Field(min_length=8, max_length=64), AfterValidator(validate_password)\n]\n\nclass UserBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True) ![2](assets/2.png)\n\n    username: ValidUsername\n    is_active: bool = True\n    role: str = \"USER\"\n\nclass UserCreate(UserBase): ![3](assets/3.png)\n    password: ValidPassword\n\nclass UserInDB(UserBase): ![4](assets/4.png)\n    hashed_password: str\n\nclass UserOut(UserBase):\n    id: UUID4\n    created_at: datetime\n    updated_at: datetime\n```", "```py\n# entities.py\n\nfrom datetime import UTC, datetime\nfrom sqlalchemy import ForeignKey, Index, String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Token(Base):\n    __tablename__ = \"tokens\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    expires_at: Mapped[datetime] = mapped_column()\n    is_active: Mapped[bool] = mapped_column(default=True)\n    ip_address: Mapped[str | None] = mapped_column(String(length=255))\n    created_at: Mapped[datetime] = mapped_column(default=datetime.now(UTC))\n    updated_at: Mapped[datetime] = mapped_column(\n        default=datetime.now(UTC), onupdate=datetime.now(UTC)\n    )\n\n    user = relationship(\"User\", back_populates=\"tokens\")\n\n    __table_args__ = (\n        Index(\"ix_tokens_user_id\", \"user_id\"),\n        Index(\"ix_tokens_ip_address\", \"ip_address\"),\n    )\n\nclass User(Base):\n    __tablename__ = \"users\"\n    # other columns...\n\n    tokens = relationship(\n        \"Token\", back_populates=\"user\", cascade=\"all, delete-orphan\"\n    )\n\n# schemas.py\n\nfrom datetime import datetime\nfrom pydantic import BaseModel\n\nclass TokenBase(BaseModel):\n    user_id: int\n    expires_at: datetime\n    is_active: bool = True\n    ip_address: str | None = None\n\nclass TokenCreate(TokenBase):\n    pass\n\nclass TokenOut(BaseModel):\n    access_token: str\n    token_type: str = \"Bearer\"\n```", "```py\n\"\"\"create users and tokens tables\n\nRevision ID: 1234567890ab\nRevises:\nCreate Date: 2025-01-28 12:34:56.789012\n\n\"\"\"\n\nfrom datetime import UTC, datetime\nimport sqlalchemy as sa\nfrom alembic import op\n\n...\n\ndef upgrade():\n    op.create_table(\n        \"users\",\n        sa.Column(\"id\", sa.UUID(as_uuid=True)), ![1](assets/1.png)\n        sa.Column(\"email\", sa.String(length=255)),\n        sa.Column(\"hashed_password\", sa.String(length=255)), ![2](assets/2.png)\n        sa.Column(\n            \"is_active\", sa.Boolean(), server_default=sa.sql.expression.true()\n        ), ![3](assets/3.png)\n        sa.Column(\"role\", sa.String(), server_default=sa.text(\"USER\")), ![4](assets/4.png)\n        sa.Column(\"created_at\", sa.DateTime(), default=datetime.now(UTC)),\n        sa.Column(\n            \"updated_at\",\n            sa.DateTime(),\n            default=datetime.now(UTC),\n            onupdate=datetime.now(UTC), ![5](assets/5.png)\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.UniqueConstraint(\"email\"),\n        sa.Index(\"ix_users_email\", \"email\"), ![6](assets/6.png)\n    )\n\n    op.create_table(\n        \"tokens\",\n        sa.Column(\"id\", sa.UUID(as_uuid=True)), ![1](assets/1.png)\n        sa.Column(\"user_id\", sa.Integer()),\n        sa.Column(\"expires_at\", sa.DateTime()), ![7](assets/7.png)\n        sa.Column(\"is_active\", sa.Boolean(), default=True), ![8](assets/8.png)\n        sa.Column(\"ip_address\", sa.String(length=255), nullable=True),\n        sa.Column(\"created_at\", sa.DateTime(), default=datetime.now(UTC)),\n        sa.Column(\n            \"updated_at\",\n            sa.DateTime(),\n            default=datetime.now(UTC),\n            onupdate=datetime.now(UTC), ![9](assets/9.png)\n        ),\n        sa.ForeignKeyConstraint(\n            [\"user_id\"],\n            [\"users.id\"],\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.Index(\"ix_tokens_user_id\", \"user_id\"),\n        sa.Index(\"ix_tokens_ip_address\", \"ip_address\"), ![10](assets/10.png)\n    )\n\ndef downgrade():\n    op.drop_table(\"tokens\")\n    op.drop_table(\"users\")\n```", "```py\n# services/auth.py\n\nfrom fastapi.security import HTTPBearer\nfrom passlib.context import CryptContext\n\nclass PasswordService:\n    security = HTTPBearer()\n    pwd_context = CryptContext(schemes=[\"bcrypt\"]) ![1](assets/1.png)\n\n    async def verify_password(\n        self, password: str, hashed_password: str\n    ) -> bool:\n        return self.pwd_context.verify(password, hashed_password) ![2](assets/2.png)\n\n    async def get_password_hash(self, password: str) -> str:\n        return self.pwd_context.hash(password) ![2](assets/2.png)\n```", "```py\n# exceptions.py\n\nfrom fastapi import HTTPException, status\n\nUnauthorizedException = HTTPException(\n    status_code=status.HTTP_401_UNAUTHORIZED,\n    detail=\"Not authenticated\",\n    headers={\"WWW-Authenticate\": \"Bearer\"},\n)\n\nAlreadyRegisteredException = HTTPException(\n    status_code=status.HTTP_400_BAD_REQUEST,\n    detail=\"Username already registered\",\n)\n```", "```py\n# repositories.py\n\nfrom entities import Token\nfrom repositories.interfaces import Repository\nfrom schemas import TokenCreate, TokenUpdate\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass TokenRepository(Repository):\n    def __init__(self, session: AsyncSession) -> None:\n        self.session = session\n\n    async def list(self, skip: int, take: int) -> list[Token]:\n        async with self.session.begin():\n            result = await self.session.execute(\n                select(Token).offset(skip).limit(take)\n            )\n        return [r for r in result.scalars().all()]\n\n    async def get(self, token_id: int) -> Token | None:\n        async with self.session.begin():\n            result = await self.session.execute(\n                select(Token).where(Token.id == token_id)\n            )\n        return result.scalars().first()\n\n    async def create(self, token: TokenCreate) -> Token:\n        new_token = Token(**token.dict())\n        async with self.session.begin():\n            self.session.add(new_token)\n            await self.session.commit()\n            await self.session.refresh(new_token)\n        return new_token\n\n    async def update(\n        self, token_id: int, updated_token: TokenUpdate\n    ) -> Token | None:\n        token = await self.get(token_id)\n        if not token:\n            return None\n        for key, value in updated_token.dict(exclude_unset=True).items():\n            setattr(token, key, value)\n        async with self.session.begin():\n            await self.session.commit()\n            await self.session.refresh(token)\n        return token\n\n    async def delete(self, token_id: int) -> None:\n        token = await self.get(token_id)\n        if not token:\n            return\n        async with self.session.begin():\n            await self.session.delete(token)\n            await self.session.commit()\n```", "```py\n# services/auth.py\n\nfrom datetime import UTC, datetime, timedelta\nfrom exceptions import UnauthorizedException\nfrom jose import JWTError, jwt\nfrom pydantic import UUID4\nfrom repositories import TokenRepository\nfrom schemas import TokenCreate, TokenUpdate\n\nclass TokenService(TokenRepository):\n    secret_key = \"your_secret_key\"\n    algorithm = \"HS256\"\n    expires_in_minutes = 60 ![1](assets/1.png)\n\nasync def create_access_token(\n    self, data: dict, expires_delta: timedelta | None = None ![2](assets/2.png)\n) -> str:\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(UTC) + expires_delta\n    else:\n        expire = datetime.now(UTC) + timedelta(minutes=self.expires_in_minutes)\n    token_id = await self.create(TokenCreate(expires_at=expire)) ![3](assets/3.png)\n    to_encode.update(\n        {\"exp\": expire, \"iss\": \"your_service_name\", \"sub\": token_id} ![4](assets/4.png)\n    )\n    encoded_jwt = jwt.encode(\n        to_encode, self.secret_key, algorithm=self.algorithm ![5](assets/5.png)\n    )\n    return encoded_jwt\n\nasync def deactivate(self, token_id: UUID4) -> None:\n    await self.update(TokenUpdate(id=token_id, is_active=False))\n\ndef decode(self, encoded_token: str) -> dict:\n    try:\n        return jwt.decode(\n            encoded_token, self.secret_key, algorithms=[self.algorithm]\n        )\n    except JWTError:\n        raise UnauthorizedException\n\nasync def validate(self, token_id: UUID4) -> bool:\n    return (token := await self.get(token_id)) is not None and token.is_active\n```", "```py\n# services/auth.py\n\nfrom typing import Annotated\nfrom databases import DBSessionDep\nfrom entities import Token, User, UserCreate, UserInDB\nfrom exceptions import AlreadyRegisteredException, UnauthorizedException\nfrom fastapi import Depends\nfrom fastapi.security import (HTTPAuthorizationCredentials, HTTPBearer,\n                              OAuth2PasswordRequestForm)\nfrom services.auth import PasswordService, TokenService\nfrom services.users import UserService\n\nsecurity = HTTPBearer()\nLoginFormDep = Annotated[OAuth2PasswordRequestForm, Depends()]\nAuthHeaderDep = Annotated[HTTPAuthorizationCredentials, Depends(security)]\n\nclass AuthService:\n    def __init__(self, session: DBSessionDep):\n        self.password_service = PasswordService()\n        self.token_service = TokenService(session)\n        self.user_service = UserService(session)\n\n    async def register_user(self, user: UserCreate) -> User:\n        if await self.user_service.get(user.username):\n            raise AlreadyRegisteredException\n        hashed_password = await self.password_service.get_password_hash(\n            user.password\n        )\n        return await self.user_service.create(\n            UserInDB(username=user.username, hashed_password=hashed_password)\n        )\n\n    async def authenticate_user(self, form_data: LoginFormDep) -> Token: ![1](assets/1.png)\n        if not (user := await self.user_service.get_user(form_data.username)):\n            raise UnauthorizedException\n        if not await self.password_service.verify_password(\n            form_data.password, user.hashed_password\n        ):\n            raise UnauthorizedException\n        return await self.token_service.create_access_token(user._asdict())\n\n    async def get_current_user(self, credentials: AuthHeaderDep) -> User:\n        if credentials.scheme != \"Bearer\":\n            raise UnauthorizedException\n        if not (token := credentials.credentials):\n            raise UnauthorizedException\n        payload = self.token_service.decode(token)\n        if not await self.token_service.validate(payload.get(\"sub\")):\n            raise UnauthorizedException\n        if not (username := payload.get(\"username\")):\n            raise UnauthorizedException\n        if not (user := await self.user_service.get(username)):\n            raise UnauthorizedException\n        return user\n\n    async def logout(self, credentials: AuthHeaderDep) -> None:\n        payload = self.token_service.decode(credentials.credentials)\n        await self.token_service.deactivate(payload.get(\"sub\"))\n\n    # Add Password Reset Method\n    async def reset_password(self): ...\n```", "```py\n# routes/auth.py\n\nfrom typing import Annotated\nfrom entities import User\nfrom fastapi import APIRouter, Depends\nfrom models import TokenOut, UserOut\nfrom services.auth import AuthService\n\nauth_service = AuthService()\nRegisterUserDep = Annotated[User, Depends(auth_service.register_user)]\nAuthenticateUserCredDep = Annotated[\n    str, Depends(auth_service.authenticate_user_with_credentials)\n]\nAuthenticateUserTokenDep = Annotated[User, Depends(auth_service.register_user)]\nPasswordResetDep = Annotated[None, Depends(auth_service.reset_password)] ![1](assets/1.png)\n\nrouter = APIRouter(prefix=\"/auth\", tags=[\"Authentication\"]) ![2](assets/2.png)\n\n@router.post(\"/register\")\nasync def register_user_controller(new_user: RegisterUserDep) -> UserOut:\n    return new_user\n\n@router.post(\"/token\") ![3](assets/3.png)\nasync def login_for_access_token_controller(\n    access_token: AuthenticateUserCredDep,\n) -> TokenOut:\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@router.post(\"/logout\", dependencies=[Depends(auth_service.logout)]) ![3](assets/3.png) ![4](assets/4.png)\nasync def logout_access_token_controller() -> dict:\n    return {\"message\": \"Logged out\"}\n\n@router.post(\"reset-password\") ![3](assets/3.png)\nasync def reset_password_controller(credentials: str) -> dict:\n    return {\n        \"message\": \"If an account exists, \"\n        \"a password reset link will be sent to the provided email\"\n    }\n```", "```py\n# routes/resource.py\n\nfrom fastapi import APIRouter\n\nrouter = APIRouter(prefix=\"/generate\", tags=[\"Resource\"]) ![1](assets/1.png)\n\n@router.get(\"/generate/text\", ...)\ndef serve_language_model_controller(...):\n    ...\n\n@router.get(\"/generate/audio\", ...)\ndef serve_text_to_audio_model_controller(...)\n    ...\n\n... # Add other controllers to the resource router here\n\n# main.py\n\nfrom typing import Annotated\nimport routes\nfrom entities import User\nfrom fastapi import Depends, FastAPI\nfrom services.auth import AuthService\n\nauth_service = AuthService()\nAuthenticateUserDep = Annotated[User, Depends(auth_service.get_current_user)]\n\n...\n\napp = FastAPI(lifespan=lifespan)\n\napp.include_router(routes.auth.router, prefix=\"/auth\", tags=[\"Auth\"]) ![2](assets/2.png)\napp.include_router(\n    routes.resource.router,\n    dependencies=[AuthenticateUserDep],\n    prefix=\"/generate\",\n    tags=[\"Generate\"],\n) ![3](assets/3.png)\n...  # Add other routes to the app here\n```", "```py\n# routes/auth.py\n\nimport secrets\nfrom fastapi import APIRouter, Request, status\nfrom fastapi.responses import RedirectResponse\n\nclient_id = \"your_client_id\"\nclient_secret = \"your_client_secret\"\n\nrouter = APIRouter()\n\n...\n\n@router.get(\"/oauth/github/login\", status_code=status.HTTP_301_REDIRECT)\ndef oauth_github_login_controller(request: Request) -> RedirectResponse:\n    state = secrets.token_urlsafe(16)\n    redirect_uri = request.url_for(\"oauth_github_callback_controller\")\n    response = RedirectResponse(\n        url=f\"https://github.com/login/oauth/authorize\"\n        f\"?client_id={client_id}\"\n        f\"&scope=user\"\n        f\"&state={state}\"\n        f\"&redirect_uri={redirect_uri}\"\n    ) ![1](assets/1.png)\n    csrf_token = secrets.token_urlsafe(16)\n    request.session[\"x-csrf-state-token\"] = csrf_token\n    return response\n```", "```py\n# client.py\n\nimport requests\nimport streamlit as st\n\nif st.button(\"Login with GitHub\"):\n    response = requests.get(\"http://localhost:8000/auth/oauth/github/login\")\n    if not response.ok:\n        st.error(\"Failed to login with GitHub. Please try again later\")\n        response.raise_for_status()\n```", "```py\n# dependencies/auth.py\n\nfrom typing import Annotated\nimport aiohttp\nfrom fastapi import Depends, HTTPException\nfrom loguru import logger\n\nclient_id = \"your_client_id\"\nclient_secret = \"your_client_secret\"\n\nasync def exchange_grant_with_access_token(code: str) -> str:\n    try:\n        body = {\n            \"client_id\": client_id,\n            \"client_secret\": client_secret,\n            \"code\": code,\n        }\n        headers = {\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n        }\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                \"https://github.com/login/oauth/access_token\",\n                json=body,\n                headers=headers,\n            ) as resp:\n                access_token_data = await resp.json()\n    except Exception as e:\n        logger.warning(f\"Failed to fetch the access token. Error: {e}\")\n        raise HTTPException(\n            status_code=503, detail=\"Failed to fetch access token\"\n        )\n\n    if not access_token_data:\n        raise HTTPException(\n            status_code=503, detail=\"Failed to obtain access token\"\n        )\n\n    return access_token_data.get(\"access_token\", \"\")\n\nExchangeCodeTokenDep = Annotated[str, Depends(exchange_grant_with_access_token)]\n```", "```py\n# routes/auth.py\n\nfrom dependencies.auth import ExchangeCodeTokenDep\nfrom fastapi import Depends, HTTPException, Request\nfrom fastapi.responses import RedirectResponse\n\n...\n\ndef check_csrf_state(request: Request, state: str) -> None:\n    if state != request.session.get(\"x-csrf-token\"):\n        raise HTTPException(detail=\"Bad request\", status_code=401)\n\n@router.get(\"/oauth/github/callback\", dependencies=[Depends(check_csrf_state)])\nasync def oauth_github_callback_controller(\n    access_token: ExchangeCodeTokenDep,\n) -> RedirectResponse:\n    response = RedirectResponse(url=f\"http://localhost:8501\")\n    response.set_cookie(key=\"access_token\", value=access_token, httponly=True)\n    return response\n```", "```py\n# main.py\n\nfrom fastapi import FastAPI\nfrom starlette.middleware.sessions import SessionMiddleware\n\n...\n\napp = FastAPI(lifespan=lifespan)\napp.add_middleware(SessionMiddleware, secret_key=\"your_secret_key\")\n```", "```py\n# routes/auth.py\n\nfrom typing import Annotated\nimport aiohttp\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\n\nsecurity = HTTPBearer()\nHTTPBearerDep = Annotated[HTTPAuthorizationCredentials, Depends(security)]\n\n...\n\nasync def get_user_info(credentials: HTTPBearerDep) -> dict:\n    try:\n        async with aiohttp.ClientSession() as session:\n            headers = {\"Authorization\": f\"Bearer {credentials.credentials}\"}\n            async with session.get(\n                \"https://api.github.com/user\", headers=headers\n            ) as resp:\n                return await resp.json()\n    except Exception as e:\n        raise HTTPException(\n            status_code=503, detail=f\"Failed to obtain user info - Error: {e}\"\n        )\n\nGetUserInfoDep = Annotated[dict, Depends(get_user_info)]\n\n@router.get(\"/oauth/github/callback\")\nasync def get_current_user_controller(user_info: GetUserInfoDep) -> dict:\n    return user_info\n```", "```py\n# dependencies/auth.py\n\nfrom entities import User\nfrom fastapi import Depends, HTTPException, status\nfrom services.auth import AuthService\n\nasync def is_admin(user: User = Depends(AuthService.get_current_user)) -> User: ![1](assets/1.png)\n    if user.role != \"ADMIN\":\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not allowed to perform this action\",\n        )\n    return user\n\n# routers/resource.py\n\nfrom dependencies.auth import is_admin\nfrom fastapi import APIRouter, Depends\nfrom services.auth import AuthService\n\nrouter = APIRouter(\n    dependencies=[Depends(AuthService.get_current_user)], ![3](assets/3.png)\n    prefix=\"/generate\",\n    tags=[\"Resource\"],\n)\n\n@router.post(\"/image\", dependencies=[Depends(is_admin)])\nasync def generate_image_controller(): ![2](assets/2.png)\n    ...\n\n@router.post(\"/text\") ![3](assets/3.png)\nasync def generate_text_controller():\n    ...\n```", "```py\n# dependencies/auth.py\n\nfrom typing import Annotated\n\nfrom entities import User\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom services.auth import AuthService\n\nCurrentUserDep = Annotated[User, Depends(AuthService.get_current_user)]\n\nasync def has_role(user: CurrentUserDep, roles: list[str]) -> User:\n    if user.role not in roles:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not allowed to perform this action\",\n        )\n    return user\n\n# routes/resource.py\n\n...\n\n@router.post(\n    \"/image\",\n    dependencies=[Depends(lambda user: has_role(user, [\"ADMIN\", \"MODERATOR\"]))],\n)\nasync def generate_image_controller():\n    ...\n\n@router.post(\n    \"/text\", dependencies=[Depends(lambda user: has_role(user, [\"EDITOR\"]))]\n)\nasync def generate_text_controller():\n    ...\n```", "```py\n# dependencies/auth.py\n\nfrom typing import Annotated\nfrom fastapi import Depends, HTTPException, status\n...  # import services and entities here\n\nCurrentUserDep = Annotated[User, Depends(AuthService.get_current_user)]\nTeamMembershipRep = Annotated[Team, Depends(TeamService.get_current_team)]\nResourceDep = Annotated[Resource, Depends(ResourceService.get_resource)]\n\ndef authorize(\n    user: CurrentUserDep, resource: ResourceDep, team: TeamMembershipRep\n) -> bool:\n    if user.role == \"ADMIN\":\n        return True\n    if user.id in team.members:\n        return True\n    if resource.is_public:\n        return True\n    raise HTTPException(\n        status_code=status.HTTP_403_FORBIDDEN, detail=\"Access Denied\"\n    )\n\n# routes/resource.py\n\nfrom dependencies.auth import authorize\nfrom fastapi import APIRouter, Depends\n\nrouter = APIRouter(\n    dependencies=[Depends(authorize)], prefix=\"/generate\", tags=[\"Resource\"]\n)\n\n@router.post(\"/image\")\nasync def generate_image_controller(): ...\n\n@router.post(\"/text\")\nasync def generate_text_controller(): ...\n```", "```py\n# authorization_api.py (Authorization Service)\n\nfrom typing import Annotated, Literal\nfrom fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\n...  # import services and entities here\n\nCurrentUserDep = Annotated[User, Depends(AuthService.get_current_user)]\nActionRep = Annotated[Literal[\"READ\", \"CREATE\", \"UPDATE\", \"DELETE\"], str]\nResourceDep = Annotated[Resource, Depends(ResourceService.get_resource)]\n\nclass AuthorizationResponse(BaseModel):\n    allowed: bool\n\napp = FastAPI()\n\napp.get(\"/authorize\")\ndef authorization_controller(\n    user: CurrentUserDep, resource: ResourceDep, action: ActionRep\n) -> AuthorizationResponse:\n    if user.role == \"ADMIN\":\n        return AuthorizationResponse(allowed=True)\n    if action in user.permissions.get(resource.id, []):\n        return AuthorizationResponse(allowed=True)\n    ...  # Other permission checks\n    return AuthorizationResponse(allowed=False)\n\n# genai_api.py (GenAI Service)\n\nfrom fastapi import APIRouter, HTTPException, status\nfrom pydantic import BaseModel\n\nclass AuthorizationData(BaseModel):\n    user_id: int\n    resource_id: int\n    action: str\n\nauthorization_client = ...  # Create authorization client\n\nasync def enforce(data: AuthorizationData) -> bool:\n    response = await authorization_client.decide(data)\n    if response.allowed:\n        return True\n    raise HTTPException(\n        status_code=status.HTTP_403_FORBIDDEN, detail=\"Access Denied\"\n    )\n\nrouter = APIRouter(\n    dependencies=[Depends(enforce)], prefix=\"/generate\", tags=[\"Resource\"]\n)\n\n@router.post(\"/text\")\nasync def generate_text_controller():\n    ...\n```"]