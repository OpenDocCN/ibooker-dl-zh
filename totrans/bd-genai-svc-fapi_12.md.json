["```py\nimport secrets\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import HTTPBasic, HTTPBasicCredentials\n\napp = FastAPI()\nsecurity = HTTPBasic() ![1](assets/1.png)\nusername_bytes = b\"ali\"\npassword_bytes = b\"secretpassword\"\n\ndef authenticate_user(\n    credentials: Annotated[HTTPBasicCredentials, Depends(security)]\n) -> str:\n    is_correct_username = secrets.compare_digest(\n        credentials.username.encode(\"UTF-8\"), username_bytes ![2](assets/2.png)\n    )\n    is_correct_password = secrets.compare_digest(\n        credentials.password.encode(\"UTF-8\"), password_bytes ![2](assets/2.png)\n    )\n    if not (is_correct_username and is_correct_password):\n        raise HTTPException( ![3](assets/3.png)\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect credentials\",\n            headers={\"WWW-Authenticate\": \"Basic\"},\n        )\n    return credentials.username\n\nAuthenticatedUserDep = Annotated[str, Depends(authenticate_user)] ![4](assets/4.png)\n\n@app.get(\"/users/me\")\ndef get_current_user_controller(username: AuthenticatedUserDep): ![4](assets/4.png)\n    return {\"message\": f\"Current user is {username}\"}\n```", "```py\n$ pip install passlib python-jose\n```", "```py`Una volta installate le dipendenze, avrai bisogno di tabelle nel database per memorizzare gli utenti generati e i dati dei token associati. Per la persistenza dei dati, migriamo il database per creare le tabelle `users` e `tokens`, come mostrato nella [Figura 8-4](#erd).  ![bgai 0804](assets/bgai_0804.png)  ###### Figura 8-4\\. Diagramma delle relazioni tra entità delle tabelle `users` e `tokens`    Se guardi la [Figura 8-4](#erd), noterai che la tabella `tokens` ha una relazione uno-a-molti con la tabella `users`. Puoi usare i record dei token per tenere traccia dei tentativi di accesso riusciti per ogni utente e per revocare l'accesso se necessario.    Definiamo quindi i modelli SQLAlchemy e gli schemi Pydantic necessari per le query al database e la validazione dei dati, come mostrato negli Esempi [8-2](#user_models) e [8-3](#users_schema).    ##### Esempio 8-2\\. Dichiarare i modelli ORM SQLAlchemy dell'utente    ```", "```py    Utilizzerai i modelli ORM nel livello di accesso ai dati, mentre gli schemi Pydantic convalideranno i dati di autenticazione in entrata e in uscita nel livello endpoint.    ##### Esempio 8-3\\. Dichiarare gli schemi Pydantic degli utenti con i validatori dei campi username e password    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO2-1)      Convalida sia il nome utente che la password per applicare requisiti di sicurezza più elevati.      [![2](assets/2.png)](#co_authentication_and_authorization_CO2-3)      Permettere a Pydantic di leggere gli attributi dei modelli ORM di SQLAlchemy invece di dover popolare manualmente gli schemi di Pydantic dai modelli di SQLAlchemy.      [![3](assets/3.png)](#co_authentication_and_authorization_CO2-4)      Usa l'ereditarietà per dichiarare diversi schemi Pydantic basati su un modello di base dell'utente.      [![4](assets/4.png)](#co_authentication_and_authorization_CO2-5)      Crea uno schema separato che accetti il campo `hashed_password` da utilizzare solo per la creazione di nuovi record utente durante il processo di registrazione. Tutti gli altri schemi devono evitare di memorizzare questo campo per eliminare il rischio di fuga della password.      La creazione dei modelli e degli schemi dei token è abbastanza simile, come puoi vedere nell'[Esempio 8-4](#token_models).    ##### Esempio 8-4\\. Dichiarare i modelli ORM a token e gli schemi Pydantic    ```", "```py    Il prossimo, generiamo automaticamente un file di migrazione usando il comando `alembic revision --autogenerate -m \"create users and tokens tables` in modo da poter specificare i dettagli di entrambe le tabelle seguendo l'[Esempio 8-5](#users_migration).    ##### Esempio 8-5\\. Migrazione del database per creare le tabelle `users` e `tokens`    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO3-1)      Generare automaticamente identificatori universalmente univoci (UUID) nel livello del database per i record degli utenti e dei token per impedire agli aggressori di indovinare gli identificatori delle risorse sensibili (ad esempio, i record degli utenti o dei token).      [![2](assets/2.png)](#co_authentication_and_authorization_CO3-2)      Evita di memorizzare stringhe di password grezze nel database per ridurrele vulnerabilità della sicurezza.      [![3](assets/3.png)](#co_authentication_and_authorization_CO3-3)      Aggiungi la possibilità di abilitare o disabilitare l'accesso all'account.      [![4](assets/4.png)](#co_authentication_and_authorization_CO3-4)      Aggiungi la possibilità di specificare ruoli utente come `USER` e `ADMIN` per gestire i livelli di accesso di un account. I controlli di autorizzazione utilizzeranno il campo `role` per gestire l'accesso alle risorse privilegiate.      [![5](assets/5.png)](#co_authentication_and_authorization_CO3-5)      Stampa automaticamente la creazione e gli aggiornamenti degli utenti per scopi di monitoraggio e sicurezza.      [![6](assets/6.png)](#co_authentication_and_authorization_CO3-6)      Aggiungi un vincolo univoco e un indice secondario sul campo email per ottimizzare le query degli utenti per email ed eliminare la possibilità di creare account email duplicati.      [![7](assets/7.png)](#co_authentication_and_authorization_CO3-8)      I token devono scadere dopo un breve periodo di tempo per ridurre la finestra temporale in cui i token esposti possono essere utilizzati impropriamente dagli aggressori.      [![8](assets/8.png)](#co_authentication_and_authorization_CO3-9)      Aggiungi la possibilità di disabilitare i token che non devono più essere validi perché esposti o se un utente si è disconnesso.      [![9](assets/9.png)](#co_authentication_and_authorization_CO3-10)      Traccia i tempi di creazione e aggiornamento dei token per il monitoraggio e la sicurezza.      [![10](assets/10.png)](#co_authentication_and_authorization_CO3-11)      Crea indici secondari sui campi `user_id` e `ip_address` per ottimizzare le query sui token in base a questi campi.      Ora esegui il comando `alembic upgrade head` per eseguire la migrazione dell'[Esempio 8-5](#users_migration) nel tuo database e creare le tabelle `users` e `tokens`.    Una volta dichiarati i modelli ORM e gli schemi Pydantic, puoi concentrarti sulla logica del meccanismo di autenticazione.    La[Figura 8-5](#jwt_architecture) mostra l'architettura del sistema di autenticazione JWT che implementerai nel tuo servizio FastAPI GenAI.  ![bgai 0805](assets/bgai_0805.png)  ###### Figura 8-5\\. Architettura del sistema di autenticazione JWT    Nei seguenti esempi di codice, vedrai come implementare i flussi di autenticazione principali, a partire dalla registrazione dell'utente e dalla generazione di JWT.```", "```py`### Hashing e salatura    Il primo passo da fare dopo aver creato le tabelle `users` e `tokens` nel database è quello di memorizzare i nuovi utenti nel database al momento della registrazione. Tuttavia, dovresti evitare di memorizzare le password in chiaro, perché se il database viene compromesso, i malintenzionati avranno le credenziali di ogni utente.    Invece, il meccanismo di autenticazione sfrutterà un *algoritmo di hashing* che converte le password semplici in una stringa codificata che non può essere decodificata nella sua forma originale. Poiché il processo di decodifica non è reversibile, gli algoritmi di hashing crittografici differiscono dalle funzioni di codifica/decodifica standard come Base64.    Sebbene la memorizzazione di password con hash sia più sicura rispetto alla memorizzazione di password semplici, non fornisce una protezione sufficiente.Se un database di password con hash cade nelle mani degli aggressori, questi possono utilizzare tabelle di hash precompilate, comunemente chiamate *tabelle arcobaleno*. Gli aggressori possono utilizzare le tabelle arcobaleno per entrare nel tuo sistema con la forza bruta recuperando le password in chiaro.Per proteggerti da questi attacchi con forza bruta, devi anche introdurre un elemento di casualità nel processo di hashing utilizzando una tecnica chiamata *salatura*.    Con i sali, l'algoritmo di hashing crittografico produce password diverse, anche se gli utenti possono registrarsi con password comuni, compromesse o duplicate.    ###### Avvertenze    L'hashing delle password con un sale casuale protegge dagli attacchi brute-force che utilizzano le tabelle arcobaleno.Tuttavia, non protegge dal *password spraying*, in cui gli aggressori utilizzano un database di password comuni, o dal *credential stuffing*, in cui gli aggressori enumerano un elenco di password compromesse.    Durante la salatura, la funzione di hashing genera un sale casuale da aggiungere alla password semplice prima dell'hashing e quindi genera una password con hash.^([4](ch08.html#id982)) Prima di memorizzare la password con hash nel database, il sale viene aggiunto alla password con hash per poterla recuperare successivamente durante la verifica.    Quando gli utenti registrati tentano di accedere, devono fornire la stessa password che hanno usato per creare il loro account. Durante il processo di verifica della password, la password fornita dall'utente viene sottoposta a hashish utilizzando lo stesso sale usato durante la registrazione, che viene recuperato dal database. Se la password hash generata è esattamente identica a quella presente nel database, allora l'utente viene autenticato. In caso contrario, si può tranquillamente supporre che siano state fornite credenziali sbagliate.    La salatura e l'hashing sono tecniche potenti che impediscono agli aggressori di penetrare brutalmente nel tuo sistema con le tabelle arcobaleno. Puoi vedere l'intero processo di hashing e salatura nella [Figura 8-6](#password_hashing).  ![bgai 0806](assets/bgai_0806.png)  ###### Figura 8-6\\. Meccanismo di salatura dell'hash della password    Il servizio password mostrato nella [Figura 8-6](#password_hashing) è implementato come `PasswordService` nell'[Esempio 8-6](#password_service).    ##### Esempio 8-6\\. Implementare un servizio di password    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO4-1)      Crea un `AuthService` con un contesto di segreti e password gestito dalla libreria `bcrypt` che gestirà l'hashing e la verifica delle password degli utenti.      [![2](assets/2.png)](#co_authentication_and_authorization_CO4-2)      Utilizza l'algoritmo di crittografia di `bcrypt`e il segreto dell'applicazione per eseguire l'hash e verificare le password.      La libreria crittografica `bcrypt` fornisce le funzionalità principali di `Password​Ser⁠vice` per l'hashing e la verifica delle password. Utilizzando questo servizio, le richieste possono essere autenticate.    Se una richiesta non può essere autenticata, dovrai anche sollevare delle eccezioni legate all'autorizzazione, come mostrato nell'[Esempio 8-7](#auth_exceptions).    ##### Esempio 8-7\\. Creare eccezioni di autenticazione    ```", "```py    Le due eccezioni HTTP di autorizzazione più comuni sono legate ad accessi non autorizzati o a richieste errate dovute all'utilizzo di nomi utente già usati.    Una volta verificata l'identità di un utente tramite le sue credenziali, dovrai rilasciargli un *token di accesso*. Questi token dovrebbero avere una vita breve per ridurre l'intervallo di tempo in cui un malintenzionato può utilizzare il token per accedere alle risorse se il token viene rubato.    Per ridurre le dimensioni dei token e proteggerli da eventuali *falsificazioni*, il servizio token firmerà (utilizzando un segreto) e codificherà i payload dei token con una codifica come Base64\\. Il payload conterrà normalmente i dati dell'utente come l'ID, il ruolo, il sistema di emissione e le date di scadenza.    Il servizio token può anche decodificare il payload dei token ricevuti e verificarne la validità durante il processo di autenticazione.    Infine, anche il servizio token avrà bisogno di accedere al database per memorizzare e recuperare i token per svolgere le sue funzioni. Pertanto, dovrà ereditare un `TokenRepository`, come mostrato nell'[Esempio 8-8](#token_repository).    ##### Esempio 8-8\\. Implementazione del repository di token    ```", "```py    Con l'implementazione di `TokenRepository`, puoi ora sviluppare `TokenService`, come mostrato nell'[Esempio 8-9](#token_service).    ##### Esempio 8-9\\. Implementare un servizio di token ereditando il repository dei token    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO5-1)      Implementa un `TokenService` per l'emissione e la verifica dei token di autenticazione. Le configurazioni sono condivise da tutte le istanze del servizio.      [![2](assets/2.png)](#co_authentication_and_authorization_CO5-2)      Genera token di accesso basati sui dati forniti al servizio token con date di scadenza.      [![3](assets/3.png)](#co_authentication_and_authorization_CO5-3)      Crea un record di token nel database e ottiene un identificatore unico.      [![4](assets/4.png)](#co_authentication_and_authorization_CO5-4)      Il token di accesso deve scadere entro un'ora, quindi il campo calcolato `exp` verrà utilizzato per verificare la validità del token.      [![5](assets/5.png)](#co_authentication_and_authorization_CO5-5)      Codifica il token generato in una stringa codificata utilizzando l'algoritmo `base64`.      Ora che hai un `PasswordService` e un `TokenService`, puoi completare il meccanismo di autenticazione JWT di base con un `AuthService` dedicato di livello superiore.    L['esempio 8-10](#auth_service) mostra l'implementazione della classe `AuthService` che contiene diverse funzioni di dipendenza per la registrazione degli utenti, l'emissione di token di accesso e la protezione dei percorsi API.    ##### Esempio 8-10\\. Implementare un servizio auth per gestire la logica di autenticazione di livello superiore    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO6-1)      La logica di autenticazione principale dell'applicazione che verifica l'esistenza di un utente e le credenziali della sua password. Restituisce `False` se i controlli falliscono.      Ora puoi utilizzare `AuthService` per registrare e autenticare gli utenti utilizzando le loro credenziali. Fai riferimento all'[Esempio 8-11](#auth_controllers) per vedere come `AuthService` viene utilizzato per creare le dipendenze necessarie per un router di autenticazione dedicato.    ##### Esempio 8-11\\. Implementare i controllori di autenticazione per abilitare le funzionalità di login e registrazione    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO7-1)      Crea un'istanza di `AuthService` e dichiara ledipendenze annotate riutilizzabili.      [![2](assets/2.png)](#co_authentication_and_authorization_CO7-2)      Crea un router API separato per gli endpoint di autenticazione.      [![3](assets/3.png)](#co_authentication_and_authorization_CO7-3)      Implementa gli endpoint per la registrazione degli utenti, il login degli utenti (emissione del token), il logout degli utenti (revoca del token) e la reimpostazione della password.      [![4](assets/4.png)](#co_authentication_and_authorization_CO7-5)      Poiché la dipendenza di `LogoutUserDep` non restituirà nulla, iniettala nell'array delle dipendenze del router.      Una volta che hai un router di autenticazione dedicato, crea un router di risorse separato per raggruppare tutti i tuoi endpoint di risorse. Con entrambi i router, puoi ora aggiungerli alla tua applicazione FastAPI, come mostrato nell'[Esempio 8-12](#routers), per completare il lavoro di autenticazione JWT.    ##### Esempio 8-12\\. Riformulare l'applicazione FastAPI per utilizzare i router    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO8-1)      Riformulare gli endpoint esistenti per raggrupparli in un router API separato chiamato router delle risorse.      [![2](assets/2.png)](#co_authentication_and_authorization_CO8-2)      Aggiungi i router auth e resource al router FastAPI `app`.      [![3](assets/3.png)](#co_authentication_and_authorization_CO8-3)      Proteggi gli endpoint delle risorse iniettando la dipendenza da `AuthenticateUserDep` a livello di router. Le richieste devono ora includere un'intestazione `Authorization` con un token del portatore per essere autenticate con il router delle risorse.      Congratulazioni vivissime: ora hai un servizio GenAI perfettamente funzionante e protetto dall'autenticazione JWT, che può essere messo in produzione con un po' di lavoro in più.    Nella prossima sezione scoprirai alcune idee su ulteriori miglioramenti che puoi apportare al sistema per rafforzare la sicurezza del tuo sistema di autenticazione JWT.    ### Flussi di autenticazione    Dovrai gestire diversi flussi di autenticazione per implementare completamente un sistema di autenticazione JWT utilizzabile.    I flussi di autenticazione *principali* sono i seguenti:    Registrazione utente      I nuovi utenti dovranno registrare un nuovo account fornendo la propria email e una password sicura. La tua logica di autenticazione può verificare la forza della password, l'assenza di utenti esistenti con la stessa email e che l'utente riconfermi la password e l'email. Dovresti anche evitare di memorizzare la password grezza dell'utente nel database.      Accesso utente      Ad ogni accesso dell'utente, il tuo sistema può generare, memorizzare e fornire un token di accesso temporaneo unico (cioè un JWT) se l'utente fornisce le sue credenziali corrette. I router del tuo server di risorse protette dovrebbero rifiutare qualsiasi richiesta in entrata che non contenga un JWT valido. I JWT validi possono essere verificati attraverso la loro firma e confrontati con i token validi specificati nel database.      Logout dell'utente      Quando l'utente si disconnette, il tuo sistema può revocare il token attualmente rilasciato e impedire futuri tentativi di accesso malevoli con il token attuale.      Oltre ai flussi principali, dovresti considerare anche i flussi *secondari* per implementare un sistema di autenticazione pronto per la produzione. Questi flussi possono essere utilizzati per:    Verifica dell'identità      Per evitare che gli spambot registrino account attivi nel tuo sistema e consumino le risorse del server, dovrai predisporre una qualche forma di meccanismo di verifica degli utenti. Ad esempio, puoi aggiungere la verifica via e-mail integrando un server di posta elettronica al tuo sistema di autenticazione.      Ripristino delle password      Gli utenti possono dimenticare la propria password in qualsiasi momento. Dovrai implementare un flusso che permetta agli utenti di reimpostare la propria password. Se un utente reimposta la propria password, tutti i token attivi nel database relativi al suo account utente devono essere revocati.      Forzare il logout      Revoca tutti i token di accesso generati in precedenza da un utente su tutti i client per evitare che i token rubati vengano utilizzati per accedere al sistema.      Disabilitare gli account utente      Gli amministratori o gli utenti potrebbero voler disabilitare i loro account per evitare futuri tentativi di accesso.      Eliminazione degli account utente      Questo è necessario se gli utenti desiderano rimuovere i loro account dai tuoi sistemi. A seconda delle tue esigenze di archiviazione dei dati, potresti voler eliminare le informazioni di identificazione personale mantenendo gli altri dati associati.      Blocco dei tentativi di accesso successivi      Disabilita temporaneamente un account che ha avuto più tentativi di accesso falliti in un breve lasso di tempo.      Fornire token di aggiornamento      Generare sia token *di accesso* di breve durata che token di *aggiornamento* di lunga durata. Poiché i token di accesso possono scadere frequentemente per ridurre la finestra di opportunità per gli aggressori di utilizzare un token rubato, i clienti possono riutilizzare il loro token di aggiornamento per richiedere nuovi token di accesso. In questo modo si elimina la necessità di effettuare login frequenti, mantenendo la sicurezza del sistema contro gli aggressori.      Autenticazione a due fattori (2FA) o autenticazione a più fattori (MFA)      Puoi proteggere il tuo sistema dagli account protetti da password esposte richiedendo 2FA o MFA come ulteriore livello di protezione. Esempi di 2FA/MFA sono la verifica via SMS/email, le password monouso (OTP) o le sequenze di numeri generati casualmente da un'app di autenticazione abbinata come secondo passaggio di login prima che possa essere generato un token di accesso.      ###### Avvertenze    L'elenco di cui sopra non è esaustivo. Puoi consultare la [\"OWASP Top 10 Web Applications Security Risks\"](https://oreil.ly/xAGfn) e [\"OWASP Authentication Cheat Sheet\"](https://oreil.ly/oSyuz) per un elenco completo di considerazioni da fare per implementare la tua autenticazione JWT da zero.    Oltre a seguire le linee guida della top 10 di OWASP, dovresti utilizzare meccanismi di sicurezza come la *limitazione del tasso*, il *tracciamento geo/IP* e il *blocco dell'account* per difenderti da vari attacchi.    Puoi anche prendere in considerazione l'utilizzo di fornitori di autenticazione di terze parti (come Okta/Auth0, Firebase Auth, KeyCloak, Amazon Cognito, ecc.) che includono queste funzioni di sicurezza nei loro servizi.    Sebbene l'autenticazione basata sulle credenziali che utilizza i JWT possa essere considerata un sistema di autenticazione pronto per la produzione e possa essere ulteriormente migliorata con i sistemi MFA in uso, il meccanismo ha i suoi limiti. Ad esempio, come già accennato in precedenza, richiedere le credenziali e memorizzare le password con hash in un database può comportare rischi per la sicurezza se gli aggressori sfruttano gli attacchi brute-force di password spraying o credential stuffing.    Inoltre, se hai bisogno di accedere a risorse utente esterne al tuo sistema, dovrai implementare meccanismi aggiuntivi per verificare l'identità della tua applicazione con fornitori di identità esterni.Poiché questa rimane un'esigenza comune a molte applicazioni e servizi, è stato sviluppato un protocollo chiamato OAuth per facilitare l'interoprocesso.    Vediamo come utilizzare l'autenticazione OAuth per aggiungere altre opzioni di login per gli utenti e per accedere a risorse esterne. Questo può migliorare le prestazioni dei tuoi servizi GenAI e generare output di qualità superiore .```", "```py`# Implementare l'autenticazione OAuth    In questo capitolo abbiamo accennato al concetto di autenticazione OAuth tramite identity provider.    OAuth è uno standard aperto per la delega degli accessi, spesso utilizzato per concedere a siti web o applicazioni un accesso limitato alle informazioni degli utenti senza esporre le password. Permette di autenticare gli utenti utilizzando identity provider come Google, Facebook, ecc. e concede alla tua applicazione l'accesso alle risorse dell'utente come calendari, file, social feed, ecc. su servizi esterni.    Utilizzando OAuth, puoi semplificare l'implementazione dell'autenticazione nella tua applicazione sfruttando i fornitori di identità esistenti invece di creare meccanismi di autenticazione propri come JWT.    Gli*Identity Provider* (IDP) sono piattaforme che consentono ad altre applicazioni, come il tuo servizio GenAI, di integrarsi con i loro sistemi di identità e autenticazione e di affidarsi ad essi per accedere alle risorse per conto degli utenti attraverso un processo standardizzato. L'IDP autentica gli utenti ed emette token di sicurezza che attestano l'identità dell'utente e altri attributi. GitHub, Google, Microsoft 365, Apple, Meta e LinkedIn sono solo alcune delle centinaia di identity provider.    Il protocollo che alimenta l'intero flusso è *OAuth 2.0*, un framework di autorizzazione che consente alle applicazioni di accedere in modo limitato a un altro servizio per conto di un utente.    Utilizzando questo approccio, la tua applicazione può reindirizzare gli utenti verso piattaforme di identity provider in modo che gli utenti possano concedere un accesso limitato nel tempo ai loro account su tali piattaforme. Dopo che l'utente ha dato il suo consenso, la tua applicazione può eseguire operazioni a suo nome sulle sue risorse, come i calendari, o leggere le informazioni del suo profilo, comprese le informazioni di identificazione personale come le e-mail o le immagini.    Di conseguenza, l'autenticazione OAuth viene spesso utilizzata per verificare l'identità degli utenti, in quanto ci si fida del processo di autenticazione della piattaforma esterna/del fornitore di identità. Pertanto, questo approccio riduce l'onere di memorizzare e proteggere le credenziali degli utenti nel tuo sistema, che può essere soggetto ad attacchi di forza bruta su password deboli o compromesse.    In questa sezione, implementerai una variante di OAuth basata sul *flusso di codice di autorizzazione* comunemente utilizzato nelle applicazioni moderne. Il processo passo dopo passo è il seguente:    1.  L'utente clicca sul pulsante di login della tua applicazione per avviare il flusso di autenticazione.           2.  L'utente viene reindirizzato alla pagina di login del fornitore di identità e la tua applicazione fornisce un ID cliente e un segreto al fornitore di identità per identificarsi.           3.  L'utente accede al proprio account e viene presentato con una schermata di consenso come quella mostrata nella [Figura 8-7](#oauth2_consent_screen) che presenta gli ambiti (cioè i permessi) che la tua applicazione sta richiedendo per suo conto.          ![bgai 0807](assets/bgai_0807.png)          ###### Figura 8-7\\. Esempio di schermata di consenso           4.  L'utente concede tutti, alcuni o nessuno degli ambiti richiesti.           5.  Se il consenso non viene rifiutato dall'utente (cioè dal proprietario della risorsa), il server di autorizzazione dell'identity provider rilascia alla tua applicazione un *codice di concessione* verso un endpoint da te fornito, chiamato *URI di reindirizzamento*. Se l'URI di reindirizzamento non è stato precedentemente approvato dall'identity provider, quest'ultimo rifiuterà di rilasciare un codice di concessione.           6.  Dopo aver ricevuto un codice di concessione associato alla sessione utente, agli ambiti consentiti e all'ID client dell'applicazione, l'applicazione può scambiare questo codice di concessione con il server di autorizzazione per un *token di accesso di breve durata* e un *token di aggiornamento di durata maggiore*. Puoi usare il token di aggiornamento per richiedere nuovi token di accesso senza dover riavviare l'intero processo di autenticazione.           7.  La tua applicazione può ora utilizzare questo token di accesso per accedere al server di risorse del provider ed eseguire operazioni per conto dell'utente sulle sue risorse. Di conseguenza, puoi autenticare l'utente tramite l'identity provider alle risorse del tuosistema.              ###### Suggerimento    Attraverso il processo OAuth, il server di autorizzazione può anche rilasciare un parametro di *stato* o un *token CSRF*, che la tua applicazione deve fornire quando comunica con i server del fornitore di identità. Lo scopo del parametro di stato o del token CSRF è quello di proteggere dagli attacchi CSRF (cross-site request forgery).    Con il CSRF, gli aggressori possono rubare una sessione autenticata per falsificare le richieste autenticate ai server delle risorse all'insaputa dell'utente.    [La Figura 8-8](#oauth2) mostra il flusso di autenticazione OAuth completo.  ![bgai 0808](assets/bgai_0808.png)  ###### Figura 8-8\\. Flusso di autenticazione OAuth    Ora che hai una panoramica di alto livello del flusso di autenticazione OAuth, implementiamolo all'interno di FastAPI con un provider di identità come GitHub per comprendere appieno i meccanismi sottostanti.    ## Autenticazione OAuth con GitHub    Il primo passo per impostare l'autenticazione OAuth è quello di creare un set di ID cliente e credenziali segrete all'interno di GitHub in modo che i loro sistemi possano identificare la tua applicazione.    Puoi generare un ID e un segreto del cliente da GitHub visitando le impostazioni dello sviluppatore sotto il tuo profilo GitHub e creando un'applicazione OAuth.^([5](ch08.html#id994))    Con il nuovo ID e segreto del client dell'applicazione, puoi ora reindirizzare gli utenti al server di autorizzazione di GitHub dalla tua applicazione seguendo l'[Esempio 8-13](#oauth_redirect).    ##### Esempio 8-13\\. Reindirizzare gli utenti al server di autorizzazione di GitHub per avviare il processo OAuth    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO9-1)      Reindirizza l'utente al server di autorizzazione di GitHub per accedere al suo account fornendo le credenziali dell'applicazione, un ambito richiesto e un valore di stato CSRF per prevenire gli attacchi CSRF.      Come puoi vedere nell'[Esempio 8-13](#oauth_redirect), l'ambito della richiesta è l'utente, il che significa che una volta che l'utente accede al suo account GitHub, gli verrà presentata una schermata di consenso per l'accesso della tua applicazione al suo profilo utente.    Ora che hai un endpoint di backend che reindirizza le richieste al server di autorizzazione di GitHub, puoi inserire un pulsante nella tua applicazione lato client per colpire questo endpoint e avviare il processo di OAuth con GitHub (vedi [Esempio 8-14](#oauth_client)).    ##### Esempio 8-14\\. Aggiunta di un pulsante di accesso a GitHub all'applicazione Streamlit lato client    ```", "```py    Ora hai implementato il flusso di reindirizzamento che avvia il processo di autenticazione OAuth con GitHub come fornitore di identità.    Quando gli utenti accedono al loro account GitHub, GitHub mostrerà loro una schermata di consenso simile a quella della [Figura 8-7](#oauth2_consent_screen).    Se l'utente accetta il consenso, GitHub lo reindirizzerà alla tua applicazione con un codice di concessione e uno stato. Dovresti controllare se lo stato corrisponde a quello generato in precedenza.    ###### Avvertenze    Se gli stati non corrispondono, significa che la richiesta è stata fatta da una terza persona e devi interrompere il processo.    Una volta ottenuto il codice di sovvenzione, puoi inviarlo all'autorizzazione di GitHub per scambiarlo con un token di accesso, come mostrato nell'[Esempio 8-15](#oauth_exchange).    ##### Esempio 8-15\\. Scambio del codice di concessione con un token di accesso e protezione dagli attacchi CSRF    ```", "```py    Ora puoi aggiungere un nuovo endpoint che accetta le richieste dal server di autorizzazione di GitHub. Questo endpoint di callback deve avere una protezione CSRF per evitare che terze parti impersonino il server di autorizzazione. Se la richiesta da GitHub è contraffatta, il parametro di stato fornito e quello memorizzato nella sessione della richiesta non corrisponderanno.    L['esempio 8-16](#oauth_callback) mostra l'implementazione dell'endpoint di callback.    ##### Esempio 8-16\\. Implementare un endpoint di callback per ottenere il token di accesso proteggendosi dagli attacchi CSRF    ```", "```py    Nell'[esempio 8-16](#oauth_callback), si utilizza la sessione di richiesta per la protezione CSRF, ma questo non funzionerà se non si aggiunge prima il sito `SessionMiddlware` di Starlette per mantenere una sessione utente sicura e mutabile solo sul lato server, come mostrato nell'[esempio 8-17](#oauth_session).    ##### Esempio 8-17\\. Aggiungere un middleware di sessione per gestire lo stato della sessione per proteggere dagli attacchi CSRF    ```", "```py    ###### Avvertenze    Evita di affidarti ai *cookie* HTTP per memorizzare e leggere il sito `state` tra le sessioni di richiesta, poiché i cookie possono essere letti e manipolati da terzi. Non fidarti mai dei dati provenienti dal client.    Scrivendo il codice univoco `state` nella sessione nell'[Esempio 8-13](#oauth_redirect) e confrontandolo con il valore `state` nei parametri della query della richiesta in arrivo, puoi confermare l'identità della richiesta.    In questo caso, il richiedente è il server di autorizzazione di GitHub che ti invia un grant `code`. Una volta ricevuta la concessione `code`, la scambi con il server di autorizzazione di GitHub per un token di accesso.    ###### Suggerimento    Il processo mostrato negli esempi di codice relativi a OAuth può essere implementato anche con il pacchetto open source `authlib` per un'implementazione più semplice, in quanto il pacchetto gestisce la maggior parte del lavoro per te.    Infine, puoi utilizzare il token di accesso ricevuto dal server di autorizzazione per recuperare le informazioni dell'utente, come il nome, l'email e l'immagine del profilo, per registrare la sua identità nella tua applicazione.    L['esempio 8-18](#oauth_user_info) mostra come implementare un endpoint che restituisce le informazioni sull'utente da GitHub se la richiesta fornisce un token di accesso come parte dell'intestazione di autorizzazione della richiesta.    ###### Avvertenze    Idealmente, dovresti evitare di condividere il token di accesso a GitHub con il browser dell'utente: se il token viene rubato, la tua applicazione è responsabile della compromissione dell'account GitHub dell'utente.    Invece, crea e condividi un tuo token di accesso di breve durata legato al token di accesso di GitHub per autenticare l'utente con la tua applicazione. Se il token dell'applicazione viene rubato, eviti di compromettere gli account utente al di fuori dell'ambito della tua applicazione.    ##### Esempio 8-18\\. Utilizzare il token di accesso per ottenere le informazioni sull'utente dai server delle risorse di GitHub    ```", "```py    Congratulazioni! Ora dovresti avere un sistema di autenticazione funzionante che sfrutta OAuth2 per autenticare gli utenti.    ## Tipi di flusso OAuth2    Il flusso OAuth2 che hai appena implementato è il *flusso del codice di autorizzazione* (ACF). Tuttavia, ci sono altri flussi che puoi scegliere a seconda del caso d'uso. La documentazione del fornitore di identità può presentarti soluzioni per vari flussi, che possono sembrare schiaccianti se non sei a conoscenza di questi casi d'uso.    ### Flusso del codice di autorizzazione    Il flusso di codice di autorizzazione è l'approccio comune per le applicazioni che sfruttano i server e le API di backend come FastAPI, utilizzando le concessioni di codice per emettere i token di accesso.    Una variante più sicura di ACF sfrutta la *chiave di prova per lo scambio* (PKCE, pronunciato \"pixie\"). Puoi usare il flusso ACF-PKCE quando non puoi proteggere il codice di autorizzazione dal furto, ad esempio sui dispositivi mobili.    Durante il flusso ACF-PKCE, quando invii la richiesta iniziale al fornitore di identità, aggiungi un segreto con hashhed chiamato `code_challenge`. Poi ripresenterai il segreto non hashhed `code_verifier` per scambiare il codice di autorizzazione con un token di accesso.    In sostanza, il PKCE protegge dagli attacchi di *intercettazione del codice di autorizzazione*, come mostrato nella [Figura 8-10,](#oauth_interception_attack)aggiungendo un livello di verifica durante il processo di scambio dei token.  ![bgai 0810](assets/bgai_0810.png)  ###### Figura 8-10\\. Attacco di intercettazione del codice di autorizzazione OAuth2 su un dispositivo mobile    ### Flusso implicito    Per le applicazioni a pagina singola (SPA) di in cui non c'è un backend separato, puoianche usare il *flusso implicito*, che salta il codice di autorizzazione per ottenere direttamente un token di accesso. Il flusso implicito è meno sicuro del flusso precedente ma migliora l'esperienza dell'utente.    ### Flusso di credenziali del cliente    Se stai costruendo un servizio backend per la comunicazione machine-to-machine e non è previsto il coinvolgimento di alcun browser, allora puoi utilizzare il *flusso delle credenziali del cliente*. Qui puoi scambiare l'ID e il segreto del tuo cliente con un token di accesso per accedere alle tue risorse sui server dell'identity provider (cioè non avrai accesso per conto di altri utenti).    ### Flusso di credenziali del proprietario della risorsa    Il*flusso di credenziali con password del proprietario della risorsa* è simile al flusso di credenziali del cliente, ma utilizza un nome utente e una password dell'utente per ottenere un token di accesso. Poiché le credenziali vengono scambiate direttamente con il server di autorizzazione, dovresti evitare il più possibile di utilizzare questo flusso.    ### Flusso di autorizzazione del dispositivo    Infine, c'è il *flusso di autorizzazione del dispositivo* che viene utilizzato soprattutto per i dispositivi con capacità di input limitate, come quando accedi al tuo account Apple TV sulla tua smart TV scansionando un codice QR e utilizzando un browser web dal tuo telefono.    La[Tabella 8-2](#oauth_flows_comparison) mette a confronto i vari flussi per aiutarti a selezionare l'opzione giusta per il tuo caso d'uso, in base ai tuoi requisiti e vincoli specifici.      Tabella 8-2\\. Confronto tra i flussi di autorizzazione di OAuth2   | Flusso | Descrizione | Considerazioni | Casi d'uso | | --- | --- | --- | --- | | Flusso del codice di autorizzazione (incluso PKCE) | Ottieni il codice di autorizzazione tramite un login utente e scambialo con un token di accesso. |   *   Il token di accesso del fornitore deve essere memorizzato in modo sicuro e non deve mai essere esposto al browser.           *   Usa il flusso ACF-PKCE se possibile per una maggiore sicurezza.             |   *   Applicazioni lato server e applicazioni web con un server backend in grado di gestire in modo sicuro il segreto del cliente e i token di accesso.           *   Se le applicazioni mobili utilizzano un token PKCE, le credenziali del cliente non possono essere archiviate in modo sicuro.             | | Flusso implicito | Ottieni un token di accesso senza codice di autorizzazione. |   *   Meno sicuro perché il token di accesso è esposto al browser.           *   Da utilizzare quando non è possibile utilizzare il flusso del codice di autorizzazione.             | Applicazioni a pagina singola (SPA) in cui l'esperienza dell'utente è prioritaria rispetto alla sicurezza, durante la prototipazione o quando il flusso di codice di autorizzazione non è possibile. | | Flusso di credenziali del cliente | Il cliente scambia direttamente le sue credenziali (ID e segreto del cliente) con un token di accesso. | Non prevede l'interazione con l'utente, è pensato per scenari in cui il cliente agisce per conto proprio. Garantisce l'archiviazione sicura delle credenziali del cliente. | Applicazioni da server a server. | | Flusso di credenziali del proprietario della risorsa | Scambia il nome utente e la password dell'utente direttamente con un token di accesso. |   *   Alto rischio di sicurezza perché le credenziali dell'utente vengono gestite direttamente.           *   Da utilizzare solo nei sistemi legacy dove gli altri flussi non sono supportati.             | Applicazioni legacy o ambienti altamente affidabili. | | Flusso di autorizzazione del dispositivo | Visita un URL su un altro dispositivo per inserire un codice per un token di accesso. | Richiede un secondo dispositivo con un browser web per l'autenticazione dell'utente. | Dispositivi con capacità di input limitate, come smart TV, console di gioco o dispositivi IoT. |    Ora dovresti sentirti più sicuro nel proteggere la tua applicazione con una serie di meccanismi commerciali di verifica dell'identità, compresi i vari flussi OAuth2 che sfruttano IDP esterni.    L'autenticazione è il primo passo per rendere sicuri i tuoi servizi, identificando chi sono gli utenti del tuo sistema.    Rimane una domanda: cosa dovrebbe accadere quando un utente accede ai tuoi servizi? Può recuperare dati, interagire con i modelli e mutare le risorse a suo piacimento o preferisci controllare le sue interazioni nei tuoi servizi?    Si tratta di problemi che verranno affrontati da un sistema di autorizzazione, di cui parleremo in seguito.    # Autorizzazione    Finora abbiamo trattato diversi meccanismi di autenticazione, tra cui quelli di base, quelli basati su token (JWT) e OAuth2, per proteggere le tue applicazioni.    Come già accennato, i sistemi di autenticazione identificano e verificano gli attori, mentre i sistemi di autorizzazione impongono i *permessi* in un'applicazione (cioè chi può fare cosa su quale risorsa).    In questa sezione imparerai a conoscere il sistema di autorizzazione che tiene conto di quanto segue:    *   L'*attore* (cioè l'utente o un servizio di terze parti che agisce per conto dell'utente)           *   L'*azione* intrapresa           *   L'impatto dell'azione sulle *risorse*              In sostanza, un sistema di autorizzazione può essere paragonato a una funzione che accetta tre input (*attore*, *azione*, *risorsa) e*restituisce una *decisione booleana* per *consentire* o *negare* una richiesta. Per implementare la funzione di autorizzazione, avrai bisogno di *dati di autorizzazione* come gli attributi dell'utente, le relazioni (come l'appartenenza a team/gruppi/org), la proprietà delle risorse, i ruoli e i permessi passati attraverso un insieme di *regole astratte* per determinare le decisioni booleane di autorizzazione/negazione.    Una volta presa la decisione, puoi *far rispettare* l'autorizzazione consentendo le azioni (come recuperare o modificare le risorse) o negando le richieste (come inviare risposte 403 Forbidden, reindirizzare gli utenti, nascondere le risorse, bloccare gli account e così via).    A livello superficiale, l'implementazione dell'autorizzazione può essere semplice. Utilizzando alcune dichiarazioni condizionali, puoi verificare se un utente ha i permessi per eseguire un'azione. Tuttavia, questo approccio ingenuo può diventare complesso da gestire man mano che aumenta il numero di punti in cui devi implementare i passaggi di autorizzazione. Questo problema si aggrava man mano che apporti modifiche alla logica dell'applicazione, rendendo il sistema complesso e aggiungendo controlli più fini. Potresti finire per duplicare la logica o rendere più difficili le modifiche future; inoltre, le regole di autorizzazione potrebbero essere profondamente intrecciate alla logica dell'applicazione, rendendo più difficile la separazione dal resto dell'applicazione.    In questi casi, i modelli di autorizzazione possono essere utili per aiutarti a gestire la complessità delle decisioni e dell'applicazione delle autorizzazioni nelle tue applicazioni.    ## Modelli di autorizzazione    Ci sono alcuni *modelli di autorizzazione* comuni che puoi imparare per rendere più semplice la strutturazione e l'implementazione di un sistema di autorizzazione:    Controllo dell'accesso basato sui ruoli (RBAC)      L'autorizzazione si basa sui ruoli assegnati agli utenti, dove ogni ruolo ha permessi specifici. Ad esempio, gli amministratori possono accedere a tutti i modelli GenAI disponibili, aggirando le regole di autorizzazione applicate agli utenti.      Controllo dell'accesso basato sulle relazioni (ReBAC)      L'autorizzazione è determinata dalle relazioni tra le entità, come le relazioni tra utenti (ad esempio, follower, amici, connessioni) o tra utenti e risorse (ad esempio, gruppi, team, organizzazioni). Ad esempio, questo potrebbe autorizzare un utente che è membro di un team ad accedere ai modelli premium acquistati da quel team.      Controllo dell'accesso basato sugli attributi (ABAC)      Le decisioni di autorizzazione vengono prese in base agli attributi degli utenti, delle risorse e dell'ambiente, consentendo un controllo degli accessi a grana fine. Ad esempio, una conversazione con un attributo *pubblico* è visibile a tutti, mentre un utente con un attributo *a pagamento* può accedere ai modelli GenAI premium.      RBAC è il modello di autorizzazione più semplice, ma non offre i controlli granulari e la flessibilità di altri modelli di autorizzazione. I controlli ABAC forniscono un controllo degli accessi più fine e possono sovrascrivere le regole di ReBAC e RBAC. Inoltre, ReBAC può anche sovrascrivere o estendere i controlli RBAC.    La[Tabella 8-4](#authorization_methods_comparison) mette a confronto i tre modelli di autorizzazione.      Tabella 8-4\\. Confronto tra i metodi di autorizzazione   | Tipo | Vantaggi | Limitazioni | Casi d'uso | | --- | --- | --- | --- | | Basato sui ruoli (RBAC) | Semplifica la gestione | Flessibilità limitata | Ambienti aziendali, controllo degli accessi, sistemi finanziari, sistemi sanitari | | Basato sulla relazione (ReBAC) | Controllo a grana fine | Necessita di dati relazionali provenienti da varie fonti con valutazioni complesse dei permessi. | Social network, piattaforme collaborative, applicazioni di condivisione dei contenuti, strumenti di gestione dei progetti | | Basato sugli attributi (ABAC) | Altamente flessibile | Ha bisogno di dati sugli attributi provenienti da varie fonti con complesse valutazioni dei permessi. | Ambienti dinamici, servizi Cloud, sistemi IoT, conformità normativa, esperienze utente personalizzate |    Questi tre modelli di autorizzazione hanno anche una relazione gerarchica, come dimostra la [Figura 8-11](#authorization_models).  ![bgai 0811](assets/bgai_0811.png)  ###### Figura 8-11\\. Modelli di autorizzazione    Vediamo ora nel dettaglio ogni modello di autorizzazione, iniziando dal modello RBAC.    ## Controllo degli accessi basato sui ruoli    L'uso dei *ruoli* è un modello ampiamente adottato per implementare l'autorizzazione nelle applicazioni grazie alla loro semplicità.    I ruoli sono semplici da capire: di solito corrispondono a chi è l'utente e a cosa vuole fare nell'applicazione. A volte i ruoli di autorizzazione possono corrispondere direttamente ai ruoli nella gerarchia della tua organizzazione.    Puoi raggruppare le autorizzazioni sotto un ruolo che può essere *assegnato* agli utenti per concedere loro tali autorizzazioni. Un'*autorizzazione* specifica l'azione che un utente può compiere sulle risorse, ad esempio se l'utente può interagire con il modello LLM a pagamento fornito dal tuo servizio.    Per migliorare l'esperienza amministrativa e degli utenti, puoi creare ruoli multipli con permessi preimpostati per ridurre la fatica di decidere quando si impostano i permessi degli utenti. Invece di dover impostare un gran numero di permessi, puoi assegnare alcuni ruoli predefiniti.    Un punto di partenza comune a molti servizi commerciali è rappresentato dai ruoli di utente e di amministratore. Sebbene un utente possa accedere alle funzionalità principali dell'applicazione, come interagire con i modelli GenAI e leggere e scrivere le risorse, non potrà visualizzare i dati di altri utenti o gestire i ruoli. D'altro canto, gli amministratori possono assegnare e rimuovere i ruoli, visualizzare e modificare ogni risorsa o disabilitare e abilitare gli account. Gli amministratori possono anche avere accesso alle prime funzionalità, come i modelli GenAI, a cui gli utenti normali non possono ancora accedere, come mostrato nella [Figura 8-12](#rbac_example).  ![bgai 0812](assets/bgai_0812.png)  ###### Figura 8-12\\. Esempio di RBAC in cui solo gli amministratori hanno accesso ai modelli GenAI basati sulle immagini    Puoi implementare un semplice modello di autorizzazione RBAC per controllare i servizi GenAI a cui gli utenti possono accedere, come mostrato nell'[Esempio 8-19](#rbac).    ##### Esempio 8-19\\. Implementazione di RBAC utilizzando le dipendenze di FastAPI    ```", "```py    [![1](assets/1.png)](#co_authentication_and_authorization_CO10-1)      Implementa la protezione della dipendenza di autorizzazione `is_admin` sopra la dipendenza `Auth​Ser⁠vice.get_current_user`. Contrassegna la funzione come `async` poiché la dipendenza figlia esegue un'operazione asincrona contro il database.      [![2](assets/2.png)](#co_authentication_and_authorization_CO10-3)      Utilizza la dipendenza authorization guard per negare l'accesso al servizio di generazione delle immagini agli utenti non autenticati dall'amministratore.      [![3](assets/3.png)](#co_authentication_and_authorization_CO10-2)      Gli utenti non autenticati possono comunque accedere ad altri controllori di risorse poiché il router è protetto da una dipendenza di autenticazione.      Utilizzando la stessa logica mostrata nell'[Esempio 8-19](#rbac), puoi costruire diversi modelli di prompt di sistema o utilizzare diverse varianti di modello adattate a ciascun ruolo.    ###### Avvertenze    Tieni presente che implementare l'autorizzazione a livello applicativo è più sicuro che delegarla al modello GenAI. Gli LLMs e altri modelli GenAI possono essere vulnerabili agli attacchi *prompt injection*, in cui un attaccante manipola l'input del modello per aggirare le istruzioni del sistema e produrre output non autorizzati e dannosi.    Le versioni future di LLMs e di altri modelli GenAI potrebbero mitigare i rischi di prompt injection applicando regole di autorizzazione personalizzate internamente, utilizzando estensioni come la *rete neurale di controllo (ControlNet)* nei modelli Stable Diffusion.    Per creare una logica di autorizzazione RBAC più complessa di quella mostrata nell'[Esempio 8-19](#rbac), puoi implementare delle *sottodipendenze* o una *dipendenza astratta*. Entrambi gli approcci sfrutteranno i potenti *grafi di dipendenza gerarchici* di FastAPI come guardie di autorizzazione per far rispettare i permessi nel tuo servizio GenAI.    Ad esempio, se in futuro aggiungerai nuovi ruoli che erediteranno un sottoinsieme di permessi di un altro ruolo (ad esempio, moderatori e amministratori), potrai seguire uno dei due approcci mostrati nella [Figura 8-13](#complex_rbac_approaches).  ![bgai 0813](assets/bgai_0813.png)  ###### Figura 8-13\\. Approcci per l'implementazione di modelli RBAC complessi    Puoi implementare una logica di autorizzazione RBAC complessa utilizzando delle dipendenze astratte, come mostrato nell'[Esempio 8-20](#complex_rbac_abstract).    ##### Esempio 8-20\\. Implementare un'autorizzazione RBAC complessa utilizzando le dipendenze astratte    ```", "```py    In sintesi, il RBAC semplifica la gestione dei permessi assegnando le autorizzazioni ai ruoli piuttosto che agli individui, rendendo più facile la gestione e la verifica. È scalabile ed efficiente per le organizzazioni con ruoli e responsabilità ben definiti.    Tuttavia, RBAC può portare all'esplosione dei ruoli quando sono necessari molti ruoli granulari, rendendone difficile la gestione. Inoltre, non ha la flessibilità necessaria per gestire relazioni gerarchiche complesse come team e gruppi e per impostare permessi dinamici basati su attributi come le preferenze dell'utente, il tempo e le impostazioni di privacy, il che limita la sua granularità rispetto a ReBAC o ABAC.    ## Controllo degli accessi basato sulle relazioni    Il*controllo degli accessi basato sulle relazioni* è un'estensione del RBAC che si concentra sulle relazioni tra risorse e utenti.    Con questa modalità, invece di impostare i ruoli a livello di utente per l'intera applicazione, dovrai impostare i ruoli e i permessi a livello di risorsa. Ciò significa che dovrai confermare le azioni che ogni ruolo può compiere su ogni tipo di risorsa. Ad esempio, invece di assegnare un ruolo \"moderatore\" a un utente che garantisce l'accesso a tutte le risorse (conversazioni, team, utenti, ecc.), dovrai assegnare permessi specifici al ruolo di moderatore per ogni risorsa. Un moderatore potrebbe avere i permessi di lettura e di cancellazione sulla risorsa conversazione ma solo di lettura sulla risorsa team.    Questo modello ti permette di creare politiche di autorizzazione basate su strutture gerarchiche e annidate all'interno dei tuoi dati e di visualizzarle come grafici in cui i nodi possono essere rappresentati come risorse/identità e i bordi come relazioni.    Dato che puoi creare regole di autorizzazione basate sulle relazioni, puoi risparmiare molto tempo nell'impostazione delle autorizzazioni a livello di istanza. Ad esempio, invece di condividere una per una tutte le conversazioni private di LLM nella tua applicazione, puoi raggrupparle in un team o in una cartella e condividere la cartella o aggiungere membri al team. In ReBAC, le istanze figlio possono ereditare le autorizzazioni del genitore, come mostrato nella [Figura 8-14](#rebac_example). Lo stesso vale per le istanze correlate, se necessario.  ![bgai 0814](assets/bgai_0814.png)  ###### Figura 8-14\\. Esempio di ReBAC in cui un utente può vedere le conversazioni e le discussioni private del team    L'esempio mostrato nella [Figura 8-14](#rebac_example) mostra sia l'organizzazione che le relazioni gerarchiche tra gli utenti (cioè i team e i membri) e le risorse (conversazioni e discussioni).    ###### Suggerimento    Se decidi di adottare il modello ReBAC, ti consiglio di tracciare visivamente le relazioni tra risorse e identità nella tua applicazione.    Questo lavoro comprende la mappatura delle *politiche* (cioè delle regole), delle *risorse* e delle *azioni* disponibili su di esse, dei *ruoli a livello di risorse* e delle *relazioni* tra le entità.    Un grosso problema che ReBAC risolve estendendo RBAC è l'esplosione dei ruoli all'interno del modello RBAC, combinando le relazioni con i ruoli. È ideale per gestire i permessi in strutture gerarchiche complesse e permette di effettuare query inverse, consentendo di definire in modo efficiente i permessi utilizzando team e gruppi. Tuttavia, ReBAC può essere complesso da implementare e mantenere, richiede molte risorse, è difficile da verificare e non ha la stessa precisione di ABAC per i permessi dinamici basati su attributi come l'orario o laposizione di.    ## Controllo dell'accesso basato sugli attributi    Il modello di autorizzazione*del controllo degli accessi basato sugli attributi* espande i ruoli RBAC di base impostando regole di controllo degli accessi basate su *condizioni applicate agli attributi* per implementare politiche più granulari. Ad esempio, ABAC può impedire agli utenti di caricare documenti sensibili nei tuoi servizi abilitati al RAG se il documento contiene *informazioni di identificazione personale (PII)* (ad esempio, `upload.has_pii=true`).    Un altro esempio di ABAC può essere visto nelle applicazioni SaaS come ChatGPT, dove solo gli utenti a pagamento hanno accesso ai modelli GenAI premium del servizio (vedi [Figura 8-15](#abac_example)).  ![bgai 0815](assets/bgai_0815.png)  ###### Figura 8-15\\. Esempio di ABAC in cui solo gli utenti a pagamento hanno accesso aimodelli GenAI premium    Poiché la libertà di definire criteri basati sugli attributi è infinita, il modello ABAC permette di definire politiche di autorizzazione molto precise. Tuttavia, ABAC può essere complicato per la gestione di strutture gerarchiche, rendendo difficile determinare quali utenti hanno accesso a una risorsa specifica. Ad esempio, se hai un criterio che concede l'accesso in base ad attributi come il ruolo dell'utente, il livello di sensibilità dei dati e l'appartenenza a un progetto, determinare tutti gli utenti che possono accedere a un set di dati specifico richiede la valutazione di questi attributi per ogni utente.    Sebbene sia meno complicato di ReBAC, ABAC può essere comunque impegnativo da implementare, in particolare in applicazioni grandi e complesse che supportano un gran numero di ruoli, utenti e attributi.    ## Modelli di autorizzazione ibridi    Se in passato hai lavorato con applicazioni di grandi dimensioni, noterai che esse combinano le caratteristiche dei modelli di autorizzazione RBAC, ReBAC e ABAC. Ad esempio, gli amministratori possono avere accesso a qualsiasi risorsa e alle funzioni di gestione/autenticazione degli utenti (RBAC), mentre gli utenti possono condividere le loro risorse private impostando l'attributo di visibilità su `public` (ABAC) e possono aggiungere membri al loro team per collaborare alle risorse private.    Un approccio ibrido che combina i modelli RBAC, ReBAC e ABAC può offrire i punti di forza di tutti i modelli di autorizzazione:    *   RBAC semplifica la gestione dei permessi assegnando ruoli agli utenti, rendendoli più facili da gestire e verificare.           *   ReBAC è perfetto per gestire le relazioni gerarchiche e le query inverse, rendendolo adatto a strutture gerarchiche complesse.           *   ABAC fornisce un controllo a grana fine basato sugli attributi dell'utente e della risorsa, consentendo di ottenere permessi dinamici e consapevoli del contesto.              [La Figura 8-16](#authorization_hybrid) mostra il modello di autorizzazione ibrido.  ![bgai 0816](assets/bgai_0816.png)  ###### Figura 8-16\\. Modello di autorizzazione ibrido basato su ruoli, relazioni e attributi    Per implementare l'autorizzazione ibrida che combina i modelli RBAC, ReBAC e ABAC, puoi seguire l'[Esempio 8-21](#rbac_rebac_abac).    ##### Esempio 8-21\\. Implementazione del modello di autorizzazione ibrido che combina RBAC, ReBAC e ABAC    ```", "```py    Quando definisci le regole e i permessi in base a ciascun modello di autorizzazione, puoi anche decidere di bypassare le regole se si verificano determinate condizioni, il che può portare a una logica complessa e creare un onere di manutenzione per il codice dell'applicazione.    Poiché l'implementazione di un modello ibrido può essere complessa, potresti considerare di sviluppare un servizio di autorizzazione separato per eliminare la necessità di apportare modifiche significative al codice con autorizzazioni volatili che cambiano frequentemente.    L'utilizzo di un sistema esterno per le decisioni sull'autorizzazione permette alla logica di autorizzazione della tua applicazione di rimanere coerente, come mostra la [Figura 8-17](#authz_separate).  ![bgai 0817](assets/bgai_0817.png)  ###### Figura 8-17\\. Separazione del servizio di autorizzazione dal servizio GenAI    L['esempio 8-22](#authorization_separate_example) mostra come sviluppare un sistema di autorizzazione separato.    ##### Esempio 8-22\\. Utilizzo di un servizio di autorizzazione con il servizio GenAI    ```", "```py    Come puoi vedere nell'[Esempio 8-22](#authorization_separate_example), l'utilizzo di un sistema esterno per autorizzare le azioni degli utenti sulle risorse aiuta te e il tuo team a modulare la logica di autorizzazione con requisiti più complessi e volatili.    Tuttavia, poiché lo sviluppo di un complesso servizio di autorizzazione esterno da zero può richiedere molto tempo, potresti prendere in considerazione l'utilizzo di provider di autorizzazione (come Oso, Permify, Okta/Auth0, ecc.) con la tua autenticazione.    # Riassunto    In questo capitolo hai imparato a conoscere i meccanismi di autenticazione e autorizzazione per proteggere i tuoi servizi GenAI.    All'inizio del capitolo ti sono stati presentati diversi metodi di autenticazione, tra cui l'autenticazione di base, quella basata su token, quella OAuth e quella basata su chiavi. Per fare esperienza pratica, hai implementato diversi sistemi di autenticazione da zero nel tuo servizio FastAPI, il che ti ha aiutato a comprendere i meccanismi sottostanti, tra cui la gestione delle password degli utenti, la creazione e l'utilizzo di token di accesso JWT e l'implementazione di flussi di autenticazione per la verifica degli utenti. Inoltre, hai imparato a integrare i tuoi servizi con identity provider come GitHub utilizzando lo standard OAuth2 per autenticare gli utenti e accedere a risorse esterne nella tua applicazione.    Mentre costruivi il sistema di autenticazione, hai imparato a conoscere i vettori di attacco come credential stuffing, password spraying, cross-site request forgery, open redirect e attacchi di phishing.    Inoltre, hai esplorato i sistemi di autorizzazione che determinano e applicano i livelli di accesso in base ai dati e alla logica di autorizzazione. Hai imparato come i sistemi di autorizzazione possono diventare complessi e come diversi modelli, tra cui RBAC, ReBAC e ABAC, possono aiutare a gestire i permessi nelle tue applicazioni.    Nel prossimo capitolo ti concentrerai sui test, compresa la scrittura di test unitari, di integrazione, end-to-end e di regressione. Verranno introdotti concetti come i confini dei test, la copertura, il mocking, il patching, la parametrizzazione, l'isolamento e l'idempotenza, che ti aiuteranno a scrivere test manutenibili ed efficaci man mano che le tue applicazioni crescono di complessità. In particolare, imparerai a testare i servizi GenAI che utilizzano modelli probabilistici e si interfacciano con sistemi asincroni.    ^([1](ch08.html#id970-marker)) Open Worldwide Application Security Project è una comunità online che produce risorse sulla sicurezza del software di sistema e delle applicazioni web.    ^([2](ch08.html#id971-marker)) L'autenticazione basata su chiavi non verrà discussa ulteriormente perché coinvolge principi crittografici complessi che esulano dallo scopo di questo capitolo.    ^([3](ch08.html#id972-marker)) In un *attacco di temporizzazione*, gli aggressori cercano di indovinare le password confrontando e analizzando i tempi di valutazione della password con la lunghezza della stessa. Pertanto, per prevenire gli attacchi temporali, gli algoritmi crittografici devono verificare le password in un arco di tempo costante.    ^([4](ch08.html#id982-marker)) Le lunghezze tipiche dei sali sono 16 byte (128 bit) per bilanciare prestazioni e sicurezza, oppure 32 byte (256 bit) per proteggere i sistemi sensibili. Puoi utilizzare librerie crittografiche come `passlib` per generare correttamente questi sali .    ^([5](ch08.html#id994-marker)) Per istruzioni aggiornate, visita [la documentazione di GitHub](https://oreil.ly/tWg6w).```"]