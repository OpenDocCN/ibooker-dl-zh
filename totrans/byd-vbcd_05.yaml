- en: 'Chapter 3\. The 70% Problem: AI-Assisted Workflows That Actually Work'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：70%问题：真正有效的人工智能辅助工作流程
- en: AI-based coding tools are astonishingly good at certain tasks.^([1](ch03.html#id486))
    They excel at producing boilerplate, writing routine functions, and getting projects
    *most of the way* to completion. In fact, many developers find that an AI assistant
    can implement an initial solution that covers roughly 70% of the requirements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于人工智能的编码工具在某些任务上令人惊讶地出色.^([1](ch03.html#id486)) 它们擅长生成样板代码、编写常规函数，并将项目推进到大部分完成。事实上，许多开发者发现，一个AI助手可以实施一个初始解决方案，覆盖大约70%的需求。
- en: 'Peter Yang perfectly captured what I’ve been observing in the field [in a post
    on X](https://oreil.ly/i9qwq):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 杨彼得在X上的一篇帖子中完美地捕捉了我一直在观察到的领域情况[链接](https://oreil.ly/i9qwq)：
- en: 'Honest reflections from coding with AI so far as a non-engineer:'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为非工程师，至今使用人工智能进行编码的真实反思：
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can get you 70% of the way there, but that last 30% is frustrating. It keeps
    taking one step forward and two steps backward with new bugs, issues, etc.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它可以带你完成70%的工作，但最后的30%却令人沮丧。它总是前进一小步，后退两步，出现新的错误、问题等。
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If I knew how the code worked I could probably fix it myself. But since I don’t,
    I question if I’m actually learning that much.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我知道代码是如何工作的，我可能可以自己修复它。但由于我不知道，我开始质疑自己是否真的学到了很多。
- en: Nonengineers using AI for coding find themselves hitting a frustrating wall.
    They can get 70% of the way there surprisingly quickly, but that final 30% becomes
    an exercise in diminishing returns.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用人工智能进行编码的非工程师发现自己遇到了令人沮丧的障碍。他们可以出奇地快地完成70%的工作，但最后的30%却变成了收益递减的练习。
- en: 'This “70% problem” reveals something crucial about the current state of AI-assisted
    development. The initial progress feels magical: you can describe what you want,
    and AI tools like v0 or Bolt will generate a working prototype that looks impressive.
    But then reality sets in.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“70%问题”揭示了关于当前人工智能辅助开发状态的关键信息。最初的进展感觉神奇：你可以描述你想要的内容，然后AI工具如v0或Bolt将生成一个看起来令人印象深刻的可工作原型。但随后现实就出现了。
- en: The 70% is often the straightforward, patterned part of the work—the kind of
    code that follows well-trod paths or common frameworks. As one [*Hacker News*
    commenter observed](https://oreil.ly/Ff3Ts), AI is superb at handling the “accidental
    complexity” of software (the repetitive, mechanical stuff), while the “essential
    complexity”⁠—understanding and managing the inherent complexity of a problem—remains
    on human shoulders. In Fred Brooks’s classic terms, AI tackles the incidental
    but not the intrinsic difficulties of development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 70%通常是工作中的简单、模式化的部分——那种遵循良好路径或常见框架的代码。正如一位[*Hacker News*评论者观察到的](https://oreil.ly/Ff3Ts)，AI在处理软件的“偶然复杂性”（重复的、机械的）方面非常出色，而“本质复杂性”——理解和管理问题的固有复杂性——则仍然落在人类的肩膀上。在Fred
    Brooks的经典术语中，AI解决的是发展的偶然困难，而不是内在困难。
- en: Where do these tools struggle? Experienced engineers consistently report a “last
    mile” gap. AI can generate a plausible solution, but the final 30%—covering edge
    cases, refining the architecture, and ensuring maintainability—“needs serious
    human expertise.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具在哪里遇到挑战？经验丰富的工程师一致报告存在一个“最后一英里”的差距。AI可以生成一个合理的解决方案，但最后的30%（涵盖边缘情况、细化架构和确保可维护性）“需要严重的人类专业知识”。
- en: For example, an AI might give you a function that technically works for the
    basic scenario, but it won’t automatically account for unusual inputs, race conditions,
    performance constraints, or future requirements unless explicitly told. AI can
    get you most of the way there, but that final crucial 30% (edge cases, keeping
    things maintainable, and solid architecture) needs serious human expertise.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个AI可能会给你一个在基本情况下技术上可行的函数，但它不会自动考虑异常输入、竞态条件、性能约束或未来的要求，除非明确告知。AI可以带你走大部分的路，但最后的至关重要的30%（边缘情况、保持可维护性和构建坚实的架构）需要严重的人类专业知识。
- en: Moreover, AI has a known tendency to generate convincing but incorrect output.
    It may introduce subtle bugs or “hallucinate” nonexistent functions and libraries.
    [Steve Yegge wryly likens](https://oreil.ly/hjv8f) today’s LLMs to “wildly productive
    junior developers”—incredibly fast and enthusiastic but “potentially whacked out
    on mind-altering drugs,” prone to concocting crazy or unworkable approaches.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，人工智能有一个已知的倾向，即生成令人信服但错误的输出。它可能会引入微妙的错误或“幻觉”不存在的函数和库。[Steve Yegge讽刺地比喻](https://oreil.ly/hjv8f)今天的LLMs为“极具生产力的初级开发者”——速度极快且热情洋溢，但“可能因为精神改变药物而变得疯狂”，容易想出疯狂或不切实际的方法。
- en: 'In [Yegge’s words](https://oreil.ly/yPMPO), an LLM can spew out code that looks
    polished at first glance, yet if a less-experienced developer naively says, “Looks
    good to me!” and runs with it, hilarity (or disaster) ensues in the following
    weeks. The AI doesn’t truly *understand* the problem; it stitches together patterns
    that *usually* make sense. Only a human can discern whether a seemingly fine solution
    hides long-term landmines. [Simon Willison echoed this](https://oreil.ly/sLzFY)
    after seeing an AI propose a bewitchingly clever design that *only a senior engineer
    with deep understanding of the problem* could recognize as flawed. The lesson:
    AI’s confidence far exceeds its reliability.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Yegge 的话中](https://oreil.ly/yPMPO)，一个大型语言模型（LLM）可以吐出看起来很整洁的代码，但如果一个经验不足的开发者天真地说，“看起来不错！”然后继续使用它，接下来的几周里就会发生荒谬（或灾难）。AI
    并没有真正 *理解* 问题；它缝合在一起的模式 *通常* 是有意义的。只有人类才能判断一个看似完美的解决方案是否隐藏着长期的地雷。[Simon Willison
    在看到 AI 提出一个迷人的巧妙设计后也表达了同样的观点](https://oreil.ly/sLzFY)，只有对问题有深刻理解的资深工程师才能识别出其缺陷。教训是：AI
    的自信远超其可靠性。
- en: Crucially, current AIs [do not create fundamentally new abstractions or strategies
    beyond their training data](https://oreil.ly/HkwVF). They won’t invent a novel
    algorithm or an innovative architecture for you—they remix what’s known. They
    also won’t take responsibility for decisions. As one engineer noted, “AIs don’t
    have ‘better ideas’ than what their training data contains. They don’t take responsibility
    for their work.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，当前的 AI [并不能在其训练数据之外创建根本性的新抽象或策略](https://oreil.ly/HkwVF)。它们不会为您发明新的算法或创新的架构——它们只是重新组合已知的内容。它们也不会对决策承担责任。正如一位工程师所说，“AI
    没有比其训练数据包含的‘更好的想法’。它们不对自己的工作承担责任。”
- en: 'All of this means that creative and analytical thinking—deciding *what* to
    build, *how* to structure it, and *why*—firmly remains a human domain. In summary,
    AI is a force multiplier for developers, handling the repetitive 70% and giving
    us a “turbo boost” in productivity. But it is *not* a silver bullet that can replace
    human judgment. The remaining 30% of software engineering—the hard parts—still
    requires skills that only trained, thoughtful developers can bring. Those are
    the durable skills to focus on, and [Chapter 4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)
    is dedicated to them. As one [discussion](https://oreil.ly/QXYsj) put it: “AI
    is a powerful tool, but it’s not a magic bullet.…Human judgment and good software
    engineering practices are still essential.”'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都意味着创造性和分析性思维——决定 *要构建什么*、*如何构建它* 和 *为什么构建它*——坚定地仍然是人类的领域。总之，AI 是开发者的力量倍增器，处理重复的
    70%，并给我们带来“涡轮增压”的生产力提升。但它 *不是* 一个可以取代人类判断的银弹。剩余的 30% 的软件工程——困难的方面——仍然需要只有受过训练、深思熟虑的开发者才能带来的技能。那些是我们要关注的持久技能，[第
    4 章](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)
    专门讨论了这些技能。正如一位 [讨论](https://oreil.ly/QXYsj) 所说：“AI 是一个强大的工具，但它不是魔法子弹。……人类的判断和良好的软件工程实践仍然是必不可少的。”
- en: How Developers Are Actually Using AI
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者实际上是如何使用 AI 的
- en: I’ve observed two distinct patterns in how teams are leveraging AI for development.
    Let’s call them the “bootstrappers” and the “iterators.” Both are helping engineers
    (and even nontechnical users) reduce the gap from idea to execution (or MVP).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我观察到团队在利用 AI 进行开发方面有两种截然不同的模式。让我们称它们为“bootstrappers”和“iterators”。两者都在帮助工程师（甚至非技术用户）缩小从想法到执行（或
    MVP）的差距。
- en: 'First, there are the *bootstrappers*, who are generally taking a new project
    from zero to MVP. Tools like Bolt, v0, and screenshot-to-code AI are revolutionizing
    how these teams bootstrap new projects. These teams typically:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有那些 *bootstrappers*，他们通常是将一个新项目从零开始到 MVP。像 Bolt、v0 和截图到代码 AI 这样的工具正在革命性地改变这些团队启动新项目的方式。这些团队通常：
- en: Start with a design or rough concept
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设计或粗略的概念开始
- en: Use AI to generate a complete initial codebase
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AI 生成完整的初始代码库
- en: Get a working prototype in hours or days instead of weeks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数小时或数天内而不是数周内获得一个可工作的原型
- en: Focus on rapid validation and iteration
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于快速验证和迭代
- en: The results can be impressive. I recently watched a solo developer use Bolt
    to turn a Figma design into a working web app in next to no time. It wasn’t production-ready,
    but it was good enough to get very initial user feedback.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以非常令人印象深刻。我最近看到一个独立开发者使用 Bolt 在几乎不花时间的情况下将 Figma 设计转换成一个可工作的网络应用。它还不是生产就绪的，但已经足够好，可以获取非常初步的用户反馈。
- en: 'The second camp, the *iterators*, uses tools like Cursor, Cline, Copilot, and
    Windsurf for their daily development workflow. This is less flashy but potentially
    more transformative. These developers are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个阵营，即“迭代者”，使用Cursor、Cline、Copilot和Windsurf等工具进行日常开发工作流程。这不太引人注目，但可能更具变革性。这些开发者是：
- en: Using AI for code completion and suggestions
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AI进行代码补全和建议
- en: Leveraging AI for complex refactoring tasks
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用AI进行复杂的重构任务
- en: Generating tests and documentation
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成测试和文档
- en: Using AI as a “pair programmer” for problem solving
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将AI用作问题解决的“搭档程序员”
- en: 'But here’s the catch: while both approaches can dramatically accelerate development,
    they come with hidden costs that aren’t immediately obvious.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有个问题：虽然这两种方法都可以显著加速开发，但它们带来了隐藏的成本，这些成本并不立即明显。
- en: 'When you watch a senior engineer work with AI tools like Cursor or Copilot,
    it looks like magic. They can scaffold entire features in minutes, complete with
    tests and documentation. But watch carefully, and you’ll notice something crucial:
    they’re not just accepting what the AI suggests. They’re constantly refactoring
    the generated code into smaller, focused modules. They’re adding comprehensive
    error handling and edge-case handling the AI missed, strengthening its type definitions
    and interfaces, and questioning its architectural decisions. In other words, they’re
    applying years of hard-won engineering wisdom to shape and constrain the AI’s
    output. The AI is accelerating their implementation, but their expertise is what
    keeps the code maintainable.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你观察资深工程师使用Cursor或Copilot等AI工具工作时，它看起来就像魔法。他们可以在几分钟内构建整个功能，包括测试和文档。但仔细观察，你会发现一个关键点：他们不仅仅接受AI的建议。他们不断地重构生成的代码，将其分解成更小、更专注的模块。他们添加了AI遗漏的全面错误处理和边缘情况处理，加强了类型定义和接口，并质疑其架构决策。换句话说，他们正在应用多年的宝贵工程智慧来塑造和约束AI的输出。AI正在加速他们的实施，但他们的专业知识是保持代码可维护性的关键。
- en: Common Failure Patterns
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见失败模式
- en: Junior engineers often miss these crucial steps.  They accept the AI’s output
    more readily, leading to what I call “house of cards code”—it looks complete but
    collapses under real-world pressure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 初级工程师常常错过这些关键步骤。他们更容易接受AI的输出，导致我所说的“纸牌屋代码”——它看起来完整，但在现实世界的压力下会崩溃。
- en: Two steps back
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退两步
- en: 'What typically happens next follows a predictable antipattern I call the “two
    steps back” pattern (shown in [Figure 3-1](#ch03_figure_1_1752630043194318)):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来通常遵循一个可预测的反模式，我称之为“退两步”模式（如图3-1所示）：
- en: You try to fix a small bug.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你试图修复一个小错误。
- en: The AI suggests a change that seems reasonable.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI建议一个看似合理的更改。
- en: This fix breaks something else.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个修复方法破坏了其他东西。
- en: You ask AI to fix the new issue.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你要求AI修复新的问题。
- en: This creates two more problems.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这又产生了两个新问题。
- en: Rinse and repeat.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复上述步骤。
- en: '![](assets/bevc_0301.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/bevc_0301.png)'
- en: Figure 3-1\. The “two steps back” antipattern.
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1. “退两步”反模式。
- en: 'This cycle is particularly painful for nonengineers because they lack the mental
    models to understand what’s actually going wrong. When an experienced developer
    encounters a bug, they can reason about potential causes and solutions based on
    years of pattern recognition. Without this background, you’re essentially playing
    whack-a-mole with code you don’t fully understand. This is the “knowledge paradox”
    I mentioned back in this book’s preface: senior engineers and developers use AI
    to accelerate what they already know how to do, while juniors try to use it to
    learn *what* to do.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非工程师来说，这个循环尤其痛苦，因为他们缺乏理解实际发生什么的心理模型。当经验丰富的开发者遇到错误时，他们可以根据多年的模式识别推理出潜在的原因和解决方案。没有这个背景，你基本上是在用你不完全理解的代码玩“打地鼠”。这就是我在本书前言中提到的“知识悖论”：资深工程师和开发者使用AI来加速他们已经知道如何做的事情，而初级工程师试图用它来学习“做什么”。
- en: This cycle is particularly painful for nonengineers using AI in a “bootstrapper”
    pattern, because they lack the mental models needed to address these issues building
    their MVP. However, even experienced “iterators” can fall into this whack-a-mole
    trap if they overly rely on AI suggestions without deep validation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用AI的“启动器”模式的非工程师来说，这个循环尤其痛苦，因为他们缺乏解决构建他们的MVP所需的心理模型。然而，即使是经验丰富的“迭代者”，如果过度依赖AI的建议而没有进行深入验证，也可能陷入这种“打地鼠”陷阱。
- en: 'There’s a deeper issue here: the very thing that makes AI coding tools accessible
    to nonengineers—their ability to handle complexity on your behalf—can actually
    impede learning. When code just “appears” without you understanding the underlying
    principles, you don’t develop debugging skills. You miss learning fundamental
    patterns. You can’t reason about architectural decisions, and so you struggle
    to maintain and evolve the code. This creates a dependency where you need to keep
    going back to the AI model to fix issues rather than developing the expertise
    to handle them yourself.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更深层次的问题：正是使AI编码工具对非工程师可访问的那一特性——它们代表了你代表处理复杂性的能力——实际上可能会阻碍学习。当代码只是“出现”而你并不理解其背后的原理时，你不会发展调试技能。你会错过学习基本模式。你无法对架构决策进行推理，因此你难以维护和演进代码。这创造了一种依赖，你需要不断回到AI模型去修复问题，而不是发展自己处理这些问题的专业知识。
- en: This dependency risk enters a new dimension with the emergence of autonomous
    AI coding agents—a topic I explore in depth in [Chapter 10](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844).
     Unlike current tools that suggest code snippets, these agents represent a fundamental
    shift in how software can be developed. As I write this, we’re witnessing the
    early deployment of systems that can independently plan, execute, and iterate
    on entire development tasks with minimal human oversight.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖风险随着自主AI编码代理的出现进入了一个新的维度——我在[第10章](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844)中深入探讨了这一主题。与当前建议代码片段的工具不同，这些代理代表了软件开发方式的一个根本转变。当我写下这些时，我们正在见证能够独立规划、执行和迭代整个开发任务（且需要最少人工监督）的系统的早期部署。
- en: This evolution from assistive to autonomous AI introduces profound questions
    about developer expertise and control. When an AI system can handle complete development
    workflows, from initial implementation through testing and deployment, the risk
    of skill atrophy becomes acute. Developers who rely heavily on these agents without
    maintaining their foundational knowledge may find themselves unable to effectively
    audit, guide, or intervene when the AI’s decisions diverge from intended outcomes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从辅助到自主AI的这种演变引发了关于开发者专业知识和控制的深刻问题。当一个AI系统可以处理完整的开发工作流程，从初始实现到测试和部署，技能退化的风险变得非常严重。那些过度依赖这些代理而没有维护其基础知识开发者的可能会发现自己无法有效地审计、指导或干预当AI的决定偏离预期结果时。
- en: The challenge compounds when we consider how these autonomous systems make cascading
    decisions throughout a project. Each individual choice might appear reasonable
    in isolation, yet the cumulative effect could steer development in unintended
    directions. Without the expertise to recognize and correct these trajectory shifts
    early, teams risk building increasingly complex systems on foundations they don’t
    fully understand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑到这些自主系统如何在项目中进行级联决策时，挑战就更加复杂了。每个单独的选择在孤立的情况下可能看起来是合理的，但累积效应可能会将开发引向未预想的方向。如果没有足够的专业知识来早期识别和纠正这些轨迹变化，团队可能会在并不完全理解的基础上构建越来越复杂的系统。
- en: As we’ll examine more thoroughly later, the advent of autonomous coding agents
    doesn’t diminish the importance of software engineering fundamentals—it amplifies
    it. The more powerful our AI tools become, the more critical it is that we maintain
    the expertise to remain architects of our systems rather than mere operators.
    Only through deep understanding of software principles can we ensure these remarkable
    tools enhance our capabilities rather than erode them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后会更彻底地考察的那样，自主编码代理的出现并没有减少软件工程基础的重要性——它放大了它。我们的AI工具变得越强大，我们就越需要保持专业知识，以确保我们成为系统的架构师而不是仅仅的操作员。只有通过深入理解软件原则，我们才能确保这些非凡的工具增强我们的能力而不是削弱它们。
- en: The demo-quality trap
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示质量陷阱
- en: 'It’s becoming a pattern: teams use AI to rapidly build impressive demos. The
    happy path works beautifully. Investors and social networks are wowed. But when
    real users start clicking around? That’s when things fall apart.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经成为一种模式：团队使用AI快速构建令人印象深刻的演示。顺利的道路运作得非常好。投资者和社交网络都为之惊叹。但当真实用户开始点击浏览时？那就是事情开始分崩离析的时候。
- en: 'I’ve seen this firsthand: error messages that make no sense to normal users,
    edge cases that crash the application, confusing UI states that never got cleaned
    up, accessibility completely overlooked, and performance issues on slower devices.
    These aren’t just low-priority bugs—they’re the difference between software people
    tolerate and software people love.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我亲眼所见：对普通用户来说毫无意义的错误信息，导致应用程序崩溃的边缘情况，从未清理的混乱用户界面状态，完全忽视的易用性，以及较慢设备上的性能问题。这些不仅仅是低优先级的错误——它们是人们忍受的软件和人们喜爱的软件之间的区别。
- en: Creating truly self-serve software—the kind where users never need to contact
    support—requires a different mindset, one that’s all about the lost art of polish.
    You need to be obsessing over error messages; testing on slow connections and
    with real, nontechnical users; making features discoverable; and handling every
    edge case gracefully. This kind of attention to detail (perhaps) can’t be AI-generated.
    It comes from empathy, experience, and caring deeply about craft.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建真正自助式软件——用户无需联系支持的那种——需要不同的思维方式，这种思维方式完全关乎失传的打磨艺术。你需要对错误信息如痴如醉；在慢速连接和真实、非技术用户上进行测试；使功能易于发现；并且优雅地处理每一个边缘情况。这种对细节的关注（或许）不能由人工智能生成。它来自同理心、经验和对工艺的深切关怀。
- en: 'What Actually Works: Practical Workflow Patterns'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际上是什么在起作用：实用的工作流程模式
- en: Before we dive into coding in [Part II](part02.html#part02) of this book, we
    need to talk about modern development practices and how AI-assisted coding fits
    within a team workflow. Software development is more than writing code, after
    all—it’s a whole workflow that includes planning, collaboration, testing, deployment,
    and maintenance. And vibe coding isn’t a standalone novelty—it can be woven into
    agile methodologies and DevOps practices, augmenting the team’s productivity while
    preserving quality and reliability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到本书[第二部分](part02.html#part02)的编码之前，我们需要讨论现代开发实践以及AI辅助编码如何在团队工作流程中发挥作用。毕竟，软件开发不仅仅是编写代码——它是一个包括规划、协作、测试、部署和维护的完整工作流程。而vibe
    coding不是一种独立的创新——它可以融入敏捷方法和DevOps实践，提高团队的生产力，同时保持质量和可靠性。
- en: In this section, we’ll explore how team members can collectively use vibe-coding
    tools without stepping on each other’s toes, how to balance AI suggestions with
    human insight, and how continuous integration/continuous delivery (CI/CD) pipelines
    can incorporate AI or adapt to AI-generated code. I’ll also touch on important
    considerations like version-control strategies.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨团队成员如何集体使用vibe-coding工具而不会互相干扰，如何平衡人工智能建议与人类洞察力，以及如何将持续集成/持续交付（CI/CD）管道整合人工智能或适应人工智能生成的代码。我还会涉及重要考虑因素，如版本控制策略。
- en: 'After observing dozens of teams, here are three patterns I’ve seen work consistently
    in both solo and team workflows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察了数十个团队之后，以下是我在独立和团队工作流程中看到的一直有效的工作模式：
- en: AI as first drafter
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能作为第一起草人
- en: The AI model generates the initial code and developers then refine, refactor,
    and test it
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能模型生成初始代码，然后开发者对其进行优化、重构和测试
- en: AI as pair programmer
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能作为配对程序员
- en: Developer and AI are in constant conversation, with tight feedback loops, frequent
    code review, and minimal context provided
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者和人工智能处于持续的对话中，有紧密的反馈循环，频繁的代码审查，以及提供最小化上下文
- en: AI as validator
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能作为验证者
- en: Developers still write the initial code and then use AI to validate, test, and
    improve it (see [Figure 3-2](#ch03_figure_2_1752630043194352))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者仍然编写初始代码，然后使用人工智能进行验证、测试和改进（见[图3-2](#ch03_figure_2_1752630043194352)）
- en: '![](assets/bevc_0302.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/bevc_0302.png)'
- en: 'Figure 3-2\. AI validation workflow: developers write initial code; AI systems
    analyze for bugs and security issues, then suggest improvements; and developers
    review and apply recommended changes.'
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2\. 人工智能验证工作流程：开发者编写初始代码；人工智能系统分析错误和安全性问题，然后提出改进建议；开发者审查并应用推荐更改。
- en: In this section, I’ll walk you through each pattern in turn, discussing workflows
    and tips for success.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将逐一介绍每种模式，讨论工作流程和成功技巧。
- en: AI as first drafter
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人工智能作为第一起草人
- en: It’s important to ensure everyone on the team is on the same page before you
    ask your AI model to draft any code. Communication is key so that developers don’t
    ask their AI assistants to do redundant tasks or generate conflicting implementations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在你要求人工智能模型起草任何代码之前，确保团队中的每个人都处于同一页面上是很重要的。沟通是关键，这样开发者就不会让他们的AI助手执行重复的任务或生成冲突的实现。
- en: In daily stand-ups (a staple of agile workflows), it’s worth discussing not
    just what you’re working on but also whether you plan to use AI for certain tasks.
    For example, two developers might be working on different features that both involve
    a utility function for date formatting. If both ask the AI to create a `formatDate`
    helper, you might end up with two similar functions. Coordinating up front (“I’ll
    generate a date utility we can both use”) can prevent duplication.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常站立会议（敏捷工作流程的基石）中，值得讨论的不仅仅是你在做什么，还包括你是否计划使用AI来完成某些任务。例如，两位开发者可能正在开发涉及日期格式化实用函数的不同功能。如果他们都要求AI创建一个`formatDate`辅助函数，你可能会得到两个类似的功能。提前协调（“我将生成一个我们可以共同使用的日期实用函数”）可以防止重复。
- en: Teams that successfully integrate AI tools often start by agreeing on coding
    standards and prompting practices. For example, the team might decide on a consistent
    style (linting rules, project conventions) and even feed those guidelines into
    their AI tools (some assistants allow providing style preferences or example code
    to steer outputs). As [noted in Codacy’s blog](https://oreil.ly/FeEN_), by familiarizing
    the AI with the team’s coding standards, you get generated code that is more uniform
    and easier for everyone to work with. On a practical level, this could mean having
    a section in your project README for “AI Usage Tips,” where you note things like
    “We use functional components only” or “Prefer using Fetch API over Axios,” which
    developers can keep in mind when prompting AI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 成功整合AI工具的团队通常从达成一致于编码标准和提示实践开始。例如，团队可能会决定采用一致的样式（linting规则、项目约定）并将这些指南输入到他们的AI工具中（一些助手允许提供样式偏好或示例代码以引导输出）。正如[Codacy的博客中提到的](https://oreil.ly/FeEN_)，通过使AI熟悉团队的编码标准，你可以生成更统一且易于大家协作的代码。在实践层面，这可能意味着在你的项目README中有一个“AI使用技巧”部分，其中记录诸如“我们只使用功能组件”或“优先使用Fetch
    API而不是Axios”等内容，开发者可以在提示AI时牢记。
- en: Another practice is to use your tools’ *collaboration features*, if available.
    Some AI-assisted IDEs allow users to share their AI sessions or at least the prompts
    they use. If Developer A got a great result with a prompt for a complex component,
    sharing that prompt with Developer B (perhaps via the issue tracker or a team
    chat) can save time and ensure consistency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种做法是，如果可用，使用你工具的*协作功能*。一些AI辅助IDE允许用户共享他们的AI会话或至少他们使用的提示。如果开发者A使用一个复杂的组件的提示得到了很好的结果，将这个提示与开发者B（可能通过问题跟踪器或团队聊天）分享可以节省时间并确保一致性。
- en: As for using version control, the fundamentals remain—with a twist. Using Git
    (or another version control system) is nonnegotiable in modern development, and
    that doesn’t change with vibe coding. In fact, version control becomes even more
    crucial when AI is generating code rapidly. Commits act as the safety net to catch
    AI missteps; if an AI-generated change breaks something, you can revert to a previous
    commit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用版本控制，其基本原理依然存在——但有所变化。在现代开发中，使用Git（或另一个版本控制系统）是不可或缺的，这在vibe编码中也不例外。实际上，当AI快速生成代码时，版本控制变得更加关键。提交（commits）充当安全网，以捕捉AI的错误；如果AI生成的更改破坏了某些内容，你可以回滚到之前的提交。
- en: One strategy is to commit more frequently when using AI assistance. Each time
    the AI produces a significant chunk of code (like generating a feature or doing
    some major refactoring) that you accept, consider making a commit with a clear
    message. Frequent commits ensure that if you need to bisect issues or undo a portion
    of AI-introduced code, the history is granular enough.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略是在使用AI辅助时更频繁地提交。每次AI生成一个重要的代码块（如生成一个功能或进行一些重大重构）且你接受时，考虑创建一个带有清晰信息的提交。频繁的提交确保如果你需要二分问题或撤销AI引入的部分代码，历史记录足够细粒度。
- en: Also, try to isolate different AI-introduced changes. If you let the AI make
    many changes across different areas and commit them all together, it’s harder
    to disentangle if something goes wrong. For example, if you use an agent to optimize
    performance and it also tweaks some UI texts, commit those separately. (Your two
    commit messages might be “Optimize list rendering performance [AI-assisted]” and
    “Update UI copy for workout completion message [AI-assisted]”). Descriptive commit
    messages are important; some teams even tag commits that had heavy AI involvement,
    just for traceability. It’s not about blame but about understanding the origin
    of code—a commit tagged with “[AI]” might signal to a reviewer that the code could
    use an extra thorough review for edge cases.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尝试隔离由AI引入的不同变化。如果你让AI在多个区域进行许多更改并将它们全部一起提交，如果出现问题，就难以区分。例如，如果你使用代理来优化性能，同时调整一些UI文本，请分别提交这些更改。（你的两个提交信息可能是“优化列表渲染性能
    [AI辅助]”和“更新锻炼完成消息的UI副本 [AI辅助]”）。描述性的提交信息很重要；一些团队甚至为涉及大量AI的提交添加标签，以便于追踪。这并不是关于责备，而是关于理解代码的来源——标记为“[AI]”的提交可能会向审阅者发出信号，表明代码可能需要额外的彻底审查以处理边缘情况。
- en: 'Essentially, the team should treat AI usage as a normal part of the development
    conversation: share experiences, successful techniques, and warnings about what
    not to do (like “Copilot suggests using an outdated library for X, so be careful
    with that”).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，团队应将AI的使用视为开发对话的正常部分：分享经验、成功的技巧和关于不要做什么的警告（例如，“Copilot建议为X使用过时的库，所以对此要小心”）。
- en: Review and refinement are crucial to this pattern. Developers should manually
    review and refactor the code for modularity, add comprehensive error handling,
    write thorough tests, and document key decisions as they refine the code. The
    next chapter goes into detail about these processes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 审查和精炼对这个模式至关重要。开发者应手动审查和重构代码以提高模块化，添加全面的错误处理，编写详尽的测试，并在精炼代码的过程中记录关键决策。下一章将详细介绍这些过程。
- en: AI as pair programmer
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为结对编程伙伴的AI
- en: 'Traditional pair programming involves two humans collaborating at one workstation.
    With the advent of AI, a hybrid approach has emerged: one human developer working
    alongside an AI assistant. This setup can be particularly effective, offering
    a blend of human intuition and machine efficiency.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的结对编程涉及两个人类在同一个工作站上协作。随着AI的出现，一种混合方法已经出现：一个人类开发者和一个AI助手一起工作。这种设置可以特别有效，它结合了人类的直觉和机器的效率。
- en: In a human-AI pairing, the developer interacts with the AI to generate code
    suggestions while also reviewing and refining the output. This dynamic allows
    the human to leverage the AI’s speed in handling repetitive tasks, such as writing
    boilerplate code or generating test cases, while maintaining oversight to ensure
    code quality and relevance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在人类-AI配对中，开发者与AI互动以生成代码建议，同时审查和精炼输出。这种动态使得人类可以利用AI处理重复性任务的速度，例如编写样板代码或生成测试用例，同时保持对代码质量和相关性的监督。
- en: For instance, when integrating a new library, a developer might prompt the AI
    to draft the initial integration code. The developer then reviews the AI’s suggestions,
    cross-referencing with official documentation to verify accuracy. This process
    not only accelerates development but also facilitates knowledge acquisition, as
    the developer engages deeply with both the AI’s output and the library’s intricacies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当集成新的库时，开发者可能会提示AI起草初始集成代码。然后，开发者会审查AI的建议，并与官方文档交叉引用以验证准确性。这个过程不仅加速了开发，还促进了知识获取，因为开发者会深入参与AI的输出和库的复杂性。
- en: 'Let’s compare this to traditional human-human pair programming:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与传统的面对面人类结对编程进行比较：
- en: '*Human-AI pairing* offers rapid code generation and can handle mundane tasks
    efficiently. It’s particularly beneficial for solo developers or when team resources
    are limited.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人类-AI配对*能够快速生成代码，并能高效地处理日常任务。它特别适合独立开发者或团队资源有限的情况。'
- en: '*Human-human pairing* excels in complex problem-solving scenarios, where nuanced
    understanding and collaborative brainstorming are essential. It fosters shared
    ownership and collective code comprehension.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人类-人类配对*在复杂问题解决场景中表现出色，在这些场景中，细微的理解和协作头脑风暴是必不可少的。它促进了共享所有权和集体代码理解。'
- en: Both approaches have their merits, and your choice between them can be guided
    by the project’s complexity, resource availability, and the specific goals of
    the development process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都有其优点，你之间的选择可以由项目的复杂性、资源可用性和开发过程的具体目标来指导。
- en: Best practices for AI pair programming
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人工智能配对编程的最佳实践
- en: 'To maximize the benefits of AI-assisted development, consider the following
    practices:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地发挥AI辅助开发的益处，请考虑以下实践：
- en: Initiate new AI sessions for distinct tasks
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同的任务启动新的AI会话
- en: This helps maintain context clarity and ensures the AI’s suggestions are relevant
    to the specific task at hand.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于保持上下文清晰，并确保AI的建议与当前任务相关。
- en: Keep prompts focused and concise
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 保持提示简洁明了
- en: Providing clear and specific instructions enhances the quality of the AI’s output.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提供清晰和具体的指令可以提高AI输出的质量。
- en: Review and commit changes frequently
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 经常审查和提交更改
- en: Regularly integrating and testing AI-generated code helps catch issues early
    and maintains project momentum.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 定期集成和测试人工智能生成的代码有助于早期发现问题并保持项目进度。
- en: Maintain tight feedback loops
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 保持紧密的反馈循环
- en: Continuously assess the AI’s contributions, providing corrections or refinements
    as needed to guide its learning and improve future suggestions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 持续评估AI的贡献，根据需要提供纠正或改进，以指导其学习并改进未来的建议。
- en: AI as validator
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人工智能作为验证者
- en: Beyond code generation, AI can serve as a valuable validator, assisting in code
    review and quality assurance. AI tools can analyze code for potential bugs, security
    vulnerabilities, and adherence to best practices. For example, platforms like
    DeepCode and Snyk’s AI-powered code checker can identify issues such as missing
    input sanitization or insecure configurations, providing actionable insights directly
    within the development environment. Platforms such as Qodo and TestGPT can automatically
    generate test cases, ensuring broader coverage and reducing manual effort. And
    many AI tools can assist in monitoring application performance, detecting anomalies
    that might indicate underlying issues.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能不仅能够生成代码，还可以作为一个有价值的验证者，协助代码审查和质量保证。人工智能工具可以分析代码以识别潜在的bug、安全漏洞以及是否符合最佳实践。例如，DeepCode和Snyk的AI驱动的代码检查平台可以识别诸如缺少输入清理或配置不安全等问题，并在开发环境中直接提供可操作的见解。Qodo和TestGPT等平台可以自动生成测试用例，确保更广泛的覆盖范围并减少人工工作量。许多AI工具还可以协助监控应用程序性能，检测可能表明潜在问题的异常。
- en: By integrating AI validators into the development workflow, teams can enhance
    code quality, reduce the likelihood of defects, and ensure compliance with security
    standards. This proactive approach to validation complements human oversight,
    leading to more robust and reliable software. These tools enhance the efficiency
    and effectiveness of the quality assurance (QA) process by handling repetitive
    and time-consuming tasks, allowing human testers to focus on more complex and
    nuanced aspects of QA.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将AI验证者集成到开发工作流程中，团队可以提高代码质量，降低缺陷发生的可能性，并确保符合安全标准。这种主动的验证方法补充了人工监督，导致更健壮和可靠的软件。这些工具通过处理重复和耗时的工作，提高了质量保证（QA）过程的效率和效果，使人工测试人员能够专注于QA的更复杂和细微的方面。
- en: Incorporating AI into the development process, whether as a pair programmer
    or validator, offers opportunities to enhance productivity and code quality. By
    thoughtfully integrating these tools, developers can harness the strengths of
    both human and artificial intelligence.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将AI融入开发过程，无论是作为配对程序员还是验证者，都提供了提高生产力和代码质量的机会。通过深思熟虑地整合这些工具，开发者可以利用人类和人工智能的优势。
- en: 'To maximize the benefits of both AI and human capabilities in QA, I recommend
    a few best practices:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地发挥AI和人类在QA中的能力，我推荐以下最佳实践：
- en: Use AI for initial assessments and preliminary scans to identify obvious issues.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AI进行初步评估和初步扫描以识别明显问题。
- en: Prioritize human review for critical areas, such as complex functionalities,
    user experience, and AI limitations.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于关键领域，如复杂功能、用户体验和人工智能限制，优先进行人工审查。
- en: Foster an environment of continuous collaboration, where AI tools and human
    testers work in tandem, with ongoing feedback loops to improve both AI performance
    and human decision making.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营造一个持续协作的环境，其中AI工具和人工测试人员协同工作，并持续进行反馈循环，以改善AI性能和人类决策。
- en: The Golden Rules of Vibe Coding
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vibe编码的黄金法则
- en: While vibe coding offers unprecedented speed and creative freedom in software
    development, its very flexibility demands a structured approach to ensure consistent
    quality and team cohesion. The rapid, intuitive nature of AI-assisted development
    can quickly lead to chaos without clear guidelines that balance creative exploration
    with engineering discipline.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然动态编码（vibe coding）在软件开发中提供了前所未有的速度和创造性自由，但其极大的灵活性要求一种结构化的方法来确保一致的质量和团队凝聚力。AI辅助开发的快速、直观特性如果没有明确的指南来平衡创造性探索与工程纪律，很容易导致混乱。
- en: These golden rules emerged from collective experience across teams who have
    successfully integrated vibe coding into their workflows. They represent hard-won
    insights about where AI excels, where it stumbles, and how human judgment remains
    essential throughout the process. Rather than constraining creativity, these principles
    create a framework within which teams can confidently experiment while maintaining
    the standards necessary for production-ready software.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些黄金法则是从成功将动态编码（vibe coding）整合到工作流程中的团队的集体经验中产生的。它们代表了关于AI在哪些方面表现优异、在哪些方面存在不足，以及人类判断在整个过程中始终至关重要的宝贵见解。这些原则并非限制创造力，而是在团队可以自信地实验的同时，维持生产级软件所需的标准的框架。
- en: 'The rules address three critical dimensions of vibe coding: the interaction
    between human and AI, the integration of AI-generated code into existing systems,
    and the cultivation of team practices that support sustainable AI-assisted development.
    By following these guidelines, teams can harness the transformative power of vibe
    coding while avoiding common pitfalls that lead to technical debt, security vulnerabilities,
    or unmaintainable codebases:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则涵盖了动态编码（vibe coding）的三个关键维度：人与AI的交互、AI生成代码与现有系统的集成，以及培养支持可持续AI辅助开发的团队实践。通过遵循这些指南，团队可以利用动态编码的变革力量，同时避免导致技术债务、安全漏洞或难以维护的代码库的常见陷阱：
- en: Be specific and clear about what you want
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 明确并清晰地表达你的需求
- en: Clearly articulate your requirements, tasks, and outcomes when interacting with
    AI. Precise prompts yield precise results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在与AI交互时，明确表达你的需求、任务和结果。精确的提示会产生精确的结果。
- en: Always validate AI output against your intent
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总是验证AI输出是否符合你的意图
- en: AI-generated code must always be checked against your original goal. Verify
    functionality, logic, and relevance before accepting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: AI生成的代码必须始终与你的原始目标进行核对。在接受之前，验证功能、逻辑和相关性。
- en: Treat AI as a junior developer (with supervision)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将AI视为初级开发者（需监督）
- en: Consider AI outputs as drafts that require your careful oversight. Provide feedback,
    refine, and ensure quality and correctness.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将AI输出视为需要你仔细监督的草稿。提供反馈，进行细化，并确保质量和正确性。
- en: Use AI to expand your capabilities, not replace your thinking
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 利用AI扩展你的能力，而不是取代你的思考
- en: Leverage AI to automate routine or complex tasks, but always remain actively
    engaged in problem solving and decision making.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 利用AI自动化常规或复杂任务，但始终积极参与问题解决和决策制定。
- en: Coordinate up front among the team before generating code
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成代码之前，在团队中进行前期协调
- en: Align with your team on AI usage standards, code expectations, and practices
    before starting AI-driven development.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始AI驱动开发之前，与团队就AI使用标准、代码期望和实践达成一致。
- en: Treat AI usage as a normal part of the development conversation
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将AI使用视为开发对话的正常部分
- en: Regularly discuss AI experiences, techniques, successes, and pitfalls with your
    team. Normalize AI as another tool for collective improvement.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 定期与团队讨论AI经验、技术、成功和陷阱。将AI视为集体改进的另一个工具。
- en: Isolate AI changes in Git by doing separate commits
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单独提交来在Git中隔离AI更改
- en: Clearly identify and separate AI-generated changes within version control to
    simplify reviews, rollbacks, and tracking.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在与AI交互时，明确识别并区分AI生成的更改，以简化审查、回滚和跟踪。
- en: Ensure that all code, whether human or AI-written, undergoes code review
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有代码，无论是人工编写还是AI编写，都经过代码审查
- en: Maintain consistent standards by subjecting all contributions to the same rigorous
    review processes, enhancing code quality and team understanding.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有贡献提交给相同的严格审查流程来维护一致的标准，从而提高代码质量和团队理解。
- en: Don’t merge code you don’t understand
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要合并你不理解的代码
- en: Never integrate AI-generated code unless you thoroughly comprehend its functionality
    and implications. Understanding is critical to maintainability and security.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你彻底理解其功能及其影响，否则绝不要集成AI生成的代码。理解对于可维护性和安全性至关重要。
- en: Prioritize documentation, comments, and ADRs
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 优先考虑文档、注释和ADR（架构决策记录）
- en: Clearly document the rationale, functionality, and context for AI-generated
    code. Good documentation ensures long-term clarity and reduces future technical
    debt.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 明确记录AI生成代码的理由、功能性和上下文。良好的文档确保了长期清晰度并减少了未来的技术债务。
- en: Share and reuse effective prompts
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分享和重用有效的提示词
- en: Document prompts that lead to high-quality AI outputs. Maintain a repository
    of proven prompts to streamline future interactions and enhance consistency.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记录导致高质量AI输出的提示词。维护一个经过验证的提示词库，以简化未来的交互并提高一致性。
- en: Regularly reflect and iterate
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 定期反思和迭代
- en: Periodically review and refine your AI development workflow. Use insights from
    past experiences to continuously enhance your team’s approach.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定期审查和改进您的AI开发工作流程。利用过去的经验不断改进团队的方法。
- en: By adhering to these golden rules, your team can harness AI effectively, enhancing
    productivity while maintaining clarity, quality, and control.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些黄金法则，您的团队能够有效地利用AI，提高生产力，同时保持清晰度、质量和控制。
- en: Summary and Next Steps
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和下一步行动
- en: 'The 70% problem defines the current state of AI-assisted development: these
    tools excel at generating boilerplate and routine functions but struggle with
    the final 30% that includes edge cases, architectural decisions, and production
    readiness. We’ve identified two main usage patterns—bootstrappers who rapidly
    build MVPs, and iterators who integrate AI into daily workflows—along with common
    failure patterns like the “two steps back” antipattern and the “demo-quality trap”
    where impressive prototypes fail under real-world pressure.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 70%问题定义了AI辅助开发的当前状态：这些工具在生成样板代码和常规函数方面表现出色，但在包括边缘情况、架构决策和生产准备在内的最后30%方面存在困难。我们已经确定了两种主要的使用模式——快速构建MVP的启动者，以及将AI整合到日常工作流程中的迭代者——以及常见的失败模式，如“退两步”反模式和“演示质量陷阱”，在这些模式中，令人印象深刻的原型在现实世界的压力下失败。
- en: 'Three proven workflow patterns have emerged: AI as first drafter (generate
    then refine), AI as pair programmer (continuous collaboration), and AI as validator
    (human-written code with AI analysis). The golden rules of vibe coding provide
    essential guardrails, emphasizing clear communication, thorough validation, team
    coordination, and the nonnegotiable requirement to understand all code before
    merging it.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 已经出现了三种经过验证的工作流程模式：AI作为第一稿作者（生成后改进）、AI作为配对程序员（持续协作）和AI作为验证者（人类编写的代码与AI分析）。Vibe编码的黄金法则提供了基本的护栏，强调清晰的沟通、彻底的验证、团队协调以及在合并之前理解所有代码的不可协商要求。
- en: 'Individual developers should choose one workflow pattern to experiment with
    systematically while implementing the golden rules in daily practice. Focus on
    developing the durable skills covered in [Chapter 4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362):
    system design, debugging, and architecture—rather than competing with AI on code
    generation.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 个人开发者应在日常实践中实施黄金法则的同时，选择一个工作流程模式进行系统性地实验。专注于发展[第4章](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)中涵盖的持久技能：系统设计、调试和架构——而不是与AI在代码生成上竞争。
- en: Teams need to establish standards for AI usage, create shared repositories of
    effective prompts, and integrate AI considerations into existing agile practices.
    Regular knowledge sharing about successes and pitfalls will help teams avoid common
    traps while maximizing AI’s benefits.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 团队需要为AI的使用制定标准，创建有效的提示词共享库，并将AI的考虑因素整合到现有的敏捷实践中。定期分享关于成功和陷阱的知识，将帮助团队避免常见陷阱，同时最大化AI的益处。
- en: As autonomous AI coding agents emerge, the human role will shift toward architectural
    oversight and strategic decision making. The next chapter explores how to maximize
    this irreplaceable human contribution, helping engineers at every level thrive
    as partners to increasingly capable AI systems rather than competitors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随着自主AI编码代理的出现，人类角色将转向架构监督和战略决策。下一章将探讨如何最大化这种无可替代的人类贡献，帮助各个级别的工程师作为越来越强大的AI系统的合作伙伴而不是竞争对手蓬勃发展。
- en: '^([1](ch03.html#id486-marker)) This chapter is based on an essay originally
    published on my Substack newsletter. See Addy Osmani, [“The 70% Problem: Hard
    Truths About AI-Assisted Coding”](https://oreil.ly/aRKIJ), *Elevate with Addy
    Osmani*, December 4, 2024.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#id486-marker))本章基于最初发表在我Substack通讯上的文章。参见Addy Osmani，《70%问题：关于AI辅助编码的艰难真相》[*Elevate
    with Addy Osmani*]，2024年12月4日。
