- en: 3 Getting started with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 开始使用Docker
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating containers for our project components using Docker and Docker Compose
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker和Docker Compose为我们的项目组件创建容器
- en: Optimizing Docker containers and images for enhanced security and maintenance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化Docker容器和镜像以提高安全性和维护性
- en: Implementing general Docker maintenance to ensure our containers and images
    do not eat up disk space
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施通用的Docker维护以确保我们的容器和镜像不会消耗磁盘空间
- en: Using health checks to ensure the system is up and running
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用健康检查来确保系统处于运行状态
- en: In the last chapter (or sprint, if we are thinking in Agile terms), we created
    a functional (albeit basic) ACH parser. We also experimented with generative AI
    tools to help us work faster and more efficiently. We have made some progress
    exploring tools and getting our bearing with ACH processing. Enjoy that feeling
    because there will surely be days when we log off the computer feeling completely
    drained.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（或者如果我们从敏捷的角度思考，是冲刺），我们创建了一个功能性的（尽管是基本的）ACH解析器。我们还尝试了生成式AI工具来帮助我们更快、更有效地工作。我们在探索工具和掌握ACH处理方面取得了一些进展。享受这种感觉吧，因为肯定会有一些日子，当我们离开电脑时会感到完全筋疲力尽。
- en: At this point, we have been given project requirements and a general framework
    of what a final project should contain. Of course, there are different approaches
    that we might take when working on a project, each having its pros and cons. While
    we may end up favoring one approach over others, there are always factors to consider
    when tackling a project, such as
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经得到了项目需求和一个关于最终项目应包含内容的总体框架。当然，在处理项目时，我们可能会采取不同的方法，每种方法都有其优缺点。虽然我们可能最终会倾向于一种方法而不是其他方法，但在处理项目时，我们总是需要考虑一些因素，例如
- en: How does the size and complexity of the project compare to our team’s experience
    and knowledge?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的大小和复杂性与我们团队的经验和知识相比如何？
- en: Have the project requirements been well defined, or is the business/customer
    still feeling the project out? How do the requirements compare to the time allotted
    for the project?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目需求是否已经明确定义，或者业务/客户还在探索项目？需求与项目分配的时间如何比较？
- en: What is our risk tolerance for items such as bugs, delays, new technologies,
    and similar?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于像错误、延误、新技术等类似项目，我们的风险容忍度是多少？
- en: Do we have existing infrastructure for the project, such as testing environments
    and automated builds? If not, will we need to factor in building that infrastructure,
    or will that come later?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否有现有的项目基础设施，例如测试环境和自动化构建？如果没有，我们是否需要考虑构建该基础设施，或者它会在以后进行？
- en: While the previous points may seem more pertinent when having more of a leadership
    role (technical lead, architect, etc.), it is beneficial to have everyone thinking
    about them because different perspectives are always useful. We just need to be
    careful that our feedback comes across as constructive and not as an attack on
    our co-workers (and we should be careful about when it is obvious any feedback
    will be ignored). Let us get back to our project at hand.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在担任更多领导角色（技术负责人、架构师等）时，前面的观点可能显得更为重要，但让每个人都考虑这些观点是有益的，因为不同的观点总是有用的。我们只需要确保我们的反馈是建设性的，而不是攻击我们的同事（我们应当注意，在明显任何反馈都会被忽视的情况下要小心）。让我们回到手头的项目上来。
- en: 3.1 Where to begin
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 从哪里开始
- en: First, you may not have any choice in what you are able to work on. The business
    needs may dictate that you work on these pieces in this order. However, assuming
    you have a choice on where to start, what would you pick? You could start with
    a piece that you are comfortable with—perhaps you are a strong Python programmer,
    so you want to finish working on the ACH parser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能没有选择权来决定你能够做什么工作。业务需求可能规定你必须按照这个顺序来工作这些部分。然而，假设你可以在哪里开始有选择权，你会选择什么？你可以从一个你感到舒适的部分开始——也许你是一个强大的Python程序员，所以你想完成对ACH解析器的工作。
- en: Or, maybe you should pick the thing you know the least. Maybe you have never
    worked with Next.js before, and you want to ensure you have enough time to devote
    to that part because you feel the other pieces won’t take much time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许你应该选择你最不熟悉的事情。也许你以前从未使用过Next.js，你想要确保你有足够的时间投入到这部分，因为你觉得其他部分不会花费太多时间。
- en: We like to get started with the whole project! Well, not the whole project,
    but we like to see if we can get all the pieces talking to each other in some
    form. Even if it is the equivalent of a bunch of “Hello, World!” programs and
    components, at least we have the pieces together, and then we can pick them up,
    start building them, and let them evolve. It is really up to you—you could just
    as easily jump around to other chapters and get the various components up and
    running. This chapter focuses on getting a Docker setup and then putting our basic
    project components in place. Subsequent chapters will build on these components,
    but for now, we want to create an environment that looks similar to the one in
    figure 3.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢从整个项目开始！好吧，不是整个项目，但我们想看看我们是否能让所有部件以某种形式相互交流。即使它只是一堆“Hello, World！”程序和组件，至少我们把部件组合在一起了，然后我们可以捡起来，开始构建它们，并让它们发展。这完全取决于你——你同样可以跳到其他章节，让各种组件启动运行。这一章的重点是设置Docker环境，然后放置我们的基本项目组件。后续章节将在此基础上构建，但到目前为止，我们想要创建一个类似于图3.1所示的环境。
- en: As you can see, this environment will provide us with a UI container running
    Node and Next.js, an API container powered by FastAPI, and a database container
    running PostgreSQL. Running these inside Docker also allows the introduction of
    other
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个环境将为我们提供一个运行Node和Next.js的UI容器，一个由FastAPI提供动力的API容器，以及一个运行PostgreSQL的数据库容器。在Docker内部运行这些容器还允许引入其他
- en: '![A diagram of a computer program  Description automatically generated](../Images/CH03_F01_Kardell.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序图  自动生成的描述](../Images/CH03_F01_Kardell.png)'
- en: Figure 3.1  An overview of our ACH system
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1  我们ACH系统的概述
- en: components that we will explore in other chapters. While this project takes
    a more service-oriented approach to architecture, this general approach of using
    Docker to break our software down paves the way for other architecture patterns.
    The goal is not to make you an expert in Docker (check out *Docker in Action*
    [2019, Manning] by Jeff Nickoloff and Stephen Kuenzli if you want to become an
    expert) but rather to show you how to use it to explore different technologies
    and software without having to install and configure it on a host machine. It
    really helps you stay more organized.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在其他章节中探讨的组件。虽然这个项目采用了一种更面向服务的架构方法，但使用Docker将我们的软件分解的一般方法为其他架构模式铺平了道路。目标不是让你成为Docker专家（如果你想成为专家，可以查看Jeff
    Nickoloff和Stephen Kuenzli所著的《Docker in Action》（2019，Manning）），而是向你展示如何使用它来探索不同的技术和软件，而无需在主机机器上安装和配置它。这真的有助于你保持更整洁的秩序。
- en: Is the monolith dead?
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单体架构是否已经死亡？
- en: Since we are using containers, and you may have heard about Microservices and
    how they are the latest and greatest, you might be tempted to run back to your
    company looking for any monolithic software and start insisting that they are
    doing it wrong. We would advise against that. Just because something is new does
    not necessarily mean it is better. Monolithic architecture can have its drawbacks,
    but there is no silver bullet when it comes to technology. Change for the sake
    of change is not only unnecessary—it can be detrimental to the software.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用容器，你可能已经听说过微服务以及它们是如何成为最新和最伟大的，你可能会想回到公司寻找任何单体软件，并开始坚持认为他们做错了。我们建议你不要这样做。仅仅因为某件事物是新的，并不意味着它就是更好的。单体架构可能有其缺点，但技术领域没有万能的解决方案。为了改变而改变不仅是不必要的——它可能对软件有害。
- en: Therefore, we suggest that if it is not broken, do not fix it. If there is monolithic
    software running at your company, it may continue to run for long after you have
    left the company. Only after identifying problems with the architecture should
    you look for alternatives.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议，如果它没有坏，就不要去修复它。如果你的公司运行着单体软件，它可能在你离开公司很久之后仍然在运行。只有在你确定了架构的问题之后，你才应该寻找替代方案。
- en: Monolithic architecture can also be very useful in developing proof of concepts,
    as you can bundle and deploy everything in one easy package. We believe everything
    has its time and place, so while we encourage forward thinking and engineering,
    remember that part of Agile is looking to deliver the right product at the right
    time. It just may not be the right time to explore moving to containers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构在开发概念验证时也非常有用，因为你可以将所有内容捆绑并部署在一个简单的包中。我们相信每件事物都有其时间和地点，因此虽然我们鼓励前瞻性思维和工程实践，但请记住，敏捷的一部分是寻找在正确的时间交付正确的产品。可能现在并不是探索迁移到容器的好时机。
- en: 3.2 Creating a docker-compose.yml file
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 创建docker-compose.yml文件
- en: If you have never worked with Docker before, you are in for a real treat. Docker
    allows us to create and distribute various containers. A container is sort of
    a mini-VM that you build in a declarative fashion and can be pulled in by others.
    If you are a Java programmer, think of your pom.xml and Maven, where you can basically
    describe your project and provide that file to someone else, so they can use it
    to have Maven pull the necessary files. Containers are similar, except they work
    on a larger scale. In figure 3.1, we showed a solution that has multiple containers
    running Nginx, FastAPI, and PostgreSQL. When working with a multicontainer application,
    we want to be able to manage everything from a centralized location, and that
    is where Docker Compose comes into play. We can declare a docker-compose.yml file
    and configure all the applications, containers, and services in one location.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过 Docker，那么你将真正享受到一份大礼。Docker 允许我们创建和分发各种容器。容器可以看作是一种微型虚拟机，你可以以声明的方式构建它，并且可以被他人拉取。如果你是
    Java 程序员，可以想想你的 pom.xml 和 Maven，在那里你可以基本上描述你的项目并将该文件提供给他人，以便他们可以使用 Maven 拉取必要的文件。容器类似，但它们工作在更大的规模上。在图
    3.1 中，我们展示了具有多个容器运行 Nginx、FastAPI 和 PostgreSQL 的解决方案。当与多容器应用程序一起工作时，我们希望能够从集中位置管理一切，这就是
    Docker Compose 发挥作用的地方。我们可以声明一个 docker-compose.yml 文件，并在一个位置配置所有应用程序、容器和服务。
- en: 'If you are new to Docker, you might try to use Copilot, but our attempt did
    not yield any meaningful results. We tried to use the following command with Copilot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始使用 Docker，你可能想尝试使用 Copilot，但我们的尝试并没有产生任何有意义的成果。我们尝试使用以下命令与 Copilot 一起使用：
- en: '![](../Images/Prompt-Icon.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/Prompt-Icon.png)'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The results of that prompt are shown in the following listing. Unfortunately,
    it did not produce any actual executable code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那个提示的结果显示在下述列表中。不幸的是，它并没有生成任何实际的可执行代码。
- en: Listing 3.1  Failed attempt at a Docker setup
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1  Docker 设置尝试失败
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We had much better results asking ChatGPT directly, as shown in the next listing,
    as it provided an actual compose file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 直接询问 ChatGPT 我们得到了更好的结果，如下一列表所示，因为它提供了一个实际的 compose 文件。
- en: Listing 3.2  docker-compose.yml generated by ChatGPT
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2  ChatGPT 生成的 docker-compose.yml
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 The version tag is obsolete, but even 3.7 was outdated when ChatGPT provided
    this answer; this is an example of the need to verify responses.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 版本标签已经过时，但即使 3.7 在 ChatGPT 提供这个答案时也已经过时；这是需要验证响应的另一个例子。'
- en: '#2 ChatGPT gives us a nonstandard name of Dockerfile.fastapi; instead, we should
    use Dockerfile with no extension or fastapi.Dockerfile (see [https://mng](https://mng.bz/xKoB)
    [.bz/xKoB](https://mng.bz/xKoB) ); this is another example of the need to verify
    responses.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 ChatGPT 给我们提供了一个非标准的名称 Dockerfile.fastapi；相反，我们应该使用没有扩展名的 Dockerfile 或 fastapi.Dockerfile（见
    [https://mng](https://mng.bz/xKoB) [.bz/xKoB](https://mng.bz/xKoB)）；这是需要验证响应的另一个例子。'
- en: '#3 These environment variables allow configuration for the Postgres database.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这些环境变量允许为 Postgres 数据库进行配置。'
- en: These were good starts, but we need to back up a step so that we can break the
    code down and get something even shorter. Because we relied too heavily on generative
    AI, we started larger than we normally would, and that is a good lesson for us
    to take away. We spoke about the need for quick feedback loops and short cycles.
    It is never a good idea to change too much code in one session because when verifying
    our changes, we are unsure what actually addressed our problem. Therefore, asking
    generative AI to build four or five containers without a good understanding of
    what needs to happen was a bad idea.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是良好的开端，但我们需要退一步，以便我们可以分解代码并得到更短的内容。因为我们过度依赖生成式 AI，所以我们开始得比平时更大，这是一个我们应该吸取的好教训。我们讨论了需要快速反馈循环和短周期的必要性。在一次会话中更改太多代码从来不是一个好主意，因为当我们验证我们的更改时，我们不确定实际上解决了我们的问题。因此，在没有充分了解需要发生什么的情况下，让生成式
    AI 构建四个或五个容器是一个糟糕的想法。
- en: Now that we have gotten a dose of reality and taken a step back, let us pick
    a single container to get up and running.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经吸取了现实的一课并退了一步，让我们选择一个容器来启动并运行。
- en: 3.2.1 Creating a CloudBeaver container
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 创建 CloudBeaver 容器
- en: We will start by building out a CloudBeaver container. CloudBeaver is a database
    management tool that supports multiple databases through a simple web-based user
    interface. There is no shortage of database management interfaces. You may also
    want to check out pgAdmin ([https://www.pgadmin.org/](https://www.pgadmin.org/))
    since we are working with a Postgres database or DataGrip by JetBrains ([https://www.jetbrains.com/datagrip/](https://www.jetbrains.com/datagrip/))
    since we’ll be using other JetBrains IDEs in this project. We do not have any
    vested interest in any particular product but are hoping to share what we have
    seen in use in FinTech.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建一个 CloudBeaver 容器。CloudBeaver 是一个数据库管理工具，通过简单的基于网页的用户界面支持多种数据库。数据库管理界面并不少见。如果您正在使用
    Postgres 数据库，也可以查看 pgAdmin ([https://www.pgadmin.org/](https://www.pgadmin.org/))，或者使用
    JetBrains 的 DataGrip ([https://www.jetbrains.com/datagrip/](https://www.jetbrains.com/datagrip/))，因为我们将在项目中使用其他
    JetBrains IDE。我们没有对任何特定产品有投资利益，只是希望分享我们在 FinTech 中看到的使用情况。
- en: We are installing CloudBeaver because we want another way to view and manage
    our database other than just using code. Your company probably has a preferred
    tool, and you can feel free to use it. However, CloudBeaver is simple to get up
    and running.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装 CloudBeaver 是因为我们想有另一种方式查看和管理我们的数据库，而不仅仅是使用代码。您的公司可能有一个首选的工具，您可以自由使用它。然而，CloudBeaver
    非常容易启动和运行。
- en: So, why are we setting up a database management tool before our database? That
    is a good question. Because CloudBeaver is a web interface, we will be able to
    confirm the container is up and running simply by opening a browser and navigating
    to a URL. So, CloudBeaver provides a quick and simple way to get started and verify
    our progress. Another option is to use our IDE, as IDEs often provide integration
    (or a plugin) to browse the database. Of course, using our IDE gets away from
    Docker, and we are looking to explore different containers with Docker.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们在数据库之前设置数据库管理工具呢？这是一个好问题。因为 CloudBeaver 是一个网页界面，我们可以通过打开浏览器并导航到 URL
    来简单地确认容器是否正在运行。因此，CloudBeaver 提供了一种快速简单的方法来开始并验证我们的进度。另一种选择是使用我们的 IDE，因为 IDE 通常提供集成（或插件）来浏览数据库。当然，使用我们的
    IDE 会脱离 Docker，而我们正在探索使用 Docker 的不同容器。
- en: 'With that in mind, let’s get started by prompting ChatGPT:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们通过提示 ChatGPT 来开始：
- en: '**![image](../Images/Prompt-Icon.png)** Create just a basic Cloudbeaver service
    in Docker Compose.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**![image](../Images/Prompt-Icon.png)** 在 Docker Compose 中仅创建一个基本的 Cloudbeaver
    服务。'
- en: We receive the following output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了以下输出。
- en: Listing 3.3  Sample CloudBeaver container output from ChatGPT
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3  ChatGPT 的示例 CloudBeaver 容器输出
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 The version tag is obsolete, but even 3. 1 was outdated when ChatGPT provided
    this answer; this is an example of the need to verify ChatGPT responses.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 版本标签已过时，但即使 3.1 版本在 ChatGPT 提供这个答案时也已经过时；这是一个需要验证 ChatGPT 响应的例子。'
- en: 'The output looks plausible, but we see the version number is `3.1`. The latest
    Docker compose version was `3.8`, but now the `version` tag has been marked as
    obsolete by the project. While we can still specify it for the time being, using
    it will show a warning message. If it were ever to become an error, that would
    certainly pose a problem. So, we tell ChatGPT:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是合理的，但我们看到版本号是 `3.1`。最新的 Docker Compose 版本是 `3.8`，但现在 `version` 标签已被项目标记为过时。虽然我们目前还可以指定它，但使用它将显示警告消息。如果它将来成为错误，这肯定会引起问题。因此，我们告诉
    ChatGPT：
- en: '**![image](../Images/Prompt-Icon.png)** Update the basic setup to remove the
    Docker Compose version as it is now obsolete.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**![image](../Images/Prompt-Icon.png)** 更新基本设置以删除 Docker Compose 版本，因为它现在已经过时。'
- en: With that, our file is updated. The ability to update output from our conversation
    is a powerful aspect of generative AI that we should keep in mind. Of course,
    we could have simply removed it from the produced file; however, we hope that
    our updated prompt will feed back into the system, and we will eventually stop
    getting the `version` tag as part of generated files.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的文件就更新了。从我们的对话中更新输出的能力是生成式 AI 的一个强大方面，我们应该记住。当然，我们也可以简单地从生成的文件中删除它；然而，我们希望我们的更新提示能够反馈到系统中，我们最终将不再在生成的文件中获得
    `version` 标签。
- en: 'We can copy and paste the output from listing 3.3 into a docker-compose.yml
    file, navigate to the folder, and then issue the command `docker-compose` `up`.
    On our machine, it failed to do this because of the following error:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将列表 3.3 的输出复制粘贴到 docker-compose.yml 文件中，导航到文件夹，然后执行 `docker-compose up`
    命令。在我们的机器上，由于以下错误，它未能完成此操作：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This error is pretty straightforward, but remembering what you have running
    that might be using the port is not always straightforward. We could also update
    our docker-compose file to use a different port, but at this point, we can find
    the offending process on Windows PowerShell by using `netstat` `-aon` `|` `findstr`
    `"8080"` and then `tasklist` `|` `findstr` `PID` where PID are the process IDs
    that we just came across (which are on the right-hand side). Once you do that,
    you can either determine whether you want to shut down/stop whatever program you
    have running or adjust the port being used. In our case, another Docker container
    was being used, so it was safe to shut down. At this point, running `docker-compose`
    `up` works, and we can navigate to http://localhost:8080/ and see a web interface
    shown in figure 3.2.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误相当直接，但记住你正在运行可能使用该端口的程序并不总是那么直接。我们也可以更新我们的docker-compose文件以使用不同的端口，但在这个时候，我们可以通过在Windows
    PowerShell中使用`netstat` `-aon` `|` `findstr` `"8080"`然后`tasklist` `|` `findstr`
    `PID`（PID是我们刚刚遇到的进程ID，它们在右侧）来找到那个引起问题的进程。一旦你这样做，你可以决定是否要关闭/停止你正在运行的任何程序，或者调整正在使用的端口。在我们的情况下，另一个Docker容器正在使用，所以可以安全地关闭。在这个时候，运行`docker-compose`
    `up`是有效的，我们可以导航到http://localhost:8080/并看到图3.2所示的Web界面。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH03_F02_Kardell.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](../Images/CH03_F02_Kardell.png)'
- en: Figure 3.2  CloudBeaver welcome screen
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2  CloudBeaver欢迎屏幕
- en: 3.2.2 Create a PostgreSQL container
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 创建一个PostgreSQL容器
- en: Things will get a little more interesting now because we get to add a database
    container. Eventually, the database will store our ACH files and associated data,
    but for now, we will keep things simple. We can also populate the database with
    data when the container starts, so that we can use CloudBeaver to connect to the
    database and view our data. We can ask ChatGPT to simply
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情会变得更有趣，因为我们有机会添加一个数据库容器。最终，数据库将存储我们的ACH文件和相关数据，但现在我们将保持简单。我们还可以在容器启动时填充数据库，这样我们就可以使用CloudBeaver连接到数据库并查看我们的数据。我们可以要求ChatGPT简单地
- en: '**![image](../Images/Prompt-Icon.png)** Update the docker-compose file to also
    include a `postgres` service.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](../Images/Prompt-Icon.png)** 更新docker-compose文件，以包括一个`postgres`服务。'
- en: Again, that created a helpful starting point, shown in the next listing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这提供了一个有利的起点，如下一个列表所示。
- en: Listing 3.4  Multiple containers generated by ChatGPT
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4  ChatGPT生成的多个容器
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, let’s take a step back and build a simpler file, which will serve us
    better at this time because we are still trying to adhere to the principle of
    YAGNI (“You aren’t going to need it”) as much as possible. Some purists might
    argue that even creating these Docker containers violates that principle. We do
    not strictly need any of this for our project at this point—we may not even need
    a database. Perhaps, we could get away with just writing to a file or keeping
    things in memory! That could certainly be true, but we could also look at this
    as the existing code because our application is built on PostgreSQL and so that
    is going to be a requirement regardless of whether we really need it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们退一步，构建一个更简单的文件，这将在这个时候更好地为我们服务，因为我们仍在尽可能遵守YAGNI（你不需要它）的原则。一些纯粹主义者可能会争论，甚至创建这些Docker容器也违反了这一原则。目前，我们可能并不需要我们项目的任何这些——我们甚至可能不需要数据库。也许，我们可以通过只写入文件或保持数据在内存中而逃脱！这当然可能是真的，但我们可以将这视为现有代码，因为我们的应用程序是基于PostgreSQL构建的，所以不管我们是否真的需要它，这都将是一个要求。
- en: What is YAGNI?
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是YAGNI？
- en: YAGNI is an acronym for “You aren’t going to need it.” It is a principle of
    extreme programming and ties back to our Agile principles, such as minimum viable
    product (MVP), by trying to enforce the idea of avoiding unnecessary work and
    complexity. Sometimes, when coding, it is hard to resist adding that extra function
    that you’re pretty sure you will need later, so you might as well code it now.
    Then, that code never gets used but is flagged by static code analysis for fixes
    and requires changes when you update some object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI是“你不需要它”（You aren’t going to need it）的缩写。它是极限编程的一个原则，并且与我们的敏捷原则（如最小可行产品MVP）相联系，通过试图强制执行避免不必要的工作和复杂性的想法。有时候，在编码时，很难抗拒添加那些你很确定将来会需要的额外功能，所以你可能会选择现在就编写它。然后，那段代码从未被使用，但被静态代码分析标记为需要修复，并在更新某些对象时需要更改。
- en: So, if nothing else, just keep the principle in mind to avoid that extra complexity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，至少要记住这个原则，以避免额外的复杂性。
- en: 'Let’s go back to building our container. We add a simple container with the
    following (you can view the whole file in the provided v2/docker folder on GitHub
    for this chapter):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到构建我们的容器。我们添加一个简单的容器，如下所示（你可以查看GitHub上提供的v2/docker文件夹中本章的整个文件）：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this, we can navigate to CloudBeaver with http://localhost:8080 and set
    up a connection; however, we do not have any data to view. We want to be able
    to load some data when the container is built, so we will look into doing that
    now. Note that we removed the networking and volume fields from the generated
    Dockerfile because we are going to rely on the networking that is set up by Docker.
    By default, all the containers defined with our docker-compose file under services
    will be able to communicate with each other. Also, we are not interested in persisting
    data in this project (at least for now), so we removed the volumes tag. This gives
    us a simple starting point.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以导航到CloudBeaver，使用http://localhost:8080并设置连接；然而，我们没有数据可以查看。我们希望能够在容器构建时加载数据，所以我们将现在查看如何实现这一点。注意，我们已从生成的Dockerfile中删除了网络和卷字段，因为我们将依赖于Docker设置的网络。默认情况下，所有在docker-compose文件下的服务中定义的容器都能够相互通信。此外，我们在这个项目中不感兴趣持久化数据（至少目前是这样），所以我们删除了卷标签。这为我们提供了一个简单的起点。
- en: To add some data, we will create a SQL script that executes when the container
    is first built. We start off by creating a `health_check` table. This table could
    be used to determine whether our application is in a valid state. For us, it is
    more of a “Hello, World!” scenario than anything meaningful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一些数据，我们将创建一个SQL脚本，该脚本在容器首次构建时执行。我们首先创建一个`health_check`表。这个表可以用来确定我们的应用程序是否处于有效状态。对我们来说，这更像是一个“Hello,
    World！”场景，而不是任何有意义的内容。
- en: Health checks
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 健康检查
- en: Because our application will be spread across a number of containers, it is
    often useful to create a health check. It is a common pattern to follow when using
    microservices. Even though we have started by initially creating a database table
    named `health_check`, this is just the beginning.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序将分布在多个容器中，创建一个健康检查通常很有用。在使用微服务时，这是一个常见的模式。尽管我们最初创建了一个名为`health_check`的数据库表，但这只是开始。
- en: Docker allows us to create a health check for the container within our setup,
    which we will explore later. This test can determine whether the container is
    “unhealthy.” When using a container orchestration tool such as Kubernetes, these
    health status checks can trigger alerts to admins, as well as automatically restart
    containers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许我们在设置中为容器创建一个健康检查，我们将在稍后探讨。这个测试可以确定容器是否“不健康”。当使用Kubernetes之类的容器编排工具时，这些健康状态检查可以触发管理员警报，并自动重启容器。
- en: Tools such as Kubernetes also have expanded these checks to differentiate between
    the app being unavailable because it is initializing and because something crashed.
    These are referred to as “readiness” and “liveness,” respectively.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes之类的工具还扩展了这些检查，以区分应用程序因初始化而不可用和因崩溃而不可用的情况。这些分别被称为“就绪”和“存活”。
- en: 'Now that we have a little more robust container, we will be working with four
    `docker-compose` commands:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个更健壮的容器，我们将使用四个`docker-compose`命令：
- en: '`docker-compose` `build`—We use this command when we need to build the container
    as specified in the Dockerfile. Any updates to files/scripts that we are including
    in the container will require us to issue this command.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose` `build`—当我们需要根据Dockerfile构建容器时，我们使用这个命令。对我们包含在容器中的文件/脚本所做的任何更新，都需要我们发出这个命令。'
- en: '`docker-compose` `up`—This command is used when we need to start our containers.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose` `up`—当我们需要启动我们的容器时，使用这个命令。'
- en: '`docker-compose` `stop`—We use this command when we want to stop our container
    and leave the data in place. While important, we will typically use the `down`
    argument because we will rely on our initialization scripts to populate the database
    and start with a fresh database each time.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose` `stop`—当我们想要停止我们的容器并保留数据时，使用这个命令。虽然很重要，但我们将通常使用`down`参数，因为我们将依赖于我们的初始化脚本来填充数据库，并且每次都从一个全新的数据库开始。'
- en: '`docker-compose` `down`—This command is used when we need to stop and remove
    the containers. We use it to make changes to any of our initialization scripts
    because the initialization will not occur when the database exists.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose` `down`—这个命令用于在需要停止并删除容器时使用。我们用它来更改任何初始化脚本，因为当数据库存在时，初始化将不会发生。'
- en: We’ll require these commands as we make changes to our Dockerfiles. Usually,
    for development, we just chain them together as `docker-compose` `down` `&&` `docker-compose`
    `build` `&&` `docker-compose` `up`. You can even slim the command down to `docker-compose`
    `down` `&&` `docker-compose` `up` `--build`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们修改 Dockerfile 时，我们需要这些命令。通常，对于开发，我们只是将它们链在一起作为 `docker-compose down` `&&`
    `docker-compose build` `&&` `docker-compose up`。你甚至可以将命令简化为 `docker-compose down`
    `&&` `docker-compose up` `--build`。
- en: Initially creating our containers may take a bit of time, but the process will
    be significantly faster when making small incremental changes. We should now be
    able to view our table and its data through CloudBeaver.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 初始创建我们的容器可能需要一些时间，但在进行小幅度增量更改时，这个过程将会显著加快。现在我们应该能够通过 CloudBeaver 查看我们的表格及其数据。
- en: 3.2.3 API container
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 API 容器
- en: Our next container expands on our container experience by building a container
    for our APIs. Soon, we will begin to build out specific APIs for dealing with
    ACH files, but for now, we will keep things very basic. We want to make use of
    the FastAPI framework for running our APIs in Python.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个容器通过构建我们的 API 容器来扩展我们的容器经验。很快，我们将开始构建处理 ACH 文件的具体 API，但到目前为止，我们将保持非常基础。我们希望利用
    FastAPI 框架在 Python 中运行我们的 API。
- en: 'We will create a Python container from the standard Docker Python image (an
    image in Docker is a standard read-only template used to create a container) and
    install FastAPI and some dependencies on top. In our previous containers, we worked
    directly in the docker-compose file to create our containers. With this container,
    we will create a Dockerfile that will be referenced by the docker-compose file.
    To store the dependencies and configuration of the image, we need to introduce
    a few new commands:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从标准的 Docker Python 镜像（Docker 中的镜像是一个标准的只读模板，用于创建容器）创建一个 Python 容器，并在其上安装
    FastAPI 和一些依赖项。在我们之前的容器中，我们直接在 docker-compose 文件中创建容器。使用这个容器，我们将创建一个 Dockerfile，该文件将被
    docker-compose 文件引用。为了存储镜像的依赖项和配置，我们需要引入一些新的命令：
- en: '`FROM`—Specifies a base image to start building the image from.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`—指定一个基础镜像来从它开始构建镜像。'
- en: '`COPY`—Copies directories/files from the local machine to the image. In the
    upcoming section, we will create a requirements.txt that will need to be copied
    to the image that contains FastAPI, among other things.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`—从本地机器复制目录/文件到镜像。在接下来的章节中，我们将创建一个 requirements.txt 文件，该文件需要被复制到包含 FastAPI
    的镜像中，以及其他一些内容。'
- en: '`RUN`—Executes a command in the image during the build process. We will execute
    `pip` to install the required Python packages.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`—在构建过程中在镜像中执行命令。我们将执行 `pip` 来安装所需的 Python 包。'
- en: '`CMD`—Specifies a default command to run when the container starts. We will
    use this command to run Uvicorn, which is an Asynchronous Server Gateway Interface
    (ASGI) that we need to run FastAPI.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`—指定容器启动时运行的默认命令。我们将使用此命令来运行 Uvicorn，这是一个异步服务器网关接口（ASGI），我们需要运行 FastAPI。'
- en: As mentioned, we are using the `FROM` command to declare a base image to build
    from. Docker will default to the latest if you do not specify anything, but you
    can also specify a particular image tag. Specifying a tag can be useful for various
    reasons, especially if you want to lock the image to a particular version. We
    will use the `latest` for our images because we consider this a development project
    that would not be immediately pushed to production.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用 `FROM` 命令来声明一个基础镜像来构建。如果你不指定任何内容，Docker 将默认使用最新版本，但你也可以指定一个特定的镜像标签。指定标签可能有各种原因，特别是如果你想将镜像锁定到特定版本。我们将使用
    `latest` 作为我们的镜像，因为我们认为这是一个开发项目，不会立即推送到生产环境。
- en: What do we mean by a development project? We just mean that in a production
    environment, more care is needed when changing the software version. You may have
    deprecated features, and there may be bugs or vulnerabilities that you should
    be aware of. These are all considerations that you need to weigh before changing
    the version. In this instance, we pick the latest version of Python when building
    our container. In a production environment, you would want to control that upgrade
    by running it through your test suite and ensuring no incompatibilities exist.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的开发项目是什么意思？我们只是意味着在生产环境中，更改软件版本时需要更加小心。你可能会有过时的功能，可能会有你需要注意的错误或漏洞。这些都是你在更改版本之前需要权衡的考虑因素。在这种情况下，我们在构建容器时选择
    Python 的最新版本。在生产环境中，你将通过运行测试套件来控制升级，并确保不存在任何不兼容性。
- en: These concerns about the containers’ version also extend to the application
    itself. This container installs FastAPI on top of the Python container, so we
    have a requirements.txt file to take care of that. We have chosen to just install
    the latest packages for this example; however, we encourage you to look at locking
    in a particular version and other requirements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关于容器版本的问题也扩展到应用程序本身。此容器在Python容器之上安装了FastAPI，因此我们有一个requirements.txt文件来处理这个问题。我们选择在这个示例中只安装最新的包；然而，我们鼓励您考虑锁定特定版本和其他要求。
- en: Python requirements.txt
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Python requirements.txt
- en: Our example uses the package name without any type of versioning. However, there
    are better safety measures that you can take advantage of, such as
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用不带任何类型版本控制的包名。然而，您可以利用更好的安全措施，例如
- en: '*Specifying the exact versio**n*—`package``==``1.0.0`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定确切版本*—`package==1.0.0`'
- en: '*A version rang**e*—`package>=1.0.0,<2.0.0`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*版本范围*—`package>=1.0.0,<2.0.0`'
- en: '*Exclude a versio**n*—`package!=1.0.5`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排除版本*—`package!=1.0.5`'
- en: '*A version combined with a Python version*—`package==1.1.0;``python_version``<``''3.10''`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*版本与Python版本的组合*—`package==1.1.0;python_version<''3.10''`'
- en: You can also install from version control systems, URLs, and local files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从版本控制系统、URL和本地文件中进行安装。
- en: Finally, you can create a requirements.txt for your project by using `pip` `freeze`
    `>` `requirements.txt`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过使用`pip freeze > requirements.txt`为您的项目创建一个requirements.txt文件。
- en: You should be able to use the standard `docker-compose` `build` and `docker-compose
    up` commands to build and bring the containers online. Depending on the ports
    that you used (`8000` for us), you should be able to navigate to the APIs with
    http://localhost:8000/ and then see the output `{"message":"Hello` `World!"}`,
    which is still pretty cool although not doing much.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够使用标准的`docker-compose build`和`docker-compose up`命令来构建并使容器上线。根据您使用的端口（对我们来说是`8000`），您应该能够通过http://localhost:8000/导航到API，然后看到输出`{"message":"Hello
    World!"}`，尽管它没有做太多事情，但仍然相当酷。
- en: 3.2.4 Web server container
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 Web服务器容器
- en: The final piece of our container puzzle that we are looking into is a web interface.
    The plan is to provide a dashboard with which we can upload and view ACH files.
    Again, for now, we are just going to build a simple page to ensure everything
    is working. For this container, we will be building our application on top of
    Nginx. While a large number of existing infrastructures run Apache for a web Server,
    Nginx has had a slightly larger market share for the past few years.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在研究的容器拼图中最后一部分是一个Web界面。计划是提供一个仪表板，我们可以通过它上传和查看ACH文件。同样，目前我们只是构建一个简单的页面来确保一切正常工作。对于这个容器，我们将在Nginx之上构建我们的应用程序。虽然大量现有基础设施使用Apache作为Web服务器，但Nginx在过去几年中拥有略大的市场份额。
- en: This container builds on some of the concepts we explored before, such as building
    a container using a base image. In addition, you will likely want to manage the
    ports from the docker-compose file. Previously, we specified ports such as `8000:8000`,
    which gave both the host and container ports, respectively. By default, Nginx
    will be listening on `port` `80`, and while we could update its configuration
    file to define a different port to listen on, we can take this opportunity to
    introduce configuring the ports in Docker. Suppose we want to be able to keep
    the default port for Nginx and just give a different port to the web browser.
    For instance, let us say we want to be able to navigate to http://localhost:3000/hello.xhtml
    to access our sample web page. We can do that by specifying `3000:80` and then
    starting our containers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器基于我们之前探索的一些概念，例如使用基础镜像构建容器。此外，您可能还希望从docker-compose文件中管理端口。之前，我们指定了如`8000:8000`这样的端口，分别给出了主机和容器的端口。默认情况下，Nginx将监听`端口``80`，虽然我们可以更新其配置文件以定义不同的监听端口，但我们可以利用这个机会来介绍在Docker中配置端口。假设我们希望能够保留Nginx的默认端口，同时只为网页浏览器提供一个不同的端口。例如，让我们假设我们希望能够导航到http://localhost:3000/hello.xhtml来访问我们的示例网页。我们可以通过指定`3000:80`然后启动我们的容器来实现这一点。
- en: At this point, we have set all the containers we are going to need so far, but
    we haven’t ensured they are talking to each other.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了我们将需要的所有容器，但我们还没有确保它们正在相互通信。
- en: 3.3 Connecting our containers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 连接我们的容器
- en: Now, let’s go back to getting our containers to communicate. We would like to
    make sure that our containers can interact. Our use case is simple to start with,
    but it lays the groundwork for expanding our project. We would like to be able
    to access a web page that uses the API layer to access our `health_check` database
    table. This table is not necessarily changing at this point, but we can manually
    adjust it and see the results. It will be a nice first step in ensuring that everything
    is functioning as expected.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到让我们的容器进行通信的问题。我们希望确保我们的容器可以交互。我们的用例一开始很简单，但为扩展我们的项目奠定了基础。我们希望能够访问一个使用API层访问我们的`health_check`数据库表的网页。这个表在这个阶段可能不会改变，但我们可以手动调整它并查看结果。这将是一个确保一切按预期运行的很好的第一步。
- en: As mentioned earlier, ports can pose a problem, not only from a security perspective
    but just remembering which ports you have chosen. So, let us make a list of our
    containers and the ports we are using.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，港口可能会带来问题，不仅从安全角度考虑，而且仅仅记住你选择了哪些端口。因此，让我们列出我们的容器和正在使用的端口。
- en: Table 3.1 Container port listing
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1 容器港口列表
- en: '| Container name | Host port | Internal port |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 容器名称 | 主机端口 | 内部端口 |'
- en: '| CloudBeaver | `8080` | `8080` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| CloudBeaver | `8080` | `8080` |'
- en: '| Postgres | `-` | `5432` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| Postgres | `-` | `5432` |'
- en: '| Api | `8000` | `8000` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Api | `8000` | `8000` |'
- en: '| Web | `3000` | `80` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| Web | `3000` | `80` |'
- en: 3.3.1 Connecting to the database
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 连接到数据库
- en: Our first step is to have the API container connected to the database and grab
    the result from the table. At this point, we are only looking to get the plumbing
    sorted out, so we are not going to look at writing a unit test yet. We will be
    able to easily test this ourselves as we build out the sample. First, we will
    focus on updating our API layer to connect to the database and return our given
    status.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是让API容器连接到数据库并从表中获取结果。在这个阶段，我们只是想要整理好管道，所以我们不会考虑编写单元测试。随着我们构建示例，我们将能够轻松地测试这一点。首先，我们将专注于更新我们的API层以连接到数据库并返回我们的给定状态。
- en: We start by updating our requirements.txt to include `psycopg[c]` to support
    connecting to the database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先更新我们的requirements.txt，包括`psycopg[c]`以支持连接到数据库。
- en: Listing 3.5  Our updated requirements.txt
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5  我们更新的requirements.txt
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `psycopg[c]` is a production appropriate approach but also requires updating
    our Dockerfile to include additional dependencies. You should now be able to access
    http://localhost:8000/health/status to view the status. If everything went okay,
    you should see `[{"id":1,"status":"OK"}]`. If not, you can jump down to section
    3.2.2, which discusses some common problems you may encounter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`psycopg[c]`是一个适合生产的方案，但也需要更新我们的Dockerfile以包括额外的依赖项。你现在应该能够访问http://localhost:8000/health/status来查看状态。如果一切顺利，你应该会看到`[{"id":1,"status":"OK"}]`。如果不这样，你可以跳到3.2.2节，该节讨论了你可能遇到的一些常见问题。'
- en: We have a few things to think about now that we have updated this code. Our
    `health_check` table is currently built to have a sequential ID and a status,
    and we decided to return all our records in this example. You can experiment with
    this by going into CloudBeaver (http://localhost:8080), clicking the `SQL` command,
    and inserting another record with `INSERT` `INTO` `health_check` `VALUES(DEFAULT,`
    `'testing')`. It is not necessary to capitalize the SQL statements, but we find
    that doing so helps keep the code more readable when dealing with SQL intermingled
    with other code. After inserting the record, you will find that navigating back
    to the health/status endpoint will return all records. So, you should see something
    similar to `[{"id":1,"status":"OK"},{"id":2,"status":"testing"}]`. Later, we can
    review and explore ways to address this. Keep in mind that we wanted to provide
    the health of the current system but that we are not doing anything to update
    that table at this time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了这段代码之后，我们现在有几件事情需要考虑。我们的`health_check`表目前是按照顺序ID和状态构建的，并且我们决定在这个例子中返回所有记录。你可以通过进入CloudBeaver（http://localhost:8080），点击`SQL`命令，并使用`INSERT`
    `INTO` `health_check` `VALUES(DEFAULT,` `'testing')`插入另一条记录来实验。不需要将SQL语句大写，但我们发现这样做有助于在处理与其他代码混合的SQL时使代码更易读。插入记录后，你会发现导航回健康/状态端点将返回所有记录。所以，你应该会看到类似`[{"id":1,"status":"OK"},{"id":2,"status":"testing"}]`的内容。稍后，我们可以回顾并探索解决这一问题的方法。记住，我们想要提供当前系统的健康状况，但我们目前并没有做任何事情来更新这个表。
- en: Exposed ports and internal networks
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 暴露的端口和内部网络
- en: When specifying our connection string, we selected `port` `5432`. You can also
    see that the `postgres` container is listening on `5432` as there should be a
    log message saying `listening` `on` `IPv4 address 0.0.0.0,` `port` `5432`. However,
    our list of ports shows we did not specify it, so what gives?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定我们的连接字符串时，我们选择了 `端口` `5432`。你还可以看到 `postgres` 容器正在监听 `5432`，因为应该有一个日志消息说
    `监听` `IPv4 地址 0.0.0.0,` `端口` `5432`。然而，我们的端口列表显示我们没有指定它，那么问题出在哪里呢？
- en: Because we are using Docker Compose, one of the benefits is the creation of
    an internal network. This allows the containers to talk to each other as if they
    were on the same network. In our case, the above ports were only for the host
    system. If we wanted to write scripts or browse the database using tools installed
    on our desktop, then we could have exposed `port` `5432`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Docker Compose，其中一个好处是创建了一个内部网络。这允许容器像在同一网络中一样相互通信。在我们的情况下，上述端口仅用于主机系统。如果我们想使用安装在桌面上的工具编写脚本或浏览数据库，那么我们可以暴露
    `端口` `5432`。
- en: Why can we use CloudBeaver to view the SQL data? Well, that is because we exposed
    the `8080` `port` for CloudBeaver which we can browse with our web browser. So,
    we are communicating externally with CloudBeaver, but CloudBeaver can use the
    internal network to hit `port` `5432`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们可以使用 CloudBeaver 来查看 SQL 数据？嗯，那是因为我们为 CloudBeaver 暴露了 `8080` `端口`，我们可以用我们的网页浏览器来浏览它。因此，我们与
    CloudBeaver 进行外部通信，但 CloudBeaver 可以使用内部网络来访问 `端口` `5432`。
- en: 3.3.2 Troubleshooting PostgreSQL and FastAPI
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 PostgreSQL 和 FastAPI 故障排除
- en: It is entirely likely that things did not go as expected when setting up your
    container or that things will not go as intended when setting up other containers.
    When starting the containers with `docker-compose` `up`, be sure to keep an eye
    on the logs as you may frequently see a meaningful error message. Also note that
    you may need to scroll back because an earlier container failed, and others are
    running after it, or an error/warning message was just lost in the shuffle. The
    following are some of the more common errors you may get in the scenario of a
    container not starting.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置容器时，事情可能没有按预期进行，或者在其他容器设置时可能不会按预期进行。当使用 `docker-compose` `up` 启动容器时，务必注意日志，因为你可能会频繁地看到有意义的错误信息。还要注意，你可能需要向上滚动，因为之前的容器失败了，其他容器随后启动，或者错误/警告信息在混乱中丢失了。以下是在容器无法启动的情况下可能会遇到的更常见的一些错误。
- en: We are trying to make a connection from one container to another, so you may
    see a message on the console similar to  `Is` `the` `server` `running` `on` `that`
    `host` `and` `accepting` `TCP/IP` `connections?`  This message could mean that
    the container failed to start, and since it is connecting from our FastAPI code
    to the database, there may be a syntax error in our code that prevented the container
    from starting. This error could be a typo in our code or could result from dependencies
    that we failed to include. If the code is syntactically correct, check the requirements.txt
    and Dockerfile to ensure that all requirements are being installed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图从一个容器连接到另一个容器，所以你可能在控制台上看到类似的消息 `Is` `the` `server` `running` `on` `that`
    `host` `and` `accepting` `TCP/IP` `connections?` 这条消息可能意味着容器启动失败，并且由于它是从我们的 FastAPI
    代码连接到数据库，我们的代码中可能存在语法错误，阻止了容器的启动。这个错误可能是代码中的拼写错误，也可能是由于我们未能包含的依赖项导致的。如果代码在语法上是正确的，请检查
    requirements.txt 和 Dockerfile，以确保所有要求都被安装。
- en: The error `connection` `to` `server` `at` `"localhost"` `(::1),` `port` `5432`
    `failed:` `Cannot` `assign` `requested` `address` is another one we can run into.
    This error is common because many examples may refer to `localhost`, and it may
    be easy to mistakenly use localhost instead of the name/address of the container.
    You may also assume that since we are running on our computer, you can use `localhost`.
    Remember, though, that we are running in a container. We should specify the name
    of the container in our connection string rather than `localhost`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 错误 `连接` `到` `服务器` `at` `"localhost"` `(::1),` `端口` `5432` `失败:` `无法` `分配` `请求的`
    `地址` 是我们可能会遇到的其他错误之一。这个错误很常见，因为许多示例可能引用了 `localhost`，并且可能会错误地使用 localhost 而不是容器的名称/地址。你也可能认为，既然我们在自己的电脑上运行，就可以使用
    `localhost`。但是记住，我们是在容器中运行。我们应该在我们的连接字符串中指定容器的名称，而不是 `localhost`。
- en: The error `psycopg.OperationalError:` `connection` `failed:` `FATAL:` `password
    authentication` `failed` `for` `user` `"postgres"` can occur when you have an
    invalid user or password specified. Look at the Dockerfile and docker-compose.yml
    to ensure you have the correct username and password. Remember that at this point,
    we have defined the username and password in our docker-compose file when setting
    up the database container, but we also had to hardcode it into our Python code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定了无效的用户名或密码时，可能会发生`psycopg.OperationalError:` `connection` `failed:` `FATAL:`
    `password authentication` `failed` `for` `user` `"postgres"`这个错误。查看Dockerfile和docker-compose.yml文件，确保你有正确的用户名和密码。记住，在这个阶段，我们在设置数据库容器时已经在我们的docker-compose文件中定义了用户名和密码，但我们还必须在Python代码中硬编码它。
- en: Another error we may encounter, especially when generative AI is helping, is
    a `NameError`. A `NameError` is raised when a local or global name is not found,
    meaning we tried to use a variable, function, or module that has either not been
    defined or is not accessible in the current scope. We encountered the error `NameError:`
    `name` `'status'` `is` `not` `defined` when working through the code ourselves
    because we were not paying close attention to the code generative AI suggested.
    The variable `status` was populated by Copilot even though that was not the name
    of the variable we used. So, this amounted to a simple syntax error, and we had
    to return the right value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到的其他错误，尤其是在生成式AI的帮助下，是`NameError`。当本地或全局名称未找到时，会引发`NameError`，这意味着我们尝试使用尚未定义或当前作用域中不可访问的变量、函数或模块。当我们自己处理代码时遇到了`NameError:`
    `name` `'status'` `is` `not` `defined`这个错误，因为我们没有仔细注意生成式AI建议的代码。尽管这不是我们使用的变量名，Copilot还是填充了`status`变量。因此，这只是一个简单的语法错误，我们必须返回正确的值。
- en: 3.4 Calling our API
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 调用我们的API
- en: At this point, we should be able to confirm that the API has access to the database
    container. We have one more jump that we would like to make—we want to be able
    to create a web page that will access the API. Although we have already seen that
    we can access the API in our browser, we were able to get away with testing that
    way because our REST API was using a `GET` request, which is the same request
    used to retrieve web pages. Later, when using some of the other HTTP verbs such
    as `POST`, `PUT`, and `DELETE`, we will not be able to test in this fashion. Furthermore,
    we will be looking to build the UI, so we need to ensure connectivity between
    the web and API containers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该能够确认API可以访问数据库容器。我们还想进行一次跳跃——我们希望能够创建一个可以访问API的网页。尽管我们已经看到我们可以在浏览器中访问API，但我们能够通过这种方式进行测试，因为我们的REST
    API使用的是`GET`请求，这与检索网页使用的请求相同。稍后，当使用其他HTTP动词，如`POST`、`PUT`和`DELETE`时，我们无法以这种方式进行测试。此外，我们将构建UI，因此我们需要确保Web和API容器之间的连接性。
- en: We will create a simple web page that incorporates d3.js to display our results.
    In our case, we do not need anything fancy, so we will just create a list of the
    results. If you are not familiar with HTML or d3.js, this would be a wonderful
    time to see whether our generative AI tool could help you get started.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的网页，结合d3.js来显示我们的结果。在我们的例子中，我们不需要任何花哨的东西，所以我们只创建一个结果列表。如果你不熟悉HTML或d3.js，这将是一个很好的时候看看我们的生成式AI工具是否可以帮助你开始。
- en: We prompted ChatGPT (GPT-40) with
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用ChatGPT（GPT-40）提示
- en: '**![image](../Images/Prompt-Icon.png)** Create a simple d3.js webpage that
    calls an API.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](../Images/Prompt-Icon.png)** 创建一个简单的d3.js网页，调用API。'
- en: It produced an example visible in `chat_gpt_example.xhtml`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成了一个在 `chat_gpt_example.xhtml` 中可见的示例。
- en: Listing 3.6  Sample page produced by ChatGPT
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.6  ChatGPT生成的示例页面
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This response gives us a great starting point, and with a few tweaks, we have
    a workable solution for our initial needs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应为我们提供了一个很好的起点，经过一些调整，我们就有了一个满足我们初始需求的可行解决方案。
- en: Listing 3.7  Updated sample page
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.7  更新的示例页面
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 We start by giving our page a title and importing d3.js.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们首先给我们的页面一个标题并导入d3.js。'
- en: '#2 Creates a heading and updates the ID to be more meaningful for our purposes'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建一个标题并更新ID，使其对我们更有意义'
- en: '#3 Accesses the API endpoint for the status check'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 访问状态检查的API端点'
- en: '#4 Updates the select statement and text fields (ID and text) so that we are
    writing out the expected data'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 更新选择语句和文本字段（ID和文本），以便我们写入预期的数据'
- en: In addition to customizing the output for our specific need, we had to bump
    up the version of d3.js to the current level. This is a reoccurring theme when
    working with generative AI; depending on the model and training data, the latest
    software may not always be included. It is a good idea to quickly double-check
    all software release levels just to confirm you are running an appropriate version.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定制输出以满足我们的特定需求外，我们还需要将d3.js的版本提升到当前水平。当与生成式AI一起工作时，这是一个经常出现的问题；根据模型和训练数据，最新的软件可能并不总是包含在内。快速检查所有软件发布级别以确认你正在运行适当的版本是一个好主意。
- en: The most important customization that we had to make was pointing the page to
    the correct API URL. You can refer to the port listing we made earlier; do you
    have any ideas what that URL will look like? You may have been tripped up by the
    previous example of connecting the database and API containers where we had to
    specify the container name. In that example, we were internal to Docker. Now,
    our web page is external, so we want to access it from the outside and thus use
    localhost with `port` `8000`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做出的最重要的定制是将页面指向正确的API URL。你可以参考我们之前制作的端口列表；你有什么想法这个URL会是什么样子吗？你可能被之前连接数据库和API容器的例子所困扰，在那个例子中，我们必须指定容器名称。在那个例子中，我们是在Docker内部。现在，我们的网页是外部的，因此我们想要从外部访问它，所以使用localhost和端口`8000`。
- en: 'Testing access gives us a CORS (cross-origin resource sharing) error:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 测试访问时，我们得到了一个CORS（跨源资源共享）错误：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: CORS
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CORS
- en: CORS, which is better known as the bane of getting things done quickly, is one
    of the more common problems you will run into. CORS stands for cross-origin resource
    sharing and is a security mechanism that allows servers to specify controls over
    which resources are shared with external callers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: CORS，更广为人知的是快速完成任务的障碍，是你在工作中会遇到的问题之一。CORS代表跨源资源共享，是一种安全机制，允许服务器指定对与外部调用者共享的资源进行控制的规则。
- en: CORS provides the idea of simple requests and preflight requests. We are not
    really concerned with simple requests because preflight requests are the ones
    that trigger CORS exceptions. To work around these exceptions, we will need to
    configure our server to ensure some specific headers dealing with CORS are sent
    back.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: CORS提供了简单请求和预请求的概念。我们并不真正关心简单请求，因为预请求是触发CORS异常的请求。为了绕过这些异常，我们需要配置我们的服务器以确保发送回处理CORS的一些特定头部信息。
- en: 'The following headers need to be used:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用以下头部信息：
- en: '`Access-Control-Allow-Origin`—Specifies which sites are allowed to access the
    resource. We can use a wildcard `*`, but this can pose a potential security risk.
    Remember, the principle of least privilege? Start with a more focused origin and
    only broaden it as necessary.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Origin`—指定哪些网站允许访问资源。我们可以使用通配符`*`，但这可能存在潜在的安全风险。记住，最小权限原则？从一个更具体的源开始，并在必要时才扩展。'
- en: '`Access-Control-Allow-Methods`—Specifies which HTTP methods are allowed. Again,
    you can use wildcards but should only use what is necessary. In our example, we
    are only using `GET` so that is the only one we really need. Later, we will be
    using more requests, but we recommend keeping it as `GET` for now and not updating
    it to use HTTP methods we have not yet defined, so that CORS will complain again
    later as it provides good troubleshooting practice.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Methods`—指定哪些HTTP方法是被允许的。同样，你可以使用通配符，但应仅使用必要的。在我们的例子中，我们只使用`GET`，因此这是我们真正需要的唯一一个。稍后，我们将使用更多的请求，但我们建议目前保持为`GET`，不要更新为使用尚未定义的HTTP方法，这样CORS会在稍后再次提出抱怨，这提供了良好的故障排除实践。'
- en: '`Access-Control-Allow-Headers`—Allows the server to specify what headers can
    be used for the request.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Headers`—允许服务器指定可以用于请求的头部信息。'
- en: '`Access-Control-Allow-Credentials`—Indicates whether the browser should include
    credentials for requests. If you have authenticated requests or need to maintain
    state with cookies, or otherwise have requests that include sensitive information,
    set this to `true`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Credentials`—指示浏览器是否应在请求中包含凭据。如果你有经过身份验证的请求或需要使用cookie维护状态，或者有包含敏感信息的请求，请将其设置为`true`。'
- en: To correct this error, our API layer needs to be updated with the following.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个错误，我们的API层需要更新以下内容。
- en: Listing 3.8  Incorporating CORS into our API
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.8  将CORS集成到我们的API中
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 We import the CORSMiddleware from fastapi.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们从fastapi导入CORSMiddleware。'
- en: '#2 The origins are where we expect to receive requests from; we create this
    as a separate variable because we expect to update it a few times.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 原始地址是我们期望接收请求的地方；我们将其作为一个单独的变量创建，因为我们预计会更新它几次。'
- en: '#3 We pass all the parameters here; allow_methods and allow_headers are an
    integral part of securing our API.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们在这里传递所有参数；allow_methods和allow_headers是我们保护API的一个不可或缺的部分。'
- en: Notice how we tried to keep the origins and methods narrow. In other words,
    we limited the allowed origins and methods to only what we need for now. Resist
    the urge to future-proof the code by using wildcards and more methods than you
    currently have/need. This is because when it comes to security, we want to keep
    it locked down. We wanted to say “Less is more” but did not want anyone coming
    back to us saying that they were hacked because they had less security! We mean
    that less access is better!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何尝试保持原始地址和方法尽可能窄。换句话说，我们限制了允许的原始地址和方法，仅限于我们现在需要的。抵制使用通配符和比您目前拥有/需要的更多方法的诱惑，以使代码具有未来性。这是因为当涉及到安全时，我们希望将其锁定。我们本想说“少即是多”，但不想有人回来告诉我们，因为他们有更少的保护而被黑客攻击！我们的意思是，更少的访问权限更好！
- en: With the CORS updates in place, you should be able to build the containers and
    bring Docker back up. Hopefully, you can now navigate to http://localhost:3000/health.xhtml
    and see some results. You should be able to again go back into Cloud­Beaver and
    enter additional records in the `health_check` table, which will be displayed
    when you refresh the web page.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在CORS更新到位后，您应该能够构建容器并重新启动Docker。希望您现在可以导航到http://localhost:3000/health.xhtml并看到一些结果。您应该能够再次进入CloudBeaver并在`health_check`表中输入额外的记录，这些记录将在您刷新网页时显示。
- en: 3.4.1 Troubleshooting our web site
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 故障排除我们的网站
- en: 'The main problem you are likely to encounter is the error that we discussed
    before—the CORS error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的主要问题是之前讨论过的错误——CORS错误：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As previously mentioned, this security-related error is easy to work around
    if you choose to just allow everything. We would caution against this approach
    as you should maintain some security. Often, your APIs may have a level of redirection
    built in as they may go through other tools such as WSO2 API Manager (which we
    discuss in chapter 4). In this case, you may want to just specify that middle
    layer in your CORS configuration. Or, you may want to limit HTTP requests. Again,
    the idea is that if you do not need it, then you should not have it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果您选择允许一切，那么这个与安全相关的错误很容易解决。但我们警告您不要采取这种方法，因为您应该保持一定的安全性。通常，您的API可能内置了一定级别的重定向，因为它们可能通过其他工具，例如WSO2
    API Manager（我们在第4章中讨论过）。在这种情况下，您可能只想在您的CORS配置中指定那层中间层。或者，您可能想限制HTTP请求。再次强调，如果不需要，那么就不应该有。
- en: An `ERR_SSL_PROTOCOL_ERROR` may occur if you are using HTTPS and the API was
    only listening on HTTP. You may see an error on your web browser console such
    as `Failed` `to` `load` `resource:` `net::ERR_SSL_PROTOCOL_ERROR`. For now, we
    are using HTTP and not HTTPS because we did not want to introduce additional complications
    with certificates. However, we will work on expanding this later in our project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您使用HTTPS并且API只监听HTTP，可能会发生`ERR_SSL_PROTOCOL_ERROR`错误。您可能在浏览器控制台看到错误，如`Failed
    to load resource: net::ERR_SSL_PROTOCOL_ERROR`。目前，我们使用HTTP而不是HTTPS，因为我们不想引入与证书相关的额外复杂性。然而，我们将在项目后期扩展这一点。'
- en: You may encounter a `404` `error` from d3.js such as `d3.v7.min.js:2` `Uncaught`
    `(in promise)` `Error:` `404 Not` `Found`. This is usually going to be a typo
    in your API endpoint. Another reason could be using the wrong HTTP method (`GET`
    when you need `POST`), although it is more common to see a `405` `Method` `Not`
    `Allowed.` We have seen some frameworks use the `404` error code as well. Other
    problems also exist, but we start exceeding the scope of this book as they start
    getting into server and network configurations. So, you will need more assistance
    if you have eliminated these basic reasons.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '您可能会遇到来自d3.js的`404`错误，例如`d3.v7.min.js:2 Uncaught (in promise) Error: 404 Not
    Found`。这通常是因为API端点有拼写错误。另一个原因可能是使用了错误的HTTP方法（当您需要`POST`时使用`GET`），尽管更常见的是看到`405
    Method Not Allowed`。我们见过一些框架也使用`404`错误代码。其他问题也存在，但当我们开始涉及服务器和网络配置时，它们开始超出本书的范围。因此，如果您排除了这些基本原因，您将需要更多的帮助。'
- en: We mention this here although it could happen at any time. If Docker is not
    running, then you may get errors building and starting your project. Seeing an
    error such as `error` `during` `connect:` `this` `error` `may` `indicate` `that`
    `the` `docker` `daemon` `is` `not running` is an obvious message that you do not
    have Docker running. However, we are likely to make that mistake at least a couple
    of times, so it is best to address it now.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提到这一点，尽管它可能随时发生。如果 Docker 没有运行，那么在构建和启动项目时可能会出现错误。看到像 `error during connect:`
    `this error may indicate that the docker daemon is not running` 这样的错误是一个明显的消息，表明您没有运行
    Docker。然而，我们可能会犯这个错误至少几次，所以最好现在就解决这个问题。
- en: 3.5 Container security
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 容器安全
- en: Hopefully, you have an idea of how cool working with containers can be. Yes,
    our application has inherited some complexity but that is a tradeoff for some
    of the benefits of using this type of architecture.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经对使用容器的工作方式有了概念。是的，我们的应用程序继承了一些复杂性，但这是为了使用这种类型架构的一些好处所做的权衡。
- en: We also inherit some security risk as part of this convenience. When we build
    a container using an image, even an official image can have risks associated with
    it. These come in the form of security vulnerabilities included in the package.
    It is important to understand these problems as they could be serious exploits
    in a version of the image or packages you are using. Some images are complex,
    and it may not be apparent what is actually included in a particular image. That
    is where tools such as Snyk and Docker Scout come into play. They can scan your
    containers and report on vulnerabilities in any of the images or included packages.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也继承了部分安全风险作为这种便利的一部分。当我们使用镜像构建容器时，即使是官方镜像也可能存在与之相关的风险。这些风险以包含在软件包中的安全漏洞的形式出现。了解这些问题很重要，因为它们可能是您使用的镜像或软件包版本中的严重漏洞。一些镜像很复杂，可能不明显知道特定镜像中实际包含的内容。这就是
    Snyk 和 Docker Scout 等工具发挥作用的地方。它们可以扫描您的容器，并报告任何镜像或包含的软件包中的漏洞。
- en: Snyk offers a command-line-scanning tool that creates an inventory of our Docker
    containers (figure 3.3). We can then use their web site to view scans and fix
    potential problems. When new problems are discovered in one of our containers,
    we will be automatically alerted so that we can begin fixing them immediately
    (if necessary).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Snyk 提供了一个命令行扫描工具，可以创建我们的 Docker 容器清单（图 3.3）。然后我们可以使用他们的网站来查看扫描结果并修复潜在问题。当我们的容器中发现了新的问题时，我们会自动收到警报，以便我们可以立即开始修复它们（如果需要的话）。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH03_F03_Kardell.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](../Images/CH03_F03_Kardell.png)'
- en: Figure 3.3  Sample results generated by Snyk
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3  Snyk 生成的示例结果
- en: Another aspect to pay attention to is port numbers used both within the containers
    and exposed to the world. We can see ports available using `docker` `ps`. When
    configuring containers, it may be helpful to allow ports to be set dynamically.
    For instance, our `api` `host` `port` could be set with `${API_PORT:-8080}:80`,
    which would allow us to default to `port` `8080` unless `API_PORT` has been defined,
    in which case that would take precedence.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的方面是容器内和暴露给世界的端口号。我们可以使用 `docker ps` 来查看可用的端口。在配置容器时，允许端口动态设置可能会有所帮助。例如，我们的
    `api host port` 可以设置为 `${API_PORT:-8080}:80`，这将允许我们默认使用端口 `8080`，除非 `API_PORT`
    已经定义，在这种情况下，它将优先使用。
- en: 'There are numerous options within Docker to help secure containers, and we
    will briefly touch on some and their application:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 中有许多选项可以帮助保护容器，我们将简要介绍一些及其应用：
- en: '`--read-only`—It marks a container as read-only, which can help limit malicious
    activity in the event of an attacker gaining access to the container.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--read-only` — 它将容器标记为只读，这有助于在攻击者访问容器时限制恶意活动。'
- en: '`--memory` and `–cpu`—There are multiple configuration options around memory
    and CPU. These can configure how many resources are available to a container from
    the host system. Preventing a container from eating up too much of a resource
    is important to the overall health of the system.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--memory` 和 `–cpu` — 在内存和 CPU 方面有多个配置选项。这些选项可以配置容器从主机系统可用的资源数量。防止容器消耗过多资源对于系统的整体健康至关重要。'
- en: '`--no-new-privileges`—It prevents the application from gaining any new privileges.
    This means Docker will prevent you from executing scripts and commands that would
    give you root privileges. The idea again is to keep malicious code and users contained.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-new-privileges`——它阻止应用程序获得任何新的权限。这意味着Docker将阻止你执行那些会给你root权限的脚本和命令。这种想法再次是为了保持恶意代码和用户的隔离。'
- en: The principles of least privilege and defense in depth
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最小权限原则和深度防御
- en: A common notion in security is known as the principle of least privilege (PoLP).
    We try to use minimal access or only the necessary permissions to complete our
    work, elevating those permissions only when necessary and then reverting to our
    original state. Ideally, even administrators or those with root access are not
    using it as their default sign-on. It is easier to grant users everything or higher
    permissions, but if their account is compromised, then the attacker has that same
    access. Perhaps, even more common is a user just making a typo or not paying attention
    to the system or directory they are in, and causing damage by removing unintended
    files. We have heard more than one story of a script being run as root that brought
    down the system. Or someone may be doing `rm *` in the wrong directory and crashing
    the system!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全领域，有一个常见的概念被称为最小权限原则（PoLP）。我们试图使用最小的访问权限或仅必要的权限来完成我们的工作，只有在必要时才提升权限，然后恢复到原始状态。理想情况下，即使是管理员或具有root访问权限的人也不应该将其作为默认的登录方式。虽然授予用户一切或更高的权限更容易，但如果他们的账户被入侵，攻击者将拥有相同的访问权限。也许更常见的是，用户只是输入了一个错误或者没有注意到他们所在的系统或目录，通过删除未预期的文件造成了损害。我们听说过不止一个脚本以root权限运行导致系统崩溃的故事。或者有人可能在错误的目录中执行`rm
    *`命令，导致系统崩溃！
- en: “Defense in depth” or “security in layers” is another security practice that
    you will be implementing, regardless of your role in an organization. It simply
    refers to the broad range of security practices put in place to protect an organization
    from physical security to network security to application security. As a developer,
    you are likely going to be involved in the application-level security. This will
    also expand into data security and access management, as you will need to encrypt
    and mask data, as well as authenticate and authorize users to the system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: “深度防御”或“分层安全”是另一种安全实践，无论你在组织中的角色如何，你都将实施。它简单指的是为了保护组织免受物理安全到网络安全再到应用安全而实施的广泛安全实践。作为开发者，你很可能会参与到应用层的安全。这也会扩展到数据安全和访问管理，因为你需要加密和隐藏数据，以及验证和授权用户访问系统。
- en: If you are part of a large organization, the managing and security of containers
    may not be your area, especially if you are working in a software developer role.
    In a smaller company, you may be wearing multiple hats, and having some knowledge
    of these concepts will be useful. In our case, we are using containers to play
    around with our development project, and we just need to understand the CliffsNotes.
    However, security is a major consideration in all organizations, and understanding
    some of the basics will not only help you be a better developer but will also
    give you a different perspective when that next annoying request comes from the
    security team. If you want to explore Docker security further, check out the OWASP
    Docker Security Cheat Sheet ([https://mng.bz/nR8K](https://mng.bz/nR8K)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你属于一个大型的组织，容器管理和安全可能不是你的领域，尤其是如果你是软件开发者角色的话。在较小的公司，你可能需要戴多顶帽子，对这些概念有一些了解将会很有用。在我们的案例中，我们使用容器来玩弄我们的开发项目，我们只需要了解CliffsNotes。然而，安全是所有组织的一个主要考虑因素，了解一些基础知识不仅可以帮助你成为一个更好的开发者，而且当安全团队提出下一个令人烦恼的要求时，也会给你提供一个不同的视角。如果你想进一步探索Docker的安全性，可以查看OWASP
    Docker安全备忘录（[https://mng.bz/nR8K](https://mng.bz/nR8K)）。
- en: 3.6 Optimizing Docker
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 优化Docker
- en: Docker is great, especially if you are a developer. There are tons of Docker
    images that you can use to explore different technologies and tools without the
    need to install them on your machine (other than with the Docker image). So, you
    no longer need to clutter up your personal machine with a bunch of software that
    you later forget about. Of course, this convenience is not without some drawbacks.
    For instance, if you have started all the Docker projects bundled with this chapter,
    you may have a lot of wasted space as Docker created containers, images, and volumes
    for each, which is why we are just going to take a little bit of a dive into managing
    and optimizing Docker.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 很棒，尤其是如果你是一名开发者。有大量的 Docker 图像可供使用，你可以探索不同的技术和工具，而无需在你的机器上安装它们（除了使用 Docker
    图像）。因此，你不再需要用一大堆你后来会忘记的软件来弄乱你的个人机器。当然，这种便利性并非没有缺点。例如，如果你已经启动了本章附带的所有 Docker 项目，你可能有大量的浪费空间，因为
    Docker 为每个项目创建了容器、图像和卷，这就是为什么我们将稍微深入一下管理和优化 Docker。
- en: So, why optimize? When we look at optimizing Docker, we are primarily speaking
    about removing unnecessary components and perhaps building them out from a different
    image. By reducing the components, we can usually achieve better security, faster
    deployment, and potentially run-time improvements. As developers, we may haphazardly
    pull in images with little regard for what they are built on. After all, we usually
    try to get to our work, but for now, let us see what things look like under the
    hood.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要优化呢？当我们谈论优化 Docker 时，我们主要是在说移除不必要的组件，也许是从不同的图像中构建它们。通过减少组件，我们通常可以实现更好的安全性、更快的部署，以及可能的运行时改进。作为开发者，我们可能随意拉取图像，而对它们基于什么构建并不关心。毕竟，我们通常试图完成我们的工作，但现在，让我们看看内部是什么样子。
- en: 3.6.1 General maintenance
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 通用维护
- en: 'First, we run the command `docker image ls`. It will show us the images and
    their sizes. Here is a sample output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们运行命令 `docker image ls`。它将显示图像及其大小。以下是一个示例输出：
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first thing you should notice is that we have a bunch of repositories with
    `<none>`. These are known as dangling images and can appear when we are building/rebuilding
    our project. We may have brought some of these on ourselves simply by working
    in our development environment and continually building our containers as we modify
    our project. Another common reason is using the `latest` tag. We had previously
    chosen to use the `latest` tag because we always wanted the latest project. Now
    we could be paying a price for that decision. In our current environment, we personally
    are not overly concerned about this, but in a production environment, where we
    had a specific project we were building, we would ensure we had tagged our project
    to a specific level.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意的第一件事是我们有一堆带有 `<none>` 的仓库。这些被称为悬挂的图像，在我们构建/重建项目时可能会出现。我们可能只是通过在开发环境中工作，并在修改项目时不断构建容器，自己引入了一些这些图像。另一个常见的原因是使用
    `latest` 标签。我们之前选择使用 `latest` 标签是因为我们总是想要最新的项目。现在，我们可能正在为那个决定付出代价。在我们的当前环境中，我们个人并不特别关心这一点，但在一个生产环境中，如果我们正在构建一个特定的项目，我们会确保我们的项目被标记到特定的级别。
- en: 'To clean up these dangling images, we can issue the following `prune` command.
    With all the prerequisite warnings about being careful when removing things, we
    issue `docker` `image` `prune` and are prompted to confirm we want to continue.
    Then, several images are removed, and we then do `docker` `image` `ls` to see
    what is left:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理这些悬挂的图像，我们可以发出以下 `prune` 命令。在所有关于谨慎删除东西的先决条件警告之后，我们发出 `docker` `image` `prune`
    并被提示确认我们想要继续。然后，删除了几个图像，我们接着执行 `docker` `image` `ls` 来查看剩下什么：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, we take a look at what is left over, and we see we have previous images
    out there that we presumably do not care about (`dockercompose6-api` and `dockercompose6-web`).
    We can confirm they are not in use by any (either running or not) containers by
    issuing `docker` `ps` `-a` `--filter ancestor=dockercompose6-api:latest`. This
    code will return the status of the container. When nothing is returned, it can
    be safely deleted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看看剩下什么，我们看到我们有一些之前的图像（`dockercompose6-api` 和 `dockercompose6-web`），我们可能并不关心。我们可以通过发出
    `docker` `ps` `-a` `--filter ancestor=dockercompose6-api:latest` 来确认它们没有被任何（无论是运行还是未运行）的容器使用。此代码将返回容器的状态。当没有返回任何内容时，它可以安全地被删除。
- en: 3.6.2 Optimizing image size
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 优化图像大小
- en: 'Now that we have done some general clean-up, it may be a little easier to review
    our images. We can start again by taking a look at the current images with `docker`
    `image` `ls`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进行了一些基本的清理，审查我们的镜像可能稍微容易一些。我们可以再次从查看当前镜像开始，使用`docker` `image` `ls`：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our biggest image is the `dockercompose7-api` image at 1.09 GB.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最大的镜像是在1.09 GB的`dockercompose7-api`镜像。
- en: One way we can reduce image size is checking whether the particular Docker image
    supports Alpine Linux. Alpine Linux is a lightweight version of Linux focusing
    on security, which makes it a good fit for use within Docker.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以减少图像大小的一种方法就是检查特定的Docker镜像是否支持阿尔卑斯Linux。阿尔卑斯Linux是Linux的一个轻量级版本，专注于安全性，这使得它非常适合在Docker中使用。
- en: Postgres went from 417 MB to 239 MB just by switching the image, and the web
    went from 187 MB to 42.6 MB. Unfortunately, we cannot simply switch to Alpine
    for our biggest container, the API layer that currently sits at 1.09 GB. This
    is because we are running `apt-get` in our Dockerfile, and this is not supported
    by Alpine since it is not based on Debian. We can take a shortcut and use the
    `slim` tag. By specifying `slim` instead of `alpine`, we do not need to change
    our Dockerfile and end up with an image that is about half the size, at 557 MB.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过切换镜像，Postgres从417 MB降至239 MB，而Web从187 MB降至42.6 MB。不幸的是，我们不能简单地切换到阿尔卑斯Linux，因为我们的最大容器，当前位于1.09
    GB的API层，不支持阿尔卑斯Linux。这是因为我们在Dockerfile中使用`apt-get`，而阿尔卑斯Linux不是基于Debian的，因此不支持它。我们可以采取捷径，使用`slim`标签。通过指定`slim`而不是`alpine`，我们不需要更改我们的Dockerfile，最终得到的镜像大小大约是557
    MB。
- en: Slim vs. alpine
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 瘦身版与阿尔卑斯版
- en: So, what exactly is the difference between the `slim` and `alpine` tags? Both
    are typically smaller than a standard image, with `alpine` images typically being
    even smaller than `slim` images.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`slim`和`alpine`标签之间究竟有什么区别？两者通常都比标准镜像小，而`alpine`镜像通常比`slim`镜像更小。
- en: As the name implies, `slim` images are minimized versions of the standard images,
    removing nonessential components such as documentation and development libraries
    but leaving the core functionality intact. Remember, these containers are specifically
    designed for running whatever you have put in them. They are not meant for people
    to be logged in and cruising around, so we do not need things such as man pages
    for documentation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`slim`镜像是最小化的标准镜像版本，移除了非必要组件，如文档和开发库，但保留了核心功能。记住，这些容器是专门为运行放入其中的内容而设计的。它们不是供人们登录并四处浏览的，所以我们不需要像手册页这样的文档。
- en: In contrast, Alpine focuses on security, and it is based on the `musl` `libc`
    library and BusyBox. These can cause problems with other software and libraries
    that you may be installing. As we saw, we had to update our Dockerfile to take
    advantage of Alpine with some minor changes. Of course, for larger projects, more
    extensive testing would be needed to ensure everything is working.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，阿尔卑斯Linux专注于安全性，它基于`musl` `libc`库和BusyBox。这些可能会与其他软件和库产生问题。正如我们所见，我们必须更新我们的Dockerfile，通过一些小的改动来利用阿尔卑斯Linux。当然，对于更大的项目，需要进行更广泛的测试以确保一切正常工作。
- en: We can look into reducing the image even further if we want to pursue using
    Alpine for the API layer. We will need to update the Dockerfile to use the Alpine
    Package Keeper (`apk`) instead of `apt-get` to install the needed packages. Your
    mileage may vary depending on your project and what exactly needs to be installed.
    In this case, removing the `RUN` `apt-get` line and replacing it with
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要追求在API层使用阿尔卑斯Linux，我们可以进一步减少镜像的大小。我们需要更新Dockerfile，使用阿尔卑斯包管理器（`apk`）而不是`apt-get`来安装所需的软件包。具体效果可能因项目不同和需要安装的具体内容而异。在这种情况下，我们需要移除`RUN`
    `apt-get`行，并用以下内容替换：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: allowed us to successfully get the project up and running again. This reduced
    the image size for another 200 MB, bringing it down from 557 MB to 344 MB—quite
    a difference from the original 1GB!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们能够成功地将项目重新启动并运行。这减少了图像大小200 MB，从557 MB降至344 MB——与原始的1GB相比，差距相当大！
- en: Choosing a smaller base image in your Dockerfile is one of the most straightforward
    ways of reducing the image size. One of the mantras of development is “Make it
    work, make it right, make it fast.” That approach works for containers as well.
    There are benefits of smaller image size, but you do not need to worry about that
    right at the beginning of your project. When working with a big company, there
    will likely be a whole team that takes care of this for you, so you may not have
    a lot of flexibility when it comes to building and running containers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dockerfile 中选择较小的基础镜像是减少镜像大小最直接的方法之一。开发中的一个格言是“让它工作，让它正确，让它快速。”这种方法也适用于容器。较小的镜像大小有一些好处，但在项目开始时你不需要担心这一点。当与一个大公司合作时，可能有一个整个团队会为你处理这些事情，所以你在构建和运行容器时可能没有太多灵活性。
- en: 3.6.3 Optimizing build time
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.3 优化构建时间
- en: A task that can go hand in hand with optimizing image size is also working on
    the actual build time. Several tools are available for analyzing Docker images.
    Two popular tools are Docker Scout and dive, which is a command-line tool. Let
    us look at running the Docker Scout utility because it is readily available within
    Docker Desktop. This discussion also provides a good introduction to some of the
    metrics and terms that get thrown around when using Docker. Figure 3.4 shows the
    results of analyzing our API image. This screen is from the personal (free) tier
    of using Docker and Docker Scout. More features are available for the paid tiers
    ([https://www.docker.com/pricing/](https://www.docker.com/pricing/)).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与优化镜像大小可以并行进行的一项任务也是实际构建时间。有几种工具可用于分析 Docker 镜像。其中两个流行的工具是 Docker Scout 和 dive，这是一个命令行工具。让我们看看如何运行
    Docker Scout 实用工具，因为它在 Docker Desktop 中很容易获得。这次讨论也提供了使用 Docker 时经常提到的某些指标和术语的良好介绍。图
    3.4 展示了分析我们的 API 镜像的结果。这个屏幕来自使用 Docker 和 Docker Scout 的个人（免费）级别。付费级别提供了更多功能（[https://www.docker.com/pricing/](https://www.docker.com/pricing/))。
- en: The layers are what we are primarily interested in when considering ways to
    optimize the build. In a Dockerfile, the order of instructions matters, and each
    instruction translates into a layer, although there is not always a one-to-one
    correspondence. We can see the size of each layer and the command being executed.
    We can also see how the filesystem is affected by each of the commands.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑优化构建的方法时，我们主要关注层。在 Dockerfile 中，指令的顺序很重要，每条指令都转换为一个层，尽管并不总是存在一对一的对应关系。我们可以看到每个层的尺寸和正在执行的命令。我们还可以看到每个命令如何影响文件系统。
- en: One way to optimize the builds is to ensure we are managing the layers appropriately.
    Layers should be kept to a minimum, and any adding/removing of files should happen
    in the same layer. For instance, a command that may download temporary files should
    also be cleaned up.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 优化构建的一种方法是通过确保我们适当地管理层。层应保持最小化，任何添加/删除文件的操作都应在同一层中完成。例如，可能下载临时文件的命令也应该被清理。
- en: We also mentioned that the order of instructions in a Dockerfile matters because
    Docker uses a caching mechanism to determine if a command needs to be rerun. Therefore,
    items that change frequently, such as your application code, are usually near
    the bottom of the instructions, while less frequent changes or changes that may
    cause a large download are executed near the top. Doing this in reverse order
    is known as
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到，Dockerfile 中指令的顺序很重要，因为 Docker 使用缓存机制来确定是否需要重新运行命令。因此，经常变化的项目，如你的应用程序代码，通常位于指令的底部，而较少变化或可能引起大量下载的变化则执行在顶部。以相反的顺序做这件事被称为
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH03_F04_Kardell.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](../Images/CH03_F04_Kardell.png)'
- en: Figure 3.4  Analysis with Docker Scout
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.4  Docker Scout 分析
- en: cache busting because it breaks Docker’s cache mechanism and can cause Docker
    to rebuild the entire image every time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存失效，因为它破坏了 Docker 的缓存机制，并可能导致 Docker 在每次都重建整个镜像。
- en: Docker squash is another tool that can help with removing layers and other unused
    files. A few different versions of this utility and also an experimental command
    within Docker itself for this functionality can be found on the internet.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Docker squash 是另一个可以帮助移除层和其他未使用文件的工具。在互联网上可以找到这个实用工具的几个不同版本，以及 Docker 本身为了这个功能提供的实验性命令。
- en: 'There is also a `.`dockerignore file that functions similar to a .gitignore
    file (if you are familiar with Git). Otherwise, the concept is simple: we can
    put files or directories into these ignore files, and Docker will ignore them.
    So, maybe unnecessary configuration files from your IDE, other application related
    information, and documentation such as READMEs are all good candidates for these
    files.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`.dockerignore`文件，其功能类似于`.gitignore`文件（如果你熟悉Git）。否则，概念很简单：我们可以将这些文件或目录放入这些忽略文件中，Docker将忽略它们。所以，也许你的IDE中的不必要配置文件、其他与应用程序相关的信息以及如READMEs之类的文档都是这些文件的良好候选者。
- en: Finally, general application maintenance can go a long way, ensuring that dependencies
    are up to date and that you have minimized CSS, JavaScript, and so forth to keep
    the images small.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一般的应用程序维护可以走得很远，确保依赖项是最新的，并且你已经最小化了CSS、JavaScript等，以保持图像大小。
- en: 3.7 Removing the hardcoded username/password
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 移除硬编码的用户名/密码
- en: Now that we have covered some of the maintenance aspects of working with Docker
    and Docker images, let us take our advice from earlier and work with the application.
    One thing that we had to do was specify a username and password for the PostgreSQL
    instance (remember the `POSTGRES_USER` and `POSTGRES_PASSWORD` from our docker
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了与Docker和Docker镜像一起工作的某些维护方面，让我们借鉴我们之前的建议，并处理应用程序。我们必须做的一件事是为PostgreSQL实例指定用户名和密码（记得docker中的`POSTGRES_USER`和`POSTGRES_PASSWORD`）。
- en: -compose file).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: -compose文件）。
- en: We were able to do this with environment variables; however, when it came to
    the API container, we hardcoded the values, and that is something we always want
    to avoid if possible.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够通过环境变量做到这一点；然而，当涉及到API容器时，我们硬编码了值，这是我们总是想尽量避免的事情。
- en: Avoid magic numbers and hardcoded values
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 避免使用魔法数字和硬编码的值
- en: Magic numbers have unexplained meanings, such as when we define a log level
    of 1, 2, 3, 4, or 5\. Which one is the highest severity? What does it mean to
    have a log level of 1 versus a log level of 4? That is an example of a magic number.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法数字具有未解释的含义，例如当我们定义日志级别为1、2、3、4或5时。哪一个是最高的严重性？1级日志级别与4级日志级别有什么区别？这就是一个魔法数字的例子。
- en: We consider hardcoded values to be a superset of magic numbers as they come
    with a similar set of problems. Any time we start using hardcoded values such
    as usernames/passwords, ports, servers, and similar, it poses a problem. Not only
    can it be a security concern to have them stored insecurely in source control
    but can also pose a maintenance nightmare when they are sprinkled throughout the
    code, and your server moves after 10 years. Finding all those places and testing
    that everything was changed correctly can be a real pain.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为硬编码的值是魔法数字的超集，因为它们带来了类似的一系列问题。任何开始使用硬编码值，如用户名/密码、端口、服务器等的情况，都会引发问题。这不仅可能因为它们在源代码控制中不安全地存储而成为安全问题，而且当它们散布在代码中，而服务器在10年后移动时，也可能成为维护的噩梦。找到所有这些地方并测试是否正确更改了一切可能真的非常痛苦。
- en: Even though we have yet to examine the application, we will practice good habits
    by removing our hardcoded values.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尚未检查应用程序，但我们将通过移除硬编码的值来培养良好的习惯。
- en: Luckily, Docker comes with a way for us to make use of environment variables
    by applying an `env_file` directive that specifies an environment file. As a bonus,
    we can refer to the `gitignore` command to prevent this file from being uploaded
    to source control. Or maybe there is another layer of redirection where the more
    sensitive information (the database credentials) is referenced and stored somewhere
    else. If you are not storing the environment variables in source control, be sure
    that they are well documented somewhere so that new instances, or new employees,
    know how to set them up. Often, we have found ourselves having someone email us
    random configuration files because nobody is sure how to set up the system and
    what exactly is still needed!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker提供了一种方法，我们可以通过应用一个`env_file`指令来利用环境变量，该指令指定了一个环境文件。作为额外的好处，我们可以引用`gitignore`命令来防止此文件被上传到源代码控制。或者可能还有另一层重定向，其中更敏感的信息（数据库凭证）被引用并存储在别处。如果你不在源代码控制中存储环境变量，确保它们在某处有良好的文档，以便新实例或新员工知道如何设置它们。我们经常发现自己有人通过电子邮件发送随机的配置文件，因为没有人确定如何设置系统以及确切还需要什么！
- en: The first order of business is to create a file to hold our environment variables.
    We will need to create a file named `.`sql_server.conf. The actual name of the
    file is not important but should be something meaningful. The leading period (.)
    will often cause the operating system to hide the file and an extension “conf”
    is a standard for configuration files. Another common naming standard is to use
    .env. We often see .env files being used in companies, especially when there are
    source control tools such as Git, which are usually set to ignore .env files.
    Another example form the Docker documentation available at [https://mng.bz/vK5M](https://mng.bz/vK5M)
    shows the use of an environment file named webapp.env when defining their webapp
    service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是创建一个文件来存放我们的环境变量。我们需要创建一个名为 `.sql_server.conf` 的文件。文件的实际名称并不重要，但应该是有意义的。前导点（.）通常会导致操作系统隐藏文件，而“conf”扩展名是配置文件的行业标准。另一个常见的命名标准是使用
    .env。我们经常在公司看到使用 .env 文件，尤其是在有源代码控制工具如 Git 的环境中，这些工具通常被设置为忽略 .env 文件。Docker 文档中的一个例子，可在
    [https://mng.bz/vK5M](https://mng.bz/vK5M) 找到，展示了在定义他们的 webapp 服务时使用名为 webapp.env
    的环境文件。
- en: The main thing to remember is that the naming of the file is flexible, and neither
    a specific name nor leading period are required for them to work. However, we
    are simply establishing a convention, and that may be slightly different from
    the standards and conventions in place at other companies (remember the saying,
    “When in Rome . . .”).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的主要事项是文件的命名是灵活的，文件能够正常工作并不需要特定的名称或前导点。然而，我们只是在建立一个约定，这可能与其他公司现有的标准和约定略有不同（记住那句俗语，“入乡随俗……”）。
- en: With the file created, we will move our hardcoded username and password denoted
    by `POSTGRES_USER` and `POSTGRESS_PASSWORD`, respectively, ending with a file
    that contains
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 文件创建后，我们将把用硬编码的 `POSTGRES_USER` 和 `POSTGRESS_PASSWORD` 表示的用户名和密码移动到文件中，分别以 `POSTGRES_USER`
    和 `POSTGRESS_PASSWORD` 结尾
- en: '[PRE17]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will also need to update the `docker-compose.yml` to make use of this newly
    created file. Note that we removed environment and replaced it with `env_file`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新 `docker-compose.yml` 文件以使用这个新创建的文件。请注意，我们移除了环境变量，并用 `env_file` 代替：
- en: '[PRE18]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we also made a change to the API container to employ the same `.sql_server.conf`
    in the `env_file` directive. Before going further, we should build and bring our
    containers up to ensure that everything is still working. Finally, we will need
    to update our API container to also pull in these variables. We import the `os`
    module and then use `getenv` to retrieve the environment variables that were set
    in our .sql_server.conf file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也对 API 容器进行了更改，在 `env_file` 指令中使用了相同的 `.sql_server.conf`。在继续之前，我们应该构建并启动我们的容器以确保一切仍然正常工作。最后，我们还需要更新我们的
    API 容器以也引入这些变量。我们导入 `os` 模块，然后使用 `getenv` 来检索在 .sql_server.conf 文件中设置的环境变量：
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With those changes, we can remove, build, and bring up the containers to test.
    You may also want to change the values in the environment to ensure that the changes
    are indeed working. In addition, do not forget to sign into CloudBeaver to ensure
    that is working as well.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改后，我们可以移除、构建并启动容器进行测试。你可能还想要更改环境中的值，以确保更改确实生效。此外，别忘了登录 CloudBeaver，以确保它也能正常工作。
- en: The `os.getenv` command also allows you to specify a default value if the `environment`
    variable is not found. So, we could have used `os.getenv("POSTGRES_USER",` `"postgres"),`
    but we stayed away from a default value in this example because we wanted to ensure
    that our containers would not work accidentally if we had set something up incorrectly
    (because the Postgres user was still valid somehow). Your use cases will vary,
    so just keep that functionality in mind.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.getenv` 命令还允许你在找不到环境变量时指定一个默认值。因此，我们可以使用 `os.getenv("POSTGRES_USER", "postgres")`，但在本例中我们避免了默认值，因为我们想确保如果设置有误（因为
    Postgres 用户仍然以某种方式有效），我们的容器不会意外地工作。你的用例可能会有所不同，所以只需记住这个功能即可。'
- en: We also updated the `DATABASE_URL`. Substituting the `POSTGRES_USER` for both
    the `dbname` and `user` in the connection string. This is just a convention in
    the PostgreSQL database. The `dbname` and `user` are independent of each other,
    but we kept our SQL script straightforward, so the table was created under the
    same username. You will also notice that the connection string contains hardcoded
    values for the host and port. We are leaving it up to you whether you would like
    to replace those with an environment value that will not hurt anything and may
    also be an opportunity for you to try out the default value in the `os.getenv`
    mentioned earlier.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了`DATABASE_URL`。在连接字符串中将`POSTGRES_USER`替换为`dbname`和`user`。这只是PostgreSQL数据库中的一个约定。`dbname`和`user`是相互独立的，但我们保持了我们的SQL脚本简单，因此表是在相同的用户名下创建的。你也会注意到连接字符串中包含了硬编码的主机和端口值。我们将是否用环境变量替换这些值留给你决定，这样做不会影响任何东西，也许也是你尝试之前提到的`os.getenv`中默认值的机会。
- en: 3.8 Health checks
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 健康检查
- en: In our sample, we built out a simple health check endpoint. This endpoint is
    something that applications could use to get a status of the system or application.
    It can be as fine-grained as you want, checking not just the services that it
    may be running but also potential problems connecting to other services.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们构建了一个简单的健康检查端点。这个端点是应用程序可以用来获取系统或应用程序状态的东西。它可以细粒度到你想的程度，不仅检查可能正在运行的服务，还包括连接到其他服务的潜在问题。
- en: Here we would like to take a moment to look at health checks from a purely Docker
    perspective as opposed to what may be done at the application level. These health
    checks can be used to determine whether the container is running correctly (or
    healthy). Containers can be in multiple statuses such as starting, healthy, or
    unhealthy, and the importance of knowing the state of a container is one of the
    benefits of using containers. Unhealthy containers will adversely affect your
    system and could be the result of bad application code, networking problems, or
    perhaps a bad update in one of the components being used in the container. Docker
    and Docker Compose can automatically restart containers in an attempt to resolve
    potential problems, or you may build a more robust logging and notification system
    to monitor your containers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想花一点时间从纯粹Docker的角度来看健康检查，而不是在应用层面可能做的事情。这些健康检查可以用来确定容器是否正在正确运行（或健康）。容器可以处于多种状态，如启动、健康或不健康，了解容器状态的重要性是使用容器的好处之一。不健康的容器会对你系统产生不利影响，可能是糟糕的应用程序代码、网络问题，或者可能是容器中使用的某个组件的更新有问题。Docker和Docker
    Compose可以自动重启容器以尝试解决潜在问题，或者你可能构建一个更健壮的日志和通知系统来监控你的容器。
- en: We can determine the health of our containers using the `docker` `ps` command.
    You can run the command now; however, unless the image you are using includes
    a health check, you will not see starting/healthy/unhealthy next to the status;
    you will only see the up time. To save space, we will format the output of the
    `docker ps` command with the `format` argument. Running `docker` `ps` `--format`
    `'{{.Names}}` `-` `{{.Status}}'` from the command line shows
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker ps`命令确定我们容器的健康状况。你现在可以运行这个命令；然而，除非你使用的镜像包含健康检查，否则你不会在状态旁边看到启动/健康/不健康；你只会看到运行时间。为了节省空间，我们将使用`format`参数格式化`docker
    ps`命令的输出。从命令行运行`docker ps --format `'{{.Names}}' `- `{{.Status}}'``会显示
- en: '[PRE20]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, let’s add a health check for the Postgres container. We will update the
    Dockerfile with
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为Postgres容器添加一个健康检查。我们将更新Dockerfile，如下
- en: '[PRE21]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that the command takes several parameters and that the actual work is
    done by the `CMD`. The `pg_isready` is a Postgres command that confirms the database
    is up and running. It requires a user, so we are referencing the `environment`
    variable we defined.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到该命令有几个参数，实际工作是由`CMD`完成的。`pg_isready`是Postgres命令，用于确认数据库正在运行。它需要一个用户，所以我们引用了我们定义的环境变量。
- en: If we rebuild following the usual procedure of removing the containers, rebuilding,
    and bringing them back up, then running that `docker ps` command gives us
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照常规程序移除容器、重建并重新启动它们，然后运行那个`docker ps`命令，我们会得到
- en: '[PRE22]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see that the Postgres container now shows as healthy. Including health
    checks helps us prepare our containers for a production environment where a container
    orchestration tool such as Docker Swarm or Kubernetes will enable our containers
    to be self-healing, meaning that the containers will be able to be restarted or
    replaced if they fail these checks. That is a bit beyond the scope of this book
    though. For the time being, keep in mind the power that health checks provide
    and the potential difference between a health check at the application level versus
    health checks from the Docker perspective.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Postgres容器现在显示为健康状态。包括健康检查有助于我们为生产环境做准备，在这种环境中，容器编排工具如Docker Swarm或Kubernetes将使我们的容器能够自我修复，这意味着如果容器在这些检查失败时，它们将能够重新启动或替换。但这超出了本书的范围。目前，请记住健康检查提供的力量以及与应用程序级别健康检查相比从Docker视角进行健康检查的潜在差异。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Docker and Docker Compose can manage our environment. By building out small
    pieces of a project into separate containers, we can start expanding each component
    of our project independently.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker和Docker Compose可以管理我们的环境。通过将项目的小部分构建成独立的容器，我们可以独立扩展项目的每个组件。
- en: Evaluating team experience, project size, and risk factors is vital when determining
    the best approach to a project.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在确定项目最佳方法时，评估团队经验、项目规模和风险因素至关重要。
- en: Generative AI tools can increase productivity but have limitations and require
    verification.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成式AI工具可以提高生产力，但存在局限性并需要验证。
- en: Docker creates isolated environments for efficiently managing multiple services
    and technologies.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker为高效管理多个服务和技术创建了隔离环境。
- en: Transitioning to microservices should be based on need, not trend, as monolithic
    architectures can still be effective.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向微服务架构的过渡应基于需求，而非趋势，因为单体架构仍然可能有效。
- en: Dividing a project into manageable components and ensuring initial connectivity
    is crucial for effective development.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目划分为可管理的组件并确保初始连通性对于有效开发至关重要。
- en: Health checks in containers provide system status monitoring and enable self-healing
    in production environments.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器中的健康检查提供系统状态监控并使生产环境中的自我修复成为可能。
- en: Security and efficient management are achieved by applying the principle of
    least privilege and using vulnerability scanning tools.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用最小权限原则和使用漏洞扫描工具实现安全和高效的管理。
- en: Container optimization is important in reducing image size and build time.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器优化对于减少镜像大小和构建时间很重要。
- en: Environment variables should be used to avoid hardcoding sensitive information
    such as usernames and passwords.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应使用环境变量来避免硬编码敏感信息，如用户名和密码。
- en: Adhering to best practices in storage, application optimization, and dependency
    management enhances Docker’s effectiveness.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循存储、应用优化和依赖管理方面的最佳实践可以增强Docker的有效性。
