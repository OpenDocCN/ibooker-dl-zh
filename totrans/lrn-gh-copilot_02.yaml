- en: Chapter 1\. Foundations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 基础
- en: Welcome to *Learning GitHub Copilot*! I’m excited you’re reading this book and
    hope you find it useful. AI tools like ChatGPT and AI agents have changed, and
    will continue to change, how we interact with software applications. GitHub Copilot
    and similar tools have changed, and will continue to change, how programmers create
    software applications. Through its ability to take context from existing code
    or natural language prompts, GitHub Copilot provides a richer and more powerful
    code-generation capability than any we’ve seen before.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 *学习 GitHub Copilot*！我很高兴你正在阅读这本书，希望它能对你有所帮助。像 ChatGPT 和 AI 代理这样的 AI 工具已经改变了，并将继续改变我们与软件应用程序的交互方式。GitHub
    Copilot 和类似工具已经改变了，并将继续改变程序员创建软件应用程序的方式。通过从现有代码或自然语言提示中提取上下文的能力，GitHub Copilot
    提供了比我们之前所见任何都更丰富、更强大的代码生成能力。
- en: In this book, I’ll help you understand how to use GitHub Copilot’s capabilities—from
    performing code generation and completion, forming tests, and translating and
    explaining code, to working with repositories, pull requests, and issues directly
    in GitHub. You’ll see examples of using Copilot across multiple domains and programming
    languages. You’ll learn to leverage it to your advantage and craft prompts to
    get the best results. You’ll even learn how to add your own custom functionality
    to it. And you’ll understand how it does what it does, including why it sometimes
    doesn’t provide the results you expect—and how to mitigate those situations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将帮助你了解如何使用 GitHub Copilot 的功能——从执行代码生成和补全、形成测试、翻译和解释代码，到直接在 GitHub 中处理仓库、拉取请求和问题。你将看到跨多个领域和编程语言使用
    Copilot 的示例。你将学会如何利用它并构建提示以获得最佳结果。你甚至将学习如何向其中添加自己的自定义功能。你还将了解它是如何工作的，包括为什么它有时不会提供你预期的结果——以及如何减轻这些情况。
- en: Some foundational knowledge is required to begin with, though. That’s the purpose
    of this chapter. I’ll start by explaining GitHub Copilot at a high level. We’ll
    then explore the key underlying technology, its overall flow, some usage considerations,
    how it differs from tools like ChatGPT, and what you need to know about getting
    and installing it. So, let’s get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前需要一些基础知识。这就是本章的目的。我将首先从高层次上解释 GitHub Copilot。然后我们将探讨关键的基础技术、整体流程、一些使用注意事项、它与像
    ChatGPT 这样的工具的不同之处，以及你需要了解的获取和安装它的信息。那么，让我们开始吧。
- en: Copilot Catchall
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copilot 概括
- en: As we begin this discussion, be aware that *copilot* is a popular term for AI
    applications that collect information, formulate prompts, and return answers and
    suggestions. For example, Microsoft has an [Office 365 Copilot](https://oreil.ly/DaSLT)
    that does this for Microsoft Office applications. It analyzes context from Word,
    Teams, Outlook, etc., and provides summarizations, suggested responses, and other
    valuable interactions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这次讨论之前，请注意，“copilot”是用于指代收集信息、形成提示并返回答案和建议的 AI 应用程序的流行术语。例如，微软有一个 [Office
    365 Copilot](https://oreil.ly/DaSLT)，它为微软 Office 应用程序执行此操作。它分析来自 Word、Teams、Outlook
    等的上下文，并提供总结、建议回复和其他有价值的交互。
- en: In this book, I use *Copilot* to mean *GitHub Copilot*. The only exceptions
    will occur when I am referring to another system that uses the same word. In those
    cases, I’ll explicitly identify them with their formal names, such as *Office
    365 Copilot*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我使用 *Copilot* 来指代 *GitHub Copilot*。只有在我提到使用相同单词的另一个系统时，才会有例外。在这种情况下，我会明确地用它们的正式名称来标识它们，例如
    *Office 365 Copilot*。
- en: What Is GitHub Copilot?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 GitHub Copilot？
- en: GitHub Copilot is a cloud-based, generative artificial intelligence (AI) tool.
    Let’s break down these buzzwords. We can generically define AI as *computers doing
    tasks that previously only humans were thought to be able to accomplish because
    of required reasoning and skills*. More recently, this has also taken on the aspect
    of interacting with humans in a natural and human-like way through natural language
    processing (NLP), chat interfaces, and automated processing and decision making
    with AI agents.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot 是一个基于云的生成式人工智能（AI）工具。让我们来分解这些术语。我们可以泛泛地定义 AI 为 *计算机执行那些以前认为只有人类才能完成的任务，因为这些任务需要推理和技能*。最近，这还包含了通过自然语言处理（NLP）、聊天界面以及
    AI 代理的自动处理和决策来以自然和人类似的方式与人类互动的方面。
- en: '*Cloud-based* refers to the pathway through which Copilot returns suggestions
    and generates answers. It refers to a cloud environment managed by GitHub that
    facilitates interaction with the AI models. *Generative* expresses the AI’s ability
    to *generate* new results from the context it takes in. Copilot can offer responses
    and suggestions for software development based on the context and prompts from
    the user’s environment. How well it does this depends on several factors that
    we’ll talk about in the next section. But, as a quick example, [Figure 1-1](#using-copilot-on-a-pr)
    shows using Copilot to suggest optimizations based on a project in Visual Studio
    (VS) Code.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于云的* 指的是 Copilot 返回建议和生成答案的路径。它指的是由 GitHub 管理的云环境，该环境便于与 AI 模型交互。*生成性* 表达了
    AI 从其接收到的上下文中生成新结果的能力。Copilot 可以根据用户环境的上下文和提示为软件开发提供回应和建议。它在这方面做得如何取决于我们将在下一节讨论的几个因素。但作为一个快速示例，[图
    1-1](#using-copilot-on-a-pr) 展示了如何使用 Copilot 基于在 Visual Studio (VS) Code 中的项目来提出优化建议。'
- en: '![](assets/lghc_0101.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0101.png)'
- en: Figure 1-1\. Using Copilot on a project in VS Code
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 在 VS Code 中的项目上使用 Copilot
- en: Default IDE
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认 IDE
- en: Because it’s not possible to represent all integrated development environments
    (IDEs) in this book, we’ll be using VS Code or GitHub Codespace in our examples
    where an IDE is involved. If you use a different IDE, please consult the Copilot
    documentation for any differences in use, controls, etc.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中无法表示所有集成开发环境 (IDE)，在我们的示例中，如果涉及到 IDE，我们将使用 VS Code 或 GitHub Codespace。如果您使用不同的
    IDE，请查阅 Copilot 文档以了解使用、控制等方面的任何差异。
- en: How Does Copilot Work?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copilot 的工作原理是怎样的？
- en: To understand how Copilot works, we need to understand some of the pieces that
    underpin its functionality and that of similar AI tools. These details include
    where it gets information to base responses on and its overall flow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Copilot 的工作原理，我们需要了解支撑其功能以及类似 AI 工具的一些基础组件。这些细节包括它从哪里获取信息来基于这些信息做出回应，以及其整体流程。
- en: Copilot and most AI applications get their data from large language models (LLMs)
    trained on extensive data collections. If you’re unfamiliar with term LLM, the
    following section provides a brief explanation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 和大多数 AI 应用程序从在大量数据集上训练的大型语言模型 (LLMs) 获取数据。如果您对 LLM 这个术语不熟悉，以下部分提供了一个简要的解释。
- en: Large Language Models
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大型语言模型
- en: It’s challenging to discuss AI tooling today without mentioning LLMs. LLMs are
    AI models trained on vast amounts of existing data to predict the next words or
    other types of content (e.g., *tokens*) that *fit* given some input (a *prompt*).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天讨论 AI 工具时，不提及大型语言模型 (LLMs) 是有挑战性的。LLMs 是在大量现有数据上训练的 AI 模型，用于预测给定一些输入（一个*提示*）的下一个单词或其他类型的内容（例如，*标记*）。这些内容与输入相匹配。
- en: LLMs differ from traditional computer models that can process formatted data
    or respond to a math problem because LLMs are taught to understand context, syntax,
    and structure. This is done by algorithms that consider vast numbers of parameters
    to figure out what words or tokens make the most sense to come next. In this way,
    the models statistically craft responses based on how the input is presented,
    not just the input itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: LLMs 与可以处理格式化数据或响应数学问题的传统计算机模型不同，因为 LLMs 是被训练来理解上下文、语法和结构的。这是通过考虑大量参数的算法来完成的，以确定哪些单词或标记最有可能接下来出现。以这种方式，模型根据输入的呈现方式而不是输入本身来统计性地构建回应。
- en: The model’s prediction capabilities are learned and tuned from extensive collections
    of existing content. In this training process, the models map how the various
    pieces of information relate in any given domain. Technically, given a sequence
    of tokens as a query, LLMs can assess the input’s syntax and structure, infer
    context based on the model’s training data, and predict the sequence of tokens
    that would likely come next. Simply put, LLMs can figure out what would sound
    right based on all the data they’ve digested and continue the conversation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的预测能力是通过从大量现有内容中学习并调整得来的。在这个训练过程中，模型映射了任何给定领域中的各种信息之间的关系。技术上讲，给定一个作为查询的标记序列，LLMs
    可以评估输入的语法和结构，根据模型的训练数据推断上下文，并预测可能接下来出现的标记序列。简单来说，LLMs 可以根据他们所消化的所有数据推断出什么听起来是正确的，并继续对话。
- en: To appreciate the difference from traditional processing, think of learning
    a language and then conversing with someone who speaks it as a first language.
    You can learn the vocabulary and individual words and phrases. But in a conversation
    with someone who speaks this language well, you also need to gather and understand
    the context of what the other person is saying. This is so you can choose the
    right words or phrases to respond with. You also need to be able to frame your
    response in a context that will make sense to the other person. Language has syntax
    and structure, but the context of a conversation is how we ensure that syntax
    and structure make sense and convey meaning. LLMs can assess context from the
    inputs and supply relevant context in their outputs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解与传统处理方式的区别，可以想象学习一门语言并与说这门语言作为母语的人进行对话。你可以学习词汇和单个单词及短语。但在与说这种语言的人的对话中，你还需要收集和理解对方说话的上下文。这样你才能选择合适的单词或短语来回应。你还需要能够在一个能让对方理解上下文中构建你的回应。语言有语法和结构，但对话的上下文是我们确保语法和结构有意义并传达意义的方式。大型语言模型可以从输入中评估上下文，并在其输出中提供相关的上下文。
- en: Turning back to Copilot, it uses, by default, LLMs developed and managed by
    [OpenAI](https://openai.com), the same company behind [ChatGPT](https://chat.openai.com).
    In conjunction with OpenAI, GitHub developed Copilot over several years. Recently,
    they have added options to use several other families of models, including ones
    from Claude by Anthropic and Google Gemini. Across models, the common characteristic
    of Copilot is the focus on creating software, and its conversational language
    is code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Copilot，它默认使用由[OpenAI](https://openai.com)开发和管理的LLM，该公司也是[ChatGPT](https://chat.openai.com)背后的公司。与OpenAI合作，GitHub在过去的几年里开发了Copilot。最近，他们增加了使用其他几个模型系列的选择，包括来自Anthropic的Claude和Google的Gemini。在各个模型中，Copilot的共同特点是专注于创建软件，其对话语言是代码。
- en: Code and Generative AI
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码和生成式AI
- en: 'Programming languages, by definition, have specific, required syntax and semantics
    that differ for each language. When coding in Python versus Go, you use different
    tokens and structures to create the program. However, the tokens and structure
    you use have rules. They are well-defined and form a closed set. Copilot’s abilities
    are targeted to provide coding suggestions and related information that match
    syntax and structure. But the real value-add is providing responses that are relevant
    to what the coder is creating or prompting about. The context that gets fed into
    Copilot can come from several sources, including these:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，编程语言具有特定、必需的语法和语义，每种语言都不同。在Python和Go之间编码时，你使用不同的标记和结构来创建程序。然而，你使用的标记和结构都有规则。它们是明确定义的，并形成一个封闭集。Copilot的能力旨在提供与语法和结构相匹配的编码建议和相关信息。但真正的增值在于提供与编码者正在创建或提示的内容相关的回应。输入到Copilot中的上下文可以来自多个来源，包括以下这些：
- en: A set of code being written in an editor in a development environment
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发环境中编辑器中编写的代码集
- en: Interactions with the model via direct natural language prompts or queries,
    aka *chat models*
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过直接的自然语言提示或查询与模型交互，也就是所谓的*聊天模型*
- en: Typical development activities in GitHub itself, such as pull requests
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub本身中的典型开发活动，例如拉取请求
- en: I’ll discuss these interactions more throughout the book. But regardless of
    the interface, the context (code, directives/input, or GitHub elements you work
    with) gets turned into a *prompt*—your side of the conversation that you expect
    the AI to respond to. Processing those and deciding on a response based on context
    and the model’s training and capabilities is the *generative* part of Copilot’s
    *generative AI* functionality. The response can be suggested code, an answer to
    a question, or step-by-step directions. It is what the AI thinks completes the
    code, satisfies the prompt, or answers the query.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本书的后续部分更详细地讨论这些交互。但无论接口如何，上下文（代码、指令/输入或你工作的GitHub元素）都会被转换成*提示*——你期望AI回应的对话的一部分。处理这些提示并根据上下文以及模型训练和能力来决定回应是Copilot的*生成式AI*功能中的*生成*部分。回应可以是建议的代码、对问题的回答或逐步指示。这是AI认为可以完成代码、满足提示或回答查询的内容。
- en: You can think of this process like describing a set of symptoms to a doctor
    over a Zoom call so they can try to reach a diagnosis based on their years of
    training. Or describing to the car mechanic over the phone an issue that you are
    seeing with your vehicle so that they can suggest a fix. In these cases, the communication
    and context you provide, with the professional’s training, make all the difference.
    The interaction can result in suggestions to address the issue (some of which
    may not apply) or indicate that the professional didn’t have enough context or
    understanding to help. Generative AI behaves the same way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个过程想象成在Zoom通话中向医生描述一系列症状，以便他们可以根据多年的培训尝试做出诊断。或者，你可以向汽车修理工打电话描述你在车辆上看到的问题，以便他们可以提出解决方案。在这些情况下，你提供的沟通和上下文，加上专业人士的培训，对结果至关重要。这种交互可能导致提出解决问题的建议（其中一些可能不适用），或者表明专业人士没有足够的上下文或理解来提供帮助。生成式AI的行为方式相同。
- en: When Copilot offers suggestions as you’re coding, items in your coding environment
    provide the context to create a prompt for the AI model. Copilot can produce suggestions
    that follow the coding style used in the files that are part of the project you’re
    working on. This can be both good and bad.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当Copilot在你编码时提供建议时，你的编码环境中的项目提供了上下文，为AI模型创建一个提示。Copilot可以产生遵循你正在工作的项目中的文件所使用的编码风格的建议。这既有好的一面，也有不好的一面。
- en: It can be good that Copilot’s suggestions are often similar to the users’ existing
    coding styles if those coding styles reflect best practices. It can be bad if
    Copilot sometimes skews too much towards bad practices in existing code. The latter
    situation can lead to reinforcing limited and inefficient coding practices—or
    you may have to wade through a more extensive set of suggestions to find the one
    that fits. The quality and quantity of the examples that Copilot has to draw on
    from your environment, and its own training, can affect its responses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Copilot的建议通常与用户的现有编码风格相似，并且这些编码风格反映了最佳实践，那么这可能是好的。如果Copilot有时过于偏向现有代码中的不良实践，那么这可能是坏的。后一种情况可能导致强化有限和低效的编码实践，或者你可能需要浏览更广泛的建议集来找到适合的建议。Copilot从你的环境和自己的训练中可以借鉴的示例的质量和数量会影响其响应。
- en: Ultimately, the generative AI employed with Copilot can be very useful. Still,
    be aware that the coding suggestions will be biased by the context and training
    Copilot has to work with. You can use this to your advantage to provide Copilot
    with more examples of the style of suggestions it should return. However, this
    bias can also be a disadvantage if the context that Copilot has to work with is
    limited. We’ll discuss how to help Copilot return the best results throughout
    the book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，与Copilot一起使用的生成式AI可以非常有用。然而，请注意，编码建议将受到上下文和Copilot必须与之一起工作的训练的影响。你可以利用这一点，为Copilot提供更多它应该返回的建议风格的示例。然而，如果Copilot必须与之一起工作的上下文有限，这种偏差也可能是一个缺点。我们将在整本书中讨论如何帮助Copilot返回最佳结果。
- en: Let’s briefly look at Copilot’s high-level flow to understand more about how
    it interacts with context to respond to you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看Copilot的高层次流程，以了解它是如何与上下文交互以回应你的。
- en: High-Level Flow
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高层次流程
- en: To understand how Copilot works at a high level, we can trace the basic workflow
    from the perspective of working in one of the supported IDEs. Currently, the supported
    IDEs for Copilot include Visual Studio, VS Code, NeoVim, any of the JetBrains
    family of IDEs, and others. Copilot also works in selected other environments,
    such as [GitHub Codespaces](https://oreil.ly/QyEks).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要从高层次了解Copilot的工作原理，我们可以从在支持的IDE之一中工作的角度追踪基本工作流程。目前，Copilot支持的IDE包括Visual Studio、VS
    Code、NeoVim、JetBrains家族的任何IDE以及其他一些IDE。Copilot还在选定的其他环境中工作，例如[GitHub Codespaces](https://oreil.ly/QyEks)。
- en: GitHub has also released the [Copilot Language Server SDK](https://oreil.ly/6rDHq),
    which can be used to integrate GitHub Copilot into any editor or IDE. So, expect
    to see more applications integrated with Copilot in the future.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub还发布了[Copilot语言服务器SDK](https://oreil.ly/6rDHq)，它可以用于将GitHub Copilot集成到任何编辑器或IDE中。因此，预计未来将看到更多与Copilot集成的应用程序。
- en: About Codespaces
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Codespaces
- en: GitHub Codespaces utilize virtual machines (VMs) running in the cloud that provide
    a full-featured and customizable development environment for GitHub users. Their
    interface is similar to that of VS Code; they can be tailored with the same extensions
    used in VS Code in a browser or connected to several IDEs. GitHub provides them
    as an optional service.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Codespaces利用在云中运行的虚拟机（VM），为GitHub用户提供了一个功能齐全且可定制的开发环境。它们的界面类似于VS Code；它们可以通过在浏览器中使用与VS
    Code相同的扩展来定制，或者连接到几个IDE。GitHub将它们作为一个可选服务提供。
- en: 'When writing code in an editor and using Copilot to suggest coding completions,
    several pieces of information are automatically scanned to gather context about
    what you’re working on:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当在编辑器中编写代码并使用Copilot建议代码补全时，会自动扫描几项信息以收集关于你正在处理的内容的上下文：
- en: Current file
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文件
- en: The current file that a user is editing is one key source of context for Copilot.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当前用户正在编辑的文件是Copilot获取上下文的关键来源之一。
- en: Name of the currently active file
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当前活动文件的名称
- en: When named descriptively, this can provide Copilot with clues about what the
    code is intended to do, such as *TestConfig.go*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当以描述性命名时，这可以为Copilot提供关于代码意图的线索，例如*TestConfig.go*。
- en: Content before and after the current cursor position
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当前光标位置前后内容
- en: Copilot can draw context from the code and comments immediately before and after
    the cursor position in the file. This can help it decide what to fill in and/or
    understand gaps in the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot可以从文件中光标前后立即的代码和注释中提取上下文。这可以帮助它决定要填写的内容，并/或理解代码中的空白。
- en: Comments
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Like human pair programmers or reviewers, Copilot can use comments to understand
    what code is doing and the intent of code that has yet to be written. This is
    one of the primary ways to provide context for Copilot—the more precise and detailed
    the comments, the more likely the code that Copilot suggests will be relevant.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于人类结对程序员或审阅者，Copilot可以使用注释来理解代码正在做什么以及尚未编写的代码的意图。这是为Copilot提供上下文的主要方法之一——注释越精确、越详细，Copilot建议的代码就越有可能相关。
- en: Other open files in the editor
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器中打开的其他文件
- en: Copilot uses the code being developed in any open files as context. This is
    key to gathering information about the current task and augmenting information
    in the model. For example, one strategy for dealing with deprecated features stored
    in the LLM is to open a file in the editor with the replacement approach for the
    deprecated feature. From this example, Copilot can interpret preferred alternatives
    for coding instead of relying on the deprecated approach used to train the LLM.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot使用任何打开文件中正在开发的代码作为上下文。这是收集关于当前任务信息并增强模型信息的关键。例如，处理存储在LLM中的已弃用功能的一种策略是在编辑器中打开一个文件，其中包含已弃用功能的替代方法。从这个例子中，Copilot可以解释编码的首选替代方案，而不是依赖于训练LLM时使用的已弃用方法。
- en: Local index
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本地索引
- en: Copilot automatically parses most files in a project opened in IDEs like VS
    Code and builds an advanced local *index* for the project. (See the following
    sidebar for more info.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot自动解析在VS Code等IDE中打开的项目中的大多数文件，并为项目构建一个高级本地*索引*。(有关更多信息，请参阅以下侧边栏。)
- en: If you are using the chat interface, it will usually be pre-populated with a
    file, selection, or terminal command as context, depending on what you were most
    recently working on. However, you can explicitly change that before submitting
    your prompt. (More on this in [Chapter 3](ch03.html#ch03).)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用聊天界面，它通常会根据你最近的工作内容预先填充一个文件、选择或终端命令作为上下文。然而，在提交提示之前，你可以明确地更改它。(有关更多信息，请参阅[第3章](ch03.html#ch03)。)
- en: So, when you’re using one of the interfaces with Copilot installed and activated,
    Copilot gathers context from these sources as you enter code ([Figure 1-2](#gathering-context-fro)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你使用安装并激活了Copilot的一个界面时，Copilot会在你输入代码时从这些来源收集上下文([图1-2](#gathering-context-fro))。
- en: '![](assets/lghc_0102.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0102.png)'
- en: Figure 1-2\. Gathering context from the IDE environment
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2. 从IDE环境中收集上下文
- en: That context is processed and ultimately sent to GitHub, synthesized into a
    prompt ([Figure 1-3](#prompt-synthesized)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该上下文被处理并最终发送到GitHub，合成为一个提示([图1-3](#prompt-synthesized))。
- en: '![](assets/lghc_0103.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0103.png)'
- en: Figure 1-3\. Synthesizing the prompt
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3. 合成提示
- en: The prompt is then passed through GitHub to the LLM, and possible completions
    or answers are returned. Once results are generated from the prompt to the LLM,
    GitHub’s Copilot systems perform additional processing on the result (more on
    that later). After that, the response is returned to the IDE, where you can evaluate
    it and choose how to proceed. See [Figure 1-4](#flow-from-prompt-to-s) for the
    flow for code completion.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提示随后通过GitHub传递到LLM，并返回可能的完成或答案。一旦从提示到LLM生成结果，GitHub的Copilot系统会对结果进行额外的处理（关于这一点稍后讨论）。然后，响应返回到IDE，你可以评估它并选择如何继续。参见[图1-4](#flow-from-prompt-to-s)了解代码补全的流程。
- en: This process continues and repeats with the user/Copilot interactions. In this
    way, Copilot acts as an assistant to help you with whatever use case you are working
    on, whether crafting boilerplate code, searching for a sophisticated algorithm,
    generating data or queries, writing unit tests, or learning a new programming
    language.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会随着用户/Copilot的交互继续和重复。这样，Copilot作为一个助手，可以帮助你处理你正在工作的任何用例，无论是编写样板代码、搜索复杂的算法、生成数据或查询、编写单元测试，还是学习一门新的编程语言。
- en: '![](assets/lghc_0104.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0104.png)'
- en: Figure 1-4\. Flow from the prompt to suggestions
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-4. 从提示到建议的流程
- en: You’ll see more of how the flow happens as we discuss how to use Copilot throughout
    the remaining chapters. But at this point, it’s worth understanding some of the
    usage considerations when using Copilot to help you produce software.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论如何在接下来的章节中使用Copilot时，你会看到更多关于流程是如何发生的。但在这个阶段，了解使用Copilot来帮助你生成软件时的一些使用注意事项是值得的。
- en: Usage Considerations
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**使用注意事项**'
- en: 'Now that you know what Copilot is and how it works, here’s a key point to understand:
    Copilot, like any AI, can give incorrect or incomplete answers. It can be wrong,
    or it can give you unexpected results. This is not common, but you should keep
    some important things in mind when using it so you can be aware. In this section,
    we’ll look at the following considerations:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Copilot是什么以及它是如何工作的，这里有一个关键点需要理解：Copilot，就像任何AI一样，可能会给出不正确或不完整的答案。它可能会出错，或者给出你意料之外的结果。这并不常见，但当你使用它时，你应该记住一些重要的事情，以便保持警觉。在本节中，我们将探讨以下注意事项：
- en: Timeliness
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**及时性**'
- en: Relevance
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相关性**'
- en: Completeness
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**'
- en: Accuracy
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准确性**'
- en: Privacy
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私**'
- en: Security
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**'
- en: And by the way, these aren’t unique to Copilot. They can apply to any current
    AI tool assisting you with a task.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这些并不局限于Copilot。它们可以适用于任何当前帮助你完成任务的人工智能工具。
- en: Timeliness
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**及时性**'
- en: '*Timeliness* here refers to the currency of Copilot’s suggestions. This may
    seem like an odd choice to start with, but it can intersect with all of the others.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 *及时性* 指的是Copilot建议的时效性。这看起来可能是一个奇怪的选择，但它可以与其他所有因素相交。
- en: Copilot relies on models trained initially at a point in time, so its data is
    based on what was current in the training data at that point. For example, if
    the model Copilot uses was trained two years ago, it does not necessarily know
    about changes since then.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot依赖于在某个时间点最初训练的模型，因此其数据基于那个时间点训练数据中的当前内容。例如，如果Copilot使用的模型是在两年前训练的，那么它并不一定了解那之后的变化。
- en: Your everyday use of Copilot can produce outdated suggestions and answers. Results
    could contain deprecated code that no longer works with your compiler or interpreter.
    You could get a suggestion that references a version of a dependency with a known
    vulnerability or a response that might include an outdated approach.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你日常使用Copilot可能会产生过时的建议和答案。结果可能包含不再与你的编译器或解释器兼容的弃用代码。你可能会得到一个引用已知漏洞的依赖项版本的建议，或者可能包含过时方法的响应。
- en: You might ask the chat interface in Copilot, “Is *X* deprecated?” and get an
    answer that *X* is *not* deprecated when, in fact, it is. Copilot is answering
    as of the point in time when the model it is using was trained. Or you might ask,
    “What is the current version of *X*?” and get a result from two years ago. I’m
    sure you can see how this could cause issues. Results can also vary significantly
    depending on the model you’ve chosen (from the ones that Copilot supports) for
    the current interaction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在Copilot的聊天界面上问，“*X* 是否已弃用？”并得到一个回答，说 *X* 是 *未* 弃用的，但实际上它是。Copilot是在它所使用的模型训练的那个时间点回答的。或者你可能问，“*X*
    的当前版本是什么？”并得到两年前的结果。我相信你可以看到这可能会造成问题。结果也可能根据你选择的模型（从Copilot支持的模型中选择）而有很大差异。
- en: '[Chapter 7](ch07.html#ch07) discusses techniques for providing Copilot with
    more up-to-date context for deprecated items within your environment, increasing
    the likelihood of returning more up-to-date responses.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html#ch07) 讨论了为Copilot提供更多最新环境上下文的技术，以增加返回更更新颖响应的可能性。'
- en: Relevance
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关性
- en: Copilot’s suggestions and chat responses are based on LLMs trained on large
    sets of code. If you’re using the default OpenAI models, that codebase is the
    public code hosted on GitHub. GitHub arguably has the most comprehensive collection
    of repositories for open source software. This includes code written in today’s
    most popular programming languages, such as Python, Go, and JavaScript.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot的建议和聊天响应基于在大量代码上训练的LLM。如果你使用的是默认的OpenAI模型，那么这个代码库就是GitHub上托管的开源代码。GitHub可以说是拥有最全面的开放源代码仓库集合。这包括用当今最流行的编程语言编写的代码，如Python、Go和JavaScript。
- en: Given the training, it stands to reason that Copilot will be most effective
    when you’re working in one of the more common programming languages or frameworks
    represented in the codebase used for training. The more a language or framework
    is represented in that collection (GitHub repositories for the OpenAI models),
    the more references Copilot can learn from. Think of it like the subjects you
    spent more time studying in school—those are the ones you know the most about.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到训练，可以合理地认为，当你在一个用于训练的代码库（用于OpenAI模型的GitHub仓库）中工作，并且该语言或框架在集合中（GitHub仓库）有更多代表时，Copilot将最为有效。一个语言或框架在该集合中的代表越多，Copilot可以从中学习的参考就越多。想象一下你在学校花更多时间学习的科目——那些是你最熟悉的。
- en: If you’re working in a less represented language or framework, the suggestions
    may not be as useful. That doesn’t imply you can’t get relevant suggestions and
    answers, but you may find them less helpful in answering your exact query.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个不太有代表性的语言或框架中工作，建议可能不那么有用。这并不意味着你不能得到相关性的建议和答案，但你可能会发现它们在回答你的具体查询时不太有帮助。
- en: A key factor beyond Copilot’s control is the amount of context it has to work
    with. For example, if your code consists of a function named `ParseData` or you
    supply a generic or ambiguous prompt, such as “Create a function to parse data,”
    without additional context, the results returned from Copilot are likely to also
    be generic.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 超出Copilot控制的关键因素是它必须处理的上下文数量。例如，如果你的代码包含一个名为`ParseData`的函数，或者你提供了一个没有额外上下文的通用或模糊的提示，例如“创建一个解析数据的函数”，那么Copilot返回的结果可能也是通用的。
- en: Completeness
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整性
- en: Generative AI can sometimes return incomplete or unusable suggestions. This
    rarely happens in the chat interface, but it’s not uncommon for Copilot’s code
    completion to return a set of suggestions that are only partial solutions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 生成式AI有时会返回不完整或不实用的建议。这种情况在聊天界面中很少发生，但Copilot的代码补全返回一组仅部分解决方案的建议并不罕见。
- en: The same caveat discussed at the end of the previous section on relevancy applies
    here. If your code or query is generic or ambiguous, Copilot may not have enough
    context to draw on to return a complete result.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节关于相关性的讨论中提到的相同注意事项也适用于此处。如果你的代码或查询是通用的或模糊的，Copilot可能没有足够的上下文来引用，从而返回完整的结果。
- en: In other instances, you might provide specific context to Copilot, but it suggests
    only a comment or the first line of a function. This is generally seen when working
    through the suggestion process in the IDE rather than in the chat interface. You
    may need to provide additional prompting or supply more context for Copilot. Sometimes
    you can *nudge* Copilot by giving it a hint (typing a keyword, for example), and
    that will be enough to make it return a more complete suggestion. At other times,
    Copilot may simply respond with a blank line, and accepting that response may
    cause it to continue generating code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，你可能为Copilot提供了特定的上下文，但它只建议一个注释或函数的第一行。这通常发生在通过IDE中的建议过程而不是在聊天界面中。你可能需要提供额外的提示或为Copilot提供更多上下文。有时，你可以通过给出一个提示（例如输入一个关键字）来“推动”Copilot，这样它就会返回一个更完整的建议。在其他时候，Copilot可能会简单地响应一个空白行，接受这个响应可能会导致它继续生成代码。
- en: Copilot does offer options to get more suggestions if the immediate one isn’t
    a good fit, but those can be of limited utility. I’ll delve into details on those
    approaches in [Chapter 2](ch02.html#ch02).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果立即的建议不适合，Copilot确实提供了获取更多建议的选项，但这些可能作用有限。我将在[第2章](ch02.html#ch02)中深入探讨这些方法的细节。
- en: Accuracy
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准确性
- en: Except in the simplest of cases, you cannot assume that any response from Copilot
    is entirely correct or the best answer. You should always carefully review Copilot
    responses. It’s not hard to find stories of AI results in other domains that made
    their way into official records with references that don’t exist. For example,
    there have been reports of court briefs that were filed referencing previous cases
    that didn’t happen. I know of people who have tried to use AI to plan vacation
    itineraries and received a promising agenda—only with hotels that didn’t exist.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最简单的情况外，你不能假设Copilot的任何响应都是完全正确或最佳答案。你应该始终仔细审查Copilot的响应。在其他领域，AI的结果进入官方记录，但引用的内容并不存在的故事并不难找到。例如，有报道称提交的法庭简报引用了未曾发生过的先例。我知道有人试图使用AI来规划假期行程，并收到了一个有希望的日程安排——但酒店并不存在。
- en: 'Likewise, Copilot may return a response that is valid syntax but references
    constructs or variables that do not exist in the code. This is a coding form of
    AI *hallucination*: the AI presents information that is incorrect, made up, or
    otherwise not grounded in reality as a valid solution or suggestion. This is rare
    but can still occur. Sometimes this can be because Copilot needs to create suggestions
    around elements that don’t exist yet. For example, if you ask Copilot how to open
    and write to a file without specifying the name, it may use a filename that has
    no meaning in your code within its example.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Copilot可能会返回一个语法上有效但引用了代码中不存在的构造或变量的响应。这是一种编码形式的AI*幻觉*：AI呈现的信息是不正确的、虚构的，或者以其他方式没有基于现实作为有效解决方案或建议。这种情况很少见，但仍然可能发生。有时这可能是因为Copilot需要围绕尚不存在的内容元素创建建议。例如，如果你要求Copilot说明如何打开并写入一个文件，但没有指定文件名，它可能会在其示例中使用一个在你代码中没有意义的文件名。
- en: Regardless of the circumstances, the user is always responsible for reviewing
    Copilot’s responses for accuracy. This should be no different from reviewing a
    human’s contributions to your code; you want to ensure they are correct and do
    no harm.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论情况如何，用户始终负责审查Copilot的响应以确保准确性。这应该与审查人类对代码的贡献没有区别；你希望确保它们是正确的，并且不会造成损害。
- en: Prompts and Accuracy
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和准确性
- en: The results from Copilot can often be improved by developing a better prompt
    for the AI. We’ll cover more about prompting throughout the book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为AI开发更好的提示，Copilot的结果通常可以得到改善。我们将在本书中详细介绍提示的相关内容。
- en: Privacy
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐私
- en: Another aspect of working with Copilot is data privacy. As previously noted,
    several information sources (including open files and current files) are read,
    and information is collected and transferred through Copilot to factor into the
    prompt for the LLM. That means some data is going across the web and being processed
    outside your control. This may seem like a potential security risk. However, Copilot
    includes options when signing up to specify whether or not you want to allow GitHub
    to include your context information as part of its data to help Copilot get better.
    (See the bottom part of [Figure 1-5](#options-at-signup-for).) If you do not,
    while the information will be gathered, it will not be retained. It will be collected
    to construct the prompt and then discarded.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与Copilot一起工作的另一个方面是数据隐私。如前所述，几个信息来源（包括打开的文件和当前文件）被读取，信息被收集并通过Copilot传输以纳入LLM的提示。这意味着一些数据正在互联网上传输，并且在没有您控制的情况下进行处理。这看起来可能是一个潜在的安全风险。然而，Copilot在注册时提供了选项，允许您指定是否希望GitHub将您的上下文信息作为其数据的一部分，以帮助Copilot变得更好。（见[图1-5](#options-at-signup-for)的底部部分。）如果您不这样做，虽然信息将被收集，但不会保留。它将被收集来构建提示，然后丢弃。
- en: Copilot Trust Center
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copilot信任中心
- en: GitHub has a [Trust Center](https://oreil.ly/0GM3-) to help with any privacy-related
    content issues or concerns.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub有一个[信任中心](https://oreil.ly/0GM3-)，可以帮助处理任何与隐私相关的内容问题或担忧。
- en: '![](assets/lghc_0105.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0105.png)'
- en: Figure 1-5\. Options at sign-up for data privacy
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-5\. 注册时数据隐私选项
- en: 'Copilot intersects with user data in three areas: user engagement, prompts,
    and suggestions. Here’s a summary:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot在三个领域与用户数据相交：用户参与度、提示和建议。以下是总结：
- en: User engagement
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用户参与度
- en: This is usage data about how you interact with Copilot (telemetry). It can include
    whether you accept or dismiss suggestions from Copilot, how you interact with
    the chat UI, and metrics such as latency and error messages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于您如何与Copilot互动的使用数据（遥测数据）。它可以包括您是否接受或拒绝Copilot的建议，您如何与聊天UI互动，以及诸如延迟和错误消息之类的指标。
- en: Prompts
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As previously discussed, the context information taken from your environment,
    or a chat query passed back to GitHub.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，从你的环境或传回GitHub的聊天查询中获取的上下文信息。
- en: Suggestions
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 建议
- en: The suggested code completions returned by Copilot and/or the responses to chat
    queries.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot返回的代码补全建议和/或对聊天查询的响应。
- en: User engagement data is tracked by default and could include anonymized data,
    although there are nuances depending on the particular Copilot plan you’re using.
    (See the [Trust Center](https://oreil.ly/rC8Rm) documentation for more information.)
    Mechanisms exist to encrypt data in transit and at rest. GitHub has controls to
    strictly limit who can access data on their side.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 用户参与数据默认会进行跟踪，可能包括匿名数据，尽管具体取决于你使用的特定Copilot计划。（有关更多信息，请参阅[信任中心](https://oreil.ly/rC8Rm)文档。）存在机制可以加密传输中和静止中的数据。GitHub有控制措施，严格限制谁可以访问其侧的数据。
- en: GitHub Repositories and Legal Concerns
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub仓库和法律问题
- en: The legality of using the *public* repositories on GitHub to train some LLMs
    has been questioned in public opinion and in courts. We will leave those considerations
    for others to sort out, and we won’t focus on, or comment on, those aspects of
    the initial training process in this book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在公众舆论和法庭上，使用GitHub上的*公共*仓库来训练某些LLM的合法性受到了质疑。我们将把这些考虑留给其他人去解决，我们不会关注或评论本书中初始训练过程的这些方面。
- en: 'One other concern is often raised about Copilot when using a model trained
    on licensed repositories: Copilot could generate suggestions that closely match
    content from that codebase. The implication is that users could end up unwittingly
    violating licensing terms and intellectual property rights by having the duplicated
    code included in their work. Copilot includes an option for individuals and administrators
    to block public code matches if those are generated as part of the AI’s process.
    (See the top part of [Figure 1-5](#options-at-signup-for).) If that option is
    selected, Copilot will alert you to the situation and filter out matches from
    the public code base.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用在许可仓库上训练的模型时，关于Copilot的一个其他担忧经常被提出：Copilot可能会生成与该代码库内容非常接近的建议。这意味着用户可能会无意中违反许可条款和知识产权，因为复制的代码包含在他们的工作中。Copilot为个人和管理员提供了一个选项，如果这些匹配是AI过程的一部分生成，则可以阻止公共代码匹配。（见[图1-5](#options-at-signup-for)的顶部部分。）如果选择了该选项，Copilot将提醒你这种情况，并过滤掉来自公共代码库的匹配。
- en: Security
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Last but certainly not least is the area of security in the results that Copilot
    returns. Security is an ever-present concern in any product or application used
    today. Addressing that concern starts with secure coding practices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项但绝对重要的是Copilot返回的结果中的安全问题。在当今使用的任何产品或应用程序中，安全性都是一个始终存在的担忧。解决这一担忧从安全的编码实践开始。
- en: I stated earlier that once Copilot receives potential results from the LLM,
    GitHub performs some additional processing on them. This processing includes running
    algorithms to quickly look for possible vulnerabilities. GitHub does not run a
    security scanning application against the result, which would take too long. Instead,
    it quickly scans for patterns indicating vulnerabilities and/or insecure coding
    practices. If those are identified, the proposed suggestion is flagged.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，一旦Copilot从LLM收到潜在结果，GitHub会对这些结果进行一些额外的处理。这包括运行算法以快速查找可能存在的漏洞。GitHub不会对结果运行安全扫描应用程序，因为这会花费太长时间。相反，它会快速扫描表明漏洞和/或编码实践不安全的模式。如果确定了这些模式，则提出的建议会被标记。
- en: Even with these measures, there is no guarantee that something hasn’t slipped
    through. Since the processing isn’t the same as running full scans with an application
    focused on finding vulnerabilities, the results from Copilot should still be subject
    to whatever other security checks you would use for any code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了这些措施，也不能保证没有东西被遗漏。由于处理过程与使用专注于寻找漏洞的应用程序进行完整扫描不同，Copilot的结果仍然应该受到你为任何代码使用的任何其他安全检查。
- en: '*The clear and ever-present requirement when using generative AI is that you
    must always review and assess any suggestions it returns. You should not assume
    that it completely and correctly interpreted the context. And, in all but the
    simplest of cases, you cannot assume that the result is perfect.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*在使用生成式AI时，一个清晰且始终存在的需求是，你必须始终审查和评估它返回的任何建议。你不应该假设它完全且正确地理解了上下文。而且，在所有非简单情况下，你不能假设结果是完美的。*'
- en: To state this another way, while Copilot is often referred to as an *AI pair
    programmer*, it does not have the same understanding and level of familiarity
    with your code as an actual human pair programmer would. Instead, it is best to
    think of Copilot as a skilled programmer new to the project. A programmer in that
    position can create useful code based on what they can observe and what has been
    shared with them, but they can’t possess all of the larger context, project history,
    or backstory. As a result, you must be diligent in ensuring that the code they
    produce is accurate, secure, and suitable to merge. Copilot’s answers and suggestions
    should be treated the same way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以另一种方式来说，虽然Copilot经常被称为*AI配对程序员*，但它并不具备像实际的人类配对程序员那样对你的代码的理解和熟悉程度。相反，最好将Copilot视为一个对项目不太熟悉但技艺高超的程序员。处于这种位置的程序员可以根据他们所能观察到的以及与他们分享的内容创建有用的代码，但他们无法拥有所有更大的背景、项目历史或背景故事。因此，你必须勤奋地确保他们产生的代码是准确、安全且适合合并的。Copilot的答案和建议也应同样对待。
- en: And, as when working with a new programmer on the team, the more details you
    provide (whether code to use as context or specific directions), the better the
    result will usually be. Giving Copilot more coding examples to draw on and more
    specifics in your prompt in the chat can go a long way towards getting a better
    result from the AI.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像与团队中的新程序员合作一样，你提供的细节越多（无论是用作背景的代码还是具体的指示），通常结果会越好。为Copilot提供更多的编码示例，并在聊天中提供更具体的提示，可以大大提高从AI获得更好的结果。
- en: 'Another consideration may come up as you start to work with or consider using
    an assistant like Copilot: why not just use ChatGPT or a similar chatbot to produce
    code? The answer is that you certainly can. However, the two approaches and interfaces
    have key differences. The following section provides a quick comparison, using
    ChatGPT to represent other generalized AI applications that can create code.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用或考虑使用像Copilot这样的助手时，可能会出现另一个考虑因素：为什么不直接使用ChatGPT或类似的聊天机器人来生成代码呢？答案是，你当然可以。然而，这两种方法和界面有关键的区别。以下部分提供了一个快速比较，使用ChatGPT代表其他可以创建代码的通用AI应用。
- en: Copilot Versus ChatGPT
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copilot 与 ChatGPT 对比
- en: You might wonder how Copilot or similar coding assistants differ from ChatGPT
    or similar chatbots, given both may use the same underlying models to produce
    responses. The general distinction is that Copilot is focused only on the coding
    domain and provides functionality to specifically help with that. ChatGPT, on
    the other hand, is targeted more broadly across any domain and doesn’t provide
    the same level of integration. [Table 1-1](#comparison-of-copilot10) highlights
    differences in several more specific categories.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，鉴于两者都可能使用相同的底层模型来生成响应，Copilot或类似的编码助手与ChatGPT或类似的聊天机器人有何不同。一般的区别是，Copilot仅关注编码领域，并提供专门帮助该领域的功能。另一方面，ChatGPT的目标更广泛，覆盖任何领域，并且不提供相同级别的集成。[表
    1-1](#comparison-of-copilot10)突出了在几个更具体的类别中的差异。
- en: Table 1-1\. Comparison of Copilot to ChatGPT
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1\. Copilot 与 ChatGPT 的比较
- en: '| Category | GitHub Copilot | ChatGPT |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | GitHub Copilot | ChatGPT |'
- en: '| --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Primary function | Understanding and generating code or code-related prompts
    | Understanding and generating any natural language |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 主要功能 | 理解和生成代码或与代码相关的提示 | 理解和生成任何自然语言 |'
- en: '| Primary user interface | Code editors, chat | Chat |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 主要用户界面 | 代码编辑器，聊天 | 聊天 |'
- en: '| Developer | GitHub with OpenAI | OpenAI |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 开发者 | GitHub with OpenAI | OpenAI |'
- en: '| Primary use cases | Writing and augmenting code and code documentation |
    Conversational responses with text generation |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 主要用例 | 编写和增强代码及代码文档 | 文本生成的对话式响应 |'
- en: '| Pricing model | Subscription based with usage tracking for premium models
    | Usage based and subscription based |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 定价模式 | 预付费模式，并跟踪高级模型的使用情况 | 基于使用情况和预付费模式 |'
- en: '| Training data | Code repos, documentation | Diverse, broad text content |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 训练数据 | 代码库，文档 | 多样化、广泛的多文本内容 |'
- en: '| Public APIs | Limited to telemetry, monitoring, and license management |
    Broad API surface for interaction |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 公共API | 限于遥测、监控和许可证管理 | 广泛的API界面用于交互 |'
- en: In general, you can think of Copilot as a very domain-specific implementation
    of generative AI. This is as opposed to the broader (domain-less) implementation
    and function of ChatGPT and other general chat tools. ChatGPT can certainly be
    used for generating code, but it lacks the integration with development environments,
    coding focus, and GitHub support and features that Copilot has.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以将Copilot视为一种非常特定领域的生成式AI实现。这与ChatGPT和其他通用聊天工具更广泛的（无领域）实现和功能形成对比。ChatGPT当然可以用于生成代码，但它缺乏与开发环境、编码重点、GitHub支持和功能集成的Copilot所具有的特性。
- en: Although we’ve been discussing Copilot as a single application, it actually
    has five configurations. Let’s finish up this introductory chapter by helping
    explain the plans available for you to choose from.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们一直在讨论Copilot作为一个单一的应用程序，但实际上它有五种配置。让我们通过帮助解释您可以选择的计划来结束这一章的介绍。
- en: Copilot Plans
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copilot计划
- en: 'Copilot comes in five plans at the time of this writing: *Free*, *Pro*, *Pro+*,
    *Business*, and *Enterprise*. To understand the differences between them, you
    need to understand some common terms:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Copilot提供五种计划：*免费*、*专业*、*专业+*、*商业*和*企业*。要了解它们之间的区别，你需要了解一些常见术语：
- en: Code completions
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码补全
- en: AI-suggested code for completing code being worked on in your IDE.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的IDE中正在工作的代码中完成代码的AI建议。
- en: Chat request
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天请求
- en: A prompt, which can be a direction or a question, that you pass to Copilot through
    a chat interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个提示，可以是方向或问题，通过聊天界面传递给Copilot。
- en: Agent mode
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式
- en: An option in Copilot to have it act on a prompt by independently planning, executing,
    and iterating across files to suggest changes needed to accomplish a task.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot中的一个选项，允许它通过独立规划、执行和迭代文件来对提示做出反应，以建议完成任务所需的更改。
- en: Agent mode request
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式请求
- en: A request made to Copilot to accomplish a task while it is in Agent mode.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理模式下向Copilot提出的完成任务请求。
- en: Model access
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模型访问
- en: The LLMs that Copilot is allowed to access from the set of all LLMs it works
    with; a list of models currently available is included in the [Copilot documentation](https://oreil.ly/icFQK).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot允许从所有它工作的LLM集中访问的LLM；当前可用的模型列表包含在[Copilot文档](https://oreil.ly/icFQK)中。
- en: Premium requests
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 优先请求
- en: Interactions that use advanced AI models with operations such as Copilot Chat,
    Agent mode, code review, or extensions. These consume more compute resources and
    are counted separately from standard code completions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Copilot Chat、代理模式、代码审查或扩展等操作的高级AI模型交互。这些操作消耗更多计算资源，并单独计算于标准代码补全之外。
- en: With those terms in mind, [Table 1-2](#comparison-of-github) explains the available
    plans and the key differences between them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些术语，[表1-2](#comparison-of-github)解释了可用的计划以及它们之间的关键区别。
- en: Table 1-2\. Comparison of GitHub Copilot plans
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-2。GitHub Copilot计划的比较
- en: '|   | Free | Pro | Pro+ | Business | Enterprise |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|   | 免费版 | 专业版 | 专业+版 | 商业版 | 企业版 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Target users | Individual developers looking to explore Copilot | Individual
    developers who want unlimited access to Copilot but don’t need to use all models
    | Individual developers who want maximum flexibility and access to all models
    | Organizations or enterprises that need unlimited access to core Copilot functionality
    and business management features but not all models | Organizations or enterprises
    that need unlimited access to core Copilot functionality and business management
    features with maximum flexibility and access to all models |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 目标用户 | 寻求探索Copilot的个人开发者 | 想要无限制访问Copilot但不需要使用所有模型的个人开发者 | 想要最大灵活性和访问所有模型的个人开发者
    | 需要无限制访问核心Copilot功能和企业管理功能但不需要所有模型的组织或企业 | 需要无限制访问核心Copilot功能和企业管理功能，具有最大灵活性和访问所有模型的组织或企业
    |'
- en: '| Coding completions, chat requests, and Agent mode requests | 50 chat requests
    or Agent mode requests/month (counted as premium)2,000 code completion requests/month
    | Unlimited | Unlimited | Unlimited | Unlimited |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 编码补全、聊天请求和代理模式请求 | 每月50个聊天请求或代理模式请求（计为高级）每月2,000个代码补全请求 | 无限制 | 无限制 | 无限制
    | 无限制 |'
- en: '| Model access | Access to a small subset of models | Access to more models
    | Access to all models | Access to more models | Access to all models |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 模型访问 | 访问一小部分模型 | 访问更多模型 | 访问所有模型 | 访问更多模型 | 访问所有模型 |'
- en: '| Premium requests | 50 premium requests/month | 300 premium requests/month
    | 1,500 premium requests/month | 300 premium requests/month | 1,000 premium requests/month
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 付费请求 | 50个付费请求/每月 | 300个付费请求/每月 | 1,500个付费请求/每月 | 300个付费请求/每月 | 1,000个付费请求/每月
    |'
- en: '| Additional features | Limited code review for selections in VS Code |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 额外功能 | VS Code中选择的代码审查有限 |'
- en: Code review
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: Pull request summaries
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取请求摘要
- en: '|'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Code review
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: Pull request summaries
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取请求摘要
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Code review
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: Pull request summaries
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取请求摘要
- en: User management and metrics
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理和指标
- en: Data privacy
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据隐私
- en: IP indemnity
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP赔偿
- en: '|'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Code review
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: Pull request summaries
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取请求摘要
- en: User management and metrics
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理和指标
- en: Data privacy
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据隐私
- en: IP indemnity
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP赔偿
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Administration | Individual | Individual | Individual | Enterprise | Enterprise
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 管理 | 个人 | 个人 | 个人 | 企业 | 企业 |'
- en: '| Cost | Free | $10/month or $100/year (free trial available for 30 days) |
    $39/month or $390/year | $19/month/user | $39/month/user |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 成本 | 免费 | 每月10美元或每年100美元（提供30天免费试用） | 每月39美元或每年390美元 | 每用户每月19美元 | 每用户每月39美元
    |'
- en: Latest Info
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最新信息
- en: The information in [Table 1-2](#comparison-of-github) is accurate as of the
    time of this writing. Consult [the Copilot features page](https://oreil.ly/ptoVy)
    for the latest information.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-2中的信息在撰写本文时是准确的。有关最新信息，请参阅[Copilot功能页面](https://oreil.ly/ptoVy)。
- en: Of course, cost is a significant factor. If you are an individual user who only
    uses Copilot on a limited basis in your IDE and doesn’t need the extra features,
    the Free plan may make sense. If you’re an individual user who wants to use Copilot
    on a regular basis and can benefit from the additional features, the Pro or Pro+
    plans can provide a good match.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，成本是一个重要因素。如果您是仅限于在IDE中使用Copilot的个人用户，并且不需要额外功能，那么免费计划可能是有意义的。如果您是希望定期使用Copilot并可以从额外功能中受益的个人用户，那么Pro或Pro+计划可以提供良好的匹配。
- en: At a corporate or community level, if you need or want the extra ability to
    easily assign and manage licenses across multiple users, as well as additional
    administrative oversight, the Business subscription can provide that. And if,
    as a business or community, you you want to take full advantage of advanced features
    and have maximum access to models, then the Enterprise plan is your best option.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业或社区层面，如果您需要或想要轻松地为多个用户分配和管理许可证以及额外的管理监督，则商务订阅可以提供这些功能。如果您作为企业或社区希望充分利用高级功能并最大限度地访问模型，那么企业计划是您的最佳选择。
- en: Mixing Plans
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合计划
- en: It is possible to mix plan types within an enterprise at the organization level.
    See the [documentation](https://oreil.ly/BZ1p6).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织层面，企业内部可以混合计划类型。请参阅[文档](https://oreil.ly/BZ1p6)。
- en: 'Regardless of the plan you choose, the steps are similar:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪种计划，步骤都是相似的：
- en: Sign up and register for license(s).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册并注册许可证。
- en: Establish a payment process.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立支付流程。
- en: Install Copilot via an extension or whatever process you use to add functionality
    in your IDE.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扩展或您在IDE中添加功能所使用的任何过程安装Copilot。
- en: At an organization level, once the plan is set up, organization admins can add
    users and manage licenses as shown in [Figure 1-6](#managing-a-copilot-or).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织层面，一旦计划设置完成，组织管理员可以添加用户并管理许可证，如图1-6所示[图1-6](#managing-a-copilot-or)。
- en: '![](assets/lghc_0106.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0106.png)'
- en: Figure 1-6\. Managing a Copilot Business plan
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-6\. 管理Copilot商业计划
- en: 'Once you gain access to a Copilot subscription, you can install it into whichever
    IDE you use. [The GitHub Copilot documentation](https://oreil.ly/kF4rn) provides
    links for installing the GitHub Copilot extension in your chosen IDE. As of this
    writing, the currently supported IDEs include the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得Copilot订阅的访问权限，您就可以将其安装到您使用的任何IDE中。[GitHub Copilot文档](https://oreil.ly/kF4rn)提供了在您选择的IDE中安装GitHub
    Copilot扩展的链接。截至本文撰写时，目前支持以下IDE：
- en: '[Azure Data Studio](https://oreil.ly/uUNGn)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Azure Data Studio](https://oreil.ly/uUNGn)'
- en: '[Eclipse](https://oreil.ly/Mqdq2)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Eclipse](https://oreil.ly/Mqdq2)'
- en: '[JetBrains IDEs](https://oreil.ly/dlYdh)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JetBrains IDEs](https://oreil.ly/dlYdh)'
- en: '[Vim/Neovim](https://oreil.ly/rA6oI)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vim/Neovim](https://oreil.ly/rA6oI)'
- en: '[Visual Studio](https://oreil.ly/qYbh_)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Visual Studio](https://oreil.ly/qYbh_)'
- en: '[Visual Studio Code](https://oreil.ly/GYc9X)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Visual Studio Code](https://oreil.ly/GYc9X)'
- en: '[Xcode](https://oreil.ly/MGeCb)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Xcode](https://oreil.ly/MGeCb)'
- en: GitHub Copilot Language Server
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub Copilot语言服务器
- en: GitHub also provides the [Copilot Language Server SDK](https://oreil.ly/008MF).
    This SDK allows integrating Copilot with any editor or IDE that can use the Language
    Server Protocol (LSP) standard. So expect to see more integrations being developed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 还提供了 [Copilot 语言服务器 SDK](https://oreil.ly/008MF)。此 SDK 允许将 Copilot 集成到任何可以使用语言服务器协议（LSP）标准的编辑器或
    IDE 中。因此，预计将看到更多集成开发。
- en: Conclusion
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: I hope you’re starting to have a better sense of what GitHub Copilot is all
    about and how it potentially can be used. I also hope you’re finding yourself
    intrigued to learn and understand more about it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你开始对 GitHub Copilot 有更好的了解，以及它可能如何被使用。我也希望你对学习和了解它感到好奇。
- en: In this chapter, I’ve provided an overview of what Copilot is, how it works,
    some key considerations to keep in mind when using it, and how to understand the
    plans it provides. This paints a picture of how Copilot fits in with the current
    use and potential of AI to help you in a given domain. In this case, that domain
    is creating software, and more generally, coding.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我概述了 Copilot 是什么，它是如何工作的，使用它时需要考虑的一些关键因素，以及如何理解它提供的计划。这描绘了 Copilot 如何与当前
    AI 在特定领域的应用和潜力相结合。在这种情况下，该领域是创建软件，更普遍地说，是编码。
- en: There are a few key points to take away from this text. One is that AI can greatly
    simplify and support your efforts as a coder. A second is that context is king
    when it comes to helping Copilot provide you with the best results. And a third,
    and arguably the most important one, is that you still have the ultimate responsibility
    to review and assess any suggestions and answers from the AI. Copilot is great
    at what it does, but it is only as good as the context we give it and the capabilities
    and training data of the model it is using. And as with human coders, those variables
    factor in to how complete, relevant, and accurate (or not) any result is.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从本文中可以提取几个关键点。一是 AI 可以极大地简化并支持你作为编码者的努力。二是当帮助 Copilot 提供最佳结果时，上下文至关重要。第三点，也许是最重要的一点，你仍然有最终责任来审查和评估来自
    AI 的任何建议和答案。Copilot 在其领域内做得很好，但它的好坏取决于我们提供的上下文以及它所使用的模型的能力和训练数据。就像人类编码者一样，这些变量会影响结果的完整性、相关性以及准确性（或不准确性）。
- en: There are a number of standard ways of leveraging Copilot to complete code.
    In the next chapter, you’ll look at how to use and work with Copilot code completions
    in the IDE interfaces where you are coding. Understanding those will help get
    you to the next level of using the tool, completing the foundation you need for
    the rest of the book, and getting the most out of Copilot.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种标准方式可以利用 Copilot 完成代码。在下一章中，你将了解如何在编码的 IDE 界面中使用和操作 Copilot 代码补全。理解这些将帮助你达到使用该工具的更高层次，完成本书其余部分所需的基础，并充分利用
    Copilot。
