- en: 6 Building autonomous assistants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behavior trees for robotics and AI apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPT Assistants Playground and creating assistants and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autonomous control of agentic behavior trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating conversational multi-agent systems via agentic behavior trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using back chaining to create behavior trees for complex systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve covered how actions extend the power/capabilities of agents,
    we can look at how behavior trees can guide agentic systems. We’ll start by understanding
    the basics of behavior trees and how they control robotics and AI in games.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to agentic actions and examine how actions can be implemented on
    the OpenAI Assistants platform using the GPT Assistants Playground project. From
    there, we’ll look at how to build an autonomous agentic behavior tree (ABT) using
    OpenAI assistants. Then, we’ll move on to understanding the need for controls
    and guardrails on autonomous agents and using control barrier functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of the chapter, we’ll examine the use of the AgentOps platform
    to monitor our autonomous behavior-driven agentic systems. This will be an exciting
    chapter with several challenges. Let’s begin by jumping into the next section,
    which introduces behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Introducing behavior trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behavior trees are a long-established pattern used to control robotics and AI
    in games. Rodney A. Brooks first introduced the concept in his “A Robust Layered
    Control System for a Mobile Robot” paper in 1986\. This laid the groundwork for
    a pattern that expanded on using the tree and node structure we have today.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve ever played a computer game with nonplayer characters (NPCs) or interacted
    with advanced robotic systems, you’ve witnessed behavior trees at work. Figure
    6.1 shows a simple behavior tree. The tree represents all the primary nodes: selector
    or fallback nodes, sequence nodes, action nodes, and condition nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 A simple behavior tree of eating an apple or a pear
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Table 6.1 describes the functions and purpose of the primary nodes we’ll explore
    in this book. There are other nodes and node types, and you can even create custom
    nodes, but for now, we’ll focus on those in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1 The primary nodes used in behavior trees
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Node | Purpose | Function | Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Selector (fallback)  | This node works by selecting the first child that
    completes successfully. It’s often called the fallback node because it will always
    fall back to the last successful node that executed.  | The node calls its children
    in sequence and stops executing when the first child succeeds. When a child node
    succeeds, it will return success; if no nodes succeed, it returns failure.  |
    Composite  |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence  | This node executes all of its children in sequence until one
    node fails or they all complete successfully.  | The node calls each of its children
    in sequence regardless of whether they fail or succeed. If all children succeed,
    it returns success, and failure if just one child fails.  | Composite  |'
  prefs: []
  type: TYPE_TB
- en: '| Condition  | Behavior trees don’t use Boolean logic but rather success or
    failure as a means of control. The condition returns success if the condition
    is true and false otherwise.  | The node returns success or failure based on a
    condition.  | Task  |'
  prefs: []
  type: TYPE_TB
- en: '| Action  | This is where the action happens.  | The node executes and returns
    success if successful or returns failure otherwise.  | Task  |'
  prefs: []
  type: TYPE_TB
- en: '| Decorator  | They work by controlling the execution of child nodes. They
    are often referred to as conditionals because they can determine whether a node
    is worth executing or safe to execute.  | The node controls execution of the child
    nodes. Decorators can operate as control barrier functions to block or prevent
    unwanted behaviors.  | Decorator  |'
  prefs: []
  type: TYPE_TB
- en: '| Parallel  | This node executes all of its nodes in parallel. Success or failure
    is controlled by a threshold of the number of children needed to succeed to return
    success.  | The node executes all of its child nodes in sequence regardless of
    the status of the nodes.  | Composite  |'
  prefs: []
  type: TYPE_TB
- en: The primary nodes in table 6.1 can provide enough functionality to handle numerous
    use cases. However, understanding behavior trees initially can be daunting. You
    won’t appreciate their underlying complexity until you start using them. Before
    we build some simple trees, we want to look at execution in more detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1 Understanding behavior tree execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding how behavior trees execute is crucial to designing and implementing
    behavior trees. Unlike most concepts in computer science, behavior trees operate
    in terms of success and failure. When a node in a behavior tree executes, it will
    return either success or failure; this even applies to conditions and selector
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior trees execute from top to bottom and left to right. Figure 6.2 shows
    the process and what happens if a node fails or succeeds. In the example, the
    AI the tree controls has an apple but no pear. In the first sequence node, a condition
    checks if the AI has an apple. Because the AI doesn’t have an apple, it aborts
    the sequence and falls back to the selector. The selector then selects its next
    child node, another sequence, that checks if the AI has a pear, and because it
    does, the AI eats the apple.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 The execution process of a simple behavior tree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Behavior trees provide control over how an AI system will execute at a macro
    or micro level. Regarding robotics, behavior trees will typically be designed
    to operate at the micro level, where each action or condition is a small event,
    such as detecting the apple. Conversely, behavior trees can also control more
    macro systems, such as NPCs in games, where each action may be a combination of
    events, like attacking the player.
  prefs: []
  type: TYPE_NORMAL
- en: For agentic systems, behavior trees support controlling an agent or assistant
    at your chosen level. We’ll explore controlling agents at the task and, in later
    chapters, the planning levels. After all, with the power of LLMs, agents can construct
    their own behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, several other forms of AI control could be used to control agentic
    systems. The next section will examine those different systems and compare them
    to behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2 Deciding on behavior trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numerous other AI control systems have benefits and are worth exploring in controlling
    agentic systems. They can demonstrate the benefits of behavior trees and provide
    other options for specific use cases. The behavior tree is an excellent pattern,
    but it isn’t the only one, and it’s worth learning about others.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.2 highlights several other systems we may consider for controlling AI
    systems. Each item in the table describes what the method does, its shortcomings,
    and its possible application to agentic AI control.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.2 Comparison of other AI control systems
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Control name | Description | Shortcomings | Control agentic AI? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Finite state machine ^a (FSM)  | FSMs model AI using a set of states and
    transitions triggered by events or conditions.  | FSMs can become unwieldy with
    increasing complexity.  | FSMs aren’t practical for agents because they don’t
    scale well.  |'
  prefs: []
  type: TYPE_TB
- en: '| Decision tree ^b  | Decision trees use a tree-like model of decisions and
    their possible consequences.  | Decision trees can suffer from overfitting and
    lack generalization in complex scenarios.  | Decision trees can be adapted and
    enhanced with behavior trees.  |'
  prefs: []
  type: TYPE_TB
- en: '| Utility-based system ^b  | Utility functions evaluate and select the best
    action based on the current situation.  | These systems require careful design
    of utility functions to balance priorities.  | This pattern can be adopted within
    a behavior tree.  |'
  prefs: []
  type: TYPE_TB
- en: '| Rule-based system ^a  | This set of if-then rules define the behavior of
    the AI.  | These systems can become cumbersome with many rules, leading to potential
    conflicts.  | These aren’t very practical when paired with agentic systems powered
    by LLMs.  |'
  prefs: []
  type: TYPE_TB
- en: '| Planning system ^c  | Planning systems generate a sequence of actions to
    achieve a specific goal using planning algorithms.  | These systems are computationally
    expensive and require significant domain knowledge.  | Agents can already implement
    such patterns on their own as we’ll see in later chapters.  |'
  prefs: []
  type: TYPE_TB
- en: '| Behavioral cloning ^c  | Behavioral cloning refers to learning policies by
    mimicking expert demonstrations.  | This system may struggle with generalization
    to unseen situations.  | This can be incorporated into behavior trees or into
    a specific task.  |'
  prefs: []
  type: TYPE_TB
- en: '| Hierarchical Task Network (HTN) ^d  | HTNs decompose tasks into smaller,
    manageable subtasks arranged in a hierarchy.  | These are complex to manage and
    design for very large tasks.  | HTNs allow for better organization and execution
    of complex tasks. This pattern can be used for larger agentic systems.  |'
  prefs: []
  type: TYPE_TB
- en: '| Blackboard system ^b  | These systems feature collaborative problem-solving
    using a shared blackboard for different subsystems.  | These systems are difficult
    to implement and manage communication between subsystems.  | Agentic systems can
    implement similar patterns using conversation or group chats/threads.  |'
  prefs: []
  type: TYPE_TB
- en: '| Genetic algorithm (GA) ^d  | These optimization techniques are inspired by
    natural selection to evolve solutions to solve problems.  | GAs are computationally
    intensive and may not always find the optimal solution.  | GAs have potential
    and could even be used to optimize behavior trees.  |'
  prefs: []
  type: TYPE_TB
- en: '| ^a Not practical when considering complex agentic systems ^b Exists in behavior
    trees or can easily be incorporated'
  prefs: []
  type: TYPE_NORMAL
- en: ^c Typically applied at the task or action/condition level
  prefs: []
  type: TYPE_NORMAL
- en: ^d Advanced systems that would require heavy lifting when applied to agents
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters of this book, we’ll investigate some of the patterns discussed
    in table 6.2\. Overall, several patterns can be enhanced or incorporated using
    behavior trees as the base. While other patterns, such as FSMs, may be helpful
    for small experiments, they lack the scalability of behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behavior trees can provide several benefits as an AI control system, including
    scalability. The following list highlights other notable benefits of using behavior
    trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Modularity and reusability*—Behavior trees promote a modular approach to designing
    behaviors, allowing developers to create reusable components. Nodes in a behavior
    tree can be easily reused across different parts of the tree or even in different
    projects, enhancing maintainability and reducing development time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scalability*—As systems grow in complexity, behavior trees handle the addition
    of new behaviors more gracefully than other methods, such as FSMs. Behavior trees
    allow for the hierarchical organization of tasks, making it easier to manage and
    understand large behavior sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flexibility and extensibility*—Behavior trees offer a flexible framework where
    new nodes (actions, conditions, decorators) can be added without drastically altering
    the existing structure. This extensibility makes it straightforward to introduce
    new behaviors or modify existing ones to adapt to new requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugging and visualization*—Behavior trees provide a clear and intuitive
    visual representation of behaviors, which is beneficial for debugging and understanding
    the decision-making process. Tools that support behavior trees often include graphical
    editors that allow developers to visualize and debug the tree structure, making
    it easier to identify and fix problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Decoupling of decision logic*—Behavior trees separate the decision-making
    and execution logic, promoting a clear distinction between high-level strategy
    and low-level actions. This decoupling simplifies the design and allows for more
    straightforward modifications and testing of specific behavior parts without affecting
    the entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having made a strong case for behavior trees, we should now consider how to
    implement them in code. In the next section, we look at how to build a simple
    behavior tree, using Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.3 Running behavior trees with Python and py_trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because behavior trees have been around for so long and have been incorporated
    into many technologies, creating a sample demonstration is very simple. Of course,
    the easiest way is to ask ChatGPT or your favorite AI chat tool. Listing 6.1 shows
    the result of using a prompt to generate the code sample and submitting figure
    6.1 as the example tree. The final code had to be corrected for simple naming
    and parameter errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note  All the code for this chapter can be found by downloading the GPT Assistants
    Playground project at [https://mng.bz/Ea0q](https://mng.bz/Ea0q).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.1 `first_btree.py`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a class to implement an action or condition'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates the action and condition nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Adds the nodes to their respective parents'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Creates the action and condition nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Creates the whole behavior tree'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Executes one step/tick on the behavior tree'
  prefs: []
  type: TYPE_NORMAL
- en: The code in listing 6.1 represents the behavior tree in figure 6.1\. You can
    run this code as is or alter what the conditions return and then run the tree
    again. You can also change the behavior tree by removing one of the sequence nodes
    from the root selector.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of behavior trees, we can move on to
    working with agents/assistants. Before doing that, we’ll look at a tool to help
    us work with OpenAI Assistants. This tool will help us wrap our first ABTs around
    OpenAI Assistants.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Exploring the GPT Assistants Playground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the development of this book, several GitHub projects were created to address
    various aspects of building agents and assistants. One such project, the GPT Assistants
    Playground, is built using Gradio for the interface that mimics the OpenAI Assistants
    Playground but with several extras added.
  prefs: []
  type: TYPE_NORMAL
- en: The Playground project was developed as both a teaching and demonstration aid.
    Inside the project, the Python code uses the OpenAI Assistants API to create a
    chat interface and an agentic system to build and power assistants. There is also
    a comprehensive collection of actions assistants you can use, and you can easily
    add your own actions.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Installing and running the Playground
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following listing shows installing and running the Playground project from
    the terminal. There is currently no PyPI package to install.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.2 Installing the GPT Assistants Playground
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Pulls the source code from GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Changes directory to the project source code folder'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Installs the requirements'
  prefs: []
  type: TYPE_NORMAL
- en: You can run the application from the terminal or using Visual Studio Code (VS
    Code), with the latter giving you more control. Before running the application,
    you need to set your OpenAI API key through the command line or by creating an
    `.env` file, as we’ve done a few times already. Listing 6.3 shows an example of
    setting the environment variable on Linux/Mac or the Git Bash shell (Windows recommended)
    and running the application.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.3 Running the GPT Assistants Playground
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets your API key as an environment variable'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Runs the app from the terminal or via VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser to the URL displayed (typically `http://127.0.0.1:7860`) or
    what is mentioned in the terminal. You’ll see an interface similar to that shown
    in figure 6.3\. If you’ve already defined the OpenAI Assistants, you’ll see them
    in the Select Assistant dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 The GPT Assistants Playground interface being used to learn math
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’ve never defined an assistant, you can create one and choose the various
    options and instructions you need. If you’ve visited the OpenAI Playground, you’ve
    already experienced a similar interface.
  prefs: []
  type: TYPE_NORMAL
- en: GPT vs. an assistant
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: OpenAI defines a GPT as the assistant you can run and use within the ChatGPT
    interface. An assistant can only be consumed through the API and requires custom
    code in most cases. When you run an assistant, you’re charged according to the
    model token usage and any special tools, including the Code Interpreter and files,
    whereas a GPT runs within ChatGPT and is covered by account costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for creating a local version of the Playground was an exercise to
    demonstrate the code structure but also provide additional features listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Actions (custom actions)*—Creating your own actions allows you to add any
    functionality you want to an assistant. As we’ll see, the Playground makes it
    very easy to create your own actions quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code runner*—The API does come with a Code Interpreter, but it’s relatively
    expensive ($.03 per run), doesn’t allow you to install your modules, can’t run
    code interactively, and runs slowly. The Playground will enable you to run Python
    code locally in an isolated virtual environment. While not as secure as pushing
    code out to Docker images, it does execute code windowed and out of process better
    than other platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transparency and logging*—The Playground provides for comprehensive capturing
    of logs and will even show how the assistant uses internal and external tools/actions.
    This can be an excellent way to see what the assistant is doing behind the scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these features is covered in more detail over the next few sections.
    We’ll start with a look at using and consuming actions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Using and building custom actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actions and tools are the building blocks that empower agents and assistants.
    Without access to tools, agents are functionless chatbots. The OpenAI platform
    is a leader in establishing many of the patterns for tools, as we saw in chapter
    3.
  prefs: []
  type: TYPE_NORMAL
- en: The Playground provides several custom actions that can be attached to assistants
    through the interface. In this next exercise, we’ll build a simple assistant and
    attach a couple of custom actions to see what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 shows the expanded Actions accordion, which displays many available
    custom actions. Run the Playground from the terminal or debugger, and create a
    new assistant. Then, select the actions shown in the figure. After you’re done
    selecting the actions, scroll to the bottom, and click Add Assistant to add the
    assistant. Assistants need to be created before they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 Selecting and using custom actions in the interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After you create the assistant, you can ask it to list all available assistants.
    Listing the assistants also gives you the IDs required to call the assistant.
    You can also call other assistants and ask them to complete tasks in their area
    of specialization.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your custom actions is as simple as adding code to a file and dropping
    it in the right folder. Open the `playground/assistant_actions` folder from the
    main project folder, and you’ll see several files that define the various actions.
    Open the `file_actions.py` file in VS Code, as shown in listing 6.4.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.4 `playground/assistant_actions/file_actions.py`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This decorator automatically adds the function as an action.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Give your functions clear names that align with the purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The description is what the assistant uses to determine the function, so
    document it well.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Generally returns a message stating success or failure'
  prefs: []
  type: TYPE_NORMAL
- en: You can add any custom action you want by placing the file in the `assistant_actions`
    folder and decorating it with the `agent_action` decorator. Just make sure to
    give the function a good name and enter quality documentation for how the function
    should be used. When the Playground starts up, it loads all the actions in the
    folder that are decorated correctly and have descriptions/documentation.
  prefs: []
  type: TYPE_NORMAL
- en: It’s that simple. You can add several custom actions as needed. In the next
    section, we’ll look at a special custom action that allows the assistant to run
    code locally.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.3 Installing the assistants database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run several of the examples in this chapter, you’ll need to install the
    assistants database. Fortunately, this can be easily done through the interface
    and just by asking agents. The upcoming instructions detail the process for installing
    the assistants and are taken directly from the GPT Assistants Playground README.
    You can install several of the demo assistants located in the `assistants.db`
    SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new assistant, or use an existing assistant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the assistant the `create_manager_assistant` action (found under the Actions
    section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the assistant to create the manager assistant (i.e., “please create the
    manager assistant”), and be sure to name the assistant “Manager Assistant.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh your browser to reload the assistants selector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the new Manager Assistant. This assistant has the instructions and actions
    that will allow it to install assistants from the `assistants.db` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Talk to the Manager Assistant to give you a list of assistants to install, or
    just ask the Manager Assistant to install all available assistants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6.2.4 Getting an assistant to run code locally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting agents and assistants to generate and run executable code has a lot
    of power. Unlike the Code Interpreter, running code locally provides numerous
    opportunities to iterate and tune quickly. We saw this earlier with AutoGen, where
    the agents could keep running the code until it worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the Playground, it’s a simple matter to select the custom action `run_code`,
    as shown in figure 6.5\. You’ll also want to choose the `run_shell_command` action
    because it allows the assistant to `pip install` any required modules.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 Selecting custom actions for the assistant to run Python code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can now ask an assistant to generate and run the code to be sure it works
    on your behalf. Try this out by adding the custom actions and asking the assistant
    to generate and run code, as shown in figure 6.6\. If the code doesn’t work as
    expected, tell the assistant what problems you encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 Getting the assistant to generate and run Python code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Again, the Python code running in the Playground creates a new virtual environment
    in a project subfolder. This system works well if you’re not running any operating
    system–level code or low-level code. If you need something more robust, a good
    option is AutoGen, which uses Docker containers to run isolated code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding actions to run code or other tasks can make assistants feel like a black
    box. Fortunately, the OpenAI Assistants API allows you to consume events and see
    what the assistant is doing behind the scenes. In the next section, we’ll see
    what this looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.5 Investigating the assistant process through logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenAI added a feature into the Assistants API that allows you to listen to
    events and actions chained through tool/action use. This feature has been integrated
    into the Playground, capturing action and tool use when an assistant calls another
    assistant.
  prefs: []
  type: TYPE_NORMAL
- en: We can try this by asking an assistant to use a tool and then open the log.
    A great example of how you can do this is by giving an assistant the Code Interpreter
    tool and then asking it to plot an equation. Figure 6.7 shows an example of this
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 Internal assistant logs being captured
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Usually, when the Assistant Code Interpreter tool is enabled, you don’t see
    any code generation or execution. This feature allows you to see all tools and
    actions used by the assistant as they happen. Not only is it an excellent tool
    for diagnostics, but it also provides additional insights into the functions of
    LLMs.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t reviewed the code to do all this because it’s extensive and will
    likely undergo several changes. That being said, if you plan on working with the
    Assistants API, this project is a good place to start. With the Playground introduced,
    we can continue our journey into ABTs in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Introducing agentic behavior trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Agentic behavior trees (ABTs) implement behavior trees on assistant and agent
    systems. The key difference between regular behavior trees and ABTs is that they
    use prompts to direct actions and conditions. Because prompts may return a high
    occurrence of random results, we could also name these trees *stochastic* behavior
    trees, which do exist. For simplicity, we’ll differentiate behavior trees used
    to control agents, referring to them as agentic.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll undertake an exercise to create an ABT. The finished tree will be
    written in Python but will require the setup and configuration of various assistants.
    We’ll cover how to manage assistants using the assistants themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.1 Managing assistants with assistants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fortunately, the Playground can help us quickly manage and create the assistants.
    We’ll first install the Manager Assistant, followed by installing the predefined
    assistants. let’s get started with installing the Manager Assistant using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Playground in your browser, and create a new simple assistant or use an
    existing assistant. If you need a new assistant, create it and then select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the assistant selected, open the Actions accordion, and select the `create_
    manager_assistant` action. You don’t need to save; the interface will update the
    assistant automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the chat interface, prompt the assistant with the following: “Please
    create the manager assistant.”'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a few seconds, the assistant will say it’s done. Refresh your browser,
    and confirm that the Manager Assistant is now available. If, for some reason,
    the new assistant isn’t shown, try restarting the Gradio app itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Manager Assistant is like an admin that has access to everything. When
    engaging the Manager Assistant, be sure to be specific about your requests. With
    the Manager Assistant active, you can now install new assistants used in the book
    using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Manager Assistant. If you’ve modified the Manager Assistant, you
    can delete it and reinstall it anytime. Although it’s possible to have multiple
    Manager Assistants, it’s not recommended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ask the Manager Assistant what assistants can be installed by typing the following
    in the chat interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '3\. Identify which assistant you want installed when you ask the Manager Assistant
    to install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can manage and install any available assistants using the Playground. You
    can also ask the Manager Assistant to save the definitions of all your assistants
    as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Manager Assistant can access all actions, which should be considered unique
    and used sparingly. When crafting assistants, it’s best to keep them goal specific
    and limit the actions to just what they need. This not only avoids giving the
    AI too many decisions but also avoids accidents or mistakes caused by hallucinations.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through the remaining exercises in this chapter, you’ll likely need
    to install the required assistants. Alternatively, you can ask the Manager Assistant
    to install all available assistants. Either way, we look at creating an ABT with
    assistants in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.2 Building a coding challenge ABT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coding challenges provide a good baseline for testing and evaluating agent and
    assistant systems. Challenges and benchmarks can quantify how well an agent or
    agentic system operates. We already applied coding challenges to multi-platform
    agents in chapter 4 with AutoGen and CrewAI.
  prefs: []
  type: TYPE_NORMAL
- en: For this coding challenge, we’re going a little further and looking at Python
    coding challenges from the Edabit site ([https://edabit.com](https://edabit.com)),
    which range in complexity from beginner to expert. We’ll stick with the expert
    code challenges because GPT-4o and other models are excellent coders. Look at
    the challenge in the next listing, and think about how you would solve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.5 Edabit challenge: Plant the Grass'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use any challenge or coding exercise you want, but here are a few things
    to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The challenge should be testable with quantifiable assertions (pass/fail).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid opening windows when asking for a game, building a website, or using another
    interface. At some point, testing full interfaces will be possible, but for now,
    it’s just text output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid long-running challenges, at least initially. Start by keeping the challenges
    concise and short lived.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with any challenge, you’ll also want a set of tests or assertions to confirm
    the solution works. On Edabit, a challenge typically provides a comprehensive
    set of tests. The following listing shows the additional tests provided with the
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.6 Plant the Grass tests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The tests will be run as part of a two-step verification to confirm that the
    solution works. We’ll also use the tests and challenges as written, which will
    further test the AI.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 shows the makeup of a straightforward behavior tree that will be
    used to solve various programming challenges. You’ll notice that this ABT uses
    a different assistant for the actions and conditions. For the first step, the
    Python coding assistant (called the Hacker) generates a solution that is then
    reviewed by the coding challenge Judge (called the Judge), which produces a refined
    solution that is verified by a different Python coding assistant (called the Verifier).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 The ABT for the coding challenge
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Figure 6.8 also shows how each agent converses on which thread. Assistants use
    message threads, similar to a Slack or Discord channel, where all assistants conversing
    on a thread will see all messages. For this ABT, we keep one main conversation
    thread for the Hacker and Judge to share messages, while the Verifier works on
    a separate message thread. Keeping the Verifier on its own thread isolates it
    from the noise of the solution-solving efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Now, building the ABT in code is a matter of combining the `py_trees` package
    and the Playground API functions. Listing 6.7 shows an excerpt of code that creates
    each of the action/condition nodes with the assistants and gives them the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.7 `agentic_btree_coding_challenge.py`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a message thread that will be shared by the Hacker and Judge'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The challenge as shown in the example listing 6.5'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The tests as shown in the example listing 6.6'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Creates a message thread that will be shared by the Hacker and Judge'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 The challenge as shown in the example listing 6.5'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Creates a message thread that will be shared by the Hacker and Judge'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 The challenge as shown in the example listing 6.5'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 The tests as shown in the example listing 6.6'
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Call creates a new message thread'
  prefs: []
  type: TYPE_NORMAL
- en: '#10 The challenge as shown in the example listing 6.5'
  prefs: []
  type: TYPE_NORMAL
- en: '#11 The tests as shown in the example listing 6.6'
  prefs: []
  type: TYPE_NORMAL
- en: '#12 The sleep time can be adjusted up or down as needed and can be used to
    throttle the messages sent to an LLM.'
  prefs: []
  type: TYPE_NORMAL
- en: '#13 The process will continue until the verification succeeds.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the ABT by loading the file in VS Code or using the command line. Follow
    the output in the terminal, and watch how the assistants work through each step
    in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: If the solution fails to be verified at the condition node, the process will
    continue per the tree. Even with this simple solution, you could quickly create
    numerous variations. You could extend the tree with more nodes/steps and subtrees.
    Perhaps you want a team of Hackers to break down and analyze the challenge, for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: This example’s work is done mainly with the Playground code, using the helper
    functions `create_assistant_condition` and `create_assistant_action_on_thread`.
    This code uses a couple of classes to integrate the `py_trees` behavior tree code
    and the OpenAI Assistants code wrapped in the Playground. Review the code within
    the project if you want to understand the lower-level details.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.3 Conversational AI systems vs. other methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already looked at conversational multi-agent systems in chapter 4 when we
    looked at AutoGen. The ABT can work using a combination of conversations (over
    threads) and other methods, such as file sharing. Having your assistants/agents
    pass files around helps reduce the number of noisy and repetitive thoughts/conversations.
    In contrast, conversational systems benefit from potential emergent behaviors.
    So, using both can help evolve better control and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The simple solution in listing 6.7 could be extended to handle more real-world
    coding challenges and perhaps even to work as a coding ABT. In the next section,
    we build a different ABT to handle a different problem.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.4 Posting YouTube videos to X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section’s exercise, we look at an ABT that can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Search for videos on YouTube for a given topic and return the latest videos.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the transcripts for all the videos your search provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summarize the transcripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the summarized transcripts and select a video to write an X (formerly
    Twitter) post about.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an exciting and engaging post about the video, ensuring it’s less than
    280 characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the post and then post it on X.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.9 shows the ABT assembled with each of the different assistants. In
    this exercise, we use a sequence node for the root, and each assistant performs
    a different action. Also, to keep things simple, each assistant interaction will
    always occur in a new thread. This isolates each assistant’s interaction into
    a concise conversation that’s easier to debug if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 The YouTube social media ABT
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 6.3.5 Required X setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you plan to run the code in this exercise, you must add your X credentials
    to the `.env` file. The `.env.default` file shows an example of how the credentials
    need to be, as shown in listing 6.8\. You don’t have to enter your credentials.
    This means the last step, posting, will fail, but you can still look at the file
    (`youtube_twitter_post.txt`) to see what was generated.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.8 Configuring credentials
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: YouTube search and spam
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you plan to run this exercise for real and let it post to your X account,
    be aware that YouTube has a bit of a spam problem. The assistants have been configured
    to try to avoid video spam, but some of it may get through. Building a working
    ABT that can wade through videos while avoiding spam has some suitable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.9 shows just the code for creating the assistant actions. This ABT
    uses three different assistants, each with its own task instructions. Note that
    each assistant has a unique set of instructions defining its role. You can review
    the instructions for each assistant by using the Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.9 `agentic_btree_video_poster_v1.py`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the code as you normally would, and after a few minutes, a new post will
    appear in the `assistants_output` folder. Figure 6.10 shows an example of a post
    generated using this ABT. Running this ABT to generate more than a few posts a
    day could, and likely will, get your X account blocked. If you’ve configured X
    credentials, you’ll see the post appear on your feed.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 A sample X post from the ABT
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This ABT is shown for demonstration purposes and isn’t for production or long-term
    use. The primary features of this demonstration are to show search and loading
    data, summarization and filtering, then generating new content, and finally highlighting
    multiple custom actions and integrations with APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Building conversational autonomous multi-agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The conversational aspect of multi-agent systems can drive mechanisms such as
    feedback, reasoning, and emergent behaviors. Driving agents with ABTs that silo
    assistants/agents can be effective for controlling structured processes, as we
    saw in the YouTube posting example. However, we also don’t want to miss out on
    the benefits of conversation across agents/assistants.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the Playground provides methods to silo or join assistants to conversation
    threads. Figure 6.11 shows how assistants can be siloed or mixed in various combinations
    to threads. Combining silos with conversation provides the best of both patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/6-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 The various layouts of siloed and conversational assistants
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll examine a simple but practical exercise to demonstrate the effectiveness
    of the conversational pattern. For the next exercise, we’ll employ two assistants
    in an ABT that converse over the same thread. The next listing shows the tree’s
    construction in code with the respective assistants.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.10 `agentic_conversation_btree.py`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a message thread for the assistants to share and converse over'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates the debug code action with a special assistant'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates the verification condition to test if the code is fixed or not'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The tree will continue to run until the root sequence completes with success.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three nodes comprise the tree: the root sequence, the debug code action, and
    the verify fix condition. Because the tree’s root is a sequence, the two assistants
    will continue to work one after another until they both return with success. Both
    assistants converse on the same thread and yet are controlled in a manner that
    provides constant feedback.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the exercise by loading the file in VS Code, or execute it directly from
    the command line. The example code has a few minor bugs and problems that the
    assistants will work through to fix. After the ABT completes running successfully,
    you can open the `assistants_output/fixed_bug.py` file and verify the results
    are all good.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen a couple of ABTs in action and understand the nuances of using
    silos or conversations. The following section will teach you some techniques for
    building your own ABTs.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Building ABTs with back chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back chaining is a method derived from logic and reasoning used to help build
    behavior trees by working backward from the goal. This section will use the back
    chaining process to construct an ABT that works to achieve the goal. The following
    list provides a description of the process in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Identify goal behavior*. Start with the behavior you want the agent to perform.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Determine the required actions*. Identify the actions that lead to the goal
    behavior.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Identify the conditions*. Determine the conditions that must be met for each
    action to succeed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Determine the mode of communication*. Determine how the assistants will pass
    on information. Will the assistants be siloed or converse over threads, or is
    a combination of patterns better?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Construct the tree.* Start by building the behavior tree from the goal behavior,
    adding nodes for actions and conditions recursively until all necessary conditions
    are linked to known states or facts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behavior trees typically use a pattern called the *blackboard* to communicate
    across nodes. Blackboards, like those in `py_trees`, use a key/value store to
    save information and make it accessible across nodes. It also provides for several
    controls, such as limiting access to specific nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We deferred to using files for communication because of their simplicity and
    transparency. At some point, agentic systems are expected to consume much more
    information and in different formats than those designed for blackboards. Blackboards
    must either become more sophisticated or be integrated with file storage solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build an ABT using back chaining. We could tackle a variety of goals,
    but one interesting and perhaps meta goal is to build an ABT that helps build
    assistants. So let’s first present our goal as a statement “Create an assistant
    that can help me do {task}”:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Required actions*: (working backwards)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify the assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Name the assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Give the assistant the relevant instructions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identified condition:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify the assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Determine communication patterns*: To keep things interesting, we’ll run all
    assistants on the same message thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Construct the tree*: To construct the tree, let’s first reverse the order
    of actions and mark each of the element’s actions and conditions accordingly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (action) Give the assistant relevant instructions to help a user with a given
    task.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (action) Name the assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (action) Test the assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (condition) Verify the assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (action) Create the assistant.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the simple solution to building the tree now is to ask ChatGPT or
    an otherwise capable model. The result of asking ChatGPT to make the tree is shown
    in the next listing. You could also work the tree out independently and perhaps
    introduce other elements.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.11 ABT for building an assistant
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From this point, we can start building the tree by iterating over each action
    and condition node and determining what instructions the assistant needs. This
    can also include any tools and custom actions, including ones you may need to
    develop. On your first pass, keep the instructions generic. Ideally, we want to
    create as few assistants as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'After determining the assistant, tools, and actions for each assistant and
    for which task, you can try to generalize things further. Think about where it
    may be possible to combine actions and reduce the number of assistants. It’s better
    to start evaluating with insufficient assistants than with too many. However,
    be sure to maintain the proper divisions of work as tasks: for example, testing
    and verification are best done with different assistants.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complete the following exercises to improve your knowledge of the material:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Exercise 1*—Creating a Travel Planner ABT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Objective *—Build an agentic behavior tree (ABT) to plan a travel itinerary
    using assistants.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tasks*:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the GPT Assistants Playground on your local machine.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an ABT to plan a travel itinerary. The tree should have the following
    structure:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Travel assistant to gather information about potential destinations.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Itinerary Planner to create a day-by-day travel plan.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Condition: Verify the completeness and feasibility of the itinerary using another
    Travel Assistant.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement and run the ABT to create a complete travel itinerary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Exercise 2*—Building an ABT for Customer Support Automation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Objective *—Create an ABT that automates customer support responses using
    assistants.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tasks*:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the GPT Assistants Playground on your local machine.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an ABT with the following structure:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Customer Query Analyzer assistant to categorize customer queries.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Response Generator assistant to draft responses based on the
    query categories.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Customer Support assistant to send the responses to customers.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement and run the ABT to automate the process of analyzing and responding
    to customer queries.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Exercise 3*—Managing Inventory with an ABT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Objective *—Learn how to create and manage inventory levels using an ABT.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tasks*:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the GPT Assistants Playground on your local machine.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an ABT that manages inventory for a retail business:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Inventory Checker assistant to review current stock levels.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Order assistant to place orders for low-stock items.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Condition: Verify that orders have been placed correctly and update inventory
    records.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement and run the ABT to manage inventory dynamically.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Exercise 4*—Creating a Personal Fitness Trainer ABT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Objective *—Create an ABT that provides personalized fitness training plans
    using assistants.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tasks*:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the GPT Assistants Playground on your local machine.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an ABT to develop a personalized fitness plan:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Fitness Assessment assistant to evaluate the user’s current
    fitness level.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action: Use the Training Plan Generator to create a custom fitness plan based
    on the assessment.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Condition: Verify the plan’s suitability and safety using another Fitness assistant.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement and run the ABT to generate and validate a personalized fitness training
    plan.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Exercise 5*—Using Back Chaining to Build a Financial Advisor ABT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Objective *—Apply back chaining to construct an ABT that provides financial
    advice and investment strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tasks*:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the GPT Assistants Playground on your local machine.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define the following goal: “Create an assistant that can provide financial
    advice and investment strategies.”'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using back chaining, determine the actions and conditions needed to achieve
    this goal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement and run the ABT to generate a comprehensive financial advisory service
    by back chaining the construction of the base actions and conditions for the tree.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behavior trees are a robust and scalable AI control pattern, first introduced
    in robotics by Rodney A. Brooks. They are widely used in gaming and robotics for
    their modularity and reusability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The primary nodes in behavior trees are the selector, sequence, condition,
    action, decorator, and parallel nodes. Selectors are like “or” blocks: sequence
    executes nodes in sequence, condition tests the state, action does the work, decorator
    is a wrapper, and parallel nodes allow for dual execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the execution flow of behavior trees can be critical to designing,
    building, and operating them to provide control for making clear decision-making
    paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of behavior trees include modularity, scalability, flexibility,
    debugging ease, and decoupling of decision logic, making behavior trees suitable
    for complex AI systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and running a simple behavior tree in Python requires correctly naming
    and documenting custom nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GPT Assistants Playground project is a Gradio-based interface that mimics
    the OpenAI Assistants Playground with additional features for teaching and demonstrating
    ABTs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GPT Assistants Playground allows for creating and managing custom actions,
    which is essential for building versatile assistants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ABTs control agents and assistants by using prompts to direct actions and conditions
    for assistants. ABTs use the power of LLMs to create dynamic and autonomous systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back chaining is a method for constructing behavior trees by working backward
    from the goal behavior. This process involves identifying required actions, conditions,
    and communication patterns, and then constructing the tree step by step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agentic systems benefit from siloed and conversation patterns for communicating
    between entities. ABTs can benefit from combining siloed and conversational assistants
    to use structured processes and emergent behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
