<html><head></head><body>
  <h1 class="tochead" id="heading_id_2">2 <a id="idTextAnchor000"/><a id="idTextAnchor001"/><a id="idTextAnchor002"/><a id="idTextAnchor003"/><a id="idTextAnchor004"/>Getting started with large language models</h1>

  <p class="co-summary-head">This chapter covers<a id="idIndexMarker000"/><a id="marker-12"/></p>

  <ul class="calibre5">
    <li class="co-summary-bullet">Engaging with ChatGPT</li>

    <li class="co-summary-bullet">Learning the basics of using Copilot</li>

    <li class="co-summary-bullet">Learning the basics of using CodeWhisperer</li>

    <li class="co-summary-bullet">Exploring prompt engineering patterns</li>

    <li class="co-summary-bullet">Contrasting the differences between these three Generative AI offerings</li>
  </ul>

  <p class="body">In this chapter, we embark on a practical journey through the landscape of Generative AI, harnessing the power of three groundbreaking tools: ChatGPT, GitHub Copilot, and AWS CodeWhisperer. As we navigate the intricacies of these technologies, we’ll apply them to a series of challenging scenarios modeled after the rigorous interview questions posed by leading tech giants. Whether you’re a seasoned developer or a curious enthusiast, prepare to unlock innovative strategies that could give you the edge in your next technical interview. Get ready to transform abstract concepts into tangible solutions right at the forefront of AI’s evolving role in tech hiring.</p>

  <p class="body">We will begin by using two currently available models for ChatGPT: GPT-4 and GPT-3.5. The purpose is twofold: it will allow us to appreciate the engagement model of ChatGPT, and it will also let us establish a baseline against which we can compare and contrast the other two. Using two models will also allow us to appreciate the generational sea change between these model versions. Finally, throughout this chapter, we will use some common patterns in prompt engineering.</p>

  <h2 class="fm-head" id="heading_id_3">2.1 A foray into ChatGPT</h2>

  <p class="body"><a id="marker-13"/>Context is one of the most important aspects of working with ChatGPT. Your previous <i class="fm-italics">prompts</i> can drastically change the results from your current prompt. In language models like ChatGPT, a prompt refers to the input provided to the model to generate a response. It can be a single sentence, a paragraph, or even a longer text. It serves as the instruction or query to the model, guiding its response. Given the quality of the prompt and the context in which the model responds, it is essential always to be aware of the prompts you have issued in the current session. Therefore, starting with a new session every time you begin a new project is advised. Appendix A will walk you through setting up an account, logging in to ChatGPT, and writing your first prompt.<a id="idIndexMarker001"/><a id="idIndexMarker002"/></p>

  <h3 class="fm-head1" id="heading_id_4">2.1.1 Navigating nuances with GPT-4</h3>

  <p class="body">In this section, we will work toward finding a solution to the following question: “How would you reserve a singly linked list in Python?” <a id="idIndexMarker003"/><a id="idIndexMarker004"/><a id="idIndexMarker005"/><a id="idIndexMarker006"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">What is a singly linked list?</p>

    <p class="fm-sidebar-text">A <i class="fm-italics">singly linked list</i> is a fundamental data structure in computer science that consists of a sequence of elements, each stored in a node. Generally, singly linked lists consist of nodes in which the data is stored and a reference to the next node in the linked list. <a id="idIndexMarker007"/></p>

    <p class="fm-sidebar-text">With a singly linked list, you can only travel in one direction. Common operations on a singly linked list include insertion (adding a new node), deletion (removing a node), searching (finding a node), and traversal (accessing each node sequentially).</p>
  </div>

  <p class="body">We will start with this simple prompt:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">Going forward, when I ask a question, try to formulate a better question. As an intern who studied computer science in college, how would you define a singly linked list in pseudocode?</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Okay, this may not be such a simple prompt. First, we have directed ChatGPT to enhance and reformulate our questions based on its training data so we will get better prompts. Better prompts make for better output. You may be asking, what makes for a better prompt? Great question! General prompts produce general results. Specific prompts produce specific results. As we engage with large language models (LLMs) generally and ChatGPT specifically, we will go from general to specific, refining the output as we go. This is known as the <i class="fm-italics">Refinement Pattern in prompt engineering</i>: iteratively refining or improving the prompt to get more accurate, relevant, or sophisticated responses. <a id="idIndexMarker008"/></p>

  <p class="body"><a id="marker-14"/>The second part of the prompt introduces a prompting pattern we will see throughout this book: the <i class="fm-italics">Persona Pattern</i>. In the context of prompt engineering, mainly related to AI and LLMs, the Persona Pattern refers to a strategy of designing prompts that establish a specific persona or role for the AI to assume. This approach guides the model’s responses consistently and contextually appropriately. One of the key benefits of using the Persona Pattern is maintaining consistency in responses. Adhering to a defined persona makes the AI’s replies more predictable and aligned with the user’s expectations. In this case, we have asked ChatGPT to assume the persona of an intern with a background in computer science. Why an intern? We want a persona who will do the work. <a id="idIndexMarker009"/></p>

  <p class="body">It bears repeating that when working with LLMs, even when applying personas, the same input will not always produce the same output. For this reason, your output may not match the following exactly, but hopefully it is similar. (Note that these listings are pseudocode.)</p>

  <p class="fm-code-listing-caption">Listing 2.1 ChatGPT’s reformulation of our question about reversing a linked list</p>
  <pre class="programlisting">As a computer science intern, how can I define a singly linked list's structure and basic operations using pseudocode? This definition should include the essential components of the list, such as nodes and links, and outline fundamental operations like creating a node, adding a node to the list, and traversing the list.</pre>

  <p class="body">When asked the refined question, ChatGPT will provide the following code listing.</p>

  <p class="fm-code-listing-caption">Listing 2.2 ChatGPT’s answer about how to reverse a linked list</p>
  <pre class="programlisting">#Node Structure
class Node
    data
    nextNode
  
    Constructor(data)
        this.data = data
        this.nextNode = NULL
   #Singly Linked List Structure
class SinglyLinkedList
    head
  
    Constructor()
        this.head = NULL
  
    Function AddToFront(data)
        newNode = new Node(data)
        newNode.nextNode = this.head
        this.head = newNode
  
    Function Append(data)
        newNode = new Node(data)
        if this.head is NULL
            this.head = newNode
            return
        end if
  
        lastNode = this.head
        while lastNode.nextNode is not NULL
            lastNode = lastNode.nextNode
        end while
  
        lastNode.nextNode = newNode
  
    Function Traverse()
        currentNode = this.head
        while currentNode is not NULL
            print currentNode.data
            currentNode = currentNode.nextNode
        end while</pre>

  <p class="body">One of the excellent quality-of-life-enhancing features of working with ChatGPT is that it will usually provide documentation about the code in question. Figure 2.1 is a screenshot of the textual description provided by ChatGPT.<a id="marker-15"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH02_F01_Crocker2.png"/></p>

    <p class="figurecaption">Figure 2.1 ChatGPT Model 4’s explanation of the pseudocode definition of a singly linked list</p>
  </div>

  <p class="body">We will now have ChatGPT assume a new role—that of a computer science intern:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">As an intern with a background in computer science, how would you define the structure and basic operations of a singly linked list using the programming language Python? This definition should include the essential components of the list, such as nodes and links, and outline fundamental operations like creating a node, adding a node to the list, and traversing the list.</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="fm-code-listing-caption">Listing 2.3 ChatGPT’s implementation of a singly linked list in Python</p>
  <pre class="programlisting">class ListNode:
    def __init__(self, value):
        self.value = value
        self.next = None
  
class SinglyLinkedList:
    def __init__(self):
        self.head = None  # The list initially has no nodes
  
    def append(self, value):
        """ Append a new node at the end of the list """
        if not self.head:
            self.head = ListNode(value)
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = ListNode(value)
  
    def prepend(self, value):
        """ Prepend a new node at the beginning of the list """
        new_node = ListNode(value)
        new_node.next = self.head
        self.head = new_node
  
    def traverse(self):
        """ Traverse the list and print each node's value """
        current = self.head
        while current:
            print(current.value, end=" -&gt; ")
            current = current.next
        print("None")</pre>

  <p class="body">ChatGPT will likely include a sample test harness to run this code.<a id="marker-16"/></p>

  <p class="fm-code-listing-caption">Listing 2.4 Python-based method to implement and run the singly linked list</p>
  <pre class="programlisting"># Creating a new linked list
linked_list = SinglyLinkedList()
 
# Adding nodes to the list
linked_list.append(1)
linked_list.append(2)
  
# Prepending a node to the list
linked_list.prepend(0)
 
# Traversing and printing the list
linked_list.traverse()  # Output: 0 -&gt; 1 -&gt; 2 -&gt; None</pre>

  <p class="body">Similarly, we can refine the persona to be an interviewee for an engineering job. The switch in personas will signal to the ChatGPT-3.5 model that it should explain the code as well as an approach to solving the problem:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">You are a student with a background in computer science who is interviewing for an engineering job at a software company. You are asked the following question, based on the previous definition of a singly linked list (in Python), how would you write a method that would reverse the output of the traversal method. How would you implement such a method?</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="fm-code-listing-caption">Listing 2.5 ChatGPT’s explanation of how to reverse a singly linked list</p>
  <pre class="programlisting">To implement a method that reverses the output of a traversal method for a singly linked list in Python, you need to reverse the actual links in the linked list. This process involves changing the next reference of each node to point to the previous node instead of the next one. After reversing the links, traversing the list normally will produce the reversed order of elements.
  
def reverse(self):
        """ Reverse the linked list """
        prev = None
        current = self.head
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        self.head = prev</pre>

  <p class="body"><a id="marker-17"/>ChatGPT will likely output text similar to what is shown in figure 2.2, explaining the method and the approach to solving the problem.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH02_F02_Crocker2.png"/></p>

    <p class="figurecaption">Figure 2.2 ChatGPT Model 4’s explanation of the pseudocode definition of a reversing a linked list</p>
  </div>

  <p class="body">This implementation effectively reverses the singly linked list in place, and the traversal method will output the elements in reverse order compared to their original insertion sequence.<a id="idIndexMarker010"/><a id="idIndexMarker011"/><a id="idIndexMarker012"/><a id="idIndexMarker013"/></p>

  <h3 class="fm-head1" id="heading_id_5">2.1.2 Charting paths with GPT-3.5</h3>

  <p class="body"><a id="marker-18"/>In this section, we will explore how to harness the capabilities of ChatGPT-3.5 to create a singly linked list in Python. ChatGPT-3.5 excels at generating human-like text based on the input it receives. This makes it a valuable tool for coding assistance, as it can provide step-by-step guidance, suggest improvements, and offer detailed explanations of complex programming concepts.<a id="idIndexMarker014"/><a id="idIndexMarker015"/><a id="idIndexMarker016"/><a id="idIndexMarker017"/></p>

  <p class="body">To create a singly linked list, we will use ChatGPT-3.5 to generate the necessary Python code. A singly linked list is a data structure consisting of nodes, where each node contains a value and a reference to the next node in the sequence. This structure is particularly useful for dynamic memory allocation and efficient insertions and deletions. Using ChatGPT-3.5, we can simplify the process of coding a singly linked list, ensuring that our implementation is both efficient and easy to understand. The following example demonstrates how to define the <code class="fm-code-in-text">Node</code> and <code class="fm-code-in-text">LinkedList</code> classes, initialize a list, and perform basic operations such as insertion and traversal.<a id="idIndexMarker018"/><a id="idIndexMarker019"/></p>

  <p class="fm-code-listing-caption">Listing 2.6 Implementation of a singly linked list by ChatGPT-3.5</p>
  <pre class="programlisting">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
  
class LinkedList:
    def __init__(self):
        self.head = None
  
    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
  
    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
 
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" -&gt; ")
            current = current.next
        print("None")
  
    def reverse_and_display(self):
        prev = None
        current = self.head
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        self.head = prev
  
        current = self.head
        while current:
            print(current.data, end=" -&gt; ")
            current = current.next
        print("None")
  
  
# Example usage:
if __name__ == "__main__":
    linked_list = LinkedList()
  
    linked_list.append(1)
    linked_list.append(2)
    linked_list.append(3)
  
    linked_list.prepend(0)
  
    linked_list.display()
    linked_list.reverse_and_display()</pre>

  <p class="body">You can apply the Persona Pattern in either direction: you can tell the LLM to respond as though it were someone or something within a given role, or you can ask the LLM to assume that you are a certain persona. This can be very useful when you need to explain some code in simplified terms or are attempting to understand complex or complicated topics. For example, we can ask ChatGPT to explain our code to us in a simplified manner with this prompt:<a id="marker-19"/></p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">Assume that I am an adult who graduated from college with a degree in communications. I have no experience with computer science. How would you explain that method to me?</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Let’s examine how ChatGPT would explain our method to someone without a computer science background.</p>

  <p class="fm-code-listing-caption">Listing 2.7 ChatGPT explanation for someone who is not a computer scientist</p>
  <pre class="programlisting">Certainly! Let's break down the reverse_and_display method in a way that doesn't involve technical jargon or computer science concepts.
 
Imagine you have a set of books on a bookshelf, and each book has a bookmark pointing to the next book in the shelf. This set of books represents our linked list, and the bookmarks represent the next connections between the items.
  
Getting Ready: You start at the first book (the head of the linked list) and have two empty hands: one to remember the book you just read (prev) and another to hold the book you are currently reading (current). There's also an empty placeholder (a table, perhaps) to help you temporarily remember the next book.
  
Changing the Order: Now, let's change the order of the books. For each book (node) you read:
a. Use the bookmark (the next reference) to find out where the next book is and put it on the empty placeholder (the table). This is like making a note of where the next book is located.
b. Turn the bookmark in the current book around, so it now points to the previous book. This means that the current book is now connected to the book you just read instead of the next book. It's like flipping the bookmark.
c. Swap the books in your hands: Put the book you just read (prev) in your left hand (so you remember it for the next iteration) and put the book you are currently reading (current) in your right hand (so you can work on the next book).
d. Walk to where you put the next book (the one on the table) to continue the process.
  
Starting Over: Keep doing this until you run out of books to read. At this point, your right hand will hold the last book (the first book initially), and your left hand will be empty. Now, you put the first book you're holding (the last book in the original order) back on the shelf as the new first book.
  
Reading Backward: Finally, go through the books starting from the new first book, and follow the bookmarks in the reversed direction. As you read each book, you say its title out loud. This will give you the titles of the books in reverse order.
  
So, the reverse_and_display method essentially changes the order of the books (nodes) in the bookshelf and then reads the titles (data) of those books in the reversed order.
Bottom of Form</pre>

  <p class="body"><a id="marker-20"/>When you use the Persona Pattern in reverse, it is commonly referred to as the <i class="fm-italics">Audience Persona Pattern</i> in the context of prompt engineering. This refers to a predefined profile or representation of the intended audience for a particular application or use case. It helps in tailoring the responses generated by LLMs to better suit the needs and expectations of a specific group of users or individuals. Before we move on to GitHub CoPilot, let’s compare the output quality of each model. <a id="idIndexMarker020"/><a id="idIndexMarker021"/><a id="idIndexMarker022"/><a id="idIndexMarker023"/><a id="idIndexMarker024"/></p>

  <h3 class="fm-head1" id="heading_id_6">2.1.3 Navigating the AI seas: From the shores of GPT-3.5 to the horizons of GPT-4</h3>

  <p class="body">One of the significant differences between the output of these two models is in the sophistication and transparency of their outputs, particularly in how these models interact with and modify data structures. The difference between the approaches used by GPT-3.5 and GPT-4 underscores a broader shift toward greater clarity and predictability in AI-generated code. As AI models become more advanced, their output increasingly reflects the nuances of good programming practices, mirroring the evolution of human programmers’ skills and sensibilities. This evolution is crucial for AI to be a reliable partner in software development, where clarity and precision are not just ideals but necessities.<a id="idIndexMarker025"/><a id="idIndexMarker026"/><a id="idIndexMarker027"/><a id="idIndexMarker028"/></p>

  <p class="body">With GPT-3.5, the approach taken in the <code class="fm-code-in-text">reverse_and_display</code> method was somewhat opaque in its execution. This version of the model altered the underlying data structure of the linked list, effectively reversing the nodes. However, it did so without explicitly signaling this change to the user. From a developer’s standpoint, this could lead to unexpected side effects. For instance, if we were to call <code class="fm-code-in-text">reverse_and_display</code> with the assumption of merely displaying the reversed list, we would find that the original list structure had been permanently altered. This lack of transparency in the operation could easily lead to confusion and bugs, especially in more complex applications where the integrity of the original data structure is crucial.<a id="idIndexMarker029"/></p>

  <p class="body">In contrast, GPT-4 exhibits a more refined approach with its <code class="fm-code-in-text">reverse</code> method. This method explicitly reverses the linked list, and any seasoned programmer could infer from the name and structure of the method that it would modify the underlying data structure. GPT-4’s methodology aligns more closely with clear and maintainable code principles. It embodies the idea that each function or method should perform a well-defined task. The separation of concerns is evident here: the reversal of the list and its display are treated as distinct operations. This enhances code readability and reduces the likelihood of unintended side effects, as the developer is fully aware of the changes applied to the data structure.<a id="idIndexMarker030"/><a id="idIndexMarker031"/><a id="idIndexMarker032"/><a id="marker-21"/></p>

  <h2 class="fm-head" id="heading_id_7">2.2 Let Copilot take control</h2>

  <p class="body">Now let’s use GitHub Copilot to tackle the same problem. Appendix B has instructions on creating an account and installing the plugin into your favorite integrated development environment (IDE; assuming your favorite IDE is either VS Code or PyCharm). Once you have completed the installation, you should create a new project in your IDE. First, create a new file named main.py. At the beginning of this file, enter the following comment/prompt: <a id="idIndexMarker033"/><a id="idIndexMarker034"/></p>
  <pre class="programlistinge"># You are a student with a background in computer science who is interviewing for an engineering job at a software company. You are asked the following question: based on the previous definition of a singly linked list (in Python), how would you write a method that would reverse the output of the traversal method? How would you implement such a method?</pre>

  <p class="body">Note the hash character at the beginning; it denotes a Python comment. What is particularly interesting is that we used the same prompt in ChatGPT and GitHub Copilot.</p>

  <p class="body">Next, note that as you begin to type the definition of the <code class="fm-code-in-text">ListNode</code> class, Copilot will make code suggestions. This is the inline mode of engagement. Alternatively, you can activate the interactive model by pressing Ctrl-Enter and have Copilot generate up to 10 recommendations based on the current context.<a id="idIndexMarker035"/></p>

  <p class="fm-callout"><span class="fm-callout-head">NOTE</span> Throughout the book, we will mainly use inline mode, in which you use the Tab key to accept a given suggestion.</p>

  <p class="body">You will likely get code resembling the source code created by ChatGPT. Let’s try a slightly different programming challenge rather than reprint the same code from the previous section. We will ask the following of Copilot:</p>
  <pre class="programlistinge"># Given an unsorted array of integers, write a function to find the kth smallest element in the array. Can you discuss the time and space complexity of your solution?</pre>

  <p class="body">After a few carriage returns, Copilot should add some comments that discuss this code’s time and space complexity and the problem in general. Fascinating!</p>

  <p class="fm-code-listing-caption">Listing 2.8 ChatGPT calculating and reporting the complexity of this code</p>
  <pre class="programlisting">def kth_smallest_element(arr, k):
    # Time Complexity: O(N)
    # Space Complexity: O(1)
    if k &gt; len(arr):
        return None
    return sorted(arr)[k - 1]</pre>

  <p class="body">Copilot’s suggestion is admirable and completely valid, but it would not likely be an acceptable answer during an interview. It feels like a cheat. We should expect that there would be a follow-up question about how to do this without sorting the entire list. Let’s refine the prompt to ensure that the list is not sorted before taking the <i class="fm-italics">k</i>th element:</p>
  <pre class="programlistinge">#As a computer science graduate seeking a software engineering role, imagine you are in an interview where you are presented with a problem: 'How would you implement a function in Python to determine the kth smallest element within an unsorted array of integers, without resorting to full array sorting or utilizing any built-in sorting functions? Additionally, can you explain the time and space complexity of your algorithm?' This question tests your ability to devise efficient algorithms and your understanding of complexity analysis, all while adhering to specified constraints.</pre>

  <p class="body">The code that Copilot provides looks very similar to a binary search, which is certainly an interesting choice.<a id="marker-22"/></p>

  <p class="fm-code-listing-caption">Listing 2.9 Copilot’s approach to solving the <i class="fm-italics">k</i>th element problem<a id="idIndexMarker036"/></p>
  <pre class="programlisting"># The following code demonstrates an implementation of the kth smallest element function in Python, along with an explanation of its time and space complexity.
  
# Function to determine the kth smallest element in an unsorted array
def kth_smallest(arr, k):
    # Check if the input array is empty or if k is out of bounds
    if not arr or k &lt; 1 or k &gt; len(arr):
        return None
 
    # Initialize variables to store the lower and upper bounds of the array
    low = min(arr)
    high = max(arr)
  
    # Perform binary search to find the kth smallest element
    while low &lt;= high:
        # Calculate the middle element of the array
        mid = low + (high - low) // 2
  
        # Count the number of elements less than or equal to the middle element
        count = sum(1 for num in arr if num &lt;= mid)
  
        # Adjust the search range based on the count
        if count &lt; k:
            low = mid + 1
        else:
            high = mid - 1
  
    # Return the kth smallest element
    return low
  
# Time complexity: O(n log(max(arr) - min(arr)))<a id="idIndexMarker037"/><a id="idIndexMarker038"/>
# Space complexity: O(1)</pre>

  <h2 class="fm-head" id="heading_id_8">2.3 Let CodeWhisperer speak loudly</h2>

  <p class="body"><a id="marker-23"/>Before we begin using CodeWhisperer, we should disable Copilot. Click the Extensions tab, and search for Copilot. Once you have found it, click the Disable button. You will need to restart the application. When the application has restarted, you can begin to use CodeWhisperer. If you need assistance installing or configuring CodeWhisperer, refer to appendix C. Once the plugin is installed and you are logged in to your developer account, create a file called asset.py. Figure 2.3 shows how to locate and disable this plug-in.<a id="idIndexMarker039"/><a id="idIndexMarker040"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH02_F03_Crocker2.png"/></p>

    <p class="figurecaption">Figure 2.3 Before we can switch to CodeWhisperer, we must disable Copilot. We turn off the extension in the Extensions tab.</p>
  </div>

  <p class="body">We will use the same prompt that we used for Copilot. It is reprinted here for convenience:</p>
  <pre class="programlistinge">#As a computer science graduate seeking a software engineering role, imagine you are in an interview where you are presented with a problem: 'How would you implement a function in Python to determine the kth smallest element within an unsorted array of integers, without resorting to full array sorting or utilizing any built-in sorting functions? Additionally, can you explain the time and space complexity of your algorithm?' This question tests your ability to devise efficient algorithms and your understanding of complexity analysis, all while adhering to specified constraints.</pre>

  <p class="body">The code that CodeWhisperer provides implements the Quickselect algorithm, which is closely related to the QuickSort sorting algorithm. Quickselect is specifically designed to efficiently find the <i class="fm-italics">k</i>th smallest element in an unsorted array.<a id="marker-24"/></p>

  <p class="fm-code-listing-caption">Listing 2.10 CodeWhisperer’s approach to solving the <i class="fm-italics">k</i>th element problem</p>
  <pre class="programlisting">def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] &lt;= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
  
def quickselect(arr, k, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    if low &lt; high:
        pivot = partition(arr, low, high)
        if pivot == k:
            return arr[k]
        elif pivot &gt; k:
            return quickselect(arr, k, low, pivot - 1)
        else:
            return quickselect(arr, k, pivot + 1, high)
    return arr[low]
  
# Usage Example
arr = [5, 2, 4, 6, 1, 3]
k = 2
print(quickselect(arr, k))
# Output: 2</pre>

  <p class="body">There is a fascinating distinction between the code created by Copilot and that of CodeWhisperer. CodeWhisperer interprets <code class="fm-code-in-text">k</code> as the index of the element in the sorted array. Because array indices in most programming languages start at 0, if <code class="fm-code-in-text">k</code> is 2, CodeWhisperer will find the third-smallest element (because indices 0, 1, and 2 correspond to the first, second, and third smallest elements, respectively). On the other hand, Copilot assumes that <code class="fm-code-in-text">k</code> refers to the rank of the element, not the index. So, if <code class="fm-code-in-text">k</code> is 2, Copilot will return the second-smallest element in the array. This is akin to saying “second place” rather than “index 2.”</p>

  <p class="body">In this section, we introduced AWS CodeWhisperer into the mix. Like its predecessors, CodeWhisperer capably generated code that solves the problem, reinforcing AI’s transformative potential in software development.</p>

  <p class="body">Given the striking similarity of the code produced by these tools, an intriguing question naturally arises: how do these products truly compare? Given each tool’s unique strengths and limitations, the answer is not as straightforward as you may think.</p>

  <p class="body">In the following section, we’ll delve into this question, comparing these three tools—ChatGPT, Copilot, and AWS CodeWhisperer—in a bid to understand their unique offerings, optimal use cases, and how they may reshape the future of software development. We aim to provide a comprehensive guide that can help software developers navigate this rapidly evolving landscape of AI-driven tools.<a id="idIndexMarker041"/><a id="idIndexMarker042"/></p>

  <h2 class="fm-head" id="heading_id_9">2.4 Comparing ChatGPT, Copilot, and CodeWhisperer</h2>

  <p class="body"><a id="marker-25"/>The first dimension we will consider is the engagement model: how we engage with AI. In the case of ChatGPT, we log in to the chat website and enter prompts into a chat input box. Then we refine our requirements in subsequent prompts. The feedback loop takes the context from the previous prompts, applies it to the current prompt, and generates output to which the user reacts and refires. If we contrast this engagement model against that of Copilot and CodeWhisperer, we note that the latter two tools work within an IDE. We can’t use it outside our IDE, try as we may. The approach is not inherently inferior; it just differs. <a id="idIndexMarker043"/><a id="idIndexMarker044"/><a id="idIndexMarker045"/></p>

  <p class="body">The way that Copilot and CodeWhisperer keep you in your IDE can be seen as a benefit rather than a deficiency. In later chapters, we will get acquainted with Copilot Chat, the best of both worlds: ChatGPT and GPT-4, all in your IDE. These tools keep you in your code without distraction for longer. Working distraction-free is one of the keys to productivity. Copilot and CodeWhisperer excel at getting out of your way, keeping you from switching contexts, freeing you from distraction, and keeping you in the flow state longer. They do this well. You engage ChatGPT in a dialog; Copilot and CodeWhisperer advise you. The dialog takes longer; advice comes fast and free.</p>

  <p class="body">Next, we will examine how the code is presented and generated. ChatGPT can create the code as a block, method, class, or project. ChatGPT reveals projects deliberatively if asked. But it does create the project behind the scenes. ChatGPT, after all, likes to talk. With Copilot and CodeWhisperer, the code unfolds one method at a time, at least initially. As you use these tools more, you will notice that they can write more and more of the code for a given class. But unfortunately, they can’t write an entire project with a tiny prompt.</p>

  <p class="body">One item that they all share is their ability to respond to prompts. With ChatGPT, prompts are the only way to engage with the tool. With Copilot and CodeWhisperer, responding to prompts is not strictly necessary, but coding such prompts will make the output correspond more closely to what you initially had in mind.</p>

  <p class="body">Combining these factors, you may conclude that ChatGPT is an excellent choice for exploration and prototyping. However, ChatGPT can introduce unnecessary distractions, partly because you have left your IDE and are now in a web browser with all of the accompanying temptations that come with it. ChatGPT itself is part of the inclusion of unnecessary distractions. You will eventually fall into the proverbial rabbit hole. The tool makes it too easy not to. Don’t let that scare you off. It is a beautiful resource.</p>

  <p class="body">Copilot and CodeWhisperer require that you have a desired outcome in mind. Therefore, these tools are perfect for when you want to go head down, coding with precise requirements and tight deadlines. Copilot and CodeWhisperer work best when you know the language and the framework. They can automate much of the drudgery, allowing you to focus on the business requirements, which add value and are likely why you are writing the software in the first place. Figure 2.4 briefly summarizes the benefits and limitations of all three generative AIs.<a id="marker-26"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH02_F04_Crocker2.png"/></p>

    <p class="figurecaption">Figure 2.4 A comparison of the positives and negatives of ChatGPT, Copilot, and CodeWhisperer</p>
  </div>

  <p class="body">In this chapter, we went through a lot, implementing basic data structures and solving some classic computer science problems. The work in this chapter is foundational, allowing us to better recognize when it makes sense to use ChatGPT as opposed to when to use the other IDE-focused tools such as Copilot and CodeWhisperer. In subsequent chapters, we will use this knowledge to choose the most suitable tool.</p>

  <p class="body">One final note: these tools work best when they work together. ChatGPT is an excellent tool for example and structure. Copilot and CodeWhisperer allow you to extend and customize the code. <a id="idIndexMarker046"/><a id="idIndexMarker047"/><a id="idIndexMarker048"/><a id="marker-27"/></p>

  <h2 class="fm-head" id="heading_id_10">Summary</h2>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">ChatGPT is a prompt-based Generative AI that engages the user in a dialogue that helps them explore ideas to aid in the design and development of entire projects. In addition, ChatGPT artfully generates documentation for each method it writes. One of the reasons we began the chapter using it is that it helped define a template we used throughout the remainder of the chapter. It is a fascinating product, one that can lead to unnecessary albeit enjoyable distractions.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Copilot and CodeWhisperer are head-down tools that work best when you know what you want to do and need some advice about how best to get it done. You engage with these tools in a way that is remarkably similar, as are the results.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">ChatGPT (as of this writing) does not support development within an IDE. However, unlike GitHub Copilot and AWS CodeWhisperer, it can produce entire projects and easily translate code from one programming language to another. Copilot and CodeWhisperer take hints from your comments to infer what code you want to write. With ChatGPT, you explicitly write prompts that ChatGPT uses to create the code.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The purpose of the Persona Pattern is to design prompts that establish a specific persona or role for the AI to assume, which guides the model’s responses in a consistent and contextually appropriate manner. By adhering to a defined persona, the AI’s replies become more predictable and aligned with the user’s expectations.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The intern persona is often characterized by eagerness to learn, a basic to intermediate level of knowledge in the field, and a willingness to take on various tasks for learning and experience. The intern may ask clarifying questions, seek guidance, and demonstrate a proactive approach to problem-solving. They are often resourceful but may lack the deep expertise of more experienced professionals in the field. This persona is useful in scenarios where the AI needs to simulate a learning and growth-oriented mindset.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Refinement Pattern involves iteratively refining or improving the prompt to get more accurate, relevant, or sophisticated responses. It’s about going from general to specific, enhancing the output quality as the interaction progresses with large language models like ChatGPT.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Audience Persona Pattern is a variation of the Persona Pattern in prompt engineering. It involves defining a profile or representation of the intended audience for a particular application or use case, which helps tailor the responses generated by LLMs to better suit the needs and expectations of a specific group of users or individuals.<a id="idIndexMarker049"/><a id="marker-28"/></p>
    </li>
  </ul>
</body></html>