<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Extending Copilot’s Functionality"><div class="chapter" id="ch10">
<h1><span class="label">Chapter 10. </span>Extending Copilot’s Functionality</h1>

<p>GitHub Copilot is an amazingly useful tool. It can be made even more useful by extending its capabilities through integration with other tools. This includes ones you can write. The mechanisms for doing this are called <em>extensions</em>.</p>

<p>Copilot extensions enhance the functionality of GitHub Copilot by tailoring it to specific use cases or environments. For example, extensions can integrate custom or third-party applications with Copilot through the chat interface. As an example, you can install a <a href="https://oreil.ly/QS54S">Copilot Docker extension</a> <a contenteditable="false" data-primary="Copilot Docker extension" data-type="indexterm" id="id892"/>and then ask questions via chat like “@Docker, how do I containerize this project?”</p>

<p>In this chapter, we’ll examine what extensions for GitHub Copilot are and how to find and work with public ones from the marketplace. Then we’ll progress to understanding details about the various types, how they work, and their advantages and disadvantages. And we’ll cover some details on simple, yet useful, implementation examples. But before we cover those topics, we need to clarify some possibly confusing terminology.</p>

<section data-type="sect1" data-pdf-bookmark="Copilot Extensions Versus VS Code Extensions for Copilot"><div class="sect1" id="id107">
<h1>Copilot Extensions Versus VS Code Extensions for Copilot</h1>

<p><a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-secondary="VS code extensions for Copilot versus" data-type="indexterm" id="xi_ExtensionsGitHubCopilotVScodeextensionsforCopilotversus10144"/><a contenteditable="false" data-primary="VS Code (Visual Studio Code)" data-secondary="extensions for Copilot versus Copilot extensions" data-type="indexterm" id="xi_VSCodeVisualStudioCodeextensionsforCopilotversusCopilotExtensions10144"/>Extensions for Copilot’s functionality can be implemented for one of two different targets. They can be engineered to work on any platform where Copilot Chat is supported (IDEs, GitHub.com, etc.), independent of the platform. Or they can be targeted for VS Code to leverage its underlying functions and only run on that platform (or on another IDE if ported).</p>

<p>Throughout this chapter, we’ll use the terms <em>VS Code extensions for Copilot </em>or c<em>hat participants</em> when referring to the ones implemented via VS Code. For the <em>native</em> Copilot ones (implemented to be independent of the platform), we’ll use the shorter term <em>Copilot extensions</em>.</p>

<p>In both cases, the extension’s functionality is surfaced through Copilot’s chat interface. VS Code extensions for Copilot simply utilize its functionality for both hosting and execution. Copilot extensions require a separately configured and dedicated GitHub App to bridge between the chat interface and the backend code.</p>

<p>We’ll be discussing the details of implementation and configuration for both types of extensions later in this chapter. That will include information on what GitHub Apps are and how they are used with Copilot extensions. But, first, let’s learn more about what Copilot extensions are in general.</p>

<div data-type="tip">
<h1>Server-Based and Client-Based Extensions</h1>

<p>It may be helpful to think of Copilot extensions as <em>server-based<a contenteditable="false" data-primary="server-based extensions" data-type="indexterm" id="id893"/></em>, in the sense of needing to communicate back to the app running on the GitHub side to function (although that’s not an official description). Likewise, VS Code extensions for Copilot could be thought of as <em>client-based<a contenteditable="false" data-primary="client-based extensions" data-type="indexterm" id="id894"/></em> since they function utilizing the APIs of the VS Code client where they are installed<a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotVScodeextensionsforCopilotversus10144" data-type="indexterm" id="id895"/><a contenteditable="false" data-primary="" data-startref="xi_VSCodeVisualStudioCodeextensionsforCopilotversusCopilotExtensions10144" data-type="indexterm" id="id896"/>.</p>
</div>
</div></section>

<section data-type="sect1" data-pdf-bookmark="What Are Copilot Extensions?"><div class="sect1" id="id108">
<h1>What Are Copilot Extensions?</h1>

<p><a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-type="indexterm" id="xi_ExtensionsGitHubCopilot10334"/>Copilot has a framework of APIs and lower-level capabilities that underlie its user-facing functionality. That framework can be used by third parties and users to extend Copilot’s capabilities. This framework allows other applications to provide their services through Copilot Chat directly to the user. As the user, you get the benefit of being able to invoke and converse with the other tooling, similar to the way you interact with the Copilot AI out of the box.</p>

<p>Extensions have multiple use cases, as noted in Copilot’s <a href="https://oreil.ly/B7yAU">documentation</a>. They include the following:</p>

<dl>
	<dt>Querying documentation</dt>
	<dd><a contenteditable="false" data-primary="queries and querying" data-secondary="documentation" data-type="indexterm" id="id897"/><a contenteditable="false" data-primary="documentation" data-secondary="querying" data-type="indexterm" id="id898"/>Allowing Copilot Chat to query a third-party documentation service to find information about a specific topic.</dd>
	<dt>AI-assisted coding</dt>
	<dd><a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="Copilot extensions for AI-assisted coding" data-type="indexterm" id="id899"/>Using a third-party AI model to provide code suggestions.</dd>
	<dt><a contenteditable="false" data-primary="data retrieval, Copilot extensions for" data-type="indexterm" id="id900"/>Data retrieval</dt>
	<dd>A Copilot extension can allow Copilot Chat to query a third-party data service to retrieve information about a specific topic.</dd>
	<dt>Action execution</dt>
	<dd><a contenteditable="false" data-primary="actions, Copilot extensions for executing" data-type="indexterm" id="id901"/>Allowing Copilot Chat to execute a specific action, such as posting to a message board or updating a tracking item in an external system.</dd>
</dl>

<p>Think of using Copilot extensions as giving Copilot Chat additional knowledge of another application or set of data, and adding specialized skills that you can invoke to help when needed.</p>

<p>Copilot extensions are built to provide cross-platform compatibility, app management, and support. They work anywhere that chat does. They can be private, public and shareable, and listed on GitHub Marketplace, if desired. In fact, the marketplace is a good place to start learning about extensions and the public ones available to use<a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilot10334" data-type="indexterm" id="id902"/>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Getting Copilot Extensions from the Marketplace"><div class="sect1" id="id109">
<h1>Getting Copilot Extensions from the Marketplace</h1>

<p><a contenteditable="false" data-primary="GitHub Marketplace, getting Copilot extensions from" data-type="indexterm" id="xi_GitHubMarketplacegettingCopilotExtensionsfrom10554"/><a contenteditable="false" data-primary="Marketplace, getting Copilot extensions from" data-type="indexterm" id="xi_MarketplacegettingCopilotExtensionsfrom10554"/>You can write your own extensions (as you’ll see later in this chapter), and organizations or companies can create <em>private<a contenteditable="false" data-primary="private extensions" data-type="indexterm" id="id903"/></em> extensions. In addition, <em>public<a contenteditable="false" data-primary="public extensions" data-type="indexterm" id="id904"/></em> extensions from third-party companies and organizations are already available. To see these, go to <a href="https://github.com/marketplace">GitHub Marketplace</a> and select Copilot in the left column. <a data-type="xref" href="#copilot-extensions-on">Figure 10-1</a> shows the main screen for Copilot extensions in the marketplace.</p>

<figure><div id="copilot-extensions-on" class="figure"><img alt="" src="assets/lghc_1001.png" width="1871" height="972"/>
<h6><span class="label">Figure 10-1. </span>Copilot extensions on the marketplace</h6>
</div></figure>

<p class="pagebreak-before"><a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-secondary="getting from the GitHub Marketplace" data-type="indexterm" id="xi_ExtensionsGitHubCopilotgettingfromtheGitHubMarketplace10614"/>From here, we’ll pick the PerplexityAI extension<a contenteditable="false" data-primary="PerplexityAI" data-type="indexterm" id="id905"/>. This extension allows for gathering responses through real-time web searches. Clicking the link in the marketplace opens up the extension’s details page with information about what the extension is and what it can do (<a data-type="xref" href="#extension-main-page">Figure 10-2</a>).</p>

<figure><div id="extension-main-page" class="figure"><img alt="" src="assets/lghc_1002.png" width="1527" height="996"/>
<h6><span class="label">Figure 10-2. </span>Extension main page</h6>
</div></figure>

<p class="pagebreak-before">Clicking the Add button (in the upper right) or scrolling to the bottom takes you to the section of the page where you can install the extension (<a data-type="xref" href="#extension-install-pag">Figure 10-3</a>). This one is free. </p>

<figure><div id="extension-install-pag" class="figure"><img alt="" src="assets/lghc_1003.png" width="1233" height="990"/>
<h6><span class="label">Figure 10-3. </span>Extension installation page</h6>
</div></figure>

<p class="pagebreak-before">Some extensions may require you to select the user or organization that will be authorized to use the extension. You can see an example of that if you choose to install the Docker extension<a contenteditable="false" data-primary="Docker extension" data-type="indexterm" id="id906"/> (<a data-type="xref" href="#docker-extension-inst">Figure 10-4</a>). In the case of the PerplexityAI extension<a contenteditable="false" data-primary="PerplexityAI" data-type="indexterm" id="id907"/>, its functionality is general search, so it is usable for all repos associated with the user who is installing it.</p>

<figure><div id="docker-extension-inst" class="figure"><img alt="" src="assets/lghc_1004.png" width="1190" height="988"/>
<h6><span class="label">Figure 10-4. </span>Installing the Docker extension with the user or organization selected</h6>
</div></figure>

<p>Most Copilot extensions get access to repositories and your account through the use of a <em>GitHub App<a contenteditable="false" data-primary="GitHub App" data-type="indexterm" id="id908"/></em>. These are basically backend applications installed and authorized in your GitHub account to work with your repositories. For Copilot extensions that use an app, the app serves as the bridge between the chat interface and the code that implements the extension’s functionality. The app provides the access and control layer between Copilot and the extension’s operations.</p>

<p class="pagebreak-before">You can see the app integration once you’ve done the initial install for the extension. You’ll be asked to authorize the associated GitHub App for the account by authenticating to GitHub. After authorizing, you’ll be taken to the configuration page for the installed app, as shown in <a data-type="xref" href="#perplexity-ais-githu1">Figure 10-5</a>.</p>

<figure><div id="perplexity-ais-githu1" class="figure"><img alt="" class="iimagesch9-perplexity-app-configurepng fse fs" src="assets/lghc_1005.png" width="1598" height="940"/>
<h6><span class="label">Figure 10-5. </span>PerplexityAI’s GitHub App configuration</h6>
</div></figure>

<p>On this page, you can select specific permissions for the app and/or specific repositories for the app to access. In the case of the app for the PerplexityAI extension<a contenteditable="false" data-primary="PerplexityAI" data-type="indexterm" id="id909"/>, it simply applies to all repositories and does not have any specific permission requirements, so we are good to go. You can also suspend or uninstall the app from this page.</p>

<div data-type="note" epub:type="note">
<h1>Changing App Configuration</h1>

<p><a contenteditable="false" data-primary="applications" data-secondary="configuring" data-type="indexterm" id="id910"/>If you later need to change the configuration settings for the app and are logged in, you can go to the <a href="https://oreil.ly/WOBZf">applications portion of your settings</a> to modify an installed app’s configuration.</p>
</div>

<p class="pagebreak-before">After the install and authorization steps are complete, start or restart any instances of applications where GitHub Copilot is active. Then, type the <strong><code>@<a contenteditable="false" data-primary="@ symbol" data-type="indexterm" id="id911"/></code></strong> sign and the extension’s name in the chat interface to start using the newly installed extension, as shown in <a data-type="xref" href="#invoking-the-perplexi">Figure 10-6</a>.</p>

<figure><div id="invoking-the-perplexi" class="figure"><img alt="" src="assets/lghc_1006.png" width="807" height="608"/>
<h6><span class="label">Figure 10-6. </span>Invoking the PerplexityAI app in chat</h6>
</div></figure>

<p class="pagebreak-before">The first time you attempt to use the new extension via the app after restarting, you may get prompted to authorize it—either for the selected workspace or for all workspaces (<a data-type="xref" href="#authorization-for-wor">Figure 10-7</a>).</p>

<figure><div id="authorization-for-wor" class="figure"><img alt="" src="assets/lghc_1007.png" width="807" height="585"/>
<h6><span class="label">Figure 10-7. </span>Authorization for workspace</h6>
</div></figure>

<p class="pagebreak-before">This is done in a similar manner to the initial authorization. Once the authorization is completed, you can pose your prompt again, and you should be able to get a response (<a data-type="xref" href="#perplexityai-response">Figure 10-8</a>).</p>

<figure><div id="perplexityai-response" class="figure"><img alt="" src="assets/lghc_1008.png" width="808" height="765"/>
<h6><span class="label">Figure 10-8. </span>PerplexityAI response after authorization</h6>
</div></figure>

<p>The number of public Copilot extensions is growing regularly. If they fit with an application or purpose you need, they can be a useful option. But if you need functionality that is not already available or need an integration more directly with your data or processes, you may want to consider developing and using your own Copilot extension. To understand more about that option, let’s first talk about the two <em>implementation</em> types of Copilot extensions that can exist<a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotgettingfromtheGitHubMarketplace10614" data-type="indexterm" id="id912"/><a contenteditable="false" data-primary="" data-startref="xi_GitHubMarketplacegettingCopilotExtensionsfrom10554" data-type="indexterm" id="id913"/><a contenteditable="false" data-primary="" data-startref="xi_MarketplacegettingCopilotExtensionsfrom10554" data-type="indexterm" id="id914"/>.</p>
</div></section>

<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Understanding Copilot Extension Implementation Types"><div class="sect1" id="id110">
<h1 class="less_space">Understanding Copilot Extension Implementation Types</h1>

<p><a contenteditable="false" data-primary="implementation types, for Copilot extensions" data-type="indexterm" id="xi_implementationtypesforCopilotExtensions101194"/>Copilot extensions<a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-secondary="implementation types" data-type="indexterm" id="xi_ExtensionsGitHubCopilotimplementationtypes1011922"/> can be implemented as one of two types:</p>

<dl>
	<dt>Agent</dt>
	<dd><a contenteditable="false" data-primary="agents" data-type="indexterm" id="id915"/>An extension implemented as an agent serves as a full AI assistant. This means it can handle complex chat conversations, execute custom code, and return very tailored responses.</dd>
	<dt>Skillsets</dt>
	<dd><a contenteditable="false" data-primary="skillsets" data-type="indexterm" id="id916"/>An extension implemented as a skillset can invoke one or more API endpoints behind the scenes to retrieve specific information or perform basic actions.</dd>
</dl>

<p>You’ll see examples of how to build each implementation type later in the chapter. But for now, let’s level-set on the general advantages and disadvantages of each.</p>

<p>Agents are the original type of Copilot extension and can provide the most extensive functionality if you need complex or custom processing and integration. They provide full control but also can be complex to implement.</p>

<p>Skillsets make it easy to call other APIs or perform basic operations. They are simpler to implement while being more limited in what they can do and how much control they provide.</p>

<p><a data-type="xref" href="#comparison-of-copilot">Table 10-1</a> compares the two implementation choices.</p>

<table class="border" id="comparison-of-copilot">
	<caption><span class="label">Table 10-1. </span>Comparison of Copilot extension types</caption>
	<thead>
		<tr>
			<th scope="row">Attribute</th>
			<th scope="col">Copilot agents</th>
			<th scope="col">Copilot skillsets</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th scope="row">Complexity</th>
			<td>Requires more development effort to manage the entire user interaction flow response and response generation</td>
			<td>Designed for easy integration with minimal setup</td>
		</tr>
		<tr>
			<th scope="row">Control</th>
			<td><span data-huuid="4493955542516024087">Provides full control over how requests are processed and responses are generated</span></td>
			<td><span data-huuid="4493955542516024087">Limited control over the user interaction, focus is on data retrieval and basic actions</span></td>
		</tr>
		<tr>
			<th scope="row">Use cases</th>
			<td><span data-huuid="4493955542516024406">Suitable for complex scenarios where you need to implement custom logic, integrate with other AI models, and manage conversation context</span></td>
			<td><span data-huuid="4493955542516024406">Straightforward tasks like fetching data from an external API or performing simple operations,</span></td>
		</tr>
		<tr>
			<th scope="row">Interfaces available</th>
			<td>All (GitHub, IDEs)</td>
			<td>All (GitHub, IDEs)</td>
		</tr>
		<tr>
			<th scope="row">Support</th>
			<td>GitHub</td>
			<td>GitHub</td>
		</tr>
	</tbody>
</table>

<p>Now that you understand these types, we can look at implementation. The first step in that process is making sure you are clear on some of the building blocks when you are assembling a Copilot extension<a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotimplementationtypes1011922" data-type="indexterm" id="id917"/><a contenteditable="false" data-primary="" data-startref="xi_implementationtypesforCopilotExtensions101194" data-type="indexterm" id="id918"/>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Assembling Building Blocks for Extensions"><div class="sect1" id="id111">
<h1>Assembling Building Blocks for Extensions</h1>

<p><em><a contenteditable="false" data-primary="building blocks, assembling for Copilot extensions" data-type="indexterm" id="xi_buildingblocksassemblingforCopilotExtensions101827"/><a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-secondary="assembling building blocks for" data-type="indexterm" id="xi_ExtensionsGitHubCopilotassemblingbuildingblocksfor101827"/>Building blocks </em>are the components that need to be assembled to allow the extension to be accessed and function. At the core, these are the parts we need when working with a Copilot extension:</p>

<ul>
	<li>A GitHub App with a specific endpoint that handles interactions between the extension and Copilot Chat.</li>
	<li>A server process capable of hosting the backend and making endpoints available.</li>
	<li>A backend implementation that provides the functionality for the extension. This functionality can involve calls to the LLM along with integration with external tools, services, or APIs.</li>
</ul>

<p><a data-type="xref" href="#overview-building-blocks">Figure 10-9</a> shows an overview of the building blocks we’ll be using to construct extensions.</p>

<figure><div id="overview-building-blocks" class="figure"><img alt="" src="assets/lghc_1009.png" width="1416" height="484"/>
<h6><span class="label">Figure 10-9. </span>Overview of our building blocks</h6>
</div></figure>

<p>While GitHub apps and endpoint servers are required for agent and skillset extensions, those constructs are not unique to extensions. Next up is some clarification on how these are used for enabling extensions.</p>

<section data-type="sect2" data-pdf-bookmark="GitHub Apps"><div class="sect2" id="id112">
<h2>GitHub Apps</h2>

<p>A <em>GitHub App<a contenteditable="false" data-primary="GitHub App" data-type="indexterm" id="xi_GitHubApp1020120"/></em> is a tool that integrates with GitHub to extend GitHub’s functionality. It can do this in several ways:</p>

<ul>
	<li>Automating tasks</li>
	<li>Integrating with APIs and webhooks</li>
	<li>Customizing the GitHub workflow</li>
</ul>

<p>Once created, installed, and registered, a GitHub App can act, independently of the user, as an authorized process to do the type of operations described in the preceding list. The steps involve registering the app (including any manual configuration, if needed), writing any needed code for the functionality, and then setting it up to run via a webhook, callback URL, etc. The App also serves as a gateway for getting authorization to access resources.</p>

<div data-type="note" epub:type="note">
<h1>Callback URL</h1>

<p>In the context of GitHub Copilot extensions, a <em>callback URL<a contenteditable="false" data-primary="callback URL" data-type="indexterm" id="id919"/> </em>is a URL that your custom Copilot extension provides to GitHub. The URL serves as the destination where the system will redirect the user after successfully authenticating with your extension. It acts like a <em>return address<a contenteditable="false" data-primary="return address" data-type="indexterm" id="id920"/></em> once the authorization is complete.</p>
</div>

<p>The app for the PerplexityAI extension<a contenteditable="false" data-primary="PerplexityAI" data-type="indexterm" id="id921"/> discussed previously is a good example. After installing the extension, go to your GitHub profile, and, from the left menu, under Integrations, choose Applications. You’ll then see the installed app for that extension (<a data-type="xref" href="#perplexityai-app-inst">Figure 10-10</a>).</p>

<figure><div id="perplexityai-app-inst" class="figure"><img alt="" src="assets/lghc_1010.png" width="1025" height="386"/>
<h6><span class="label">Figure 10-10. </span>PerplexityAI app installed via extension</h6>
</div></figure>

<div data-type="note" epub:type="note">
<h1>Link to Install Applications</h1>

<p><a contenteditable="false" data-primary="links, for installing applications" data-type="indexterm" id="id922"/><a contenteditable="false" data-primary="applications" data-secondary="links for installing" data-type="indexterm" id="id923"/>If you are logged into GitHub, you can also access the list of installed applications via <a href="https://oreil.ly/WOBZf">the Installations page</a>.</p>
</div>

<p>For existing GitHub extensions that are available publicly or in your organization or enterprise, the app is installed and configured automatically as part of the extension’s installation and authorization process. For extensions that you implement, you’ll need to create and configure a new app as a part of the overall process. We’ll cover the creation and configuration steps in more detail later in this chapter.</p>

<p>Next, let’s talk about another important piece of how extensions work: the endpoint server<a contenteditable="false" data-primary="" data-startref="xi_GitHubApp1020120" data-type="indexterm" id="id924"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Endpoint Server"><div class="sect2" id="id113">
<h2>Endpoint Server</h2>

<p><a contenteditable="false" data-primary="endpoint server" data-type="indexterm" id="id925"/>In simplest terms, an agent or skillset Copilot extension can be viewed as an app that connects to an endpoint which handles interactions between the extension and Copilot Chat. The <em>endpoint</em> is the API for code that processes a chat input, does some processing, and then streams the output back to the chat. So, having the endpoint available is a key requirement for the flow.</p>

<p>In the case of an extension that you install from the marketplace or an enterprise/organization site, the server will have already been set up and configured. If you are creating your own extension, you need to have it hosted on a publicly accessible server (e.g., via deploying on a cloud service or tunneling). For example, you can use a simple service such as <a href="https://oreil.ly/m1eVi">Cloudflare</a><a contenteditable="false" data-primary="Cloudflare" data-type="indexterm" id="id926"/> or <a href="https://ngrok.com">ngrok</a><a contenteditable="false" data-primary="ngrok" data-type="indexterm" id="id927"/> to expose a public URL for development and testing.</p>

<p>Both of those services require signing up and then logging in to utilize. Another option, if you are using VS Code or a GitHub Codespace for development and testing, is to expose the port and enable <a href="https://oreil.ly/jgyG3">port forwarding</a><a contenteditable="false" data-primary="port forwarding" data-type="indexterm" id="id928"/>. This method is free and suitable for use before converting to a formal location when the extension is made public. The key thing to remember if using this method is that the port’s visibility must be changed to <code translate="no">public</code> from the default <code translate="no">private</code>.</p>

<p>While the app and endpoint provide a way to exchange information with the chat interface, the real work happens with the backend code that implements the endpoint. The rest of this chapter is devoted to looking at and understanding how to do these implementations, starting with creating an extension as an agent<a contenteditable="false" data-primary="" data-startref="xi_buildingblocksassemblingforCopilotExtensions101827" data-type="indexterm" id="id929"/><a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotassemblingbuildingblocksfor101827" data-type="indexterm" id="id930"/>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Implementing an Extension as an Agent"><div class="sect1" id="id114">
<h1>Implementing an Extension as an Agent</h1>

<p><a contenteditable="false" data-primary="Extensions (GitHub Copilot)" data-secondary="implementing as agents" data-type="indexterm" id="xi_ExtensionsGitHubCopilotimplementingasagents102514"/><a contenteditable="false" data-primary="agents" data-type="indexterm" id="xi_agentsimplementingCopilotExtensionsas102514"/>A Copilot Agent is a custom tool embedded in a Copilot extension. Agents augment the capabilities of Copilot by allowing you to build and integrate custom features into the Copilot Chat interface.</p>

<div data-type="note" epub:type="note">
<h1>Copilot Agent Mode</h1>

<p>In <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>, we discussed Copilot’s built-in <em>Agent mode<a contenteditable="false" data-primary="Agent mode" data-type="indexterm" id="id931"/> </em>that allows it to autonomously create code and terminal commands repeatedly to achieve a goal. In this chapter, we’re talking about agents again, but as separate functions built for use by extensions.</p>
</div>

<p>An agent implementation is appropriate when you need more control over how a request is processed or how a response is generated during a chat interaction. Agents can implement custom logic, integrate with other LLMs and the Copilot API, help with the context for chat conversations, and manage the interaction. But they are also more complex to create and maintain.</p>

<section data-type="sect2" data-pdf-bookmark="Performing a Basic Implementation"><div class="sect2" id="id115">
<h2>Performing a Basic Implementation</h2>

<p>In this section, you’ll see how to implement a basic but useful agent-based extension named <code>@meta-files</code>. Given a programming language in the prompt, our extension will generate example <em>.gitignore</em> and <em>.gitattributes</em> files. Alternatively, if the user provides an open source license name as part of the prompt, the extension will generate an example of the open source license. If the license has a placeholder for the user’s name and the current year, the extension will attempt to fill those in. Finally, the extension will also provide some guidance on when that type of license is useful.</p>

<p>Examples of using the extension are shown in Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#extension-generating">10-11</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#extension-generating-license">10-12</a>. The prompts used to invoke the extension are shown in the upper right: <code>@meta-files Python</code> for <a data-type="xref" href="#extension-generating">Figure 10-11</a> and <code>@meta-files MIT</code> for <a data-type="xref" href="#extension-generating-license">Figure 10-12</a>. The code is based on examples in the <a href="https://oreil.ly/pWQcX">Copilot extensions</a> and can be found in <a href="https://oreil.ly/93ZY_">the book’s GitHub repository</a><a contenteditable="false" data-primary="GitHub repository" data-type="indexterm" id="id932"/><a contenteditable="false" data-primary="repositories" data-secondary="GitHub" data-type="indexterm" id="id933"/>.</p>

<figure><div id="extension-generating" class="figure"><img alt="" src="assets/lghc_1011.png" width="1222" height="830"/>
<h6><span class="label">Figure 10-11. </span>Extension generating meta files for Python</h6>
</div></figure>

<figure><div id="extension-generating-license" class="figure"><img alt="" src="assets/lghc_1012.png" width="1274" height="787"/>
<h6><span class="label">Figure 10-12. </span>Extension generating license information</h6>
</div></figure>

<p><a data-type="xref" href="#agent-extension-overview">Figure 10-13</a> shows at a high level how an agent extension works. I’ll have more to say about the individual pieces in the following sections.</p>

<figure><div id="agent-extension-overview" class="figure"><img alt="" src="assets/lghc_1013.png" width="1440" height="857"/>
<h6><span class="label">Figure 10-13. </span>Agent extension overview</h6>
</div></figure>

<p>For the sake of brevity, we won’t dive into all the code here. We’ll just hit some key points. This example is written in JavaScript, but your extension can be written in nearly any modern language.</p>

<p>This simple example focuses on only two standard JavaScript files: <a href="https://oreil.ly/vowZU"><em>package.json</em></a> and <a href="https://oreil.ly/k16Kn"><em>index.js</em></a>. Let’s take a look at the <em>package.json</em> contents first. The contents are shown here:</p>

<pre data-type="programlisting" translate="no">
{
  "name": "metafiles-extension",
  "private": "true",
  "description": "Generate metafiles for a GitHub repository",
  "scripts": {
    "start": "node index.js",
    "dev": "node --watch index.js"
  },
  "type": "module",
  "dependencies": {
    "@octokit/core": "^6.1.2",
    "express": "^4.19.2"
  }
}</pre>

<p>The structure of this is standard boilerplate for this type of file. We could have multiple other fields, but we’re keeping the example simple. The only pieces that warrant additional explanation are the dependencies.</p>

<p><a href="https://expressjs.com">Express</a><a contenteditable="false" data-primary="Express" data-type="indexterm" id="id934"/> is a simple, backend web application framework. It’s designed to make it easy to build web apps and APIs with Node.js. When we create our agent extension, we are essentially creating a web app with an endpoint that is surfaced via the GitHub App.</p>

<p>The other dependency we’re using, <a href="https://github.com/octokit">Octokit</a><a contenteditable="false" data-primary="Octokit" data-type="indexterm" id="id935"/>, is a set of libraries provided by GitHub to let code interact with its REST and GraphQL APIs. It facilitates programmatically automating tasks and managing repositories and allows you to manipulate GitHub resources like pull requests and issues in code. We use it here to help get and work with a token for the user’s information.</p>

<p>The file with our main logic is <em>index.js</em>. You can look at the <a href="https://oreil.ly/GJW8z">file in GitHub</a> if you want to see the entire code. The logic at the top of the file does the necessary imports, starts an Express app, posts a welcome message, and then goes into the main processing.</p>

<p>The main processing uses Octokit to get a token, then moves into a standard cycle:</p>

<ul>
	<li>Getting the payload coming to us from the chat interface (via the GitHub App)</li>
	<li>Augmenting the prompt to tell the AI what we’re looking for</li>
	<li class="pagebreak-before">Sending the prompt off to the underlying LLM to get a response from the AI</li>
	<li>Passing the response to the chat interface</li>
</ul>

<p>The mechanics are fairly straightforward. The real magic happens where we augment the prompt to tell the AI what we’re looking for. Here’s the code for that part:</p>

<pre data-type="programlisting" translate="no">
  // Define the LLM's role and what it should look for and do

  const messages = payload.messages;

  messages.unshift({
    role: "system",
    content: "Search for a programming language name in the message
 from the user. If you find one, generate example .gitignore and 
.gitattributes files for that programming language",
  });

  messages.unshift({
    role: "system",
    content: "Search for an open source software license name, type,
 or abbreviation in the message from the user. If you find one,
 do the following: Provide a few key bullet points about the 
license and when it should/should not be used. Then generate an 
example LICENSE file for that license. If the example file contains
 the text [NAME] or [YOUR NAME], replace that text with " + 
user.data.name + ". If the LICENSE file contains the text [YEAR], 
replace [YEAR] with the current year.",
  })</pre>

<p>We are adding content to the prompt we received from the chat to tell the LLM what we want it to look for and how to respond. This is the key to making an agent extension work—providing a detailed prompt to the LLM to tell it what we want it to pay attention to and the kind of output we require. Think of it as similar to interacting directly with a model like ChatGPT. The more details we can provide in our prompt conversation, the better response we can expect from the AI. The logic we use in our agent code to get the desired outcome really comes down to crafting a good prompt.</p>

<div data-type="note" epub:type="note">
<h1>Crafting a Good Prompt</h1>

<p><a contenteditable="false" data-primary="prompts" data-secondary="creating" data-type="indexterm" id="id936"/>Any number of resources are available with guidance on crafting a good prompt. Ultimately, the best prompt is the one that works as you intend in terms of parsing out the right information and returning a meaningful response.</p>

<p>One simple approach to this is trying out and then refining your prompt through the Copilot Chat interface (or an AI model) directly first. Once you have found a prompt that works, you can add it into your extension’s code.</p>
</div>

<p>With this basic setup, we have the core code we need for our extension. The necessary code for running this extension was created in a <em>nonproduction<a contenteditable="false" data-primary="nonproduction environment" data-type="indexterm" id="id937"/></em> environment. Taking this to production would require more implementation.</p>

<p>To help simplify the larger implementation for production, GitHub has made an SDK available that implements some of the core functionality needed for production extensions. At the time of this writing, the SDK is only an alpha release and only suitable for extensions implemented as agents. You can learn more about it in the sidebar.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id938">
<h1>GitHub Copilot Extensions SDK</h1>

<p>To simplify some common tasks when building an extension as an agent, GitHub has provided an SDK. The <em>GitHub Copilot extensions SDK</em><a contenteditable="false" data-primary="GitHub Copilot extensions SDK" data-type="indexterm" id="xi_GitHubCopilotExtensionsSDK10360139"/>, also known as the <em>Preview SDK</em><a contenteditable="false" data-primary="Preview SDK" data-type="indexterm" id="xi_PreviewSDK10360179"/>, is a tool designed to simplify and speed up implementation of GitHub Copilot extensions written as agents. The SDK can be used to automate common tasks such as the following:</p>

<dl>
	<dt>Request payload verification</dt>
	<dd>Ensures that incoming requests are valid and secure</dd>
	<dt>Payload parsing</dt>
	<dd>Simplifies the extraction of relevant data from requests</dd>
	<dt>Response building</dt>
	<dd>Formats responses in a way compatible with Copilot Chat</dd>
	<dt>Streamline API interactions</dt>
	<dd>Provides utilities to integrate external tools, APIs, or data sources directly into Copilot Chat without needing to write repetitive integration code</dd>
</dl>

<p>By handling these kinds of boilerplate tasks, use of the SDK lets developers focus on the extension’s core functionality. The code for the SDK is located in GitHub’s <a href="https://oreil.ly/Dgdr4">Copilot extensions area</a>. For the sake of brevity and because it is still early in the SDK’s development, we won’t go into how to use the SDK’s functionality, but you can find basic examples of common tasks in the project’s <a href="https://oreil.ly/G_IfL"><em>README.md file</em></a>. An <a href="https://oreil.ly/PjTdz">examples folder</a> also includes a couple of basic examples of how to use the SDK.</p>
</div></aside>

<p>We need a server and an app to complete the implementation. Let’s look at how those can be set up<a contenteditable="false" data-primary="" data-startref="xi_GitHubCopilotExtensionsSDK10360139" data-type="indexterm" id="id939"/><a contenteditable="false" data-primary="" data-startref="xi_PreviewSDK10360179" data-type="indexterm" id="id940"/>.</p>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Configuring a GitHub App for a Copilot Agent Extension"><div class="sect2" id="configuring-github-app">
<h2 class="less_space">Configuring a GitHub App for a Copilot Agent Extension</h2>

<p><a contenteditable="false" data-primary="GitHub App" data-secondary="configuring for Copilot Agent extensions" data-type="indexterm" id="xi_GitHubAppconfiguringforCopilotAgentextensions103824"/><a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-secondary="configuring GitHub Apps for using" data-type="indexterm" id="xi_ExtensionsGitHubCopilotconfiguringGitHubAppsforusing103824"/>In this example, we’re leveraging a GitHub Codespace to provide the runtime environment and server for the endpoint. Using a codespace is not something you would do in production use, but it simplifies the process quite a bit for our basic demo and testing scenarios. You could also use a service like ngrok if you preferred.</p>

<p>The steps for creating a codespace from a GitHub repository are outlined <a href="https://oreil.ly/DCh4K">in the documentation</a>. Once the codespace is started, you just need two commands to get the server going:</p>

<pre data-type="programlisting" translate="no">
npm install
npm start
</pre>

<div data-type="note" epub:type="note">
<h1>Node App and npm</h1>

<p><a contenteditable="false" data-primary="node app" data-type="indexterm" id="id941"/>The code here is a <a href="https://nodejs.org/en/about">node app</a>, and <a href="https://npmjs.com">npm</a><a contenteditable="false" data-primary="npm" data-type="indexterm" id="id942"/> is a node tool used to run it.</p>
</div>

<p>At this point, you’ll have a server running from the codespace on port 3000. You need to take two steps prior to configuring a GitHub App for the extension. First, you need to make the port serving the endpoint <em>public</em> instead of <em>private</em>. To do that, switch to the Ports tab in the codespace, right-click the port in the list, and change its Port Visibility setting to Public, as shown in <a data-type="xref" href="#changing-port-to-publ">Figure 10-14</a>.</p>

<figure><div id="changing-port-to-publ" class="figure"><img alt="" src="assets/lghc_1014.png" width="999" height="548"/>
<h6><span class="label">Figure 10-14. </span>Changing the port to public</h6>
</div></figure>

<p>Then copy the server address from the same location (<a data-type="xref" href="#copying-the-port-addr">Figure 10-15</a>).</p>

<figure><div id="copying-the-port-addr" class="figure"><img alt="" src="assets/lghc_1015.png" width="2422" height="1278"/>
<h6><span class="label">Figure 10-15. </span>Copying the port address</h6>
</div></figure>

<div data-type="note" epub:type="note">
<h1>Behind the Scenes</h1>

<p>If you want to understand more about how the codespace is configured and how the server is started, the port selected, etc., take a look at the files <a href="https://oreil.ly/E9daL"><em>.devcontainer/devcontainer.json</em></a> and <a href="https://oreil.ly/HTlM8"><em>.vscode/launch.json</em></a> in the GitHub repository.</p>
</div>

<p>With the code implemented for the extension agent and the server running, we’re now ready to complete the implementation of the extension itself by creating and configuring a corresponding GitHub App.</p>

<div data-type="warning" epub:type="warning">
<h1>For Development and Test Purposes Only</h1>

<p>In our examples in this chapter, we are creating code, setting up simple servers, and implementing user-specific agents for demo purposes. To convert these examples to production-ready instances, you would need to add functionality for security, hosting, and more.</p>
</div>

<p class="pagebreak-before">To set up the app, log into GitHub with the same ID as the the one used to run the codespace. Then go to your developer settings and create a new app. The shortcut link for this is <a href="https://github.com/settings/apps/new"><em>https://github.com/settings/apps/new</em></a>.</p>

<p>Next, fill in the required fields. The App Name should be a unique name. This is the name that you will use in the Copilot Chat interface to invoke your extension. For example, if you choose <em>my-app</em> for the name, you would use <code translate="no">@my-app</code> in the chat interface to invoke your extension.</p>

<p>For the Homepage URL field, you can provide a URL that goes to a web page about your app/extension if you have a page. If not, you can just put in the link to the GitHub repository for your extension or even just <a href="https://github.com"><em>https://github.com</em></a>.</p>

<p>The Callback URL field is where you place the public URL address from the port you set as public in the codespace. This must be in place in order for your extension to send and receive responses for its code. You should also add <code translate="no">/callback</code> at the end of the URL.</p>

<p class="fix_trackings">For the examples we’re using here, we can disable any other selected options on this page, such as <em>Webhooks</em>. Next is the app’s visibility setting. You can make it accessible only to you for development and testing purposes. Later, you can enable public access when you’re ready to share. <a data-type="xref" href="#initial-agent-extensi">Figure 10-16</a> shows an example page with completed fields.</p>

<p>When you have completed this screen, you can click Create GitHub App to complete the registration.</p>

<figure><div id="initial-agent-extensi" class="figure"><img alt="" src="assets/lghc_1016.png" width="765" height="759"/>
<h6><span class="label">Figure 10-16. </span>Initial agent extension configuration</h6>
</div></figure>

<p class="pagebreak-before">At this point, you’ll need to generate a private key in order to install your app and sign access tokens. GitHub will provide you with a link to generate and download the key (<a data-type="xref" href="#generate-a-private-ke">Figure 10-17</a>). The key will then be automatically added to your app’s <span class="keep-together">configuration</span>.</p>

<figure><div id="generate-a-private-ke" class="figure"><img alt="" src="assets/lghc_1017.png" width="1133" height="271"/>
<h6><span class="label">Figure 10-17. </span>Generating a private key to install the app</h6>
</div></figure>

<p>Once you’ve created the app on the General page, you need to do a bit more configuration by using the selections on the left. On the Permissions &amp; Events page, the only option you must set for dev/test purposes is in the Account Permissions section. Give Copilot Chat read-only permissions (<a data-type="xref" href="#adding-permissions-fo">Figure 10-18</a>). Then save those changes.</p>

<figure><div id="adding-permissions-fo" class="figure"><img alt="" src="assets/lghc_1018.png" width="1311" height="953"/>
<h6><span class="label">Figure 10-18. </span>Adding permissions for Copilot Chat</h6>
</div></figure>

<p>On the Copilot-specific settings page, change the app type from Disabled to Agent (since we’re implementing our extension as an agent). Then, in the URL section, paste the public URL from your codespace.</p>

<p class="pagebreak-before">Lastly on this page, add content in the “Inference description” field. This information is used to provide a brief description of your agent to help users understand the purpose of the extension. The contents are displayed to users when they hover over the extension’s slug in the chat area. After completing this, you can save your changes. <a data-type="xref" href="#copilot-settings-for">Figure 10-19</a> shows the completed page.</p>

<figure><div id="copilot-settings-for" class="figure"><img alt="" src="assets/lghc_1019.png" width="1186" height="946"/>
<h6><span class="label">Figure 10-19. </span>Copilot settings for the app</h6>
</div></figure>

<p>These are all the required fields you need to set up for the app to work with your agent. An Optional Features page only allows you to opt out of token expiration, and an Advanced page handles Danger Zone types of options for transferring ownership of the app, deleting the app, or making it public.</p>

<p class="pagebreak-before">After completing the preceding steps, you can install the app in your personal or organizational account for testing. To do this, click the Install App page and follow the instructions.</p>

<p>The first time you attempt to use the extension, you’ll need to authorize access for it to continue (<a data-type="xref" href="#connecting-the-app-on">Figure 10-20</a>).</p>

<figure><div id="connecting-the-app-on" class="figure"><img alt="" src="assets/lghc_1020.png" width="921" height="848"/>
<h6><span class="label">Figure 10-20. </span>Connecting the app on the first use</h6>
</div></figure>

<p>After clicking the Connect button, you’ll need to authorize the app to access the relevant resources (<a data-type="xref" href="#authorizing-app">Figure 10-21</a>).</p>

<figure><div id="authorizing-app" class="figure"><img alt="" src="assets/lghc_1021.png" width="684" height="744"/>
<h6><span class="label">Figure 10-21. </span>Authorizing the app</h6>
</div></figure>

<p>Once the app is authorized, you’re ready to use the extension as shown earlier.</p>

<p>Another way to create an extension is to utilize the <em>skillsets</em> pattern. This implementation choice works well for allowing Copilot to get real-time targeted information or do simple API processing easily. But while it can be a simpler coding implementation, it does require a more complex app configuration. We’ll explore extensions implemented via skillsets in the next section<a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotimplementingasagents102514" data-type="indexterm" id="id943"/><a contenteditable="false" data-primary="" data-startref="xi_agentsimplementingCopilotExtensionsas102514" data-type="indexterm" id="id944"/><a contenteditable="false" data-primary="" data-startref="xi_GitHubAppconfiguringforCopilotAgentextensions103824" data-type="indexterm" id="id945"/><a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotconfiguringGitHubAppsforusing103824" data-type="indexterm" id="id946"/>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Implementing an Extension via Skillsets"><div class="sect1" id="id117">
<h1>Implementing an Extension via Skillsets</h1>

<p><a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-secondary="implementing via skillsets" data-type="indexterm" id="xi_ExtensionsGitHubCopilotimplementingviaskillsets104894"/><a contenteditable="false" data-primary="skillsets" data-secondary="implementing Code extensions via" data-type="indexterm" id="xi_skillsetsimplementingCodeExtensionsvia104894"/>While agents provide a powerful and flexible architecture for implementing Copilot extensions, they can be overkill. If all you need to do in response to a chat prompt is invoke a specific tool or call an API, you can implement your extension by using skillsets instead.</p>

<p>A single<em> skill<a contenteditable="false" data-primary="skill" data-type="indexterm" id="id947"/></em> in Copilot is a tool that the model calls to do a specific task in response to a prompt—for example, calling an external API. A collection of up to five skills is called a <em>skillset</em>. These skillsets allow for integration of external services or custom API endpoints into the Copilot workflow, without the complexity of agents.</p>

<p>Skillsets are more lightweight and simpler than agents. They are a better architecture choice when you need to do simple, specific tasks without a lot of setup. They can automatically handle tasks like routing, prompt crafting, function evaluation, and response generation.</p>

<p><a data-type="xref" href="#overview-skillset-extension">Figure 10-22</a> shows at a high level how a skillset extension works. I’ll have more to say about the individual pieces in the following sections.</p>

<figure><div id="overview-skillset-extension" class="figure"><img alt="" src="assets/lghc_1022.png" width="1438" height="547"/>
<h6><span class="label">Figure 10-22. </span>Overview of a skillset extension</h6>
</div></figure>

<section data-type="sect2" data-pdf-bookmark="Performing a Basic Implementation"><div class="sect2" id="id118">
<h2>Performing a Basic Implementation</h2>

<p>As an example for the book, I’ve created a simple Copilot extension, implemented with skillsets, that allows you to do three basic operations for Go releases:</p>

<ul>
	<li>Find out the latest release of Go</li>
	<li>Find out the currently supported releases of Go</li>
	<li>Determine whether a given release of Go is supported or when it reached its end of life (EOL)</li>
</ul>

<p>The code for this example lives in <a href="https://oreil.ly/n13JY">book’s GitHub repository</a><a contenteditable="false" data-primary="GitHub repository" data-type="indexterm" id="id948"/><a contenteditable="false" data-primary="repositories" data-secondary="GitHub" data-type="indexterm" id="id949"/>. To show an example of implementing an extension in a different language, the code for the <code translate="no">gover-ext</code> extension is written in Go. It is modeled after the Copilot <a href="https://oreil.ly/WWZxW">skillset extension example</a>.</p>

<p>A <a href="https://oreil.ly/8dk9j"><em>main.go file </em></a><em>registers</em> handler functions for specific URL patterns related to each of the capabilities of the extension. The core logic is shown here:</p>

<pre data-type="programlisting" translate="no">
func main() {
    if err := run(); err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}

func run() error {
    http.HandleFunc("/latest-version-go", handlers.LatestVersionGo)
    http.HandleFunc("/supported-versions-go", 
handlers.SupportedVersionsGo)
    http.HandleFunc("/is-supported-or-eol", 
handlers.IsSupportedOrEOL)
    http.HandleFunc("/_ping", func(w http.ResponseWriter, 
r *http.Request) {
        w.Write([]byte("OK"))
    })

    http.ListenAndServe(":8080", nil)
    return nil
}
</pre>

<p>For each of the handlers, we implement a separate function that invokes an API, checks for errors, and returns the desired results. For example, in the handler for getting the latest version—<a href="https://oreil.ly/TxXMz">LatestVersionGo</a><a contenteditable="false" data-primary="LatestVersionGo" data-type="indexterm" id="id950"/>—the key parts of the code are implemented as follows.</p>

<p>First, we implement a structure to hold the version and make a call to the Go site’s API to get the latest version:</p>

<pre data-type="programlisting" translate="no">
type GoVersion struct {
    Version string `json:"version"`
}

func LatestVersionGo(w http.ResponseWriter, r *http.Request) {
    fmt.Println("Latest Go Version Called")
    req, err := http.NewRequestWithContext(r.Context(), 
http.MethodGet, "https://go.dev/dl/?mode=json", nil)
    if err != nil {
        http.Error(w, "Failed to create request", 
http.StatusInternalServerError)
        return
    }
</pre>

<p>After doing some error checking to make sure the call was successful, we buffer the response and then parse it to get the latest version and write that back to the stream:</p>

<pre data-type="programlisting" translate="no">
// Buffer the response body for decoding
    var bodyBuffer bytes.Buffer
    tee := io.TeeReader(resp.Body, &amp;bodyBuffer)

    // Drain the tee to ensure we can parse the body later
    if _, err := io.Copy(io.Discard, tee); err != nil {
        http.Error(w, "Failed to process response body", 
http.StatusInternalServerError)
        return
    }

    // Parse the JSON response
    var versions []GoVersion
    if err := json.NewDecoder(&amp;bodyBuffer).Decode(&amp;versions); 
err != nil {
        http.Error(w, "Failed to parse JSON response", 
http.StatusInternalServerError)
        fmt.Printf("Failed to decode JSON: %v\n", err)
        return
    }

    // The latest version is the first item in the array
    if len(versions) &gt; 0 {
        trimmedVersion := strings.TrimPrefix(versions[0].Version, 
"go")
        fmt.Fprintf(w, "%s", trimmedVersion) // Write the version 
to the HTTP response
        return
    }
</pre>

<p>The handler for the supported versions query uses a similar approach. There’s a structure to hold the data and a call to a different API to get the raw information:</p>

<pre data-type="programlisting" translate="no">
type VersionInfo struct {
    Cycle       string      `json:"cycle"`
    ReleaseDate string      `json:"releaseDate"`
    EOL         interface{} `json:"eol"`
}

func SupportedVersionsGo(w http.ResponseWriter, r *http.Request) {
    fmt.Println("Supported Go Versions Called")
    req, err := http.NewRequestWithContext(r.Context(), 
http.MethodGet, "https://endoflife.date/api/go.json", nil)
    if err != nil {
        http.Error(w, "Failed to create request", 
http.StatusInternalServerError)
        return
    }
</pre>

<p>Then after some error checking to make sure the call was successful, and buffering the response, the results are parsed and converted into a single string that is written back to the stream:</p>

<pre data-type="programlisting" translate="no">
// Parse the JSON into a slice of VersionInfo
    var versions []VersionInfo
    if err := json.NewDecoder(&amp;bodyBuffer).Decode(&amp;versions); 
err != nil {
        http.Error(w, "Failed to parse JSON response", 
http.StatusInternalServerError)
        fmt.Printf("Failed to decode JSON: %v\n", err)
        return
    }

    // Filter versions with eol == false and collect the results
    result := make([]struct {
        Cycle       string `json:"cycle"`
        ReleaseDate string `json:"releaseDate"`
    }, 0)

    for _, v := range versions {
        // Check if EOL is a boolean and is false
        if eolBool, ok := v.EOL.(bool); ok &amp;&amp; !eolBool {
            result = append(result, struct {
                Cycle       string `json:"cycle"`
                ReleaseDate string `json:"releaseDate"`
            }{
                Cycle:       v.Cycle,
                ReleaseDate: v.ReleaseDate,
            })
        }
    }

    // Convert the result to a single string
    var builder strings.Builder
    for _, r := range result {
        builder.WriteString(fmt.Sprintf("Version: %s, Release Date:
 %s\n", r.Cycle, r.ReleaseDate))
    }

    // The versions are all in one string now
    if len(builder.String()) &gt; 0 {
        fmt.Fprintf(w, "%s", builder.String()) // Write the list of 
supported versions to the HTTP response
        return
    }
</pre>

<p>The flow for the other function to determine whether a version is supported or has reached EOL is similar.</p>

<p>Since the coding is pretty basic and makes no mention of the AI or inferences, you may be wondering how the prompts in Copilot Chat ultimately end up invoking the respective handlers. The secret is in the GitHub App configuration when you are creating an extension that uses skillsets.</p>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Configuring a GitHub App for a Copilot Extension Using Skillsets"><div class="sect2" id="id119">
<h2 class="less_space">Configuring a GitHub App for a Copilot Extension Using Skillsets</h2>

<p><a contenteditable="false" data-primary="skillsets" data-secondary="configuring GitHub Apps for Copilot extensions using" data-type="indexterm" id="xi_skillsetsconfiguringGitHubAppsforCopilotExtensionsusing106694"/><a contenteditable="false" data-primary="GitHub App" data-secondary="configuring for Copilot extensions using skillsets" data-type="indexterm" id="xi_GitHubAppconfiguringforCopilotExtensionsusingskillsets106694"/><a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-secondary="configuring GitHub Apps for using skillsets" data-type="indexterm" id="xi_ExtensionsGitHubCopilotconfiguringGitHubAppsforusingskillsets106694"/>Like extensions that are implemented as agents, extensions implemented as skillsets need a GitHub App to act as a bridge between Copilot’s chat interface and the underlying extension implementation. Much of the setup is similar to that done for agents, but we’ll cover some significant differences here. (For any other details on app setup and configuration, you can refer back to <a data-type="xref" href="#configuring-github-app">“Configuring a GitHub App for a Copilot Agent Extension”</a>.)</p>

<p>The first difference is that, on the General page, you do not have to put in an extension-specific Callback URL. You will need a callback URL for authentication, but it can be a simple URL like <a href="https://github.com"><em>https://github.com</em></a>.</p>

<p>The other changes for configuring the app, and the most significant ones, are done on the Copilot page. On this page, you need to set the App Type field to Skillset. Doing this will then bring up a section called Skill definitions (<a data-type="xref" href="#copilot-page-for-skil">Figure 10-23</a>).</p>

<figure><div id="copilot-page-for-skil" class="figure"><img alt="" src="assets/lghc_1023.png" width="1343" height="744"/>
<h6><span class="label">Figure 10-23. </span>The Copilot page for setting up the skillset app</h6>
</div></figure>

<p>The “Skill definitions” section is where the mapping happens from the prompt in chat to the handlers in the code. For each skill that we are handling in our code, we need to go through the process of adding a new skill. We’ll look at one as an example. The others follow the same pattern.</p>

<p class="pagebreak-before">When you click the “Add new skill” button, you get a dialog with various fields to fill in, including Name, Inference description, URL, and Parameters (<a data-type="xref" href="#new-skill-definition">Figure 10-24</a>).</p>

<figure><div id="new-skill-definition" class="figure"><img alt="" src="assets/lghc_1024.png" width="703" height="836"/>
<h6><span class="label">Figure 10-24. </span>New skill definition screen for the app</h6>
</div></figure>

<p>In the Name field, we put the name of the skill to be used by the model, and that is shown to the user when it is invoked.</p>

<p>In the “Inference description” field, we are explaining to the model <em>what/when/how </em>this skill should be invoked. This description should be meaningful enough that the model can understand what is intended.</p>

<p class="pagebreak-before">Think of this as the direct prompt that you might supply to the model if you wanted it to execute this skill. While we are using a simple prompt here, depending on what your skill does and how complex it is, you may want to define additional details. Examples could include expected inputs and outputs, especially if other skillsets are very similar. <a data-type="xref" href="#skill-definition-in-a">Figure 10-25</a> shows an example definition including the inference description matching one of the skills we are using.</p>

<figure><div id="skill-definition-in-a" class="figure"><img alt="" src="assets/lghc_1025.png" width="848" height="908"/>
<h6><span class="label">Figure 10-25. </span>Skill definition in the app </h6>
</div></figure>

<p>Based on the prompt in the chat and how well the model can match it up with the Inference description, the process will invoke the endpoint specified in the URL field. This field is where you put the endpoint server address with the path specified in the extension code. In this case, since our extension code is looking for <code translate="no">latest-version-go</code> to know to invoke the handler for getting the latest Go version, we can put the API endpoint in this field with <code translate="no">latest-version-go </code>at the end.</p>

<p class="pagebreak-before">In production, we would have a designated public URL that this would be directed to. But if we’re using ngrok, a codespace, or something similar to serve this, we would put the public URL being served from those applications with <em>latest-version-go<a contenteditable="false" data-primary="LatestVersionGo" data-type="indexterm" id="id951"/></em> appended. For an <a href="https://ngrok.com">ngrok</a><a contenteditable="false" data-primary="ngrok" data-type="indexterm" id="id952"/> instance, the entire URL would look something like this:</p>

<pre data-type="programlisting" translate="no">
https://8fa7-2605-a601-a6ca-f00-1466-39cc-11f7-7f71.ngrok-free.app/
latest-version-go</pre>

<div data-type="warning" epub:type="warning">
<h1>Localhost URL and ngrok</h1>

<p><em>ngrok<a contenteditable="false" data-primary="ngrok" data-type="indexterm" id="id953"/></em> l<a contenteditable="false" data-primary="localhost URL" data-type="indexterm" id="id954"/>ets you create secure tunnels from a public internet endpoint to a locally running service on your machine. This cross-platform tool lets you easily expose local web servers to the internet for testing and sharing without having to set up complex networking configurations.</p>

<p>While you would typically start ngrok serving on localhost:8080, you cannot use localhost in the skill configuration because it is not publicly reachable. Instead, you’ll need to grab the actual public URL that ngrok is forwarding to localhost:8080.</p>
</div>

<p>If we were using a codespace, the URL might look like this:</p>

<pre data-type="programlisting" translate="no">
https://turbo-dollop-p74p45vgx739pqj-8080.app.github.dev/latest-
version-go</pre>

<p>The Parameters section is for defining the parameters of the skill in JSON. Since each of our skillsets keys off the prompt string, we can simply use the following in this field:</p>

<pre data-type="programlisting" translate="no">
{ "type": "object" }
</pre>

<p>Once we have the implementation completed and the app set up and configured, we can run the app in the same way as we did for the agent one. <a data-type="xref" href="#running-the-go-versio">Figure 10-26</a> shows an example of trying out the various skills from the extension. Notice the specific prompts that are being used: “@go-versions supported versions” and “@go-versions 1.21” (as shown on the right).</p>

<figure><div id="running-the-go-versio" class="figure"><img alt="" src="assets/lghc_1026.png" width="789" height="867"/>
<h6><span class="label">Figure 10-26. </span>Running the <code>go-versions</code> extension</h6>
</div></figure>

<p>Extensions implemented as agents and skillsets provide maximum flexibility with their ability to be run in any of the integrated chat interfaces (GitHub, IDEs). Now that we’ve covered those, it’s time to look at the other alternative for adding capabilities into the IDE mentioned at the start of the chapter—VS Code extensions for Copilot<a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotimplementingviaskillsets104894" data-type="indexterm" id="id955"/><a contenteditable="false" data-primary="" data-startref="xi_skillsetsimplementingCodeExtensionsvia104894" data-type="indexterm" id="id956"/><a contenteditable="false" data-primary="" data-startref="xi_skillsetsconfiguringGitHubAppsforCopilotExtensionsusing106694" data-type="indexterm" id="id957"/><a contenteditable="false" data-primary="" data-startref="xi_GitHubAppconfiguringforCopilotExtensionsusingskillsets106694" data-type="indexterm" id="id958"/><a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotconfiguringGitHubAppsforusingskillsets106694" data-type="indexterm" id="id959"/>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Creating VS Code Extensions for Copilot"><div class="sect1" id="id120">
<h1>Creating VS Code Extensions for Copilot</h1>

<p><a contenteditable="false" data-primary="VS Code (Visual Studio Code)" data-secondary="creating Copilot extensions" data-type="indexterm" id="xi_VSCodeVisualStudioCodecreatingCopilotExtensions107394"/><a contenteditable="false" data-primary="extensions (GitHub Copilot)" data-secondary="creating with VS code" data-type="indexterm" id="xi_ExtensionsGitHubCopilotcreatingwithVScode107394"/>Like Copilot extensions, VS Code extensions for Copilot provide additional capabilities for the user through Copilot Chat. Unlike Copilot extensions, VS Code extensions are implemented using the VS Code platform and APIs. Because of that implementation approach, the VS Code extensions have access to broad and deep VS Code functionality and can have tight integration. And they don’t require a separate GitHub App to use. The disadvantage is that you can’t use them in other non-IDE clients (like a chat interface in GitHub). <a data-type="xref" href="#comparison2-of-copilot">Table 10-2</a> shows an updated version of our earlier comparison table with an added column for VS Code extensions for Copilot.</p>

<table class="border" id="comparison2-of-copilot">
	<caption><span class="label">Table 10-2. </span>Comparison of Copilot extension types</caption>
	<thead>
		<tr>
			<th>Attribute</th>
			<th>Copilot agents</th>
			<th>Copilot skillsets</th>
			<th>VS Code extensions for Copilot</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>Complexity</th>
			<td>Requires more development effort to manage the entire user interaction flow response and response generation</td>
			<td>Designed for easy integration with minimal setup</td>
			<td>Can be complex or simple, depending on VS Code APIs used</td>
		</tr>
		<tr>
			<th>Control</th>
			<td><span data-huuid="4493955542516024087">Provides full control over how requests are processed and how responses are generated</span></td>
			<td><span data-huuid="4493955542516024087">Limited control over the user interaction, focus is on data retrieval and basic actions</span></td>
			<td>Most control as written for VS Code only</td>
		</tr>
		<tr>
			<th>Use cases</th>
			<td><span data-huuid="4493955542516024406">Suitable for complex scenarios where you need to implement custom logic, integrate with other AI models, and manage conversation context</span></td>
			<td><span data-huuid="4493955542516024406">Straightforward tasks like fetching data from an external API or performing simple operations</span></td>
			<td>Tasks for working with code in the IDE and, optionally, providing additional commands for the participant</td>
		</tr>
		<tr>
			<th>Interfaces available</th>
			<td>All (GitHub, IDEs)</td>
			<td>All (GitHub, IDEs)</td>
			<td>Limited to VS Code to get full advantage of all VS Code APIs</td>
		</tr>
		<tr>
			<th>Support</th>
			<td>GitHub</td>
			<td>GitHub</td>
			<td>VS Code Team<br/>
			 </td>
		</tr>
	</tbody>
</table>

<p>Ultimately, what the user sees when we add a VS Code extension for Copilot is a new chat participant.</p>

<p>A <em>chat <a contenteditable="false" data-primary="Copilot Chat" data-secondary="participants" data-type="indexterm" id="id960"/>participant<a contenteditable="false" data-primary="participants (chat)" data-secondary="Copilot Chat" data-type="indexterm" id="id961"/><a contenteditable="false" data-primary="chat participants" data-secondary="Copilot Chat" data-type="indexterm" id="id962"/> </em>is a domain expert that can answer questions about a specific topic, or perform specific tasks, when you are working with Copilot Chat in an IDE. We’ve discussed these before in the context of participants that come built-in with Copilot (see <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>). For example, the built-in <code translate="no">@workspace<a contenteditable="false" data-primary="@workspace chat participant" data-type="indexterm" id="id963"/></code> participant can respond relative to your entire VS Code workspace. To do this, it uses integrated tools such as semantic search and code indexes. Other examples we’ve discussed include <code translate="no">@termi⁠nal</code> and <code translate="no">@vscode</code>.</p>

<p>Chat participants are invoked using the same <code translate="no">@identifier</code> syntax as for other extensions. Once a participant is invoked and passed a prompt, the code for the participant can use one of several approaches to handle the prompt. These include the following:</p>

<ul>
	<li>Calling an AI model to interpret and respond</li>
	<li>Forwarding the request to a backend service</li>
	<li>Using built-in logic and/or APIs to do the processing</li>
</ul>

<p>Because of the underlying tight integration with VS Code, chat participants can return responses that include interactive elements like buttons, file trees, or progress updates. The chat participants can also provide follow-up suggestions and their own slash commands (as in previous examples, such as <code translate="no">/explain</code> and <code translate="no">/fix</code>) that are related to the participant’s domain.</p>

<p>In short, VS Code extensions for Copilot can provide rich <em>client-side</em> experiences. These extensions have access to the VS Code client context and interfaces on the frontend, while utilizing the power of Copilot on the backend.</p>

<div data-type="note" epub:type="note">
<h1>Chat Participants in Other IDEs</h1>

<p><a contenteditable="false" data-primary="IDEs" data-secondary="chat participants in other" data-type="indexterm" id="id964"/>While we are focusing on VS Code in this chapter, chat participants are available in other IDEs as well. Likewise, depending on the capabilities of the underlying IDE platform, VS Code extensions for Copilot could be ported to other IDEs where Copilot also runs.</p>
</div>

<p>The implementation example we’ll use for this extension is an <em>API finder<a contenteditable="false" data-primary="API finder" data-type="indexterm" id="id965"/></em>. This extension, when installed in VS Code, allows the user to search for APIs that perform a certain function and stream back information in the chat interface on the APIs and how to use them.</p>

<p><a data-type="xref" href="#overview-vscode-extension">Figure 10-27</a> shows at a high level how a VS Code extension for Copilot works. I’ll have more to say about the individual pieces in the following sections.</p>

<figure><div id="overview-vscode-extension" class="figure"><img alt="" src="assets/lghc_1027.png" width="1419" height="579"/>
<h6><span class="label">Figure 10-27. </span>Overview of a VS Code extension</h6>
</div></figure>

<p class="pagebreak-before"><a data-type="xref" href="#using-the-apifinder-c">Figure 10-28</a> shows an example of using the extension’s user-facing functionality to find suitable APIs.</p>

<figure><div id="using-the-apifinder-c" class="figure"><img alt="" src="assets/lghc_1028.png" width="970" height="879"/>
<h6><span class="label">Figure 10-28. </span>Using the API Finder chat participant to find weather APIs</h6>
</div></figure>

<p class="pagebreak-before">This extension also has an additional command built-in that can be invoked as <code translate="no">/⁠exam⁠ples</code>. <a data-type="xref" href="#using-the-command-fro">Figure 10-29</a> shows an example usage of the command.</p>

<figure><div id="using-the-command-fro" class="figure"><img alt="" src="assets/lghc_1029.png" width="1135" height="826"/>
<h6><span class="label">Figure 10-29. </span>Using the command from our chat participant</h6>
</div></figure>

<p>The code for the extension is located in <a href="https://oreil.ly/RUAtr">the book’s GitHub repository</a><a contenteditable="false" data-primary="GitHub repository" data-type="indexterm" id="id966"/><a contenteditable="false" data-primary="repositories" data-secondary="GitHub" data-type="indexterm" id="id967"/>. This one is implemented in TypeScript<a contenteditable="false" data-primary="TypeScript" data-type="indexterm" id="id968"/>, with the main logic in the file <a href="https://oreil.ly/VSPMM"><em>src/extension.ts</em></a>. This is based on the <a href="https://oreil.ly/uRBxt">example</a> in the VS Code extension examples in GitHub.</p>

<p>The code starts off by importing dependencies from VS Code’s libraries. Then it defines the prompt to send to the model for the base functionality and the one to send for the code font command:</p>

<pre data-type="programlisting" translate="no">
import * as vscode from 'vscode';

const BASE_PROMPT = 'You are a helpful API finder. Your job is to
 locate and provide documentation on the top 3 APIs that match the 
prompt. Respond with basic documentation about the API, how to call 
it, and its parameters. Cite your sources and provide links to more 
information where appropriate.  Use bullet points in explanations 
wherever possible. If the user asks a question that is not relevant 
to APIs, politely decline to respond.';

const SAMPLE_CODE_PROMPT = 'You are a helpful source of API examples.
 Your job is to locate the top 3 APIs that match the prompt and 
provide simple example code for how to call them. Keep the code as 
short as possible to still provide a usable, relevant example. 
If the user asks a question that is not relevant to APIs, politely 
decline to respond.';
</pre>

<p>Notice that we are being explicit about how we want the LLM to process our query by supplying detailed prompts to use.</p>

<div data-type="note" epub:type="note">
<h1>Specifying the Language for /examples</h1>

<p><a contenteditable="false" data-primary="language, specifying" data-type="indexterm" id="id969"/>In the previous example shown in <a data-type="xref" href="#using-the-command-fro">Figure 10-29</a>, we specified the language <code translate="no">Go</code> as a second argument on the prompt to <code translate="no">@apifinder /⁠examples<a contenteditable="false" data-primary="@apifinder /examples" data-type="indexterm" id="id970"/></code>. However, our prompt does not explicitly reference the programming language. This is a benefit of using the AI to handle the request. It infers additional context and meaning that we don’t have to explicitly call out.</p>
</div>

<p>Code at the bottom of the file instantiates the chat handler and adds an icon to it for use in chat:</p>

<pre data-type="programlisting" translate="no">
// create participant
const apifinder = vscode.chat.createChatParticipant("chat-tutorial.
api-finder", handler);

// add icon to participant
apifinder.iconPath = vscode.Uri.joinPath(context.extensionUri, 
'apifinder.jpeg');

</pre>

<p>The main processing function selects the prompt (based on whether we want the core functionality or are using the <code>examples<a contenteditable="false" data-primary="examples command" data-type="indexterm" id="id971"/></code> command). It then combines the prompt and any previous messages, sends that to the model, and streams the response:</p>

<pre data-type="programlisting" translate="no">
export function activate(context: vscode.ExtensionContext) {

    // define a chat handler
    const handler: vscode.ChatRequestHandler = async (request: 
vscode.ChatRequest, context: vscode.ChatContext, 
stream: vscode.ChatResponseStream, token: vscode.CancellationToken)
 =&gt; {
        // initialize the prompt
        let prompt = BASE_PROMPT;
        if (request.command === 'examples') {
            prompt = SAMPLE_CODE_PROMPT;
        }
        // initialize the messages array with the prompt
        const messages = [
            vscode.LanguageModelChatMessage.User(prompt),
        ];
        // get all the previous participant messages
        const previousMessages = context.history.filter(
            (h) =&gt; h instanceof vscode.ChatResponseTurn
        );
        // add the previous messages to the messages array
        previousMessages.forEach((m) =&gt; {
            let fullMessage = '';
            m.response.forEach((r) =&gt; {
                const mdPart = r as vscode.ChatResponseMarkdownPart;
                fullMessage += mdPart.value.value;
            });
            messages.push(vscode.LanguageModelChatMessage.Assistant
(fullMessage));
        });
        // add in the user's message
        messages.push(vscode.LanguageModelChatMessage.User
(request.prompt));
        // send the request
        const chatResponse = await request.model.sendRequest
(messages, {}, token);
        // stream the response
        for await (const fragment of chatResponse.text) {
            stream.markdown(fragment);
        }
        return;
    };
</pre>

<p>Testing this extension is as simple as opening the folder in VS Code, installing the dependencies with <code translate="no">npm install</code>, compiling the code via <code translate="no">npm run compile</code>, and then running the extension in a new VS Code instance.</p>

<div data-type="note" epub:type="note">
<h1>Running a Participant with the Debugger</h1>

<p><a contenteditable="false" data-primary="Copilot Chat" data-secondary="running participants with debugger" data-type="indexterm" id="id972"/><a contenteditable="false" data-primary="debugging" data-type="indexterm" id="id973"/>Probably the simplest way to test your participant code is to load it into a VS Code instance, run the <code translate="no">npm</code> commands, and then use the Start Debugging option from the Run menu to spin up a new instance of VS Code. The new debug instance will have the participant installed and active, so you can use it in that instance’s chat interface. Instructions can be found in the repository’s <a href="https://oreil.ly/QXsC_">README file</a>.</p>
</div>

<p>As with the other types of extensions, you would want to make additional changes before rolling this out to production, such as ensuring that authentication works as needed. The <a href="https://oreil.ly/UH18y">VS Code documentation</a><a contenteditable="false" data-primary="VS Code (Visual Studio Code)" data-secondary="documentation" data-type="indexterm" id="id974"/> describes implementation in much more detail. You can also find information on publishing your finished extension to the <a href="https://oreil.ly/HGZkA">VS Code Marketplace</a><a contenteditable="false" data-primary="" data-startref="xi_VSCodeVisualStudioCodecreatingCopilotExtensions107394" data-type="indexterm" id="id975"/><a contenteditable="false" data-primary="" data-startref="xi_ExtensionsGitHubCopilotcreatingwithVScode107394" data-type="indexterm" id="id976"/><a contenteditable="false" data-primary="VS Code Marketplace" data-type="indexterm" id="id977"/>.</p>
</div></section>

<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Conclusion"><div class="sect1" id="id380">
<h1 class="less_space">Conclusion</h1>

<p>GitHub Copilot extensions and VS Code extensions for Copilot provide a way to augment the built-in capabilities of GitHub Copilot. These extensions are accessed via the Copilot Chat interface and the <code translate="no">@</code> prefix.</p>

<p>The backend code for Copilot extensions can be architected in one of two ways. Agents are the most flexible option but also the most complex in general to implement. Extensions that use the skillsets architecture call one or more skills on the backend to get additional information. A skill can be as simple as an API call.</p>

<p>VS Code extensions for Copilot are architected on top of VS Code’s platform. They have full access to the underlying VS Code APIs and rely on VS Code to function. From a user-facing perspective, they provide VS Code chat participants, similar to the built-in ones like <code translate="no">@workspace</code> and <code translate="no">@terminal</code>.</p>

<p>The backend code for extensions can be implemented in several languages, including JavaScript, TypeScript, and Go. For extensions using the agent approach and JavaScript, GitHub has provided an early version of an SDK that can be used to simplify coding and help fill in production needs like authentication.</p>

<p>Copilot extensions (implemented as either agents or skillsets) require a GitHub App to bridge the connection between the Copilot chat interface and the backend code. While both use GitHub Apps, the configuration for each is different. Agents rely on a single callback URL defined in the app. Apps for skillsets require additional inference details in their configuration so that the AI can map the prompt to the correct skill API endpoint.</p>

<p>Since Copilot extensions utilize a GitHub App, they can run in any Copilot chat interface, including in an IDE or on GitHub. In contrast, since VS Code extensions for Copilot rely on VS Code APIs and functions, they can only be used in that <span class="keep-together">environment</span>.</p>
</div></section>
</div></section></div></div></body></html>