- en: 5 Agentic RAG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 代理 RAG
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What agentic RAG is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理 RAG 是什么
- en: Why we need agentic RAG
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要代理 RAG
- en: How to implement agentic RAG
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现代理 RAG
- en: In earlier chapters, we saw how to find relevant data using different methods
    of vector similarity search. Using similarity search, we can find relevant data
    in unstructured data sources, but data with a structure can often bring more value
    over unstructured data because there’s information in the structure itself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用不同的向量相似度搜索方法来查找相关数据。使用相似度搜索，我们可以在非结构化数据源中找到相关数据，但具有结构的数据往往比非结构化数据更有价值，因为结构本身包含信息。
- en: Adding structure to data can be an incremental process. We can start with a
    simple structure and then add more complex structures as we go. We saw this in
    the previous chapter, where we started with simple graph data and then added more
    complex structures to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据添加结构可以是一个逐步的过程。我们可以从一个简单的结构开始，然后随着进行添加更复杂的结构。我们在上一章中看到了这一点，我们从一个简单的图数据开始，然后向其中添加了更复杂的结构。
- en: An agentic RAG system (see figure 5.1) is a system where a variety of retrieval
    agents are available to retrieve the data needed to answer the user question.
    The starting interface to an agentic RAG system is usually a retriever router,
    whose job is to find the best-suited retriever (or retrievers) to perform the
    task at hand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 代理 RAG 系统（见图 5.1）是一个提供多种检索代理的系统，这些代理可以检索回答用户问题所需的数据。代理 RAG 系统的起始界面通常是一个检索路由器，其任务是找到最适合执行当前任务的检索器（或检索器）。
- en: One common way to implement an agentic RAG system is to use an LLM’s ability
    to use tools (sometimes called *function calling*). Not all LLMs have this ability,
    but OpenAI’s GPT-3.5 and GPT-4 do, and that is what we will use in this chapter.
    This can be achieved with most LLMs using the ReAct approach (see [https://arxiv.org/abs/2210.03629](https://arxiv.org/abs/2210.03629)),
    but over time, the current trajectory is that this feature will be available in
    all LLMs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实现代理 RAG 系统的一种常见方式是利用 LLM 使用工具的能力（有时称为 *函数调用*）。并非所有 LLM 都具备这种能力，但 OpenAI 的 GPT-3.5
    和 GPT-4 就有，这就是我们在本章中要使用的。这可以通过大多数 LLM 使用 ReAct 方法（见 [https://arxiv.org/abs/2210.03629](https://arxiv.org/abs/2210.03629)）来实现，但随着时间的推移，目前的趋势是这一功能将适用于所有
    LLM。
- en: '![figure](../Images/5-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/5-1.png)'
- en: Figure 5.1 The data flow for an application using agentic RAG
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1 使用代理 RAG 的应用程序数据流
- en: 5.1 What is agentic RAG?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 什么是代理 RAG？
- en: Agentic systems vary in sophistication and complexity, but the core idea is
    that the system can act on behalf of the user to perform tasks. In this chapter,
    we will look at a basic agentic system where the system only has to choose which
    retriever to use and decide whether the found context answers the question. In
    more advanced systems, the system might make up plans on what kind of tasks to
    perform to solve the task at hand. Starting from the basics as we do in this chapter
    is a good way to understand the core concepts of agentic systems, and for RAG
    tasks, this is often all you need.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代理系统在复杂性和复杂性方面各不相同，但核心思想是系统能够代表用户执行任务。在本章中，我们将探讨一个基本的代理系统，其中系统只需选择使用哪个检索器，并决定找到的上下文是否回答了问题。在更高级的系统中，系统可能会制定计划执行什么类型的任务来解决当前任务。从本章的基本内容开始是一个理解代理系统核心概念的好方法，对于
    RAG 任务，这通常就是你所需要的。
- en: 'Agentic RAG is a system whereby a variety of retrieval agents are available
    to retrieve the data needed to answer the user question. Successful agentic RAG
    systems require a few foundational parts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代理 RAG 是一个系统，其中提供了多种检索代理来检索回答用户问题所需的数据。成功的代理 RAG 系统需要几个基础部分：
- en: '*Retriever router* —A function that takes in the user question(s) and returns
    the best retriever(s) to use'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检索路由器* — 一个接收用户问题并返回最佳检索器（或检索器）的功能'
- en: '*Retriever agents* —The actual retrievers that can be used to retrieve the
    data needed to answer the user question(s)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检索代理* — 实际上可以用来检索回答用户问题所需数据的检索器'
- en: '*Answer critic* —A function that takes in the answers from the retrievers and
    checks if the original question is answered correctly'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*答案评论员* — 一个接收检索器答案并检查原始问题是否得到正确回答的功能'
- en: 5.1.1 Retriever agents
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 检索代理
- en: Retriever agents are the actual retrievers that can be used to retrieve the
    data needed to answer the user question(s). These retrievers can be very broad,
    like a vector similarity search, or very specific, like a template of a hardcoded
    database query that takes in parameters, such as the retriever router, covered
    in section 5.1.2.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 检索代理是实际用于检索回答用户问题所需数据的检索器。这些检索器可以是非常广泛的，例如向量相似度搜索，或者非常具体的，例如一个硬编码的数据库查询模板，它接收参数，例如第5.1.2节中提到的检索路由器。
- en: A few generic retriever agents are relevant in most agentic RAG systems, like
    vector similarity search and text2cypher. The former is useful for unstructured
    data sources and the latter for structured data in a graph database, but in a
    real-world production system, it’s not trivial to make any of them perform at
    par with user expectations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数代理RAG（检索增强生成）系统中，一些通用的检索代理是相关的，如向量相似度搜索和text2cypher。前者适用于非结构化数据源，后者适用于图数据库中的结构化数据，但在现实世界的生产系统中，要使任何这些达到用户期望的水平并不简单。
- en: That’s why we need specialized retrievers that are very narrow but perform very
    well at what they’re meant for. These specialized retrievers can be built over
    time as we identify questions that the generic retrievers have problems generating
    queries to answer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们需要专门的检索器，它们非常狭窄但执行得非常好。随着我们识别出通用检索器在生成查询以回答问题时遇到的问题，这些专门的检索器可以随着时间的推移而构建。
- en: 5.1.2 The retriever router
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 检索路由器
- en: To pick the right retriever for the job, we have something called a retriever
    router. The retriever router is a function that takes in the user question and
    returns the best retriever(s) to use. How the router makes this decision can vary,
    but usually an LLM is used to make this decision.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择适合工作的正确检索器，我们有一个叫做检索路由器的机制。检索路由器是一个函数，它接收用户问题并返回最佳检索器。路由器如何做出这个决定可能有所不同，但通常使用LLM来做出这个决定。
- en: 'Let’s say we have a question like “What is the capital of France?” And let’s
    say we have coded two retriever agents that are available (that both retrieve
    the answer from a database):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个类似“法国的首都是什么？”的问题，并且我们编写了两个可用的检索代理（这两个代理都从数据库中检索答案）：
- en: '`capital_by_country`—A retriever that takes in a country name and returns the
    capital of that country'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capital_by_country`——一个接收国家名称并返回该国家首都的检索器'
- en: '`country_by_capital`—A retriever that takes in a capital name and returns the
    country of that capital'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`country_by_capital`——一个接收首都名称并返回该首都所在国家的检索器'
- en: Both of these retrievers can be hardcoded database queries that take in a parameter
    for the country or capital.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个检索器都可以是硬编码的数据库查询，接收国家或首都作为参数。
- en: The retriever router can be an LLM that takes in the user question and returns
    the best retriever to use. In this case, the LLM can return the `capital_by_country`
    retriever with `"France"` as the extracted argument. So the actual call to the
    retriever would be `capital_by_country("France")`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 检索路由器可以是一个LLM（大型语言模型），它接收用户问题并返回最佳检索器。在这种情况下，LLM可以返回带有“France”（法国）作为提取参数的`capital_by_country`检索器。因此，实际调用检索器的代码将是`capital_by_country("France")`。
- en: This is a simple example, but in a real-world scenario, many retrievers may
    be available. The retriever router can be a complex function that uses the LLM
    to pick the best retriever for the job.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但在现实世界的场景中，可能会有许多检索器可用。检索路由器可能是一个复杂的函数，它使用LLM来选择最适合工作的最佳检索器。
- en: 5.1.3 Answer critic
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 回答批评者
- en: The answer critic is a function that takes in the answers from the retrievers
    and checks whether the original question is answered correctly. The answer critic
    is a blocking function that can stop the answer from being returned to the user
    if the answer is not correct or is incomplete.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回答批评者是一个函数，它接收检索器的答案并检查原始问题是否被正确回答。回答批评者是一个阻塞函数，如果答案不正确或不完整，它可以阻止答案返回给用户。
- en: If an incomplete or incorrect answer is blocked, the answer critic should generate
    a new question that can be used to retrieve the correct answer and go through
    another round of retrieving the correct answer. It might be that the correct answer
    is not available in the data source, so there needs to be some exit criteria from
    this loop; the answer critic should be able to handle that and return a message
    to the user that the answer is not available in such cases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个不完整或不正确的答案被阻止，答案批评者应生成一个新问题，该问题可用于检索正确答案，并进入另一轮检索正确答案。可能的情况是正确答案在数据源中不可用，因此需要从这个循环中设置一些退出标准；答案批评者应能够处理这种情况，并在这种情况下向用户返回消息，告知答案不可用。
- en: 5.2 Why do we need agentic RAG?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 为什么我们需要代理RAG？
- en: One area where agentic RAG is useful is when we have a variety of data sources
    and we want to use the best data source for the job. Another common usage is when
    the data source is very broad or complex and we need specialized retrievers to
    retrieve the data we need consistently.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代理RAG有用的一个领域是我们有多种数据源，并且希望为工作使用最佳数据源。另一个常见用途是当数据源非常广泛或复杂，我们需要专门的检索器来一致地检索所需数据时。
- en: As seen earlier in the book, generic retrievers like vector similarity search
    can find relevant data in unstructured data sources. When we have structured data
    sources like a graph database, we might use generic retrievers like text2cypher
    that we introduced in chapter 4\. If the data is very complex, tools like text2cypher
    can have problems generating the right query. In such cases, specialized retrievers
    can be used to retrieve the correct data. This could, for example, be a narrow
    text2cypher retriever or a hard-coded database query that takes in parameters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书前面所述，通用的检索器，如向量相似度搜索，可以在非结构化数据源中找到相关数据。当我们有如图数据库这样的结构化数据源时，我们可能会使用在第4章中介绍的通用检索器，如text2cypher。如果数据非常复杂，像text2cypher这样的工具在生成正确查询时可能会遇到问题。在这种情况下，可以使用专门的检索器来检索正确数据。例如，这可能是一个窄范围的text2cypher检索器或一个硬编码的数据库查询，该查询接受参数。
- en: Over time, we can identify questions that tools like text2cypher have problems
    generating queries to answer, and we can build specialized retrievers for those
    questions and use text2cypher as a catchall retriever for the cases when there
    isn’t a good specific retriever match.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们可以识别出像text2cypher这样的工具在生成查询以回答问题时遇到的问题，并为这些问题构建专门的检索器，并将text2cypher作为没有良好特定检索器匹配情况下的通用检索器使用。
- en: This is where agentic RAG can be useful. A variety of retrievers are available,
    and we need to use the best retriever for the job and assess the answer before
    returning it to the user. In a production environment, this is very useful to
    keep the performance of the system high and the quality of the answers consistent.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代理RAG可以发挥作用的地方。有多种检索器可供选择，我们需要为工作选择最佳的检索器，并在将其返回给用户之前评估答案。在生产环境中，这非常有用，可以保持系统性能高和答案质量一致。
- en: 5.3 How to implement agentic RAG
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 如何实现代理RAG
- en: 'In this section, we’ll walk through how to implement the foundational parts
    of an agentic RAG system. You can follow the implementation directly in the accompanying
    Jupyter notebook available here: [https://github.com/tomasonjo/kg-rag/blob/main/notebooks/ch05.ipynb](https://github.com/tomasonjo/kg-rag/blob/main/notebooks/ch05.ipynb).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何实现代理RAG系统的基本部分。您可以直接在附带的Jupyter笔记本中跟随实现，笔记本地址如下：[https://github.com/tomasonjo/kg-rag/blob/main/notebooks/ch05.ipynb](https://github.com/tomasonjo/kg-rag/blob/main/notebooks/ch05.ipynb)。
- en: NOTE In the implementation in this chapter, we use what we call the “Movies
    dataset.” See the appendix for more information on the dataset and various ways
    to load it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本章的实现中，我们使用我们所说的“电影数据集”。有关数据集的更多信息以及各种加载方式，请参阅附录。
- en: 5.3.1 Implementing retriever tools
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 实现检索工具
- en: Before we can route the user input to be handled by the right retriever(s),
    we need to have the retrievers available for the router to choose from. The retrievers
    can be very broad, like a vector similarity search, or very specific, like a template
    of a hardcoded database query that takes in parameters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以将用户输入路由到由正确检索器（s）处理之前，我们需要让检索器可供路由器选择。检索器可以是广泛的，如向量相似度搜索，也可以是非常具体的，如接受参数的硬编码数据库查询模板。
- en: 'In this practical example, we’ll use a simple list of retrievers: two that
    use Cypher templates to get movies by title and movies by actor name and one that
    uses text2cypher for all other questions. As mentioned earlier, the useful set
    of retrievers differs from system to system and should be added over time as needed
    to improve the performance of the application.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实际示例中，我们将使用一个简单的检索器列表：两个使用Cypher模板通过标题和演员名称获取电影，以及一个使用text2cypher处理所有其他问题的检索器。如前所述，有用的检索器集合因系统而异，应根据需要随时间添加以提高应用程序的性能。
- en: Listing 5.1 Available retriever tools
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1 可用的检索器工具
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that `neo4j_driver` and `text2cypher` are imports that you can find implemented
    in the code repository for this book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`neo4j_driver`和`text2cypher`是可以在本书的代码仓库中找到的实现导入。
- en: NOTE The previous retriever definitions follow OpenAI’s tools format at the
    time of writing this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书编写时，之前的检索器定义遵循OpenAI的工具格式。
- en: We need to be careful with how we describe the retriever to the LLM. We need
    to make sure the LLM understands the retriever and can make a decision on which
    retriever to use. The parameters are also very important to describe so the LLM
    can make the right call to the retriever.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心描述检索器给LLM的方式。我们需要确保LLM理解检索器并能决定使用哪个检索器。参数的描述也非常重要，以便LLM能够正确调用检索器。
- en: Note that the LLM can’t make actual calls to your retrievers; it can only make
    a decision on which retriever to use and what parameters to pass to the retriever.
    The actual call to the retriever needs to be done by the system that calls the
    LLM, which we’ll see in the next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，LLM不能实际调用您的检索器；它只能决定使用哪个检索器以及传递给检索器的参数。实际调用检索器需要由调用LLM的系统来完成，我们将在下一节中看到。
- en: Note on a generic retriever tool
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于通用检索工具的说明
- en: A generic retriever tool that we almost always include in our agentic RAG systems
    is a tool that is being called if the answer to the question is already given
    within the question or other parts of the context. This tool is usually a simple
    function that extracts the answer from the question or context and returns it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是包含在我们智能RAG系统中的通用检索工具是，当问题的答案已经在问题或其他上下文部分中给出时，将被调用的工具。这个工具通常是一个简单的函数，它从问题或上下文中提取答案并返回它。
- en: An example could be a question like “What’s Dave Smith’s last name?” This is
    what the retriever tool could look like.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是一个像“Dave Smith的姓氏是什么？”这样的问题。这就是检索器工具可能的样子。
- en: Listing 5.2 Generic retriever tool for answer already in context
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2 已在上下文中提供答案的通用检索工具
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 5.3.2 Implementing the retriever router
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 实现检索器路由器
- en: The retriever router is the central part of the agentic RAG system. Its job
    is to take in the user question(s) and return the best retriever(s) to use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 检索器路由器是智能RAG系统的核心部分。其任务是接收用户问题并返回用于使用的最佳检索器。
- en: When implementing the retriever router, we’ll use an LLM to help us with the
    task. We will provide the LLM with a list of retrievers and the user question(s),
    and the LLM will return the best retriever(s) to use to find the answer for each
    question. For simplicity, we’ll use an LLM that has official tools/function-calling
    support, like OpenAI’s GPT-4o. The functionality can be achieved with other LLMs
    as well, but the implementation might be different.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现检索路由器时，我们将使用一个大型语言模型（LLM）来帮助我们完成任务。我们将向LLM提供一个检索器列表和用户问题，然后LLM将返回用于为每个问题找到答案的最佳检索器。为了简化，我们将使用具有官方工具/函数调用支持的LLM，例如OpenAI的GPT-4o。其他LLM也可以实现此功能，但实现方式可能不同。
- en: Before we dig into the routing function, we need to look into some parts that
    are needed to be able to successfully build an agentic RAG system. These parts
    are
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究路由功能之前，我们需要查看一些必要的部分，以便能够成功构建一个智能RAG系统。这些部分包括
- en: Handling tool calls
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理工具调用
- en: Continuous query updating
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续查询更新
- en: Routing the questions to the relevant retrievers
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问题路由到相关检索器
- en: Handling tool calls on behalf of the LLM
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代表LLM处理工具调用
- en: When the LLM returns the best retriever to use, the system needs to make the
    call to the retriever. This can be done by having a function that takes in the
    retriever and the arguments and makes the call to the retriever. The following
    listing shows an example of what that function might look like.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当LLM返回要使用的最佳检索器时，系统需要调用检索器。这可以通过一个接收检索器和参数并调用检索器的函数来完成。以下列表展示了该函数可能的样子。
- en: Listing 5.3 Retriever call function
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3 检索器调用函数
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `tools` we’re passing in is a dictionary where the key is the name of the
    tool and the value is the actual function to call. The `llm_tool_calls` is a list
    of the tools the LLM has decided to use and the arguments to pass to the tool.
    The LLM can decide that it wants to make multiple function calls to respond to
    a single question. The shape of the `llm_tool_calls` argument looks like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的`tools`是一个字典，其中键是工具的名称，值是实际要调用的函数。`llm_tool_calls`是一个LLM决定要使用的工具及其传递给工具的参数的列表。LLM可以决定它想要对单个问题进行多次函数调用。`llm_tool_calls`参数的形状如下：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Continuous query updating
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 持续查询更新
- en: When we get to the retriever router function section later, we’ll see that we
    will send the questions to the LLM one by one in sequence. This is a deliberate
    choice to make it easier for the LLM to handle each question individually and
    to make it easier to route the questions to the right retriever.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后到达检索器路由器函数部分时，我们会看到我们将按顺序逐个将问题发送给LLM。这是一个故意的选择，以便让LLM更容易单独处理每个问题，并使将问题路由到正确的检索器更容易。
- en: One extra benefit of sending the questions in sequence is that we can use the
    answers from the previous questions to rewrite the next question. This can be
    useful if the user asks a follow-up question that is dependent on the answer to
    the previous question.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题按顺序发送的一个额外好处是，我们可以使用前一个问题的答案来重写下一个问题。如果用户提出的问题依赖于前一个问题的答案，这可能很有用。
- en: 'Consider the following example: “Who has won the most Oscars, and is that person
    alive?” A rewrite of this question could be “Who won the most Oscars?” and “Is
    that person alive?” where the second question is dependent on the answer to the
    first question.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：“谁赢得了最多的奥斯卡奖项，这个人还活着吗？”这个问题的重写可以是“谁赢得了最多的奥斯卡奖项？”以及“这个人还活着吗？”其中第二个问题依赖于第一个问题的答案。
- en: So once we have the answer to the first question, we want to update the remaining
    questions with the new information. This can be done by calling a query updater
    with the original question and the answers from the retrievers. The query updater
    updates the existing questions with the new information.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们得到了第一个问题的答案，我们希望用新的信息更新剩余的问题。这可以通过调用一个带有原始问题和检索器答案的查询更新器来完成。查询更新器会使用新的信息更新现有的问题。
- en: Listing 5.4 Query updater instructions
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4 查询更新说明
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The query updater is called with the original question and the answers from
    the retrievers. The output is the updated question, and we instruct the LLM to
    return the updated question in a JSON format. It’s important that the LLM doesn’t
    ask for more information than the original question—only rephrase the question
    to make it more complete.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 查询更新器使用原始问题和检索器的答案被调用。输出是更新后的问题，我们指示LLM以JSON格式返回更新后的问题。重要的是LLM不要要求比原始问题更多的信息——只需重新措辞问题以使其更完整。
- en: Listing 5.5 Query updater function
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5 查询更新函数
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this in place, we can update the questions with the new information as
    we go along and make sure the questions are as complete as possible and that we
    make it as easy as possible to find the answer to the questions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以随着进程更新问题，并确保问题尽可能完整，并尽可能容易找到问题的答案。
- en: Routing the questions
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由问题
- en: The final piece in the retriever router is actually routing the questions to
    the right retriever. This is done by calling the LLM with the questions and the
    available tools, and the LLM will return the best retriever to use for each question.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 检索器路由的最后一部分实际上是路由问题到正确的检索器。这是通过调用LLM并传递问题和可用工具来完成的，LLM将返回每个问题的最佳检索器。
- en: First, we need to have our tools available in a dictionary so we can pass them
    to the LLM but also find them when it’s time to invoke the tools. Let’s start
    by defining the tools we have available.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的工具字典中提供我们的工具，这样我们就可以将它们传递给LLM，同时当需要调用工具时也可以找到它们。让我们首先定义我们可用的工具。
- en: Listing 5.6 Available retriever tools dictionary
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6 可用检索器工具字典
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we’ve grouped the tool descriptions and the actual functions in a dictionary
    so we can easily find the tools when we need to make the actual call to the tools.
    Let’s start the prompt to the LLM where we describe its task.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将工具描述和实际功能分组到一个字典中，这样我们可以在需要实际调用工具时轻松找到它们。让我们开始向LLM的提示，其中我们描述其任务。
- en: Listing 5.7 Retriever router Instructions
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7 检索路由器指令
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a pretty short prompt, but it’s enough to instruct the LLM to pick the
    right retriever for the job because of the built-in tools/function-calling support.
    Next we’ll have a look at the function that calls the LLM.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简短的提示，但足以指导 LLM 选择正确的检索器来完成工作，因为内置的工具/函数调用支持。接下来，我们将查看调用 LLM 的函数。
- en: Listing 5.8 Retriever router function
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8 检索路由器函数
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function takes a single question and the available tools and the answers
    from the previous questions. It then calls the LLM with the question and the tools,
    and the LLM will return the best retriever to use for the question. The last line
    of the function is a call to the `handle_tool_calls` function we saw earlier that
    makes the actual call to the retriever.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收一个单独的问题、可用工具和前一个问题提供的答案。然后，它使用问题和工具调用 LLM，LLM 将返回用于问题的最佳检索器。函数的最后一行是调用我们之前看到的
    `handle_tool_calls` 函数，该函数实际调用检索器。
- en: The final piece of the retrieval router is to tie all previous parts together
    and go all the way from the user input to the answer. We want to make sure that
    we have a loop that goes through all questions and that we update the questions
    with the new information as we go along.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 检索路由器的最后一部分是将所有先前部分整合在一起，从用户输入到答案的全过程。我们想要确保有一个循环遍历所有问题，并在过程中更新问题以包含新的信息。
- en: Listing 5.9 Agentic RAG function
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9 代理 RAG 函数
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One thing to note here is that the `handle_user_input` function optionally takes
    in a list of answers. We will get to this in section 5.3.3.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，`handle_user_input` 函数可以可选地接收一个答案列表。我们将在 5.3.3 节中讨论这一点。
- en: With this in place, we have a complete agentic RAG system that can take in user
    input and return the answer to the user. The system is built in a way that it
    can be extended with more retrievers as needed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们拥有一个完整的代理 RAG 系统，该系统能够接收用户输入并返回答案。系统构建的方式允许根据需要扩展更多的检索器。
- en: We need to implement one more part to make the system complete, and that is
    the answer critic.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个额外的部分来使系统完整，那就是答案批评家。
- en: 5.3.3 Implementing the answer critic
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 实现答案批评家
- en: The job of the answer critic is to take all answers from the retrievers and
    check if the original question is answered correctly. LLMs are nondeterministic
    and can make mistakes when rewriting the questions, updating the questions, and
    routing the questions, so we want to have this check in place to make sure we
    actually receive the answers we need.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 答案批评家的任务是接收所有来自检索器的答案，并检查原始问题是否得到正确回答。LLM 是非确定性的，在重写问题、更新问题和路由问题时可能会出错，因此我们希望设置这个检查以确保我们确实收到了所需答案。
- en: The following listing shows instructions to the LLM for the answer critic.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了针对答案批评家的 LLM 指令。
- en: Listing 5.10 Answer critic instructions
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10 答案批评家指令
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We follow the same pattern as before with the JSON format and the instructions
    to the LLM.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循之前的模式，使用 JSON 格式和 LLM 的指令。
- en: Next, we’ll have a look at the function that calls the LLM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看调用 LLM 的函数。
- en: Listing 5.11 Answer critic function
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11 答案批评家函数
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function takes the original question and the answers from the retrievers
    and calls the LLM to check if the original question is answered correctly. If
    the question is not answered correctly, the LLM will return a list of new questions
    that can be asked to gather the missing information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收原始问题和检索器提供的答案，并调用 LLM 检查原始问题是否得到正确回答。如果问题没有正确回答，LLM 将返回一系列可以提出的新问题，以收集缺失的信息。
- en: If we get a list of new questions back, we can go through the retriever router
    again to get the missing information. We should also have some exit criteria from
    this loop so we don’t get stuck in a loop where we can’t get the answer to the
    original question from the retrievers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到一系列新问题，我们可以再次通过检索路由器来获取缺失信息。我们还应该设置一些退出标准，以避免陷入无法从检索器中获得原始问题答案的循环。
- en: 5.3.4 Tying it all together
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 整合所有部分
- en: So far, we have implemented the retriever agents, the retriever router, and
    the answer critic. The final piece is to tie it all together in a main function
    that takes in the user input and returns the answer to the user, if the answer
    is available.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了检索代理、检索路由器和答案批评家。最后一步是将所有这些部分整合到一个主函数中，该函数接收用户输入并返回答案，如果答案可用的话。
- en: The following listing shows what the main function might look like. Let’s start
    with the instructions to the LLM.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了主要功能可能的样子。让我们从对LLM的指令开始。
- en: Listing 5.12 Agentic RAG main instructions
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.12 代理型RAG主要指令
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s very important that the LLM only uses the information provided to it in
    the prompt to answer the questions. This is to make sure that the system is consistent
    and that we can trust the answers it provides.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，大型语言模型（LLM）在回答问题时只能使用其提示中提供的信息。这是为了保证系统的连贯性，以及我们能够信任它提供的答案。
- en: Next, we’ll have a look at the main function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看主要功能。
- en: Listing 5.13 Agentic RAG main function
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.13 代理型RAG主要功能
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main function runs the user input through the agentic RAG system and returns
    the answer to the user. If the answer is not complete or is incorrect, the critique
    function will return a list of new questions that can be asked to gather the missing
    information.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主要功能将用户输入通过代理型RAG系统运行，并将答案返回给用户。如果答案不完整或不正确，评估功能将返回一系列新问题，这些问题可以用来收集缺失的信息。
- en: We only critique the answers once; if the answers are still incomplete or incorrect
    after the critique, we return the answers to the user as is and rely on the LLM
    to let the user know what’s incomplete.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对答案进行一次评估；如果评估后答案仍然不完整或不正确，我们将原样返回答案给用户，并依赖LLM让用户知道哪些信息不完整。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Agentic RAG is a system where a variety of retrieval agents are available to
    retrieve the data needed to answer the user question.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理型RAG是一个提供多种检索代理的系统，用于检索回答用户问题所需的数据。
- en: The main interface to an agentic RAG system is usually some kind of use case
    or retriever router, whose job is to find the best-suited retriever (or retrievers)
    to perform the task at hand.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理型RAG系统的主要界面通常是某种用例或检索路由器，其任务是找到最适合执行当前任务的检索器（或检索器组）。
- en: The foundational parts of an agentic RAG system are retriever agents, retriever
    router, and answer critic.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理型RAG系统的基本部分包括检索代理、检索路由器和答案评估器。
- en: The main parts of an agentic RAG system can be implemented using an LLM with
    tools/function-calling support.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理型RAG系统的主要部分可以使用具有工具/函数调用支持的LLM来实现。
- en: The retriever agents can be generic or specialized and should be added over
    time as needed to improve the performance of the application.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索代理可以是通用的或专门的，应根据需要逐步添加，以改善应用程序的性能。
- en: The answer critic is a function that takes in the answers from the retrievers
    and checks if the original question is answered correctly.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案评估器是一个函数，它接收检索器提供的答案，并检查原始问题是否得到正确回答。
