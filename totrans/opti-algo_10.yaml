- en: 8 Genetic algorithm variants
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 种遗传算法变体
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing the Gray-coded genetic algorithm
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍格雷码遗传算法
- en: Understanding real-valued GA and its genetic operators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解实值GA及其遗传算子
- en: Understanding permutation-based GA and its genetic operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基于排列的GA及其遗传算子
- en: Understanding multi-objective optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多目标优化
- en: Adapting genetic algorithms to strike a balance between exploration and exploitation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将遗传算法调整为在探索和利用之间取得平衡
- en: Solving continuous and discrete problems using GA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GA解决连续和离散问题
- en: 'This chapter continues with the topic of chapter 7: we will look at various
    forms of genetic algorithms (GAs) and delve deeper into their real-world applications.
    We’ll also look at a number of case studies and exercises, such as the traveling
    salesman problem (TSP), proportional integral derivative (PID) controller design,
    political districting, the cargo bike loading problem, manufacturing planning,
    facility allocation, and the opencast mining problem in this chapter and its supplementary
    exercises included in the online appendix C.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续第7章的主题：我们将探讨各种形式的遗传算法（GA）并深入探讨其现实世界的应用。我们还将探讨一些案例研究和练习，例如旅行商问题（TSP）、比例积分微分（PID）控制器设计、政治选区划分、载货自行车装载问题、制造计划、设施分配以及本章及其在线附录C中包含的露天采矿问题。
- en: 8.1 Gray-coded GA
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 格雷码GA
- en: The Hamming cliff effect refers to the fact that small changes in a chromosome
    can result in large changes in a solution’s fitness, which can lead to a sharp
    drop-off in the fitness landscape and cause the algorithm to converge prematurely.
    In binary genetic algorithms, the crossover and mutation operations can significantly
    affect the solution due to this Hamming cliff effect, especially when the bits
    that are to be changed are among the most significant bits in the binary string.
    To mitigate the Hamming cliff effect, Gray-coded GA uses a Gray-code encoding
    scheme for the chromosomes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 哈明悬崖效应指的是染色体中微小的变化可能导致解的适应度发生大的变化，这可能导致适应度景观急剧下降，并导致算法过早收敛。在二进制遗传算法中，由于哈明悬崖效应，交叉和变异操作可以显著影响解，尤其是在要更改的位是二进制字符串中最显著的位时。为了减轻哈明悬崖效应，格雷码GA使用格雷码编码方案对染色体进行编码。
- en: The reflected binary code, commonly referred to as *Gray code* after its inventor
    Frank Gray, is a unique binary numbering system characterized by adjacent numerical
    values differing by only one bit, as shown in table 8.1\. In this numeral system,
    each value has a unique representation that is close to the representations of
    its neighboring values, which helps minimize the effect of crossover and mutation
    operations on the solution. This coding ensures a smooth transition between values
    and minimizes the risk of errors during conversions or when used in various applications,
    such as rotary encoders and digital-to-analog converters. Table 8.1 shows the
    decimal numbers 1 to 15 and their corresponding binary and Gray equivalents.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 反射二进制码，通常称为**格雷码**，是以其发明者Frank Gray的名字命名的，是一种独特的二进制数制系统，其特点是相邻数值仅相差一位，如表8.1所示。在这个数制系统中，每个值都有一种独特的表示方式，这种表示方式接近其相邻值的表示方式，有助于最小化交叉和变异操作对解的影响。这种编码确保了值之间的平稳过渡，并最小化了在转换过程中或在使用于各种应用（如旋转编码器和数字到模拟转换器）时的错误风险。表8.1显示了十进制数1到15及其对应的二进制和格雷码等价值。
- en: Table 8.1 Decimal, binary, and Gray coding
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 十进制、二进制和格雷码编码
- en: '| Decimal number | Binary code | Gray code |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 十进制数 | 二进制码 | 格雷码 |'
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0000 | 0000 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0000 | 0000 |'
- en: '| 1 | 0001 | 0001 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0001 | 0001 |'
- en: '| 2 | 0010 | 0011 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0010 | 0011 |'
- en: '| 3 | 0011 | 0010 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0011 | 0010 |'
- en: '| 4 | 0100 | 0110 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0100 | 0110 |'
- en: '| 5 | 0101 | 0111 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0101 | 0111 |'
- en: '| 6 | 0110 | 0101 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0110 | 0101 |'
- en: '| 7 | 0111 | 0100 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 0111 | 0100 |'
- en: '| 8 | 1000 | 1100 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1000 | 1100 |'
- en: '| 9 | 1001 | 1101 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 1001 | 1101 |'
- en: '| 10 | 1010 | 1111 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1010 | 1111 |'
- en: '| 11 | 1011 | 1110 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 1011 | 1110 |'
- en: '| 12 | 1100 | 1010 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 1100 | 1010 |'
- en: '| 13 | 1101 | 1011 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 1101 | 1011 |'
- en: '| 14 | 1110 | 1001 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 1110 | 1001 |'
- en: '| 15 | 1111 | 1000 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 1111 | 1000 |'
- en: Exclusive OR (XOR) gates are used to convert 4-bit binary numbers to Gray codes,
    as illustrated in figure 8.1 for the ticket pricing example discussed in the previous
    chapter. These XOR gates result in 1 only if the inputs are different and 0 if
    the inputs are the same.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 独异或（XOR）门用于将4位二进制数转换为格雷码，如图8.1所示，这是在上一章讨论的票价示例中。这些XOR门仅在输入不同时产生1，在输入相同时产生0。
- en: '![](../Images/CH08_F01_Khamis.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH08_F01_Khamis.png)'
- en: Figure 8.1 Gray coding and binary-to-Gray conversion
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 格雷码和二进制到格雷码转换
- en: In Gray code, two successive values differ by only one bit. This property reduces
    the Hamming distance between adjacent numbers, leading to a smoother search space
    or smoother genotype-to-phenotype mapping.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在格雷码中，两个连续的值只相差一位。这个性质减少了相邻数字之间的汉明距离，导致搜索空间或基因型到表型的映射更加平滑。
- en: Hamming cliff problem
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 汉明悬崖问题
- en: One of the drawbacks of encoding variables as binary strings is the presence
    of Hamming cliffs. In binary-coded GAs, a small change in the encoded value (e.g.,
    flipping a single bit) can lead to a significant change in the decoded value,
    especially if the flipped bit is located toward the most significant bit position.
    This abrupt change between two adjacent numbers in the search space is referred
    to as a Hamming cliff. This problem negatively affects binary-coded GAs by disrupting
    the search space’s smoothness, causing poor convergence and leading to inefficient
    exploration and exploitation. To address the Hamming cliff problem, alternative
    representations like Gray code or real-valued encoding can be used, as they offer
    better locality and smoother search spaces, minimizing the disruptive effects
    of small changes on decoded values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量编码为二进制字符串的一个缺点是存在汉明悬崖。在二进制编码的遗传算法中，编码值的小幅变化（例如，翻转单个位）可能导致解码值发生显著变化，特别是如果翻转的位位于最高位位置。搜索空间中两个相邻数字之间的这种突然变化被称为汉明悬崖。这个问题通过破坏搜索空间的平滑性，导致收敛不良，并导致探索和利用效率低下，从而对二进制编码的遗传算法产生负面影响。为了解决汉明悬崖问题，可以使用像格雷码或实值编码这样的替代表示，因为它们提供了更好的局部性和更平滑的搜索空间，最小化了小变化对解码值的影响。
- en: 'For example, assume that we have a decision variable in the range [0, 15],
    as shown in the following figure. In binary-coded GA, we would use 4-bit binary
    representation to encode the candidate solutions. Let’s assume we have two adjacent
    solutions in the search space: 7 and 8, or 0111 and 1000 in binary representation.
    The Hamming distance is the number of bit-wise differences, so the Hamming distance
    between 1000 and 0111 is 4\. These two solutions (7 and 8) are neighbors in the
    search space, but when you look at their binary representations, you can see that
    they differ in all 4 bits. Flipping the most significant bit causes a significant
    change in the decoded value. In the case of Gray code, the Hamming distance between
    the Gray code representation 0100 (7 in decimal) and 1100 (8 in decimal) is only
    1\. This means that these Gray code representations for the two adjacent solutions
    differ by only 1 bit, providing a smoother search space and potentially improving
    the performance of the GA.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个范围在 [0, 15] 内的决策变量，如图所示。在二进制编码的遗传算法中，我们会使用 4 位二进制表示来编码候选解。假设我们在搜索空间中有两个相邻的解：7
    和 8，或者二进制表示中的 0111 和 1000。汉明距离是位差的数量，所以 1000 和 0111 之间的汉明距离是 4。这两个解（7 和 8）在搜索空间中是邻居，但当你看它们的二进制表示时，你会发现它们在所有
    4 位上都有差异。翻转最高位会导致解码值发生显著变化。在格雷码的情况下，格雷码表示 0100（十进制的 7）和 1100（十进制的 8）之间的汉明距离仅为
    1。这意味着这两个相邻解的格雷码表示只相差 1 位，提供了更平滑的搜索空间，并可能提高遗传算法的性能。
- en: '![](../Images/CH08_F01_UN01_Khamis.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH08_F01_UN01_Khamis.png)'
- en: Hamming distances for decimal number change from 0 to 15 for binary and Gray
    coding
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制和格雷码中十进制数从 0 到 15 的汉明距离
- en: Gray code representations provide better locality, meaning that small changes
    in the encoded value result in small changes in the decoded value. This property
    can improve the convergence of the GA by reducing the likelihood of disruptive
    changes during crossover and mutation operations. However, it is worth noting
    that the performance improvements offered by Gray coding are problem-dependent,
    and this representation method is not commonly used compared to binary-coded GA.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 格雷码表示提供了更好的局部性，这意味着编码值的小幅变化会导致解码值的小幅变化。这个性质可以通过减少交叉和变异操作期间破坏性变化的概率来提高遗传算法的收敛性。然而，值得注意的是，格雷码提供的性能改进是问题相关的，并且与二进制编码的遗传算法相比，这种表示方法并不常用。
- en: 8.2 Real-valued GA
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 实值遗传算法
- en: 'Real-valued GA is a variation on the standard GA that uses real numbers for
    encoding chromosomes instead of binary or Gray code representations. Many optimization
    problems involve continuous variables or real-valued parameters, such as curve
    fitting, function optimization with real-valued inputs, proportional integral
    derivative (PID) controller parameter tuning, or optimizing the weights of a neural
    network. To handle these continuous problems, it’s recommended that we use real-value
    GA directly for the following reasons:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实值遗传算法是标准遗传算法的一种变体，它使用实数来编码染色体，而不是二进制或灰度码表示。许多优化问题涉及连续变量或实值参数，例如曲线拟合、具有实值输入的函数优化、比例积分微分（PID）控制器参数调整或优化神经网络的权重。为了处理这些连续问题，建议我们直接使用实值遗传算法，以下是一些原因：
- en: '*Precision*—Real-valued GAs can achieve a higher level of precision in the
    search space than binary GAs. Binary encoding requires the discretization of the
    search space into a finite number of possible solutions, which can limit the accuracy
    of the search. Real-valued encoding, on the other hand, allows for a continuous
    search space, which can provide a more precise search.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精度*—实值遗传算法在搜索空间中可以达到比二进制遗传算法更高的精度水平。二进制编码需要将搜索空间离散化成有限数量的可能解决方案，这可能会限制搜索的准确性。另一方面，实值编码允许进行连续的搜索空间搜索，这可以提供更精确的搜索。'
- en: '*Efficiency*—Real-valued GAs can require fewer bits to encode a solution compared
    to binary GAs. For example, assume that the decision variable to be represented
    has a lower bound (*LB*) of 0 and an upper bound (*UB*) of 10, and we need to
    represent the solution with a precision (*P*) of 0.0001\. As explained in the
    previous chapter, the number of bits required to represent a range between *LB*
    and *UB* with a desired precision *P* is *number_of_bits* = ceil(log2(*UB* – *LB*)/*P*))
    = ceil(log2(ceil(10/0.0001))) = ceil(log2(100000)) = 17 bits. A real-valued encoding
    can use floating-point numbers with a smaller number of bits to represent a wider
    range of values than a binary encoding. This can result in a more efficient use
    of the available memory and computation resources.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*效率*—与二进制遗传算法相比，实值遗传算法可能需要更少的位来编码一个解决方案。例如，假设要表示的决策变量有一个下限（*LB*）为0和一个上限（*UB*）为10，并且我们需要用精度（*P*）为0.0001来表示解决方案。正如前一章所解释的，用所需的精度*P*表示*LB*和*UB*之间范围的位数是*number_of_bits*
    = ceil(log2(*UB* – *LB*)/*P*)) = ceil(log2(ceil(10/0.0001))) = ceil(log2(100000))
    = 17位。实值编码可以使用更少的位来表示比二进制编码更广泛的值。这可能导致更有效地使用可用的内存和计算资源。'
- en: '*Smoothness*—Real-valued GAs can maintain the continuity and smoothness of
    the search space, which can be important in some applications. In contrast, binary
    GAs can suffer from the Hamming cliff effect, as discussed in the previous section.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平滑性*—实值遗传算法可以保持搜索空间的连续性和平滑性，这在某些应用中可能很重要。相比之下，二进制遗传算法可能会受到前述章节中讨论的汉明悬崖效应的影响。'
- en: '*Adaptability*—Real-valued GAs can adapt more easily to changes in the search
    space or the fitness landscape. For example, if the fitness landscape changes
    abruptly, real-valued GAs can adjust the step size or mutation rate to explore
    the new landscape more effectively. Binary GAs, on the other hand, can require
    a more extensive redesign of the encoding or operator parameters to adapt to changes
    in the search space.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*适应性*—实值遗传算法可以更容易地适应搜索空间或适应度景观的变化。例如，如果适应度景观突然变化，实值遗传算法可以调整步长或变异率，以更有效地探索新的景观。另一方面，二进制遗传算法可能需要更广泛的编码或操作参数的重设计，以适应搜索空间的变化。'
- en: In the following subsections, we’ll look at the crossover and mutation methods
    used in real-valued GA.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将探讨实值遗传算法中使用的交叉和变异方法。
- en: 8.2.1 Crossover methods
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 交叉方法
- en: Some popular crossover methods for real-valued GAs are single arithmetic crossover,
    simple arithmetic crossover, and whole arithmetic crossover.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实值遗传算法中一些流行的交叉方法包括单算术交叉、简单算术交叉和整体算术交叉。
- en: Single arithmetic crossover
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单算术交叉
- en: 'The *single arithmetic crossover method* involves picking a gene (*k*) at random
    and generating a random weight *α*, which lies in the range [0, 1]. Genes with
    indices *i* before and after the crossover point (*i* < *k* or *i* > *k*) will
    inherit the genes from the corresponding parent chromosome. For genes at the crossover
    point (*i* = *k*), we create the offspring genes by taking a weighted average
    of the corresponding genes in the parent chromosomes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*单个算术交叉方法*涉及随机选择一个基因（*k*）并生成一个位于[0, 1]范围内的随机权重*α*。交叉点之前和之后的基因（*i* < *k*或*i*
    > *k*）将从相应的父染色体继承基因。对于交叉点的基因（*i* = *k*），我们通过取父染色体中相应基因的加权平均来创建后代基因：'
- en: '*Child*[1]*Gene[i]* = *α* × *Parent*[1]*Gene[i]* + (1 – *α*) × *Parent*[2]*Gene[i]*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*子代*[1]*基因[i]* = *α* × *父代*[1]*基因[i]* + (1 – *α*) × *父代*[2]*基因[i]*'
- en: '*Child*[2]*Gene[i]* = *α* × *Parent*[2]*Gene[i]* + (1 – *α*) × *Parent*[1]*Gene[i]*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*子代*[2]*基因[i]* = *α* × *父代*[2]*基因[i]* + (1 – *α*) × *父代*[1]*基因[i]*'
- en: Figure 8.2 illustrates the single arithmetic crossover in real-valued GA.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 展示了实值GA中的单个算术交叉。
- en: '![](../Images/CH08_F02_Khamis.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F02_Khamis.png)'
- en: Figure 8.2 Single arithmetic crossover in real-valued GA
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 实值GA中的单个算术交叉
- en: Simple arithmetic crossover
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简单算术交叉
- en: '*Simple arithmetic crossover* is similar to single arithmetic crossover. Before
    a randomly picked crossover point (*i* < *k*), the genes are inherited from the
    corresponding parent chromosome. After the crossover point (*i* >= *k*), we create
    the offspring genes by taking a weighted average of the corresponding genes in
    the parent chromosomes. Figure 8.3 illustrates the simple arithmetic crossover
    in real-valued GA.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单算术交叉*与单个算术交叉相似。在随机选择的交叉点（*i* < *k*）之前，基因从相应的父染色体继承。在交叉点（*i* >= *k*）之后，我们通过取父染色体中相应基因的加权平均来创建后代基因。图8.3展示了实值GA中的简单算术交叉。'
- en: '![](../Images/CH08_F03_Khamis.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F03_Khamis.png)'
- en: Figure 8.3 Simple arithmetic crossover in real-valued GA
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 实值GA中的简单算术交叉
- en: Whole arithmetic crossover
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 整体算术交叉
- en: In the *whole arithmetic crossover* method, we take a weighted average of the
    entire parent chromosomes to create the offspring. Figure 8.4 illustrates this
    method in real-valued GA.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*整体算术交叉*方法中，我们通过对整个父染色体进行加权平均来创建后代。图8.4展示了实值GA中的这种方法。
- en: '![](../Images/CH08_F04_Khamis.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Khamis.png)'
- en: Figure 8.4 Whole arithmetic crossover in real-valued GA
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 实值GA中的整体算术交叉
- en: Simulated binary crossover
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟二进制交叉
- en: '*Simulated binary crossover* (SBX) [1] is another crossover method in real-valued
    GA. In SBX, real values can be represented by a binary notation, and then the
    point crossovers can be performed. SBX is designed to generate offspring close
    to the parent chromosomes by creating a probability distribution function, thus
    maintaining a balance between exploration and exploitation in the search space.
    SBX is implemented in pymoo.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*模拟二进制交叉*（SBX）[1]是实值GA中另一种交叉方法。在SBX中，实值可以通过二进制表示，然后执行点交叉。SBX通过创建概率分布函数来生成接近父染色体的后代，从而在搜索空间中保持探索和利用之间的平衡。SBX在pymoo中实现。'
- en: 8.2.2 Mutation methods
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 变异方法
- en: 'The simplest way to mutate a continuous variable is to introduce small, random
    perturbations to the genes of an individual to maintain diversity in the population
    and help the search process escape from local optima. There are several common
    mutation methods used in real-valued GAs:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对连续变量进行变异的最简单方法是通过向个体的基因引入小的随机扰动来维持种群中的多样性，并帮助搜索过程逃离局部最优。实值GA中使用了多种常见的变异方法：
- en: '*Gaussian mutation*—Gaussian mutation adds a random value to the gene, where
    the random value is sampled from a Gaussian distribution with 0 mean and a specified
    standard deviation *σ*. The standard deviation controls the magnitude of the mutation
    (aka the *mutation step*).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高斯变异*——高斯变异向基因添加一个随机值，该随机值是从均值为0、指定标准差*σ*的高斯分布中抽取的。标准差控制变异的大小（也称为*变异步长*）。'
- en: '*Cauchy mutation*—Similar to Gaussian mutation, Cauchy mutation adds a random
    value to the gene, but the random value is sampled from a *Cauchy distribution*
    (aka a *Lorentz distribution* or *Cauchy–Lorentz distribution*) instead of a Gaussian
    distribution. The Cauchy distribution has heavier tails than the Gaussian distribution,
    leading to a higher probability of larger mutations.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*柯西变异*—与高斯变异类似，柯西变异将一个随机值添加到基因中，但这个随机值是从*柯西分布*（也称为*洛伦兹分布*或*柯西-洛伦兹分布*）中抽取的，而不是从高斯分布中抽取。柯西分布的尾部比高斯分布重，导致较大变异的概率更高。'
- en: '*Boundary mutation*—In boundary mutation, the mutated gene is randomly drawn
    from the uniform distribution within the variable’s range, defined by the lower
    bound (*LB*) and upper bound (*UB*). This method is analogous to the bit-flipping
    mutation in a binary-coded GA, and it helps explore the boundaries of the search
    space. It may be useful when optimal solutions are located near the variable limits.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边界变异*—在边界变异中，变异的基因是从变量的范围（由下限 (*LB*) 和上限 (*UB*) 定义）内的均匀分布中随机抽取的。这种方法类似于二进制编码GA中的位翻转变异，并有助于探索搜索空间的边界。当最优解位于变量极限附近时，这可能是有用的。'
- en: '*Polynomial mutation*—Polynomial mutation is a method that generates offspring
    close to the parent by creating a probability distribution function [2]. A distribution
    index (*η*) controls the shape of the probability distribution function, with
    higher values resulting in offspring closer to their parents (exploitation) and
    lower values leading to offspring more spread out in the search space (exploration).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多项式变异*—多项式变异是一种通过创建概率分布函数 [2] 生成接近父母的子代的方法。分布指数 (*η*) 控制概率分布函数的形状，较高的值会导致子代更接近其父母（利用）而较低的值会导致子代在搜索空间中分布更广（探索）。'
- en: To illustrate these genetic operators, let’s consider a curve-fitting example.
    Assume we have the data points shown in table 8.2 and that we want to fit a third-order
    polynomial to these data points using real-valued GA.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '为了说明这些遗传算子，让我们考虑一个曲线拟合的例子。假设我们有表8.2中显示的数据点，并且我们想使用实值GA将这些数据点拟合到三次多项式。 '
- en: Table 8.2 Curve-fitting problem data
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 曲线拟合问题数据
- en: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
- en: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
- en: 'The third-order polynomial takes the form *y* = *ax*³ + *bx*² + *cx* + *d*.
    A real-valued GA can be used to find the four coefficients of the polynomial:
    *a, b, c*, and *d*. This problem is treated as a minimization problem where the
    objective is to minimize the mean squared error (MSE) that measures how close
    a fitted polynomial is to given data points. MSE is calculated using the following
    formula:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 三次多项式具有形式 *y* = *ax*³ + *bx*² + *cx* + *d*。实值GA可以用来找到多项式的四个系数：*a, b, c* 和 *d*。这个问题被视为一个最小化问题，目标是最小化衡量拟合多项式与给定数据点接近程度的均方误差（MSE）。MSE使用以下公式计算：
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH08_F04_Khamis-EQ02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Khamis-EQ02.png)'
- en: '| 8.1 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 8.1 |'
- en: where *n* is the number of data points, *y* is the *y*-coordinate value of each
    data point, and *y*′ is the desired value that sits on the line we created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *n* 是数据点的数量，*y* 是每个数据点的 *y* 坐标值，而 *y*′ 是位于我们创建的直线上的期望值。
- en: 'In real-valued GA, a candidate solution is represented by a vector of parameters
    *a, b, c*, and *d* that can be represented by real values. Let’s start with the
    following initial random solution: *Parent*[1] = [1 2 3 4]. We calculate its fitness
    by substituting these values in the function (*y* = *x*³ + 2*x*² + 3*x* + 4),
    calculating *y*′ for each corresponding *x* and calculating the MSE as in table
    8.3.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实值GA中，候选解由参数向量 *a, b, c* 和 *d* 表示，这些参数可以用实数值表示。让我们从以下初始随机解开始：*父代*[1] = [1 2
    3 4]。我们通过将这些值代入函数 (*y* = *x*³ + 2*x*² + 3*x* + 4) 来计算其适应性，计算每个对应 *x* 的 *y*′，并像表8.3中那样计算MSE。
- en: Table 8.3 MSE calculation for parent 1
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.3 父代1的MSE计算
- en: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
- en: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
- en: '| *y*′ | 4 | 12.83 | 39.63 | 96.11 | 194 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| *y*′ | 4 | 12.83 | 39.63 | 96.11 | 194 |'
- en: '| *Square* *of error* | 9 | 57.88 | 260 | 283.23 | 4 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| *平方误差* | 9 | 57.88 | 260 | 283.23 | 4 |'
- en: '| MSE | 122.83 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| MSE | 122.83 |'
- en: 'Let’s generate another random solution: *Parent*[2] = [2 2 2 2], which gives
    the formula 2*x*³ + 2*x*² + 2*x* + 2 and the MSE in table 8.4.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成另一个随机解：*父代*[2] = [2 2 2 2]，这给出了公式 2*x*³ + 2*x*² + 2*x* + 2 和表8.4中的MSE。
- en: Table 8.4 MSE calculation for parent 2
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.4 父代2的MSE计算
- en: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
- en: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
- en: '| *y*′ | 2 | 11.53 | 50.75 | 143.09 | 312 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| *y*′ | 2 | 11.53 | 50.75 | 143.09 | 312 |'
- en: '| *Square of* *error* | 1 | 39.83 | 742.56 | 4,072.2 | 13,456 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| *误差平方* | 1 | 39.83 | 742.56 | 4,072.2 | 13,456 |'
- en: '| MSE | 3,662.32 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| MSE | 3,662.32 |'
- en: 'Applying whole arithmetic crossover on the two parents *P*[1] = [1 2 3 4] and
    *P*[2] = [2 2 2 2] with weight *α* = 0.2 results in the following offspring:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个父代 *P*[1] = [1 2 3 4] 和 *P*[2] = [2 2 2 2] 应用整体算术交叉，权重 *α* = 0.2，得到以下子代：
- en: '![](../Images/CH08_F04_Khamis-EQ03.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Khamis-EQ03.png)'
- en: '![](../Images/CH08_F04_Khamis-EQ04.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Khamis-EQ04.png)'
- en: 'Let’s assume *Child*[1] is subject to Gaussian mutation. This mutation process
    results in another child as follows: *Child*[3] = *Child*[1] + *N*(0, *σ*), where
    *N*(0, *σ*) is a random number from a normal distribution with a mean of 0 and
    a standard deviation of *σ*. Assuming that *σ* = 1.2, a random value of 0.43 is
    generated by `numpy.random.normal(0, 1.2)`, *s*o *Child*[3] = [1.8 2 2.2 2.4]
    + 0.43 = [2.23 2.43 2.63 2.83].'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *Child*[1] 受高斯变异的影响。此变异过程导致另一个子代如下：*Child*[3] = *Child*[1] + *N*(0, *σ*)，其中
    *N*(0, *σ*) 是均值为 0、标准差为 *σ* 的正态分布中的随机数。假设 *σ* = 1.2，通过 `numpy.random.normal(0,
    1.2)` 生成了一个随机值 0.43，因此 *Child*[3] = [1.8 2 2.2 2.4] + 0.43 = [2.23 2.43 2.63 2.83]。
- en: Listing 8.1 shows how to perform this curve-fitting using real-valued GA implemented
    in pymoo. We’ll start by generating a dataset driven by a third-order polynomial,
    to be used later as a ground truth. Feel free to replace this synthetically generated
    data with any experimental data you may have.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 展示了如何使用 pymoo 中实现的实值 GA 执行此曲线拟合。我们将首先生成一个由三次多项式驱动的数据集，稍后将用作真实值。您可以自由地将这个合成的数据替换为您可能拥有的任何实验数据。
- en: Listing 8.1 Curve fitting using real-valued GA
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 使用实值 GA 进行曲线拟合
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Define coefficients for the third-order polynomial.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义三次多项式的系数。
- en: ② Generate five values as in the hand-iteration example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ② 生成五个值，如手迭代示例中所示。
- en: ③ Calculate y values using the third-order polynomial function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用三次多项式函数计算 y 值。
- en: ④ Combine x and y values into an array of data samples.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将 x 和 y 值组合成一个数据样本数组。
- en: 'As a continuation of listing 8.1, we can define a problem for curve fitting
    by subclassing pymoo’s `Problem` class, ensuring we pass the parameters to the
    superclass and provide an `_evaluate` function. The `CurveFittingProblem` class
    has an initializer method that sets the number of decision variables to 4, the
    number of objectives to 1, the number of constraints to 0, the lower bound of
    the decision variables to –10.0, and the upper bound of the decision variables
    to 10.0\. The `vtype` parameter specifies the data type of the decision variables,
    which is set to `float`. This initializer method creates an instance of the problem
    to be solved using the genetic algorithm. The `_evaluate` method takes as input
    a set of candidate solutions (`X`) and an output dictionary (`out`) and returns
    the fitness of each candidate solution in the `F` field of the `out` dictionary:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表 8.1 的延续，我们可以通过继承 pymoo 的 `Problem` 类来定义一个曲线拟合问题，确保我们传递参数给超类并提供一个 `_evaluate`
    函数。`CurveFittingProblem` 类有一个初始化方法，该方法将决策变量的数量设置为 4，目标数量的数量设置为 1，约束数量的数量设置为 0，决策变量的下限设置为
    –10.0，决策变量的上限设置为 10.0。`vtype` 参数指定决策变量的数据类型，设置为 `float`。此初始化方法创建了一个使用遗传算法解决的问题的实例。`_evaluate`
    方法接受一组候选解（`X`）和一个输出字典（`out`），并返回 `out` 字典中每个候选解的适应度 `F` 字段：
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Import the GA implementation for single-objective optimization in nonconvex
    scenarios.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入用于非凸场景单目标优化的 GA 实现。
- en: ② Import the simulated binary crossover (SBX) operator.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入模拟二进制交叉（SBX）算子。
- en: ③ Import the polynomial mutation operator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 导入多项式变异算子。
- en: ④ Import the rounding repair operator to ensure that the generated solutions
    remain within specified bounds.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 导入四舍五入修复算子以确保生成的解保持在指定的范围内。
- en: ⑤ Import the float random sampling operator to generate random initial solutions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 导入浮点随机采样算子以生成随机初始解。
- en: ⑥ Import the generic optimization problem class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 导入通用的优化问题类。
- en: ⑦ Import the minimize function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 导入最小化函数。
- en: ⑧ Define the optimization problem for curve fitting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 定义曲线拟合的优化问题。
- en: ⑨ Initialize the problem with four decision variables, ranging from –10.0 to
    10.0, and a single objective with no constraints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 使用四个决策变量初始化问题，范围从 –10.0 到 10.0，以及一个无约束的单目标。
- en: ⑩ Calculate the mean squared error for each set of coefficients in the input
    variable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 计算输入变量中每组系数的均方误差。
- en: Now we can instantiate the `CurveFittingProblem` class to create an instance
    of the problem to be solved. We can then define the genetic algorithm to be used
    for the optimization. The `GA` class is used to define the algorithm, and the
    `pop_size` parameter sets the population size to 50\. The `sampling` parameter
    uses the `FloatRandomSampling` operator to generate the initial population of
    candidate solutions randomly. The `crossover` parameter uses the `SBX` operator
    with a crossover probability of 0.8\. The `mutation` parameter uses the `PolynomialMutation`
    operator with a mutation probability of 0.3 and a rounding repair operator to
    ensure that the decision variables remain within the specified bounds. The `eliminate_duplicates`
    parameter is set to `True` to remove duplicate candidate solutions from the population.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实例化`CurveFittingProblem`类来创建要解决的问题的实例。然后我们可以定义用于优化的遗传算法。`GA`类用于定义算法，`pop_size`参数将种群大小设置为50。`sampling`参数使用`FloatRandomSampling`算子随机生成候选解的初始种群。`crossover`参数使用具有交叉概率0.8的`SBX`算子。`mutation`参数使用具有突变概率0.3和舍入修复算子的`PolynomialMutation`算子，以确保决策变量保持在指定的界限内。`eliminate_duplicates`参数设置为`True`以从种群中删除重复的候选解。
- en: 'Next, we can run the genetic algorithm to solve the curve fitting problem using
    the `minimize` function. This function takes three arguments: the instance of
    the problem to be solved (`problem`), the instance of the algorithm to be used
    (`algorithm`), and a tuple specifying the stopping criterion for the algorithm
    `(''n_gen'', 100)`, which specifies that the algorithm should run for 100 generations.
    The `seed` parameter is set to 1 to ensure the reproducibility of the results.
    The `verbose` parameter is set to `True` to display the progress of the algorithm
    during the optimization:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以运行遗传算法，使用`minimize`函数来解决曲线拟合问题。此函数接受三个参数：要解决的问题的实例（`problem`）、要使用的算法的实例（`algorithm`），以及指定算法停止标准的元组`('n_gen',
    100)`，表示算法应运行100代。`seed`参数设置为1以确保结果的再现性。`verbose`参数设置为`True`以在优化过程中显示算法的进度：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Initialize an instance of the CurveFittingProblem class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化`CurveFittingProblem`类的实例。
- en: ② Create a GA solver.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个GA求解器。
- en: ③ Perform the optimization for 100 generations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 对100代进行优化。
- en: 'You can print the four coefficients obtained by GA as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式打印GA获得的四个系数：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the estimated values of the four coefficients are same as the
    coefficients of the ground truth polynomial (a, b, c, d = 2, –3, 4, 1). You can
    experiment with the code by changing the polynomial coefficients, using your own
    data, and using different crossover and mutation methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，四个系数的估计值与真实多项式的系数（a, b, c, d = 2, –3, 4, 1）相同。您可以通过更改多项式系数、使用自己的数据和使用不同的交叉和突变方法来实验代码。
- en: Next, we’ll look at permutation-based GA.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨基于排列的遗传算法。
- en: 8.3 Permutation-based GA
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 基于排列的遗传算法
- en: Permutation-based GAs are designed to solve optimization problems where the
    solutions are permutations of a set of elements. Examples of such problems include
    the traveling salesman problem (TSP), vehicle routing problem, sports tournament
    scheduling, and job scheduling problem. In these problems, the solutions are represented
    as optimal orders or permutations of a set of elements or events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 基于排列的遗传算法旨在解决解决方案是一组元素排列的优化问题。这类问题的例子包括旅行商问题（TSP）、车辆路径问题、体育锦标赛调度和作业调度问题。在这些问题中，解决方案表示为一组元素或事件的最佳顺序或排列。
- en: 'There are typically two main types of problems where the goal is to determine
    the optimal order of events:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种主要类型的问题，其目标是确定事件的最佳顺序：
- en: '*Resource or time-constrained problems*—In these problems, the events rely
    on limited resources or time, making the order of events crucial for optimal solutions.
    One example of this type of problem is ride-sharing scheduling, where the goal
    is to efficiently allocate resources like vehicles and drivers to serve the maximum
    number of passengers in the shortest possible time.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源或时间限制问题*——在这些问题中，事件依赖于有限的资源或时间，这使得事件的顺序对于最佳解决方案至关重要。这类问题的一个例子是拼车调度，其目标是高效地分配车辆和司机等资源，以在尽可能短的时间内服务于最多的乘客。'
- en: '*Adjacency-based problems*—In these problems, the proximity or adjacency of
    elements plays a significant role in finding the best solution. An example of
    such a problem is the traveling salesman problem (TSP), where the aim is to visit
    a set of cities while minimizing the total travel distance, taking into account
    the distances between adjacent cities in the tour.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于邻接的问题*——在这些问题中，元素之间的邻近性或邻接性在寻找最佳解决方案中起着重要作用。这类问题的一个例子是旅行商问题（TSP），其目标是访问一组城市，同时最小化总旅行距离，并考虑巡游中相邻城市之间的距离。'
- en: These problems are often formulated as permutation problems. In a permutation
    representation, if there are *n* variables, the solution is a list of *n* distinct
    integers, each occurring exactly once. This representation ensures that the order
    or adjacency of the elements in the solution is explicitly encoded, which is essential
    for finding the optimal sequence of events in these types of problems. For example,
    let’s consider the following TSP for 8 cities. A candidate solution for this TSP
    is represented by a permutation such as [1, 2, 3, 4, 5, 6, 7, 8]. In permutation-based
    GA, specialized crossover and mutation operators are employed to preserve the
    constraints of the permutation problem, such as maintaining a valid sequence of
    cities in the TSP, where each city appears only once.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题通常被表述为排列问题。在排列表示中，如果有 *n* 个变量，解决方案是一个包含 *n* 个不同整数的列表，每个整数恰好出现一次。这种表示确保了解决方案中元素的顺序或邻接性被明确编码，这对于在这些类型的问题中找到最佳事件序列至关重要。例如，让我们考虑以下
    8 个城市的 TSP。该 TSP 的一个候选解决方案由排列表示，例如 [1, 2, 3, 4, 5, 6, 7, 8]。在基于排列的遗传算法中，使用专门的交叉和变异算子来保留排列问题的约束，例如在
    TSP 中保持城市的有效序列，其中每个城市只出现一次。
- en: The following subsections describe commonly used crossover and mutation methods
    in permutation-based GAs. The choice of crossover and mutation methods in GAs
    depends on the problem being solved, the type of solutions being sought, and the
    objectives of the optimization problem. By carefully selecting and designing these
    operators, GAs can effectively explore and exploit the search space to find high-quality
    solutions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节描述了基于排列的遗传算法中常用的交叉和变异方法。遗传算法中交叉和变异方法的选择取决于要解决的问题、所寻求的解决方案类型以及优化问题的目标。通过仔细选择和设计这些算子，遗传算法可以有效地探索和利用搜索空间以找到高质量的解决方案。
- en: 8.3.1 Crossover methods
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 交叉方法
- en: Several crossover methods are commonly used in permutation-based GAs, such as
    partially mapped crossover (PMX), edge crossover (EC), order 1 crossover (OX1),
    and cycle crossover (CX).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于排列的遗传算法中，常用的交叉方法包括部分映射交叉（PMX）、边交叉（EC）、顺序 1 交叉（OX1）和循环交叉（CX）。
- en: Partially mapped crossover
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 部分映射交叉
- en: The *partially mapped crossover* (PMX) method creates offspring by combining
    the genetic information from two parent chromosomes while preserving the feasibility
    of the resulting offspring with the procedure shown in algorithm 8.1.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*部分映射交叉*（PMX）方法通过结合两个父代染色体的遗传信息来创建后代，同时通过算法 8.1 中所示的程序保持后代的可行性。'
- en: Algorithm 8.1 Partially mapped crossover (PMX)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 8.1 部分映射交叉（PMX）
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Figure 8.5 illustrates these steps for an 8-city TSP. In step 1, two random
    crossover points are chosen, and the cities between these two points are copied
    from parent P1 to child C1 and from the second parent P2 to the second child C2\.
    Then we follow steps 2 to 5 for the cities that were not included in step 1\.
    For the first city in C1, which is 3, we need to find the corresponding city in
    the P2 segment, which is 7\. City 7 is not already included in C1, so we need
    to place city 7 in the place where city 3 appears in P2, which is the last position
    on the right, as shown by the solid black arrow in figure 8.5.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 展示了 8 个城市的 TSP 问题中的这些步骤。在第 1 步中，选择两个随机的交叉点，并将这两个点之间的城市从父代 P1 复制到子代 C1，从第二个父代
    P2 复制到第二个子代 C2。然后我们对第 1 步中没有包含的城市执行步骤 2 到 5。对于 C1 中的第一个城市，即 3，我们需要找到 P2 段中对应的城市，即
    7。城市 7 已经不在 C1 中，因此我们需要将城市 7 放在 P2 中城市 3 出现的位置，即右侧的最后位置，如图 8.5 中的实心黑色箭头所示。
- en: '![](../Images/CH08_F05_Khamis.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F05_Khamis.png)'
- en: Figure 8.5 Partially mapped crossover (PMX)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 部分映射交叉（PMX）
- en: The following listing shows code that performs a partially mapped crossover
    on two parents to generate two offspring.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了执行部分映射交叉以生成两个后代的代码。
- en: Listing 8.2 Partially mapped crossover (PMX)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 部分映射交叉（PMX）
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Select two random crossover points.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ① 选择两个随机的交叉点。
- en: ② Copy the segment between crossover points from a parent to a child.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从父节点复制交叉点之间的段到子节点。
- en: ③ Map the remaining elements from the other parent.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将另一个父节点中的剩余元素映射过来。
- en: ④ Return the generated offspring.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 返回生成的后代。
- en: Running this code will produce output like that shown in figure 8.6, depending
    on the generated random sample.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生如图8.6所示的输出，具体取决于生成的随机样本。
- en: '![](../Images/CH08_F06_Khamis.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F06_Khamis.png)'
- en: Figure 8.6 PMX results
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 PMX结果
- en: The complete version of listing 8.2 is available in the book’s GitHub repository.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2的完整版本可在本书的GitHub仓库中找到。
- en: Edge crossover
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 边交叉
- en: The *edge crossover* (EC) method preserves the connectivity and adjacency information
    between elements from the parent chromosomes. In order to achieve this, an *edge
    table* (or *adjacency list*) is constructed. For example, in the 8-cities TSP,
    the edge table for two parents P1 = [1, 2, 3, 4, 5, 6, 7, 8] and P2 = [1, 6, 7,
    8, 5, 2, 4, 3] is created by counting the adjacent elements in both parents, as
    in table 8.5\. The “+” signs in the table denote a common edge between the two
    parents.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*边交叉*（EC）方法保留了父染色体中元素之间的连接性和邻接信息。为了实现这一点，构建了一个*边表*（或*邻接表*）。例如，在8城市TSP中，通过计算两个父节点P1
    = [1, 2, 3, 4, 5, 6, 7, 8]和P2 = [1, 6, 7, 8, 5, 2, 4, 3]中的相邻元素，创建了边表，如表8.5所示。表中的“+”符号表示两个父节点之间的公共边。'
- en: Table 8.5 An edge table (or adjacency list)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.5 边表（或邻接表）
- en: '| City | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 城市 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |'
- en: '| Edges | 2,8,6,3 | 1,3,5,4 | 2,4+,1 | 3+,5,2 | 4,6,8,2 | 5,7+,1 | 6+,8+ |
    7+,1,5 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 边 | 2,8,6,3 | 1,3,5,4 | 2,4+,1 | 3+,5,2 | 4,6,8,2 | 5,7+,1 | 6+,8+ | 7+,1,5
    |'
- en: Algorithm 8.2 shows the steps involved in edge crossover.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 算法8.2展示了边交叉涉及的步骤。
- en: Algorithm 8.2 Edge crossover (EC)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 算法8.2 边交叉（EC）
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Figure 8.7 illustrates these steps for the 8-cities TSP. This figure illustrates
    how to construct the edge table or adjacency list of each city. The process of
    counting the edges is shown in this figure. For example, cities 3 and 5 are adjacent
    cities or edges to city 4 in the first parent. In the second parent, cities 2
    and 3 are edges for city 4\. This means that city 3 is a common edge.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7展示了8城市TSP的这些步骤。此图说明了如何构建每个城市的边表或邻接表。图中展示了计算边的流程。例如，城市3和5是第一个父节点中与城市4相邻的城市或边。在第二个父节点中，城市2和3是城市4的边。这意味着城市3是一个公共边。
- en: Creating a child starts by selecting city 1 randomly or as a home city. In the
    second row of the table, we list the adjacent cities of city 1, which are 2, 8,
    6 and 3\. Note that cities loop around, meaning city 1 is adjacent to city 8 in
    the first parent, and city 1 is adjacent to city 3 in the second parent. Discarding
    the already visited city 1, these cities have the following adjacent cities {3,5,4}
    for city 2, {7,5} for city 8, {5,7} for city 6, and {2,4} for city 3\. We discard
    city 2, as it has three adjacent cities, and we select city 3 arbitrarily from
    8, 6, and 3, as they have the same number of edges. We keep adding cities to the
    child following algorithm 8.2 until all the cities are added.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子节点首先随机选择城市1或作为家乡城市。在表格的第二行中，我们列出城市1的相邻城市，即2、8、6和3。请注意，城市是循环的，这意味着在第一个父节点中，城市1与城市8相邻，在第二个父节点中，城市1与城市3相邻。丢弃已经访问过的城市1，这些城市对城市2有{3,5,4}的相邻城市，对城市8有{7,5}的相邻城市，对城市6有{5,7}的相邻城市，对城市3有{2,4}的相邻城市。我们丢弃城市2，因为它有三个相邻城市，并从8、6和3中任意选择城市3，因为它们有相同数量的边。我们继续按照算法8.2添加城市到子节点，直到所有城市都添加完毕。
- en: '![](../Images/CH08_F07_Khamis.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F07_Khamis.png)'
- en: Figure 8.7 Edge crossover
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 边交叉
- en: The complete version of listing 8.2 is available in the book’s GitHub repository.
    It shows the Python implementation of edge crossover with a TSP example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2的完整版本可在本书的GitHub仓库中找到。它展示了使用TSP示例的Python实现边交叉。
- en: Order 1 crossover
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序1交叉
- en: '*Order 1 crossover* (OX1) creates offspring by combining the genetic information
    from two parent chromosomes while preserving the relative order of the elements
    in the resulting solutions. Algorithm 8.3 shows the steps involved in order 1
    crossover.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺序1交叉*（OX1）通过结合两个父染色体中的遗传信息来创建后代，同时保持结果解中元素的相对顺序。算法8.3展示了顺序1交叉的步骤。'
- en: Algorithm 8.3 Order 1 crossover (OX1)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 算法8.3 顺序1交叉（OX1）
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Figure 8.8 illustrates these steps for the 8-cities TSP. Starting from the second
    crossover point, cities 4 and 3 cannot be added, as they are already included
    in C1\. The next element in P2 is city 1, so it is added to C1 after the second
    crossover point, followed by city 7, as city 6 is already included. City 8 is
    added next, followed by city 2, as city 5 is already included in C1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8说明了8个城市TSP的这些步骤。从第二个交叉点开始，城市4和3不能添加，因为它们已经在C1中。P2中的下一个元素是城市1，因此它在第二个交叉点之后添加到C1中，然后是城市7，因为城市6已经包含在内。接下来添加城市8，然后是城市2，因为城市5已经在C1中。
- en: '![](../Images/CH08_F08_Khamis.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F08_Khamis.png)'
- en: Figure 8.8 Order 1 crossover (OX1)—The numbers in circles show the sequence
    in which elements are added from parent 2 to child 1.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 顺序1交叉（OX1）——圆圈中的数字显示了从父代2到子代1添加元素的顺序。
- en: The complete version of listing 8.2 is available in the book’s GitHub repository,
    and it shows the Python implementation of OX1 with the TSP example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2的完整版本可在本书的GitHub仓库中找到，它展示了使用TSP示例的OX1的Python实现。
- en: Cycle crossover
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 循环交叉
- en: '*Cycle crossover* (CX) operates by dividing the elements into cycles, where
    a *cycle* is a subset of elements that consistently appear together in pairs when
    the two parent chromosomes are aligned. Given two parents, a cycle is formed by
    selecting an element from the first parent, finding its corresponding position
    in the second parent, and then repeating this process with the element at that
    position until returning to the starting element. The CX operator effectively
    combines the genetic information from both parents while preserving the order
    and adjacency relationships among the elements in the resulting offspring and
    maintaining the feasibility and diversity of the offspring solutions. Algorithm
    8.4 shows the steps of this crossover method.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环交叉*（CX）通过将元素划分为周期来实现，其中*周期*是一组元素，当两个父代染色体对齐时，这些元素成对一致地出现。给定两个父代，通过从第一个父代中选择一个元素，找到其在第二个父代中的对应位置，然后重复这个过程，直到回到起始元素，形成一个周期。CX算子有效地结合了两个父代的遗传信息，同时保持结果后代中元素之间的顺序和相邻关系，并保持后代解的可行性和多样性。算法8.4展示了这种交叉方法的步骤。'
- en: Algorithm 8.4 Cycle crossover (CX)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 算法8.4 循环交叉（CX）
- en: '[PRE9]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 8.9 illustrates these steps for the 10-cities TSP.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9说明了10个城市TSP的这些步骤。
- en: '![](../Images/CH08_F09_Khamis.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F09_Khamis.png)'
- en: Figure 8.9 Cycle crossover (CX)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 循环交叉（CX）
- en: A Python implementation of CX with a TSP example is included in the complete
    version of listing 8.2, available in the book’s GitHub repository. It’s important
    to note that the performance of crossover operators is often problem-dependent
    and may also be influenced by the specific parameter settings of the genetic algorithm,
    such as population size, mutation rate, and selection pressure. Therefore, it
    is recommended that you experiment with different crossover operators and fine-tune
    the genetic algorithm’s parameters to suit the problem being addressed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的GitHub仓库中完整版列表8.2中包含了一个使用TSP示例的CX的Python实现。需要注意的是，交叉算子的性能通常依赖于问题本身，也可能受到遗传算法特定参数设置的影响，例如种群大小、突变率和选择压力。因此，建议您尝试不同的交叉算子，并微调遗传算法的参数以适应要解决的问题。
- en: 8.3.2 Mutation methods
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 突变方法
- en: 'Insert, swap, inversion, and scramble are commonly used mutation methods in
    permutation-based GA. These methods are designed to introduce small perturbations
    to the solution while still preserving its feasibility:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 插入、交换、倒置和打乱是基于排列的GA中常用的突变方法。这些方法旨在在保持解的可行性的同时引入小的扰动：
- en: '*Insert mutation*—Pick two gene values at random, and move the second to follow
    the first, shifting the rest along to accommodate them. This method primarily
    maintains the order and adjacency information of the genes.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插入突变*——随机选择两个基因值，并将第二个移动到第一个之后，以适应它们而移动其余部分。这种方法主要保持基因的顺序和相邻信息。'
- en: '*Swap mutation*—Pick two genes at random, and swap their positions. This method
    mainly retains adjacency information while causing some disruption to the original
    order.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交换突变*——随机选择两个基因，并交换它们的位置。这种方法主要保留相邻信息，同时会对原始顺序造成一些破坏。'
- en: '*Inversion mutation*—Randomly select two genes, and invert the substring between
    them. This method largely maintains adjacency information but is disruptive to
    the order information.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*倒置突变*——随机选择两个基因，并倒置它们之间的子串。这种方法在很大程度上保持相邻信息，但对顺序信息有破坏性。'
- en: '*Scramble mutation*—Randomly select two gene values, and rearrange the genes
    between the chosen positions non-contiguously, applying a random order.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*洗牌变异*——随机选择两个基因值，并在所选位置之间非连续地重新排列基因，应用随机顺序。'
- en: Figure 8.10 illustrates these methods on the first parent as a selected individual
    in the 8-cities TSP.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10展示了这些方法在8城市旅行商问题（TSP）的第一个父代作为选定的个体中的应用。
- en: '![](../Images/CH08_F10_Khamis.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F10_Khamis.png)'
- en: Figure 8.10 Mutation methods in permutation-based GA
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 基于排列的遗传算法中的变异方法
- en: 'As a continuation of listing 8.2, the following code snippet shows how you
    can implement inversion mutation in Python:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对列表8.2的延续，以下代码片段展示了如何在Python中实现反转变异：
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running this code will produce output like that in figure 8.11.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生如图8.11所示的输出。
- en: '![](../Images/CH08_F11_Khamis.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F11_Khamis.png)'
- en: Figure 8.11 Inversion mutation result
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 反转变异结果
- en: The complete version of listing 8.2, available in the book’s GitHub repository,
    includes implementations of different crossover and mutation methods commonly
    used in permutation-based genetic algorithms.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2的完整版本，可在本书的GitHub仓库中找到，包括在基于排列的遗传算法中常用的不同交叉和变异方法的实现。
- en: 8.4 Multi-objective optimization
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 多目标优化
- en: As mentioned earlier in section 1.3.2, optimization problems with multiple objective
    functions are known as multi-objective optimization problems (MOPs). These problems
    can be handled using a preference-based multi-objective optimization procedure
    or by using a Pareto optimization approach. In the former approach, the multiple
    objectives are combined into a single or overall objective function by using a
    relative preference vector or a weighting scheme to scalarize the multiple objectives.
    However, finding this preference vector or weight is subjective and sometimes
    is not straightforward.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文1.3.2节所述，具有多个目标函数的优化问题被称为多目标优化问题（MOPs）。这些问题可以通过基于偏好的多目标优化程序或使用帕累托优化方法来处理。在前一种方法中，使用相对偏好向量或加权方案将多个目标组合成一个或整体目标函数，以标量化多个目标。然而，找到这个偏好向量或权重是主观的，有时并不直接。
- en: '*Pareto optimization*, named after Italian economist and sociologist Vilfredo
    Pareto (1848–1923), relies on finding multiple trade-off optimal solutions and
    choosing one using higher-level information. This procedure tries to find the
    best trade-off by reducing the number of alternatives to an optimal set of nondominated
    solutions known as the Pareto front (or Pareto frontier), which can be used to
    make strategic decisions in multi-objective space. A solution is Pareto optimal
    if there is no other solution that improves one objective without worsening another
    objective, in the case of conflicting objective functions. Thus, the optimal solution
    for MOPs is not a single solution, as for mono-objective or single optimization
    problems (SOPs), but a set of solutions defined as *Pareto optimal solutions*.
    These Pareto optimal solutions are also known as acceptable, efficient, nondominated,
    or non-inferior solutions. *Nondominated solutions* in Pareto optimization represent
    the best compromises that are not outperformed by any other solution across multiple
    conflicting objectives.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*帕累托优化*，以意大利经济学家和社会学家维弗雷多·帕累托（1848-1923）的名字命名，依赖于寻找多个权衡最优解，并使用高级信息选择其中一个。此过程试图通过减少备选方案的数量到一个最优的非支配解集，称为帕累托前沿（或帕累托边界），在多目标空间中用于做出战略决策。在存在冲突目标函数的情况下，如果一个解没有其他解能在不降低另一个目标的情况下提高一个目标，则该解是帕累托最优的。因此，对于多目标优化问题（MOPs）的最优解不是一个单一解，如单目标或单一优化问题（SOPs）那样，而是一组定义为*帕累托最优解*的解。这些帕累托最优解也被称为可接受、有效、非支配或非劣解。在帕累托优化中，*非支配解*代表了在多个冲突目标中没有被其他任何解超越的最佳折衷方案。'
- en: 'In chapter 1, we looked at an electric vehicles example: acceleration time
    and driving range are conflicting objective functions, as we need to minimize
    the acceleration time and maximize the driving range of the vehicle. There is
    no universal best vehicle that achieves both, as shown in figure 8.12, which is
    based on real data retrieved from the *Inside EVs* website ([https://insideevs.com/](https://insideevs.com/)).
    For example, the Lucid Air Dream Edition has the highest driving range but not
    the lowest acceleration time. The dotted line shows the Pareto front—the vehicles
    that achieve the best trade-off between the acceleration time and the driving
    range.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们研究了电动汽车的例子：加速时间和续航里程是相互冲突的目标函数，因为我们需要最小化车辆的加速时间并最大化其续航里程。没有一种车辆能够同时实现这两个目标，如图
    8.12 所示，该图基于从 *Inside EVs* 网站获取的真实数据（[https://insideevs.com/](https://insideevs.com/)）。例如，Lucid
    Air Dream Edition 具有最长的续航里程，但不是最低的加速时间。虚线表示帕累托前沿——这些车辆在加速时间和续航里程之间实现了最佳权衡。
- en: '![](../Images/CH08_F12_Khamis.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F12_Khamis.png)'
- en: Figure 8.12 Acceleration time vs. driving range of 19 electric vehicles, as
    per September 2021
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 19 种电动汽车的加速时间与续航里程对比，截至 2021 年 9 月
- en: Multi-objective optimization algorithms
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 多目标优化算法
- en: There are several algorithms for solving multi-objective optimization problems.
    The nondominated sorting genetic algorithm (NSGA-II) is one of the most commonly
    used. Other algorithms include, but are not limited to, the strength Pareto evolutionary
    algorithm 2 (SPEA2), the Pareto-archived evolution strategy (PAES), the niched-Pareto
    genetic algorithm (NPGA), multi-objective selection based on dominated hypervolume
    (SMS-EMOA), and multi-objective evolutionary algorithm based on decomposition
    (MOEA/D).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 解决多目标优化问题的算法有很多。非支配排序遗传算法（NSGA-II）是最常用的之一。其他算法包括但不限于强度Pareto进化算法2（SPEA2）、Pareto存档进化策略（PAES）、带生态位Pareto遗传算法（NPGA）、基于支配超体积的多目标选择（SMS-EMOA）和基于分解的多目标进化算法（MOEA/D）。
- en: These algorithms have their own strengths and weaknesses, and your choice of
    algorithm will depend on the specific problem being solved and your preferences.
    NSGA-II has several advantages, such as diversity maintenance, non-dominated sorting,
    and fast convergence. For more details about multi-objective optimization, see
    Deb’s “Multi-objective optimization using evolutionary algorithms” [3] and Zitzler’s
    “Evolutionary algorithms for multiobjective optimization” [4].
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法各有优缺点，你选择的算法将取决于要解决的问题的具体情况和你的偏好。NSGA-II 有几个优点，如多样性维护、非支配排序和快速收敛。有关多目标优化的更多详细信息，请参阅
    Deb 的《使用进化算法进行多目标优化》[3] 和 Zitzler 的《多目标优化的进化算法》[4]。
- en: 'Let’s solve a MOP using NSGA-II in an example. Assume that a manufacturer produces
    two products, P1 and P2, involving two different machines, M1 and M2\. Each machine
    can only produce one product at a time, and each product has a different production
    time and cost on each machine:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子使用 NSGA-II 解决一个多目标优化问题。假设一个制造商生产两种产品，P1 和 P2，涉及两种不同的机器，M1 和 M2。每台机器一次只能生产一种产品，每种产品在每个机器上的生产时间和成本都不同：
- en: P1 requires 2 hours on M1 and 3 hours on M2, with production costs of $100 and
    $150 respectively.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P1 在 M1 上需要 2 小时，在 M2 上需要 3 小时，生产成本分别为 100 美元和 150 美元。
- en: P2 requires 4 hours on M1 and 1 hour on M2, with production costs of $200 and
    $50 respectively.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P2 在 M1 上需要 4 小时，在 M2 上需要 1 小时，生产成本分别为 200 美元和 50 美元。
- en: In each shift, the two machines, M1 and M2, have the capacity of producing 100
    units of P1 and 500 units of P2\. The manufacturer wants to produce at least 80
    units of P1 and 300 units of P2 while minimizing production costs and minimizing
    the difference in production times between the two machines.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个班次中，两台机器 M1 和 M2 的生产能力分别为生产 100 单位的 P1 和 500 单位的 P2。制造商希望生产至少 80 单位的 P1 和
    300 单位的 P2，同时最小化生产成本并最小化两台机器的生产时间差异。
- en: 'We’ll let *x*[1] and *x*[2] be the number of units of P1 produced on M1 and
    M2, respectively, and *y*[1] and *y*[2] be the number of units of P2 produced
    on M1 and M2, respectively. The problem can be formulated as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将令 *x*[1] 和 *x*[2] 分别表示在 M1 和 M2 上生产的 P1 的单位数量，*y*[1] 和 *y*[2] 分别表示在 M1 和
    M2 上生产的 P2 的单位数量。问题可以表述如下：
- en: '![](../Images/CH08_F12_Khamis-EQ05.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F12_Khamis-EQ05.png)'
- en: 'Subject to:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 受限于：
- en: '![](../Images/CH08_F12_Khamis-EQ06.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F12_Khamis-EQ06.png)'
- en: The first objective function (*f*[1]) represents the total production costs,
    and the second objective function (*f*[2]) represents the difference in production
    times between the two machines. Listing 8.3 shows the code for finding the optimal
    number of units to be produced in a shift using NSGA-II.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目标函数（*f*[1]）表示总生产成本，第二个目标函数（*f*[2]）表示两个机器的生产时间差异。列表8.3显示了使用NSGA-II找到在一个班次中应生产的单位最优数量的代码。
- en: We’ll start by inheriting from `ElementwiseProblem`, which allows us to define
    the optimization problem in an element-wise manner. `n_var` specifies the number
    of variables (4 in this case), `n_obj` defines the number of objectives (2), and
    `n_ieq_constr` indicates the number of inequality constraints (2). The `xl` and
    `xu` parameters define the lower and upper bounds for each variable respectively.
    The `_evaluate` method takes an input `x` (a solution candidate) and computes
    the objective values `f1` and `f2`, as well as the inequality constraints `g1`
    and `g2`. The third constraint is boundary constraint represented by the lower
    and upper bounds of the decision variables.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从`ElementwiseProblem`继承，这允许我们以逐元素的方式定义优化问题。`n_var`指定变量的数量（本例中为4），`n_obj`定义目标函数的数量（2），而`n_ieq_constr`表示不等式约束的数量（2）。`xl`和`xu`参数分别定义每个变量的下界和上界。`_evaluate`方法接受一个输入`x`（一个解候选）并计算目标值`f1`和`f2`，以及不等式约束`g1`和`g2`。第三个约束是边界约束，由决策变量的下界和上界表示。
- en: Listing 8.3 Solving a manufacturing problem using NSGA-II
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 使用NSGA-II解决制造问题
- en: '[PRE11]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Import an instance of the problem class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入问题类的一个实例。
- en: ② Define the number of variables, objective functions, constraints, and lower
    and upper bounds.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义变量数量、目标函数、约束以及下界和上界。
- en: ③ Total production costs as a first-objective function
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 总生产成本作为第一个目标函数
- en: ④ Difference in production times between the two machines as a second-objective
    function
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 两个机器的生产时间差异作为第二个目标函数
- en: ⑤ Define the constraints.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义约束。
- en: 'We can now set up an instance of the NSGA-II algorithm as the solver:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设置一个NSGA-II算法的实例作为求解器：
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Import the NSGA-II class.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入NSGA-II类。
- en: ② Import simulated binary crossover (SBX) as a crossover operator.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将模拟二进制交叉（SBX）作为交叉算子导入。
- en: ③ Import polynomial mutation (PM) as a mutation operator.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将多项式变异（PM）作为变异算子导入。
- en: ④ Import the FloatRandomSampling method to generate random floating-point values
    for each variable within a specified range.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 导入FloatRandomSampling方法以生成指定范围内的每个变量的随机浮点值。
- en: ⑤ Set up an instance of NSGA-II.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置NSGA-II的一个实例。
- en: The solver has a population size (`pop_size`) of 40 individuals, generates 10
    offspring using `FloatRandomSampling`, employs SBX crossover with a probability
    of 0.9, and fine-tunes the exponential distribution with an `eta` parameter of
    15\. PM mutation is used with an `eta` parameter of 20\. This `eta` parameter
    controls the spread of the mutation distribution. `eliminate_duplicates` is set
    to `True` so that duplicate candidate solutions will be removed from the population
    at each generation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 求解器具有40个个体的人口大小（`pop_size`），使用`FloatRandomSampling`生成10个后代，采用概率为0.9的SBX交叉，并使用`eta`参数为15的指数分布进行微调。使用`eta`参数为20的PM变异。此`eta`参数控制变异分布的扩散。`eliminate_duplicates`设置为`True`，以便在每一代中从种群中删除重复的候选解。
- en: 'We define the termination criterion by specifying the number of generations
    as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指定代数数来定义终止标准：
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now run the solver to minimize both objective functions simultaneously:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行求解器以同时最小化两个目标函数：
- en: '[PRE14]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we print the best 10 solutions as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式打印出最佳10个解决方案：
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code will produce output representing the best 10 non-dominated solutions
    obtained by NSGA-II and will look like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将生成表示NSGA-II获得的最佳10个非支配解的输出，其外观如下：
- en: '[PRE16]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As there is no universal best solution for these two objective functions, multi-criteria
    decision-making can be applied to select the best trade-off—the Pareto optimal.
    In pymoo, the decision-making procedure starts by defining boundary points called
    *ideal* and *nadir* points:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个目标函数没有通用的最佳解决方案，因此可以使用多标准决策来选择最佳权衡——帕累托最优。在pymoo中，决策过程首先通过定义称为*理想*点和*下界*点的边界点来开始：
- en: '*The ideal point*—This refers to the best possible values for each objective
    function that can be achieved in the entire feasible region of the problem. This
    point represents the scenario where all the objective functions are minimized
    simultaneously.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理想点*——这指的是在整个问题可行区域内可以实现的每个目标函数的最佳可能值。这一点代表了所有目标函数同时最小化的场景。'
- en: '*The nadir point*—This is the point where each objective function is maximized
    while satisfying all the constraints of the problem. It is the opposite of the
    ideal point and represents the worst possible values for each objective function
    in the entire feasible region of the problem.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*谷点*——这是每个目标函数在满足所有问题约束条件的同时达到最大化的点。它是理想点的对立面，代表了整个问题可行区域内每个目标函数的最坏可能值。'
- en: 'These points are used in multi-objective optimization problems to normalize
    the objective functions and convert them to a common scale, allowing for a fair
    comparison of different solutions. The two points are calculated as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点在多目标优化问题中用于标准化目标函数，并将它们转换为共同尺度，从而允许对不同的解决方案进行公平的比较。这两个点的计算如下：
- en: '[PRE17]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then define weights, which are required by the decomposition functions,
    based on the level of importance of each objective function from the developer’s
    perspective:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据开发者对每个目标函数重要性的看法，定义了分解函数所需的权重：
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Weights for f1 and f2 respectively
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ① f1和f2的权重
- en: 'A decomposition method is defined using the augmented scalarization function
    (ASF), discussed in Wierzbicki’s “The use of reference objectives in multiobjective
    optimization” [5]:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用增强标量化函数（ASF），如Wierzbicki在“多目标优化中参考目标的使用”[5]中讨论的，定义了一种分解方法：
- en: '[PRE19]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To find the best solutions, we choose the minimum ASF values calculated from
    all the solutions and use the inverse of the weights as required by ASF:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到最佳解决方案，我们选择从所有解决方案中计算出的最小ASF值，并使用ASF所需的权重的倒数：
- en: '[PRE20]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output is shown in figure 8.13.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如图8.13所示。
- en: '![](../Images/CH08_F13_Khamis.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F13_Khamis.png)'
- en: Figure 8.13 Manufacturing problem solution—the point marked with the X represents
    the selected Pareto optimal or best trade-off.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 制造问题解决方案——标记为X的点代表选定的帕累托最优或最佳权衡点。
- en: 'Running the code produces the following output:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码产生以下输出：
- en: '[PRE21]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The complete version of listing 8.3 is available in the book’s GitHub repository.
    It includes another method using pseudo-weights to choose a solution from a solution
    set in the context of multi-objective optimization.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3的完整版本可在本书的GitHub仓库中找到。它包括另一种方法，使用伪权重在多目标优化的上下文中从解决方案集中选择一个解决方案。
- en: 8.5 Adaptive GA
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 自适应遗传算法（GA）
- en: Adaptation methods help genetic algorithms strike a balance between exploration
    and exploitation, using different parameters such as initialization population
    size, crossover operators, and mutation operators. These parameters can be deterministically
    or dynamically adapted based on the search progress, allowing the algorithm to
    converge on high-quality solutions for complex optimization problems.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应方法帮助遗传算法在探索和利用之间取得平衡，使用不同的参数，如初始化种群大小、交叉算子和变异算子。这些参数可以根据搜索进度确定性地或动态地调整，使算法收敛到复杂优化问题的优质解决方案。
- en: For example, population size can be adaptive. A larger population size promotes
    diversity and exploration, while a smaller size allows for faster convergence.
    The population size can be increased if the algorithm is struggling to find better
    solutions or decreased if the population has become too diverse.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，种群大小可以是自适应的。较大的种群大小促进多样性和探索，而较小的种群大小允许更快地收敛。如果算法难以找到更好的解决方案，则可以增加种群大小；如果种群变得过于多样化，则可以减少种群大小。
- en: 'Mutation operator parameters can be used to adapt the genetic algorithm and
    balance its exploration and exploitation aspects. For example, in the case of
    Gaussian mutation, we can adaptively set the value of the standard deviation *σ*
    of the Gaussian distribution during the run. The standard deviation of the Gaussian
    distribution can be changed following a deterministic approach, an adaptive approach,
    or a self-adaptive approach. If you’re using a deterministic approach, the value
    of *σ* can be calculated in each generation using this formula: *σ*(*i*) = 1 –
    0.9 * *i*/ *N* where *i* is the generation number, ranging from 0 to *N* (the
    maximum generation number). In this case, the value of *σ* is 1 at the beginning
    of the optimization process and gradually reduces to 0.1 toward the end to move
    the search algorithm’s behavior from exploration to exploitation.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 突变算子参数可以用来适应遗传算法并平衡其探索和利用方面。例如，在高斯突变的情况下，我们可以在运行过程中自适应地设置高斯分布的标准差*σ*的值。高斯分布的标准差可以按照确定性方法、自适应方法或自适应性方法来改变。如果您使用确定性方法，*σ*的值可以在每一代使用此公式计算：*σ*(*i*)
    = 1 – 0.9 * *i*/ *N*，其中*i*是代数，范围从0到*N*（最大代数）。在这种情况下，*σ*的值在优化过程开始时为1，并逐渐减少到0.1，以将搜索算法的行为从探索转变为利用。
- en: The adaptive approach incorporates feedback from the search process to adjust
    the variance and improve the search performance. Rechenberg’s *1/5 success rule*
    is a well-known method that adjusts the step size of the search by monitoring
    the success rate of the search. This rule involves increasing the variance if
    a certain percentage of the previous mutations were successful in finding better
    solutions (i.e., if there was more than one successful mutation out of five tries),
    favoring exploration in order to avoid getting trapped in local optima. Otherwise,
    if there was a lower success rate, the variance should be decreased to favor exploitation.
    This allows the search to fine-tune its parameters based on its progress, leading
    to better performance and faster convergence to optimal solutions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应方法将搜索过程中的反馈纳入其中，以调整方差并提高搜索性能。Rechenberg的*1/5成功规则*是一种众所周知的方法，通过监控搜索的成功率来调整搜索的步长。这个规则涉及在一定的百分比的前一次突变成功找到更好的解决方案（即，在五次尝试中有多于一次的成功突变）时增加方差，以促进探索，从而避免陷入局部最优。否则，如果成功率较低，方差应减少以促进利用。这允许搜索根据其进度微调其参数，从而实现更好的性能和更快地收敛到最优解。
- en: Figure 8.14 shows the steps of applying Rechenberg’s 1/5 success rule. This
    update rule is applied in every generation, and a constant 0.82 <= *c* <= 1 is
    used to update the standard deviation of the Gaussian distribution. As you can
    see, the higher the standard deviation, the higher the value of *x*, and the higher
    the deviation from the current solution (more exploration), and vice versa.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14展示了应用Rechenberg的1/5成功规则的步骤。这个更新规则在每一代都应用，并使用一个常数0.82 <= *c* <= 1来更新高斯分布的标准差。正如您所看到的，标准差越高，*x*的值就越高，与当前解的偏差也越大（更多的探索），反之亦然。
- en: '![](../Images/CH08_F14_Khamis.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F14_Khamis.png)'
- en: Figure 8.14 Rechenberg’s 1/5 success rule. Following this rule, the Gaussian
    distribution’s standard deviation is updated by a constant. The higher the standard
    deviation, the higher the value of *x* (i.e., larger step size), the higher the
    deviation from the current solution (more exploration), and vice versa.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 Rechenberg的1/5成功规则。遵循此规则，高斯分布的标准差通过一个常数进行更新。标准差越高，*x*的值（即更大的步长）就越高，与当前解的偏差也越大（更多的探索），反之亦然。
- en: 'The self-adaptive approach incorporates the mutation step size into each individual—a
    technique originally employed in evolution strategies (ES). In this method, the
    value of *σ* (the standard deviation or the mutation step size) evolves alongside
    the individual, resulting in distinct mutation step sizes for each individual
    in the population. The following equations are used in this self-adaptive approach:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应方法将突变步长纳入每个个体——这是一种最初在进化策略（ES）中使用的技巧。在这个方法中，*σ*（标准差或突变步长）的值与个体一起进化，导致种群中每个个体的突变步长各不相同。以下方程用于这种自适应方法：
- en: '|'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH08_F14_Khamis-EQ07.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F14_Khamis-EQ07.png)'
- en: '| 8.2 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 8.2 |'
- en: '|'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH08_F14_Khamis-EQ08.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F14_Khamis-EQ08.png)'
- en: '| 8.3 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 8.3 |'
- en: where *τ[o]* is the learning rate.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *τ[o]* 是学习率。
- en: 'Now that you have a solid understanding of the various components of GAs, we
    can apply this powerful optimization technique to real-world problems. In the
    following sections, we will use GAs to solve three distinct problems: the traveling
    salesman problem, tuning the parameters of a PID controller, and the political
    districting problem.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对GAs的各个组成部分有了扎实的理解，我们可以将这种强大的优化技术应用于现实世界的问题。在接下来的几节中，我们将使用GAs来解决三个不同的问题：旅行商问题、PID控制器参数调整以及政治区划问题。
- en: 8.6 Solving the traveling salesman problem
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 解决旅行商问题
- en: Let’s consider the following traveling salesman problem (TSP) for 20 major cities
    in the USA, starting from New York City, as illustrated in figure 8.15.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下美国前20大城市的旅行商问题（TSP），从纽约市开始，如图8.15所示。
- en: '![](../Images/CH08_F15_Khamis.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F15_Khamis.png)'
- en: Figure 8.15 The 20 major US cities TSP
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 美国前20大城市TSP
- en: In listing 8.4, we start by importing the libraries we’ll use and defining the
    TSP. First, we define the city names and their latitudes and longitudes. We then
    use those coordinates to create a haversine distance matrix and then convert the
    data dictionary into a dataframe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表8.4中，我们首先导入我们将使用的库并定义TSP。首先，我们定义城市名称及其纬度和经度。然后，我们使用这些坐标创建一个哈夫曼距离矩阵，然后将数据字典转换为dataframe。
- en: Listing 8.4 Solving TSP using GA
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 使用GA解决TSP
- en: '[PRE22]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Define city names, latitudes, and longitudes for 20 major US cities.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义20个主要美国城市的城市名称、纬度和经度。
- en: ② Create a haversine distance matrix based on latitude-longitude coordinates.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ② 基于经纬度坐标创建哈夫曼距离矩阵。
- en: ③ Convert the distance dictionary into a dataframe.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将距离字典转换为dataframe。
- en: ④ Create a networkx graph.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建一个networkx图。
- en: 'We can then create `TravelingSalesman` as a subclass of the `ElementwiseProblem`
    class available in pymoo. This class defines the number of cities and the intercity
    distances as problem parameters, and it evaluates the total path length as an
    objective function to be minimized:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建`TravelingSalesman`作为pymoo中可用的`ElementwiseProblem`类的子类。这个类定义了城市数量和城市间距离作为问题参数，并将总路径长度作为要最小化的目标函数进行评估：
- en: '[PRE23]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following function is a subclass of the `Repair` class, and it provides
    a method to repair solutions for the TSP, ensuring that each solution starts with
    the city indexed as 0 (New York City, in this example). The repair operator in
    pymoo is used to make sure the algorithm is only searching the feasible space.
    It is applied after the offspring have been reproduced:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是`Repair`类的子类，它提供了一个用于修复TSP解决方案的方法，确保每个解决方案都以索引为0的城市（在本例中为纽约市）开始。pymoo中的修复操作员用于确保算法只搜索可行空间。它是在后代繁殖之后应用的：
- en: '[PRE24]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It’s time now to define a GA solver and apply it to solve the problem.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是定义GA求解器并将其应用于解决问题的时刻。
- en: '[PRE25]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Create a TSP instance for the given cities and intercity distances.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为给定城市和城市间距离创建TSP实例。
- en: ② Define the GA solver.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义GA求解器。
- en: ③ Terminate (and disable the max generations) if the algorithm did not improve
    in the last 300 generations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果算法在最后300代中没有改进，则终止（并禁用最大代数）。
- en: ④ Find the shortest path.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 找到最短路径。
- en: 'We can print the found route and its length as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式打印找到的路线及其长度：
- en: '[PRE26]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in the following output:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE27]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code is used to visualize the obtained route using NetworkX:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于使用NetworkX可视化获得的路线：
- en: '[PRE28]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① Create an independent shallow copy of the problem graph and attributes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建问题图和属性的独立浅拷贝。
- en: ② Reverse latitude and longitude for correct visualization.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ② 反转纬度和经度以正确可视化。
- en: ③ Create a list of keys in the original dictionary.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建原始字典的键列表。
- en: ④ Create a new dictionary with the keys in the desired order.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建一个具有所需顺序键的新字典。
- en: ⑤ Create an edge list.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建边列表。
- en: ⑥ Draw the closest edges on each node only.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 仅在每个节点上绘制最近的边。
- en: ⑦ Draw and show the route.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 绘制并显示路线。
- en: Figure 8.16 shows the obtained route for this traveling salesman problem.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16显示了该旅行商问题的获得路线。
- en: '![](../Images/CH08_F16_Khamis.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F16_Khamis.png)'
- en: Figure 8.16 The 20 major US cities TSP solution
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 美国前20大城市TSP解决方案
- en: You can experiment with the full code in the book’s GitHub repository by changing
    the problem data and the genetic algorithm parameters, such as population size,
    sampling, crossover, and mutation methods.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改问题数据和遗传算法参数（如种群大小、采样、交叉和变异方法）在书的GitHub仓库中实验完整的代码。
- en: 8.7 PID tuning problem
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 PID调整问题
- en: Have you ever wondered how your room stays at a comfortable temperature? Have
    you ever thought about how the heating or cooling system knows when to turn on
    and off automatically to maintain the temperature set on the thermostat? This
    is where control systems come into the picture. Control systems are like behind-the-scenes
    wizards that ensure things work smoothly and efficiently. They are sets of rules
    and mechanisms that guide devices or processes to achieve specific goals.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾想过你的房间是如何保持舒适温度的？你是否想过加热或冷却系统是如何知道何时自动开启和关闭以维持恒温器上设定的温度的？这就是控制系统发挥作用的地方。控制系统就像幕后的魔术师，确保事物平稳高效地运行。它们是一套规则和机制，引导设备或过程实现特定目标。
- en: 'One type of control system is a *closed-loop system*. Picture this: you’ve
    set your room’s thermostat to a cozy 22°C (72°F), and the heating or cooling system
    kicks in to reach that temperature. But what happens if it becomes too chilly
    or too warm? That’s when the closed-loop system starts to take action. It’s continually
    tracking the room’s current temperature, comparing it to the desired temperature,
    and making the necessary heating or cooling tweaks.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一种控制系统类型是*闭环系统*。想象一下：你将房间的恒温器设定在舒适的22°C（72°F），加热或冷却系统启动以达到该温度。但如果变得太冷或太热怎么办？这时闭环系统开始采取行动。它持续跟踪房间当前的温度，将其与期望温度进行比较，并做出必要的加热或冷却调整。
- en: The proportional integral derivative (PID) controller is the most commonly used
    algorithm in control systems engineering. This controller is designed to compensate
    for any error between the measured state (e.g., the current room temperature)
    and the desired state (e.g., the desired temperature value). Let’s consider room
    temperature control using a PID controller as an example.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 比例积分微分（PID）控制器是控制系统工程中最常用的算法。该控制器旨在补偿测量状态（例如，当前室温）与期望状态（例如，期望的温度值）之间的任何误差。让我们以使用PID控制器进行房间温度控制为例。
- en: 'As shown in figure 8.17, the controller takes the error signal *e*(*t*) (the
    difference between the desired state and the feedback signal) and produces the
    appropriate control signal *u*(*t*) to turn on or off the heater in order to minimize
    the difference between the current room temperature and the desired value. The
    control signal is calculated using equation 8.4:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如图8.17所示，控制器接收误差信号 *e*(*t*)（期望状态与反馈信号之间的差异）并产生适当的控制信号 *u*(*t*)以打开或关闭加热器，以最小化当前室温与期望值之间的差异。控制信号的计算使用方程8.4：
- en: '|'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH08_F16_Khamis-EQ09.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F16_Khamis-EQ09.png)'
- en: '| 8.4 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 8.4 |'
- en: As shown in this equation, the *proportional term* *K[p]e*(*t*) tends to produce
    a control signal that is proportional to the error and aims to rectify it. The
    *integral term* (the second term on the right side of the equation) tends to produce
    a control signal that is proportional to the magnitude of the error and its duration,
    or the area under the error curve. The *derivative term* (the third term on the
    right side of the equation) tends to produce a control signal that is proportional
    to the rate of error change, thus providing an anticipatory control signal.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如此方程所示，*比例项* *K[p]e*(*t*)倾向于产生一个与误差成比例的控制信号，旨在纠正它。*积分项*（方程右侧的第二项）倾向于产生一个与误差的大小及其持续时间成比例的控制信号，或者误差曲线下的面积。*微分项*（方程右侧的第三项）倾向于产生一个与误差变化率成比例的控制信号，从而提供一个预测控制信号。
- en: '![](../Images/CH08_F17_Khamis.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F17_Khamis.png)'
- en: Figure 8.17 PID-based closed-loop control system—the PID controller takes the
    error signal and produces a control signal to reduce the error to zero.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 基于PID的闭环控制系统——PID控制器接收误差信号并产生控制信号以将误差减少到零。
- en: 'Utilizing a PID controller allows the system (e.g., an air conditioner or heater)
    to follow the specified input and attain a desired or optimal steady-state error,
    rise time, settling time, and overshoot:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 利用PID控制器可以使系统（例如，空调或加热器）遵循指定的输入并达到期望或最优的稳态误差、上升时间、调整时间和超调：
- en: '*Rise time*—The rise time is the time required for the response to rise from
    10% to 90% of its final value.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上升时间*—上升时间是响应从最终值的10%上升到90%所需的时间。'
- en: '*Peak overshoot*—The peak overshoot (aka maximum overshoot) is the deviation
    of the response at peak time from the final value of the response.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*峰值超调*—峰值超调（也称为最大超调）是响应在峰值时刻与最终值之间的偏差。'
- en: '*Settling time*—The settling time is the time required for the response to
    reach the steady state and stay within the specified tolerance bands (e.g., 2–5%
    of the final value) after the transient response has settled.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*稳定时间*—稳定时间是响应达到稳态并保持在指定的容差带内（例如，最终值的2-5%）所需的时间，在瞬态响应稳定后。'
- en: '*Steady-state error*—The steady-state error is the difference between the desired
    value and the actual value of the system output when the system has reached a
    stable condition.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*稳态误差*—稳态误差是在系统达到稳定状态时，系统输出期望值与实际值之间的差异。'
- en: As shown in figure 8.18, the heater is turned on (i.e., energized) when the
    current room temperature is lower than the set point or the desired value. The
    heater is turned off (i.e., de-energized) when the temperature is above the set
    point.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如图8.18所示，当当前室温低于设定点或期望值时，加热器开启（即，通电）。当温度高于设定点时，加热器关闭（即，断电）。
- en: '![](../Images/CH08_F18_new_Khamis.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F18_new_Khamis.png)'
- en: Figure 8.18 Step response of a system. The heater is turned on or off according
    to the difference between the actual temperature and the desired value.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 系统的阶跃响应。加热器根据实际温度与期望值之间的差异开启或关闭。
- en: Table 8.6 shows the effect of PID controller parameters on the time response
    of the system. Note that these correlations may not be exactly accurate, because
    *K[p], K[i]*, and *K[d]* are dependent on each other. In fact, changing one of
    these variables can change the effect of the other two. For this reason, the table
    should only be used as a reference when you are determining the values for *K[p],
    K[i]*, and *K[d]*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.6显示了PID控制器参数对系统时间响应的影响。请注意，这些相关性可能并不完全准确，因为 *K[p]，K[i]* 和 *K[d]* 之间相互依赖。事实上，改变其中一个变量可能会改变其他两个变量的影响。因此，在确定
    *K[p]，K[i]* 和 *K[d]* 的值时，应仅将此表作为参考。
- en: Table 8.6 Effects of adding PID controller parameters on the system’s response
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.6 添加PID控制器参数对系统响应的影响
- en: '| Parameter | Rise time | Overshoot | Settling time | Steady-state error |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 上升时间 | 超调 | 稳定时间 | 稳态误差 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| K[p] | Decreases | Increases | Small change | Decreases |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| K[p] | 减少 | 增加 | 小变化 | 减少 |'
- en: '| K[i] | Decreases | Increases | Increases | Decreases significantly |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| K[i] | 减少 | 增加 | 增加 | 显著减少 |'
- en: '| K[d] | Small change | Decreases | Decreases | Small change |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| K[d] | 小变化 | 减少 | 减少 | 小变化 |'
- en: 'Finding the optimal values of the PID controller parameters for an optimal
    controller response is a multivariate optimization problem commonly referred to
    as the *PID tuning problem*. The following four performance metrics are commonly
    used to evaluate the quality of a control system such as a PID controller:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找PID控制器参数的最佳值以实现最佳控制器响应是一个多变量优化问题，通常被称为*PID调整问题*。以下四个性能指标通常用于评估控制系统的质量，如PID控制器：
- en: '*ITAE (integral time absolute error)*—This metric penalizes errors that persist
    over time, making it suitable for systems where transient response and settling
    time are important. It is calculated using this formula: ITAE = ∫(*t*|*e*(*t*)|)
    *dt*, where *t* is the time, *e*(*t*) is the error at time *t* defined as *e*(*t*)
    = *r*(*t*) – *y*(*t*), *r*(*t*) is the reference signal (desired output) at time
    *t* (for step response *r*(*t*) = 1), and *y*(*t*) is the actual output of the
    system at time *t*.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ITAE (积分时间绝对误差)*—这个指标惩罚随时间持续存在的错误，使其适用于瞬态响应和稳定时间都很重要的系统。它是通过以下公式计算的：ITAE =
    ∫(*t*|*e*(*t*)|) *dt*，其中 *t* 是时间，*e*(*t*) 是时间 *t* 的误差，定义为 *e*(*t*) = *r*(*t*)
    – *y*(*t*)，*r*(*t*) 是时间 *t* 的参考信号（期望输出）（对于阶跃响应 *r*(*t*) = 1），*y*(*t*) 是时间 *t*
    时系统的实际输出。'
- en: '*ITSE (integral time square error)*—Like ITAE, this metric also penalizes errors
    that last for a long time but places more emphasis on larger errors due to the
    squared term. It is calculated using this formula: ITSE = ∫(*te*(*t*)²) *dt*.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ITSE (积分时间平方误差)*—与ITAE类似，这个指标也惩罚持续时间较长的错误，但由于平方项，它更强调较大的错误。它是通过以下公式计算的：ITSE
    = ∫(*te*(*t*)²) *dt*。'
- en: '*IAE (integral absolute error)*—This metric measures the overall magnitude
    of the error without considering the duration of the error. This is a simple and
    widely used performance metric, and it’s calculated using this formula: IAE =
    ∫|*e*(*t*)| *dt*.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IAE (积分绝对误差)*—这个指标衡量了误差的整体幅度，不考虑误差的持续时间。这是一个简单且广泛使用的性能指标，它使用以下公式计算：IAE = ∫|*e*(*t*)|
    *dt*。'
- en: '*ISE (integral squared error)*—This metric emphasizes larger errors due to
    the squared term, making it useful for systems where minimizing large errors is
    a priority. It is calculated using this formula: ISE = ∫*e*(*t*)² *dt*. It penalizes
    errors more heavily if they occur later in the evolution of the response. It also
    penalizes an error *E* for time *dt* more heavily than *E*/*α* for time *αdt*,
    where *α* > 1. This expected response may have a slow rise time but with a more
    oscillatory behavior.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISE (积分平方误差)*—这个指标强调较大的误差，由于平方项的存在，使其在需要优先最小化大误差的系统中非常有用。它使用以下公式进行计算：ISE =
    ∫*e*(*t*)² *dt*。如果误差发生在响应演化的后期，它会对误差进行更重的惩罚。它对时间 *dt* 内的误差 *E* 的惩罚比对 *E*/*α*（其中
    *α* > 1）的惩罚更重。这种预期的响应可能具有较慢的上升时间，但具有更振荡的行为。'
- en: '*Combined criteria*—This metric combines overshoot, rise time, settling time,
    and steady-state error [6]. It is calculated using this formula: *W* = (1 – *e*^–*^β*)(*M[p]*
    + error*[ss]*) + *e*^–*^β* (*t[s]* – *t[r]*), where *M*[p] is the overshoot, error[ss]
    is the steady-state error, *t[s]* is the settling time, *t[r]* is the rise time,
    and *β* is a balancing factor in the range of 0.8 to 1.5\. You can set *β* to
    be larger than 0.7 to reduce the overshoot and steady-state error. On the other
    hand, you can set *β* to be smaller than 0.7 to reduce the rise time and settling
    time.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*综合标准*—这个指标结合了超调、上升时间、稳定时间和稳态误差 [6]。它使用以下公式进行计算：*W* = (1 – *e*^–*^β*)(*M[p]*
    + error*[ss]*) + *e*^–*^β* (*t[s]* – *t[r]*)，其中 *M*[p] 是超调，error[ss] 是稳态误差，*t[s]*
    是稳定时间，*t[r]* 是上升时间，*β* 是介于 0.8 到 1.5 之间的平衡因子。你可以将 *β* 设置得大于 0.7 以减少超调和稳态误差。另一方面，你可以将
    *β* 设置得小于 0.7 以减少上升时间和稳定时间。'
- en: Each of these metrics quantifies the error between the desired output and the
    actual output of the system in different ways, emphasizing different aspects of
    the control system’s performance. Note that performance metrics are not strictly
    confined to the aforementioned metrics. Engineers have the flexibility to devise
    custom performance metrics tailored to the specific goals and characteristics
    of the control system under consideration.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标中的每一个都以不同的方式量化了期望输出和系统实际输出之间的误差，强调了控制系统性能的不同方面。请注意，性能指标并不严格局限于上述指标。工程师有灵活性，可以设计定制的性能指标，以适应所考虑的控制系统的特定目标和特征。
- en: Figure 8.19 shows a closed-loop control system where a transfer function is
    used to describe the relationship between the input and output of the system in
    a Laplace domain. This domain is a generalization of a frequency domain, providing
    a more comprehensive representation that includes transient behavior and initial
    conditions. Assume that *T[sp]* is the set point or the desired output and *G*
    represents the transfer functions indicated in the block diagram.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 展示了一个闭环控制系统，其中传递函数用于描述系统在拉普拉斯域中输入和输出之间的关系。这个域是频率域的推广，提供了一个更全面的表示，包括瞬态行为和初始条件。假设
    *T[sp]* 是设定点或期望输出，*G* 代表框图中指示的传递函数。
- en: '![](../Images/CH08_F19_Khamis.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F19_Khamis.png)'
- en: Figure 8.19 Closed-loop control system
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 闭环控制系统
- en: 'All variables are a function of *s*, which is the output variable from a Laplace
    transform. The transfer function of a PID controller is given by this equation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量都是 *s* 的函数，*s* 是拉普拉斯变换的输出变量。PID 控制器的传递函数由以下方程给出：
- en: '|'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH08_F19_Khamis-EQ10.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F19_Khamis-EQ10.png)'
- en: '| 8.5 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 8.5 |'
- en: 'where *K[p]* is the proportional gain, *K[i]* is the integral gain, and *K[d]*
    is the derivative gain. Assume that the transfer function of the HVAC system is
    given by this equation:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *K[p]* 是比例增益，*K[i]* 是积分增益，*K[d]* 是微分增益。假设 HVAC 系统的传递函数由以下方程给出：
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH08_F19_Khamis-EQ11.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F19_Khamis-EQ11.png)'
- en: '| 8.6 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 8.6 |'
- en: 'Assuming that *G[s]* = 1 (unity feedback) and using block diagram reduction,
    we can find the overall transfer function *T*(*s*) of the closed loop system:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *G[s]* = 1（单位反馈）并使用框图简化，我们可以找到闭环系统的整体传递函数 *T*(*s*)：
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH08_F19_Khamis-EQ12.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F19_Khamis-EQ12.png)'
- en: '| 8.7 |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 8.7 |'
- en: Let’s now look at how we can find the optimal values for the PID parameters
    with Python. In the next listing, we start by importing the libraries we’ll use
    and defining the overall transfer function of the control system.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 Python 找到 PID 参数的最佳值。在下一个列表中，我们首先导入我们将使用的库并定义控制系统的整体传递函数。
- en: Listing 8.5 Solving the PID tuning problem using GA
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 使用 GA 解决 PID 调节问题
- en: '[PRE29]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① Import the control module.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入控制模块。
- en: ② Take PID parameters as input.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将PID参数作为输入。
- en: ③ Define the numerator of the transfer function.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义传递函数的分子。
- en: ④ Define the denominator of the transfer function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义传递函数的分母。
- en: ⑤ Create a transfer function.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建传递函数。
- en: ⑥ Get time response output using a step function as a system input.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 使用阶跃函数作为系统输入来获取时间响应输出。
- en: 'Next, we can define the objective functions or performance criteria:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义目标函数或性能标准：
- en: '[PRE30]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① ITAE (integral time absolute error)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ① ITAE（积分时间绝对误差）
- en: ② ITSE (integral time square error)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ② ITSE（积分时间平方误差）
- en: ③ IAE (integral absolute error)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ③ IAE（积分绝对误差）
- en: ④ ISE (integral squared error)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ④ ISE（积分平方误差）
- en: ⑤ W (combined criteria)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ W（综合标准）
- en: 'We can now define the optimization problem for the PID controller:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义PID控制器的优化问题：
- en: '[PRE31]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① Three decision variables, representing the PID controller’s Kp, Ki, and Kd
    gains
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ① 三个决策变量，代表PID控制器的Kp、Ki和Kd增益
- en: ② Number of objective functions
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ② 目标函数的数量
- en: ③ No constraints
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 无约束
- en: ④ Lower and upper bounds for the decision variables
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 决策变量的上下限
- en: ⑤ Evaluate the objective function.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 评估目标函数。
- en: 'Next, we can set up and solve the PID tuning problem using GA. The previously
    defined `PIDProblem` class is used to model the optimization problem. The GA solver
    is configured with a population size of 50\. Initial solutions are sampled using
    `FloatRandomSampling`, and the crossover operation employs a two-point crossover
    with a probability of 0.8\. Additionally, polynomial mutation is applied with
    a probability of 0.3, and the algorithm runs for 60 generations:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用遗传算法（GA）设置和解决PID调整问题。之前定义的`PIDProblem`类用于建模优化问题。GA求解器配置了50个种群大小。初始解通过`FloatRandomSampling`采样，交叉操作采用两点交叉，概率为0.8。此外，应用多项式变异，概率为0.3，算法运行60代：
- en: '[PRE32]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s now print the results:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打印结果：
- en: '[PRE33]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And we’ll visualize the time response:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将可视化时间响应：
- en: '[PRE34]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Figure 8.20 depicts the step response of the system, demonstrating how its outputs
    change over time when the inputs swiftly transition from 0 to 1.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20描述了系统的阶跃响应，展示了当输入迅速从0变为1时，其输出随时间的变化情况。
- en: '![](../Images/CH08_F20_Khamis.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F20_Khamis.png)'
- en: Figure 8.20 Step response
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20阶跃响应
- en: 'To show the step response characteristics (rise time, settling time, peak,
    and others), you can use the following function:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示阶跃响应特性（上升时间、稳定时间、峰值等），你可以使用以下函数：
- en: '[PRE35]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This results in the following output:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE36]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can experiment with adjusting the algorithm’s parameters (such as population
    size, crossover method and probability, mutation method and probability, number
    of generations, etc.) and altering the performance metric to observe the effects
    on the system’s performance.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试调整算法的参数（如种群大小、交叉方法和概率、变异方法和概率、代数数量等）以及改变性能指标，以观察对系统性能的影响。
- en: 8.8 Political districting problem
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 政治选区划分问题
- en: I introduced political districting in section 2.1.5—it can be defined as the
    process of grouping *n* subregions within a territory into *m* electoral districts
    while adhering to certain constraints. Suppose we need to merge *n* neighborhoods
    in the City of Toronto into *m* electoral districts while ensuring a sufficient
    level of population equality. Figure 8.21 shows a sample dataset that contains
    population and median household income for 16 neighborhoods in East Toronto.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第2.1.5节介绍了政治选区划分——它可以定义为将一个领土内的*n*个子区域划分为*m*个选区的过程，同时遵守某些约束。假设我们需要将多伦多市的*n*个社区合并为*m*个选区，同时确保足够的人口平等水平。图8.21显示了包含东多伦多16个社区的人口和中等家庭收入样本数据集。
- en: '![](../Images/CH08_F21_Khamis.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F21_Khamis.png)'
- en: Figure 8.21 The 16 neighborhoods in East Toronto with their population and median
    household income
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 东多伦多的16个社区及其人口和中等家庭收入
- en: 'In addressing the political districting problem, a viable solution must ensure
    that there is a satisfactory degree of population equilibrium (i.e., a fair and
    balanced distribution) in every electoral district. For example, we can evaluate
    a district’s population balance by calculating the deviation from an ideal population
    size within an upper bound (pop[UB]) and lower bound (pop[LB]) as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决政治选区划分问题时，一个可行的解决方案必须确保每个选区都有令人满意的种群均衡程度（即公平和平衡的分布）。例如，我们可以通过计算一个选区的人口平衡度，即在上限（pop[UB]）和下限（pop[LB]）内与理想人口规模的偏差来评估一个选区的人口平衡度，如下所示：
- en: '![](../Images/CH08_F21_Khamis-EQ13.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F21_Khamis-EQ13.png)'
- en: where *pop[av]* represents the target population size that can be considered
    the average of all the neighborhoods and *pop[margin]* indicates the acceptable
    degree of deviation from the ideal population size. *n* is the number of the neighborhoods,
    and *m* is the number of districts.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *pop[av]* 代表可以被认为是所有邻里平均值的预期人口规模，而 *pop[margin]* 表示从理想人口规模可接受的偏差程度。*n* 是邻里数量，而
    *m* 是区域数量。
- en: A district will be regarded as overpopulated if its total population exceeds
    the upper bound, and conversely, a district will be deemed underpopulated if its
    total population falls below the lower bound. A district whose population falls
    within the upper and lower bounds will be regarded as having an appropriate population
    size. The objective function is to minimize the total number of overpopulated
    and underpopulated districts. The search process will persist until the objective
    function’s minimum value is obtained, ideally zero. This indicates that no districts
    are either overpopulated or underpopulated.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个区域的总人口超过上限，则该区域将被视为过度拥挤，反之，如果一个区域的总人口低于下限，则该区域将被视为人口不足。如果一个区域的居民人数在上下限之间，则该区域将被视为具有适当的人口规模。目标函数是最小化过度拥挤和人口不足的区域总数。搜索过程将持续进行，直到目标函数的最小值获得，理想情况下为零。这表明没有区域是过度拥挤或人口不足的。
- en: The next listing shows how to find the political districts using GA. We’ll start
    by reading the data from a local folder or using a URL.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何使用遗传算法（GA）查找政治区域。我们将从读取本地文件夹中的数据或使用URL开始。
- en: Listing 8.6 Solving a political districting problem using GA
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 使用遗传算法解决政治区域划分问题
- en: '[PRE37]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① URL for the data folder
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ① 数据文件夹的URL
- en: ② Read the Toronto region administration boundaries.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ② 读取多伦多地区行政边界。
- en: ③ Read the neighborhood information (e.g., names, populations, and median household
    incomes).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 读取邻里信息（例如，名称、人口和平均家庭收入）。
- en: ④ Pick 16 neighborhoods as a subset to represent neighborhoods in East Toronto.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 选择16个邻里作为子集来代表东多伦多的邻里。
- en: After reading the dataset, we’ll do the following data preprocessing to get
    the population of each neighborhood, and the adjacency relationship among every
    possible pair of neighborhoods, in a Boolean matrix.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取数据集后，我们将进行以下数据预处理，以获取每个邻里的居民人数以及每个可能邻里的每对邻里之间的邻接关系，以布尔矩阵的形式。
- en: '[PRE38]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① Get the population of each neighborhood.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ① 获取每个邻里的居民人数。
- en: ② Prepare the population dataset.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ② 准备人口数据集。
- en: ③ Represent the adjacency relationship among every possible pair of neighborhoods.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 表示每个可能邻里的每对邻里之间的邻接关系。
- en: 'We’ll now define the political districting class with a single objective function,
    three constraints, a given number of districts, a given population margin, and
    an adjacency matrix between the neighborhoods. `PoliticalDistricting` is a custom
    problem class that extends the `Problem` class from pymoo. The `Problem` class
    implements a method that evaluates a set of solutions instead of a single solution
    at a time, like in the case of the `ElementwiseProblem` class. In the `PoliticalDistricting`
    class, the following parameters are defined:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义一个具有单个目标函数、三个约束条件、给定数量的区域、给定的人口边际和邻里之间的邻接矩阵的政治区域划分类。`PoliticalDistricting`是一个自定义问题类，它扩展了来自pymoo的`Problem`类。`Problem`类实现了一个方法，该方法评估一组解决方案而不是一次评估一个解决方案，就像在`ElementwiseProblem`类的情况下。在`PoliticalDistricting`类中，以下参数被定义：
- en: '`num_dist`—The number of districts to divide the region into'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_dist`—将区域划分为多少个区域'
- en: '`neighbor`—A matrix representing the neighborhood relationships between locations
    in the region'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`neighbor`—表示区域中位置之间邻里关系的矩阵'
- en: '`populations`—The population of each neighborhood'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`populations`—每个邻里的居民人数'
- en: '`margin`—The acceptable degree of deviation from the ideal population size'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin`—从理想人口规模可接受的偏差程度'
- en: '`average`—The average population'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`average`—平均人口'
- en: '`n_var`—The number of decision variables, which is equal to the number of neighborhoods'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_var`—决策变量的数量，等于邻里的数量'
- en: '`n_obj=1`—The number of objectives, which is 1 for this problem'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_obj=1`—目标函数的数量，对于这个问题是1'
- en: '`n_eq_constr=3`—The number of equality constraints, which is 3 for this problem'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_eq_constr=3`—等式约束的数量，对于这个问题是3'
- en: '`xl=0`—The lower bound for the decision variables, which is 0 for this problem'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xl=0`—决策变量的下限，对于这个问题是0'
- en: '`xu=num_dist-1`—The upper bound for the decision variables, which is `num_dist-1`
    for this problem'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xu=num_dist-1`—决策变量的上限，对于这个问题是`num_dist-1`'
- en: '`vtype=int`—The type of decision variables, which is integer for this problem'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vtype=int`—决策变量的类型，对于这个问题是整数'
- en: 'The following code shows how to define a `PoliticalDistricting` class with
    different parameters, such as the number of districts, neighbor information, populations,
    and margin:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何定义具有不同参数的`PoliticalDistricting`类，例如区域数量、邻域信息、人口和边际值：
- en: '[PRE39]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Define a constructor with specific parameters.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个具有特定参数的构造函数。
- en: ② Hold the population data.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ② 保存人口数据。
- en: ③ Store the mean population of all districts.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 存储所有区域的平均人口。
- en: ④ Call the constructor of the parent class with specific parameters.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用特定参数调用父类的构造函数。
- en: ⑤ Evaluate the solution against the objective function and constraints.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 对解决方案进行目标函数和约束的评估。
- en: 'As a continuation and as part of the `problem` class, we’ll extract the neighborhoods
    that belong to a specific district using the following function:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 作为延续并作为`problem`类的一部分，我们将使用以下函数提取属于特定区域的邻域：
- en: '[PRE40]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We’ll then calculate the upper and lower bounds based on the given population
    values and margin as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将根据给定的人口值和边际值计算上下限，如下所示：
- en: '[PRE41]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following function is used to decide whether an electoral district is overpopulated
    or underpopulated:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于判断选举区域是否过度拥挤或人口不足：
- en: '[PRE42]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As all the constraints are equality constraints, the following function returns
    true if the constraint is satisfied:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有约束都是等式约束，以下函数在约束满足时返回true：
- en: '[PRE43]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To make sure that there is no isolated neighborhood far from other neighbors
    within a district, unless the district only has one neighborhood, the following
    function is used:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保区域内没有远离其他邻域的孤立邻域，除非该区域只有一个邻域，以下函数被使用：
- en: '[PRE44]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following function determines the best approximation to make an electoral
    district a contiguous block:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数确定将选举区域变成连续块的最佳近似：
- en: '[PRE45]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The last function in the `problem` class is used to evaluate the solution against
    the objective function, including checking the constraints:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`problem`类中的最后一个函数用于评估解决方案与目标函数的对比，包括检查约束：'
- en: '[PRE46]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '① Constraint 1: make sure that there is no empty district,'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ① 约束1：确保没有空区域，
- en: '② Constraint 2: make sure there is no lone neighborhood within a district,
    unless the district only has one neighborhood.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ② 约束2：确保区域内没有孤立的邻域，除非该区域只有一个邻域。
- en: '③ Constraint 3: ensure the electoral district is a contiguous block by achieving
    the best possible approximation.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 约束3：通过实现最佳可能近似来确保选举区域是连续块。
- en: 'We can now define the GA solver and apply it to solve the problem as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义GA求解器并将其应用于解决问题，如下所示：
- en: '[PRE47]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The resultant political districts are listed here and visualized in figure
    8.22:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的结果政治区域在此处，并在图8.22中可视化：
- en: '[PRE48]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![](../Images/CH08_F22_Khamis.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F22_Khamis.png)'
- en: Figure 8.22 The three political districts that combine the 16 neighborhoods
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 结合16个邻域的三个政治区域
- en: The problem is treated as a single objective optimization problem where the
    objective is to minimize the total number of overpopulated and underpopulated
    districts. The dataset contains the median household income of each neighborhood,
    so you can replace the objective function to focus on the heterogeneity of the
    median household income. You can also treat the problem as a multi-objective optimization
    problem by considering both criteria.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题被视为一个单目标优化问题，目标是最小化过度拥挤和人口不足的区域总数。数据集包含每个邻域的中等家庭收入，因此您可以替换目标函数以关注中等家庭收入的不均匀性。您还可以通过考虑这两个标准将问题视为多目标优化问题。
- en: This chapter marks the end of the third part of the book, which focused on genetic
    algorithms and their applications in solving complex optimization problems. The
    fourth part of the book will delve into the fascinating realm of swarm intelligence
    algorithms.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着本书第三部分的结束，该部分主要关注遗传算法及其在解决复杂优化问题中的应用。本书的第四部分将深入探讨群智能算法的迷人领域。
- en: Summary
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The Hamming cliff problem, which results from the inherent nature of binary
    representation, negatively affects binary-coded GAs by disrupting the search space’s
    smoothness, causing poor convergence and leading to inefficient exploration and
    exploitation. To address this problem, alternative representations like Gray code
    or real-valued encoding can be used, as they offer better locality and smoother
    search spaces, minimizing the disruptive effects of small changes on decoded values.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汉明悬崖问题是由二进制表示的固有性质引起的，它通过破坏搜索空间的平滑性，对二进制编码的遗传算法产生负面影响，导致收敛不良，并导致探索和利用效率低下。为了解决这个问题，可以使用如格雷码或实值编码等替代表示方法，因为它们提供了更好的局部性和更平滑的搜索空间，最小化了小变化对解码值的影响。
- en: Real-valued GA is well suited for optimization problems involving continuous
    variables or real-valued parameters. It offers benefits such as better representation
    precision, faster convergence, diverse crossover and mutation operations, and
    reduced complexity, making it an attractive choice for many continuous optimization
    problems.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实值遗传算法（GA）非常适合涉及连续变量或实值参数的优化问题。它提供了诸如更好的表示精度、更快的收敛速度、多样化的交叉和变异操作以及降低复杂度等好处，使其成为许多连续优化问题的理想选择。
- en: Permutation-based GA is a class of genetic algorithms specifically designed
    to handle combinatorial optimization problems where the solutions can be represented
    as ordered sequences, or permutations, of elements.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于排列的遗传算法是一类专门设计用来处理组合优化问题的遗传算法，其中解决方案可以表示为元素的有序序列或排列。
- en: Multi-objective optimization problems can be tackled using either a preference-based
    multi-objective optimization method or a Pareto optimization approach. In the
    preference-based method, the multiple objectives are combined into a single or
    overall objective function by using a weighting scheme. The Pareto optimization
    approach focuses on identifying multiple trade-off optimal solutions known as
    Pareto-optimal solutions. These solutions can be further refined using higher-level
    information or decision-making processes.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多目标优化问题可以使用基于偏好的多目标优化方法或帕累托优化方法来解决。在基于偏好的方法中，多个目标通过使用加权方案组合成一个或整体目标函数。帕累托优化方法侧重于识别多个权衡最优解，即帕累托最优解。这些解决方案可以通过更高层次的信息或决策过程进一步优化。
- en: Crossover is primarily exploitative, as it combines the genetic material of
    two parent individuals to produce offspring, promoting the exchange of beneficial
    traits between solutions. However, depending on the implementation, crossover
    can also have some explorative properties, as it can produce offspring with new
    combinations of genes, leading to the discovery of new solutions.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉操作主要是利用性的，因为它结合了两个父个体的遗传物质以产生后代，促进了解决方案之间有益特征的交换。然而，根据实现方式，交叉也可以具有一些探索性，因为它可以产生具有新基因组合的后代，从而发现新的解决方案。
- en: Mutation can act as an explorative or exploitative operator depending on influencing
    factors such as the mutation rate and the mutation step size.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异操作可以根据影响因子，如变异率和变异步长，起到探索或利用的作用。
- en: In general, the crossover rate should be relatively high, as it promotes the
    exchange of genetic information between parent chromosomes. On the other hand,
    mutation is typically applied with a low probability, as its main purpose is to
    introduce random variations into the population.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，交叉率应该相对较高，因为它促进了父染色体之间遗传信息的交换。另一方面，变异通常以低概率应用，因为其主要目的是向种群中引入随机变异。
