- en: 8 Genetic algorithm variants
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Gray-coded genetic algorithm
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding real-valued GA and its genetic operators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding permutation-based GA and its genetic operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding multi-objective optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting genetic algorithms to strike a balance between exploration and exploitation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving continuous and discrete problems using GA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter continues with the topic of chapter 7: we will look at various
    forms of genetic algorithms (GAs) and delve deeper into their real-world applications.
    We’ll also look at a number of case studies and exercises, such as the traveling
    salesman problem (TSP), proportional integral derivative (PID) controller design,
    political districting, the cargo bike loading problem, manufacturing planning,
    facility allocation, and the opencast mining problem in this chapter and its supplementary
    exercises included in the online appendix C.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Gray-coded GA
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Hamming cliff effect refers to the fact that small changes in a chromosome
    can result in large changes in a solution’s fitness, which can lead to a sharp
    drop-off in the fitness landscape and cause the algorithm to converge prematurely.
    In binary genetic algorithms, the crossover and mutation operations can significantly
    affect the solution due to this Hamming cliff effect, especially when the bits
    that are to be changed are among the most significant bits in the binary string.
    To mitigate the Hamming cliff effect, Gray-coded GA uses a Gray-code encoding
    scheme for the chromosomes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The reflected binary code, commonly referred to as *Gray code* after its inventor
    Frank Gray, is a unique binary numbering system characterized by adjacent numerical
    values differing by only one bit, as shown in table 8.1\. In this numeral system,
    each value has a unique representation that is close to the representations of
    its neighboring values, which helps minimize the effect of crossover and mutation
    operations on the solution. This coding ensures a smooth transition between values
    and minimizes the risk of errors during conversions or when used in various applications,
    such as rotary encoders and digital-to-analog converters. Table 8.1 shows the
    decimal numbers 1 to 15 and their corresponding binary and Gray equivalents.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1 Decimal, binary, and Gray coding
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '| Decimal number | Binary code | Gray code |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0000 | 0000 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0001 | 0001 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0010 | 0011 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0011 | 0010 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0100 | 0110 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0101 | 0111 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| 6 | 0110 | 0101 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| 7 | 0111 | 0100 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1000 | 1100 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| 9 | 1001 | 1101 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1010 | 1111 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| 11 | 1011 | 1110 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| 12 | 1100 | 1010 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| 13 | 1101 | 1011 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| 14 | 1110 | 1001 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| 15 | 1111 | 1000 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: Exclusive OR (XOR) gates are used to convert 4-bit binary numbers to Gray codes,
    as illustrated in figure 8.1 for the ticket pricing example discussed in the previous
    chapter. These XOR gates result in 1 only if the inputs are different and 0 if
    the inputs are the same.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F01_Khamis.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH08_F01_Khamis.png)'
- en: Figure 8.1 Gray coding and binary-to-Gray conversion
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 格雷码和二进制到格雷码转换
- en: In Gray code, two successive values differ by only one bit. This property reduces
    the Hamming distance between adjacent numbers, leading to a smoother search space
    or smoother genotype-to-phenotype mapping.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在格雷码中，两个连续的值只相差一位。这个性质减少了相邻数字之间的汉明距离，导致搜索空间或基因型到表型的映射更加平滑。
- en: Hamming cliff problem
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 汉明悬崖问题
- en: One of the drawbacks of encoding variables as binary strings is the presence
    of Hamming cliffs. In binary-coded GAs, a small change in the encoded value (e.g.,
    flipping a single bit) can lead to a significant change in the decoded value,
    especially if the flipped bit is located toward the most significant bit position.
    This abrupt change between two adjacent numbers in the search space is referred
    to as a Hamming cliff. This problem negatively affects binary-coded GAs by disrupting
    the search space’s smoothness, causing poor convergence and leading to inefficient
    exploration and exploitation. To address the Hamming cliff problem, alternative
    representations like Gray code or real-valued encoding can be used, as they offer
    better locality and smoother search spaces, minimizing the disruptive effects
    of small changes on decoded values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量编码为二进制字符串的一个缺点是存在汉明悬崖。在二进制编码的遗传算法中，编码值的小幅变化（例如，翻转单个位）可能导致解码值发生显著变化，特别是如果翻转的位位于最高位位置。搜索空间中两个相邻数字之间的这种突然变化被称为汉明悬崖。这个问题通过破坏搜索空间的平滑性，导致收敛不良，并导致探索和利用效率低下，从而对二进制编码的遗传算法产生负面影响。为了解决汉明悬崖问题，可以使用像格雷码或实值编码这样的替代表示，因为它们提供了更好的局部性和更平滑的搜索空间，最小化了小变化对解码值的影响。
- en: 'For example, assume that we have a decision variable in the range [0, 15],
    as shown in the following figure. In binary-coded GA, we would use 4-bit binary
    representation to encode the candidate solutions. Let’s assume we have two adjacent
    solutions in the search space: 7 and 8, or 0111 and 1000 in binary representation.
    The Hamming distance is the number of bit-wise differences, so the Hamming distance
    between 1000 and 0111 is 4\. These two solutions (7 and 8) are neighbors in the
    search space, but when you look at their binary representations, you can see that
    they differ in all 4 bits. Flipping the most significant bit causes a significant
    change in the decoded value. In the case of Gray code, the Hamming distance between
    the Gray code representation 0100 (7 in decimal) and 1100 (8 in decimal) is only
    1\. This means that these Gray code representations for the two adjacent solutions
    differ by only 1 bit, providing a smoother search space and potentially improving
    the performance of the GA.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个范围在 [0, 15] 内的决策变量，如图所示。在二进制编码的遗传算法中，我们会使用 4 位二进制表示来编码候选解。假设我们在搜索空间中有两个相邻的解：7
    和 8，或者二进制表示中的 0111 和 1000。汉明距离是位差的数量，所以 1000 和 0111 之间的汉明距离是 4。这两个解（7 和 8）在搜索空间中是邻居，但当你看它们的二进制表示时，你会发现它们在所有
    4 位上都有差异。翻转最高位会导致解码值发生显著变化。在格雷码的情况下，格雷码表示 0100（十进制的 7）和 1100（十进制的 8）之间的汉明距离仅为
    1。这意味着这两个相邻解的格雷码表示只相差 1 位，提供了更平滑的搜索空间，并可能提高遗传算法的性能。
- en: '![](../Images/CH08_F01_UN01_Khamis.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH08_F01_UN01_Khamis.png)'
- en: Hamming distances for decimal number change from 0 to 15 for binary and Gray
    coding
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制和格雷码中十进制数从 0 到 15 的汉明距离
- en: Gray code representations provide better locality, meaning that small changes
    in the encoded value result in small changes in the decoded value. This property
    can improve the convergence of the GA by reducing the likelihood of disruptive
    changes during crossover and mutation operations. However, it is worth noting
    that the performance improvements offered by Gray coding are problem-dependent,
    and this representation method is not commonly used compared to binary-coded GA.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 格雷码表示提供了更好的局部性，这意味着编码值的小幅变化会导致解码值的小幅变化。这个性质可以通过减少交叉和变异操作期间破坏性变化的概率来提高遗传算法的收敛性。然而，值得注意的是，格雷码提供的性能改进是问题相关的，并且与二进制编码的遗传算法相比，这种表示方法并不常用。
- en: 8.2 Real-valued GA
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 实值遗传算法
- en: 'Real-valued GA is a variation on the standard GA that uses real numbers for
    encoding chromosomes instead of binary or Gray code representations. Many optimization
    problems involve continuous variables or real-valued parameters, such as curve
    fitting, function optimization with real-valued inputs, proportional integral
    derivative (PID) controller parameter tuning, or optimizing the weights of a neural
    network. To handle these continuous problems, it’s recommended that we use real-value
    GA directly for the following reasons:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实值遗传算法是标准遗传算法的一种变体，它使用实数来编码染色体，而不是二进制或灰度码表示。许多优化问题涉及连续变量或实值参数，例如曲线拟合、具有实值输入的函数优化、比例积分微分（PID）控制器参数调整或优化神经网络的权重。为了处理这些连续问题，建议我们直接使用实值遗传算法，以下是一些原因：
- en: '*Precision*—Real-valued GAs can achieve a higher level of precision in the
    search space than binary GAs. Binary encoding requires the discretization of the
    search space into a finite number of possible solutions, which can limit the accuracy
    of the search. Real-valued encoding, on the other hand, allows for a continuous
    search space, which can provide a more precise search.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精度*—实值遗传算法在搜索空间中可以达到比二进制遗传算法更高的精度水平。二进制编码需要将搜索空间离散化成有限数量的可能解决方案，这可能会限制搜索的准确性。另一方面，实值编码允许进行连续的搜索空间搜索，这可以提供更精确的搜索。'
- en: '*Efficiency*—Real-valued GAs can require fewer bits to encode a solution compared
    to binary GAs. For example, assume that the decision variable to be represented
    has a lower bound (*LB*) of 0 and an upper bound (*UB*) of 10, and we need to
    represent the solution with a precision (*P*) of 0.0001\. As explained in the
    previous chapter, the number of bits required to represent a range between *LB*
    and *UB* with a desired precision *P* is *number_of_bits* = ceil(log2(*UB* – *LB*)/*P*))
    = ceil(log2(ceil(10/0.0001))) = ceil(log2(100000)) = 17 bits. A real-valued encoding
    can use floating-point numbers with a smaller number of bits to represent a wider
    range of values than a binary encoding. This can result in a more efficient use
    of the available memory and computation resources.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*效率*—与二进制遗传算法相比，实值遗传算法可能需要更少的位来编码一个解决方案。例如，假设要表示的决策变量有一个下限（*LB*）为0和一个上限（*UB*）为10，并且我们需要用精度（*P*）为0.0001来表示解决方案。正如前一章所解释的，用所需的精度*P*表示*LB*和*UB*之间范围的位数是*number_of_bits*
    = ceil(log2(*UB* – *LB*)/*P*)) = ceil(log2(ceil(10/0.0001))) = ceil(log2(100000))
    = 17位。实值编码可以使用更少的位来表示比二进制编码更广泛的值。这可能导致更有效地使用可用的内存和计算资源。'
- en: '*Smoothness*—Real-valued GAs can maintain the continuity and smoothness of
    the search space, which can be important in some applications. In contrast, binary
    GAs can suffer from the Hamming cliff effect, as discussed in the previous section.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平滑性*—实值遗传算法可以保持搜索空间的连续性和平滑性，这在某些应用中可能很重要。相比之下，二进制遗传算法可能会受到前述章节中讨论的汉明悬崖效应的影响。'
- en: '*Adaptability*—Real-valued GAs can adapt more easily to changes in the search
    space or the fitness landscape. For example, if the fitness landscape changes
    abruptly, real-valued GAs can adjust the step size or mutation rate to explore
    the new landscape more effectively. Binary GAs, on the other hand, can require
    a more extensive redesign of the encoding or operator parameters to adapt to changes
    in the search space.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*适应性*—实值遗传算法可以更容易地适应搜索空间或适应度景观的变化。例如，如果适应度景观突然变化，实值遗传算法可以调整步长或变异率，以更有效地探索新的景观。另一方面，二进制遗传算法可能需要更广泛的编码或操作参数的重设计，以适应搜索空间的变化。'
- en: In the following subsections, we’ll look at the crossover and mutation methods
    used in real-valued GA.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将探讨实值遗传算法中使用的交叉和变异方法。
- en: 8.2.1 Crossover methods
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 交叉方法
- en: Some popular crossover methods for real-valued GAs are single arithmetic crossover,
    simple arithmetic crossover, and whole arithmetic crossover.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实值遗传算法中一些流行的交叉方法包括单算术交叉、简单算术交叉和整体算术交叉。
- en: Single arithmetic crossover
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单算术交叉
- en: 'The *single arithmetic crossover method* involves picking a gene (*k*) at random
    and generating a random weight *α*, which lies in the range [0, 1]. Genes with
    indices *i* before and after the crossover point (*i* < *k* or *i* > *k*) will
    inherit the genes from the corresponding parent chromosome. For genes at the crossover
    point (*i* = *k*), we create the offspring genes by taking a weighted average
    of the corresponding genes in the parent chromosomes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*单个算术交叉方法*涉及随机选择一个基因（*k*）并生成一个位于[0, 1]范围内的随机权重*α*。交叉点之前和之后的基因（*i* < *k*或*i*
    > *k*）将从相应的父染色体继承基因。对于交叉点的基因（*i* = *k*），我们通过取父染色体中相应基因的加权平均来创建后代基因：'
- en: '*Child*[1]*Gene[i]* = *α* × *Parent*[1]*Gene[i]* + (1 – *α*) × *Parent*[2]*Gene[i]*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*子代*[1]*基因[i]* = *α* × *父代*[1]*基因[i]* + (1 – *α*) × *父代*[2]*基因[i]*'
- en: '*Child*[2]*Gene[i]* = *α* × *Parent*[2]*Gene[i]* + (1 – *α*) × *Parent*[1]*Gene[i]*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*子代*[2]*基因[i]* = *α* × *父代*[2]*基因[i]* + (1 – *α*) × *父代*[1]*基因[i]*'
- en: Figure 8.2 illustrates the single arithmetic crossover in real-valued GA.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 展示了实值GA中的单个算术交叉。
- en: '![](../Images/CH08_F02_Khamis.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F02_Khamis.png)'
- en: Figure 8.2 Single arithmetic crossover in real-valued GA
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 实值GA中的单个算术交叉
- en: Simple arithmetic crossover
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简单算术交叉
- en: '*Simple arithmetic crossover* is similar to single arithmetic crossover. Before
    a randomly picked crossover point (*i* < *k*), the genes are inherited from the
    corresponding parent chromosome. After the crossover point (*i* >= *k*), we create
    the offspring genes by taking a weighted average of the corresponding genes in
    the parent chromosomes. Figure 8.3 illustrates the simple arithmetic crossover
    in real-valued GA.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单算术交叉*与单个算术交叉相似。在随机选择的交叉点（*i* < *k*）之前，基因从相应的父染色体继承。在交叉点（*i* >= *k*）之后，我们通过取父染色体中相应基因的加权平均来创建后代基因。图8.3展示了实值GA中的简单算术交叉。'
- en: '![](../Images/CH08_F03_Khamis.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F03_Khamis.png)'
- en: Figure 8.3 Simple arithmetic crossover in real-valued GA
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 实值GA中的简单算术交叉
- en: Whole arithmetic crossover
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 整体算术交叉
- en: In the *whole arithmetic crossover* method, we take a weighted average of the
    entire parent chromosomes to create the offspring. Figure 8.4 illustrates this
    method in real-valued GA.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*整体算术交叉*方法中，我们通过对整个父染色体进行加权平均来创建后代。图8.4展示了实值GA中的这种方法。
- en: '![](../Images/CH08_F04_Khamis.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Khamis.png)'
- en: Figure 8.4 Whole arithmetic crossover in real-valued GA
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 实值GA中的整体算术交叉
- en: Simulated binary crossover
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟二进制交叉
- en: '*Simulated binary crossover* (SBX) [1] is another crossover method in real-valued
    GA. In SBX, real values can be represented by a binary notation, and then the
    point crossovers can be performed. SBX is designed to generate offspring close
    to the parent chromosomes by creating a probability distribution function, thus
    maintaining a balance between exploration and exploitation in the search space.
    SBX is implemented in pymoo.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*模拟二进制交叉*（SBX）[1]是实值GA中另一种交叉方法。在SBX中，实值可以通过二进制表示，然后执行点交叉。SBX通过创建概率分布函数来生成接近父染色体的后代，从而在搜索空间中保持探索和利用之间的平衡。SBX在pymoo中实现。'
- en: 8.2.2 Mutation methods
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 变异方法
- en: 'The simplest way to mutate a continuous variable is to introduce small, random
    perturbations to the genes of an individual to maintain diversity in the population
    and help the search process escape from local optima. There are several common
    mutation methods used in real-valued GAs:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对连续变量进行变异的最简单方法是通过向个体的基因引入小的随机扰动来维持种群中的多样性，并帮助搜索过程逃离局部最优。实值GA中使用了多种常见的变异方法：
- en: '*Gaussian mutation*—Gaussian mutation adds a random value to the gene, where
    the random value is sampled from a Gaussian distribution with 0 mean and a specified
    standard deviation *σ*. The standard deviation controls the magnitude of the mutation
    (aka the *mutation step*).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高斯变异*——高斯变异向基因添加一个随机值，该随机值是从均值为0、指定标准差*σ*的高斯分布中抽取的。标准差控制变异的大小（也称为*变异步长*）。'
- en: '*Cauchy mutation*—Similar to Gaussian mutation, Cauchy mutation adds a random
    value to the gene, but the random value is sampled from a *Cauchy distribution*
    (aka a *Lorentz distribution* or *Cauchy–Lorentz distribution*) instead of a Gaussian
    distribution. The Cauchy distribution has heavier tails than the Gaussian distribution,
    leading to a higher probability of larger mutations.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Boundary mutation*—In boundary mutation, the mutated gene is randomly drawn
    from the uniform distribution within the variable’s range, defined by the lower
    bound (*LB*) and upper bound (*UB*). This method is analogous to the bit-flipping
    mutation in a binary-coded GA, and it helps explore the boundaries of the search
    space. It may be useful when optimal solutions are located near the variable limits.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Polynomial mutation*—Polynomial mutation is a method that generates offspring
    close to the parent by creating a probability distribution function [2]. A distribution
    index (*η*) controls the shape of the probability distribution function, with
    higher values resulting in offspring closer to their parents (exploitation) and
    lower values leading to offspring more spread out in the search space (exploration).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate these genetic operators, let’s consider a curve-fitting example.
    Assume we have the data points shown in table 8.2 and that we want to fit a third-order
    polynomial to these data points using real-valued GA.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.2 Curve-fitting problem data
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: 'The third-order polynomial takes the form *y* = *ax*³ + *bx*² + *cx* + *d*.
    A real-valued GA can be used to find the four coefficients of the polynomial:
    *a, b, c*, and *d*. This problem is treated as a minimization problem where the
    objective is to minimize the mean squared error (MSE) that measures how close
    a fitted polynomial is to given data points. MSE is calculated using the following
    formula:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F04_Khamis-EQ02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: '| 8.1 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: where *n* is the number of data points, *y* is the *y*-coordinate value of each
    data point, and *y*′ is the desired value that sits on the line we created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In real-valued GA, a candidate solution is represented by a vector of parameters
    *a, b, c*, and *d* that can be represented by real values. Let’s start with the
    following initial random solution: *Parent*[1] = [1 2 3 4]. We calculate its fitness
    by substituting these values in the function (*y* = *x*³ + 2*x*² + 3*x* + 4),
    calculating *y*′ for each corresponding *x* and calculating the MSE as in table
    8.3.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.3 MSE calculation for parent 1
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| *y*′ | 4 | 12.83 | 39.63 | 96.11 | 194 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| *Square* *of error* | 9 | 57.88 | 260 | 283.23 | 4 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| MSE | 122.83 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: 'Let’s generate another random solution: *Parent*[2] = [2 2 2 2], which gives
    the formula 2*x*³ + 2*x*² + 2*x* + 2 and the MSE in table 8.4.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.4 MSE calculation for parent 2
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '| x | 0 | 1.25 | 2.5 | 3.75 | 5 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| y | 1 | 5.22 | 23.5 | 79.28 | 196 |'
- en: '| *y*′ | 2 | 11.53 | 50.75 | 143.09 | 312 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| *y*′ | 2 | 11.53 | 50.75 | 143.09 | 312 |'
- en: '| *Square of* *error* | 1 | 39.83 | 742.56 | 4,072.2 | 13,456 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| *误差平方* | 1 | 39.83 | 742.56 | 4,072.2 | 13,456 |'
- en: '| MSE | 3,662.32 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| MSE | 3,662.32 |'
- en: 'Applying whole arithmetic crossover on the two parents *P*[1] = [1 2 3 4] and
    *P*[2] = [2 2 2 2] with weight *α* = 0.2 results in the following offspring:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个父代 *P*[1] = [1 2 3 4] 和 *P*[2] = [2 2 2 2] 应用整体算术交叉，权重 *α* = 0.2，得到以下子代：
- en: '![](../Images/CH08_F04_Khamis-EQ03.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Khamis-EQ03.png)'
- en: '![](../Images/CH08_F04_Khamis-EQ04.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Khamis-EQ04.png)'
- en: 'Let’s assume *Child*[1] is subject to Gaussian mutation. This mutation process
    results in another child as follows: *Child*[3] = *Child*[1] + *N*(0, *σ*), where
    *N*(0, *σ*) is a random number from a normal distribution with a mean of 0 and
    a standard deviation of *σ*. Assuming that *σ* = 1.2, a random value of 0.43 is
    generated by `numpy.random.normal(0, 1.2)`, *s*o *Child*[3] = [1.8 2 2.2 2.4]
    + 0.43 = [2.23 2.43 2.63 2.83].'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *Child*[1] 受高斯变异的影响。此变异过程导致另一个子代如下：*Child*[3] = *Child*[1] + *N*(0, *σ*)，其中
    *N*(0, *σ*) 是均值为 0、标准差为 *σ* 的正态分布中的随机数。假设 *σ* = 1.2，通过 `numpy.random.normal(0,
    1.2)` 生成了一个随机值 0.43，因此 *Child*[3] = [1.8 2 2.2 2.4] + 0.43 = [2.23 2.43 2.63 2.83]。
- en: Listing 8.1 shows how to perform this curve-fitting using real-valued GA implemented
    in pymoo. We’ll start by generating a dataset driven by a third-order polynomial,
    to be used later as a ground truth. Feel free to replace this synthetically generated
    data with any experimental data you may have.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 展示了如何使用 pymoo 中实现的实值 GA 执行此曲线拟合。我们将首先生成一个由三次多项式驱动的数据集，稍后将用作真实值。您可以自由地将这个合成的数据替换为您可能拥有的任何实验数据。
- en: Listing 8.1 Curve fitting using real-valued GA
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 使用实值 GA 进行曲线拟合
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Define coefficients for the third-order polynomial.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义三次多项式的系数。
- en: ② Generate five values as in the hand-iteration example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ② 生成五个值，如手迭代示例中所示。
- en: ③ Calculate y values using the third-order polynomial function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用三次多项式函数计算 y 值。
- en: ④ Combine x and y values into an array of data samples.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将 x 和 y 值组合成一个数据样本数组。
- en: 'As a continuation of listing 8.1, we can define a problem for curve fitting
    by subclassing pymoo’s `Problem` class, ensuring we pass the parameters to the
    superclass and provide an `_evaluate` function. The `CurveFittingProblem` class
    has an initializer method that sets the number of decision variables to 4, the
    number of objectives to 1, the number of constraints to 0, the lower bound of
    the decision variables to –10.0, and the upper bound of the decision variables
    to 10.0\. The `vtype` parameter specifies the data type of the decision variables,
    which is set to `float`. This initializer method creates an instance of the problem
    to be solved using the genetic algorithm. The `_evaluate` method takes as input
    a set of candidate solutions (`X`) and an output dictionary (`out`) and returns
    the fitness of each candidate solution in the `F` field of the `out` dictionary:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表 8.1 的延续，我们可以通过继承 pymoo 的 `Problem` 类来定义一个曲线拟合问题，确保我们传递参数给超类并提供一个 `_evaluate`
    函数。`CurveFittingProblem` 类有一个初始化方法，该方法将决策变量的数量设置为 4，目标数量的数量设置为 1，约束数量的数量设置为 0，决策变量的下限设置为
    –10.0，决策变量的上限设置为 10.0。`vtype` 参数指定决策变量的数据类型，设置为 `float`。此初始化方法创建了一个使用遗传算法解决的问题的实例。`_evaluate`
    方法接受一组候选解（`X`）和一个输出字典（`out`），并返回 `out` 字典中每个候选解的适应度 `F` 字段：
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Import the GA implementation for single-objective optimization in nonconvex
    scenarios.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入用于非凸场景单目标优化的 GA 实现。
- en: ② Import the simulated binary crossover (SBX) operator.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入模拟二进制交叉（SBX）算子。
- en: ③ Import the polynomial mutation operator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 导入多项式变异算子。
- en: ④ Import the rounding repair operator to ensure that the generated solutions
    remain within specified bounds.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 导入四舍五入修复算子以确保生成的解保持在指定的范围内。
- en: ⑤ Import the float random sampling operator to generate random initial solutions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 导入浮点随机采样算子以生成随机初始解。
- en: ⑥ Import the generic optimization problem class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 导入通用的优化问题类。
- en: ⑦ Import the minimize function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 导入最小化函数。
- en: ⑧ Define the optimization problem for curve fitting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 定义曲线拟合的优化问题。
- en: ⑨ Initialize the problem with four decision variables, ranging from –10.0 to
    10.0, and a single objective with no constraints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 使用四个决策变量初始化问题，范围从 –10.0 到 10.0，以及一个无约束的单目标。
- en: ⑩ Calculate the mean squared error for each set of coefficients in the input
    variable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 计算输入变量中每组系数的均方误差。
- en: Now we can instantiate the `CurveFittingProblem` class to create an instance
    of the problem to be solved. We can then define the genetic algorithm to be used
    for the optimization. The `GA` class is used to define the algorithm, and the
    `pop_size` parameter sets the population size to 50\. The `sampling` parameter
    uses the `FloatRandomSampling` operator to generate the initial population of
    candidate solutions randomly. The `crossover` parameter uses the `SBX` operator
    with a crossover probability of 0.8\. The `mutation` parameter uses the `PolynomialMutation`
    operator with a mutation probability of 0.3 and a rounding repair operator to
    ensure that the decision variables remain within the specified bounds. The `eliminate_duplicates`
    parameter is set to `True` to remove duplicate candidate solutions from the population.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实例化`CurveFittingProblem`类来创建要解决的问题的实例。然后我们可以定义用于优化的遗传算法。`GA`类用于定义算法，`pop_size`参数将种群大小设置为50。`sampling`参数使用`FloatRandomSampling`算子随机生成候选解的初始种群。`crossover`参数使用具有交叉概率0.8的`SBX`算子。`mutation`参数使用具有突变概率0.3和舍入修复算子的`PolynomialMutation`算子，以确保决策变量保持在指定的界限内。`eliminate_duplicates`参数设置为`True`以从种群中删除重复的候选解。
- en: 'Next, we can run the genetic algorithm to solve the curve fitting problem using
    the `minimize` function. This function takes three arguments: the instance of
    the problem to be solved (`problem`), the instance of the algorithm to be used
    (`algorithm`), and a tuple specifying the stopping criterion for the algorithm
    `(''n_gen'', 100)`, which specifies that the algorithm should run for 100 generations.
    The `seed` parameter is set to 1 to ensure the reproducibility of the results.
    The `verbose` parameter is set to `True` to display the progress of the algorithm
    during the optimization:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以运行遗传算法，使用`minimize`函数来解决曲线拟合问题。此函数接受三个参数：要解决的问题的实例（`problem`）、要使用的算法的实例（`algorithm`），以及指定算法停止标准的元组`('n_gen',
    100)`，表示算法应运行100代。`seed`参数设置为1以确保结果的再现性。`verbose`参数设置为`True`以在优化过程中显示算法的进度：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Initialize an instance of the CurveFittingProblem class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化`CurveFittingProblem`类的实例。
- en: ② Create a GA solver.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个GA求解器。
- en: ③ Perform the optimization for 100 generations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 对100代进行优化。
- en: 'You can print the four coefficients obtained by GA as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式打印GA获得的四个系数：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the estimated values of the four coefficients are same as the
    coefficients of the ground truth polynomial (a, b, c, d = 2, –3, 4, 1). You can
    experiment with the code by changing the polynomial coefficients, using your own
    data, and using different crossover and mutation methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，四个系数的估计值与真实多项式的系数（a, b, c, d = 2, –3, 4, 1）相同。您可以通过更改多项式系数、使用自己的数据和使用不同的交叉和突变方法来实验代码。
- en: Next, we’ll look at permutation-based GA.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨基于排列的遗传算法。
- en: 8.3 Permutation-based GA
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 基于排列的遗传算法
- en: Permutation-based GAs are designed to solve optimization problems where the
    solutions are permutations of a set of elements. Examples of such problems include
    the traveling salesman problem (TSP), vehicle routing problem, sports tournament
    scheduling, and job scheduling problem. In these problems, the solutions are represented
    as optimal orders or permutations of a set of elements or events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 基于排列的遗传算法旨在解决解决方案是一组元素排列的优化问题。这类问题的例子包括旅行商问题（TSP）、车辆路径问题、体育锦标赛调度和作业调度问题。在这些问题中，解决方案表示为一组元素或事件的最佳顺序或排列。
- en: 'There are typically two main types of problems where the goal is to determine
    the optimal order of events:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种主要类型的问题，其目标是确定事件的最佳顺序：
- en: '*Resource or time-constrained problems*—In these problems, the events rely
    on limited resources or time, making the order of events crucial for optimal solutions.
    One example of this type of problem is ride-sharing scheduling, where the goal
    is to efficiently allocate resources like vehicles and drivers to serve the maximum
    number of passengers in the shortest possible time.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源或时间限制问题*——在这些问题中，事件依赖于有限的资源或时间，这使得事件的顺序对于最佳解决方案至关重要。这类问题的一个例子是拼车调度，其目标是高效地分配车辆和司机等资源，以在尽可能短的时间内服务于最多的乘客。'
- en: '*Adjacency-based problems*—In these problems, the proximity or adjacency of
    elements plays a significant role in finding the best solution. An example of
    such a problem is the traveling salesman problem (TSP), where the aim is to visit
    a set of cities while minimizing the total travel distance, taking into account
    the distances between adjacent cities in the tour.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于邻接的问题*——在这些问题中，元素之间的邻近性或邻接性在寻找最佳解决方案中起着重要作用。这类问题的一个例子是旅行商问题（TSP），其目标是访问一组城市，同时最小化总旅行距离，并考虑巡游中相邻城市之间的距离。'
- en: These problems are often formulated as permutation problems. In a permutation
    representation, if there are *n* variables, the solution is a list of *n* distinct
    integers, each occurring exactly once. This representation ensures that the order
    or adjacency of the elements in the solution is explicitly encoded, which is essential
    for finding the optimal sequence of events in these types of problems. For example,
    let’s consider the following TSP for 8 cities. A candidate solution for this TSP
    is represented by a permutation such as [1, 2, 3, 4, 5, 6, 7, 8]. In permutation-based
    GA, specialized crossover and mutation operators are employed to preserve the
    constraints of the permutation problem, such as maintaining a valid sequence of
    cities in the TSP, where each city appears only once.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题通常被表述为排列问题。在排列表示中，如果有 *n* 个变量，解决方案是一个包含 *n* 个不同整数的列表，每个整数恰好出现一次。这种表示确保了解决方案中元素的顺序或邻接性被明确编码，这对于在这些类型的问题中找到最佳事件序列至关重要。例如，让我们考虑以下
    8 个城市的 TSP。该 TSP 的一个候选解决方案由排列表示，例如 [1, 2, 3, 4, 5, 6, 7, 8]。在基于排列的遗传算法中，使用专门的交叉和变异算子来保留排列问题的约束，例如在
    TSP 中保持城市的有效序列，其中每个城市只出现一次。
- en: The following subsections describe commonly used crossover and mutation methods
    in permutation-based GAs. The choice of crossover and mutation methods in GAs
    depends on the problem being solved, the type of solutions being sought, and the
    objectives of the optimization problem. By carefully selecting and designing these
    operators, GAs can effectively explore and exploit the search space to find high-quality
    solutions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节描述了基于排列的遗传算法中常用的交叉和变异方法。遗传算法中交叉和变异方法的选择取决于要解决的问题、所寻求的解决方案类型以及优化问题的目标。通过仔细选择和设计这些算子，遗传算法可以有效地探索和利用搜索空间以找到高质量的解决方案。
- en: 8.3.1 Crossover methods
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 交叉方法
- en: Several crossover methods are commonly used in permutation-based GAs, such as
    partially mapped crossover (PMX), edge crossover (EC), order 1 crossover (OX1),
    and cycle crossover (CX).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于排列的遗传算法中，常用的交叉方法包括部分映射交叉（PMX）、边交叉（EC）、顺序 1 交叉（OX1）和循环交叉（CX）。
- en: Partially mapped crossover
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 部分映射交叉
- en: The *partially mapped crossover* (PMX) method creates offspring by combining
    the genetic information from two parent chromosomes while preserving the feasibility
    of the resulting offspring with the procedure shown in algorithm 8.1.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*部分映射交叉*（PMX）方法通过结合两个父代染色体的遗传信息来创建后代，同时通过算法 8.1 中所示的程序保持后代的可行性。'
- en: Algorithm 8.1 Partially mapped crossover (PMX)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 8.1 部分映射交叉（PMX）
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Figure 8.5 illustrates these steps for an 8-city TSP. In step 1, two random
    crossover points are chosen, and the cities between these two points are copied
    from parent P1 to child C1 and from the second parent P2 to the second child C2\.
    Then we follow steps 2 to 5 for the cities that were not included in step 1\.
    For the first city in C1, which is 3, we need to find the corresponding city in
    the P2 segment, which is 7\. City 7 is not already included in C1, so we need
    to place city 7 in the place where city 3 appears in P2, which is the last position
    on the right, as shown by the solid black arrow in figure 8.5.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 展示了 8 个城市的 TSP 问题中的这些步骤。在第 1 步中，选择两个随机的交叉点，并将这两个点之间的城市从父代 P1 复制到子代 C1，从第二个父代
    P2 复制到第二个子代 C2。然后我们对第 1 步中没有包含的城市执行步骤 2 到 5。对于 C1 中的第一个城市，即 3，我们需要找到 P2 段中对应的城市，即
    7。城市 7 已经不在 C1 中，因此我们需要将城市 7 放在 P2 中城市 3 出现的位置，即右侧的最后位置，如图 8.5 中的实心黑色箭头所示。
- en: '![](../Images/CH08_F05_Khamis.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F05_Khamis.png)'
- en: Figure 8.5 Partially mapped crossover (PMX)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 部分映射交叉（PMX）
- en: The following listing shows code that performs a partially mapped crossover
    on two parents to generate two offspring.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了执行部分映射交叉以生成两个后代的代码。
- en: Listing 8.2 Partially mapped crossover (PMX)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 部分映射交叉（PMX）
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Select two random crossover points.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ① 选择两个随机的交叉点。
- en: ② Copy the segment between crossover points from a parent to a child.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: ③ Map the remaining elements from the other parent.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: ④ Return the generated offspring.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Running this code will produce output like that shown in figure 8.6, depending
    on the generated random sample.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F06_Khamis.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 PMX results
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of listing 8.2 is available in the book’s GitHub repository.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Edge crossover
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The *edge crossover* (EC) method preserves the connectivity and adjacency information
    between elements from the parent chromosomes. In order to achieve this, an *edge
    table* (or *adjacency list*) is constructed. For example, in the 8-cities TSP,
    the edge table for two parents P1 = [1, 2, 3, 4, 5, 6, 7, 8] and P2 = [1, 6, 7,
    8, 5, 2, 4, 3] is created by counting the adjacent elements in both parents, as
    in table 8.5\. The “+” signs in the table denote a common edge between the two
    parents.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.5 An edge table (or adjacency list)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '| City | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| Edges | 2,8,6,3 | 1,3,5,4 | 2,4+,1 | 3+,5,2 | 4,6,8,2 | 5,7+,1 | 6+,8+ |
    7+,1,5 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: Algorithm 8.2 shows the steps involved in edge crossover.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 8.2 Edge crossover (EC)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Figure 8.7 illustrates these steps for the 8-cities TSP. This figure illustrates
    how to construct the edge table or adjacency list of each city. The process of
    counting the edges is shown in this figure. For example, cities 3 and 5 are adjacent
    cities or edges to city 4 in the first parent. In the second parent, cities 2
    and 3 are edges for city 4\. This means that city 3 is a common edge.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Creating a child starts by selecting city 1 randomly or as a home city. In the
    second row of the table, we list the adjacent cities of city 1, which are 2, 8,
    6 and 3\. Note that cities loop around, meaning city 1 is adjacent to city 8 in
    the first parent, and city 1 is adjacent to city 3 in the second parent. Discarding
    the already visited city 1, these cities have the following adjacent cities {3,5,4}
    for city 2, {7,5} for city 8, {5,7} for city 6, and {2,4} for city 3\. We discard
    city 2, as it has three adjacent cities, and we select city 3 arbitrarily from
    8, 6, and 3, as they have the same number of edges. We keep adding cities to the
    child following algorithm 8.2 until all the cities are added.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F07_Khamis.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 Edge crossover
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of listing 8.2 is available in the book’s GitHub repository.
    It shows the Python implementation of edge crossover with a TSP example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Order 1 crossover
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '*Order 1 crossover* (OX1) creates offspring by combining the genetic information
    from two parent chromosomes while preserving the relative order of the elements
    in the resulting solutions. Algorithm 8.3 shows the steps involved in order 1
    crossover.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 8.3 Order 1 crossover (OX1)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Figure 8.8 illustrates these steps for the 8-cities TSP. Starting from the second
    crossover point, cities 4 and 3 cannot be added, as they are already included
    in C1\. The next element in P2 is city 1, so it is added to C1 after the second
    crossover point, followed by city 7, as city 6 is already included. City 8 is
    added next, followed by city 2, as city 5 is already included in C1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F08_Khamis.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 Order 1 crossover (OX1)—The numbers in circles show the sequence
    in which elements are added from parent 2 to child 1.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of listing 8.2 is available in the book’s GitHub repository,
    and it shows the Python implementation of OX1 with the TSP example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Cycle crossover
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*Cycle crossover* (CX) operates by dividing the elements into cycles, where
    a *cycle* is a subset of elements that consistently appear together in pairs when
    the two parent chromosomes are aligned. Given two parents, a cycle is formed by
    selecting an element from the first parent, finding its corresponding position
    in the second parent, and then repeating this process with the element at that
    position until returning to the starting element. The CX operator effectively
    combines the genetic information from both parents while preserving the order
    and adjacency relationships among the elements in the resulting offspring and
    maintaining the feasibility and diversity of the offspring solutions. Algorithm
    8.4 shows the steps of this crossover method.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 8.4 Cycle crossover (CX)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 8.9 illustrates these steps for the 10-cities TSP.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F09_Khamis.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 Cycle crossover (CX)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: A Python implementation of CX with a TSP example is included in the complete
    version of listing 8.2, available in the book’s GitHub repository. It’s important
    to note that the performance of crossover operators is often problem-dependent
    and may also be influenced by the specific parameter settings of the genetic algorithm,
    such as population size, mutation rate, and selection pressure. Therefore, it
    is recommended that you experiment with different crossover operators and fine-tune
    the genetic algorithm’s parameters to suit the problem being addressed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 Mutation methods
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Insert, swap, inversion, and scramble are commonly used mutation methods in
    permutation-based GA. These methods are designed to introduce small perturbations
    to the solution while still preserving its feasibility:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '*Insert mutation*—Pick two gene values at random, and move the second to follow
    the first, shifting the rest along to accommodate them. This method primarily
    maintains the order and adjacency information of the genes.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Swap mutation*—Pick two genes at random, and swap their positions. This method
    mainly retains adjacency information while causing some disruption to the original
    order.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inversion mutation*—Randomly select two genes, and invert the substring between
    them. This method largely maintains adjacency information but is disruptive to
    the order information.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scramble mutation*—Randomly select two gene values, and rearrange the genes
    between the chosen positions non-contiguously, applying a random order.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 8.10 illustrates these methods on the first parent as a selected individual
    in the 8-cities TSP.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F10_Khamis.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 Mutation methods in permutation-based GA
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation of listing 8.2, the following code snippet shows how you
    can implement inversion mutation in Python:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running this code will produce output like that in figure 8.11.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F11_Khamis.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 Inversion mutation result
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of listing 8.2, available in the book’s GitHub repository,
    includes implementations of different crossover and mutation methods commonly
    used in permutation-based genetic algorithms.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Multi-objective optimization
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in section 1.3.2, optimization problems with multiple objective
    functions are known as multi-objective optimization problems (MOPs). These problems
    can be handled using a preference-based multi-objective optimization procedure
    or by using a Pareto optimization approach. In the former approach, the multiple
    objectives are combined into a single or overall objective function by using a
    relative preference vector or a weighting scheme to scalarize the multiple objectives.
    However, finding this preference vector or weight is subjective and sometimes
    is not straightforward.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '*Pareto optimization*, named after Italian economist and sociologist Vilfredo
    Pareto (1848–1923), relies on finding multiple trade-off optimal solutions and
    choosing one using higher-level information. This procedure tries to find the
    best trade-off by reducing the number of alternatives to an optimal set of nondominated
    solutions known as the Pareto front (or Pareto frontier), which can be used to
    make strategic decisions in multi-objective space. A solution is Pareto optimal
    if there is no other solution that improves one objective without worsening another
    objective, in the case of conflicting objective functions. Thus, the optimal solution
    for MOPs is not a single solution, as for mono-objective or single optimization
    problems (SOPs), but a set of solutions defined as *Pareto optimal solutions*.
    These Pareto optimal solutions are also known as acceptable, efficient, nondominated,
    or non-inferior solutions. *Nondominated solutions* in Pareto optimization represent
    the best compromises that are not outperformed by any other solution across multiple
    conflicting objectives.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'In chapter 1, we looked at an electric vehicles example: acceleration time
    and driving range are conflicting objective functions, as we need to minimize
    the acceleration time and maximize the driving range of the vehicle. There is
    no universal best vehicle that achieves both, as shown in figure 8.12, which is
    based on real data retrieved from the *Inside EVs* website ([https://insideevs.com/](https://insideevs.com/)).
    For example, the Lucid Air Dream Edition has the highest driving range but not
    the lowest acceleration time. The dotted line shows the Pareto front—the vehicles
    that achieve the best trade-off between the acceleration time and the driving
    range.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F12_Khamis.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 Acceleration time vs. driving range of 19 electric vehicles, as
    per September 2021
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Multi-objective optimization algorithms
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: There are several algorithms for solving multi-objective optimization problems.
    The nondominated sorting genetic algorithm (NSGA-II) is one of the most commonly
    used. Other algorithms include, but are not limited to, the strength Pareto evolutionary
    algorithm 2 (SPEA2), the Pareto-archived evolution strategy (PAES), the niched-Pareto
    genetic algorithm (NPGA), multi-objective selection based on dominated hypervolume
    (SMS-EMOA), and multi-objective evolutionary algorithm based on decomposition
    (MOEA/D).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: These algorithms have their own strengths and weaknesses, and your choice of
    algorithm will depend on the specific problem being solved and your preferences.
    NSGA-II has several advantages, such as diversity maintenance, non-dominated sorting,
    and fast convergence. For more details about multi-objective optimization, see
    Deb’s “Multi-objective optimization using evolutionary algorithms” [3] and Zitzler’s
    “Evolutionary algorithms for multiobjective optimization” [4].
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s solve a MOP using NSGA-II in an example. Assume that a manufacturer produces
    two products, P1 and P2, involving two different machines, M1 and M2\. Each machine
    can only produce one product at a time, and each product has a different production
    time and cost on each machine:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: P1 requires 2 hours on M1 and 3 hours on M2, with production costs of $100 and
    $150 respectively.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P2 requires 4 hours on M1 and 1 hour on M2, with production costs of $200 and
    $50 respectively.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each shift, the two machines, M1 and M2, have the capacity of producing 100
    units of P1 and 500 units of P2\. The manufacturer wants to produce at least 80
    units of P1 and 300 units of P2 while minimizing production costs and minimizing
    the difference in production times between the two machines.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll let *x*[1] and *x*[2] be the number of units of P1 produced on M1 and
    M2, respectively, and *y*[1] and *y*[2] be the number of units of P2 produced
    on M1 and M2, respectively. The problem can be formulated as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F12_Khamis-EQ05.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: 'Subject to:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F12_Khamis-EQ06.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: The first objective function (*f*[1]) represents the total production costs,
    and the second objective function (*f*[2]) represents the difference in production
    times between the two machines. Listing 8.3 shows the code for finding the optimal
    number of units to be produced in a shift using NSGA-II.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by inheriting from `ElementwiseProblem`, which allows us to define
    the optimization problem in an element-wise manner. `n_var` specifies the number
    of variables (4 in this case), `n_obj` defines the number of objectives (2), and
    `n_ieq_constr` indicates the number of inequality constraints (2). The `xl` and
    `xu` parameters define the lower and upper bounds for each variable respectively.
    The `_evaluate` method takes an input `x` (a solution candidate) and computes
    the objective values `f1` and `f2`, as well as the inequality constraints `g1`
    and `g2`. The third constraint is boundary constraint represented by the lower
    and upper bounds of the decision variables.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.3 Solving a manufacturing problem using NSGA-II
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Import an instance of the problem class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the number of variables, objective functions, constraints, and lower
    and upper bounds.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: ③ Total production costs as a first-objective function
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: ④ Difference in production times between the two machines as a second-objective
    function
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Define the constraints.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now set up an instance of the NSGA-II algorithm as the solver:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Import the NSGA-II class.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: ② Import simulated binary crossover (SBX) as a crossover operator.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: ③ Import polynomial mutation (PM) as a mutation operator.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: ④ Import the FloatRandomSampling method to generate random floating-point values
    for each variable within a specified range.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set up an instance of NSGA-II.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The solver has a population size (`pop_size`) of 40 individuals, generates 10
    offspring using `FloatRandomSampling`, employs SBX crossover with a probability
    of 0.9, and fine-tunes the exponential distribution with an `eta` parameter of
    15\. PM mutation is used with an `eta` parameter of 20\. This `eta` parameter
    controls the spread of the mutation distribution. `eliminate_duplicates` is set
    to `True` so that duplicate candidate solutions will be removed from the population
    at each generation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the termination criterion by specifying the number of generations
    as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now run the solver to minimize both objective functions simultaneously:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we print the best 10 solutions as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code will produce output representing the best 10 non-dominated solutions
    obtained by NSGA-II and will look like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As there is no universal best solution for these two objective functions, multi-criteria
    decision-making can be applied to select the best trade-off—the Pareto optimal.
    In pymoo, the decision-making procedure starts by defining boundary points called
    *ideal* and *nadir* points:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '*The ideal point*—This refers to the best possible values for each objective
    function that can be achieved in the entire feasible region of the problem. This
    point represents the scenario where all the objective functions are minimized
    simultaneously.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The nadir point*—This is the point where each objective function is maximized
    while satisfying all the constraints of the problem. It is the opposite of the
    ideal point and represents the worst possible values for each objective function
    in the entire feasible region of the problem.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These points are used in multi-objective optimization problems to normalize
    the objective functions and convert them to a common scale, allowing for a fair
    comparison of different solutions. The two points are calculated as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then define weights, which are required by the decomposition functions,
    based on the level of importance of each objective function from the developer’s
    perspective:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Weights for f1 and f2 respectively
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'A decomposition method is defined using the augmented scalarization function
    (ASF), discussed in Wierzbicki’s “The use of reference objectives in multiobjective
    optimization” [5]:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To find the best solutions, we choose the minimum ASF values calculated from
    all the solutions and use the inverse of the weights as required by ASF:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output is shown in figure 8.13.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F13_Khamis.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 Manufacturing problem solution—the point marked with the X represents
    the selected Pareto optimal or best trade-off.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code produces the following output:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The complete version of listing 8.3 is available in the book’s GitHub repository.
    It includes another method using pseudo-weights to choose a solution from a solution
    set in the context of multi-objective optimization.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Adaptive GA
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adaptation methods help genetic algorithms strike a balance between exploration
    and exploitation, using different parameters such as initialization population
    size, crossover operators, and mutation operators. These parameters can be deterministically
    or dynamically adapted based on the search progress, allowing the algorithm to
    converge on high-quality solutions for complex optimization problems.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: For example, population size can be adaptive. A larger population size promotes
    diversity and exploration, while a smaller size allows for faster convergence.
    The population size can be increased if the algorithm is struggling to find better
    solutions or decreased if the population has become too diverse.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutation operator parameters can be used to adapt the genetic algorithm and
    balance its exploration and exploitation aspects. For example, in the case of
    Gaussian mutation, we can adaptively set the value of the standard deviation *σ*
    of the Gaussian distribution during the run. The standard deviation of the Gaussian
    distribution can be changed following a deterministic approach, an adaptive approach,
    or a self-adaptive approach. If you’re using a deterministic approach, the value
    of *σ* can be calculated in each generation using this formula: *σ*(*i*) = 1 –
    0.9 * *i*/ *N* where *i* is the generation number, ranging from 0 to *N* (the
    maximum generation number). In this case, the value of *σ* is 1 at the beginning
    of the optimization process and gradually reduces to 0.1 toward the end to move
    the search algorithm’s behavior from exploration to exploitation.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The adaptive approach incorporates feedback from the search process to adjust
    the variance and improve the search performance. Rechenberg’s *1/5 success rule*
    is a well-known method that adjusts the step size of the search by monitoring
    the success rate of the search. This rule involves increasing the variance if
    a certain percentage of the previous mutations were successful in finding better
    solutions (i.e., if there was more than one successful mutation out of five tries),
    favoring exploration in order to avoid getting trapped in local optima. Otherwise,
    if there was a lower success rate, the variance should be decreased to favor exploitation.
    This allows the search to fine-tune its parameters based on its progress, leading
    to better performance and faster convergence to optimal solutions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 shows the steps of applying Rechenberg’s 1/5 success rule. This
    update rule is applied in every generation, and a constant 0.82 <= *c* <= 1 is
    used to update the standard deviation of the Gaussian distribution. As you can
    see, the higher the standard deviation, the higher the value of *x*, and the higher
    the deviation from the current solution (more exploration), and vice versa.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F14_Khamis.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 Rechenberg’s 1/5 success rule. Following this rule, the Gaussian
    distribution’s standard deviation is updated by a constant. The higher the standard
    deviation, the higher the value of *x* (i.e., larger step size), the higher the
    deviation from the current solution (more exploration), and vice versa.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'The self-adaptive approach incorporates the mutation step size into each individual—a
    technique originally employed in evolution strategies (ES). In this method, the
    value of *σ* (the standard deviation or the mutation step size) evolves alongside
    the individual, resulting in distinct mutation step sizes for each individual
    in the population. The following equations are used in this self-adaptive approach:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F14_Khamis-EQ07.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: '| 8.2 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F14_Khamis-EQ08.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: '| 8.3 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: where *τ[o]* is the learning rate.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a solid understanding of the various components of GAs, we
    can apply this powerful optimization technique to real-world problems. In the
    following sections, we will use GAs to solve three distinct problems: the traveling
    salesman problem, tuning the parameters of a PID controller, and the political
    districting problem.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Solving the traveling salesman problem
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s consider the following traveling salesman problem (TSP) for 20 major cities
    in the USA, starting from New York City, as illustrated in figure 8.15.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F15_Khamis.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 The 20 major US cities TSP
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In listing 8.4, we start by importing the libraries we’ll use and defining the
    TSP. First, we define the city names and their latitudes and longitudes. We then
    use those coordinates to create a haversine distance matrix and then convert the
    data dictionary into a dataframe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.4 Solving TSP using GA
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Define city names, latitudes, and longitudes for 20 major US cities.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a haversine distance matrix based on latitude-longitude coordinates.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: ③ Convert the distance dictionary into a dataframe.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a networkx graph.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create `TravelingSalesman` as a subclass of the `ElementwiseProblem`
    class available in pymoo. This class defines the number of cities and the intercity
    distances as problem parameters, and it evaluates the total path length as an
    objective function to be minimized:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following function is a subclass of the `Repair` class, and it provides
    a method to repair solutions for the TSP, ensuring that each solution starts with
    the city indexed as 0 (New York City, in this example). The repair operator in
    pymoo is used to make sure the algorithm is only searching the feasible space.
    It is applied after the offspring have been reproduced:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It’s time now to define a GA solver and apply it to solve the problem.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Create a TSP instance for the given cities and intercity distances.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the GA solver.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: ③ Terminate (and disable the max generations) if the algorithm did not improve
    in the last 300 generations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: ④ Find the shortest path.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'We can print the found route and its length as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in the following output:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code is used to visualize the obtained route using NetworkX:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① Create an independent shallow copy of the problem graph and attributes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: ② Reverse latitude and longitude for correct visualization.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create a list of keys in the original dictionary.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a new dictionary with the keys in the desired order.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Create an edge list.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Draw the closest edges on each node only.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Draw and show the route.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 shows the obtained route for this traveling salesman problem.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F16_Khamis.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 The 20 major US cities TSP solution
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with the full code in the book’s GitHub repository by changing
    the problem data and the genetic algorithm parameters, such as population size,
    sampling, crossover, and mutation methods.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 PID tuning problem
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever wondered how your room stays at a comfortable temperature? Have
    you ever thought about how the heating or cooling system knows when to turn on
    and off automatically to maintain the temperature set on the thermostat? This
    is where control systems come into the picture. Control systems are like behind-the-scenes
    wizards that ensure things work smoothly and efficiently. They are sets of rules
    and mechanisms that guide devices or processes to achieve specific goals.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'One type of control system is a *closed-loop system*. Picture this: you’ve
    set your room’s thermostat to a cozy 22°C (72°F), and the heating or cooling system
    kicks in to reach that temperature. But what happens if it becomes too chilly
    or too warm? That’s when the closed-loop system starts to take action. It’s continually
    tracking the room’s current temperature, comparing it to the desired temperature,
    and making the necessary heating or cooling tweaks.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The proportional integral derivative (PID) controller is the most commonly used
    algorithm in control systems engineering. This controller is designed to compensate
    for any error between the measured state (e.g., the current room temperature)
    and the desired state (e.g., the desired temperature value). Let’s consider room
    temperature control using a PID controller as an example.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in figure 8.17, the controller takes the error signal *e*(*t*) (the
    difference between the desired state and the feedback signal) and produces the
    appropriate control signal *u*(*t*) to turn on or off the heater in order to minimize
    the difference between the current room temperature and the desired value. The
    control signal is calculated using equation 8.4:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F16_Khamis-EQ09.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: '| 8.4 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: As shown in this equation, the *proportional term* *K[p]e*(*t*) tends to produce
    a control signal that is proportional to the error and aims to rectify it. The
    *integral term* (the second term on the right side of the equation) tends to produce
    a control signal that is proportional to the magnitude of the error and its duration,
    or the area under the error curve. The *derivative term* (the third term on the
    right side of the equation) tends to produce a control signal that is proportional
    to the rate of error change, thus providing an anticipatory control signal.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F17_Khamis.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 PID-based closed-loop control system—the PID controller takes the
    error signal and produces a control signal to reduce the error to zero.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing a PID controller allows the system (e.g., an air conditioner or heater)
    to follow the specified input and attain a desired or optimal steady-state error,
    rise time, settling time, and overshoot:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '*Rise time*—The rise time is the time required for the response to rise from
    10% to 90% of its final value.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Peak overshoot*—The peak overshoot (aka maximum overshoot) is the deviation
    of the response at peak time from the final value of the response.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Settling time*—The settling time is the time required for the response to
    reach the steady state and stay within the specified tolerance bands (e.g., 2–5%
    of the final value) after the transient response has settled.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Steady-state error*—The steady-state error is the difference between the desired
    value and the actual value of the system output when the system has reached a
    stable condition.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As shown in figure 8.18, the heater is turned on (i.e., energized) when the
    current room temperature is lower than the set point or the desired value. The
    heater is turned off (i.e., de-energized) when the temperature is above the set
    point.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F18_new_Khamis.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 Step response of a system. The heater is turned on or off according
    to the difference between the actual temperature and the desired value.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.6 shows the effect of PID controller parameters on the time response
    of the system. Note that these correlations may not be exactly accurate, because
    *K[p], K[i]*, and *K[d]* are dependent on each other. In fact, changing one of
    these variables can change the effect of the other two. For this reason, the table
    should only be used as a reference when you are determining the values for *K[p],
    K[i]*, and *K[d]*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.6 Effects of adding PID controller parameters on the system’s response
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Rise time | Overshoot | Settling time | Steady-state error |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| K[p] | Decreases | Increases | Small change | Decreases |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| K[i] | Decreases | Increases | Increases | Decreases significantly |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| K[d] | Small change | Decreases | Decreases | Small change |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: 'Finding the optimal values of the PID controller parameters for an optimal
    controller response is a multivariate optimization problem commonly referred to
    as the *PID tuning problem*. The following four performance metrics are commonly
    used to evaluate the quality of a control system such as a PID controller:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '*ITAE (integral time absolute error)*—This metric penalizes errors that persist
    over time, making it suitable for systems where transient response and settling
    time are important. It is calculated using this formula: ITAE = ∫(*t*|*e*(*t*)|)
    *dt*, where *t* is the time, *e*(*t*) is the error at time *t* defined as *e*(*t*)
    = *r*(*t*) – *y*(*t*), *r*(*t*) is the reference signal (desired output) at time
    *t* (for step response *r*(*t*) = 1), and *y*(*t*) is the actual output of the
    system at time *t*.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ITSE (integral time square error)*—Like ITAE, this metric also penalizes errors
    that last for a long time but places more emphasis on larger errors due to the
    squared term. It is calculated using this formula: ITSE = ∫(*te*(*t*)²) *dt*.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IAE (integral absolute error)*—This metric measures the overall magnitude
    of the error without considering the duration of the error. This is a simple and
    widely used performance metric, and it’s calculated using this formula: IAE =
    ∫|*e*(*t*)| *dt*.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ISE (integral squared error)*—This metric emphasizes larger errors due to
    the squared term, making it useful for systems where minimizing large errors is
    a priority. It is calculated using this formula: ISE = ∫*e*(*t*)² *dt*. It penalizes
    errors more heavily if they occur later in the evolution of the response. It also
    penalizes an error *E* for time *dt* more heavily than *E*/*α* for time *αdt*,
    where *α* > 1. This expected response may have a slow rise time but with a more
    oscillatory behavior.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Combined criteria*—This metric combines overshoot, rise time, settling time,
    and steady-state error [6]. It is calculated using this formula: *W* = (1 – *e*^–*^β*)(*M[p]*
    + error*[ss]*) + *e*^–*^β* (*t[s]* – *t[r]*), where *M*[p] is the overshoot, error[ss]
    is the steady-state error, *t[s]* is the settling time, *t[r]* is the rise time,
    and *β* is a balancing factor in the range of 0.8 to 1.5\. You can set *β* to
    be larger than 0.7 to reduce the overshoot and steady-state error. On the other
    hand, you can set *β* to be smaller than 0.7 to reduce the rise time and settling
    time.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these metrics quantifies the error between the desired output and the
    actual output of the system in different ways, emphasizing different aspects of
    the control system’s performance. Note that performance metrics are not strictly
    confined to the aforementioned metrics. Engineers have the flexibility to devise
    custom performance metrics tailored to the specific goals and characteristics
    of the control system under consideration.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 shows a closed-loop control system where a transfer function is
    used to describe the relationship between the input and output of the system in
    a Laplace domain. This domain is a generalization of a frequency domain, providing
    a more comprehensive representation that includes transient behavior and initial
    conditions. Assume that *T[sp]* is the set point or the desired output and *G*
    represents the transfer functions indicated in the block diagram.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F19_Khamis.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 Closed-loop control system
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'All variables are a function of *s*, which is the output variable from a Laplace
    transform. The transfer function of a PID controller is given by this equation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F19_Khamis-EQ10.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: '| 8.5 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: 'where *K[p]* is the proportional gain, *K[i]* is the integral gain, and *K[d]*
    is the derivative gain. Assume that the transfer function of the HVAC system is
    given by this equation:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F19_Khamis-EQ11.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: '| 8.6 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: 'Assuming that *G[s]* = 1 (unity feedback) and using block diagram reduction,
    we can find the overall transfer function *T*(*s*) of the closed loop system:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F19_Khamis-EQ12.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: '| 8.7 |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: Let’s now look at how we can find the optimal values for the PID parameters
    with Python. In the next listing, we start by importing the libraries we’ll use
    and defining the overall transfer function of the control system.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.5 Solving the PID tuning problem using GA
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① Import the control module.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: ② Take PID parameters as input.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define the numerator of the transfer function.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the denominator of the transfer function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Create a transfer function.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Get time response output using a step function as a system input.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can define the objective functions or performance criteria:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① ITAE (integral time absolute error)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: ② ITSE (integral time square error)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: ③ IAE (integral absolute error)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: ④ ISE (integral squared error)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ W (combined criteria)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now define the optimization problem for the PID controller:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① Three decision variables, representing the PID controller’s Kp, Ki, and Kd
    gains
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: ② Number of objective functions
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: ③ No constraints
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: ④ Lower and upper bounds for the decision variables
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Evaluate the objective function.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can set up and solve the PID tuning problem using GA. The previously
    defined `PIDProblem` class is used to model the optimization problem. The GA solver
    is configured with a population size of 50\. Initial solutions are sampled using
    `FloatRandomSampling`, and the crossover operation employs a two-point crossover
    with a probability of 0.8\. Additionally, polynomial mutation is applied with
    a probability of 0.3, and the algorithm runs for 60 generations:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s now print the results:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And we’ll visualize the time response:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Figure 8.20 depicts the step response of the system, demonstrating how its outputs
    change over time when the inputs swiftly transition from 0 to 1.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F20_Khamis.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 Step response
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the step response characteristics (rise time, settling time, peak,
    and others), you can use the following function:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This results in the following output:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can experiment with adjusting the algorithm’s parameters (such as population
    size, crossover method and probability, mutation method and probability, number
    of generations, etc.) and altering the performance metric to observe the effects
    on the system’s performance.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Political districting problem
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I introduced political districting in section 2.1.5—it can be defined as the
    process of grouping *n* subregions within a territory into *m* electoral districts
    while adhering to certain constraints. Suppose we need to merge *n* neighborhoods
    in the City of Toronto into *m* electoral districts while ensuring a sufficient
    level of population equality. Figure 8.21 shows a sample dataset that contains
    population and median household income for 16 neighborhoods in East Toronto.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F21_Khamis.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 The 16 neighborhoods in East Toronto with their population and median
    household income
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'In addressing the political districting problem, a viable solution must ensure
    that there is a satisfactory degree of population equilibrium (i.e., a fair and
    balanced distribution) in every electoral district. For example, we can evaluate
    a district’s population balance by calculating the deviation from an ideal population
    size within an upper bound (pop[UB]) and lower bound (pop[LB]) as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F21_Khamis-EQ13.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: where *pop[av]* represents the target population size that can be considered
    the average of all the neighborhoods and *pop[margin]* indicates the acceptable
    degree of deviation from the ideal population size. *n* is the number of the neighborhoods,
    and *m* is the number of districts.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: A district will be regarded as overpopulated if its total population exceeds
    the upper bound, and conversely, a district will be deemed underpopulated if its
    total population falls below the lower bound. A district whose population falls
    within the upper and lower bounds will be regarded as having an appropriate population
    size. The objective function is to minimize the total number of overpopulated
    and underpopulated districts. The search process will persist until the objective
    function’s minimum value is obtained, ideally zero. This indicates that no districts
    are either overpopulated or underpopulated.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: The next listing shows how to find the political districts using GA. We’ll start
    by reading the data from a local folder or using a URL.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.6 Solving a political districting problem using GA
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① URL for the data folder
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: ② Read the Toronto region administration boundaries.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: ③ Read the neighborhood information (e.g., names, populations, and median household
    incomes).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: ④ Pick 16 neighborhoods as a subset to represent neighborhoods in East Toronto.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: After reading the dataset, we’ll do the following data preprocessing to get
    the population of each neighborhood, and the adjacency relationship among every
    possible pair of neighborhoods, in a Boolean matrix.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① Get the population of each neighborhood.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: ② Prepare the population dataset.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: ③ Represent the adjacency relationship among every possible pair of neighborhoods.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now define the political districting class with a single objective function,
    three constraints, a given number of districts, a given population margin, and
    an adjacency matrix between the neighborhoods. `PoliticalDistricting` is a custom
    problem class that extends the `Problem` class from pymoo. The `Problem` class
    implements a method that evaluates a set of solutions instead of a single solution
    at a time, like in the case of the `ElementwiseProblem` class. In the `PoliticalDistricting`
    class, the following parameters are defined:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '`num_dist`—The number of districts to divide the region into'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neighbor`—A matrix representing the neighborhood relationships between locations
    in the region'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`populations`—The population of each neighborhood'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`margin`—The acceptable degree of deviation from the ideal population size'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`average`—The average population'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_var`—The number of decision variables, which is equal to the number of neighborhoods'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_obj=1`—The number of objectives, which is 1 for this problem'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_eq_constr=3`—The number of equality constraints, which is 3 for this problem'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xl=0`—The lower bound for the decision variables, which is 0 for this problem'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xu=num_dist-1`—The upper bound for the decision variables, which is `num_dist-1`
    for this problem'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vtype=int`—The type of decision variables, which is integer for this problem'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to define a `PoliticalDistricting` class with
    different parameters, such as the number of districts, neighbor information, populations,
    and margin:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Define a constructor with specific parameters.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: ② Hold the population data.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: ③ Store the mean population of all districts.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: ④ Call the constructor of the parent class with specific parameters.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Evaluate the solution against the objective function and constraints.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation and as part of the `problem` class, we’ll extract the neighborhoods
    that belong to a specific district using the following function:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We’ll then calculate the upper and lower bounds based on the given population
    values and margin as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following function is used to decide whether an electoral district is overpopulated
    or underpopulated:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As all the constraints are equality constraints, the following function returns
    true if the constraint is satisfied:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To make sure that there is no isolated neighborhood far from other neighbors
    within a district, unless the district only has one neighborhood, the following
    function is used:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following function determines the best approximation to make an electoral
    district a contiguous block:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The last function in the `problem` class is used to evaluate the solution against
    the objective function, including checking the constraints:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '① Constraint 1: make sure that there is no empty district,'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '② Constraint 2: make sure there is no lone neighborhood within a district,
    unless the district only has one neighborhood.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '③ Constraint 3: ensure the electoral district is a contiguous block by achieving
    the best possible approximation.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now define the GA solver and apply it to solve the problem as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The resultant political districts are listed here and visualized in figure
    8.22:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![](../Images/CH08_F22_Khamis.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 The three political districts that combine the 16 neighborhoods
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: The problem is treated as a single objective optimization problem where the
    objective is to minimize the total number of overpopulated and underpopulated
    districts. The dataset contains the median household income of each neighborhood,
    so you can replace the objective function to focus on the heterogeneity of the
    median household income. You can also treat the problem as a multi-objective optimization
    problem by considering both criteria.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the end of the third part of the book, which focused on genetic
    algorithms and their applications in solving complex optimization problems. The
    fourth part of the book will delve into the fascinating realm of swarm intelligence
    algorithms.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Hamming cliff problem, which results from the inherent nature of binary
    representation, negatively affects binary-coded GAs by disrupting the search space’s
    smoothness, causing poor convergence and leading to inefficient exploration and
    exploitation. To address this problem, alternative representations like Gray code
    or real-valued encoding can be used, as they offer better locality and smoother
    search spaces, minimizing the disruptive effects of small changes on decoded values.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-valued GA is well suited for optimization problems involving continuous
    variables or real-valued parameters. It offers benefits such as better representation
    precision, faster convergence, diverse crossover and mutation operations, and
    reduced complexity, making it an attractive choice for many continuous optimization
    problems.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permutation-based GA is a class of genetic algorithms specifically designed
    to handle combinatorial optimization problems where the solutions can be represented
    as ordered sequences, or permutations, of elements.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-objective optimization problems can be tackled using either a preference-based
    multi-objective optimization method or a Pareto optimization approach. In the
    preference-based method, the multiple objectives are combined into a single or
    overall objective function by using a weighting scheme. The Pareto optimization
    approach focuses on identifying multiple trade-off optimal solutions known as
    Pareto-optimal solutions. These solutions can be further refined using higher-level
    information or decision-making processes.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crossover is primarily exploitative, as it combines the genetic material of
    two parent individuals to produce offspring, promoting the exchange of beneficial
    traits between solutions. However, depending on the implementation, crossover
    can also have some explorative properties, as it can produce offspring with new
    combinations of genes, leading to the discovery of new solutions.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutation can act as an explorative or exploitative operator depending on influencing
    factors such as the mutation rate and the mutation step size.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the crossover rate should be relatively high, as it promotes the
    exchange of genetic information between parent chromosomes. On the other hand,
    mutation is typically applied with a low probability, as its main purpose is to
    introduce random variations into the population.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
