- en: 8 Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 异常情况
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Initial feedback from the MVP
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVP的初始反馈
- en: Planning and addressing user requests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划和解决用户请求
- en: Identifying different types of exceptions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别不同类型的异常
- en: Updating the dashboard
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新仪表板
- en: Ensuring our UI is responsive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们的UI响应
- en: In chapter 7, we successfully launched our minimum viable product (MVP) to our
    user base to help solicit feedback and drive enhancements to the product. The
    feedback varied significantly—from users who loved the new direction of the dashboard
    to those who expressed their dissatisfaction, feeling it was missing too much
    functionality although it was not meant to be a full replacement yet. The business
    now wants us to both capitalize on what went well and address some of the missing
    functionality the users are currently clamoring for.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，我们成功地将我们的最小可行产品（MVP）推向用户基础，以帮助征求反馈并推动产品的增强。反馈差异很大——从喜欢仪表板新方向的用户到那些表达不满的用户，他们认为它缺少太多功能，尽管它目前并不是一个完整的替代品。现在，业务希望我们既要利用做得好的地方，也要解决用户目前迫切要求的一些缺失功能。
- en: By far, the biggest need recognized in our MVP was having a wider variety of
    ACH-related exceptions and making their handling possible within the user interface.
    This chapter identifies different categories of exceptions and ways to identify
    and potentially recover from them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的MVP中，最大的需求是拥有更多种类的ACH相关异常，并在用户界面中实现它们的处理。本章确定了不同类别的异常以及识别和可能从中恢复的方法。
- en: 8.1 Planning enhancements
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 计划增强
- en: The benefit of providing our target audience with an MVP is that we can get
    feedback from them and then use it to determine which features need to be added
    to the software. This advantage allows us to concentrate on items that deliver
    the most value. In this instance, we want to focus on providing a way to view
    ACH exceptions in the UI, as well as to search through our loaded files, which
    will help us find a much-needed and practical enhancement to the application as
    users must be aware of exceptions that prevent further processing of ACH files.
    This is especially valuable because we focus on Prearranged Payment and Deposit
    (PPD) ACH transactions, meaning that payroll and bill payments are at risk of
    not being processed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的目标受众提供MVP的好处是，我们可以从他们那里获得反馈，然后利用它来确定哪些功能需要添加到软件中。这种优势使我们能够专注于最有价值的物品。在这个例子中，我们希望专注于提供一个在用户界面中查看ACH异常的方法，以及搜索我们加载的文件，这将帮助我们找到用户迫切需要且实用的应用程序增强。这尤其有价值，因为我们专注于预先安排的支付和存款（PPD）ACH交易，这意味着工资和账单支付有未处理的风险。
- en: Depending on our circumstances, we may have a normal sprint to complete our
    work, or if the need is dire enough, we may be expected to turn around changes
    and fixes sooner. We will also likely see user stories written for these items,
    such as
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的情况，我们可能有一个正常的冲刺来完成我们的工作，或者如果需求迫切，我们可能需要更快地完成更改和修复。我们也可能会看到为这些项目编写的用户故事，例如
- en: As an operator, I want to be able to view processing exceptions and be aware
    of potential ACH problems that need to be resolved so that transactions are not
    delayed in posting to a customer’s account.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为操作员，我希望能够查看处理异常并了解需要解决的潜在ACH问题，以确保交易不会延迟到客户账户的入账。
- en: As an operator, I want to be able to search for specific transactions so I can
    research items for customer inquiries.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为操作员，我希望能够搜索特定交易，以便我可以研究客户询问的项目。
- en: In either case, providing stakeholders with a timeline or Gantt chart for the
    project can be beneficial. These visualizations are especially helpful if we find
    ourselves with a hard deadline. We often work backward from that deadline, trying
    to complete the expected tasks, while fitting them all within the allotted time.
    Of course, the required timeframe may not be possible, and having it laid out
    for management is a great way to help make our case for more time should we need
    it. Again, we rely on PlantUML to provide us with a simple Gantt chart we can
    share with the stakeholders. The following listing shows the required syntax.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，为项目提供时间表或甘特图都是有利的。如果我们面临硬性截止日期，这些可视化工具尤其有帮助。我们通常从截止日期开始倒推，试图完成预期任务，同时将它们全部纳入分配的时间范围内。当然，所需的时间框架可能不可能实现，将它们展示给管理层是帮助我们争取更多时间的好方法。再次强调，我们依赖PlantUML为我们提供一个简单的甘特图，我们可以与利益相关者分享。以下列表显示了所需的语法。
- en: Listing 8.1  PlantUML syntax for a Gantt chart
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1 - Gantt图的PlantUML语法
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 Excludes weekends from our chart because we do not want to work overtime'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从我们的图表中排除周末，因为我们不想加班'
- en: '#2 A header for the chart'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 图表的标题'
- en: '#3 Creates a visual break in the chart'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 在图表中创建一个视觉上的中断'
- en: '#4 Creates a task with a start time and duration'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 创建一个具有开始时间和持续时间的任务'
- en: '#5 Tasks can be dependent on other tasks.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 任务可以依赖于其他任务。'
- en: This listing produces the chart shown in figure 8.1\. As we mentioned, such
    charts are helpful for visualizing the work and are often appreciated by project
    stakeholders.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表生成了图8.1所示的图表。正如我们提到的，此类图表有助于可视化工作，并且通常受到项目利益相关者的赞赏。
- en: '![A diagram of a project  Description automatically generated](../Images/CH08_F01_Kardell.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![一个项目图  自动生成的描述](../Images/CH08_F01_Kardell.png)'
- en: Figure 8.1 A Gantt Chart for our enhancements
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1 - 我们增强功能的甘特图
- en: Now that we have outlined the initial work for this sprint, we can start tackling
    the steps needed to add exceptions to our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了这次冲刺的初始工作，我们可以开始着手添加异常到我们的应用程序所需的步骤。
- en: 8.2 Exceptions and warnings
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 异常和警告
- en: Remember that we prefer working here in short development cycles, as shown in
    figure 8.2\. In step 1, we need to create an ACH file with our desired exception
    condition, which means we will be updating the `ach_file_creation.feature` and
    associated test_create_ach_files.py to support creating files with our desired
    exception. In step 2, we support the new exception by updating the ach_file_processor.py,
    either by diving right in and starting to work on it or by creating unit tests
    in a more test-driven development (TDD) fashion. Finally, in step 3, we update
    the actual UI for the dashboard to support viewing and displaying of the exceptions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们更喜欢在这里进行短的开发周期，如图8.2所示。在步骤1中，我们需要创建一个包含我们所需异常条件的ACH文件，这意味着我们将更新`ach_file_creation.feature`和相关的test_create_ach_files.py，以支持创建具有我们所需异常的文件。在步骤2中，我们通过直接开始工作或以更测试驱动开发（TDD）的方式创建单元测试来更新ach_file_processor.py，以支持新的异常。最后，在步骤3中，我们更新仪表板的实际UI以支持查看和显示异常。
- en: Although the steps are going to be covered in separate sections, note that we
    would likely be working on each individual exception through these general steps.
    And as we work through each exception, we will notice improvements/refinements
    that can be made.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然步骤将在单独的部分中介绍，但请注意，我们可能会通过这些一般步骤对每个个别异常进行工作。并且在我们处理每个异常的过程中，我们会注意到可以做出的改进/细化。
- en: '![A diagram of a software system  Description automatically generated](../Images/CH08_F02_Kardell.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![一个软件系统图  自动生成的描述](../Images/CH08_F02_Kardell.png)'
- en: Figure 8.2 Flowchart representing our short development cycle
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2 - 表示我们的短开发周期的流程图
- en: First, we need to define exactly what we mean when we use the terms “exception,”
    “error,” and “warning.” They may seem somewhat interchangeable, but for our purposes,
    we would like to provide some background information on what we have in mind when
    talking about each. Please bear in mind that these are our own definitions and
    not a reflection of any fintech or Nacha standards.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确切地定义当我们使用“异常”、“错误”和“警告”这些术语时我们指的是什么。它们可能看起来有些可以互换，但就我们的目的而言，我们希望提供一些背景信息，说明我们谈论每个术语时的想法。请记住，这些是我们自己的定义，并不反映任何金融科技或Nacha标准。
- en: '*Erro**r*—A condition that prevents processing from taking place. We can think
    of errors as conditions such as an incomplete file upload or a bug in our software
    that causes processing to halt. Some conditions would cause an error, such as
    having a record with a record type code that does not exist in the ACH standard
    (e.g., record type code 2) because we do not have a place for this record in the
    database.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误* - 阻止处理发生的条件。我们可以将错误视为诸如文件上传不完整或软件中的错误导致处理停止的条件。某些条件会导致错误，例如，记录类型代码不存在于ACH标准中（例如，记录类型代码2），因为我们没有在数据库中为该记录留出位置。'
- en: '*Exceptio**n*—A business condition that would prevent file processing, which
    could include an improperly formatted file, invalid data in the file, or conditions
    the business has defined that should stop processing. Examples of these business
    conditions may be transactions over certain amounts, flagged customers, or other
    transaction activity that may cause concern.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异常* - 一种可能阻止文件处理的业务条件，这可能包括格式不正确的文件、文件中的无效数据，或者业务定义的应停止处理的条件。这些业务条件的例子可能包括超过一定金额的交易、标记的客户或其他可能引起担忧的交易活动。'
- en: '*Warnin**g*—A business condition that requires notification but does not necessarily
    prevent the file from being processed. Warnings may allow us to show leniency
    in enforcing ACH rules for files or customers. For instance, if the count on a
    control record is incorrect, the business may allow this discrepancy and process
    the file anyway.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*警告*—需要通知的业务条件，但并不一定阻止文件被处理。警告可能允许我们在执行ACH规则时对文件或客户表现出宽容。例如，如果控制记录上的计数不正确，业务可能会允许这种差异并继续处理文件。'
- en: As we can see, there are slight differences in the conditions and responses
    for these different categories. We should also have the recovery or research steps
    documented clearly in case an error is encountered. We have been involved in supporting
    software in the middle of the night where an explicit check was done within the
    code but without any indication of why the condition may occur, how to resolve
    it, or whether it is important. More than once, it was not important enough to
    stop the processing, and the code would be commented out so the check could be
    bypassed. This story illustrates the need to determine the severity of exceptions,
    and when and where they should be reported. Figure 8.3 shows a flowchart that
    can help you when deciding whether an exception needs to halt processing or it
    can be handled differently.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，不同类别在条件和响应上存在细微差异。在遇到错误的情况下，我们也应清楚地记录恢复或研究步骤。我们曾参与在深夜支持软件，代码中进行了明确的检查，但没有任何指示说明条件可能发生的原因、如何解决它或它是否重要。不止一次，它并不重要到足以停止处理，代码会被注释掉以便绕过检查。这个故事说明了确定异常严重性的必要性，以及何时何地应该报告它们。图8.3显示了一个流程图，可以帮助你决定是否需要停止处理异常或以不同的方式处理。
- en: '![A diagram of a flowchart  Description automatically generated](../Images/CH08_F03_Kardell.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![流程图示意图  自动生成的描述](../Images/CH08_F03_Kardell.png)'
- en: Figure 8.3  Flow chart for deciding how to handle errors
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3  决定如何处理错误的流程图
- en: To summarize, we should be thinking about
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们应该考虑
- en: Whether this is a problem that requires halting processing
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否这是一个需要停止处理的问题
- en: Whether it can be reported to the user in a timely manner
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以及时向用户报告
- en: Whether this is something that can wait but does need to be resolved eventually
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论这是否可以等待但最终需要解决的事情
- en: Too often, we may create alerts, messages, and reports that are ignored and
    dismissed by users before corrective action is taken. It can be a balancing act
    as different products or business needs require different approaches.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 太频繁地，我们可能会创建被用户忽略和删除的警报、消息和报告，在采取纠正措施之前。这可能会是一种平衡行为，因为不同的产品或业务需求需要不同的方法。
- en: 'From our software and development perspective, we must consider these different
    types of errors and warnings. It is also important to understand that the Federal
    Reserve has their own way of looking at a file’s ACH status. These statuses can
    be `accept`, `pend`, or `reject` and are exactly what you might expect:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的软件和开发角度来看，我们必须考虑这些不同类型的错误和警告。同时，了解美联储有其自己的方式来查看文件的ACH状态也很重要。这些状态可以是`接受`、`挂起`或`拒绝`，这正是你可能会预期的：
- en: '`accept`—The file is good and has been accepted by the Federal Reserve.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`接受`—文件良好，已被美联储接受。'
- en: '`pend`—The financial institution must confirm that the file should be accepted
    or rejected. This usually happens when there is some potential exception that
    may occur due to the formatting or contents of the file.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`挂起`—金融机构必须确认文件应该被接受或拒绝。这通常发生在由于文件格式或内容存在潜在异常时。'
- en: '`reject`—A condition/error causes the file to be rejected. This is an error
    state we may also end up with when the financial institution chooses to reject
    a file that was previously in a `pend` state or when the Federal Reserve flat-out
    rejects a file.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`拒绝`—条件/错误导致文件被拒绝。当金融机构选择拒绝之前处于`挂起`状态的文件，或者美联储直接拒绝文件时，我们可能会得到这种错误状态。'
- en: It should be noted that when files are corrected, there should be an audit trail.
    If a file is modified, the originator of the file may need to be notified. Otherwise,
    these changes may lead to confusion when attempting to research problems. We can
    imagine trying to speak with someone about a file where the file ID was corrected
    from a numeric to a letter without any indication it was done. It could lead to
    some frustrating interactions, with someone at the financial institution claiming
    not to see a file although the user clearly sees the transaction hitting their
    account.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意的是，当文件被纠正时，应该有一个审计跟踪。如果文件被修改，文件的原创建者可能需要被通知。否则，这些更改在尝试研究问题时可能会导致混淆。我们可以想象试图与某人讨论一个文件，其中文件ID从数字更改为字母，但没有任何表明这是已完成的指示。这可能会导致一些令人沮丧的互动，金融机构的某个人声称没有看到文件，尽管用户明显看到交易击中他们的账户。
- en: 8.3 Creating ACH files with exceptions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 创建带有异常的ACH文件
- en: 'As part of the MVP in chapter 7, we created the `ach_file_creation.feature`
    that allowed us to easily create well-formatted files using the BDD-style syntax
    (known as Gherkin). Recall that it allowed us to create files as shown:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第 7 章MVP（最小可行产品）的一部分，我们创建了`ach_file_creation.feature`，这使得我们能够轻松地使用BDD-style语法（称为Gherkin）创建格式良好的文件。回想一下，它允许我们创建如下所示的文件：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This works well for that happy path that we often start with, but now we need
    to expand our code to address some possible exceptions so we can work on building
    the required functionality. In some cases, our syntax may help enforce proper
    formatting of the ACH file, and that’s obviously a good thing. We want the creation
    process to be easier than creating something by hand, but now we also want to
    add some flexibility to the files. Eventually, we may accept CSV or other formatted
    files that would make customizing the fields easy. For now, we can look to expand
    and hopefully improve our syntax.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我们经常从快乐路径开始的情况效果很好，但现在我们需要扩展我们的代码来处理一些可能的异常，以便我们可以着手构建所需的功能。在某些情况下，我们的语法可能有助于强制执行ACH文件的正确格式，这显然是好事。我们希望创建过程比手动创建更容易，但现在我们还想为文件添加一些灵活性。最终，我们可能会接受CSV或其他格式化的文件，这将使定制字段变得容易。目前，我们可以考虑扩展并希望改进我们的语法。
- en: 8.3.1 Creating ACH files with file-level exceptions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 创建带有文件级别异常的ACH文件
- en: 'File-level errors and warnings will have to do with either the file header
    (type 1) or the file trailer (type 9) records. Many of the exceptions we might
    encounter stem from formatting problems with the file, and we would like to be
    able to introduce the following exceptions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 文件级别的错误和警告将与文件头（类型 1）或文件尾（类型 9）记录有关。我们可能遇到的大多数异常都源于文件格式问题，我们希望能够引入以下异常：
- en: '*File ID is not an uppercase letter in the range from A to Z or a number*.
    If it is a lowercase letter, the file could be rejected, or the financial institution
    could decide to fix it since it is a minor problem and easily corrected.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件ID不是A到Z范围内的字母大写或数字*。如果它是小写字母，文件可能会被拒绝，或者金融机构可能会决定修复它，因为这是一个小问题，容易纠正。'
- en: '*The immediate destination should be our bank’s routing number*. This is important
    because we obviously want to ensure we are processing the correct file for the
    correct bank. If we were to receive a file that was intended for another institution,
    it could be categorized as information leakage, unauthorized disclosure, or inadvertent
    data sharing. Regardless of what we call it, there are serious implications in
    terms of customer privacy, and we may have legal and regulatory obligations. While
    a seemingly innocuous problem (e.g., the field didn’t match), it would be an all-hands-on-deck
    type event. In FinTech, there are all kinds of places where this may occur, especially
    when dealing with multitenant environments. For example, it could occur when storing/retrieving
    images, displaying transactions in a mobile or internet banking application, sending
    statements, or communicating to incorrect or unauthorized addresses. This change
    also requires us to maintain a list of routing numbers associated with the bank
    since we need to be able to validate them. Because of bank mergers or acquisitions,
    it may be possible for banks to have more than one routing number.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直接目的地应该是我们银行的路线号*。这很重要，因为我们显然想确保我们正在处理正确的文件，为正确的银行。如果我们收到一个打算给另一个机构的文件，它可能被归类为信息泄露、未经授权的披露或不经意的数据共享。无论我们称它为什么，在客户隐私方面都有严重的后果，我们可能还有法律和监管义务。虽然这似乎是一个无害的问题（例如，字段不匹配），但它将是一场全员参与的事件。在金融科技领域，这种事情可能发生在许多地方，尤其是在处理多租户环境时。例如，它可能发生在存储/检索图像、在移动或网络银行应用程序中显示交易、发送对账单或与不正确或未经授权的地址通信时。这个变化还要求我们维护一个与银行关联的路线号列表，因为我们需要能够验证它们。由于银行的合并或收购，银行可能有多个路线号。'
- en: Blocking factor should never change but would be an error if it did. This gives
    us a chance to update our syntax to support setting fields and using the `get(field,`
    `default value)` so we do not need to have a lot of different syntax, which could
    then be expanded to support `padding-left`/`right`, `fill` `value`, and `length`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块因子不应改变，但如果改变了，则将是一个错误。这给了我们机会更新我们的语法以支持设置字段和使用 `get(field,` `默认值)`，这样我们就不需要有很多不同的语法，这可以进一步扩展以支持
    `padding-left`/`right`，`fill` `value` 和 `length`。
- en: Record size is similar to the blocking factor, and we always expect a 094. In
    theory, this field could be used to change the record format length, but in practice,
    systems typically just assume the 94 bytes and do not use the record size to read
    different-sized records. This does allow us to expand our checks to become more
    generic, exchanging constraints imposed by specific contexts and allowing more
    flexibility, but with that greater power comes more responsibility in knowing
    how to use it. For instance, we are adjusting the field offset for what is needed
    by Python. We could have left it starting at 1, so it aligned better with the
    ACH documentation and changed offsets within the code.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录大小类似于块因子，我们始终期望为094。理论上，此字段可以用来更改记录格式长度，但在实践中，系统通常只假设94字节，并且不使用记录大小来读取不同大小的记录。这确实允许我们扩展我们的检查以变得更加通用，交换由特定上下文施加的约束，并允许更多的灵活性，但随之而来的是更大的责任，即了解如何使用它。例如，我们正在调整字段偏移量以满足
    Python 的需求。我们本可以将它从1开始，这样与 ACH 文档更一致，并在代码中更改偏移量。
- en: '*File totals*. The file trailer record should match the computed totals for
    the file'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件总计*。文件尾记录应与文件计算出的总计相匹配'
- en: '*File hashing*. Each batch control has a hash value that is added up, truncating
    the result as necessary to keep the 10 lower-order digits (rightmost digits).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件哈希*。每个批量控制都有一个哈希值，该值累加，并在必要时截断结果以保留10个低位数字（最右侧的数字）。'
- en: 8.3.2 Creating ACH files with batch-level exceptions
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 使用批量异常创建 ACH 文件
- en: 'As we parse more of the file, we need to consider batch-level exceptions. These
    are specific to the batch records, and while they share some similarities to other
    exceptions, we may find they do not necessarily cause the entire file to be rejected.
    Instead, the batch itself could potentially be rejected by the system. In turn,
    that could cause the entire file to be rejected, or the financial institution
    could simply require the originator to send a new file. Some examples of batch-level
    exceptions are the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们解析更多文件内容，我们需要考虑批量级异常。这些异常特定于批量记录，尽管它们与其他异常有一些相似之处，但我们可能会发现它们并不一定导致整个文件被拒绝。相反，批量本身可能会被系统拒绝。这反过来又可能导致整个文件被拒绝，或者金融机构可能只需要求发起者发送一个新的文件。以下是一些批量级异常的例子：
- en: An invalid effective date would cause a batch error as this is the necessary
    information for correctly posting the file. So, whether it is missing or formatted
    incorrectly, there is no way to recover it, and a new file is needed.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的有效日期会导致批量错误，因为这是正确发布文件所必需的信息。所以，无论是缺失还是格式错误，都无法恢复，需要一个新的文件。
- en: Invalid batch totals on the control record would cause a warning. In practice,
    this usually causes a file to be rejected, but it would also be possible to correct
    the given file so that the totals match the entries for the file to be accepted.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制记录上的无效批量总计会导致警告。在实践中，这通常会导致文件被拒绝，但也可以纠正给定的文件，使总计与文件条目匹配，以便文件被接受。
- en: Bad Standard Entry Codes (SEC) on a batch will cause an error and the batch
    to be rejected. There is a set list of viable SEC codes that can be used, and
    some of them change the parsing of the records. We have been focused on the SEC
    code of PPD (used in payrolls, bill payments, pensions, etc.) and will continue
    to do so in this chapter.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量中的不良标准入口代码（SEC）会导致错误，并使批量被拒绝。有一系列可行的 SEC 代码可以使用，其中一些会改变记录的解析。我们一直专注于 PPD（用于工资、账单支付、养老金等）的
    SEC 代码，并将继续在本章中这样做。
- en: 8.3.3 Creating ACH files with entry-level exceptions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 使用入门级异常创建 ACH 文件
- en: 'Entry-level exceptions are interesting because aside from the usual formatting
    exception, they can be related more to the account in our system. Covering these
    exceptions requires more functionality in the system, but to give you a better
    idea of what we mean, let’s cover some of the common entry exceptions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 入门级异常很有趣，因为除了常见的格式异常之外，它们还可能更多地与系统中的账户有关。覆盖这些异常需要系统有更多的功能，但为了更好地说明我们的意思，让我们来看看一些常见的入门级异常：
- en: '*Invalid account numbe**r*—It could be related to formatting or simply not
    found on the system.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无效账户号码*—可能与格式有关，或者系统上找不到。'
- en: '*Invalid amoun**t*—The amounts are formatted (e.g., such as including the decimal
    or containing spaces).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无效金额*—金额格式错误（例如，包括小数或包含空格）。'
- en: '*Insufficient funds (NSF**)*—An account does not have funding for the transaction.
    This opens a lot of interesting possibilities for our project, from maintaining
    customer and account tables to assessing fees for transactions that cannot be
    processed.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资金不足（NSF）*—账户没有交易的资金。这为我们项目打开了许多有趣的可能性，从维护客户和账户表到评估无法处理的交易的费用。'
- en: 8.3.4 Clean-up of our file creation syntax
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 清理我们的文件创建语法
- en: With the need to create additional files, we will be revisiting the BDD-style
    syntax we used to create our files. Often, this is a great place to gain some
    experience in refactoring code and finding little improvements to make the syntax
    or code more robust. Because these are normally internal facing, we can gain experience
    by reworking existing code and seeing the potential effects it may have.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建额外的文件时，我们将重新审视我们用来创建文件的 BDD 风格语法。通常，这是一个获得重构代码和寻找微小改进以使语法或代码更健壮的好地方。因为这些通常是面向内部的，我们可以通过重构现有代码并观察其可能产生的潜在影响来获得经验。
- en: For instance, we had the line `@then(parsers.re('I` `should` `have` `a` `file`
    `named "(?P<expected_file_name>.*)"'))`, but there is no need to specify the filename
    again. Not only does it cause potential problems if we copy/paste a scenario to
    create a similar one, but it is just unnecessary typing. Instead, since we already
    have the filename stored, we can update it to become `@then("I` `should` `have`
    `a` `file` `of` `the` `same` `name")`. Then the code can pull in the stored filename
    from `setup_info['filename']` to perform the check.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们曾经有`@then(parsers.re('I should have a file named "(?P<expected_file_name>.*)"'))`这一行，但再次指定文件名是没有必要的。这不仅会在我们复制/粘贴场景以创建类似场景时引起潜在问题，而且纯粹是多余的输入。相反，既然我们已经存储了文件名，我们可以更新它成为`@then("I
    should have a file of the same name")`。然后代码可以从`setup_info['filename']`中提取存储的文件名以执行检查。
- en: 'Another improvement we can look at is cleaning up the way we parsed the strings
    from some of our statements. We originally used regular expressions to capture
    the strings being used, and while that is not necessarily a problem, it does add
    a layer of potential confusion. We are reminded about the famous quote from Jamie
    Zawinski: “Some people when confronted with a problem think, ''I know, I’ll use
    regular expressions.’ Now they have two problems.” To fix this, we can replace
    our regular expressions such as `@given(parsers.re(r''I` `want` `to` `create`
    `an` `ACH` `file` `named` `"(?P<filename>.*)"''))` with a far simpler `@given(parsers.parse(''I`
    `want` `to` `create` `an` `ACH file` `named` `\"{filename}\"''))`. Keeping our
    code simple ensures it’s more maintainable and less error-prone to updates when
    we return to it in a year or two to add more improvements.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以关注的另一个改进是清理我们解析某些语句中字符串的方式。我们最初使用正则表达式来捕获使用的字符串，虽然这并不一定是问题，但它确实增加了一层潜在的混淆。我们想起了Jamie
    Zawinski的著名引言：“有些人面对问题时会想，‘我知道，我会使用正则表达式。’现在他们有两个问题。”为了解决这个问题，我们可以将我们的正则表达式，如`@given(parsers.re(r'I
    want to create an ACH file named "(?P<filename>.*)"'))`，替换为一个远更简单的`@given(parsers.parse('I
    want to create an ACH file named "{filename}"'))`。保持我们的代码简单确保它更易于维护，并且在一年或两年后返回添加更多改进时，更不容易出错。
- en: What other improvements can be made? Remember that we should look to balance
    functionality and need. We can probably add a lot of bells and whistles, but if
    they go unused, was that really worth the extra work? That balance is especially
    important when talking about internal tools that do not necessarily add value
    that clients can see. Our stakeholders are unlikely to be impressed if we have
    a full-function ACH creation utility but nothing for them to actually process
    those files with!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有哪些可以改进的地方？记住，我们应该寻求平衡功能与需求。我们可能可以添加很多花哨的功能，但如果它们未被使用，这真的值得额外的努力吗？这种平衡在讨论不一定会增加客户可见价值的内部工具时尤为重要。如果我们有一个功能齐全的ACH创建实用工具，但没有为他们处理这些文件的实际工具，我们的利益相关者可能不会印象深刻！
- en: 8.4 Expanding the ACH processing for exceptions
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 扩展ACH处理以处理异常
- en: When adding the exceptions to the parser, we’ll follow a TDD approach by creating
    a test that will validate the intended exception has been added to the database.
    With the TDD approach, we expect this test to fail, and then we’ll work on adding
    the required logic to have a passing test. This approach may not be for everyone,
    but we would encourage you to try it out, if nothing else, just for a different
    perspective on development.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将异常添加到解析器时，我们将通过创建一个测试来验证预期的异常是否已添加到数据库中，从而遵循TDD（测试驱动开发）方法。使用TDD方法，我们预计这个测试会失败，然后我们将努力添加必要的逻辑以使测试通过。这种方法可能不适合每个人，但我们鼓励您尝试一下，至少为了从不同的角度看待开发。
- en: 8.4.1 ACH exceptions in the database
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 数据库中的ACH异常
- en: Originally, we stored some exception text in the database. However, we may want
    some finer controls and less redundant data. Therefore, we create a database type
    called `ach_exception_severity` to limit the entries that can be used when creating
    exceptions. The use of an `ENUM` allows us to ensure consistency in the type and
    reduce redundancy in our database. The downside is that `ENUM`s are not part of
    the SQL standard, and therefore, they may not be implemented in your relational
    database management system (RDBMS). While these examples assume the use of a Postgres
    database (which supports `ENUM`s), it is also possible to mimic this functionality
    with a separate table that provides the values we would use for the `ENUM` and
    a foreign key relationship in that table.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们在数据库中存储了一些异常文本。然而，我们可能希望有更精细的控制和更少冗余的数据。因此，我们创建了一个名为`ach_exception_severity`的数据库类型，以限制在创建异常时可以使用的条目。使用`ENUM`可以确保类型的一致性并减少数据库中的冗余。缺点是`ENUM`不是SQL标准的一部分，因此，它们可能不会被你的关系数据库管理系统（RDBMS）实现。虽然这些示例假设使用的是支持`ENUM`的Postgres数据库，但也可能通过一个单独的表来模拟这种功能，该表提供我们用于`ENUM`的值，并在该表中建立外键关系。
- en: The following listing shows the creation of the `ENUM` type and our new `ach_exception_codes`
    table we use to store extended descriptions of the errors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了创建`ENUM`类型以及我们新创建的`ach_exception_codes`表的过程，我们使用这个表来存储错误扩展描述。
- en: Listing 8.2  Creating the database `ENUM` and exception code table
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2  创建数据库`ENUM`和异常代码表
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Creates the ach_exception_severity type'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建`ach_exception_severity`类型'
- en: '#2 Uses our type as the datatype for a field'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将我们的类型用作字段的数据类型'
- en: Next, we create an exceptions table to keep track of our exceptions. There are
    a few approaches to this, where we have multiple tables for each specific entry
    (similar to having multiple ACH record types) and then tie them together with
    a view. However, here, we demonstrate using a single table that can hold references
    to other tables which contain the record we could look up the exception with.
    The following listing contains the `CREATE` `TABLE` statement. The important difference
    from our previous tables is that we use foreign key constraints, which allow `NULL`
    for the `ach_records_type_5_id` and `ach_records_type_6_id` fields because this
    information will only be populated when we have a record of that type with an
    exception. Note that every exception will be associated with a file, so we expect
    `ach_files_id` to be populated every time; therefore, we still have a `NOT NULL`
    constraint.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个异常表来跟踪我们的异常。有几种方法可以做到这一点，即为每个特定条目创建多个表（类似于有多个ACH记录类型），然后通过视图将它们关联起来。然而，在这里，我们演示使用一个可以包含其他表引用的单一表，这些表包含我们可以查找的记录异常。以下列表包含`CREATE
    TABLE`语句。与之前的表相比，重要的区别是我们使用了外键约束，这使得`ach_records_type_5_id`和`ach_records_type_6_id`字段可以接受NULL，因为只有在我们有该类型的异常记录时，这些信息才会被填充。请注意，每个异常都将与一个文件相关联，因此我们预计`ach_files_id`将在每次都填充；因此，我们仍然有一个`NOT
    NULL`约束。
- en: Listing 8.3  Creating the exceptions table
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3  创建异常表
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 These fields are not always used and can be NULL.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这些字段不一定总是被使用，可以是NULL。'
- en: '#2 The exception code details are referenced in ach_exception_codes.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 异常代码详情在`ach_exception_codes`中引用。'
- en: Adding data to our table is part of the database startup. We do this because
    these are standard errors we can consider being shipped with the product. Often,
    we find these types of tables or settings that are part of the setup for a financial
    institution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的表中添加数据是数据库启动的一部分。我们这样做是因为这些是我们可以考虑作为产品一部分的标准错误。我们经常发现这些类型的表或设置是金融机构设置的一部分。
- en: Listing 8.4  Adding data to the exceptions table
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4  向异常表添加数据
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Each exception needs to be inserted into the database.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 每个异常都需要被插入到数据库中。'
- en: Adding this type of persistent data is necessary for the dashboard; however,
    it does add a level of complexity. Our tests become dependent on these tables
    being defined and the data populated. We also ran into a problem because our unit
    tests were truncating all tables to ensure the database was clean. The following
    listing shows the changes to a portion of the truncate script so that we can understand
    the needed changes to the `SqlUtils.truncate_all()`. We may want to consider updating
    the name (or at the very least the documentation) so that it is understood that
    `truncate_all` is not actually truncating all data anymore.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这种持久数据对于仪表板是必要的；然而，这也增加了一层复杂性。我们的测试变得依赖于这些表的定义和数据填充。我们还遇到了一个问题，因为我们的单元测试会将所有表截断以确保数据库是干净的。以下列表显示了截断脚本的一部分更改，以便我们可以理解对
    `SqlUtils.truncate_all()` 所需的更改。我们可能想要考虑更新名称（或者至少是文档），以便理解 `truncate_all` 实际上不再截断所有数据。
- en: Listing 8.5  Updating the `truncate` script
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5 更新 `truncate` 脚本
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 We have tables that need to be skipped from our truncate logic as they contain
    hardcoded values.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们有一些表需要在截断逻辑中跳过，因为这些表包含硬编码的值。'
- en: Although we may not be overly burdened by this approach now, there will likely
    come a time when we’ll have to manage the test database a bit better. A popular
    option is to use Testcontainers ([https://testcontainers.com/](https://testcontainers.com/)),
    which allows us to create temporary Docker containers that contain our database
    and will not persist beyond the lifespan of our test. This provides obvious advantages
    when dealing with unit testing, especially when it comes to tests run within the
    CI/CD pipeline.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在可能不会因为这个方法而过度负担，但将来我们可能需要更好地管理测试数据库。一个流行的选择是使用 Testcontainers ([https://testcontainers.com/](https://testcontainers.com/))，它允许我们创建包含我们的数据库的临时
    Docker 容器，这些容器不会超出测试的生命周期。这在处理单元测试时提供了明显的优势，尤其是在 CI/CD 管道中运行的测试。
- en: 8.4.2 Recovery options
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 恢复选项
- en: Before updating the ACH parser to support our new exceptions, let’s take a moment
    to consider the flip side of logging exceptions—what to do when they are encountered!
    We want to consider exactly how users should recover from a problem. This can
    be especially true when dealing with loading transactions, which the dashboard
    could eventually be involved with. Since an ACH file is used to move money around,
    if our file fails to load or otherwise has error conditions, we may need to consider
    implications to user’s accounts. In other words, it may not be enough to just
    load a file and try again. We need to be able to ensure transactions will not
    be posted to the account again, resulting in customers being either credited or
    debited multiple times. At this point, our concerns do not need to be centered
    around those details, but it is important to provide some help to the user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新 ACH 解析器以支持我们新的异常之前，让我们花一点时间考虑记录异常的另一方面——当遇到异常时应该做什么！我们想要确切地考虑用户应该如何从问题中恢复。这在与加载交易处理时尤其如此，仪表板最终可能会涉及到这一点。由于
    ACH 文件用于移动资金，如果我们的文件加载失败或存在其他错误条件，我们可能需要考虑对用户账户的影响。换句话说，仅仅加载文件并再次尝试可能是不够的。我们需要确保交易不会再次发布到账户，导致客户被多次贷记或借记。在这个阶段，我们的担忧不需要集中在那些细节上，但为用户提供一些帮助是很重要的。
- en: One scenario that comes to mind is encountering an exception being thrown, which
    involved comparing totals from two parts of the system. If the totals did not
    match, the processing halted, resulting in a call to a developer at 2 am. The
    concern was not an exception making us work at odd hours. If a critical processing
    exception occurs, we can expect occasional problems. Rather, the concern was about
    the recovery steps that should be taken when the error was encountered—there were
    none! The result was multiple developers having to get involved to figure out
    what needed to be done. It was determined the check could be safely bypassed,
    and we could follow up and investigate further the following day. Eventually,
    it was found the audit records were not written out as expected, which resulted
    in the totals being off, but the problem recurred several times before that was
    discovered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个浮现的情景是遇到一个异常被抛出，这涉及到比较系统两部分的总额。如果总额不匹配，处理就会停止，导致凌晨2点时需要联系开发者。担忧的并不是异常让我们在非正常时间工作。如果发生关键处理异常，我们可以预期偶尔会出现问题。相反，担忧的是在遇到错误时应该采取的恢复步骤——没有！结果是多个开发者不得不介入以确定需要做什么。确定检查可以安全地绕过，我们可以在第二天跟进并进一步调查。最终，发现审计记录没有按照预期写入，这导致了总额不准确，但在发现这个问题之前，问题已经重复出现几次了。
- en: While we do not have such concerns with our project right now, it would certainly
    be nice to provide users with some additional information. After all, the dashboard
    may eventually require its own internal help system, or perhaps a look at the
    exception will offer some advice on what actions can be taken. The following listing
    shows the creation of an `ach_recovery_options` table tied back to the `ach_exception_codes`
    table, allowing multiple entries to be associated with an exception code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们目前的项目没有这样的担忧，但为用户提供一些额外的信息当然会很不错。毕竟，仪表板最终可能需要自己的内部帮助系统，或者查看异常可能会提供一些关于可以采取哪些行动的建议。以下列表显示了创建一个与`ach_exception_codes`表关联的`ach_recovery_options`表，允许将多个条目与一个异常代码关联。
- en: Listing 8.6  ACH recovery options table
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6  ACH恢复选项表
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Each recovery option should reference a specific exception.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 每个恢复选项应引用一个特定的异常。'
- en: '#2 The recovery option is simply text that the users can review for help.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 恢复选项是用户可以查阅以获取帮助的简单文本。'
- en: We can then prepopulate the table with our recovery options as part of our startup.
    The following listing shows some possible recovery options being inserted into
    the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以作为启动过程的一部分预填充表中的恢复选项。以下列表显示了将一些可能的恢复选项插入数据库的示例。
- en: Listing 8.7  Prepopulating the recovery options
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7  预填充恢复选项
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The recovery options could certainly be expanded. However, at this point, we
    just want to ensure recovery and help is a consideration in our development. We
    should all be aware of the importance of clean code and comments to help us understand
    the code when we have to dive back into it in 6 to 12 months. Just as important
    is making sure that our software is usable by the end-user. Otherwise, we may
    find ourselves having to provide support for problems that users should be able
    to fix themselves. Defining help within the application and considering more extensive
    documentation and troubleshooting in a tool such as Confluence can be helpful
    to end-users and support staff. In the end, it will free you up to spend more
    time developing, and that is what we are all here for!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复选项当然可以扩展。然而，在这个阶段，我们只想确保恢复和帮助是我们开发中的一个考虑因素。我们都应该意识到干净代码和注释的重要性，这样当我们不得不在6到12个月后再次深入研究代码时，我们可以理解代码。同样重要的是确保我们的软件对最终用户是可用的。否则，我们可能会发现自己需要为用户应该能够自行解决的问题提供支持。在应用程序中定义帮助，并在Confluence等工具中进行更广泛的文档和故障排除，对最终用户和支持人员都有帮助。最终，这将让您有更多时间用于开发，这正是我们在这里的原因！
- en: 8.5 Updating the ACH parser
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 更新ACH解析器
- en: With the database capable of supporting better exception handling, we can now
    work on updating the ACH parsing to write our exceptions. Many exceptions that
    we might encounter from a formatting perspective can be handled through Pydantic.
    We can continue to add constraints and validation to our Pydantic definitions,
    which will take many of the more tedious tasks out of our hands. Other exceptions
    may rely on examining more than just the fields of our record. For instance, ensuring
    that trace numbers are ascending is something that we would prefer to do outside
    of Pydantic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据库能够支持更好的异常处理，我们现在可以着手更新 ACH 解析以编写我们的异常。从格式方面可能遇到的许多异常可以通过 Pydantic 处理。我们可以继续向我们的
    Pydantic 定义添加约束和验证，这将从我们的手中移除许多繁琐的任务。其他异常可能需要检查我们记录的字段之外的内容。例如，确保跟踪号是递增的，这是我们更愿意在
    Pydantic 之外完成的事情。
- en: 8.5.1 Creating unit tests for the exceptions
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 为异常创建单元测试
- en: We have already shown how to update our BDD-style syntax to create files with
    the needed errors. Then we can create the basic layout, as shown in the following
    listing. This approach should work just fine for testing, regardless of whether
    an exception was encountered.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何更新我们的 BDD 风格语法来创建带有所需错误的文件。然后我们可以创建基本布局，如下面的列表所示。这种方法对于测试应该效果很好，无论是否遇到异常。
- en: Listing 8.8  Test for invalid immediate destination
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8  测试无效的立即目的地
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Defines initial variables so we can obtain a file to load'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义初始变量，以便我们可以获取一个要加载的文件'
- en: '#2 We use an ENUM value so that the exception codes remain flexible.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们使用 ENUM 值，以便异常代码保持灵活。'
- en: '#3 Inserts a needed dummy record for our insert'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 为我们的插入插入一个所需的虚拟记录'
- en: '#4 Parses the file which loads it into the database'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 解析文件，将其加载到数据库中'
- en: '#5 Gets the exceptions'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 获取异常'
- en: '#6 Asserts that we have our one expected exception'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 断言我们有一个预期的异常'
- en: Considering the previous sample, we may notice that much of that code will be
    the same for each test. This is a perfect opportunity to recall that refactoring
    is one of the TDD phases. In this instance, we can refactor the code so that the
    processing of the file is generalized to one routine, and we call that with the
    expected values, as shown in the following listing. This approach still works
    well for these basic tests where we just want to confirm the exception has been
    caught. Since the `assert` raises an exception, we still see our error thrown
    from within the `test_incorrect_file_id_modifier` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前的示例，我们可能会注意到其中大部分代码对每个测试都是相同的。这是一个回忆重构是 TDD 阶段之一的绝佳机会。在这种情况下，我们可以重构代码，使文件的处理过程通用化到一个例程，并使用预期的值调用它，如下面的列表所示。这种方法对于这些基本测试仍然很有效，我们只是想确认异常已被捕获。由于
    `assert` 引发异常，我们仍然在 `test_incorrect_file_id_modifier` 方法内部看到我们的错误被抛出。
- en: Listing 8.9  Refactored test
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9  重构测试
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 We create a function and pass the needed variables to it.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们创建一个函数并将所需的变量传递给它。'
- en: '#2 The called function contains the same logic of parsing and asserting the
    desired variables.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 被调用的函数包含解析和断言所需变量的相同逻辑。'
- en: With these basic tests, we can easily start adding exceptions to our code. Of
    course, more extensive testing will be done at some point, but this is a great
    way to get moving in the right direction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些基本测试，我们可以轻松地为我们的代码添加异常。当然，在某个时候，我们还将进行更广泛的测试，但这是朝着正确方向前进的一个很好的方法。
- en: 8.5.2 Supporting the exceptions in our parser
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 在我们的解析器中支持异常
- en: To begin writing our exceptions, we have to add a schema that can hold the exception
    information. By providing the UUID for the file, batch, and entry, we have flexibility
    in reporting the exception at different levels. For instance, when an amount is
    invalid, we can drill down directly to the record causing the problem because
    we have access to the UUID for the file, batch, and entry. Compare that with if
    we only had the `ach_files_id` that caused the exception. If we had thousands
    of records in the file, we would have our work cut out for us, determining the
    offending record. The following listing shows our ACH exception schema. We have
    excluded the field definitions to keep things simple.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写我们的异常，我们必须添加一个可以存储异常信息的模式。通过提供文件、批次和条目的 UUID，我们在不同级别报告异常方面具有灵活性。例如，当金额无效时，我们可以直接钻到导致问题的记录，因为我们有权访问文件、批次和条目的
    UUID。与此相比，如果我们只有导致异常的 `ach_files_id`，如果我们文件中有成千上万的记录，我们将有大量工作要做，确定有问题的记录。下面的列表显示了我们的
    ACH 异常模式。我们排除了字段定义，以保持简单。
- en: Listing 8.10  The ACH exception schema
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10  ACH 异常架构
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 We always associate exceptions with a particular file.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们总是将异常与特定的文件关联。'
- en: '#2 The record number helps locate the unparsed record.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 记录号有助于定位未解析的记录。'
- en: '#3 The exception code helps locate the error details.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 异常代码有助于定位错误详情。'
- en: We then continue creating our `AchExceptionsSql` class that has the usual `insert_record`
    and `get_record` methods. We could have named these `insert_exception` and `get_exception`,
    but to stay consistent with the other methods, we keep it similar to our existing
    code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续创建我们的 `AchExceptionsSql` 类，它具有通常的 `insert_record` 和 `get_record` 方法。我们本可以将其命名为
    `insert_exception` 和 `get_exception`，但为了与其他方法保持一致，我们保持代码相似。
- en: Listing 8.11  ACH exceptions SQL
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11  ACH 异常 SQL
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 The exception class containing any SQL calls'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 包含任何SQL调用的异常类'
- en: '#2 Standard SQL to insert and return the newly added ID'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 标准SQL用于插入并返回新添加的ID'
- en: '#3 Returns the first field from our results, which is the ID'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回结果中的第一个字段，即ID'
- en: '#4 Standard SQL to read the exceptions'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 标准SQL用于读取异常'
- en: Now that we can create exception records, we can simply call an `_add_exception`
    routine from ach_file_processor.py wherever we need to write out exceptions. Listing
    8.12 shows this exception routine. Notice that we take the `AchExceptionSchema`
    and the unparsed line as parameters. We chose to take the line as an optional
    parameter and write it out to an invalid record table. This is because we split
    out the individual record types in our database earlier. To accommodate conditions
    where we may have a record that could not be parsed because it was not a valid
    type, we still want to store it somewhere.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建异常记录，我们可以在 ach_file_processor.py 中需要写入异常的地方简单地调用 `_add_exception` 例程。列表
    8.12 展示了这个异常例程。注意，我们接受 `AchExceptionSchema` 和未解析的行作为参数。我们选择将行作为可选参数，并将其写入无效记录表。这是因为我们在数据库中较早地将单个记录类型拆分出来。为了适应可能无法解析的记录（因为它不是有效的类型）的情况，我们仍然希望将其存储在某个地方。
- en: Listing 8.12  Adding an exception method
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12  添加异常方法
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 Our function to call when we have an exception during processing'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当我们在处理过程中遇到异常时调用的函数'
- en: '#2 When a record has been passed, we need to write it to a special database
    table since we could not determine the correct table for it (e.g., a record type
    that does not exist).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当记录已传递时，我们需要将其写入一个特殊的数据库表，因为我们无法确定正确的表（例如，不存在的记录类型）。'
- en: With the ability to create exceptions, we need to update our parsing methods
    to return a custom validation error. The individual field parsing does not change,
    but we want to capture the validation error and wrap it with a custom error.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建异常的能力，我们需要更新我们的解析方法以返回自定义验证错误。单个字段解析没有变化，但我们希望捕获验证错误并将其包装在自定义错误中。
- en: Listing 8.13  Updating parse routine
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13  更新解析例程
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 Tries to parse the header with Pydantic'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 尝试使用 Pydantic 解析标题'
- en: '#2 Catches when a validation error is encountered'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当遇到验证错误时进行捕获'
- en: '#3 Creates a custom error that stores our ACH related information using the
    raise keyword'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用 raise 关键字创建一个自定义错误，用于存储我们的 ACH 相关信息'
- en: The custom `AchParsingValidationError` is shown in the following listing. The
    purpose of the custom error is that we can translate the encountered errors to
    their equivalent `AchException` codes, which facilitates writing them to the database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 `AchParsingValidationError` 在以下列表中显示。自定义错误的目的在于我们可以将遇到的错误转换为等效的 `AchException`
    代码，这有助于将它们写入数据库。
- en: Listing 8.14  Custom ACH parsing error
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14  自定义 ACH 解析错误
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 Our error is a subclass of Exception.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们的错误是 Exception 的子类。'
- en: '#2 Defines a function to get a list of exceptions'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义一个获取异常列表的函数'
- en: '#3 Processes each validation from the array self.validation_errors'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 处理数组 self.validation_errors 中的每个验证'
- en: '#4 Translates the field having a problem to one of our exception codes'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将有问题的字段翻译为我们的一种异常代码'
- en: Then we can update the individual parsing of the record to add the exceptions
    when encountered.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新记录的个别解析，以在遇到异常时添加异常。
- en: Listing 8.15  Updates to handle validation errors
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15  处理验证错误的更新
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 We try to parse the record.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们尝试解析记录。'
- en: '#2 For each error we find, it writes out an exception.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 对于我们找到的每个错误，它都会写入一个异常。'
- en: That provides a basic outline for handling of exceptions in the ACH parser.
    The same formula applies to the remaining record types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这为 ACH 解析器中异常的处理提供了一个基本框架。相同的公式适用于其他记录类型。
- en: 8.5.3 Validation in Pydantic
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3 Pydantic 中的验证
- en: Much of field-level validation will happen in Pydantic. Let’s take a look at
    some of the exceptions and how we can do them in Pydantic.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分字段级验证将在 Pydantic 中进行。让我们看看一些异常以及我们如何在 Pydantic 中实现它们。
- en: First, we would like to address the file ID modifier on the type 1 record. This
    should be an uppercase letter from A to Z or a numeric value from 0 to 9, which
    we can easily specify in Pydantic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望解决类型 1 记录上的文件 ID 修改符。这应该是一个从 A 到 Z 的大写字母或从 0 到 9 的数值，我们可以在 Pydantic 中轻松指定。
- en: Listing 8.16  Pydantic validation of the file ID modifier
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16  Pydantic 对文件 ID 修改符的验证
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 We define a regular expression pattern to validate against.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们定义一个正则表达式模式来验证。'
- en: '#2 We also limit the field size, although the pattern itself should be enough.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们还限制了字段大小，尽管模式本身应该足够。'
- en: Another condition to cover is the immediate destination. We know that this should
    match the routing number of our bank. We do not necessarily want to hardcode these
    values into our code because they can change (although not often), but as previously
    mentioned, banks that go through acquisitions and mergers may gain (or lose) routing
    numbers. Therefore, we want a way to have Pydantic validate the immediate destination
    based on a list of values known at runtime.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要覆盖的条件是立即目的地。我们知道这应该匹配我们银行的路线号。我们不一定想将这些值硬编码到我们的代码中，因为它们可能会改变（尽管不经常），但如前所述，经历收购和合并的银行可能会获得（或失去）路线号。因此，我们想要一种方法，让
    Pydantic 根据在运行时已知的值列表验证立即目的地。
- en: This task is accomplished through a `field_validator` annotation in Pydantic.
    For our purposes, we will hook this into a database call, which lets us validate
    the field against a list of allowed values in our database.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务是通过 Pydantic 中的 `field_validator` 注解完成的。为了我们的目的，我们将将其连接到数据库调用，这让我们可以验证字段与数据库中允许的值列表。
- en: Listing 8.17  Pydantic field validator for immediate destination
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17  Pydantic 立即目的地字段验证器
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 Uses the field_validator and classmethod annotations'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用 field_validator 和 classmethod 注解'
- en: '#2 Uses SQL to check the bank routing number and return it if valid'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用 SQL 检查银行路由号，如果有效则返回它'
- en: '#3 Otherwise, raises a ValueError as it was not found'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 否则，如果没有找到，将引发 ValueError'
- en: '#4 Handles any unexpected errors with a ValueError as well'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 也用 ValueError 处理任何意外的错误'
- en: To support this, we have to create a simple table that contains the routing
    numbers we want to consider as our bank routing numbers. Depending on the number
    of records we expect to validate, having to perform a database query for each
    record (and possibly multiple fields) may be inefficient. In our case, there should
    only be a single ACH file header record in any file that we load. So, we are not
    overly concerned about the effects on performance, but these types of potential
    problems should be kept in mind.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，我们必须创建一个简单的表格，其中包含我们想要考虑为我们的银行路由号的路线号。根据我们期望验证的记录数量，对于每个记录（以及可能的多字段）执行数据库查询可能效率低下。在我们的情况下，任何我们加载的文件中都应该只有一个
    ACH 文件头记录。因此，我们不太关心性能的影响，但这些潜在问题的类型应该被记住。
- en: Once we start validating the immediate origin, we need to go through and correct
    many of our tests where we had a number that was valid but did not exist in our
    database. There will be an additional clean-up of unit tests to handle the exceptions
    and expanding of parameters passed to the routines so that we can log the exceptions.
    When these methods start getting too complex, it will be time to split them into
    their own record-type classes away from the parser itself.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始验证立即起源，我们需要检查并纠正许多测试，在这些测试中，我们有一个有效的数字，但它不在我们的数据库中。将进行额外的单元测试清理来处理异常，并扩展传递给例程的参数，以便我们可以记录异常。当这些方法开始变得过于复杂时，将是时候将它们拆分到自己的记录类型类中，远离解析器本身。
- en: 8.6 Updating the APIs
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 更新 API
- en: After passing the unit tests with the ACH parsing and handling our errors, we
    can jump over to the dashboard to see things in action. Unfortunately, if you
    try to load one of the exception files, you will not see it on the dashboard.
    What happened?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 ACH 解析和错误处理单元测试后，我们可以跳转到仪表板来查看实际操作。不幸的是，如果你尝试加载其中一个异常文件，你将不会在仪表板上看到它。发生了什么？
- en: We already have BDD syntax for the API endpoint that supports loading a file
    and checking the results, so no new code will be needed to support the test shown
    in the next listing. Having the flexibility to create new tests without having
    to write any new code is one of the benefits of BDD and a flexible syntax that
    powers it. Running this test does indeed show no records being returned.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了支持加载文件并检查结果的API端点的BDD语法，因此不需要编写任何新代码来支持下一个列表中显示的测试。能够创建新测试而不需要编写任何新代码是BDD及其灵活语法的优势之一。运行这个测试确实显示没有返回任何记录。
- en: Listing 8.18  Testing our API with an invalid file
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.18  使用无效文件测试我们的API
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 Defines a scenario'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个场景'
- en: '#2 Sets up the database and processes an ACH file'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 设置数据库并处理ACH文件'
- en: '#3 Executes the API'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 执行API'
- en: '#4 Checks for our included file'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 检查我们包含的文件'
- en: Another great benefit of having tests is that we can simply add a breakpoint
    to the endpoint and rerun the test in a debug mode, which then allows us to step
    through the code. If you take the time to do this, you should see that no results
    are being returned from the query.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个拥有测试的好处是，我们可以简单地添加一个断点到端点，以调试模式重新运行测试，这允许我们逐步执行代码。如果你花时间这样做，你应该会看到查询没有返回任何结果。
- en: The queries are not able to handle the parsed record (`ach_file_headers` or
    `ach_file_control_records`) not being found. Because we used `INNER` `JOIN`, the
    record must exist in the database to be returned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 查询无法处理解析记录（`ach_file_headers`或`ach_file_control_records`）未找到的情况。因为我们使用了`INNER
    JOIN`，记录必须存在于数据库中才能返回。
- en: Listing 8.19  Using `INNER JOIN` in our original query
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.19  在我们的原始查询中使用`INNER JOIN`
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 INNER JOINs on these files may cause records not to be returned when exceptions
    occur.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 在这些文件上使用INNER JOIN可能会导致异常发生时记录不返回。'
- en: Both the `ach_file_headers` and `ach_file_control_records` are needed in the
    query. Now that we have started adding our exceptions and not writing out parsed
    records, we will also need to be more aware of these queries. Since there is no
    guarantee that this feature will be present, we should use a `LEFT` `JOIN` to
    return a result. The following listing shows updating both parsed versions of
    our query to use the `LEFT` `JOIN`. Depending on the workflow we use to work through
    this problem, we may not want to make changes to both tables until we have tests
    to verify them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 查询中需要`ach_file_headers`和`ach_file_control_records`。现在我们已经开始添加异常并且不再输出解析后的记录，我们也将需要更加关注这些查询。由于无法保证这个功能一定会存在，我们应该使用`LEFT
    JOIN`来返回结果。下面的列表显示了更新我们的查询以使用`LEFT JOIN`。根据我们用来处理这个问题的流程，我们可能不想在测试验证之前对两个表都进行更改。
- en: Listing 8.20  Updating our queries to `LEFT JOIN`
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.20  更新我们的查询以使用`LEFT JOIN`
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Updating our queries to LEFT JOIN resolves the problem by keeping the data
    in the left table.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将我们的查询更新为LEFT JOIN通过保留左表中的数据来解决问题。'
- en: With the updates to the query, we now see our tests passing. We may also look
    at these queries and think that we have spent all the previous sections adding
    exceptions, but we neither have any APIs handling them nor have we updated any
    of our existing APIs to consider them as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 随着查询的更新，我们现在看到测试通过了。我们也许会认为我们之前所有章节都在添加异常，但我们既没有任何API来处理它们，也没有更新我们现有的API来考虑它们。
- en: 'When thinking about including exceptions in our dashboard, we will likely want
    APIs that can help us with the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑在我们的仪表板上包含异常时，我们可能希望有API可以帮助我们完成以下任务：
- en: '*Return all exception**s*—Regardless of whether we are looking for all exceptions
    ever or just exceptions encountered today, we need some insight into the exceptions
    that have been encountered. Also, if we are interested in allowing users to perform
    maintenance on the exceptions (change exception levels), this is a good starting
    point.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回所有异常*——无论我们是寻找所有曾经遇到的异常还是只是今天遇到的异常，我们都需要对遇到的异常有所了解。此外，如果我们有兴趣允许用户对异常进行维护（更改异常级别），这是一个好的起点。'
- en: '*Return exceptions for a fil**e*—There will certainly be a need to get exceptions
    for a specific file.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回特定文件的异常*——肯定会有获取特定文件异常的需求。'
- en: There are more use cases for our APIs, but these should be sufficient to get
    us moving with some of the APIs. One design choice we will have to make is the
    endpoint layout. Do we create a new endpoint so that our exceptions are like our
    existing `/files` endpoint (something similar to `/api/v1/exceptions`), or are
    exceptions part of our files (something similar to `/api/v1/files/exceptions`).
    Will we use a combination of the two? Since the exceptions will be associated
    with the loaded files, we keep our exceptions associated with the `/files` endpoints.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to ensure that our exception APIs are returning the expected data.
    For instance, when we load the invalid_file_id.ach, we expect an error code and
    message that will be returned from the database. We can use most of our existing
    code in the test_file_api.py and only include a few other steps. Starting with
    this, we can create a test we then verify against. We created a new file named
    ach_files_exception_endpoint.feature that stores our exception features.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.21  Testing our exceptions API
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 Sets up a scenario for the exceptions API'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures an empty database and loads the file'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Calls the API and validates the exception'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: To support the new `When` clause, we must add code that will request a list
    of files so that we can determine the UUID. After that, we use the obtained ID
    to make a request to the exception endpoint. To avoid any unexpected errors, we
    could also ensure that we have one record returned from the response, as well
    as a valid response code. However, since we have cleared the database and only
    loaded a single file, it should be an exceptional condition that causes this to
    break.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.22  Adding a new `When` clause
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Gets a list of files and ensures that it worked'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Extracts the file_id from the response'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses the file_id we just extracted from the response, makes another API
    call to our exceptions API, and validates the HTTP response'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Saves the response for use in other steps'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We have our stored API response, and now we want to ensure that we are getting
    the expected error code and message from our response. Why are we validating both
    the error code and the message text coming back? Should the error code not be
    the determining factor? On the one hand, the consumer of the API should rely on
    the error code and not the error message description. On the other hand, we want
    to ensure that both the error code and description match our expectations. Furthermore,
    we may want to identify when the description changes as maybe some consumers of
    our API work directly with the description rather than with the error code. Perhaps
    the API was incorrect at some point and returned the same error code for different
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: errors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: To work around the error, the consumers may have directly interrogated the description,
    and changes to it may break the API. Of course, if we make a change to that API,
    we may choose to change the version so that consumers can move to the updated
    API when they are ready. With all that said, we just need to be aware that changes
    can affect end-users in unexpected ways. We have seen instances where customers
    have implemented their own scraping of log messages for their own purposes. When
    those messages (even though they were internal to the application) changed, the
    infrastructure broke. In the end, the messages needed to be put back in place.
    So, be very careful—seemingly innocuous changes may cause problems.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过错误，消费者可能直接查询了描述，对其更改可能会破坏 API。当然，如果我们更改了该 API，我们可能会选择更改版本，以便消费者在他们准备好时迁移到更新的
    API。话虽如此，我们只需意识到更改可能会以意想不到的方式影响最终用户。我们已经看到客户为了自己的目的实现了自己的日志消息抓取。当这些消息（尽管它们是应用程序内部的）更改时，基础设施就崩溃了。最后，必须将消息放回原位。因此，请非常小心——看似无害的更改可能会引起问题。
- en: Listing 8.23  Adding a new `Then` clause
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.23  添加新的 `Then` 子句
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 Using any, we can search for a field in our response. This tactic is convenient
    when dealing with an array of values and we do not know the order of the response.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用 any，我们可以在我们的响应中搜索一个字段。当处理一个值数组并且我们不知道响应的顺序时，这种策略很方便。'
- en: We now have tests for these APIs to determine whether they are returning data
    successfully. As a programming challenge, can you create the logic behind these
    APIs and get the tests to pass?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对这些 API 进行了测试，以确定它们是否成功返回数据。作为一个编程挑战，你能创建这些 API 背后的逻辑并使测试通过吗？
- en: We create the endpoint for the exceptions `/{file_id}/exceptions` as shown in
    the following listing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了异常端点 `/{file_id}/exceptions`，如下所示。
- en: Listing 8.24  An exceptions endpoint for a file
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.24  文件的异常端点
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Our API details that will be used for OpenAPI documentation'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们将用于 OpenAPI 文档的 API 详细信息'
- en: '#2 The actual function'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 实际的函数'
- en: Next, we create the `get_exceptions_response` method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了 `get_exceptions_response` 方法。
- en: Listing 8.25  The `get_exceptions_response` method
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.25  `get_exceptions_response` 方法
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#1 Standard SELECT statement with our desired fields'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用我们想要的字段的标准 SELECT 语句'
- en: '#2 Our initial table is the ach_exceptions.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们最初的表是 ach_exceptions。'
- en: '#3 Joins our exceptions with the exception codes for more details'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将我们的异常与异常代码连接起来以获取更多详细信息'
- en: '#4 If we received a specific ach_files_id, then use that to filter our results
    by appending a WHERE clause.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 如果我们收到了特定的 ach_files_id，则使用它来通过附加 WHERE 子句过滤我们的结果。'
- en: '#5 Executes the query and returns the results'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 执行查询并返回结果'
- en: Our test should be passing. If we step through the code and examine the response
    that we receive, we should see the `batch_id` and `entry_id` are both set to `None`,
    as shown in the example response.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试应该通过。如果我们逐步执行代码并检查我们收到的响应，我们应该看到 `batch_id` 和 `entry_id` 都被设置为 `None`，如下例响应所示。
- en: Listing 8.26  Example response
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.26  示例响应
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We may consider updating our SQL query to set those returned values to empty
    strings by using `COALESCE`—for example, `COALESCE(afe.ach_records_type_5_id,`
    `'') AS batch_id`. However, because we have defined our Pydantic models to expect
    a UUID, and the empty string is not a valid UUID, we will receive an `InvalidText­Representation`
    error. Because we are returning JSON, a better alternative may be to drop this
    value from the response. Note that this may not always be the best option. For
    instance, if we wanted to note the explicit absence of the value, it may be desirable
    to return something to indicate the value is missing. However, for our purpose,
    dropping the value works just fine. The following listing shows how to drop the
    `None` value from our response. Since we are not interested in it, we will see
    that our UI will handle the missing value without our help.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑更新我们的 SQL 查询，使用 `COALESCE` 将返回的值设置为空字符串——例如，`COALESCE(afe.ach_records_type_5_id,
    '' ) AS batch_id`。然而，因为我们已经定义了 Pydantic 模型以期望一个 UUID，而空字符串不是一个有效的 UUID，我们将收到一个
    `InvalidTextRepresentation` 错误。因为我们返回 JSON，更好的替代方案可能是从响应中删除此值。请注意，这不一定总是最佳选择。例如，如果我们想指出值的明确缺失，可能希望返回某种表示值缺失的东西。然而，对于我们的目的，删除值就足够了。以下列表显示了如何从我们的响应中删除
    `None` 值。由于我们对此不感兴趣，我们将看到我们的 UI 将在没有我们帮助的情况下处理缺失的值。
- en: Listing 8.27  Dropping `None` values from our model
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.27  从我们的模型中删除 `None` 值
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#1 Drops the fields containing None'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 删除包含 None 的字段'
- en: With the `response_model_exclude_none` set to `True`, we should be ready to
    move on to the UI to start taking advantage of our exception API. Now that we
    have declared several endpoints within files.py, we want to ensure that we are
    paying attention to the order we declare them in. We make sure that we are going
    from general endpoints such as `/files` and `/exceptions` to more specific, such
    as `/{file_id}/exceptions`. If we encounter a `422` `error`, it could be an indication
    that FastAPI has picked up the wrong endpoint to use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `response_model_exclude_none` 设置为 `True` 后，我们应该准备好将注意力转向 UI 以开始利用我们的异常 API。现在我们已经声明了文件.py
    中的多个端点，我们想要确保我们注意到的声明顺序。我们确保我们从一般端点，如 `/files` 和 `/exceptions`，到更具体的端点，如 `/{file_id}/exceptions`。如果我们遇到
    `422` 错误，这可能表明 FastAPI 选择了错误的端点来使用。
- en: 8.6.1 Retrieving an unparsed record
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.1 获取未解析记录
- en: Another piece of functionality we need for the dashboard is the ability to retrieve
    an unparsed record from the database. As we have seen, when there is a parsing
    exception, we are not writing the parsed record out. It will be helpful to an
    end-user if they can see what the record causing the exception looked like. Of
    course, they could pull up the file themselves and look at it, but that is not
    very user friendly. We would also recommend passing the record back all the time
    (which would make this request more straightforward) because the unparsed record
    could contain nonpublic information (NPI) data. By creating this as a separate
    endpoint that returns the record, say when a button or icon is clicked, we can
    call out to the specific endpoint to retrieve the data, which allows us to take
    preventative measures such as
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为仪表板添加的另一项功能是从数据库中检索未解析记录的能力。正如我们所见，当存在解析异常时，我们不会将解析后的记录写出来。如果最终用户能够看到导致异常的记录的样子，这将很有帮助。当然，他们可以自己打开文件并查看，但这并不友好。我们还建议始终传递记录（这将使此请求更直接），因为未解析的记录可能包含非公开信息（NPI）数据。通过创建一个单独的端点来返回记录，例如当按钮或图标被点击时，我们可以调用特定的端点来检索数据，这使我们能够采取预防措施，例如
- en: Hiding the button to display the record when the user is not authenticated.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户未认证时隐藏显示记录的按钮。
- en: Creating an audit trail when the information is viewed
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查看信息时创建审计跟踪
- en: Preventing needless data from being returned since users will not always need
    to see the unparsed record
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止不必要的数据被返回，因为用户并不总是需要看到未解析的记录
- en: We can start by creating a scenario to test this approach.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以首先创建一个场景来测试这种方法。
- en: Listing 8.28  Scenario for an unparsed record
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.28  未解析记录的场景
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 Scenario for an unparsed records API'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 未解析记录 API 的场景'
- en: '#2 Contains the entire unparsed record'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 包含整个未解析记录'
- en: The following code creates a step that helps support the retrieval of the unparsed
    record for a given exception. We assume that we are only getting one file returned
    and that the only exception is the one we want. Later, we may need to make the
    code more robust, but there is no need for now.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个步骤，有助于支持获取给定异常的未解析记录。我们假设我们只返回一个文件，并且唯一的异常就是我们想要的。稍后，我们可能需要使代码更健壮，但现在没有必要。
- en: Listing 8.29  Step definition for retrieving an unparsed record
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.29  获取未解析记录的步骤定义
- en: '[PRE29]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '#1 Similarly to previous API tests, we must make several calls to drill down
    to the data we are interested in. With each API call, we must validate a successful
    200 response code before moving on to prevent errors in subsequent calls.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 与之前的 API 测试类似，我们必须进行多次调用以深入到我们感兴趣的数据。在每次 API 调用中，我们必须在继续之前验证成功的 200 响应代码，以防止后续调用中的错误。'
- en: '#2 We store the results of our final API call for further use.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们将最终 API 调用的结果存储起来以供进一步使用。'
- en: 'If we run this code, we are likely to get a `404` `error` since we have not
    defined an endpoint. You should see one of the `client.get` calls failing with
    the error:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们可能会得到 `404` 错误，因为我们尚未定义端点。你应该看到 `client.get` 调用中的一个失败，错误如下：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What steps need to be taken to fix this error?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 需要采取哪些步骤来修复此错误？
- en: We need to create a new route to get the unparsed record for a given `exception_id`
    in the files.py.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在文件.py 中创建一个新的路由来获取给定 `exception_id` 的未解析记录。
- en: We update the ach_exceptions_sql.py to return the `unparsed_record` from the
    database.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更新了 ach_exceptions_sql.py 以从数据库中返回 `unparsed_record`。
- en: We will cover this code in chapter 9 when talking about auditing. For now, feel
    free to take a shot at completing it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 9 章讨论审计时介绍此代码。现在，请随意尝试完成它。
- en: 8.7 Insights into exceptions with the UI
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 通过UI了解异常
- en: In previous sections, we have built the ability to create exception files, identify
    those exceptions, log them appropriately, and finally return the information from
    an API. Now, we can look at how to incorporate viewing the exceptions in our dashboard.
    We likely want to provide the users with successively more specific views that
    drill down into the exceptions. For example,
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经构建了创建异常文件、识别这些异常、适当地记录它们，并最终通过API返回信息的功能。现在，我们可以看看如何将查看异常的功能整合到我们的仪表板中。我们可能希望为用户提供越来越具体的视图，以便深入到异常中。例如，
- en: Exceptions for all files are useful for operations to get a sense of the exceptions
    in the system and for analyzing the number/types of exceptions being encountered.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有文件的异常有助于操作人员了解系统中的异常，并分析遇到的异常的数量/类型。
- en: Exceptions for a specific file could be useful for determining if the file needs
    to be removed and reprocessed.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于特定文件的异常可能有助于确定文件是否需要被移除并重新处理。
- en: Exceptions for a specific batch are useful for determining if a particular company
    is having a problem. Also, a file could still be processed with only a specific
    batch being rejected.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于特定批次的异常有助于确定是否有特定公司存在问题。此外，即使只有特定批次被拒绝，文件仍然可以处理。
- en: Exceptions for a specific entry may be useful to work with a client or company
    to resolve what caused an exception.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于特定条目的异常可能有助于与客户或公司合作解决导致异常的原因。
- en: Is it necessary to provide all these views? Certainly, the customers will have
    their input, and the business will provide us with direction. In addition, the
    business will take our input as well. Some of these may be easier or more efficient,
    depending on how things are set up. In our case, we can easily provide exceptions
    for all files and specific files, so we will start there.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 提供所有这些视图是否必要？当然，客户将会有他们的意见，业务将为我们提供指导。此外，业务也会考虑我们的意见。这些可能更容易或更高效，具体取决于事情是如何设置的。在我们的情况下，我们可以轻松提供所有文件和特定文件的异常，所以我们将从这里开始。
- en: 8.7.1 Showing all the exceptions
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.1 显示所有异常
- en: The easiest way to get insight into all exceptions is to provide a navigation
    button on the left-hand side of the screen to view all our exceptions for the
    day (we say “day,” but we are going to leave filtering by day as an exercise for
    you). Remember that, eventually, to provide a better UX, we need to offer users
    the ability to search and filter. Multiple ACH files will be loaded daily and
    users will soon become overwhelmed, or the dashboard will become unresponsive
    if we are not careful with the amount of data we are pushing to the user. When
    we get to the point where the number of exceptions starts causing problems with
    the performance and UX, we will need to look at limiting the data by providing
    pagination, searching capabilities, and other strategies to limit the data being
    retrieved at a time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有异常的最简单方法是在屏幕左侧提供一个导航按钮，以便查看当天所有异常（我们说“当天”，但我们将把按天过滤作为你的练习）。记住，最终，为了提供更好的用户体验，我们需要提供用户搜索和过滤的能力。每天将加载多个ACH文件，如果用户很快就会感到不知所措，或者如果我们不小心推送的数据量过大，仪表板可能会变得无响应。当我们到达异常数量开始影响性能和用户体验的程度时，我们需要考虑通过提供分页、搜索功能和其他策略来限制每次检索的数据量。
- en: With that in mind, we can review updating NavButtons.tsx to navigate to the
    exceptions page.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以审查更新NavButtons.tsx以导航到异常页面。
- en: Listing 8.30  Adding the error navigation to the dashboard
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.30 向仪表板添加错误导航
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we have the button, we will need to create the actual page. The page should
    meet the following requirements:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了按钮，我们就需要创建实际的页面。该页面应满足以下要求：
- en: Displays a list of all exceptions
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有异常的列表
- en: Allows viewing the record causing the exception
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许查看导致异常的记录
- en: Enables navigation to the file when the row is clicked
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当行被点击时，允许导航到文件
- en: Those are some straightforward requirements. Let’s see how to accomplish them.
    First, we want to display the exceptions using a DataGrid element as we did for
    some of the other data on our pages. Recall that the DataGrid element from Material
    UI (MUI) allows us to sort, search, and filter, making it fully functional with
    very little work on our part. The following listing shows the basic API call used
    to retrieve exceptions from http://localhost:8000/api/v1/files/exceptions and
    populate them to our
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些直接的要求。让我们看看如何实现它们。首先，我们希望使用数据网格元素显示异常，就像我们在页面上的一些其他数据上所做的那样。回想一下，Material
    UI（MUI）的数据网格元素允许我们排序、搜索和过滤，使得它在我们很少的工作下就能完全功能化。以下列表显示了用于从http://localhost:8000/api/v1/files/exceptions检索异常并填充到我们的数据网格的基本API调用。
- en: DataGrid.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 数据网格。
- en: Listing 8.31  API Calls to populate the DataGrid
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.31  填充数据网格的API调用
- en: '[PRE32]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#1 The URL for our API'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们API的URL'
- en: '#2 Axios call to get all exceptions'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 发起Axios调用以获取所有异常'
- en: With DataGrid, we are taking another approach to show additional functionality
    (listing 8.32). We define a column consisting of an info icon and use `renderCell`
    to add the icon. This can be a handy way to control the contents of the cell,
    especially in the case where we are not mapping something directly to our table.
    We also make use of another function—the `valueGetter`—to convert the date we
    receive using our `convertDateFormat` we have defined previously.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据网格，我们采取了另一种方法来展示额外的功能（列表8.32）。我们定义了一个包含信息图标的列，并使用`renderCell`添加图标。这可以是一个方便的方式来控制单元格的内容，尤其是在我们不直接将某些内容映射到表格的情况下。我们还利用了另一个函数——`valueGetter`——来转换我们使用之前定义的`convertDateFormat`接收到的日期。
- en: Listing 8.32  Defining the DataGrid
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.32  定义数据网格
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 Defines a clickable icon that can be used to show the unparsed record'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了一个可点击的图标，可以用来显示未解析的记录'
- en: '#2 The grid of exceptions uses the MUI DataGrid component.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 异常网格使用MUI数据网格组件。'
- en: '#3 Reuses our AlertMessage component and shows the exception record'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 重新使用我们的AlertMessage组件并显示异常记录'
- en: 'With our API and DataGrid complete, we should now be able to upload a file
    with an exception, navigate to this page, and see our exception listed. When the
    info icon is clicked, we render a static message as a placeholder. Instead of
    that static message, let’s use an API call instead to retrieve the actual record
    so we can display the unparsed record. Why not return the unparsed record when
    we pass the list of exceptions back? We could certainly do that; however, there
    are a few reasons to avoid it:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的API和数据网格完成后，我们现在应该能够上传一个包含异常的文件，导航到这个页面，并看到我们的异常被列出。当点击信息图标时，我们渲染一个静态消息作为占位符。为什么不使用API调用而不是静态消息来检索实际记录，以便我们可以显示未解析的记录？我们当然可以这样做；然而，有一些原因要避免这样做：
- en: '*Passing back unnecessary dat**a*—Since it is unlikely that a user is going
    to click on every exception in the list, a lot of that data will remain unused.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*返回不必要的数据***——由于用户不太可能点击列表中的每个异常，因此大量数据将保持未使用状态。'
- en: '*Separation of dutie**s*—We want this API to function as an overview of our
    exceptions. Returning the data using a separate API call helps keep the code for
    the API and SQL simpler.'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*职责分离**——我们希望这个API作为我们异常的概述。使用单独的API调用返回数据有助于保持API和SQL代码的简单性。'
- en: '*Security consideration**s*—The unparsed records could have account numbers
    and other sensitive NPI data that we do not want to be passed back all the time.
    By making it a separate API call, we can control who may be able to view those
    details and also log exactly when someone views that data.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*安全考虑***——未解析的记录可能包含账户号码和其他我们不希望总是传递回的敏感NPI数据。通过将其作为单独的API调用，我们可以控制谁可能能够查看这些详细信息，并且可以精确记录某人何时查看这些数据。'
- en: With the understanding that showing the unparsed record could open up showing
    NPI data, we can make a call to get the unparsed record and display it in the
    alert box. Of course, we may eventually want to make use of the other details
    we have for the exception and create a better-formatted window. For now, simply
    displaying the record in question is enough. We can use the `params.row` to retrieve
    the needed information from the row that was clicked. The following listing shows
    the updated code that goes into the icon button.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解显示未解析的记录可能会打开显示NPI数据的功能，我们可以调用API获取未解析的记录并在警告框中显示它。当然，我们最终可能希望利用我们为异常保留的其他详细信息来创建一个格式更好的窗口。目前，仅显示相关的记录就足够了。我们可以使用`params.row`从点击的行中检索所需信息。以下列表显示了放入图标按钮的更新后的代码。
- en: Listing 8.33  The updated icon button
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Retrieves the IDs for both the file and exception for the row'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Our API URL'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Axios call to get the unparsed record'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Upon response, sets the unparsed record and the Boolean for the dialog'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '#5 If there is an error, shows it in the dialog instead'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: We now have a way to view exceptions and the record causing the error. That
    should be useful to our end-users. However, should they click on exceptions whenever
    an ACH file is uploaded? Let’s update our initial Recent ACH Uploads screen to
    have an indicator next to the filename when it is a file that has exceptions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.2 A visual cue for exceptions
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we first view our dashboard, there should be some indication that a loaded
    file has exceptions. We do this by updating our dashboard to include an icon whenever
    a file contains exceptions. We make the following updates:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: SQL query needs to return a Boolean value indicating a file has exceptions.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: API needs to return the new field as `has_exceptions`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UI needs to check this field to display an icon when it is true.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We first create a couple of test scenarios so that we can work on the first
    two items on our list. The following listing shows the newly added scenarios.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.34  Scenarios testing `has_exceptions`
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `get_files_response` can be updated to include the `has_exceptions` field.
    The following listing shows how we use a Common Table Expression (CTE) to get
    a list of unique `ach_files_id` values and then convert those to a Boolean value
    to use in `has_exceptions`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.35  Updating SQL for `get_files_response`
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#1 Creates a CTE to get the distinct file IDs'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses a case statement to set a Boolean field called has_exceptions'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Since not every file has exceptions, uses LEFT JOIN'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: And now we can update the UI to support the new `has_exceptions` field as well.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.36  Updated API mapping
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '#1 The new field to determine if a file has exceptions'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: And the updated RecentAchUploads.tsx
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.37  Displaying an error icon
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '#1 If a file has exceptions, displays an icon to indicate it has them'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: With that, when an ACH file with exceptions is uploaded, there should be a visual
    indication on our Recent ACH Uploads, as shown in figure 8.4.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a computer screen  Description automatically generated](../Images/CH08_F04_Kardell.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4  Visual indication of a file error
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 8.8 Additional UI changes
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the basic structure of our exception viewing, we can take care
    of a few other requests that came from users during the initial MVP evaluation.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The files screen should also show the specific exceptions for that file. This
    should follow after our initial exception handling. We can refactor our UI exception
    page to become a component and pass the needed exception information into it.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The batch screen should contain a component with statistics such as totals and
    a line-item breakdown of the transaction codes.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our listing of the items in the batch should contain the applications they are
    associated with, such as Checking, Savings, and so forth. While the transaction
    codes relate to those applications, ensuring they are included in our DataGrid
    will provide a better UX.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在批次项目列表中应包含它们关联的应用程序，例如检查、储蓄等。虽然交易代码与那些应用程序相关，确保它们包含在我们的 DataGrid 中将提供更好的用户体验。
- en: Our screens should be more responsive to size changes. Currently, our components
    are stacked in a column, and we would like to have them use up the available width
    as well.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该对尺寸变化更加敏感。目前，我们的组件按列堆叠，我们希望它们也能使用可用宽度。
- en: 8.8.1 Creating an exceptions component
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.1 创建异常组件
- en: We can refactor our page to create an exception component, which will help prevent
    code duplication when we want to present errors elsewhere. The exception information
    that we need to display is the same, regardless of whether we want to view all
    exceptions or just filter them by file. On the one hand, that means we could easily
    copy and paste that existing page to create a new page or component that filters
    on our file, and we would be done. On the other hand, we could create a common
    exception component that both pages can use, passing to it either the full list
    of exceptions or one that has been filtered for a particular file. As we have
    stated previously, whenever feasible, we want to avoid duplicating work as that
    may pay off in the short term by getting something out the door, but future maintenance
    becomes difficult and tedious as fixes must be applied multiple times. The following
    listing shows the results of pulling the DataGrid and the associated calls from
    the original page into a stand-alone component.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将页面重构以创建一个异常组件，这有助于我们在其他地方展示错误时防止代码重复。我们需要显示的异常信息是相同的，无论我们是要查看所有异常还是仅按文件过滤它们。一方面，这意味着我们可以轻松地复制并粘贴现有页面来创建一个新的页面或组件，该页面或组件可以按我们的文件进行过滤，并且我们就完成了。另一方面，我们可以创建一个通用的异常组件，两个页面都可以使用，传递给它的是完整的异常列表或为特定文件过滤过的列表。正如我们之前所述，只要可能，我们希望避免重复工作，因为这可能在短期内通过将产品推出市场而获得回报，但未来的维护变得困难且繁琐，因为必须多次应用修复。以下列表显示了将
    DataGrid 和相关调用从原始页面拉入独立组件的结果。
- en: Listing 8.38  Stand-alone exception component
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.38  独立异常组件
- en: '[PRE39]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With our new exceptions component, we can include it in the existing `fileDetails`
    page by calling the `/file/{fileId}/exceptions` endpoint to get a list of exceptions
    for the file we are viewing and passing the results to our new component. The
    following listing shows the required changes.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新的异常组件，我们可以通过调用 `/file/{fileId}/exceptions` 端点将其包含在现有的 `fileDetails` 页面上，以获取我们正在查看的文件的异常列表，并将结果传递给我们的新组件。以下列表显示了所需的更改。
- en: Listing 8.39  Using our new component
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.39  使用我们的新组件
- en: '[PRE40]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#1 Sets the returned exceptions'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 设置返回的异常'
- en: '#2 Includes our new component passing the exceptions to it'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 包含了我们新的组件，该组件将异常传递给它'
- en: We love how by creating components, it becomes so easy to import and use them
    anywhere we may need them. The only thing we want to stress about this is to be
    careful about the data that a component may need or fetch. We may have to evaluate
    whether we want to pass data to it or have it request data itself. As we saw previously
    with the dashboard, sometimes we can save redundant API calls by passing the required
    data in. We did leave the fetching of our unparsed records within the component
    because those are occasional calls that are best encapsulated in the component.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常喜欢通过创建组件，使其变得如此容易在任何需要的地方导入和使用。我们唯一想强调的是要小心组件可能需要或获取的数据。我们可能必须评估我们是否想传递数据给它或让它自己请求数据。正如我们之前在仪表板中看到的那样，有时我们可以通过传递所需数据来节省冗余的
    API 调用。我们确实将未解析记录的获取留在了组件内部，因为这些是偶尔的调用，最好在组件中封装。
- en: 8.8.2 Batch statistics component
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.2 批量统计组件
- en: We can now tackle the batch statistics component. This request is meant to give
    users a quick overview of some important aspects of the batch, as shown in figure
    8.5\.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以处理批量统计组件。这个请求的目的是使用户快速了解批次的某些重要方面，如图 8.5 所示。
- en: '![A screenshot of a statistics  Description automatically generated](../Images/CH08_F05_Kardell.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![统计截图，描述自动生成](../Images/CH08_F05_Kardell.png)'
- en: Figure 8.5  Batch statistics component
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5  批量统计组件
- en: While charts and graphs provide nice visualizations and can help compare large
    amounts of data, we will use a simple list for this component as we only need
    to provide a handful of totals for our overview.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图表和图形提供了很好的可视化效果，可以帮助比较大量数据，但我们将使用简单的列表来构建此组件，因为我们只需要提供一些概述的总数。
- en: We will continue to use the existing `AchBatch­EntriesResponse` for this component.
    Using a simple list and items from MUI, we can create our component. We use the
    `ListItemText` for displaying primary and secondary text. We also create some
    of the elements with `createListItems` and include them in the render. The following
    listing shows our basic component.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用现有的 `AchBatch-EntriesResponse` 为此组件。使用简单的列表和 MUI 中的项目，我们可以创建我们的组件。我们使用
    `ListItemText` 来显示主要和次要文本。我们还使用 `createListItems` 创建了一些元素并将它们包含在渲染中。以下列表显示了我们的基本组件。
- en: Listing 8.40  The `AchBatchStatistics` component
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.40  `AchBatchStatistics` 组件
- en: '[PRE41]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '#1 Helper functions to collect, aggregate, and format data as necessary'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 辅助函数，用于收集、汇总和按需格式化数据'
- en: '#2 Includes any additional ListItem elements'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 包含任何额外的 ListItem 元素'
- en: In the following listing, we created the `computeBatchTotals` function to provide
    a sum of our debits, credits, and other amounts. We will end up supporting additional
    transaction codes, but for now, we will only be considering the transaction codes
    22 and 27\. Also, because the `AchBatchEntriesResponse` had formatted the amounts,
    we needed to strip those characters away. Ideally, we would like to go back and
    not have the response format those amounts, but that may not always be practical.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们创建了 `computeBatchTotals` 函数，以提供我们的借方、贷方和其他金额的总和。我们将支持额外的交易代码，但到目前为止，我们只考虑交易代码
    22 和 27。此外，由于 `AchBatchEntriesResponse` 已格式化金额，我们需要移除这些字符。理想情况下，我们希望返回并不要有格式化金额的响应，但这可能并不总是实用的。
- en: Listing 8.41  The `computeBatchTotals` function
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.41  `computeBatchTotals` 函数
- en: '[PRE42]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '#1 Initializes the BatchTotals object'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 初始化 BatchTotals 对象'
- en: '#2 We need to remove the currency formatting.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们需要移除货币格式'
- en: '#3 Returns the BatchTotals object'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回 BatchTotals 对象'
- en: In listing 8.42, we also create the `computeBatchStatistics` function that contains
    counts and amounts for each transaction. For simplicity’s sake of the code and
    testing, we create another function that spins through the entries in the batch.
    We group the items by their description because we will make use of that when
    we display them.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.42 中，我们还创建了包含每个交易的计数和金额的 `computeBatchStatistics` 函数。为了代码和测试的简便，我们创建了一个另一个函数，它会遍历批次的条目。我们根据描述对项目进行分组，因为我们将在显示时使用它。
- en: Listing 8.42  The `computeBatchStatistics f`unction
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.42  `computeBatchStatistics` 函数
- en: '[PRE43]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '#1 Defines a new map of the BatchStatistics'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个新的 BatchStatistics 映射'
- en: '#2 Each entry in the batch will be processed.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 批次中的每个条目都将被处理。'
- en: '#3 Removes the formatting from the amount'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 从金额中移除格式'
- en: '#4 Tries to get an entry for the description; if not found, initializes one'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 尝试获取描述条目；如果未找到，则初始化一个'
- en: '#5 Increments the count'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 增加计数'
- en: '#6 Uses the plus method from the Decimal package to maintain the amount'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用 Decimal 包的加法方法来维护金额'
- en: '#7 Saves the entry'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 保存条目'
- en: We are ready to add the `BatchStatistics` we returned to our component. We dynamically
    create our `ListItem` elements in a function named `createListItems`, which takes
    our map of items and returns an array of React elements, as the following listing
    shows. With this approach, we can create as many elements as needed and return
    them in one swoop. Of course, we would need to be careful not to create too many
    elements, or otherwise create something that will not provide a meaningful user
    experience.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好将返回的 `BatchStatistics` 添加到我们的组件中。我们通过一个名为 `createListItems` 的函数动态创建我们的
    `ListItem` 元素，该函数接受我们的项目映射并返回一个 React 元素数组，如下所示列表所示。使用这种方法，我们可以创建所需数量的元素，并一次性返回它们。当然，我们需要小心不要创建太多元素，否则可能会创建出不会提供有意义用户体验的东西。
- en: Listing 8.43  The c`reateListItems` function
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.43  `createListItems` 函数
- en: '[PRE44]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '#1 Defines an interface so that we can easily reference our data'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个接口，以便我们可以轻松引用我们的数据'
- en: '#2 Creates an empty array of nodes'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建一个空的节点数组'
- en: '#3 Creates a ListItem element'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建一个 ListItem 元素'
- en: '#4 Adds it to the array'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将其添加到数组中'
- en: '#5 Returns the array'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 返回数组'
- en: Finally, we can add some unit testing to this component. While we could have
    started with this approach, we also want to show that adding unit tests can be
    done at other points in our development as well. Typically, we add these unit
    tests at the point where we realize that we need something extra to process the
    data being returned. To make our testing easier, we will need to export the functions
    we used within the component. That may present opportunities to refactor the code
    to further remove the logic from the component, but for now, we will not take
    it that far.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为此组件添加一些单元测试。虽然我们可以从这种方法开始，但我们还希望展示在开发的其它阶段也可以添加单元测试。通常，我们在意识到我们需要额外的东西来处理返回的数据时添加这些单元测试。为了使我们的测试更容易，我们需要导出组件内使用的函数。这可能提供了重构代码以进一步从组件中移除逻辑的机会，但就目前而言，我们不会走那么远。
- en: Listing 8.44  Jest test for `computBatchTotals`
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.44  `computBatchTotals`的Jest测试
- en: '[PRE45]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '#1 Creates mock data'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建模拟数据'
- en: '#2 Passes it to our computeBatchTotals routine'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将其传递给我们的computeBatchTotals例程'
- en: '#3 Validates the result'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 验证结果'
- en: From there, we can add additional entries for the same transaction code, different
    transaction codes, and anything else we may be interested in testing. This is
    a great way to test some of the edge cases that may require us to deliberately
    provide data, especially if we need to test exception conditions. With this basic
    test, we can create additional tests and start evaluating test coverage before
    moving on to our next enhancement request.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以为相同的交易代码、不同的交易代码以及我们可能感兴趣测试的任何其他内容添加额外的条目。这是测试可能需要我们故意提供数据的边缘情况的好方法，特别是如果我们需要测试异常条件。有了这个基本测试，我们可以在进行下一个增强请求之前创建额外的测试并开始评估测试覆盖率。
- en: 8.8.3 Adding the application
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.3 添加应用程序
- en: A relatively straightforward request is to add an application column, as shown
    in figure 8.6\. While it is possible to determine the application from the transaction
    code for a better UX, we can provide the mapping as part of our returned data.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相对直接的要求是添加一个应用程序列，如图8.6所示。虽然从交易代码中确定应用程序以获得更好的用户体验是可能的，但我们可以在返回的数据中提供映射。
- en: '![](../Images/CH08_F06_Kardell.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6](../Images/CH08_F06_Kardell.png)'
- en: Figure 8.6  The batch entry screen with the added column
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6  添加了列的批量输入屏幕
- en: This type of request allows us to work through all the pieces of our application,
    letting us get another taste of the full stack experience using BDD. We can create
    a feature file named ach_entries_endpoint.feature containing the scenario, as
    shown in the following listing.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的请求使我们能够处理我们应用程序的所有部分，让我们再次体验使用BDD的全栈体验。我们可以创建一个名为`ach_entries_endpoint.feature`的特性文件，包含场景，如下所示。
- en: Listing 8.45  Our feature file and scenario
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.45  我们的特性文件和场景
- en: '[PRE46]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The scenario shares some similarities with how we tested the files endpoint;
    however, we chose to create a separate step definition file to support this feature.
    This decision allows us to keep the scenario-specific steps isolated and gives
    us the ability to test only this particular feature. The following listing shows
    some of the step definitions that support running the scenario.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 该场景与测试文件端点的方式有一些相似之处；然而，我们选择创建一个单独的步骤定义文件来支持这个功能。这个决定使我们能够将特定场景的步骤保持隔离，并赋予我们仅测试这个特定功能的能力。以下列表显示了支持运行该场景的一些步骤定义。
- en: Listing 8.46  Step definitions for our feature
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.46  我们特性的步骤定义
- en: '[PRE47]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With the ability to test the endpoint, we can now work on ensuring the application
    will be returned as part of the API. We can tackle these steps in several different
    orders, but we chose to start by updating the `AchBatchEntriesResponse` to include
    the application field, as shown in the following listing. This field is not coming
    from the database, and it is not technically part of the ACH file layout. Therefore,
    we limit the maximum length of the field to the longest word we plan on having
    there, which is “checking.”
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够测试端点之后，我们现在可以着手确保应用程序将作为API的一部分返回。我们可以以几种不同的顺序处理这些步骤，但我们选择首先更新`AchBatchEntriesResponse`以包括应用程序字段，如下所示。这个字段不是来自数据库，并且它不是技术上的ACH文件布局的一部分。因此，我们将该字段的最大长度限制为我们计划拥有的最长的单词，即“checking”。
- en: Listing 8.47  The updated `AchBatchEntriesResponse`
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.47  更新的`AchBatchEntriesResponse`
- en: '[PRE48]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '#1 Sets the max length for this field to the longest text we expect'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将此字段的长度设置为预期最长的文本'
- en: Next, we update our query to pass back the application name based on the transaction
    code using a `CASE` statement, as shown in listing 8.48\. As mentioned, there
    is some freedom in application naming. We could potentially choose to group both
    checking and savings accounts under the name Demand Deposit Accounts (DDA), which
    is another term used in the financial industry. The actual name for the application
    would be something that the business provides to us. We like having a bit more
    granularity in the application name, so we chose to use the names “Savings,” “Checking,”
    “GL” for General Ledger, “Loan,” and “Unknown” (to identify any transaction codes
    that we may have missed or in case of an incorrect transaction code in the database).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.48  Updated query to support the `transaction_code`
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '#1 Maps transaction codes to the application'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Names the resulting column as application'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we want to update our DataGrid to add the column. With all the heavy
    lifting already done by the server, we simply need to add the column and update
    the interface to include the application as well.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.49  Added column and field
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '#1 Includes the application column in our columns definition'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: We should now be able to navigate to our dashboard and drill down to see the
    application column being populated. This small example is a great way to illustrate
    why we love full stack development. We were able to work on unit testing, Python,
    APIs, and Typescript!
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 8.8.4 Making our UI more responsive
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, our dashboard components are stacked on top of each other. The MUI
    package that we have been using for our components provides options for controlling
    the layout that will help make our dashboard more responsive. We replace the `Box`
    elements that we wrapped our components in with a `Grid` container and `Grid`
    items. In addition, there are attributes `xs`, `sm`, `md`, `lg`, and `xl` that
    can be used to provide breakpoints based on screen size. This means that we can
    customize our layouts for all different screen sizes. The following listing shows
    an example of using a grid with various breakpoints. The given items will be displayed
    in a column when the screen is small, and when expanded, it will contain more
    items per row, with all nine items in a single row when the screen is wide enough
    to accommodate them.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.50  Example of a responsive grid
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '#1 Uses the latest Grid element'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines a container grid'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines nine elements'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Grid elements are different sizes based on breakpoints.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: After exploring the responsiveness of the layout, we can apply the same approach
    to our existing components. Using the `Grid` elements to clean up some of our
    existing layout, we move the paper elements into our components, leaving us with
    just the layout elements in our page.tsx components (not counting the API calls
    and other needed functions). The following listing shows an example of the resulting
    page.tsx for the batch details screen.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.51  The page.tsx for batch details
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.51  批次详情的page.tsx
- en: '[PRE52]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '#1 Defines a container'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个容器'
- en: '#2 Places each of our components in a Grid element'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将我们的每个组件放置在网格元素中'
- en: Breakpoints can be used with other attributes as well. For instance, if we wanted
    to adjust the amount of `margin-top`, we could set it based on the screen size,
    as shown in the next listing. Notice how the margin is set to a smaller value
    of 4 for smaller screens and then to 12 for larger ones.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 断点也可以与其他属性一起使用。例如，如果我们想调整`margin-top`的量，我们可以根据屏幕大小设置它，如以下列表所示。注意，对于较小的屏幕，边距设置为较小的值4，而对于较大的屏幕，则设置为12。
- en: Listing 8.52  The `margin-top` based on screen size
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.52  基于`margin-top`的屏幕大小
- en: '[PRE53]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Breakpoints offer a powerful way to help with our layout and design. We can
    update the default values (pixels) for each breakpoint and even rename them, as
    shown in the following listing.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 断点提供了一种强大的方式来帮助我们进行布局和设计。我们可以更新每个断点的默认值（像素），甚至可以重命名它们，如下面的列表所示。
- en: Listing 8.53  Customizing breakpoints
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.53  自定义断点
- en: '[PRE54]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This chapter covered a lot, focusing on providing feedback when uploading a
    file that is not formatted properly. Exception handling provides a way to gracefully
    handle unexpected situations within the software, giving us a chance to alert
    the user and recover as appropriate.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量内容，重点是提供在上传格式不正确的文件时的反馈。异常处理提供了一种优雅地处理软件中意外情况的方法，给我们机会提醒用户并适当地恢复。
- en: We started by looking at how we could expand our file-creation syntax to support
    adding these exceptions. Expanding the ability to produce files allows for easier
    and more robust file creation, which in turn gives us more files to load into
    our dashboard.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探讨了如何扩展我们的文件创建语法以支持添加这些异常。扩展生成文件的能力使得文件创建更加容易和健壮，这反过来又为我们提供了更多的文件可以加载到我们的仪表板中。
- en: In terms of ACH handling and Pydantic, we focused on how defining our fields
    provided us with validation without the need for a lot of code. We were able to
    limit the field length, validate formatting with regular expressions, and even
    go back to a database to validate entries. We also added support for handling
    exceptions, which allowed us to get another taste of full stack development—by
    updating the backend, providing APIs to allow access to data, and finally providing
    UI elements to view the data.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在ACH处理和Pydantic方面，我们关注了如何定义我们的字段为我们提供了验证，而无需大量代码。我们能够限制字段长度，使用正则表达式验证格式，甚至回数据库验证条目。我们还添加了对异常处理的支持，这让我们有机会再次体验全栈开发——通过更新后端，提供API以允许访问数据，最后提供UI元素来查看数据。
- en: Finally, we had the chance to expand our UI by adding new components, refactoring
    what was already being used, and looking at how to manipulate our layouts using
    breakpoints in MUI.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有机会通过添加新组件、重构现有组件和查看如何使用MUI中的断点来操纵布局来扩展我们的UI。
- en: Summary
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: After launching the MVP, user feedback highlighted both positive reception and
    areas for improvement, particularly the need for handling a wider variety of ACH-related
    exceptions.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVP发布后，用户反馈突出了积极的接受和改进领域，特别是处理更广泛的ACH相关异常的需求。
- en: Planning enhancements involves prioritizing features based on user feedback
    and working on a timeline to implement ACH exceptions and search functionality.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划增强功能涉及根据用户反馈优先排序功能，并制定时间表以实现ACH异常和搜索功能。
- en: Exceptions in ACH processing can be categorized into errors, exceptions, and
    warnings, each with different severity and handling implications.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACH处理中的异常可以分为错误、异常和警告，每种都有不同的严重性和处理含义。
- en: Creating ACH files with exceptions involves extending BDD syntax to support
    file, batch, and entry-level exceptions for more robust testing and processing.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有异常的ACH文件涉及扩展BDD语法以支持文件、批次和条目级别的异常，以实现更健壮的测试和处理。
- en: Enhancing exception handling in ACH parsing includes using Pydantic for field
    validation and storing detailed exception information in the database.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ACH解析中增强异常处理包括使用Pydantic进行字段验证和在数据库中存储详细的异常信息。
- en: Exceptions API development focuses on enabling effective reporting and search
    capabilities, providing insights into file-specific errors.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常API开发侧重于启用有效的报告和搜索功能，提供对文件特定错误的洞察。
- en: The UI is updated to display exceptions, incorporating components for viewing
    and filtering errors, with features such as DataGrid for interactive data presentation.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI已更新以显示异常，包括用于查看和过滤错误的组件，以及如DataGrid等用于交互式数据展示的功能。
- en: Additional UI enhancements include creating reusable components, statistics
    for batches, and improving layout responsiveness using the MUI grid system.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他UI增强包括创建可重用组件、批次的统计数据，以及使用MUI网格系统改进布局响应性。
- en: Utilizing unit testing and BDD helps ensure robustness and flexibility in handling
    ACH exceptions, while UI updates enhance UX and interaction with data.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用单元测试和BDD有助于确保处理ACH异常时的健壮性和灵活性，同时UI更新提升了用户体验和数据交互。
