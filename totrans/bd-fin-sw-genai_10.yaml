- en: 8 Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Initial feedback from the MVP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning and addressing user requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying different types of exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring our UI is responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In chapter 7, we successfully launched our minimum viable product (MVP) to our
    user base to help solicit feedback and drive enhancements to the product. The
    feedback varied significantly—from users who loved the new direction of the dashboard
    to those who expressed their dissatisfaction, feeling it was missing too much
    functionality although it was not meant to be a full replacement yet. The business
    now wants us to both capitalize on what went well and address some of the missing
    functionality the users are currently clamoring for.
  prefs: []
  type: TYPE_NORMAL
- en: By far, the biggest need recognized in our MVP was having a wider variety of
    ACH-related exceptions and making their handling possible within the user interface.
    This chapter identifies different categories of exceptions and ways to identify
    and potentially recover from them.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Planning enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The benefit of providing our target audience with an MVP is that we can get
    feedback from them and then use it to determine which features need to be added
    to the software. This advantage allows us to concentrate on items that deliver
    the most value. In this instance, we want to focus on providing a way to view
    ACH exceptions in the UI, as well as to search through our loaded files, which
    will help us find a much-needed and practical enhancement to the application as
    users must be aware of exceptions that prevent further processing of ACH files.
    This is especially valuable because we focus on Prearranged Payment and Deposit
    (PPD) ACH transactions, meaning that payroll and bill payments are at risk of
    not being processed.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on our circumstances, we may have a normal sprint to complete our
    work, or if the need is dire enough, we may be expected to turn around changes
    and fixes sooner. We will also likely see user stories written for these items,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: As an operator, I want to be able to view processing exceptions and be aware
    of potential ACH problems that need to be resolved so that transactions are not
    delayed in posting to a customer’s account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an operator, I want to be able to search for specific transactions so I can
    research items for customer inquiries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In either case, providing stakeholders with a timeline or Gantt chart for the
    project can be beneficial. These visualizations are especially helpful if we find
    ourselves with a hard deadline. We often work backward from that deadline, trying
    to complete the expected tasks, while fitting them all within the allotted time.
    Of course, the required timeframe may not be possible, and having it laid out
    for management is a great way to help make our case for more time should we need
    it. Again, we rely on PlantUML to provide us with a simple Gantt chart we can
    share with the stakeholders. The following listing shows the required syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.1  PlantUML syntax for a Gantt chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Excludes weekends from our chart because we do not want to work overtime'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 A header for the chart'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a visual break in the chart'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Creates a task with a start time and duration'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Tasks can be dependent on other tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: This listing produces the chart shown in figure 8.1\. As we mentioned, such
    charts are helpful for visualizing the work and are often appreciated by project
    stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a project  Description automatically generated](../Images/CH08_F01_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 A Gantt Chart for our enhancements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we have outlined the initial work for this sprint, we can start tackling
    the steps needed to add exceptions to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Exceptions and warnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that we prefer working here in short development cycles, as shown in
    figure 8.2\. In step 1, we need to create an ACH file with our desired exception
    condition, which means we will be updating the `ach_file_creation.feature` and
    associated test_create_ach_files.py to support creating files with our desired
    exception. In step 2, we support the new exception by updating the ach_file_processor.py,
    either by diving right in and starting to work on it or by creating unit tests
    in a more test-driven development (TDD) fashion. Finally, in step 3, we update
    the actual UI for the dashboard to support viewing and displaying of the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Although the steps are going to be covered in separate sections, note that we
    would likely be working on each individual exception through these general steps.
    And as we work through each exception, we will notice improvements/refinements
    that can be made.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software system  Description automatically generated](../Images/CH08_F02_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 Flowchart representing our short development cycle
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, we need to define exactly what we mean when we use the terms “exception,”
    “error,” and “warning.” They may seem somewhat interchangeable, but for our purposes,
    we would like to provide some background information on what we have in mind when
    talking about each. Please bear in mind that these are our own definitions and
    not a reflection of any fintech or Nacha standards.
  prefs: []
  type: TYPE_NORMAL
- en: '*Erro**r*—A condition that prevents processing from taking place. We can think
    of errors as conditions such as an incomplete file upload or a bug in our software
    that causes processing to halt. Some conditions would cause an error, such as
    having a record with a record type code that does not exist in the ACH standard
    (e.g., record type code 2) because we do not have a place for this record in the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Exceptio**n*—A business condition that would prevent file processing, which
    could include an improperly formatted file, invalid data in the file, or conditions
    the business has defined that should stop processing. Examples of these business
    conditions may be transactions over certain amounts, flagged customers, or other
    transaction activity that may cause concern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Warnin**g*—A business condition that requires notification but does not necessarily
    prevent the file from being processed. Warnings may allow us to show leniency
    in enforcing ACH rules for files or customers. For instance, if the count on a
    control record is incorrect, the business may allow this discrepancy and process
    the file anyway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, there are slight differences in the conditions and responses
    for these different categories. We should also have the recovery or research steps
    documented clearly in case an error is encountered. We have been involved in supporting
    software in the middle of the night where an explicit check was done within the
    code but without any indication of why the condition may occur, how to resolve
    it, or whether it is important. More than once, it was not important enough to
    stop the processing, and the code would be commented out so the check could be
    bypassed. This story illustrates the need to determine the severity of exceptions,
    and when and where they should be reported. Figure 8.3 shows a flowchart that
    can help you when deciding whether an exception needs to halt processing or it
    can be handled differently.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a flowchart  Description automatically generated](../Images/CH08_F03_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3  Flow chart for deciding how to handle errors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To summarize, we should be thinking about
  prefs: []
  type: TYPE_NORMAL
- en: Whether this is a problem that requires halting processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether it can be reported to the user in a timely manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether this is something that can wait but does need to be resolved eventually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too often, we may create alerts, messages, and reports that are ignored and
    dismissed by users before corrective action is taken. It can be a balancing act
    as different products or business needs require different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our software and development perspective, we must consider these different
    types of errors and warnings. It is also important to understand that the Federal
    Reserve has their own way of looking at a file’s ACH status. These statuses can
    be `accept`, `pend`, or `reject` and are exactly what you might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accept`—The file is good and has been accepted by the Federal Reserve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pend`—The financial institution must confirm that the file should be accepted
    or rejected. This usually happens when there is some potential exception that
    may occur due to the formatting or contents of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reject`—A condition/error causes the file to be rejected. This is an error
    state we may also end up with when the financial institution chooses to reject
    a file that was previously in a `pend` state or when the Federal Reserve flat-out
    rejects a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be noted that when files are corrected, there should be an audit trail.
    If a file is modified, the originator of the file may need to be notified. Otherwise,
    these changes may lead to confusion when attempting to research problems. We can
    imagine trying to speak with someone about a file where the file ID was corrected
    from a numeric to a letter without any indication it was done. It could lead to
    some frustrating interactions, with someone at the financial institution claiming
    not to see a file although the user clearly sees the transaction hitting their
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Creating ACH files with exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As part of the MVP in chapter 7, we created the `ach_file_creation.feature`
    that allowed us to easily create well-formatted files using the BDD-style syntax
    (known as Gherkin). Recall that it allowed us to create files as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This works well for that happy path that we often start with, but now we need
    to expand our code to address some possible exceptions so we can work on building
    the required functionality. In some cases, our syntax may help enforce proper
    formatting of the ACH file, and that’s obviously a good thing. We want the creation
    process to be easier than creating something by hand, but now we also want to
    add some flexibility to the files. Eventually, we may accept CSV or other formatted
    files that would make customizing the fields easy. For now, we can look to expand
    and hopefully improve our syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Creating ACH files with file-level exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'File-level errors and warnings will have to do with either the file header
    (type 1) or the file trailer (type 9) records. Many of the exceptions we might
    encounter stem from formatting problems with the file, and we would like to be
    able to introduce the following exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*File ID is not an uppercase letter in the range from A to Z or a number*.
    If it is a lowercase letter, the file could be rejected, or the financial institution
    could decide to fix it since it is a minor problem and easily corrected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The immediate destination should be our bank’s routing number*. This is important
    because we obviously want to ensure we are processing the correct file for the
    correct bank. If we were to receive a file that was intended for another institution,
    it could be categorized as information leakage, unauthorized disclosure, or inadvertent
    data sharing. Regardless of what we call it, there are serious implications in
    terms of customer privacy, and we may have legal and regulatory obligations. While
    a seemingly innocuous problem (e.g., the field didn’t match), it would be an all-hands-on-deck
    type event. In FinTech, there are all kinds of places where this may occur, especially
    when dealing with multitenant environments. For example, it could occur when storing/retrieving
    images, displaying transactions in a mobile or internet banking application, sending
    statements, or communicating to incorrect or unauthorized addresses. This change
    also requires us to maintain a list of routing numbers associated with the bank
    since we need to be able to validate them. Because of bank mergers or acquisitions,
    it may be possible for banks to have more than one routing number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking factor should never change but would be an error if it did. This gives
    us a chance to update our syntax to support setting fields and using the `get(field,`
    `default value)` so we do not need to have a lot of different syntax, which could
    then be expanded to support `padding-left`/`right`, `fill` `value`, and `length`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record size is similar to the blocking factor, and we always expect a 094. In
    theory, this field could be used to change the record format length, but in practice,
    systems typically just assume the 94 bytes and do not use the record size to read
    different-sized records. This does allow us to expand our checks to become more
    generic, exchanging constraints imposed by specific contexts and allowing more
    flexibility, but with that greater power comes more responsibility in knowing
    how to use it. For instance, we are adjusting the field offset for what is needed
    by Python. We could have left it starting at 1, so it aligned better with the
    ACH documentation and changed offsets within the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*File totals*. The file trailer record should match the computed totals for
    the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*File hashing*. Each batch control has a hash value that is added up, truncating
    the result as necessary to keep the 10 lower-order digits (rightmost digits).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3.2 Creating ACH files with batch-level exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we parse more of the file, we need to consider batch-level exceptions. These
    are specific to the batch records, and while they share some similarities to other
    exceptions, we may find they do not necessarily cause the entire file to be rejected.
    Instead, the batch itself could potentially be rejected by the system. In turn,
    that could cause the entire file to be rejected, or the financial institution
    could simply require the originator to send a new file. Some examples of batch-level
    exceptions are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An invalid effective date would cause a batch error as this is the necessary
    information for correctly posting the file. So, whether it is missing or formatted
    incorrectly, there is no way to recover it, and a new file is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid batch totals on the control record would cause a warning. In practice,
    this usually causes a file to be rejected, but it would also be possible to correct
    the given file so that the totals match the entries for the file to be accepted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad Standard Entry Codes (SEC) on a batch will cause an error and the batch
    to be rejected. There is a set list of viable SEC codes that can be used, and
    some of them change the parsing of the records. We have been focused on the SEC
    code of PPD (used in payrolls, bill payments, pensions, etc.) and will continue
    to do so in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3.3 Creating ACH files with entry-level exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Entry-level exceptions are interesting because aside from the usual formatting
    exception, they can be related more to the account in our system. Covering these
    exceptions requires more functionality in the system, but to give you a better
    idea of what we mean, let’s cover some of the common entry exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Invalid account numbe**r*—It could be related to formatting or simply not
    found on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Invalid amoun**t*—The amounts are formatted (e.g., such as including the decimal
    or containing spaces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Insufficient funds (NSF**)*—An account does not have funding for the transaction.
    This opens a lot of interesting possibilities for our project, from maintaining
    customer and account tables to assessing fees for transactions that cannot be
    processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3.4 Clean-up of our file creation syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the need to create additional files, we will be revisiting the BDD-style
    syntax we used to create our files. Often, this is a great place to gain some
    experience in refactoring code and finding little improvements to make the syntax
    or code more robust. Because these are normally internal facing, we can gain experience
    by reworking existing code and seeing the potential effects it may have.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we had the line `@then(parsers.re('I` `should` `have` `a` `file`
    `named "(?P<expected_file_name>.*)"'))`, but there is no need to specify the filename
    again. Not only does it cause potential problems if we copy/paste a scenario to
    create a similar one, but it is just unnecessary typing. Instead, since we already
    have the filename stored, we can update it to become `@then("I` `should` `have`
    `a` `file` `of` `the` `same` `name")`. Then the code can pull in the stored filename
    from `setup_info['filename']` to perform the check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another improvement we can look at is cleaning up the way we parsed the strings
    from some of our statements. We originally used regular expressions to capture
    the strings being used, and while that is not necessarily a problem, it does add
    a layer of potential confusion. We are reminded about the famous quote from Jamie
    Zawinski: “Some people when confronted with a problem think, ''I know, I’ll use
    regular expressions.’ Now they have two problems.” To fix this, we can replace
    our regular expressions such as `@given(parsers.re(r''I` `want` `to` `create`
    `an` `ACH` `file` `named` `"(?P<filename>.*)"''))` with a far simpler `@given(parsers.parse(''I`
    `want` `to` `create` `an` `ACH file` `named` `\"{filename}\"''))`. Keeping our
    code simple ensures it’s more maintainable and less error-prone to updates when
    we return to it in a year or two to add more improvements.'
  prefs: []
  type: TYPE_NORMAL
- en: What other improvements can be made? Remember that we should look to balance
    functionality and need. We can probably add a lot of bells and whistles, but if
    they go unused, was that really worth the extra work? That balance is especially
    important when talking about internal tools that do not necessarily add value
    that clients can see. Our stakeholders are unlikely to be impressed if we have
    a full-function ACH creation utility but nothing for them to actually process
    those files with!
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Expanding the ACH processing for exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When adding the exceptions to the parser, we’ll follow a TDD approach by creating
    a test that will validate the intended exception has been added to the database.
    With the TDD approach, we expect this test to fail, and then we’ll work on adding
    the required logic to have a passing test. This approach may not be for everyone,
    but we would encourage you to try it out, if nothing else, just for a different
    perspective on development.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 ACH exceptions in the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Originally, we stored some exception text in the database. However, we may want
    some finer controls and less redundant data. Therefore, we create a database type
    called `ach_exception_severity` to limit the entries that can be used when creating
    exceptions. The use of an `ENUM` allows us to ensure consistency in the type and
    reduce redundancy in our database. The downside is that `ENUM`s are not part of
    the SQL standard, and therefore, they may not be implemented in your relational
    database management system (RDBMS). While these examples assume the use of a Postgres
    database (which supports `ENUM`s), it is also possible to mimic this functionality
    with a separate table that provides the values we would use for the `ENUM` and
    a foreign key relationship in that table.
  prefs: []
  type: TYPE_NORMAL
- en: The following listing shows the creation of the `ENUM` type and our new `ach_exception_codes`
    table we use to store extended descriptions of the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.2  Creating the database `ENUM` and exception code table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates the ach_exception_severity type'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses our type as the datatype for a field'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create an exceptions table to keep track of our exceptions. There are
    a few approaches to this, where we have multiple tables for each specific entry
    (similar to having multiple ACH record types) and then tie them together with
    a view. However, here, we demonstrate using a single table that can hold references
    to other tables which contain the record we could look up the exception with.
    The following listing contains the `CREATE` `TABLE` statement. The important difference
    from our previous tables is that we use foreign key constraints, which allow `NULL`
    for the `ach_records_type_5_id` and `ach_records_type_6_id` fields because this
    information will only be populated when we have a record of that type with an
    exception. Note that every exception will be associated with a file, so we expect
    `ach_files_id` to be populated every time; therefore, we still have a `NOT NULL`
    constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.3  Creating the exceptions table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 These fields are not always used and can be NULL.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The exception code details are referenced in ach_exception_codes.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to our table is part of the database startup. We do this because
    these are standard errors we can consider being shipped with the product. Often,
    we find these types of tables or settings that are part of the setup for a financial
    institution.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.4  Adding data to the exceptions table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Each exception needs to be inserted into the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding this type of persistent data is necessary for the dashboard; however,
    it does add a level of complexity. Our tests become dependent on these tables
    being defined and the data populated. We also ran into a problem because our unit
    tests were truncating all tables to ensure the database was clean. The following
    listing shows the changes to a portion of the truncate script so that we can understand
    the needed changes to the `SqlUtils.truncate_all()`. We may want to consider updating
    the name (or at the very least the documentation) so that it is understood that
    `truncate_all` is not actually truncating all data anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.5  Updating the `truncate` script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We have tables that need to be skipped from our truncate logic as they contain
    hardcoded values.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we may not be overly burdened by this approach now, there will likely
    come a time when we’ll have to manage the test database a bit better. A popular
    option is to use Testcontainers ([https://testcontainers.com/](https://testcontainers.com/)),
    which allows us to create temporary Docker containers that contain our database
    and will not persist beyond the lifespan of our test. This provides obvious advantages
    when dealing with unit testing, especially when it comes to tests run within the
    CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.2 Recovery options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before updating the ACH parser to support our new exceptions, let’s take a moment
    to consider the flip side of logging exceptions—what to do when they are encountered!
    We want to consider exactly how users should recover from a problem. This can
    be especially true when dealing with loading transactions, which the dashboard
    could eventually be involved with. Since an ACH file is used to move money around,
    if our file fails to load or otherwise has error conditions, we may need to consider
    implications to user’s accounts. In other words, it may not be enough to just
    load a file and try again. We need to be able to ensure transactions will not
    be posted to the account again, resulting in customers being either credited or
    debited multiple times. At this point, our concerns do not need to be centered
    around those details, but it is important to provide some help to the user.
  prefs: []
  type: TYPE_NORMAL
- en: One scenario that comes to mind is encountering an exception being thrown, which
    involved comparing totals from two parts of the system. If the totals did not
    match, the processing halted, resulting in a call to a developer at 2 am. The
    concern was not an exception making us work at odd hours. If a critical processing
    exception occurs, we can expect occasional problems. Rather, the concern was about
    the recovery steps that should be taken when the error was encountered—there were
    none! The result was multiple developers having to get involved to figure out
    what needed to be done. It was determined the check could be safely bypassed,
    and we could follow up and investigate further the following day. Eventually,
    it was found the audit records were not written out as expected, which resulted
    in the totals being off, but the problem recurred several times before that was
    discovered.
  prefs: []
  type: TYPE_NORMAL
- en: While we do not have such concerns with our project right now, it would certainly
    be nice to provide users with some additional information. After all, the dashboard
    may eventually require its own internal help system, or perhaps a look at the
    exception will offer some advice on what actions can be taken. The following listing
    shows the creation of an `ach_recovery_options` table tied back to the `ach_exception_codes`
    table, allowing multiple entries to be associated with an exception code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.6  ACH recovery options table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Each recovery option should reference a specific exception.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The recovery option is simply text that the users can review for help.'
  prefs: []
  type: TYPE_NORMAL
- en: We can then prepopulate the table with our recovery options as part of our startup.
    The following listing shows some possible recovery options being inserted into
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.7  Prepopulating the recovery options
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The recovery options could certainly be expanded. However, at this point, we
    just want to ensure recovery and help is a consideration in our development. We
    should all be aware of the importance of clean code and comments to help us understand
    the code when we have to dive back into it in 6 to 12 months. Just as important
    is making sure that our software is usable by the end-user. Otherwise, we may
    find ourselves having to provide support for problems that users should be able
    to fix themselves. Defining help within the application and considering more extensive
    documentation and troubleshooting in a tool such as Confluence can be helpful
    to end-users and support staff. In the end, it will free you up to spend more
    time developing, and that is what we are all here for!
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Updating the ACH parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the database capable of supporting better exception handling, we can now
    work on updating the ACH parsing to write our exceptions. Many exceptions that
    we might encounter from a formatting perspective can be handled through Pydantic.
    We can continue to add constraints and validation to our Pydantic definitions,
    which will take many of the more tedious tasks out of our hands. Other exceptions
    may rely on examining more than just the fields of our record. For instance, ensuring
    that trace numbers are ascending is something that we would prefer to do outside
    of Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1 Creating unit tests for the exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already shown how to update our BDD-style syntax to create files with
    the needed errors. Then we can create the basic layout, as shown in the following
    listing. This approach should work just fine for testing, regardless of whether
    an exception was encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.8  Test for invalid immediate destination
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines initial variables so we can obtain a file to load'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We use an ENUM value so that the exception codes remain flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Inserts a needed dummy record for our insert'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Parses the file which loads it into the database'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Gets the exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Asserts that we have our one expected exception'
  prefs: []
  type: TYPE_NORMAL
- en: Considering the previous sample, we may notice that much of that code will be
    the same for each test. This is a perfect opportunity to recall that refactoring
    is one of the TDD phases. In this instance, we can refactor the code so that the
    processing of the file is generalized to one routine, and we call that with the
    expected values, as shown in the following listing. This approach still works
    well for these basic tests where we just want to confirm the exception has been
    caught. Since the `assert` raises an exception, we still see our error thrown
    from within the `test_incorrect_file_id_modifier` method.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.9  Refactored test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We create a function and pass the needed variables to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The called function contains the same logic of parsing and asserting the
    desired variables.'
  prefs: []
  type: TYPE_NORMAL
- en: With these basic tests, we can easily start adding exceptions to our code. Of
    course, more extensive testing will be done at some point, but this is a great
    way to get moving in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.2 Supporting the exceptions in our parser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin writing our exceptions, we have to add a schema that can hold the exception
    information. By providing the UUID for the file, batch, and entry, we have flexibility
    in reporting the exception at different levels. For instance, when an amount is
    invalid, we can drill down directly to the record causing the problem because
    we have access to the UUID for the file, batch, and entry. Compare that with if
    we only had the `ach_files_id` that caused the exception. If we had thousands
    of records in the file, we would have our work cut out for us, determining the
    offending record. The following listing shows our ACH exception schema. We have
    excluded the field definitions to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.10  The ACH exception schema
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We always associate exceptions with a particular file.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The record number helps locate the unparsed record.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The exception code helps locate the error details.'
  prefs: []
  type: TYPE_NORMAL
- en: We then continue creating our `AchExceptionsSql` class that has the usual `insert_record`
    and `get_record` methods. We could have named these `insert_exception` and `get_exception`,
    but to stay consistent with the other methods, we keep it similar to our existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.11  ACH exceptions SQL
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The exception class containing any SQL calls'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Standard SQL to insert and return the newly added ID'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns the first field from our results, which is the ID'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Standard SQL to read the exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can create exception records, we can simply call an `_add_exception`
    routine from ach_file_processor.py wherever we need to write out exceptions. Listing
    8.12 shows this exception routine. Notice that we take the `AchExceptionSchema`
    and the unparsed line as parameters. We chose to take the line as an optional
    parameter and write it out to an invalid record table. This is because we split
    out the individual record types in our database earlier. To accommodate conditions
    where we may have a record that could not be parsed because it was not a valid
    type, we still want to store it somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.12  Adding an exception method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Our function to call when we have an exception during processing'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 When a record has been passed, we need to write it to a special database
    table since we could not determine the correct table for it (e.g., a record type
    that does not exist).'
  prefs: []
  type: TYPE_NORMAL
- en: With the ability to create exceptions, we need to update our parsing methods
    to return a custom validation error. The individual field parsing does not change,
    but we want to capture the validation error and wrap it with a custom error.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.13  Updating parse routine
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Tries to parse the header with Pydantic'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Catches when a validation error is encountered'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a custom error that stores our ACH related information using the
    raise keyword'
  prefs: []
  type: TYPE_NORMAL
- en: The custom `AchParsingValidationError` is shown in the following listing. The
    purpose of the custom error is that we can translate the encountered errors to
    their equivalent `AchException` codes, which facilitates writing them to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.14  Custom ACH parsing error
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Our error is a subclass of Exception.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines a function to get a list of exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Processes each validation from the array self.validation_errors'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Translates the field having a problem to one of our exception codes'
  prefs: []
  type: TYPE_NORMAL
- en: Then we can update the individual parsing of the record to add the exceptions
    when encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.15  Updates to handle validation errors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We try to parse the record.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 For each error we find, it writes out an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: That provides a basic outline for handling of exceptions in the ACH parser.
    The same formula applies to the remaining record types.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.3 Validation in Pydantic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much of field-level validation will happen in Pydantic. Let’s take a look at
    some of the exceptions and how we can do them in Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: First, we would like to address the file ID modifier on the type 1 record. This
    should be an uppercase letter from A to Z or a numeric value from 0 to 9, which
    we can easily specify in Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.16  Pydantic validation of the file ID modifier
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We define a regular expression pattern to validate against.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We also limit the field size, although the pattern itself should be enough.'
  prefs: []
  type: TYPE_NORMAL
- en: Another condition to cover is the immediate destination. We know that this should
    match the routing number of our bank. We do not necessarily want to hardcode these
    values into our code because they can change (although not often), but as previously
    mentioned, banks that go through acquisitions and mergers may gain (or lose) routing
    numbers. Therefore, we want a way to have Pydantic validate the immediate destination
    based on a list of values known at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This task is accomplished through a `field_validator` annotation in Pydantic.
    For our purposes, we will hook this into a database call, which lets us validate
    the field against a list of allowed values in our database.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.17  Pydantic field validator for immediate destination
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses the field_validator and classmethod annotations'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses SQL to check the bank routing number and return it if valid'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Otherwise, raises a ValueError as it was not found'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Handles any unexpected errors with a ValueError as well'
  prefs: []
  type: TYPE_NORMAL
- en: To support this, we have to create a simple table that contains the routing
    numbers we want to consider as our bank routing numbers. Depending on the number
    of records we expect to validate, having to perform a database query for each
    record (and possibly multiple fields) may be inefficient. In our case, there should
    only be a single ACH file header record in any file that we load. So, we are not
    overly concerned about the effects on performance, but these types of potential
    problems should be kept in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Once we start validating the immediate origin, we need to go through and correct
    many of our tests where we had a number that was valid but did not exist in our
    database. There will be an additional clean-up of unit tests to handle the exceptions
    and expanding of parameters passed to the routines so that we can log the exceptions.
    When these methods start getting too complex, it will be time to split them into
    their own record-type classes away from the parser itself.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Updating the APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After passing the unit tests with the ACH parsing and handling our errors, we
    can jump over to the dashboard to see things in action. Unfortunately, if you
    try to load one of the exception files, you will not see it on the dashboard.
    What happened?
  prefs: []
  type: TYPE_NORMAL
- en: We already have BDD syntax for the API endpoint that supports loading a file
    and checking the results, so no new code will be needed to support the test shown
    in the next listing. Having the flexibility to create new tests without having
    to write any new code is one of the benefits of BDD and a flexible syntax that
    powers it. Running this test does indeed show no records being returned.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.18  Testing our API with an invalid file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a scenario'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sets up the database and processes an ACH file'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Executes the API'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Checks for our included file'
  prefs: []
  type: TYPE_NORMAL
- en: Another great benefit of having tests is that we can simply add a breakpoint
    to the endpoint and rerun the test in a debug mode, which then allows us to step
    through the code. If you take the time to do this, you should see that no results
    are being returned from the query.
  prefs: []
  type: TYPE_NORMAL
- en: The queries are not able to handle the parsed record (`ach_file_headers` or
    `ach_file_control_records`) not being found. Because we used `INNER` `JOIN`, the
    record must exist in the database to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.19  Using `INNER JOIN` in our original query
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '#1 INNER JOINs on these files may cause records not to be returned when exceptions
    occur.'
  prefs: []
  type: TYPE_NORMAL
- en: Both the `ach_file_headers` and `ach_file_control_records` are needed in the
    query. Now that we have started adding our exceptions and not writing out parsed
    records, we will also need to be more aware of these queries. Since there is no
    guarantee that this feature will be present, we should use a `LEFT` `JOIN` to
    return a result. The following listing shows updating both parsed versions of
    our query to use the `LEFT` `JOIN`. Depending on the workflow we use to work through
    this problem, we may not want to make changes to both tables until we have tests
    to verify them.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.20  Updating our queries to `LEFT JOIN`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Updating our queries to LEFT JOIN resolves the problem by keeping the data
    in the left table.'
  prefs: []
  type: TYPE_NORMAL
- en: With the updates to the query, we now see our tests passing. We may also look
    at these queries and think that we have spent all the previous sections adding
    exceptions, but we neither have any APIs handling them nor have we updated any
    of our existing APIs to consider them as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When thinking about including exceptions in our dashboard, we will likely want
    APIs that can help us with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Return all exception**s*—Regardless of whether we are looking for all exceptions
    ever or just exceptions encountered today, we need some insight into the exceptions
    that have been encountered. Also, if we are interested in allowing users to perform
    maintenance on the exceptions (change exception levels), this is a good starting
    point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return exceptions for a fil**e*—There will certainly be a need to get exceptions
    for a specific file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more use cases for our APIs, but these should be sufficient to get
    us moving with some of the APIs. One design choice we will have to make is the
    endpoint layout. Do we create a new endpoint so that our exceptions are like our
    existing `/files` endpoint (something similar to `/api/v1/exceptions`), or are
    exceptions part of our files (something similar to `/api/v1/files/exceptions`).
    Will we use a combination of the two? Since the exceptions will be associated
    with the loaded files, we keep our exceptions associated with the `/files` endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to ensure that our exception APIs are returning the expected data.
    For instance, when we load the invalid_file_id.ach, we expect an error code and
    message that will be returned from the database. We can use most of our existing
    code in the test_file_api.py and only include a few other steps. Starting with
    this, we can create a test we then verify against. We created a new file named
    ach_files_exception_endpoint.feature that stores our exception features.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.21  Testing our exceptions API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets up a scenario for the exceptions API'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures an empty database and loads the file'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Calls the API and validates the exception'
  prefs: []
  type: TYPE_NORMAL
- en: To support the new `When` clause, we must add code that will request a list
    of files so that we can determine the UUID. After that, we use the obtained ID
    to make a request to the exception endpoint. To avoid any unexpected errors, we
    could also ensure that we have one record returned from the response, as well
    as a valid response code. However, since we have cleared the database and only
    loaded a single file, it should be an exceptional condition that causes this to
    break.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.22  Adding a new `When` clause
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Gets a list of files and ensures that it worked'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Extracts the file_id from the response'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses the file_id we just extracted from the response, makes another API
    call to our exceptions API, and validates the HTTP response'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Saves the response for use in other steps'
  prefs: []
  type: TYPE_NORMAL
- en: We have our stored API response, and now we want to ensure that we are getting
    the expected error code and message from our response. Why are we validating both
    the error code and the message text coming back? Should the error code not be
    the determining factor? On the one hand, the consumer of the API should rely on
    the error code and not the error message description. On the other hand, we want
    to ensure that both the error code and description match our expectations. Furthermore,
    we may want to identify when the description changes as maybe some consumers of
    our API work directly with the description rather than with the error code. Perhaps
    the API was incorrect at some point and returned the same error code for different
  prefs: []
  type: TYPE_NORMAL
- en: errors.
  prefs: []
  type: TYPE_NORMAL
- en: To work around the error, the consumers may have directly interrogated the description,
    and changes to it may break the API. Of course, if we make a change to that API,
    we may choose to change the version so that consumers can move to the updated
    API when they are ready. With all that said, we just need to be aware that changes
    can affect end-users in unexpected ways. We have seen instances where customers
    have implemented their own scraping of log messages for their own purposes. When
    those messages (even though they were internal to the application) changed, the
    infrastructure broke. In the end, the messages needed to be put back in place.
    So, be very careful—seemingly innocuous changes may cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.23  Adding a new `Then` clause
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Using any, we can search for a field in our response. This tactic is convenient
    when dealing with an array of values and we do not know the order of the response.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have tests for these APIs to determine whether they are returning data
    successfully. As a programming challenge, can you create the logic behind these
    APIs and get the tests to pass?
  prefs: []
  type: TYPE_NORMAL
- en: We create the endpoint for the exceptions `/{file_id}/exceptions` as shown in
    the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.24  An exceptions endpoint for a file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Our API details that will be used for OpenAPI documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The actual function'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the `get_exceptions_response` method.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.25  The `get_exceptions_response` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Standard SELECT statement with our desired fields'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Our initial table is the ach_exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Joins our exceptions with the exception codes for more details'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 If we received a specific ach_files_id, then use that to filter our results
    by appending a WHERE clause.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Executes the query and returns the results'
  prefs: []
  type: TYPE_NORMAL
- en: Our test should be passing. If we step through the code and examine the response
    that we receive, we should see the `batch_id` and `entry_id` are both set to `None`,
    as shown in the example response.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.26  Example response
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We may consider updating our SQL query to set those returned values to empty
    strings by using `COALESCE`—for example, `COALESCE(afe.ach_records_type_5_id,`
    `'') AS batch_id`. However, because we have defined our Pydantic models to expect
    a UUID, and the empty string is not a valid UUID, we will receive an `InvalidText­Representation`
    error. Because we are returning JSON, a better alternative may be to drop this
    value from the response. Note that this may not always be the best option. For
    instance, if we wanted to note the explicit absence of the value, it may be desirable
    to return something to indicate the value is missing. However, for our purpose,
    dropping the value works just fine. The following listing shows how to drop the
    `None` value from our response. Since we are not interested in it, we will see
    that our UI will handle the missing value without our help.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.27  Dropping `None` values from our model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Drops the fields containing None'
  prefs: []
  type: TYPE_NORMAL
- en: With the `response_model_exclude_none` set to `True`, we should be ready to
    move on to the UI to start taking advantage of our exception API. Now that we
    have declared several endpoints within files.py, we want to ensure that we are
    paying attention to the order we declare them in. We make sure that we are going
    from general endpoints such as `/files` and `/exceptions` to more specific, such
    as `/{file_id}/exceptions`. If we encounter a `422` `error`, it could be an indication
    that FastAPI has picked up the wrong endpoint to use.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.1 Retrieving an unparsed record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another piece of functionality we need for the dashboard is the ability to retrieve
    an unparsed record from the database. As we have seen, when there is a parsing
    exception, we are not writing the parsed record out. It will be helpful to an
    end-user if they can see what the record causing the exception looked like. Of
    course, they could pull up the file themselves and look at it, but that is not
    very user friendly. We would also recommend passing the record back all the time
    (which would make this request more straightforward) because the unparsed record
    could contain nonpublic information (NPI) data. By creating this as a separate
    endpoint that returns the record, say when a button or icon is clicked, we can
    call out to the specific endpoint to retrieve the data, which allows us to take
    preventative measures such as
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the button to display the record when the user is not authenticated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an audit trail when the information is viewed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing needless data from being returned since users will not always need
    to see the unparsed record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can start by creating a scenario to test this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.28  Scenario for an unparsed record
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Scenario for an unparsed records API'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Contains the entire unparsed record'
  prefs: []
  type: TYPE_NORMAL
- en: The following code creates a step that helps support the retrieval of the unparsed
    record for a given exception. We assume that we are only getting one file returned
    and that the only exception is the one we want. Later, we may need to make the
    code more robust, but there is no need for now.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.29  Step definition for retrieving an unparsed record
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Similarly to previous API tests, we must make several calls to drill down
    to the data we are interested in. With each API call, we must validate a successful
    200 response code before moving on to prevent errors in subsequent calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We store the results of our final API call for further use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code, we are likely to get a `404` `error` since we have not
    defined an endpoint. You should see one of the `client.get` calls failing with
    the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What steps need to be taken to fix this error?
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a new route to get the unparsed record for a given `exception_id`
    in the files.py.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We update the ach_exceptions_sql.py to return the `unparsed_record` from the
    database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover this code in chapter 9 when talking about auditing. For now, feel
    free to take a shot at completing it.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Insights into exceptions with the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous sections, we have built the ability to create exception files, identify
    those exceptions, log them appropriately, and finally return the information from
    an API. Now, we can look at how to incorporate viewing the exceptions in our dashboard.
    We likely want to provide the users with successively more specific views that
    drill down into the exceptions. For example,
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions for all files are useful for operations to get a sense of the exceptions
    in the system and for analyzing the number/types of exceptions being encountered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions for a specific file could be useful for determining if the file needs
    to be removed and reprocessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions for a specific batch are useful for determining if a particular company
    is having a problem. Also, a file could still be processed with only a specific
    batch being rejected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions for a specific entry may be useful to work with a client or company
    to resolve what caused an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it necessary to provide all these views? Certainly, the customers will have
    their input, and the business will provide us with direction. In addition, the
    business will take our input as well. Some of these may be easier or more efficient,
    depending on how things are set up. In our case, we can easily provide exceptions
    for all files and specific files, so we will start there.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1 Showing all the exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way to get insight into all exceptions is to provide a navigation
    button on the left-hand side of the screen to view all our exceptions for the
    day (we say “day,” but we are going to leave filtering by day as an exercise for
    you). Remember that, eventually, to provide a better UX, we need to offer users
    the ability to search and filter. Multiple ACH files will be loaded daily and
    users will soon become overwhelmed, or the dashboard will become unresponsive
    if we are not careful with the amount of data we are pushing to the user. When
    we get to the point where the number of exceptions starts causing problems with
    the performance and UX, we will need to look at limiting the data by providing
    pagination, searching capabilities, and other strategies to limit the data being
    retrieved at a time.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, we can review updating NavButtons.tsx to navigate to the
    exceptions page.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.30  Adding the error navigation to the dashboard
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the button, we will need to create the actual page. The page should
    meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Displays a list of all exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows viewing the record causing the exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enables navigation to the file when the row is clicked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are some straightforward requirements. Let’s see how to accomplish them.
    First, we want to display the exceptions using a DataGrid element as we did for
    some of the other data on our pages. Recall that the DataGrid element from Material
    UI (MUI) allows us to sort, search, and filter, making it fully functional with
    very little work on our part. The following listing shows the basic API call used
    to retrieve exceptions from http://localhost:8000/api/v1/files/exceptions and
    populate them to our
  prefs: []
  type: TYPE_NORMAL
- en: DataGrid.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.31  API Calls to populate the DataGrid
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The URL for our API'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Axios call to get all exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: With DataGrid, we are taking another approach to show additional functionality
    (listing 8.32). We define a column consisting of an info icon and use `renderCell`
    to add the icon. This can be a handy way to control the contents of the cell,
    especially in the case where we are not mapping something directly to our table.
    We also make use of another function—the `valueGetter`—to convert the date we
    receive using our `convertDateFormat` we have defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.32  Defining the DataGrid
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a clickable icon that can be used to show the unparsed record'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The grid of exceptions uses the MUI DataGrid component.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Reuses our AlertMessage component and shows the exception record'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our API and DataGrid complete, we should now be able to upload a file
    with an exception, navigate to this page, and see our exception listed. When the
    info icon is clicked, we render a static message as a placeholder. Instead of
    that static message, let’s use an API call instead to retrieve the actual record
    so we can display the unparsed record. Why not return the unparsed record when
    we pass the list of exceptions back? We could certainly do that; however, there
    are a few reasons to avoid it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Passing back unnecessary dat**a*—Since it is unlikely that a user is going
    to click on every exception in the list, a lot of that data will remain unused.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Separation of dutie**s*—We want this API to function as an overview of our
    exceptions. Returning the data using a separate API call helps keep the code for
    the API and SQL simpler.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Security consideration**s*—The unparsed records could have account numbers
    and other sensitive NPI data that we do not want to be passed back all the time.
    By making it a separate API call, we can control who may be able to view those
    details and also log exactly when someone views that data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the understanding that showing the unparsed record could open up showing
    NPI data, we can make a call to get the unparsed record and display it in the
    alert box. Of course, we may eventually want to make use of the other details
    we have for the exception and create a better-formatted window. For now, simply
    displaying the record in question is enough. We can use the `params.row` to retrieve
    the needed information from the row that was clicked. The following listing shows
    the updated code that goes into the icon button.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.33  The updated icon button
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Retrieves the IDs for both the file and exception for the row'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Our API URL'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Axios call to get the unparsed record'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Upon response, sets the unparsed record and the Boolean for the dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 If there is an error, shows it in the dialog instead'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a way to view exceptions and the record causing the error. That
    should be useful to our end-users. However, should they click on exceptions whenever
    an ACH file is uploaded? Let’s update our initial Recent ACH Uploads screen to
    have an indicator next to the filename when it is a file that has exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.2 A visual cue for exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we first view our dashboard, there should be some indication that a loaded
    file has exceptions. We do this by updating our dashboard to include an icon whenever
    a file contains exceptions. We make the following updates:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL query needs to return a Boolean value indicating a file has exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: API needs to return the new field as `has_exceptions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UI needs to check this field to display an icon when it is true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We first create a couple of test scenarios so that we can work on the first
    two items on our list. The following listing shows the newly added scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.34  Scenarios testing `has_exceptions`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `get_files_response` can be updated to include the `has_exceptions` field.
    The following listing shows how we use a Common Table Expression (CTE) to get
    a list of unique `ach_files_id` values and then convert those to a Boolean value
    to use in `has_exceptions`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.35  Updating SQL for `get_files_response`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a CTE to get the distinct file IDs'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses a case statement to set a Boolean field called has_exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Since not every file has exceptions, uses LEFT JOIN'
  prefs: []
  type: TYPE_NORMAL
- en: And now we can update the UI to support the new `has_exceptions` field as well.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.36  Updated API mapping
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The new field to determine if a file has exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: And the updated RecentAchUploads.tsx
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.37  Displaying an error icon
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '#1 If a file has exceptions, displays an icon to indicate it has them'
  prefs: []
  type: TYPE_NORMAL
- en: With that, when an ACH file with exceptions is uploaded, there should be a visual
    indication on our Recent ACH Uploads, as shown in figure 8.4.
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a computer screen  Description automatically generated](../Images/CH08_F04_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4  Visual indication of a file error
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 8.8 Additional UI changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the basic structure of our exception viewing, we can take care
    of a few other requests that came from users during the initial MVP evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: The files screen should also show the specific exceptions for that file. This
    should follow after our initial exception handling. We can refactor our UI exception
    page to become a component and pass the needed exception information into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The batch screen should contain a component with statistics such as totals and
    a line-item breakdown of the transaction codes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our listing of the items in the batch should contain the applications they are
    associated with, such as Checking, Savings, and so forth. While the transaction
    codes relate to those applications, ensuring they are included in our DataGrid
    will provide a better UX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our screens should be more responsive to size changes. Currently, our components
    are stacked in a column, and we would like to have them use up the available width
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 8.8.1 Creating an exceptions component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can refactor our page to create an exception component, which will help prevent
    code duplication when we want to present errors elsewhere. The exception information
    that we need to display is the same, regardless of whether we want to view all
    exceptions or just filter them by file. On the one hand, that means we could easily
    copy and paste that existing page to create a new page or component that filters
    on our file, and we would be done. On the other hand, we could create a common
    exception component that both pages can use, passing to it either the full list
    of exceptions or one that has been filtered for a particular file. As we have
    stated previously, whenever feasible, we want to avoid duplicating work as that
    may pay off in the short term by getting something out the door, but future maintenance
    becomes difficult and tedious as fixes must be applied multiple times. The following
    listing shows the results of pulling the DataGrid and the associated calls from
    the original page into a stand-alone component.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.38  Stand-alone exception component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: With our new exceptions component, we can include it in the existing `fileDetails`
    page by calling the `/file/{fileId}/exceptions` endpoint to get a list of exceptions
    for the file we are viewing and passing the results to our new component. The
    following listing shows the required changes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.39  Using our new component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets the returned exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Includes our new component passing the exceptions to it'
  prefs: []
  type: TYPE_NORMAL
- en: We love how by creating components, it becomes so easy to import and use them
    anywhere we may need them. The only thing we want to stress about this is to be
    careful about the data that a component may need or fetch. We may have to evaluate
    whether we want to pass data to it or have it request data itself. As we saw previously
    with the dashboard, sometimes we can save redundant API calls by passing the required
    data in. We did leave the fetching of our unparsed records within the component
    because those are occasional calls that are best encapsulated in the component.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8.2 Batch statistics component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now tackle the batch statistics component. This request is meant to give
    users a quick overview of some important aspects of the batch, as shown in figure
    8.5\.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a statistics  Description automatically generated](../Images/CH08_F05_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5  Batch statistics component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While charts and graphs provide nice visualizations and can help compare large
    amounts of data, we will use a simple list for this component as we only need
    to provide a handful of totals for our overview.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to use the existing `AchBatch­EntriesResponse` for this component.
    Using a simple list and items from MUI, we can create our component. We use the
    `ListItemText` for displaying primary and secondary text. We also create some
    of the elements with `createListItems` and include them in the render. The following
    listing shows our basic component.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.40  The `AchBatchStatistics` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Helper functions to collect, aggregate, and format data as necessary'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Includes any additional ListItem elements'
  prefs: []
  type: TYPE_NORMAL
- en: In the following listing, we created the `computeBatchTotals` function to provide
    a sum of our debits, credits, and other amounts. We will end up supporting additional
    transaction codes, but for now, we will only be considering the transaction codes
    22 and 27\. Also, because the `AchBatchEntriesResponse` had formatted the amounts,
    we needed to strip those characters away. Ideally, we would like to go back and
    not have the response format those amounts, but that may not always be practical.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.41  The `computeBatchTotals` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Initializes the BatchTotals object'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We need to remove the currency formatting.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns the BatchTotals object'
  prefs: []
  type: TYPE_NORMAL
- en: In listing 8.42, we also create the `computeBatchStatistics` function that contains
    counts and amounts for each transaction. For simplicity’s sake of the code and
    testing, we create another function that spins through the entries in the batch.
    We group the items by their description because we will make use of that when
    we display them.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.42  The `computeBatchStatistics f`unction
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a new map of the BatchStatistics'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Each entry in the batch will be processed.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Removes the formatting from the amount'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Tries to get an entry for the description; if not found, initializes one'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Increments the count'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Uses the plus method from the Decimal package to maintain the amount'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Saves the entry'
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to add the `BatchStatistics` we returned to our component. We dynamically
    create our `ListItem` elements in a function named `createListItems`, which takes
    our map of items and returns an array of React elements, as the following listing
    shows. With this approach, we can create as many elements as needed and return
    them in one swoop. Of course, we would need to be careful not to create too many
    elements, or otherwise create something that will not provide a meaningful user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.43  The c`reateListItems` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines an interface so that we can easily reference our data'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates an empty array of nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a ListItem element'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Adds it to the array'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Returns the array'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can add some unit testing to this component. While we could have
    started with this approach, we also want to show that adding unit tests can be
    done at other points in our development as well. Typically, we add these unit
    tests at the point where we realize that we need something extra to process the
    data being returned. To make our testing easier, we will need to export the functions
    we used within the component. That may present opportunities to refactor the code
    to further remove the logic from the component, but for now, we will not take
    it that far.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.44  Jest test for `computBatchTotals`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates mock data'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Passes it to our computeBatchTotals routine'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Validates the result'
  prefs: []
  type: TYPE_NORMAL
- en: From there, we can add additional entries for the same transaction code, different
    transaction codes, and anything else we may be interested in testing. This is
    a great way to test some of the edge cases that may require us to deliberately
    provide data, especially if we need to test exception conditions. With this basic
    test, we can create additional tests and start evaluating test coverage before
    moving on to our next enhancement request.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8.3 Adding the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A relatively straightforward request is to add an application column, as shown
    in figure 8.6\. While it is possible to determine the application from the transaction
    code for a better UX, we can provide the mapping as part of our returned data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH08_F06_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6  The batch entry screen with the added column
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This type of request allows us to work through all the pieces of our application,
    letting us get another taste of the full stack experience using BDD. We can create
    a feature file named ach_entries_endpoint.feature containing the scenario, as
    shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.45  Our feature file and scenario
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The scenario shares some similarities with how we tested the files endpoint;
    however, we chose to create a separate step definition file to support this feature.
    This decision allows us to keep the scenario-specific steps isolated and gives
    us the ability to test only this particular feature. The following listing shows
    some of the step definitions that support running the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.46  Step definitions for our feature
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With the ability to test the endpoint, we can now work on ensuring the application
    will be returned as part of the API. We can tackle these steps in several different
    orders, but we chose to start by updating the `AchBatchEntriesResponse` to include
    the application field, as shown in the following listing. This field is not coming
    from the database, and it is not technically part of the ACH file layout. Therefore,
    we limit the maximum length of the field to the longest word we plan on having
    there, which is “checking.”
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.47  The updated `AchBatchEntriesResponse`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets the max length for this field to the longest text we expect'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we update our query to pass back the application name based on the transaction
    code using a `CASE` statement, as shown in listing 8.48\. As mentioned, there
    is some freedom in application naming. We could potentially choose to group both
    checking and savings accounts under the name Demand Deposit Accounts (DDA), which
    is another term used in the financial industry. The actual name for the application
    would be something that the business provides to us. We like having a bit more
    granularity in the application name, so we chose to use the names “Savings,” “Checking,”
    “GL” for General Ledger, “Loan,” and “Unknown” (to identify any transaction codes
    that we may have missed or in case of an incorrect transaction code in the database).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.48  Updated query to support the `transaction_code`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Maps transaction codes to the application'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Names the resulting column as application'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we want to update our DataGrid to add the column. With all the heavy
    lifting already done by the server, we simply need to add the column and update
    the interface to include the application as well.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.49  Added column and field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Includes the application column in our columns definition'
  prefs: []
  type: TYPE_NORMAL
- en: We should now be able to navigate to our dashboard and drill down to see the
    application column being populated. This small example is a great way to illustrate
    why we love full stack development. We were able to work on unit testing, Python,
    APIs, and Typescript!
  prefs: []
  type: TYPE_NORMAL
- en: 8.8.4 Making our UI more responsive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, our dashboard components are stacked on top of each other. The MUI
    package that we have been using for our components provides options for controlling
    the layout that will help make our dashboard more responsive. We replace the `Box`
    elements that we wrapped our components in with a `Grid` container and `Grid`
    items. In addition, there are attributes `xs`, `sm`, `md`, `lg`, and `xl` that
    can be used to provide breakpoints based on screen size. This means that we can
    customize our layouts for all different screen sizes. The following listing shows
    an example of using a grid with various breakpoints. The given items will be displayed
    in a column when the screen is small, and when expanded, it will contain more
    items per row, with all nine items in a single row when the screen is wide enough
    to accommodate them.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.50  Example of a responsive grid
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses the latest Grid element'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines a container grid'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines nine elements'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Grid elements are different sizes based on breakpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: After exploring the responsiveness of the layout, we can apply the same approach
    to our existing components. Using the `Grid` elements to clean up some of our
    existing layout, we move the paper elements into our components, leaving us with
    just the layout elements in our page.tsx components (not counting the API calls
    and other needed functions). The following listing shows an example of the resulting
    page.tsx for the batch details screen.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.51  The page.tsx for batch details
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a container'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Places each of our components in a Grid element'
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints can be used with other attributes as well. For instance, if we wanted
    to adjust the amount of `margin-top`, we could set it based on the screen size,
    as shown in the next listing. Notice how the margin is set to a smaller value
    of 4 for smaller screens and then to 12 for larger ones.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.52  The `margin-top` based on screen size
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Breakpoints offer a powerful way to help with our layout and design. We can
    update the default values (pixels) for each breakpoint and even rename them, as
    shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.53  Customizing breakpoints
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This chapter covered a lot, focusing on providing feedback when uploading a
    file that is not formatted properly. Exception handling provides a way to gracefully
    handle unexpected situations within the software, giving us a chance to alert
    the user and recover as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at how we could expand our file-creation syntax to support
    adding these exceptions. Expanding the ability to produce files allows for easier
    and more robust file creation, which in turn gives us more files to load into
    our dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of ACH handling and Pydantic, we focused on how defining our fields
    provided us with validation without the need for a lot of code. We were able to
    limit the field length, validate formatting with regular expressions, and even
    go back to a database to validate entries. We also added support for handling
    exceptions, which allowed us to get another taste of full stack development—by
    updating the backend, providing APIs to allow access to data, and finally providing
    UI elements to view the data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we had the chance to expand our UI by adding new components, refactoring
    what was already being used, and looking at how to manipulate our layouts using
    breakpoints in MUI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After launching the MVP, user feedback highlighted both positive reception and
    areas for improvement, particularly the need for handling a wider variety of ACH-related
    exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning enhancements involves prioritizing features based on user feedback
    and working on a timeline to implement ACH exceptions and search functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions in ACH processing can be categorized into errors, exceptions, and
    warnings, each with different severity and handling implications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ACH files with exceptions involves extending BDD syntax to support
    file, batch, and entry-level exceptions for more robust testing and processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing exception handling in ACH parsing includes using Pydantic for field
    validation and storing detailed exception information in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions API development focuses on enabling effective reporting and search
    capabilities, providing insights into file-specific errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI is updated to display exceptions, incorporating components for viewing
    and filtering errors, with features such as DataGrid for interactive data presentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional UI enhancements include creating reusable components, statistics
    for batches, and improving layout responsiveness using the MUI grid system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing unit testing and BDD helps ensure robustness and flexibility in handling
    ACH exceptions, while UI updates enhance UX and interaction with data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
