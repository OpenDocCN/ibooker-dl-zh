- en: 6 Rapid data creation using AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 使用AI快速创建数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Generating basic test data using LLMs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LLMs生成基本测试数据
- en: Changing the format of test data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变测试数据的格式
- en: Using complex data sets to prompt LLMs to create new data sets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复杂数据集来提示LLMs创建新的数据集
- en: Integrating LLMs as a test data manager for automated checks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将LLMs集成作为自动化检查的测试数据管理器
- en: Managing test data is one of the most challenging aspects of testing and software
    development. Typically, data requirements grow with the complexity of a system.
    Having to synthesize data relevant to our context for automated checks and human-driven
    testing that handles complex data structures and anonymizes at scale and on demand
    can impose a huge drain on testing time and resources, which could be better spent
    on other testing activities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 管理测试数据是测试和软件开发中最具挑战性的方面之一。通常，数据需求随着系统的复杂性而增长。为了自动化检查和人工驱动的测试，我们需要合成与我们的上下文相关的数据，并在需要时进行大规模匿名化，这可能会对测试时间和资源造成巨大消耗，而这些时间和资源本可以用于其他测试活动。
- en: However, we need test data. It is simply not possible to carry out most testing
    activities if we lack the necessary data to trigger actions and observe behavior.
    That’s why this chapter shows how we can use large language models (LLMs) to generate
    test data, providing different prompts to create both simple and complex data
    structures and integrate LLMs into our automation frameworks via third-party APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要测试数据。如果没有必要的数据来触发动作和观察行为，就无法进行大多数测试活动。这就是为什么本章展示了我们可以如何使用大型语言模型（LLMs）来生成测试数据，提供不同的提示来创建简单和复杂的数据结构，并通过第三方API将LLMs集成到我们的自动化框架中。
- en: 6.1 Generating and transforming data with LLMs
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 使用LLMs生成和转换数据
- en: Given that LLMs are powerful, probabilistic, text generators, it sounds logical
    that, with the right prompting, they can generate and transform test data easily.
    This is true, but it depends on writing clear prompts that communicate our data
    requirements explicitly, so that we get the right data we want, in the correct
    format and without any errors caused by hallucinations. There are many ways in
    which we can approach this, but let’s begin by looking at some basic prompts we
    can use casually to create test data for a range of testing activities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于LLMs是强大的、概率性的文本生成器，因此，通过适当的提示，它们可以轻松地生成和转换测试数据，这是合理的。但这取决于编写清晰的提示，明确传达我们的数据需求，以便我们得到我们想要的数据，格式正确，并且没有由于幻觉引起的任何错误。我们可以以多种方式来处理这个问题，但让我们首先看看我们可以随意使用的一些基本提示，以创建各种测试活动的测试数据。
- en: 6.1.1 Prompting LLMs to generate simple data sets
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 通过提示LLMs生成简单数据集
- en: 'To start, let’s explore how we can create basic data set examples such as this
    one:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索如何创建基本数据集示例，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, the JSON data set has a mixture of data types using a fairly
    straightforward structure. We’ll see how to work with more complex structures
    later in the chapter, but for now, let’s return to a prompt that we used back
    in chapter 2 to create some sample test data. First, we set out the main instructions
    for the prompt and use the time-to-think principle to improve the quality of the
    output JSON:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，JSON数据集使用相当简单的结构混合了多种数据类型。我们将在本章后面部分看到如何处理更复杂的结构，但现在，让我们回到第2章中我们用来创建一些样本测试数据的一个提示。首先，我们设定提示的主要说明，并使用思考时间原则来提高输出JSON的质量：
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a JSON data generator. Generate 5 JSON objects in an array and check
    that 5 JSON objects have been created before outputting the results. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 你是一个JSON数据生成器。生成一个包含5个JSON对象的数组，并在输出结果之前检查是否已创建了5个JSON对象。 |'
- en: 'We use different delimiters to set out the rules for our data requirements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不同的分隔符来设定我们的数据需求规则：
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '|    *   Each parameter is identified with a `%` sign.   *   Each column is
    described in order of key, value data type and options using the `&#124;` sign.  
    *   If a column data option says random, randomize data based on the suggested
    format and column name. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|    *   每个参数都用一个`%`符号标识。    *   每个列按照键、值数据类型和选项的顺序描述，使用`&#124;`符号。    *   如果列数据选项说明为随机，则根据建议的格式和列名随机化数据。
    |'
- en: 'Then we provide the data we want to be created following our delimited rule
    set:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们提供我们想要根据我们的分隔规则集创建的数据：
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| Here are the instructions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '| 这里是说明：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This prompt relies on a range of prompt-engineering tactics to set out explicitly
    what we want to see generated. We use the format tactic to declare what format
    we want our test data to be returned in. The delimiter tactic is used to set the
    rules for how we structure our data and what format values should be in. Also,
    we instruct the LLM to work out the solution before outputting it to reduce the
    risk of hallucinations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示依赖于一系列提示工程策略来明确说明我们想要生成的内容。我们使用格式策略来声明我们希望测试数据以何种格式返回。分隔符策略用于设置我们结构化数据以及格式值的规则。此外，我们还指示LLM在输出之前先找出解决方案，以降低幻觉的风险。
- en: 'Sending this prompt to ChatGPT returned the following data set:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将此提示发送到ChatGPT返回以下数据集：
- en: '|'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: There are a few observations to make from this generated data. We can see that
    in places where the prompt has been explicit in data expectations, we get generated
    data that is close to our expectations—for example, the features `accessible`
    and `roomPrice`. There are, however, some weaker areas where our prompt has left
    the LLM to determine what to output. Two notable areas are the image URLs that
    have opted for `example.com` and the relationship between `beds` and `type`. The
    image URLs, although valid, don’t point to actual images. Depending on our requirements,
    we may need to tweak our prompt further to make the URLs more explicit. The other
    relationship is interesting as well, as one of the records states that the room
    type is double but it offers three beds. It’s a good start though, and there are
    times when this type of generated data is enough to support our testing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从生成的数据中可以得出一些观察结果。我们可以看到，在提示明确数据期望的地方，我们得到的数据接近我们的期望——例如，`accessible`和`roomPrice`特征。然而，也有一些较弱的地方，我们的提示让LLM决定输出什么。两个值得注意的领域是选择了`example.com`的图像URL以及`beds`和`type`之间的关系。图像URL虽然有效，但并不指向实际的图像。根据我们的需求，我们可能需要进一步调整我们的提示，使URL更加明确。另一个关系也很有趣，因为其中一条记录表明房间类型是双人，但它提供了三张床。尽管如此，这仍然是一个良好的开端，有时这种类型的生成数据足以支持我们的测试。
- en: 'But what if we want this data in a different data structure? This can be handled
    by quickly reworking the prompt. For example, this prompt is requesting the same
    data, but this time in an XML format. We begin by rewording the initial instructions
    to create the data in an XML format:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想以不同的数据结构来获取这些数据呢？这可以通过快速重写提示来处理。例如，这个提示请求相同的数据，但这次是以XML格式。我们首先将初始说明重写为以XML格式创建数据：
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| You are an XML data generator. Generate 3 XML entries in an array and check
    that 3 XML objects have been created before outputting the results. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 你是一个XML数据生成器。在一个数组中生成3个XML条目，并在输出结果之前检查是否已创建了3个XML对象。 |'
- en: 'We add an initial instruction to handle a root XML node:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个初始说明来处理根XML节点：
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '|    *   The root node element name is identified with a `#` sign   *   Each
    element is identified with a `%` sign   *   Each column is described in order
    of element name, data type and options using the `&#124;` sign   *   If a column
    data option says random, randomize data based on the suggested format and column
    name |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|   *   根节点元素名称用`#`符号标识   *   每个元素用`%`符号标识   *   每个列按元素名称、数据类型和选项的顺序描述，使用`&#124;`符号  
    *   如果列数据选项为随机，则根据建议的格式和列名称随机化数据 |'
- en: 'Then we provide the same data steps as before:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们提供与之前相同的数据步骤：
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| Here are the instructions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '| 这里是说明：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Although it’s not necessarily common to have to handle different data formats
    in one application, the prompt demonstrates one of the advantages of working with
    LLMs to generate data. Using the structured output tactic, we’re able to keep
    most of the prompt the same as the JSON prompt example and simply modify it to
    give us XML; when I sent it to ChatGPT, I got the following result:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在一个应用程序中处理不同的数据格式并不一定常见，但这个提示展示了与LLMs合作生成数据的一个优点。使用结构化输出策略，我们能够保持大多数提示与JSON提示示例相同，只需稍作修改即可生成XML；当我将其发送到ChatGPT时，得到了以下结果：
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Again, the output has similar attributes as the previous examples. The structure
    of the XML is valid, and the rules determining what data to use have been followed.
    But, similar to the JSON example, we have some unusual choices being made. Single
    rooms with three beds, oddly named rooms, and dummy URLs are used. With both prompts,
    we could add more information to mitigate these problems, but we run the risk
    of having to create a lot of rules in our prompt to manage the relationship between
    data points. There are, however, other choices we can make with our prompts to
    handle more complex rule sets, but first, let’s explore another way in which LLMs
    can help us thanks to their ability to transform data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，输出具有与先前示例相似的属性。XML的结构是有效的，确定使用哪些数据的规则已被遵循。但是，与JSON示例类似，我们做出了一些不寻常的选择。使用带有三个床位的单人房间，奇特的房间名称和虚拟URL。在两个提示中，我们可以添加更多信息来减轻这些问题，但我们会面临在提示中创建大量规则以管理数据点之间关系的风险。然而，我们还可以在我们的提示中做出其他选择来处理更复杂的规则集，但首先，让我们探索LLMs如何通过其转换数据的能力来帮助我们。
- en: Activity 6.1
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 活动第6.1节
- en: Using the prompt shared in this section, change the data structure to create
    either new XML or JSON test data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本节中共享的提示，更改数据结构以创建新的XML或JSON测试数据。
- en: 6.1.2 Transforming test data into different formats
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 将测试数据转换为不同的格式
- en: 'One of the core benefits of LLMs, which has been highlighted by advocates of
    the technology, is its ability to translate text from one language to another—for
    example, from French to English and back again. We can also use this approach
    to transform data and code from one structure or language to another. For example,
    take a look at the following prompt that transforms some JSON into a SQL statement.
    We use the delimiter tactic and instructions to start the prompt:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: LLMs的核心优势之一，已被技术倡导者强调，是其将文本从一种语言翻译成另一种语言的能力——例如，从法语翻译成英语再翻译回来。我们还可以使用这种方法将数据或代码从一种结构或语言转换成另一种。例如，看看以下将一些JSON转换为SQL语句的提示。我们使用分隔符策略和指令来启动提示：
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a JSON to SQL transformer. Convert the JSON object delimited by triple
    hashes into a SQL statement that will:   1.  Create a SQL table to insert the
    transformed records into   2.  Create insert statements to add each record to
    a database |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 你是一个JSON到SQL转换器。将用三个井号分隔的JSON对象转换为SQL语句，该语句将：   1. 创建一个SQL表以插入转换后的记录   2.
    创建插入语句将每条记录添加到数据库中 |'
- en: 'Next, we instruct the model to check the solution to improve the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指示模型检查解决方案以改进输出：
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Check that each SQL statement covers all aspects of the JSON before outputting
    the results |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 在输出结果之前检查每个SQL语句是否涵盖了JSON的所有方面 |'
- en: 'Then we provide the data that we want to see transformed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们提供我们想要转换的数据：
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In this prompt, we’re asking an LLM not only to take a JSON object and convert
    it into a SQL `INSERT` statement that we could run, but also create the necessary
    `CREATE` statement to allow us to insert our data in the first place. Sending
    this to ChatGPT returned the following SQL statement:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个提示中，我们要求一个LLM不仅将一个JSON对象转换为我们可以运行的SQL `INSERT` 语句，而且还创建必要的 `CREATE` 语句，以便我们首先能够插入数据。将此发送到ChatGPT返回了以下SQL语句：
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'What stands out in this response is not just that correct SQL has been generated
    to create and insert our data into a database, but that it has honored the values
    from the original JSON object. It demonstrates the importance of tactics such
    as these that go into a prompt:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回答中引人注目的不仅仅是生成了正确的SQL语句来创建和将我们的数据插入数据库，而且它还尊重了原始JSON对象中的值。这证明了这些策略的重要性，这些策略被纳入提示中：
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Check that each SQL statement covers all aspects of the JSON before outputting
    the results |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 在输出结果之前检查每个SQL语句是否涵盖了JSON的所有方面 |'
- en: The prompt helps ensure that the data parameters themselves are not modified
    during the transformation process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该提示有助于确保在转换过程中数据参数本身不会被修改。
- en: These quick prompts demonstrate that LLMs can be used to rapidly generate and
    transform data with prompts that can be reused multiple times by replacing the
    data object inside the delimited portion of each prompt. This can prove useful
    for testing activities such as exploratory testing and debugging, where we require
    data fast to help us progress with our testing. But, as demonstrated, we can quickly
    come across either inconsistent or invalid data as our requirements become more
    complex.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些快速提示演示了LLM可以用来快速生成和转换数据，这些提示可以通过替换每个提示分隔部分内的数据对象来多次重复使用。这可能在需要快速数据以帮助我们进行测试活动（如探索性测试和调试）时很有用。但正如所展示的，随着我们要求的复杂化，我们可能会迅速遇到不一致或无效的数据。
- en: Activity 6.2
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 活动六.2
- en: Build a prompt that attempts to convert a piece of XML into either a SQL or
    JSON data structure. Ensure that the test data within the XML is transferred across
    without problems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个提示，尝试将一个XML片段转换为SQL或JSON数据结构。确保XML中的测试数据在转换过程中没有问题。
- en: 6.2 Processing complex test data with LLMs
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 使用LLM处理复杂测试数据
- en: In the original prompts to generate data, we set the rules and expectations
    in plain language. It means we are required to decode the structure of our data
    and its relationships before explicitly stating the learned rules in our prompt—a
    task that can quickly become quite complicated. Thus, instead of attempting to
    work out those rules ourselves, let’s take a look at how we can send different
    data specifications formats or existing data to prompt an LLM to create more complex
    data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的生成数据提示中，我们用普通语言设定了规则和期望。这意味着我们要求在明确说明提示中的学习规则之前，解码我们数据结构和其关系——这是一个可能迅速变得相当复杂的工作。因此，我们不如看看如何发送不同的数据规范格式或现有数据，以提示LLM创建更复杂的数据。
- en: 6.2.1 Using format standards in prompts
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 在提示中使用格式标准
- en: 'Let’s begin by looking at how we can employ data specification formats such
    as OpenAPI v3 and XSD that outline the structure and rules our data has to follow.
    These types of specifications can be useful for a few reasons:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探讨如何使用OpenAPI v3和XSD等数据规范格式开始，这些格式概述了我们的数据必须遵循的结构和规则。这类规范有几个原因可能是有用的：
- en: '*Ready-to-go solutions*—Creators of specification frameworks have already handled
    the heavy lifting when it comes to communicating data structures in different
    formats. Consider the prompts we created earlier with the delimited rules that
    outline data names and types. All of this has already been considered and set
    out in specification frameworks. Therefore, it makes sense to use them rather
    than build our own.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*现成解决方案*—规范框架的创建者已经处理了在不同格式中传达数据结构的繁重工作。考虑我们之前创建的带有分隔规则提示，这些规则概述了数据名称和类型。所有这些已经在规范框架中考虑并制定出来。因此，使用它们而不是自己构建是有意义的。'
- en: '*Ubiquity*—The frameworks we’ll use are standardized and have been adopted
    by lots of teams and organizations. This increases the likelihood that LLMs have
    been trained on specification frameworks, which will maximize our chances of obtaining
    a desired output when we send a prompt.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*普遍性*—我们将使用的框架是标准化的，并且已经被许多团队和组织采用。这增加了LLM在规范框架上训练的可能性，这将最大化我们在发送提示时获得期望输出的机会。'
- en: '*Free use*—If we are working in teams that use tools such as OpenAPI and XSD
    to specify data structure or APIs, then the specifications are already available
    for us to use. The work is already done in the design phase for a feature or application.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*免费使用*—如果我们是在使用OpenAPI和XSD等工具来指定数据结构或API的团队中工作，那么这些规范已经为我们准备好了。在设计阶段就已经完成了功能或应用程序的设计工作。'
- en: '*Intrinsic testability*—Employing a commonly used structure means that an LLM
    has likely been exposed to it more in its training than if we were using proprietary
    structures. This means that an LLM is likely to increase the probability of a
    higher-value output and assist our testing further.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内在可测试性*—使用常用的结构意味着LLM在其训练中可能比我们使用专有结构时更多地接触到了它。这意味着LLM可能增加产生更高价值输出的概率，并进一步协助我们的测试。'
- en: Given that this approach has a few benefits, let’s take a look at how they can
    be added to prompts to generate data for us.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这种方法有几个好处，让我们看看它们如何被添加到提示中，以生成我们所需的数据。
- en: JSON with OpenAPI
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 带有OpenAPI的JSON
- en: We’ll start by creating a prompt that uses the OpenAPI 3.0 format to create
    JSON data, resulting in the following prompt, which sets out the prompt instructions
    using the delimiter, format, and work-our-solution tactics
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个提示，使用OpenAPI 3.0格式创建JSON数据，结果如下提示，使用分隔符、格式和工作解决方案策略来设置提示说明
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![MW标志](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a JSON data generator. Generate a JSON array with 3 randomized JSON
    objects based on the OpenAPI schema delimited by three hashes. Confirm that all
    3 JSON objects match the OpenAPI schema rules before outputting the results. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 你是一个JSON数据生成器。根据OpenAPI模式，生成一个包含3个随机JSON对象的JSON数组，以三个井号作为分隔符。在输出结果之前，确认所有3个JSON对象都符合OpenAPI模式规则。|'
- en: 'We then provide the OpenAPI specification for processing:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们提供OpenAPI规范以进行处理：
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![MW标志](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Notice how the prompt indicates at the start that we intend to use the OpenAPI
    format to outline our data requirements. We use this to set our expectations of
    how the resulting data should be structured, which we can see when submitting
    the prompt to ChatGPT and receiving the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意提示开头如何表明我们打算使用OpenAPI格式来概述我们的数据需求。我们使用这一点来设定我们对结果数据的结构预期，这在我们向ChatGPT提交提示并收到以下输出时可以看到：
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI标志](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Compared to the previous data we generated, this data feels more accurate. The
    descriptions are more detailed and cite other attributes of the room found elsewhere.
    For example, the family suite description references the data related to the room
    type and features.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前生成的前数据相比，这些数据感觉更准确。描述更详细，并引用了在别处找到的房间其他属性。例如，家庭套房描述引用了与房间类型和功能相关的数据。
- en: The image attributes are questionable as they simply provide an image name,
    but that might suffice if images are stored within our application. However, what
    our use of the OpenAPI language allows us to do is to set more detailed rules,
    meaning that we could update the image section of the specification from
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图像属性值得怀疑，因为它们仅仅提供了一个图像名称，但如果图像存储在我们的应用程序中，这可能就足够了。然而，我们使用OpenAPI语言的使用允许我们设置更详细的规则，这意味着我们可以更新规范中的图像部分，从
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![MW标志](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'to the following, in which the pattern points to test images we might have
    generated earlier:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到以下内容，其中模式指向我们可能之前生成的测试图像：
- en: '|'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![MW标志](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If we were to add this pattern into our prompt and send it to an LLM, it would
    return objects such as this one:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此模式添加到我们的提示中并发送给LLM，它将返回如下对象：
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI标志](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: By utilizing different specification rules used in OpenAPI, we can control our
    output more successfully.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用OpenAPI中使用的不同规范规则，我们可以更成功地控制我们的输出。
- en: XML and XSD
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: XML和XSD
- en: 'The same process can be applied to other formats. Consider the following prompt
    that uses the same approach as the previous one but takes an XML Schema Definition
    (XSD) instead. We use format, delimiter, and work-out-solution tactics to outline
    the prompt to take an XSD format:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的过程可以应用于其他格式。考虑以下提示，它使用与上一个提示相同的方法，但使用XML模式定义（XSD）代替。我们使用格式、分隔符和工作解决方案策略来概述提示以采用XSD格式：
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![MW标志](../../OEBPS/Images/logo-MW.png)'
- en: '| You are an XML data generator. Generate 3 randomized XML objects based on
    the XSD schema delimited by three hashes. Add all the XML objects to parent element
    of rooms. Confirm that all 3 XML subobjects match the XSD schema rules before
    outputting the results. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 你是一个XML数据生成器。根据XSD模式，生成3个随机XML对象，以三个井号作为分隔符。将所有XML对象添加到rooms的父元素中。在输出结果之前，确认所有3个XML子对象都符合XSD模式规则。|'
- en: 'Next, we provide the XSD format to set how we want data output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供XSD格式以设置我们想要的数据输出格式：
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![MW标志](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The prompt works in a manner similar to the one before. This prompt comes with
    an additional step to ensure that our test data is grouped by storing it under
    a single root node. But the rest of the prompt works the same, resulting in an
    XML output that is similar to the previous prompt that generated JSON data, as
    demonstrated in the response I got when I prompted ChatGPT for XML test data:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 提示的工作方式与之前的类似。这个提示增加了一个额外步骤，以确保我们的测试数据通过存储在单个根节点下进行分组。但提示的其余部分工作方式相同，结果生成与之前生成JSON数据的提示类似的XML输出，正如我在提示ChatGPT生成XML测试数据时得到的响应所示：
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: These types of prompts can be extremely useful when we need to create test data
    for NoSQL databases. I remember once working on a project with XML documents that
    included more than 1,000 elements. It was practically impossible to generate all
    the test data we required, so we had to compromise. But with an LLM and a prompt
    similar to the ones we’ve just looked at, the process of creating XML documents
    would have taken a matter of minutes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这类提示在我们需要为NoSQL数据库创建测试数据时非常有用。我记得有一次在一个包含超过1,000个元素的项目中工作。实际上不可能生成我们所需的全部测试数据，所以我们不得不妥协。但是，使用LLM和与我们刚才看到的类似的提示，创建XML文档的过程只需几分钟。
- en: Activity 6.3
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 活动第6.3节
- en: Use either an OpenAPI or XSD specification to create new test data. If you have
    access to the specifications, try them out. Alternatively, locate example specifications
    and try them out in a prompt to generate test data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenAPI或XSD规范创建新的测试数据。如果您有权访问规范，请尝试使用它们。或者，找到示例规范并在提示中尝试使用它们来生成测试数据。
- en: 6.2.2 SQL exports as prompt guides
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 SQL导出作为提示指南
- en: The prompts we’ve explored so far have created data entities that exist as a
    single entity, but it’s just as common to work with applications in which data
    is split into separate locations. For example, how would we prompt an LLM to create
    data for a SQL-based database that contained data distributed across multiple
    tables?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前探索的提示已经创建了作为单一实体的数据实体，但与数据分散在不同位置的应用程序一起工作也同样常见。例如，我们如何提示LLM为包含数据分布在多个表中的基于SQL的数据库创建数据？
- en: 'One method is to take an alternative approach using the few-shot tactic (providing
    examples to a prompt) and provide the structure of a database, along with examples,
    to demonstrate what data is created and where. Take for example the following
    prompt requesting SQL data to be generated across two different tables. First,
    we set out the initial instructions for the prompt using delimiter and structured
    format tactic:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是采用少样本策略（向提示提供示例）并提供数据库的结构，以及示例，以展示创建的数据以及数据所在的位置。以以下请求生成跨两个不同表的SQL数据的提示为例。首先，我们使用分隔符和结构化格式策略为提示设置初始指令：
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a SQL generator. Take the sql statement delimited by three hashes
    and create a SQL statement that generates 5 new records that follow the format
    of the provided statement. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 你是一个SQL生成器。使用由三个井号分隔的sql语句创建一个SQL语句，该语句生成5个新的记录，这些记录遵循提供的语句格式。 |'
- en: 'We then have the LLM work out the solution before sharing the output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们让LLM在分享输出之前先找出解决方案：
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| Check that each new entry doesn’t match the provided SQL statement before
    outputting the newly generated data and that the SQL can be executed successfully
    before outputting it. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 在输出新生成数据之前检查每个新条目是否与提供的SQL语句不匹配，并且在输出之前确保SQL可以成功执行。 |'
- en: Finally, we provide the SQL for each table for the LLM to process
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为每个表提供SQL语句供LLM处理
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In this prompt, we’ve provided SQL statements for two different tables connected
    via the `roomid`. The first is the `rooms` table, which has the following attributes
    (laid out in a more readable format):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个提示中，我们提供了通过`roomid`连接的两个不同表的SQL语句。第一个是`rooms`表，它具有以下属性（以更易读的格式列出）：
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'And the second is the `bookings` table:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`bookings`表：
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Providing the LLM with both `CREATE` and `INSERT` statements helps maximize
    the desired output, ensuring not only that the correct type of test data is created,
    but also that the relationship between data sets is correct. If we were to provide
    only insert statements, we’d be providing less context and increasing the risk
    of foreign keys being populated with relationships to nonexistent records.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 向LLM提供`CREATE`和`INSERT`语句有助于最大化期望的输出，确保不仅正确类型的测试数据被创建，而且数据集之间的关系也是正确的。如果我们只提供插入语句，我们将提供较少的上下文，并增加外键被填充到不存在记录的关系中的风险。
- en: 'Sending this prompt to ChatGPT returned the following response:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将此提示发送到ChatGPT返回以下响应：
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI logo](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The test data inserted is similar to the responses from other prompts, but there
    is now the addition of `roomid` values using ids that connect the bookings to
    existing rooms, which have also been generated in the response.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的测试数据与来自其他提示的响应相似，但现在增加了使用`roomid`值的`roomid`，这些值将预订与现有房间连接起来，这些房间也在响应中生成。
- en: What these prompts have demonstrated is that if we have data that contains complex
    relationships or many different parameters, we can use existing documentation
    to assist test data generation. This is not only a great time saver but also an
    approach that ensures our test data generation can stay in lockstep with the structure
    of our data at any given time, saving us even more time in test data maintenance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提示所展示的是，如果我们有包含复杂关系或许多不同参数的数据，我们可以使用现有文档来协助测试数据生成。这不仅是一个节省时间的好方法，而且也是一个确保我们的测试数据生成可以与任何给定时间的数据结构保持同步的方法，从而在测试数据维护上节省我们更多的时间。
- en: Don’t forget data privacy
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记数据隐私
- en: In the examples provided in this chapter, we’ve used dummy data structures and
    specifications, but when we create test data for our applications it’s likely
    that we’ll rely on either our organization’s intellectual property or user data.
    If we are to use those items to create our test data, we need to make sure that
    we aren’t violating internal policies for sharing intellectual property or laws
    around user data privacy. Depending on what we can and can’t share will determine
    how we frame our prompts.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章提供的示例中，我们使用了虚拟数据结构和规范，但当我们为我们的应用程序创建测试数据时，我们可能会依赖于我们组织的知识产权或用户数据。如果我们打算使用这些项目来创建我们的测试数据，我们需要确保我们没有违反内部关于知识产权共享的政策或用户数据隐私的法律。根据我们可以和不能分享的内容，将决定我们如何构建我们的提示。
- en: Activity 6.4
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 活动六.4
- en: Use the SQL prompt to create your own test data. Try either locating SQL from
    an application you are working on or using example SQL to see what happens.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL提示创建您自己的测试数据。尝试从您正在工作的应用程序中定位SQL或使用示例SQL来查看会发生什么。
- en: 6.3 Setting up LLMs as test data managers
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 设置LLMs作为测试数据管理员
- en: 'We’ve examined how to create data by sending prompts through tools such as
    ChatGPT. But how can we go about integrating these types of prompts into our automated
    checks? Let’s take a look at the potential of accessing LLMs via API platforms
    by enhancing this simple UI automated check with data generation from an LLM model:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何通过发送提示通过工具如ChatGPT来创建数据。但我们如何将这些类型的提示集成到我们的自动化检查中？让我们通过增强这个简单的UI自动化检查，并使用LLM模型的数据生成来查看访问LLMs通过API平台的潜力：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We use Selenium to open a webpage:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Selenium打开网页：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we complete the Contact Us form on the webpage:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在网页上完成“联系我们”表单：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we assert that the contact form page has been submitted:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们断言联系表单页面已被提交：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this automated check, we’re going to replace the hardcoded strings used
    to complete the contact form and instead connect to the OpenAI API platform and
    prompt one of their LLM models to create test data that we can then parse and
    use in our check. Examples of the initial and completed OpenAI integrated check
    can be found in the supporting repository at [https://mng.bz/n0dv](https://mng.bz/n0dv).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个自动检查，我们将用硬编码的字符串替换完成联系表单所用的字符串，并连接到OpenAI API平台，提示其LLM模型创建测试数据，然后我们可以解析并用于我们的检查。初始和完成的OpenAI集成检查的示例可以在支持存储库[https://mng.bz/n0dv](https://mng.bz/n0dv)中找到。
- en: 6.3.1 Setting up an OpenAI account
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 设置OpenAI账户
- en: Before we can start sending prompts using the OpenAI API platform, we’ll need
    to set up an account. This can be done by registering via [https://platform.openai.com/](https://platform.openai.com/).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用OpenAI API平台发送提示之前，我们需要设置一个账户。这可以通过在[https://platform.openai.com/](https://platform.openai.com/)注册来完成。
- en: OpenAI platform costs
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI平台费用
- en: 'OpenAI charges based on the number of tokens you send to and receive from an
    LLM. A *token* is essentially a word or collection of smaller words. For example,
    “Hello ChatGPT” would count as two tokens. The more tokens you use, meaning the
    bigger the prompts and content you receive back, the more it costs. If you are
    registering for a new account with OpenAI at this point, they will give you $5
    in free credit that can be used during your first three months. This is more than
    enough for what we need to complete our exercise. However, since the free credit
    expires after three months, if you have no free credits left, you will need to
    provide billing details before you can send and receive prompts: [https://mng.bz/vJRx](https://mng.bz/vJRx).
    Also, you are strongly advised to set a usage limit that works best for you so
    that you don’t end up with a surprising bill: [https://platform.openai.com/account/billing/limits](https://platform.openai.com/account/billing/limits).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI根据您发送到和从LLM（大型语言模型）接收的token数量来收费。一个*token*本质上是一个单词或一组较小的单词。例如，“Hello ChatGPT”算作两个token。您使用的token越多，意味着您收到的提示和内容越大，费用也就越高。如果您此时正在注册OpenAI的新账户，他们将会给您5美元的免费信用额度，您可以在前三个月内使用。这已经足够我们完成练习所需了。然而，由于免费信用额度在三个月后到期，如果您没有剩余的免费信用额度，您需要在发送和接收提示之前提供账单详情：[https://mng.bz/vJRx](https://mng.bz/vJRx)。此外，强烈建议您设置一个最适合您的使用限制，以免最终收到令人惊讶的账单：[https://platform.openai.com/account/billing/limits](https://platform.openai.com/account/billing/limits)。
- en: Once registered, we need to generate an API key that we’ll provide in our requests
    to authenticate ourselves. This can be done via [https://platform.openai.com/account/api-keys](https://platform.openai.com/account/api-keys)
    and clicking the Create New Secret Key button, which asks us to give our API key
    a name. Upon entering a name and clicking the Create key, we’ll be given an API
    key, as shown in figure 6.1.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，我们需要生成一个API密钥，我们将将其提供在我们的请求中以进行身份验证。这可以通过[https://platform.openai.com/account/api-keys](https://platform.openai.com/account/api-keys)完成，点击“创建新密钥”按钮，它要求我们为API密钥命名。在输入名称并点击“创建密钥”后，我们将获得一个API密钥，如图6.1所示。
- en: '![](../../OEBPS/Images/CH06_F01_Winteringham2.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F01_Winteringham2.png)'
- en: Figure 6.1 A newly created API key for the Open API platform
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 Open API平台的新创建的API密钥
- en: As the instructions state, we need to record this API key elsewhere for future
    use as we’ll not be able to view it again. So, we make a note of the key and then
    click Done to make sure our key has been saved, as shown in figure 6.2.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 根据说明，我们需要将此API密钥记录在其他地方以备将来使用，因为我们无法再次查看它。因此，我们记录下密钥，然后点击“完成”以确保我们的密钥已被保存，如图6.2所示。
- en: '![](../../OEBPS/Images/CH06_F02_Winteringham2.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F02_Winteringham2.png)'
- en: Figure 6.2 Screen shot of the API key manager for the OpenAI API platform
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 OpenAI API平台API密钥管理器的屏幕截图
- en: With our key created and recorded, we’re ready to begin work on integrating
    OpenAI into our project.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建并记录了密钥之后，我们就可以开始将OpenAI集成到我们的项目中了。
- en: 6.3.2 Connecting to OpenAI
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 连接到OpenAI
- en: 'Our first step is to build the necessary code to send an HTTP request to OpenAI
    and confirm that we can get a response back. So, we begin by adding the following
    library into our `pom.xml` that we’ll use to send our request:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的第一步是构建必要的代码，向OpenAI发送HTTP请求并确认我们能够收到响应。因此，我们首先将以下库添加到我们的`pom.xml`文件中，我们将使用它来发送我们的请求：  '
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: LangChain4j is a Java implementation of the popular LangChain toolset that’s
    written in Python. It offers a collection of tools that can be used to integrate
    with different LLMs. For our example test, we’ll be relying on OpenAI’s GPT models
    to generate our test data. So, we’ll use the OpenAI specific version of LangChain
    to get basic access to sending a prompt. However, if we wanted more control or
    options, we could use the full AI services version of LangChain.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain4j是LangChain工具集的Java实现，该工具集是用Python编写的。它提供了一系列工具，可用于与不同的LLM集成。在我们的示例测试中，我们将依赖OpenAI的GPT模型来生成我们的测试数据。因此，我们将使用OpenAI特定的LangChain版本来获取发送提示的基本访问权限。然而，如果我们想要更多的控制或选项，我们可以使用LangChain的完整AI服务版本。
- en: gpt-3.5-turbo and other models
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: gpt-3.5-turbo和其他模型
- en: One of the features offered by the OpenAI API platform is the ability to send
    prompts to different LLM models. gpt-3.5-turbo is the model that is, at the time
    of writing, used to power the free version of ChatGPT. As we’ll learn, we can
    swap this out to call other models such as gpt-4o. Different models offer different
    features at different price points. For example, gpt-4o is a more effective LLM
    compared to gpt-3.5-turbo. However, the price point to use gpt-4o is much higher.
    More details on other models can be found in the OpenAI platform documentation
    at [https://platform.openai.com/docs/models/overview](https://platform.openai.com/docs/models/overview).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI API 平台提供的一项功能是能够向不同的 LLM 模型发送提示。gpt-3.5-turbo 是在撰写本文时用于驱动 ChatGPT 免费版本的模型。我们将了解到，我们可以将其替换为调用其他模型，如
    gpt-4o。不同的模型在不同的价格点提供不同的功能。例如，gpt-4o 相比于 gpt-3.5-turbo 是一个更有效的 LLM。然而，使用 gpt-4o
    的价格点要高得多。有关其他模型的更多详细信息，请参阅 OpenAI 平台文档[https://platform.openai.com/docs/models/overview](https://platform.openai.com/docs/models/overview)。
- en: 'With the necessary libraries installed, our next step is to build a prompt
    that will request an LLM to generate our required test data. The initial instructions
    use the structured output and delimiter tactics:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了必要的库之后，我们的下一步是构建一个请求 LLM 生成所需测试数据的提示。初始指令使用结构化输出和分隔符策略：
- en: '|'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a data generator. Create me random data in a JSON format based on
    the criteria delimited by three hashes. Additional data requirements are shared
    between back ticks. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 你是一个数据生成器。根据由三个井号分隔的标准创建随机数据，并以 JSON 格式提供。额外的数据要求在反引号之间共享。|'
- en: 'Data to be processed is added with additional instructions:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了额外说明要处理的数据：
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| ###nameemailphone `UK format`subject `Over 20 characters in length`description
    `Over 50 characters in length`### |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| ###nameemailphone `UK format`subject `Over 20 characters in length`description
    `Over 50 characters in length`### |'
- en: 'We can test this prompt by adding it and the necessary code to send the prompt
    into a new automated check:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加此提示和必要的代码将其发送到新的自动化检查来测试此提示：
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We create a new OpenAIChat model and provide an API key:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的 OpenAIChat 模型并提供 API 密钥：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we add our prompt to a string:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们的提示添加到字符串中：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we send the prompt to a GPT model and store the response in a string:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将提示发送到 GPT 模型并将响应存储在字符串中：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running the check again, we’ll see the LLM returns something similar to
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行检查，我们将看到 LLM 返回类似的内容
- en: '|'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Next, we’ll need to parse this into a Java object, so we create a new class
    `ContactFormDetails` that can convert the JSON into an object:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将此解析为 Java 对象，因此我们创建一个新的类 `ContactFormDetails`，它可以把 JSON 转换为对象：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With our `ContactFormDetails` class created, we can now convert the prompt
    response, which is currently a string, into a POJO for further use:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了 `ContactFormDetails` 类之后，我们现在可以将当前为字符串的提示响应转换为 POJO 以供进一步使用：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We now have the necessary test data to use in our automated check:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了在自动化检查中使用所需的测试数据：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following block of code sends a prompt to OpenAI to generate test data:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块将提示发送到 OpenAI 以生成测试数据：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we extract the test data from the responses and convert it into an object:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从响应中提取测试数据并将其转换为对象：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we use the test data to complete the Contact Us form and assert success:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用测试数据来完成“联系我们”表单并断言成功：
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This completes the integration of the OpenAI API platform into our automated
    check. Upon executing the check, we should see it pass and that test data has
    been successfully used to create a contact message, as shown in figure 6.3.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 OpenAI API 平台集成到我们的自动化检查中。在执行检查时，我们应该看到它通过，并且测试数据已成功用于创建联系信息，如图 6.3 所示。
- en: We could improve the code further by perhaps storing prompts in external files
    and importing them into our checks when required. This may be beneficial when
    prompts are used on multiple occasions. It would also mean that when changes are
    required for test data, we would simply update our prompts with new details in
    a way that anyone, regardless of the experience of working with test data, could
    do.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将提示存储在外部文件中并在需要时将它们导入到我们的检查中进一步改进代码。这可能在使用提示多次时是有益的。这也意味着，当需要更改测试数据时，我们只需以新的详细信息更新我们的提示即可，这样无论谁，无论其与测试数据工作的经验如何，都可以做到。
- en: '![](../../OEBPS/Images/CH06_F03_Winteringham2.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH06_F03_Winteringham2.png)'
- en: Figure 6.3 A message created using LLM test data
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 使用 LLM 测试数据创建的消息
- en: Activity 6.5
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 6.5
- en: Create a new automated check that requires inputting test data. Using the prompt
    method, create a new prompt to generate test data and then pass it through your
    automated check.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的需要输入测试数据的自动化检查。使用提示方法，创建一个新的提示来生成测试数据，然后将其传递到您的自动化检查中。
- en: 6.4 Benefiting from generated test data
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 从生成的测试数据中获益
- en: This chapter demonstrated that LLMs can be quite adept at generating test data.
    It can help us quickly create data for various testing activities from automation
    to exploratory testing, support managing complex data sets, and simplify the process
    of managing test data using natural language prompts. However, for this, we need
    to create prompts that provide clear instructions about the format we want data
    in and what examples to draw from, ensuring that what we’re sending to an LLM
    doesn’t impact personal and organizational privacy. Going back to our area of
    effect model, we can see the roles of humans and AI in test data generation described
    in figure 6.4.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了 LLM 在生成测试数据方面非常擅长。它可以帮助我们快速创建用于各种测试活动的数据，从自动化测试到探索性测试，支持管理复杂的数据集，并简化使用自然语言提示管理测试数据的过程。然而，为此，我们需要创建提供关于我们想要的数据格式和从中抽取的示例的明确说明的提示，确保我们发送给
    LLM 的内容不会影响个人和组织隐私。回到我们的影响范围模型，我们可以看到图 6.4 中描述的人类和 AI 在测试数据生成中的角色。
- en: '![](../../OEBPS/Images/CH06_F04_Winteringham2.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F04_Winteringham2.png)'
- en: Figure 6.4 The area of effect model describing the roles of humans and AI in
    test data generation
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 描述人类和 AI 在测试数据生成中角色的影响范围模型
- en: By using the tactics we’ve learned with prompt engineering in a creative manner,
    we can create test data for a wide range of situations, from simple to complex,
    to help us save time in test data management.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以创造性的方式使用我们学到的提示工程策略，我们可以为各种情况创建测试数据，从简单到复杂，以帮助我们节省测试数据管理的时间。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Prompts can be built to rapidly generate data in any common format (JSON, XML,
    or SQL, for example).
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以构建提示来快速生成任何常见格式的数据（例如 JSON、XML 或 SQL）。
- en: The relationship between data can sometimes be incorrect if not explicitly set
    in a prompt.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在提示中未明确设置，数据之间的关系有时可能是不正确的。
- en: Prompts can also be built to transform data from one format into another, while
    ensuring the raw data from an original format is copied over.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以构建提示来将数据从一种格式转换为另一种格式，同时确保从原始格式复制的原始数据。
- en: We can use data specification formats such as OpenAPI and XSD in prompts to
    set our expectations of how data is structured.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在提示中使用数据规范格式，如 OpenAPI 和 XSD，来设置我们对数据结构的期望。
- en: Using SQL statements that create the initial structure of a database can be
    used to prompt LLMs when working with distributed data structures.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用创建数据库初始结构的 SQL 语句可以用来在处理分布式数据结构时提示 LLM。
- en: OpenAI offers an API platform that can be used to interact with different AI
    models, including gpt-3.5 and gpt-4o.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI 提供了一个 API 平台，可以用来与不同的 AI 模型交互，包括 gpt-3.5 和 gpt-4o。
- en: We can programmatically build HTTP requests to send prompts to OpenAI LLMs to
    generate test data.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编程构建 HTTP 请求，将提示发送到 OpenAI LLM 以生成测试数据。
- en: Prompting LLMs for test data requires building clear prompts with explicit expectations
    and useful examples.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试数据提示 LLM 需要构建具有明确期望和有用示例的清晰提示。
