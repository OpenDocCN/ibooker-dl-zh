["```py\nInput: Graph G = (V, E) with each edge e ∈ E having a weight w(e)\nOutput: A minimum spanning tree T\n\nCreate a new graph T:= ∅ with the same vertices as G, but with no edges.\nDefine a list S containing all the edges in the graph G\nSort the edges list S in ascending order of their weights.\nFor each edge e in the sorted list:\n   If adding edge e to T does not form a cycle:\n      Add this edge to T.\n   Else:\n      Skip this edge and move to the next edge in the list.\nContinue this process until all the edges are processed.\nReturn T as the minimum spanning tree of graph G.\n```", "```py\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nG = nx.Graph()                                                          ①\nG.add_nodes_from([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"])    ①\n\nedges = [                                                               ①\n    (\"A\", \"B\", {\"weight\": 10}),                                         ①\n    (\"A\", \"C\", {\"weight\": 5}),                                          ①\n    (\"A\", \"D\", {\"weight\": 3}),                                          ①\n    (\"A\", \"E\", {\"weight\": 4}),                                          ①\n    (\"B\", \"C\", {\"weight\": 2}),                                          ①\n    (\"B\", \"F\", {\"weight\": 6}),                                          ①\n    (\"C\", \"E\", {\"weight\": 11}),                                         ①\n    (\"C\", \"F\", {\"weight\": 3}),                                          ①\n    (\"C\", \"G\", {\"weight\": 2}),                                          ①\n    (\"D\", \"E\", {\"weight\": 3}),                                          ①\n    (\"D\", \"H\", {\"weight\": 5}),                                          ①\n    (\"E\", \"G\", {\"weight\": 5}),                                          ①\n    (\"E\", \"H\", {\"weight\": 1}),                                          ①\n    (\"F\", \"G\", {\"weight\": 2}),                                          ①\n    (\"F\", \"I\", {\"weight\": 7}),                                          ①\n    (\"F\", \"J\", {\"weight\": 13}),                                         ①\n    (\"G\", \"H\", {\"weight\": 4}),                                          ①\n    (\"G\", \"I\", {\"weight\": 3}),                                          ①\n    (\"H\", \"I\", {\"weight\": 6}),                                          ①\n    (\"I\", \"J\", {\"weight\": 2}),                                          ①\n]                                                                       ①\n\nG.add_edges_from(edges)\npos = nx.spring_layout(G, seed=74)                                      ②\n\ndef Kruskal(G, attr = \"weight\"):\n    edges = sorted(G.edges(data=True), key=lambda t: t[2].get(attr, 1)) ③\n    mst = nx.Graph()\n    mst.add_nodes_from(G)\n    for e in edges:\n        mst.add_edges_from([e])\n        try:                                                            ④\n            nx.find_cycle(mst)                                          ④\n            mst.remove_edge(e[0], e[1])                                 ④\n        except:\n            if nx.is_connected(mst):                                    ⑤\n                break\n            continue\n    return mst\n```", "```py\nMST = Kruskal(G).edges                                                  ①\nlabels = nx.get_edge_attributes(G, \"weight\")\nnx.draw_networkx_edges(G, pos, list(MST), width=4, edge_color=\"red\")    ②\nnx.draw_networkx_edge_labels(G, pos, edge_labels=labels)                ③\nnx.draw_networkx(G, pos, with_labels=True, font_color=\"white\")          ④\nplt.show()\n```", "```py\nimport networkx as nx\nimport osmnx\nimport matplotlib.pyplot as plt\nfrom optalgotools.algorithms.graph_search import Kruskal\n\nreference = (43.661667, -79.395)\nG = osmnx.graph_from_point(\n    reference, dist=1000, clean_periphery=True, simplify=True, network_\ntype=\"drive\"\n)                                                                     ①\nfig, ax = osmnx.plot_graph(G)\n\nundir_G = G.to_undirected()                                           ②\nsorted_edges = sorted(undir_G.edges(data=True), key=lambda t:         ②\n➥ t[2].get(\"length\",1))                                              ②\n\nmst = Kruskal(G, sorted_edges=True, edges= sorted_edges,\n➥ graph_type=nx.MultiDiGraph)                                        ③\n\nhighlight_edges = ['b' if e in mst.edges else 'r' for e in G.edges]   ④\nedge_alphas = [1 if e in mst.edges else 0.25 for e in G.edges]        ④\nosmnx.plot_graph(\n    G, \n    edge_linewidth=2, \n    edge_color=highlight_edges, \n    edge_alpha=edge_alphas\n)                                                                     ④\nplt.show()                                                            ④\n```", "```py\nInputs: Source node, Destination node\nOutput: Route from source to destination\n\nInitialize current ← random route from source to destination\nInitialize neighbours ← children of current\n\nWhile min(neighbours) > current do\n   Set current ← min(neighbours)\n   Update neighbours ← children of current\nReturn current as the route from source to destination\n```", "```py\nimport matplotlib.pyplot as plt\n\ndef Hill_Climbing(origin, destination, cost_fn):\n    costs = [cost_fn(origin)]\n    current = origin\n    route = [current]\n    neighbours = current.expand()                           ①\n    shortest = min(neighbours, key=lambda s: cost_fn(s))    ②\n    costs.append(cost_fn(shortest))\n    route.append(shortest)\n\n    while cost_fn(shortest) < cost_fn(current):\n        current = shortest\n        neighbours = current.expand()\n        shortest = min(neighbours, key=lambda s: cost_fn(s))\n        costs.append(cost_fn(shortest))\n        route.append(shortest)\n        if shortest == destination:                         ③\n            break\n\n    return route, costs\n\ndef misplaced_tiles(state: State):                          ④\n    flat = state.flatten()                                  ④\n    goal = range(len(flat))                                 ④\n    return sum([0 if goal[i] == flat[i] else 1 for i in range(len(flat))])    \n```", "```py\ninit_state = [[1,4,2],\n              [3,7,5],\n              [6,0,8]]\n\ngoal_state = [[0,1,2],\n              [3,4,5],\n              [6,7,8]]\n\ninit_state = State(init_state)\ngoal_state = State(goal_state)\n\nif not init_state.is_solvable():                             ①\n    print(\"This puzzle is not solvable.\")\nelse:\n    solution, costs = Hill_Climbing(init_state, goal_state,\n    ➥ misplaced_tiles)                                      ②\n    plt.xticks(range(len(costs)))                            ③\n    plt.ylabel(\"Misplaced tiles\")                            ③\n    plt.title(\"Hill climbing: 8 Puzzle\")                     ③\n    plt.plot(costs)                                          ③\n    visualize(solution)                                      ③\n```", "```py\nInputs: A source node, a destination node, and beam width w\nOutput: A route from source to destination\n\nInitialize Seen ← nil\nInitialize beam ← random w routes from source to destination\nAdd beam to seen\nInitialize pool ← children of routes in the beam with consideration of seen + beam\nInitialize last_beam ← nil\nWhile beam is not last_beam do\n   Update last_beam ← beam\n   Update beam ← the best w routes from pool\n   If last_beam == beam then break\n   Add beam to seen\n   Update pool ← children of routes in the beam + beam\n\nReturn optimal route in beam\n```", "```py\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport heapq\nfrom optalgotools.structures import Node\nfrom optalgotools.routing import cost\n\nG = nx.Graph()                                               ①\nG.add_nodes_from([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"S\"])   ①\nedges = [\n    (\"A\", \"B\", {\"weight\": 4}),\n    (\"A\", \"C\", {\"weight\": 3}),\n    (\"A\", \"S\", {\"weight\": 2}),\n    (\"B\", \"D\", {\"weight\": 3}),\n    (\"B\", \"S\", {\"weight\": 4}),\n    (\"C\", \"E\", {\"weight\": 4}),\n    (\"C\", \"D\", {\"weight\": 5}),\n    (\"D\", \"E\", {\"weight\": 6}),\n    (\"D\", \"F\", {\"weight\": 5}),\n    (\"E\", \"F\", {\"weight\": 7}),\n    (\"E\", \"G\", {\"weight\": 3}),\n    (\"F\", \"G\", {\"weight\": 3}),\n]                                                            ①\nG.add_edges_from(edges)                                      ①\nG=G.to_directed()                                            ①\n\ndef Beam_Search(G, origin, destination, cost_fn, w=2, expand_kwargs=[],\n➥ cost_kwargs=[]):\n    seen = set()\n    seen.add(origin)\n    last_beam = None\n    pool = set(origin.expand(**expand_kwargs))               ②\n    beam = []\n    while beam != last_beam:\n        last_beam = beam\n        beam = heapq.nsmallest(\n            w, pool, key=lambda node: cost_fn(G, node.path(),\n            ➥ **cost_kwargs))                               ③\n        current = beam.pop(0)\n        seen.add(current)\n        pool.remove(current)\n        children = set(current.expand(**expand_kwargs))\n        for child in children:                               ④\n            if child in seen: next                           ④\n            else:    #D                                      ④\n                if child == destination:                     ④\n                    return child.path()                      ④\n                beam.append(child)                           ④\n        pool.update(beam)\n    return None                                              ⑤\n```", "```py\nresult = Beam_Search(\n    G,\n    Node(G, \"S\"),\n    Node(G, \"G\"),\n    cost,\n    expand_kwargs={\"attr_name\": \"weight\"},\n    cost_kwargs={\"attr_name\": \"weight\"},\n)\n```", "```py\nInputs: Source node, Destination node\nOutput: Route from source to destination\n\nInitialize A* heuristic ← sum of straight-line distance to source and destination\nInitialize PQ ← min heap according to A* heuristic\nInitialize frontier ← a PQ initialized with source\nInitialize explored ← empty\nInitialize found ← False\n\nWhile frontier is not empty and found is False do\n    Set node ← frontier.pop()\n    Add node to explored\n    For child in node.expand() do\n        If child is not in explored and child is not in frontier then\n            If child is destination then\n                Update route ← child.route()\n                Update found ← True\n            Add child to frontier\n\nReturn route\n```", "```py\nimport matplotlib.pyplot as plt\nfrom optalgotools.structures import Node\nfrom optalgotools.routing import cost\nimport networkx as nx\nimport heapq\n\ndef A_Star(\n    G, origin, destination, heuristic_fn, cost_fn, cost_kwargs=[],\n    ➥ expand_kwargs=[]\n):\n    toDestination = heuristic_fn(G, origin, destination)\n    toOrigin = {}\n    route = []\n    frontier = list()\n    frontier.append(origin)\n    toOrigin[origin] = 0\n    explored = set()\n    found = False\n    while frontier and not found:\n        node = min(frontier, key=lambda node: toOrigin[node] +\n        ➥ toDestination[node])                                           ①\n        frontier.remove(node)\n        explored.add(node)\n        for child in node.expand(**expand_kwargs):                        ②\n            if child not in explored and child not in frontier:           ②\n                if child == destination:                                  ②\n                    route = child.path()                                  ②\n                    found = True                                          ②\n                    continue                                              ②\n                frontier.append(child)                                    ②\n                toOrigin[child] = cost_fn(G, child.path(), **cost_kwargs) ③\n    return route\n```", "```py\nresult = A_Star(\n    G,\n    Node(G, \"S\"),\n    Node(G, \"G\"),\n    dummy_astar_heuristic,\n    cost,\n    expand_kwargs={\"attr_name\": \"weight\"},\n    cost_kwargs={\"attr_name\": \"weight\"},)\n```", "```py\n!pip install haversine                     ①\nfrom haversine import haversine            ①\n\nLA = (34.052235, -118.243683)              ②\n\nMadrid = (40.416775, -3.703790)            ③\n\ndistance = haversine(LA, Madrid)           ④\nprint(distance)\n```", "```py\nfor each pair (u,v)and (v,w)of edges:\n   if <u,v,w> is a unique shortest path then\n      add shortcut(u,w) with weight ω(<u,v,w>)or ω(<u,w>)+ω(<v,w>)\n```", "```py\nimport networkx as nx\n\nshortcuts = {}\nshortest_paths = dict(nx.all_pairs_dijkstra_path_length(G,\n➥ weight=\"weight\"))\ncurrent_G = G.copy()                                                     ①\nfor node in G.nodes:\n    current_G.remove_node(node)                                          ②\n    current_shortest_paths = dict(\n        nx.all_pairs_dijkstra_path_length(current_G, weight=\"weight\")\n    )                                                                    ③\n    for u in current_shortest_paths:\n        if u == node:\n            continue\n        SP_contracted = current_shortest_paths[u]\n        SP_original = shortest_paths[u]\n        for v in SP_contracted:\n            if u == v or node == v:\n                continue\n            if (\n                SP_contracted[v] != SP_original[v]\n                and G.has_edge(node, u)\n                and G.has_edge(node, v)\n            ):\n                G.add_edge(u, v, weight=SP_original[v],contracted=True)  ④\n                shortcuts[(u,v)] = node                                  ④\n```", "```py\nsln = bidirectional_dijkstra(G, 1, 5, hierarchy, weight=\"weight\")      ①\n\nuncontracted_route = [sln.result[0]]                                   ②\nfor u, v in zip(sln.result[:-1], sln.result[1:]): ]]                   ②\n    if (u, v) in shortcuts: ]]                                         ②\n        uncontracted_route.append(shortcuts[(u, v)])                   ②\n    uncontracted_route.append(v)                                       ②\n```", "```py\ndef Hill_Climbing(G, origin, destination, n=20):\n    time_start = process_time()                                        ①\n    costs = []                                                         ①\n\n    current = randomized_search(G, origin.osmid, destination.osmid)    ②\n    costs.append(cost(G, current))\n\n    neighbours = list(islice(get_child(G, current), n))                ③\n    space_required = getsizeof(neighbours)\n    shortest = min(neighbours, key=lambda route: cost(G, route))\n\n    while cost(G, shortest) < cost(G, current):\n        current = shortest\n        neighbours = list(islice(get_child(G, current), n))\n        shortest = min(neighbours, key=lambda route: cost(G, route))\n        costs.append(cost(G, current))\n\n    route = current\n    time_end = process_time()\n    return Solution(route, time_end - time_start, space_required, costs)\n```", "```py\ndef get_beam(G, beam, n=20):\n    new_beam = []\n    for route in beam:\n        neighbours = list(islice(get_child(G, route), n))                  ①\n        new_beam.extend(neighbours)\n    return new_beam\n\ndef Beam_Search(G, origin, destination, k=10, n=20):\n    start_time = process_time()\n    seen = set()                                                           ②\n    costs = []                                                             ②\n    beam = [randomized_search(G, origin.osmid, destination.osmid) for _ in ②\n    ➥  range(k)]                                                          ②\n\n    for route in beam:                                                     ③\n        seen.add(tuple(route))\n\n    pool = []\n    children = get_beam(G, beam, n)\n    costs.append([cost(G, r) for r in beam])\n    for r in children:\n        if tuple(r) in seen:\n            continue\n        else:\n            pool.append(r)\n            seen.add(tuple(r))\n    pool += beam\n    space_required = getsizeof(pool)\n    last_beam = None\n    while beam != last_beam:                                               ④\n        last_beam = beam\n        beam = heapq.nsmallest(k, pool, key=lambda r: cost(G, r))\n\n        for route in beam:\n            seen.add(tuple(route))\n\n        pool = []\n        children = get_beam(G, beam, n)\n        costs.append([cost(G, r) for r in beam])\n        for r in children:\n            if tuple(r) in seen:\n                continue\n            else:\n                pool.append(r)\n                seen.add(tuple(r))\n        pool += beam\n        space_required = (\n            getsizeof(pool) if getsizeof(pool) > space_required else\n            ➥ space_required\n        )\n    route = min(beam, key=lambda r: cost(G, r))                            ⑤\n    end_time = process_time()\n    return Solution(\n        route, end_time - start_time, space_required, np.rot90(costs))     ⑥\n```", "```py\nimport osmnx\nfrom optalgotools.routing import (cost, draw_route, astar_heuristic)\nfrom optalgotools.structures import Node\nfrom optalgotools.algorithms.graph_search import A_Star\nfrom optalgotools.utilities import haversine_distance\n\nreference = (43.661667, -79.395)                                       ①\n\nG = osmnx.graph_from_point(reference, dist=300, clean_periphery=True,\n➥ simplify=True)                                                      ②\n\norigin = (43.664527, -79.392442)                                       ③\ndestination = (43.659659, -79.397669)                                  ④\n\norigin_id = osmnx.distance.nearest_nodes(G, origin[1], origin[0])      ⑤ \ndestination_id = osmnx.distance.nearest_nodes(G, destination[1],       ⑤\n➥ destination[0])                                                     ⑤\n\norigin = Node(graph=G, osmid=origin_id)                                ⑥\ndestination = Node(graph=G, osmid=destination_id)                      ⑥\n\nsolution = A_Star(G, origin, destination, astar_heuristic,             ⑦\n➥ heuristic_kwargs={\"measuring_dist\": haversine_distance})            ⑦\nroute = solution.result\nprint(f\"Cost: {cost(G,route)} m\")                                      ⑧\nprint(f\"Process time: {solution.time} s\")                              ⑧\nprint(f\"Space required: {solution.space} bytes\")                       ⑧\nprint(f\"Explored nodes: {solution.explored}\")                          ⑧\ndraw_route(G,route) \n```", "```py\ndef edge_differences(G, sp):\n    ed = {}\n    degrees = dict(G.degree)\n    for node in G.nodes:\n        req_edges = 0\n        neighbours = list(G.neighbors(node))\n\n        if len(neighbours)==0: ed[node] = - degrees[node]     ①\n\n        for u, v in G.in_edges(node):\n            for v, w in G.out_edges(node):\n                if u == w: continue                           ②\n                if v in sp[u][w]:\n                    req_edges += 1\n\n        ed[node] = req_edges - degrees[node]                  ③\n\n    return dict(sorted(ed.items(), key=lambda x: x, reverse=True))\n```", "```py\ndef unpack(G, u,v):\n    u = int(u)\n    v = int(v)\n    if \"midpoint\" in G[u][v][0]:\n        midpoint = G[u][v][0][\"midpoint\"]\n        return unpack(G,u,midpoint) + unpack(G,midpoint, v)     ①\n    return [u]\n\nroute = []\nfor u,v in zip(solution.result[:-1], solution.result[1:]):      ②\n    route.extend(unpack(G,u,v))\nroute += [solution.result[-1]]\nprint(route)\n```", "```py\nfrom pyrosm import OSM, get_data\nimport numpy as np\nimport matplotlib.pyplot as plt \n\nosm = OSM(get_data(\"Toronto\"))                                      ①\nnodes, edges = osm.get_network(network_type=\"driving\", nodes=True)  ②\n\nhospitals = osm.get_pois({\"amenity\": [\"hospital\"]})                 ③\n\nG = osm.to_graph(nodes, edges, graph_type='pandana')                ④\n\nhospitals['geometry'] = hospitals.centroid                          ⑤\nhospitals = hospitals.dropna(subset=['lon', 'lat'])                 ⑤\n\nG.precompute(1000)                                                  ⑥\n\nG.set_pois(category='hospitals', maxdist=1000, maxitems=10,         ⑦\n➥ x_col=hospitals.lon, y_col=hospitals.lat)                        ⑦\n\nnearest_five = G.nearest_pois(1000, \"hospitals\", num_pois=5)        ⑧\n```"]