["```py\n#include \"tensorflow/lite/micro/examples/micro_speech/\n  audio_provider.h\"\n\n#include \"PDM.h\"\n#include \"tensorflow/lite/micro/examples/micro_speech/\n  micro_features/micro_model_settings.h\"\n```", "```py\nnamespace {\nbool g_is_audio_initialized = false;\n// An internal buffer able to fit 16x our sample size\nconstexpr int kAudioCaptureBufferSize = DEFAULT_PDM_BUFFER_SIZE * 16;\nint16_t g_audio_capture_buffer[kAudioCaptureBufferSize];\n// A buffer that holds our output\nint16_t g_audio_output_buffer[kMaxAudioSampleSize];\n// Mark as volatile so we can check in a while loop to see if\n// any samples have arrived yet.\nvolatile int32_t g_latest_audio_timestamp = 0;\n}  // namespace\n```", "```py\nvoid CaptureSamples() {\n  // This is how many bytes of new data we have each time this is called\n  const int number_of_samples = DEFAULT_PDM_BUFFER_SIZE;\n  // Calculate what timestamp the last audio sample represents\n  const int32_t time_in_ms =\n      g_latest_audio_timestamp +\n      (number_of_samples / (kAudioSampleFrequency / 1000));\n  // Determine the index, in the history of all samples, of the last sample\n  const int32_t start_sample_offset =\n      g_latest_audio_timestamp * (kAudioSampleFrequency / 1000);\n  // Determine the index of this sample in our ring buffer\n  const int capture_index = start_sample_offset % kAudioCaptureBufferSize;\n  // Read the data to the correct place in our buffer\n  PDM.read(g_audio_capture_buffer + capture_index, DEFAULT_PDM_BUFFER_SIZE);\n  // This is how we let the outside world know that new audio data has arrived.\n  g_latest_audio_timestamp = time_in_ms;\n}\n```", "```py\n// This is how many bytes of new data we have each time this is called\nconst int number_of_samples = DEFAULT_PDM_BUFFER_SIZE;\n// Calculate what timestamp the last audio sample represents\nconst int32_t time_in_ms =\n    g_latest_audio_timestamp +\n    (number_of_samples / (kAudioSampleFrequency / 1000));\n```", "```py\n(number_of_samples / (kAudioSampleFrequency / 1000))\n```", "```py\nconst int32_t start_sample_offset =\n    g_latest_audio_timestamp * (kAudioSampleFrequency / 1000);\n```", "```py\n// Determine the index of this sample in our ring buffer\nconst int capture_index = start_sample_offset % kAudioCaptureBufferSize;\n```", "```py\n// Read the data to the correct place in our buffer\nPDM.read(g_audio_capture_buffer + capture_index, DEFAULT_PDM_BUFFER_SIZE);\n```", "```py\n// This is how we let the outside world know that new audio data has arrived.\ng_latest_audio_timestamp = time_in_ms;\n```", "```py\nTfLiteStatus InitAudioRecording(tflite::ErrorReporter* error_reporter) {\n  // Hook up the callback that will be called with each sample\n  PDM.onReceive(CaptureSamples);\n  // Start listening for audio: MONO @ 16KHz with gain at 20\n  PDM.begin(1, kAudioSampleFrequency);\n  PDM.setGain(20);\n  // Block until we have our first audio sample\n  while (!g_latest_audio_timestamp) {\n  }\n\n  return kTfLiteOk;\n}\n```", "```py\nTfLiteStatus GetAudioSamples(tflite::ErrorReporter* error_reporter,\n                             int start_ms, int duration_ms,\n                             int* audio_samples_size, int16_t** audio_samples) {\n  // Set everything up to start receiving audio\n  if (!g_is_audio_initialized) {\n    TfLiteStatus init_status = InitAudioRecording(error_reporter);\n    if (init_status != kTfLiteOk) {\n      return init_status;\n    }\n    g_is_audio_initialized = true;\n  }\n```", "```py\nconst int start_offset = start_ms * (kAudioSampleFrequency / 1000);\n```", "```py\nconst int duration_sample_count =\n    duration_ms * (kAudioSampleFrequency / 1000);\n```", "```py\nfor (int i = 0; i < duration_sample_count; ++i) {\n  // For each sample, transform its index in the history of all samples into\n  // its index in g_audio_capture_buffer\n  const int capture_index = (start_offset + i) % kAudioCaptureBufferSize;\n  // Write the sample to the output buffer\n  g_audio_output_buffer[i] = g_audio_capture_buffer[capture_index];\n}\n```", "```py\n  // Set pointers to provide access to the audio\n  *audio_samples_size = kMaxAudioSampleSize;\n  *audio_samples = g_audio_output_buffer;\n\n  return kTfLiteOk;\n}\n```", "```py\nint32_t LatestAudioTimestamp() { return g_latest_audio_timestamp; }\n```"]