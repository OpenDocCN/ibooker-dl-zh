["```py\nmake -f tensorflow/lite/micro/tools/make/Makefile test_depthwise_conv_\\\n  test TAGS=\"portable_optimized\"\n```", "```py\n    for (int b = 0; b < batches; ++b) {\n      for (int out_y = 0; out_y < output_height; ++out_y) {\n        for (int out_x = 0; out_x < output_width; ++out_x) {\n          for (int ic = 0; ic < input_depth; ++ic) {\n            for (int m = 0; m < depth_multiplier; m++) {\n              const int oc = m + ic * depth_multiplier;\n              const int in_x_origin = (out_x * stride_width) - pad_width;\n              const int in_y_origin = (out_y * stride_height) - pad_height;\n              int32 acc = 0;\n              for (int filter_y = 0; filter_y < filter_height; ++filter_y) {\n                for (int filter_x = 0; filter_x < filter_width; ++filter_x) {\n                  const int in_x =\n                      in_x_origin + dilation_width_factor * filter_x;\n                  const int in_y =\n                      in_y_origin + dilation_height_factor * filter_y;\n                  // If the location is outside the bounds of the input image,\n                  // use zero as a default value.\n                  if ((in_x >= 0) && (in_x < input_width) && (in_y >= 0) &&\n                      (in_y < input_height)) {\n                    int32 input_val =\n                        input_data[Offset(input_shape, b, in_y, in_x, ic)];\n                    int32 filter_val = filter_data[Offset(\n                        filter_shape, 0, filter_y, filter_x, oc)];\n                    acc += (filter_val + filter_offset) *\n                           (input_val + input_offset);\n                  }\n                }\n              }\n              if (bias_data) {\n                acc += bias_data[oc];\n              }\n              acc = DepthwiseConvRound<output_rounding>(acc, output_multiplier,\n                                                        output_shift);\n              acc += output_offset;\n              acc = std::max(acc, output_activation_min);\n              acc = std::min(acc, output_activation_max);\n              output_data[Offset(output_shape, b, out_y, out_x, oc)] =\n                  static_cast<uint8>(acc);\n            }\n          }\n        }\n      }\n    }\n```", "```py\n                  const int in_x =\n                      in_x_origin + dilation_width_factor * filter_x;\n                  const int in_y =\n                      in_y_origin + dilation_height_factor * filter_y;\n                  // If the location is outside the bounds of the input image,\n                  // use zero as a default value.\n                  if ((in_x >= 0) && (in_x < input_width) && (in_y >= 0) &&\n                      (in_y < input_height)) {\n                    int32 input_val =\n                        input_data[Offset(input_shape, b, in_y, in_x, ic)];\n                    int32 filter_val = filter_data[Offset(\n                        filter_shape, 0, filter_y, filter_x, oc)];\n                    acc += (filter_val + filter_offset) *\n                           (input_val + input_offset);\n                  }\n```"]