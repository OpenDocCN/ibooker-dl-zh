["```py\nInput: an initial feasible solution\nOutput: optimal solution\nBegin\n    While termination criteria not met do\n        Generate a neighboring solution by applying a series of local modifications (or moves)\n        if the new solution is better then\n           Replace the old one \n```", "```py\nInput: an initial feasible solution\nOutput: optimal solution\nBegin\n    While termination criteria not met do\n        Choose the best: s’∈N(s) ← N(s)-T(s)+A(s)\n        Memorize s’ if it improves the best known solution\n        s←s’\n        Update Tab list T(S) and Aspiration criterion A(s)\n```", "```py\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef get_initial_state(board_size):\n    queens = list(range(board_size))\n    random.shuffle(queens)\n    return queens\n```", "```py\ndef num_attacking_queens(queens):\n    board_size = len(queens)\n    num_attacks = 0\n    for i in range(board_size):\n        for j in range(i + 1, board_size):\n            if queens[i]==queens[j] or abs(queens[i] - queens[j]) == j - i:\n                num_attacks += 1\n    return num_attacks \n```", "```py\ndef get_best_move(queens, tabu_list):\n    board_size = len(queens)\n    best_move = None\n    best_num_attacks = board_size * (board_size - 1) // 2\n    for i in range(board_size):\n        for j in range(board_size):\n            if queens[i] != j:\n                new_queens = queens.copy()\n                new_queens[i] = j\n                if str(new_queens) not in tabu_list:\n                    num_attacks = num_attacking_queens(new_queens)\n                    if num_attacks < best_num_attacks:\n                        best_move = (i, j)\n                        best_num_attacks = num_attacks\n    return best_move\n```", "```py\ndef update_tabu_list(tabu_list, tabu_tenure, move):\n    tabu_list.append(str(move))\n    if len(tabu_list) > tabu_tenure:\n        tabu_list.pop(0)\n```", "```py\ndef tabu_search(num_iterations, tabu_tenure, max_non_improvement, queens):\n    num_non_improvement = 0\n    best_queens = queens\n    best_num_attacks = num_attacking_queens(queens)\n    tabu_list = []\n\n    for i in range(num_iterations):\n        move = get_best_move(queens, tabu_list)\n        if move is not None:\n            queens[move[0]] = move[1]\n            update_tabu_list(tabu_list, tabu_tennure, move)\n            num_attacks = num_attacking_queens(queens)\n            if num_attacks < best_num_attacks:\n                best_queens = queens\n                best_num_attacks = num_attacks\n                num_non_improvement = 0\n        else:\n            num_non_improvement += 1\n            if num_non_improvement >= max_non_improvement:\n                break\n\n    return best_queens, num_attacks\n```", "```py\nimport numpy as np\nfrom optalgotools.algorithms import TabuSearch                          ①\nfrom optalgotools.problems import ProblemBase, ContinuousFunctionBase   ②\n\ndef Himmelblau(x,y):\n       return (((x**2+y-11)**2) + (((x+y**2-7)**2)))                    ③\n\nHimmelblau_bounds = np.asarray([[-6, 6], [-6, 6]])                      ④\n\nHimmelblau_obj = ContinuousFunctionBase(Himmelblau, Himmelblau_bounds)  ⑤\n\nts = TabuSearch(max_iter=100, tabu_tenure=5, neighbor_size=50, use_aspiration=True,\n➥ aspiration_limit=2, use_longterm=False, debug=1)                     ⑥\nts.run(Himmelblau_obj)                                                  ⑦\n```", "```py\nTabu search is initialized:\ncurrent value = 148.322\nTabu search is done: \ncurr iter: 100, curr best value: 0.005569730862620958, curr best: sol: [3.00736837 1.98045825], found at iter: 21\n```", "```py\nimport numpy as np\nfrom optalgotools.problems import TSP                                 ①\nfrom ortools.constraint_solver import pywrapcp                        ②\nfrom ortools.constraint_solver import routing_enums_pb2               ③\nimport matplotlib.pyplot as plt\n\nberlin52_tsp_url = 'https://raw.githubusercontent.com/coin-or/jorlib/\nb3a41ce773e9b3b5b73c149d4c06097ea1511680/jorlib-core/src/test/resources/\ntspLib/tsp/berlin52.tsp'                                              ④\n\nberlin52_tsp = TSP(load_tsp_url=berlin52_tsp_url, gen_method='mutate',\n➥ init_method='random')                                              ⑤\n\ncities = berlin52_tsp.cities                                          ⑥\ntsp_dist=berlin52_tsp.eval_distances_from_cities(cities)              ⑥\ntsp_dist_int=list(np.array(tsp_dist).astype(int))                     ⑥\n```", "```py\ndef create_data_model():\n    data = {}\n    data['distance_matrix'] = tsp_dist_int\n    data['num_vehicles'] = 1\n    data['depot'] = 0\n    return data\n```", "```py\ndef distance_callback(from_index, to_index): \n    from_node = manager.IndexToNode(from_index)\n    to_node = manager.IndexToNode(to_index)\n    return data['distance_matrix'][from_node][to_node]\n```", "```py\ndef print_solution(manager, routing, solution):\n    print('Objective: {} meters'.format(solution.ObjectiveValue()))\n    index = routing.Start(0)\n    plan_output = 'Route for vehicle 0:\\n'\n    route_distance = 0\n    while not routing.IsEnd(index):\n        plan_output += ' {} ->'.format(manager.IndexToNode(index))\n        previous_index = index\n        index = solution.Value(routing.NextVar(index))\n        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)\n    plan_output += ' {}\\n'.format(manager.IndexToNode(index))\n    plan_output += 'Route distance: {}meters\\n'.format(route_distance)\n```", "```py\ndata = create_data_model()                                                ①\nmanager = pywrapcp.RoutingIndexManager(len(data['distance_matrix']),\n➥                                       data['num_vehicles'], data['depot'])\nrouting = pywrapcp.RoutingModel(manager)\n\ntransit_callback_index = routing.RegisterTransitCallback(distance_callback)      \n\nrouting.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\nsearch_parameters = pywrapcp.DefaultRoutingSearchParameters()\nsearch_parameters.local_search_metaheuristic = (\n➥    routing_enums_pb2.LocalSearchMetaheuristic.TABU_SEARCH)             ②\nsearch_parameters.time_limit.seconds = 30\nsearch_parameters.log_search = True\n\nsolution = routing.SolveWithParameters(search_parameters)                 ③\nif solution:\n    print_solution(manager, routing, solution)\n```", "```py\ndef get_routes(solution, routing, manager):\n  routes = []\n  for route_nbr in range(routing.vehicles()):\n    index = routing.Start(route_nbr)\n    route = [manager.IndexToNode(index)]\n    while not routing.IsEnd(index):\n      index = solution.Value(routing.NextVar(index))\n      route.append(manager.IndexToNode(index))\n    routes.append(route)\n  return routes\n\nroutes = get_routes(solution, routing, manager)\n\nfor i, route in enumerate(routes):   ①\n  print('Route', i, route)\nberlin52_tsp.plot(route)             ②\n```", "```py\nObjective: 7884 meters\nRoute for vehicle 0:\n 0 -> 21 -> 31 -> 44 -> 18 -> 40 -> 7 -> 8 -> 9 -> 42 -> 32 -> 50 -> 11 -> 10 \n -> 51 -> 13 -> 12 -> 26 -> 27 -> 25 -> 46 -> 28 -> 29 -> 1 -> 6 -> 41 -> 20 \n -> 16 -> 2 -> 17 -> 30 -> 22 -> 19 -> 49 -> 15 -> 43 -> 45 -> 24 -> 3 -> 5 \n -> 14 -> 4 -> 23 -> 47 -> 37 -> 36 -> 39 -> 38 -> 33 -> 34 -> 35 -> 48 -> 0\n```", "```py\nfrom optalgotools.algorithms import TabuSearch                           ①\n\nts = TabuSearch(max_iter=100, tabu_tenure=5, neighbor_size=10000,\n➥ use_aspiration=True, aspiration_limit=2, use_longterm=False, debug=1) ②\n\nts.init_ts(berlin52_tsp,'random')                                        ③\nts.val_cur\n\nts.run(berlin52_tsp, repetition=1)                                       ④\n\nprint(ts.s_best)                                                         ⑤\nprint(ts.val_best)                                                       ⑥\n\nberlin52_tsp.plot(ts.s_best)                                             ⑦\n```", "```py\nsol: [0, 21, 17, 2, 16, 20, 41, 6, 1, 29, 28, 15, 45, 47, 23, 36, 33, 43, 49, \n19, 22, 30, 44, 18, 40, 7, 8, 9, 42, 32, 50, 10, 51, 13, 12, 46, 25, 26, 27, \n11, 24, 3, 5, 14, 4, 37, 39, 38, 35, 34, 48, 31, 0], found at iter: 51\n7982.79\n```", "```py\nfrom optalgotools.algorithms import TabuSearch\nfrom optalgotools.problems import TSP\n\ngta_part_tsp = TSP(dists=gta_part_dists, gen_method='mutate')             ①\n\nts = TabuSearch(max_iter=1000, tabu_tenure=5, neighbor_size=100,\n➥ use_aspiration=True, aspiration_limit=2, use_longterm=False, debug=1)  ②\n\nts.init_ts(gta_part_tsp,'random')                                         ③\n\ndraw_map_path(G, ts.s_cur, gta_part_loc, gta_part_pathes)                 ④\n\nts.run(gta_part_tsp, repetition=5)                                        ⑤\n\nprint(ts.s_allbest)                                                       ⑥\nprint(ts.val_allbest)                                                     ⑦\n\ndraw_map_path(G, ts.s_allbest, gta_part_loc, gta_part_pathes)             ⑧\n```", "```py\nimport pandas as pd \nimport numpy as np \nimport random as rd \nimport math \nimport matplotlib.pyplot as plt\n\ntasks = pd.DataFrame(columns=['Task', 'Duration'])                             ①\ntasks= pd.read_csv(\"https://raw.githubusercontent.com/Optimization-Algorithms  ①\n➥ -Book/Code-Listings/main/Appendix%20B/data/ALBP/ALB_TS_DATA.txt\", sep =\",\") ①\nPrec= pd.read_csv(\"https://raw.githubusercontent.com/Optimization-Algorithms   ①\n➥ -Book/Code-Listings/main/Appendix%20B/data/ALBP/ALB_TS_PRECEDENCE.txt\",     ①\n➥ sep =\",\")                                                                   ①\nPrec.columns=['TASK', 'IMMEDIATE_PRECEDESSOR']                                 ①\n\nCycle_time = 4                                                                 ②\n\ntenure = 3\nmax_itr=100\n\nsolution = Initial_Solution(len(tasks))                                        ③\nsoln_init = Make_Solution_Feasible(solution, Prec)                             ④\n\nsol_best, SI_best=tabu_search(max_itr, soln_init, SI_init, tenure, WS, tasks,\n➥ Prec_Matrix, Cycle_time)                                                    ⑤\n\nSmoothing_index(sol_best, WS, tasks, Cycle_time, True)                         ⑥\n\nplt = Make_Solution_to_plot(sol_best, WS, tasks, Cycle_time)                   ⑦\nplt.show()                                                                     ⑦\n```", "```py\nThe Smoothing Index value for ['T3', 'T5', 'T6', 'T1', 'T4', 'T2'] solution sequence is: 0.0 \nThe number of workstations for ['T3', 'T5', 'T6', 'T1', 'T4', 'T2'] solution sequence is: 5 \nThe workloads of workstation for ['T3', 'T5', 'T6', 'T1', 'T4', 'T2'] solution sequence are: [3\\. 3\\. 3\\. 3\\. 3.] \n```", "```py\nfrom optalgotools.algorithms import TabuSearch                                  ①\nfrom optalgotools.problems import ALBP                                          ②\n\ndata_url=\"https://raw.githubusercontent.com/Optimization-Algorithms-Book/\nCode-Listings/main/Appendix%20B/data/ALBP/SALBP-data-sets/precedence%20graphs/\" ③\n\nalbp_instance= ALBP(data_url, \"MANSOOR.IN2\", 48.0)                              ④\n\nts = TabuSearch(max_iter=20, tabu_tenure=4, neighbor_size=5, use_aspiration=True,\n➥ aspiration_limit=None, use_longterm=False)                                   ⑤\nts.init_ts(albp_instance) \nts.run(albp_instance, repetition=5)                                             ⑥\n\nSI = albp_instance.Smoothing_index(list(ts.s_best), ts.val_best,\n➥ albp_instance.tasks, True)                                                   ⑦\nprint(SI)                                                                       ⑧\n```", "```py\nThe Smoothing Index value for ['T1', 'T2', 'T4', 'T5', 'T6', 'T7', 'T9', 'T8', 'T10', 'T3', 'T11'] solution sequence is: 12.296340919151518 \nThe number of workstations for ['T1', 'T2', 'T4', 'T5', 'T6', 'T7', 'T9', 'T8', 'T10', 'T3', 'T11'] solution sequence is: 5 \nThe workloads of workstation for ['T1', 'T2', 'T4', 'T5', 'T6', 'T7', 'T9', 'T8', 'T10', 'T3', 'T11'] solution sequence are: [42\\. 44\\. 20\\. 45\\. 34.]\n```"]