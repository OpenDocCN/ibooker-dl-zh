- en: 3 Coding attention mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reasons for using attention mechanisms in neural networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic self-attention framework, progressing to an enhanced self-attention
    mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A causal attention module that allows LLMs to generate one token at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking randomly selected attention weights with dropout to reduce overfitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacking multiple causal attention modules into a multi-head attention module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, you know how to prepare the input text for training LLMs by splitting
    text into individual word and subword tokens, which can be encoded into vector
    representations, embeddings, for the LLM.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look at an integral part of the LLM architecture itself, attention
    mechanisms, as illustrated in figure 3.1\. We will largely look at attention mechanisms
    in isolation and focus on them at a mechanistic level. Then we will code the remaining
    parts of the LLM surrounding the self-attention mechanism to see it in action
    and to create a model to generate text.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1 The three main stages of coding an LLM. This chapter focuses on
    step 2 of stage 1: implementing attention mechanisms, which are an integral part
    of the LLM architecture.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We will implement four different variants of attention mechanisms, as illustrated
    in figure 3.2. These different attention variants build on each other, and the
    goal is to arrive at a compact and efficient implementation of multi-head attention
    that we can then plug into the LLM architecture we will code in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 The figure depicts different attention mechanisms we will code in
    this chapter, starting with a simplified version of self-attention before adding
    the trainable weights. The causal attention mechanism adds a mask to self-attention
    that allows the LLM to generate one word at a time. Finally, multi-head attention
    organizes the attention mechanism into multiple heads, allowing the model to capture
    various aspects of the input data in parallel.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 3.1 The problem with modeling long sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into the *self-attention* mechanism at the heart of LLMs, let‚Äôs
    consider the problem with pre-LLM architectures that do not include attention
    mechanisms. Suppose we want to develop a language translation model that translates
    text from one language into another. As shown in figure 3.3, we can‚Äôt simply translate
    a text word by word due to the grammatical structures in the source and target
    language.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 When translating text from one language to another, such as German
    to English, it‚Äôs not possible to merely translate word by word. Instead, the translation
    process requires contextual understanding and grammatical alignment.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To address this problem, it is common to use a deep neural network with two
    submodules, an *encoder* and a *decoder*. The job of the encoder is to first read
    in and process the entire text, and the decoder then produces the translated text.
  prefs: []
  type: TYPE_NORMAL
- en: Before the advent of transformers, *recurrent neural networks* (RNNs) were the
    most popular encoder‚Äìdecoder architecture for language translation. An RNN is
    a type of neural network where outputs from previous steps are fed as inputs to
    the current step, making them well-suited for sequential data like text. If you
    are unfamiliar with RNNs, don‚Äôt worry‚Äîyou don‚Äôt need to know the detailed workings
    of RNNs to follow this discussion; our focus here is more on the general concept
    of the encoder‚Äìdecoder setup.
  prefs: []
  type: TYPE_NORMAL
- en: In an encoder‚Äìdecoder RNN, the input text is fed into the encoder, which processes
    it sequentially. The encoder updates its hidden state (the internal values at
    the hidden layers) at each step, trying to capture the entire meaning of the input
    sentence in the final hidden state, as illustrated in figure 3.4\. The decoder
    then takes this final hidden state to start generating the translated sentence,
    one word at a time. It also updates its hidden state at each step, which is supposed
    to carry the context necessary for the next-word prediction.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 Before the advent of transformer models, encoder‚Äìdecoder RNNs were
    a popular choice for machine translation. The encoder takes a sequence of tokens
    from the source language as input, where a hidden state (an intermediate neural
    network layer) of the encoder encodes a compressed representation of the entire
    input sequence. Then, the decoder uses its current hidden state to begin the translation,
    token by token.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While we don‚Äôt need to know the inner workings of these encoder‚Äìdecoder RNNs,
    the key idea here is that the encoder part processes the entire input text into
    a hidden state (memory cell). The decoder then takes in this hidden state to produce
    the output. You can think of this hidden state as an embedding vector, a concept
    we discussed in chapter 2.
  prefs: []
  type: TYPE_NORMAL
- en: The big limitation of encoder‚Äìdecoder RNNs is that the RNN can‚Äôt directly access
    earlier hidden states from the encoder during the decoding phase. Consequently,
    it relies solely on the current hidden state, which encapsulates all relevant
    information. This can lead to a loss of context, especially in complex sentences
    where dependencies might span long distances.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is not essential to understand RNNs to build an LLM. Just remember
    that encoder‚Äìdecoder RNNs had a shortcoming that motivated the design of attention
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Capturing data dependencies with attention mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although RNNs work fine for translating short sentences, they don‚Äôt work well
    for longer texts as they don‚Äôt have direct access to previous words in the input.
    One major shortcoming in this approach is that the RNN must remember the entire
    encoded input in a single hidden state before passing it to the decoder (figure
    3.4).
  prefs: []
  type: TYPE_NORMAL
- en: Hence, researchers developed the *Bahdanau attention* mechanism for RNNs in
    2014 (named after the first author of the respective paper; for more information,
    see appendix B), which modifies the encoder‚Äìdecoder RNN such that the decoder
    can selectively access different parts of the input sequence at each decoding
    step as illustrated in figure 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 Using an attention mechanism, the text-generating decoder part of
    the network can access all input tokens selectively. This means that some input
    tokens are more important than others for generating a given output token. The
    importance is determined by the attention weights, which we will compute later.
    Note that this figure shows the general idea behind attention and does not depict
    the exact implementation of the Bahdanau mechanism, which is an RNN method outside
    this book‚Äôs scope.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Interestingly, only three years later, researchers found that RNN architectures
    are not required for building deep neural networks for natural language processing
    and proposed the original *transformer* architecture (discussed in chapter 1)
    including a self-attention mechanism inspired by the Bahdanau attention mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Self-attention is a mechanism that allows each position in the input sequence
    to consider the relevancy of, or ‚Äúattend to,‚Äù all other positions in the same
    sequence when computing the representation of a sequence. Self-attention is a
    key component of contemporary LLMs based on the transformer architecture, such
    as the GPT series.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on coding and understanding this self-attention mechanism
    used in GPT-like models, as illustrated in figure 3.6\. In the next chapter, we
    will code the remaining parts of the LLM.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 Self-attention is a mechanism in transformers used to compute more
    efficient input representations by allowing each position in a sequence to interact
    with and weigh the importance of all other positions within the same sequence.
    In this chapter, we will code this self-attention mechanism from the ground up
    before we code the remaining parts of the GPT-like LLM in the following chapter.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 3.3 Attending to different parts of the input with self-attention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We‚Äôll now cover the inner workings of the self-attention mechanism and learn
    how to code it from the ground up. Self-attention serves as the cornerstone of
    every LLM based on the transformer architecture. This topic may require a lot
    of focus and attention (no pun intended), but once you grasp its fundamentals,
    you will have conquered one of the toughest aspects of this book and LLM implementation
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: The ‚Äúself‚Äù in self-attention
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In self-attention, the ‚Äúself‚Äù refers to the mechanism‚Äôs ability to compute attention
    weights by relating different positions within a single input sequence. It assesses
    and learns the relationships and dependencies between various parts of the input
    itself, such as words in a sentence or pixels in an image.
  prefs: []
  type: TYPE_NORMAL
- en: This is in contrast to traditional attention mechanisms, where the focus is
    on the relationships between elements of two different sequences, such as in sequence-to-sequence
    models where the attention might be between an input sequence and an output sequence,
    such as the example depicted in figure 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: Since self-attention can appear complex, especially if you are encountering
    it for the first time, we will begin by examining a simplified version of it.
    Then we will implement the self-attention mechanism with trainable weights used
    in LLMs.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 A simple self-attention mechanism without trainable weights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let‚Äôs begin by implementing a simplified variant of self-attention, free from
    any trainable weights, as summarized in figure 3.7\. The goal is to illustrate
    a few key concepts in self-attention before adding trainable weights.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 The goal of self-attention is to compute a context vector for each
    input element that combines information from all other input elements. In this
    example, we compute the context vector z^((2)). The importance or contribution
    of each input element for computing z^((2)) is determined by the attention weights
    a[21] to a[2T]. When computing z^((2)), the attention weights are calculated with
    respect to input element x^((2)) and all other inputs.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Figure 3.7 shows an input sequence, denoted as *x*, consisting of *T* elements
    represented as *x*(1) to *x*(T). This sequence typically represents text, such
    as a sentence, that has already been transformed into token embeddings.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider an input text like ‚ÄúYour journey starts with one step.‚Äù
    In this case, each element of the sequence, such as *x*(1), corresponds to a *d*-dimensional
    embedding vector representing a specific token, like ‚ÄúYour.‚Äù Figure 3.7 shows
    these input vectors as three-dimensional embeddings.
  prefs: []
  type: TYPE_NORMAL
- en: In self-attention, our goal is to calculate context vectors *z*(i) for each
    element *x*(i) in the input sequence. A *context vector* can be interpreted as
    an enriched embedding vector.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this concept, let‚Äôs focus on the embedding vector of the second
    input element, *x*(2) (which corresponds to the token ‚Äújourney‚Äù), and the corresponding
    context vector, *z*(2), shown at the bottom of figure 3.7\. This enhanced context
    vector, *z*(2), is an embedding that contains information about *x*(2) and all
    other input elements, *x*(1) to *x*(T).
  prefs: []
  type: TYPE_NORMAL
- en: Context vectors play a crucial role in self-attention. Their purpose is to create
    enriched representations of each element in an input sequence (like a sentence)
    by incorporating information from all other elements in the sequence (figure 3.7).
    This is essential in LLMs, which need to understand the relationship and relevance
    of words in a sentence to each other. Later, we will add trainable weights that
    help an LLM learn to construct these context vectors so that they are relevant
    for the LLM to generate the next token. But first, let‚Äôs implement a simplified
    self-attention mechanism to compute these weights and the resulting context vector
    one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input sentence, which has already been embedded into
    three-dimensional vectors (see chapter 2). I‚Äôve chosen a small embedding dimension
    to ensure it fits on the page without line breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first step of implementing self-attention is to compute the intermediate
    values w, referred to as attention scores, as illustrated in figure 3.8\. Due
    to spatial constraints, the figure displays the values of the preceding `inputs`
    tensor in a truncated version; for example, 0.87 is truncated to 0.8\. In this
    truncated version, the embeddings of the words ‚Äújourney‚Äù and ‚Äústarts‚Äù may appear
    similar by random chance.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 The overall goal is to illustrate the computation of the context
    vector z^((2)) using the second input element, x^((2)) as a query. This figure
    shows the first intermediate step, computing the attention scores w between the
    query x^((2)) and all other input elements as a dot product. (Note that the numbers
    are truncated to one digit after the decimal point to reduce visual clutter.)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Figure 3.8 illustrates how we calculate the intermediate attention scores between
    the query token and each input token. We determine these scores by computing the
    dot product of the query, *x*(2), with every other input token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The second input token serves as the query.'
  prefs: []
  type: TYPE_NORMAL
- en: The computed attention scores are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Understanding dot products
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A dot product is essentially a concise way of multiplying two vectors element-wise
    and then summing the products, which can be demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output confirms that the sum of the element-wise multiplication gives the
    same results as the dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Beyond viewing the dot product operation as a mathematical tool that combines
    two vectors to yield a scalar value, the dot product is a measure of similarity
    because it quantifies how closely two vectors are aligned: a higher dot product
    indicates a greater degree of alignment or similarity between the vectors. In
    the context of self-attention mechanisms, the dot product determines the extent
    to which each element in a sequence focuses on, or ‚Äúattends to,‚Äù any other element:
    the higher the dot product, the higher the similarity and attention score between
    two elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, as shown in figure 3.9, we normalize each of the attention
    scores we computed previously. The main goal behind the normalization is to obtain
    attention weights that sum up to 1\. This normalization is a convention that is
    useful for interpretation and maintaining training stability in an LLM. Here‚Äôs
    a straightforward method for achieving this normalization step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/3-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 After computing the attention scores w[21] to w[2T] with respect
    to the input query x^((2)), the next step is to obtain the attention weights a[21]
    to a[2T] by normalizing the attention scores.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As the output shows, the attention weights now sum to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, it‚Äôs more common and advisable to use the softmax function for
    normalization. This approach is better at managing extreme values and offers more
    favorable gradient properties during training. The following is a basic implementation
    of the softmax function for normalizing the attention scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As the output shows, the softmax function also meets the objective and normalizes
    the attention weights such that they sum to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the softmax function ensures that the attention weights are always
    positive. This makes the output interpretable as probabilities or relative importance,
    where higher weights indicate greater importance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this naive softmax implementation (`softmax_naive`) may encounter
    numerical instability problems, such as overflow and underflow, when dealing with
    large or small input values. Therefore, in practice, it‚Äôs advisable to use the
    PyTorch implementation of softmax, which has been extensively optimized for performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, it yields the same results as our previous `softmax_naive` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have computed the normalized attention weights, we are ready for
    the final step, as shown in figure 3.10: calculating the context vector *z*(2)
    by multiplying the embedded input tokens, *x*(i), with the corresponding attention
    weights and then summing the resulting vectors. Thus, context vector *z*(2) is
    the weighted sum of all input vectors, obtained by multiplying each input vector
    by its corresponding attention weight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The second input token is the query.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 The final step, after calculating and normalizing the attention
    scores to obtain the attention weights for query x^((2)), is to compute the context
    vector z^((2)). This context vector is a combination of all input vectors x^((1))
    to x^(^(*T‚Äâ*)^) weighted by the attention weights.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The results of this computation are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will generalize this procedure for computing context vectors to calculate
    all context vectors simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 Computing attention weights for all input tokens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have computed attention weights and the context vector for input
    2, as shown in the highlighted row in figure 3.11\. Now let‚Äôs extend this computation
    to calculate attention weights and context vectors for all inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 The highlighted row shows the attention weights for the second input
    element as a query. Now we will generalize the computation to obtain all other
    attention weights. (Please note that the numbers in this figure are truncated
    to two digits after the decimal point to reduce visual clutter. The values in
    each row should add up to 1.0 or 100%.)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We follow the same three steps as before (see figure 3.12), except that we
    make a few modifications in the code to compute all context vectors instead of
    only the second one, *z*(2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/3-12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 In step 1, we add an additional `for` loop to compute the dot products
    for all pairs of inputs.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The resulting attention scores are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each element in the tensor represents an attention score between each pair of
    inputs, as we saw in figure 3.11\. Note that the values in that figure are normalized,
    which is why they differ from the unnormalized attention scores in the preceding
    tensor. We will take care of the normalization later.
  prefs: []
  type: TYPE_NORMAL
- en: 'When computing the preceding attention score tensor, we used `for` loops in
    Python. However, `for` loops are generally slow, and we can achieve the same results
    using matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visually confirm that the results are the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 2 of figure 3.12, we normalize each row so that the values in each
    row sum to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following attention weight tensor that matches the values
    shown in figure 3.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the context of using PyTorch, the dim parameter in functions like `torch.softmax`
    specifies the dimension of the input tensor along which the function will be computed.
    By setting `dim=-1`, we are instructing the `softmax` function to apply the normalization
    along the last dimension of the `attn_scores` tensor. If `attn_scores` is a two-dimensional
    tensor (for example, with a shape of [rows, columns]), it will normalize across
    the columns so that the values in each row (summing over the column dimension)
    sum up to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that the rows indeed all sum to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The result is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the third and final step of figure 3.12, we use these attention weights
    to compute all context vectors via matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the resulting output tensor, each row contains a three-dimensional context
    vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can double-check that the code is correct by comparing the second row with
    the context vector *z*^((2)) that we computed in section 3.3.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the result, we can see that the previously calculated `context_vec_2`
    matches the second row in the previous tensor exactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the code walkthrough of a simple self-attention mechanism. Next,
    we will add trainable weights, enabling the LLM to learn from data and improve
    its performance on specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Implementing self-attention with trainable weights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next step will be to implement the self-attention mechanism used in the
    original transformer architecture, the GPT models, and most other popular LLMs.
    This self-attention mechanism is also called *scaled dot-product attention*. Figure
    3.13 shows how this self-attention mechanism fits into the broader context of
    implementing an LLM.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 Previously, we coded a simplified attention mechanism to understand
    the basic mechanism behind attention mechanisms. Now, we add trainable weights
    to this attention mechanism. Later, we will extend this self-attention mechanism
    by adding a causal mask and multiple heads.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As illustrated in figure 3.13, the self-attention mechanism with trainable
    weights builds on the previous concepts: we want to compute context vectors as
    weighted sums over the input vectors specific to a certain input element. As you
    will see, there are only slight differences compared to the basic self-attention
    mechanism we coded earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: The most notable difference is the introduction of weight matrices that are
    updated during model training. These trainable weight matrices are crucial so
    that the model (specifically, the attention module inside the model) can learn
    to produce ‚Äúgood‚Äù context vectors. (We will train the LLM in chapter 5.)
  prefs: []
  type: TYPE_NORMAL
- en: We will tackle this self-attention mechanism in the two subsections. First,
    we will code it step by step as before. Second, we will organize the code into
    a compact Python class that can be imported into the LLM architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1 Computing the attention weights step by step
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will implement the self-attention mechanism step by step by introducing the
    three trainable weight matrices *W*[q], *W*[k], and *W*[v]. These three matrices
    are used to project the embedded input tokens, *x*^((i)), into query, key, and
    value vectors, respectively, as illustrated in figure 3.14.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 In the first step of the self-attention mechanism with trainable
    weight matrices, we compute query (q), key (k), and value (v) vectors for input
    elements x. Similar to previous sections, we designate the second input, x^((2)),
    as the query input. The query vector q^((2)) is obtained via matrix multiplication
    between the input x^((2)) and the weight matrix W[q]. Similarly, we obtain the
    key and value vectors via matrix multiplication involving the weight matrices
    W[k] and W[v].
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Earlier, we defined the second input element *x*^((2)) as the query when we
    computed the simplified attention weights to compute the context vector *z*^((2)).
    Then we generalized this to compute all context vectors *z*^((1)) *... z*^((T))
    for the six-word input sentence ‚ÄúYour journey starts with one step.‚Äù
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we start here by computing only one context vector, *z*^((2)), for
    illustration purposes. We will then modify this code to calculate all context
    vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs begin by defining a few variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The second input element'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The input embedding size, d=3'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The output embedding size, d_out=2'
  prefs: []
  type: TYPE_NORMAL
- en: Note that in GPT-like models, the input and output dimensions are usually the
    same, but to better follow the computation, we‚Äôll use different input (`d_in=3`)
    and output (`d_out=2`) dimensions here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we initialize the three weight matrices *W*[q], *W*[k], and *W*[v] shown
    in figure 3.14:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We set `requires_grad=False` to reduce clutter in the outputs, but if we were
    to use the weight matrices for model training, we would set `requires_grad=True`
    to update these matrices during model training.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compute the query, key, and value vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the query results in a two-dimensional vector since we set the
    number of columns of the corresponding weight matrix, via `d_out`, to 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Weight parameters vs. attention weights
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the weight matrices *W*, the term ‚Äúweight‚Äù is short for ‚Äúweight parameters,‚Äù
    the values of a neural network that are optimized during training. This is not
    to be confused with the attention weights. As we already saw, attention weights
    determine the extent to which a context vector depends on the different parts
    of the input (i.e., to what extent the network focuses on different parts of the
    input).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, weight parameters are the fundamental, learned coefficients that
    define the network‚Äôs connections, while attention weights are dynamic, context-specific
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Even though our temporary goal is only to compute the one context vector, *z*^((2)),
    we still require the key and value vectors for all input elements as they are
    involved in computing the attention weights with respect to the query *q‚Äâ*^((2))
    (see figure 3.14).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can obtain all keys and values via matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can tell from the outputs, we successfully projected the six input tokens
    from a three-dimensional onto a two-dimensional embedding space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The second step is to compute the attention scores, as shown in figure 3.15.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-15.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 The attention score computation is a dot-product computation similar
    to what we used in the simplified self-attention mechanism in section 3.3\. The
    new aspect here is that we are not directly computing the dot-product between
    the input elements but using the query and key obtained by transforming the inputs
    via the respective weight matrices.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, let‚Äôs compute the attention score œâ[22]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Remember that Python starts indexing at 0.'
  prefs: []
  type: TYPE_NORMAL
- en: The result for the unnormalized attention score is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can generalize this computation to all attention scores via matrix
    multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#1 All attention scores for given query'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, as a quick check, the second element in the output matches the
    `attn_score_22` we computed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to go from the attention scores to the attention weights, as illustrated
    in figure 3.16\. We compute the attention weights by scaling the attention scores
    and using the softmax function. However, now we scale the attention scores by
    dividing them by the square root of the embedding dimension of the keys (taking
    the square root is mathematically the same as exponentiating by 0.5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/3-16.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 After computing the attention scores œâ, the next step is to normalize
    these scores using the softmax function to obtain the attention weights ùõº.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The resulting attention weights are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The rationale behind scaled-dot product attention
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The reason for the normalization by the embedding dimension size is to improve
    the training performance by avoiding small gradients. For instance, when scaling
    up the embedding dimension, which is typically greater than 1,000 for GPT-like
    LLMs, large dot products can result in very small gradients during backpropagation
    due to the softmax function applied to them. As dot products increase, the softmax
    function behaves more like a step function, resulting in gradients nearing zero.
    These small gradients can drastically slow down learning or cause training to
    stagnate.
  prefs: []
  type: TYPE_NORMAL
- en: The scaling by the square root of the embedding dimension is the reason why
    this self-attention mechanism is also called scaled-dot product attention.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the final step is to compute the context vectors, as illustrated in figure
    3.17.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-17.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 In the final step of the self-attention computation, we compute
    the context vector by combining all value vectors via the attention weights.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Similar to when we computed the context vector as a weighted sum over the input
    vectors (see section 3.3), we now compute the context vector as a weighted sum
    over the value vectors. Here, the attention weights serve as a weighting factor
    that weighs the respective importance of each value vector. Also as before, we
    can use matrix multiplication to obtain the output in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the resulting vector are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So far, we‚Äôve only computed a single context vector, *z*^((2)). Next, we will
    generalize the code to compute all context vectors in the input sequence, *z*^((1))
    to *z*^((T)).
  prefs: []
  type: TYPE_NORMAL
- en: Why query, key, and value?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The terms ‚Äúkey,‚Äù ‚Äúquery,‚Äù and ‚Äúvalue‚Äù in the context of attention mechanisms
    are borrowed from the domain of information retrieval and databases, where similar
    concepts are used to store, search, and retrieve information.
  prefs: []
  type: TYPE_NORMAL
- en: A *query* is analogous to a search query in a database. It represents the current
    item (e.g., a word or token in a sentence) the model focuses on or tries to understand.
    The query is used to probe the other parts of the input sequence to determine
    how much attention to pay to them.
  prefs: []
  type: TYPE_NORMAL
- en: The *key* is like a database key used for indexing and searching. In the attention
    mechanism, each item in the input sequence (e.g., each word in a sentence) has
    an associated key. These keys are used to match the query.
  prefs: []
  type: TYPE_NORMAL
- en: The *value* in this context is similar to the value in a key-value pair in a
    database. It represents the actual content or representation of the input items.
    Once the model determines which keys (and thus which parts of the input) are most
    relevant to the query (the current focus item), it retrieves the corresponding
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2 Implementing a compact self-attention Python class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we have gone through a lot of steps to compute the self-attention
    outputs. We did so mainly for illustration purposes so we could go through one
    step at a time. In practice, with the LLM implementation in the next chapter in
    mind, it is helpful to organize this code into a Python class, as shown in the
    following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.1 A compact self-attention class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this PyTorch code, `SelfAttention_v1` is a class derived from `nn.Module`,
    which is a fundamental building block of PyTorch models that provides necessary
    functionalities for model layer creation and management.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__` method initializes trainable weight matrices (`W_query`, `W_key`,
    and `W_value`) for queries, keys, and values, each transforming the input dimension
    `d_in` to an output dimension `d_out`.
  prefs: []
  type: TYPE_NORMAL
- en: During the forward pass, using the forward method, we compute the attention
    scores (`attn_scores`) by multiplying queries and keys, normalizing these scores
    using softmax. Finally, we create a context vector by weighting the values with
    these normalized attention scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `inputs` contains six embedding vectors, this results in a matrix storing
    the six context vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As a quick check, notice that the second row (`[0.3061,` `0.8210]`) matches
    the contents of `context_vec_2` in the previous section. Figure 3.18 summarizes
    the self-attention mechanism we just implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-18.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 In self-attention, we transform the input vectors in the input matrix
    X with the three weight matrices, W[q], W[k], and W[v]. Then we compute the attention
    weight matrix based on the resulting queries (Q) and keys (K). Using the attention
    weights and values (V), we then compute the context vectors (Z). For visual clarity,
    we focus on a single input text with n tokens, not a batch of multiple inputs.
    Consequently, the three-dimensional input tensor is simplified to a two-dimensional
    matrix in this context. This approach allows for a more straightforward visualization
    and understanding of the processes involved. For consistency with later figures,
    the values in the attention matrix do not depict the real attention weights. (The
    numbers in this figure are truncated to two digits after the decimal point to
    reduce visual clutter. The values in each row should add up to 1.0 or 100%.)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Self-attention involves the trainable weight matrices *W*[q], *W*[k], and *W*[v].
    These matrices transform input data into queries, keys, and values, respectively,
    which are crucial components of the attention mechanism. As the model is exposed
    to more data during training, it adjusts these trainable weights, as we will see
    in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We can improve the `SelfAttention_v1` implementation further by utilizing PyTorch‚Äôs
    `nn.Linear` layers, which effectively perform matrix multiplication when the bias
    units are disabled. Additionally, a significant advantage of using `nn.Linear`
    instead of manually implementing `nn.Parameter(torch.rand(...))` is that `nn.Linear`
    has an optimized weight initialization scheme, contributing to more stable and
    effective model training.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.2 A self-attention class using PyTorch‚Äôs Linear layers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `SelfAttention_v2` similar to `SelfAttention_v1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The output is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that `SelfAttention_v1` and `SelfAttention_v2` give different outputs because
    they use different initial weights for the weight matrices since `nn.Linear` uses
    a more sophisticated weight initialization scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1 Comparing SelfAttention_v1 and SelfAttention_v2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Note that `nn.Linear` in `SelfAttention_v2` uses a different weight initialization
    scheme as `nn.Parameter(torch.rand(d_in,` `d_out))` used in `SelfAttention_v1`,
    which causes both mechanisms to produce different results. To check that both
    implementations, `SelfAttention_v1` and `SelfAttention_v2`, are otherwise similar,
    we can transfer the weight matrices from a `SelfAttention_v2` object to a `SelfAttention_v1`,
    such that both objects then produce the same results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task is to correctly assign the weights from an instance of `SelfAttention_v2`
    to an instance of `SelfAttention_v1`. To do this, you need to understand the relationship
    between the weights in both versions. (Hint: `nn.Linear` stores the weight matrix
    in a transposed form.) After the assignment, you should observe that both instances
    produce the same outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will make enhancements to the self-attention mechanism, focusing specifically
    on incorporating causal and multi-head elements. The causal aspect involves modifying
    the attention mechanism to prevent the model from accessing future information
    in the sequence, which is crucial for tasks like language modeling, where each
    word prediction should only depend on previous words.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-head component involves splitting the attention mechanism into multiple
    ‚Äúheads.‚Äù Each head learns different aspects of the data, allowing the model to
    simultaneously attend to information from different representation subspaces at
    different positions. This improves the model‚Äôs performance in complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Hiding future words with causal attention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many LLM tasks, you will want the self-attention mechanism to consider only
    the tokens that appear prior to the current position when predicting the next
    token in a sequence. Causal attention, also known as *masked attention*, is a
    specialized form of self-attention. It restricts a model to only consider previous
    and current inputs in a sequence when processing any given token when computing
    attention scores. This is in contrast to the standard self-attention mechanism,
    which allows access to the entire input sequence at once.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will modify the standard self-attention mechanism to create a *causal
    attention* mechanism, which is essential for developing an LLM in the subsequent
    chapters. To achieve this in GPT-like LLMs, for each token processed, we mask
    out the future tokens, which come after the current token in the input text, as
    illustrated in figure 3.19\. We mask out the attention weights above the diagonal,
    and we normalize the nonmasked attention weights such that the attention weights
    sum to 1 in each row. Later, we will implement this masking and normalization
    procedure in code.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-19.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 In causal attention, we mask out the attention weights above the
    diagonal such that for a given input, the LLM can‚Äôt access future tokens when
    computing the context vectors using the attention weights. For example, for the
    word ‚Äújourney‚Äù in the second row, we only keep the attention weights for the words
    before (‚ÄúYour‚Äù) and in the current position (‚Äújourney‚Äù).
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 3.5.1 Applying a causal attention mask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next step is to implement the causal attention mask in code. To implement
    the steps to apply a causal attention mask to obtain the masked attention weights,
    as summarized in figure 3.20, let‚Äôs work with the attention scores and weights
    from the previous section to code the causal attention mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-20.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 One way to obtain the masked attention weight matrix in causal attention
    is to apply the softmax function to the attention scores, zeroing out the elements
    above the diagonal and normalizing the resulting matrix.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the first step, we compute the attention weights using the softmax function
    as we have done previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Reuses the query and key weight matrices of the SelfAttention_v2 object
    from the previous section for convenience'
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in the following attention weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement the second step using PyTorch‚Äôs `tril` function to create
    a mask where the values above the diagonal are zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The resulting mask is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can multiply this mask with the attention weights to zero-out the values
    above the diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the elements above the diagonal are successfully zeroed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The third step is to renormalize the attention weights to sum up to 1 again
    in each row. We can achieve this by dividing each element in each row by the sum
    in each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is an attention weight matrix where the attention weights above
    the diagonal are zeroed-out, and the rows sum to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Information leakage
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When we apply a mask and then renormalize the attention weights, it might initially
    appear that information from future tokens (which we intend to mask) could still
    influence the current token because their values are part of the softmax calculation.
    However, the key insight is that when we renormalize the attention weights after
    masking, what we‚Äôre essentially doing is recalculating the softmax over a smaller
    subset (since masked positions don‚Äôt contribute to the softmax value).
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical elegance of softmax is that despite initially including all
    positions in the denominator, after masking and renormalizing, the effect of the
    masked positions is nullified‚Äîthey don‚Äôt contribute to the softmax score in any
    meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, after masking and renormalization, the distribution of attention
    weights is as if it was calculated only among the unmasked positions to begin
    with. This ensures there‚Äôs no information leakage from future (or otherwise masked)
    tokens as we intended.
  prefs: []
  type: TYPE_NORMAL
- en: While we could wrap up our implementation of causal attention at this point,
    we can still improve it. Let‚Äôs take a mathematical property of the softmax function
    and implement the computation of the masked attention weights more efficiently
    in fewer steps, as shown in figure 3.21.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-21.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 A more efficient way to obtain the masked attention weight matrix
    in causal attention is to mask the attention scores with negative infinity values
    before applying the softmax function.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The softmax function converts its inputs into a probability distribution. When
    negative infinity values (`-`‚àû) are present in a row, the softmax function treats
    them as zero probability. (Mathematically, this is because *e‚Äâ‚Äâ*^‚Äì^‚àû approaches
    0.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this more efficient masking ‚Äútrick‚Äù by creating a mask with
    1s above the diagonal and then replacing these 1s with negative infinity (`-inf`)
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all we need to do is apply the softmax function to these masked results,
    and we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see based on the output, the values in each row sum to 1, and no
    further normalization is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We could now use the modified attention weights to compute the context vectors
    via `context_vec` `=` `attn_weights` `@` `values`, as in section 3.4\. However,
    we will first cover another minor tweak to the causal attention mechanism that
    is useful for reducing overfitting when training LLMs.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.2 Masking additional attention weights with dropout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Dropout* in deep learning is a technique where randomly selected hidden layer
    units are ignored during training, effectively ‚Äúdropping‚Äù them out. This method
    helps prevent overfitting by ensuring that a model does not become overly reliant
    on any specific set of hidden layer units. It‚Äôs important to emphasize that dropout
    is only used during training and is disabled afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the transformer architecture, including models like GPT, dropout in the
    attention mechanism is typically applied at two specific times: after calculating
    the attention weights or after applying the attention weights to the value vectors.
    Here we will apply the dropout mask after computing the attention weights, as
    illustrated in figure 3.22, because it‚Äôs the more common variant in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-22.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 Using the causal attention mask (upper left), we apply an additional
    dropout mask (upper right) to zero out additional attention weights to reduce
    overfitting during training.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following code example, we use a dropout rate of 50%, which means masking
    out half of the attention weights. (When we train the GPT model in later chapters,
    we will use a lower dropout rate, such as 0.1 or 0.2.) We apply PyTorch‚Äôs dropout
    implementation first to a 6 √ó 6 tensor consisting of 1s for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We choose a dropout rate of 50%.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Here, we create a matrix of 1s.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, approximately half of the values are zeroed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When applying dropout to an attention weight matrix with a rate of 50%, half
    of the elements in the matrix are randomly set to zero. To compensate for the
    reduction in active elements, the values of the remaining elements in the matrix
    are scaled up by a factor of 1/0.5 = 2\. This scaling is crucial to maintain the
    overall balance of the attention weights, ensuring that the average influence
    of the attention mechanism remains consistent during both the training and inference
    phases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs apply dropout to the attention weight matrix itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting attention weight matrix now has additional elements zeroed out
    and the remaining 1s rescaled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that the resulting dropout outputs may look different depending on your
    operating system; you can read more about this inconsistency here on the PyTorch
    issue tracker at [https://github.com/pytorch/pytorch/issues/121595](https://github.com/pytorch/pytorch/issues/121595).
  prefs: []
  type: TYPE_NORMAL
- en: Having gained an understanding of causal attention and dropout masking, we can
    now develop a concise Python class. This class is designed to facilitate the efficient
    application of these two techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.3 Implementing a compact causal attention class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now incorporate the causal attention and dropout modifications into
    the `SelfAttention` Python class we developed in section 3.4\. This class will
    then serve as a template for developing *multi-head attention*, which is the final
    attention class we will implement.
  prefs: []
  type: TYPE_NORMAL
- en: But before we begin, let‚Äôs ensure that the code can handle batches consisting
    of more than one input so that the `CausalAttention` class supports the batch
    outputs produced by the data loader we implemented in chapter 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, to simulate such batch inputs, we duplicate the input text
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Two inputs with six tokens each; each token has embedding dimension 3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in a three-dimensional tensor consisting of two input texts with
    six tokens each, where each token is a three-dimensional embedding vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The following `CausalAttention` class is similar to the `SelfAttention` class
    we implemented earlier, except that we added the dropout and causal mask components.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.3 A compact causal attention class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Compared to the previous SelfAttention_v1 class, we added a dropout layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The register_buffer call is also a new addition (more information is provided
    in the following text).'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 We transpose dimensions 1 and 2, keeping the batch dimension at the first
    position (0).'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 In PyTorch, operations with a trailing underscore are performed in-place,
    avoiding unnecessary memory copies.'
  prefs: []
  type: TYPE_NORMAL
- en: While all added code lines should be familiar at this point, we now added a
    `self .register_buffer()` call in the `__init__` method. The use of `register_buffer`
    in PyTorch is not strictly necessary for all use cases but offers several advantages
    here. For instance, when we use the `CausalAttention` class in our LLM, buffers
    are automatically moved to the appropriate device (CPU or GPU) along with our
    model, which will be relevant when training our LLM. This means we don‚Äôt need
    to manually ensure these tensors are on the same device as your model parameters,
    avoiding device mismatch errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `CausalAttention` class as follows, similar to `SelfAttention`
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting context vector is a three-dimensional tensor where each token
    is now represented by a two-dimensional embedding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Figure 3.23 summarizes what we have accomplished so far. We have focused on
    the concept and implementation of causal attention in neural networks. Next, we
    will expand on this concept and implement a multi-head attention module that implements
    several causal attention mechanisms in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-23.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 Here‚Äôs what we‚Äôve done so far. We began with a simplified attention
    mechanism, added trainable weights, and then added a causal attention mask. Next,
    we will extend the causal attention mechanism and code multi-head attention, which
    we will use in our LLM.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 3.6 Extending single-head attention to multi-head attention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our final step will be to extend the previously implemented causal attention
    class over multiple heads. This is also called *multi-head attention*.
  prefs: []
  type: TYPE_NORMAL
- en: The term ‚Äúmulti-head‚Äù refers to dividing the attention mechanism into multiple
    ‚Äúheads,‚Äù each operating independently. In this context, a single causal attention
    module can be considered single-head attention, where there is only one set of
    attention weights processing the input sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: We will tackle this expansion from causal attention to multi-head attention.
    First, we will intuitively build a multi-head attention module by stacking multiple
    `CausalAttention` modules. Then we will then implement the same multi-head attention
    module in a more complicated but more computationally efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.1 Stacking multiple single-head attention layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practical terms, implementing multi-head attention involves creating multiple
    instances of the self-attention mechanism (see figure 3.18), each with its own
    weights, and then combining their outputs. Using multiple instances of the self-attention
    mechanism can be computationally intensive, but it‚Äôs crucial for the kind of complex
    pattern recognition that models like transformer-based LLMs are known for.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 illustrates the structure of a multi-head attention module, which
    consists of multiple single-head attention modules, as previously depicted in
    figure 3.18, stacked on top of each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24 The multi-head attention module includes two single-head attention
    modules stacked on top of each other. So, instead of using a single matrix W[v]
    for computing the value matrices, in a multi-head attention module with two heads,
    we now have two value weight matrices: W[v1] and W[v2]. The same applies to the
    other weight matrices, W[Q] and W[k]. We obtain two sets of context vectors Z[1]
    and Z[2] that we can combine into a single context vector matrix Z.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As mentioned before, the main idea behind multi-head attention is to run the
    attention mechanism multiple times (in parallel) with different, learned linear
    projections‚Äîthe results of multiplying the input data (like the query, key, and
    value vectors in attention mechanisms) by a weight matrix. In code, we can achieve
    this by implementing a simple `MultiHeadAttentionWrapper` class that stacks multiple
    instances of our previously implemented `CausalAttention` module.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.4 A wrapper class to implement multi-head attention
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: For example, if we use this `MultiHeadAttentionWrapper` class with two attention
    heads (via `num_heads=2`) and `CausalAttention` output dimension `d_out=2`, we
    get a four-dimensional context vector (`d_out*num_heads=4`), as depicted in figure
    3.25.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-25.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 Using the `MultiHeadAttentionWrapper`, we specified the number of
    attention heads (`num_heads`). If we set `num_heads=2`, as in this example, we
    obtain a tensor with two sets of context vector matrices. In each context vector
    matrix, the rows represent the context vectors corresponding to the tokens, and
    the columns correspond to the embedding dimension specified via `d_out=4`. We
    concatenate these context vector matrices along the column dimension. Since we
    have two attention heads and an embedding dimension of 2, the final embedding
    dimension is 2 √ó 2 = 4.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To illustrate this further with a concrete example, we can use the `MultiHeadAttentionWrapper`
    class similar to the `CausalAttention` class before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following tensor representing the context vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The first dimension of the resulting `context_vecs` tensor is 2 since we have
    two input texts (the input texts are duplicated, which is why the context vectors
    are exactly the same for those). The second dimension refers to the 6 tokens in
    each input. The third dimension refers to the four-dimensional embedding of each
    token.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2 Returning two-dimensional embedding vectors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Change the input arguments for the `MultiHeadAttentionWrapper(...,` `num_ heads=2)`
    call such that the output context vectors are two-dimensional instead of four
    dimensional while keeping the setting `num_heads=2`. Hint: You don‚Äôt have to modify
    the class implementation; you just have to change one of the other input arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we have implemented a `MultiHeadAttentionWrapper` that combined
    multiple single-head attention modules. However, these are processed sequentially
    via `[head(x)` `for` `head` `in` `self.heads]` in the forward method. We can improve
    this implementation by processing the heads in parallel. One way to achieve this
    is by computing the outputs for all attention heads simultaneously via matrix
    multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.2 Implementing multi-head attention with weight splits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have created a `MultiHeadAttentionWrapper` to implement multi-head
    attention by stacking multiple single-head attention modules. This was done by
    instantiating and combining several `CausalAttention` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of maintaining two separate classes, `MultiHeadAttentionWrapper` and
    `CausalAttention`, we can combine these concepts into a single `MultiHeadAttention`
    class. Also, in addition to merging the `MultiHeadAttentionWrapper` with the `CausalAttention`
    code, we will make some other modifications to implement multi-head attention
    more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MultiHeadAttentionWrapper`, multiple heads are implemented by creating
    a list of `CausalAttention` objects (`self.heads`), each representing a separate
    attention head. The `CausalAttention` class independently performs the attention
    mechanism, and the results from each head are concatenated. In contrast, the following
    `MultiHeadAttention` class integrates the multi-head functionality within a single
    class. It splits the input into multiple heads by reshaping the projected query,
    key, and value tensors and then combines the results from these heads after computing
    attention.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs take a look at the `MultiHeadAttention` class before we discuss it further.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.5 An efficient multi-head attention class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Reduces the projection dim to match the desired output dim'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses a Linear layer to combine head outputs'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Tensor shape: (b, num_tokens, d_out)'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 We implicitly split the matrix by adding a num_heads dimension. Then we
    unroll the last dim: (b, num_tokens, d_out) -&gt; (b, num_tokens, num_heads, head_dim).'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Transposes from shape (b, num_tokens, num_heads, head_dim) to (b, num_heads,
    num_tokens, head_dim)'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Computes dot product for each head'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Masks truncated to the number of tokens'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Uses the mask to fill attention scores'
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Tensor shape: (b, num_tokens, n_heads, head_dim)'
  prefs: []
  type: TYPE_NORMAL
- en: '#10 Combines heads, where self.d_out = self.num_heads * self.head_dim'
  prefs: []
  type: TYPE_NORMAL
- en: '#11 Adds an optional linear projection'
  prefs: []
  type: TYPE_NORMAL
- en: Even though the reshaping (`.view`) and transposing (`.transpose`) of tensors
    inside the `MultiHeadAttention` class looks very mathematically complicated, the
    `MultiHeadAttention` class implements the same concept as the `MultiHeadAttentionWrapper`
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: On a big-picture level, in the previous `MultiHeadAttentionWrapper`, we stacked
    multiple single-head attention layers that we combined into a multi-head attention
    layer. The `MultiHeadAttention` class takes an integrated approach. It starts
    with a multi-head layer and then internally splits this layer into individual
    attention heads, as illustrated in figure 3.26.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-26.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 In the `MultiHeadAttentionWrapper` class with two attention heads,
    we initialized two weight matrices, W[q1] and W[q2], and computed two query matrices,
    Q[1] and Q[2] (top). In the `MultiheadAttention` class, we initialize one larger
    weight matrix W[q], only perform one matrix multiplication with the inputs to
    obtain a query matrix Q, and then split the query matrix into Q[1] and Q[2] (bottom).
    We do the same for the keys and values, which are not shown to reduce visual clutter.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The splitting of the query, key, and value tensors is achieved through tensor
    reshaping and transposing operations using PyTorch‚Äôs `.view` and `.transpose`
    methods. The input is first transformed (via linear layers for queries, keys,
    and values) and then reshaped to represent multiple heads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key operation is to split the `d_out` dimension into `num_heads` and `head_dim`,
    where `head_dim` `=` `d_out` `/` `num_heads`. This splitting is then achieved
    using the `.view` method: a tensor of dimensions `(b,` `num_tokens,` `d_out)`
    is reshaped to dimension `(b,` `num_tokens,` `num_heads,` `head_dim)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The tensors are then transposed to bring the `num_heads` dimension before the
    `num_ tokens` dimension, resulting in a shape of `(b,` `num_heads,` `num_tokens,`
    `head_dim)`. This transposition is crucial for correctly aligning the queries,
    keys, and values across the different heads and performing batched matrix multiplications
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this batched matrix multiplication, suppose we have the following
    tensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The shape of this tensor is (b, num_heads, num_tokens, head_dim) = (1, 2,
    3, 4).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we perform a batched matrix multiplication between the tensor itself and
    a view of the tensor where we transposed the last two dimensions, `num_tokens`
    and `head_dim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The result is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the matrix multiplication implementation in PyTorch handles the
    four-dimensional input tensor so that the matrix multiplication is carried out
    between the two last dimensions `(num_tokens,` `head_dim)` and then repeated for
    the individual heads.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the preceding becomes a more compact way to compute the matrix
    multiplication for each head separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are exactly the same results as those we obtained when using the
    batched matrix multiplication `print(a` `@` `a.transpose(2,` `3))`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Continuing with `MultiHeadAttention`, after computing the attention weights
    and context vectors, the context vectors from all heads are transposed back to
    the shape `(b,` `num_tokens,` `num_heads,` `head_dim)`. These vectors are then
    reshaped (flattened) into the shape `(b,` `num_tokens,` `d_out)`, effectively
    combining the outputs from all heads.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we added an output projection layer (`self.out_proj`) to `MultiHeadAttention`
    after combining the heads, which is not present in the `CausalAttention` class.
    This output projection layer is not strictly necessary (see appendix B for more
    details), but it is commonly used in many LLM architectures, which is why I added
    it here for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the `MultiHeadAttention` class looks more complicated than the `MultiHeadAttentionWrapper`
    due to the additional reshaping and transposition of tensors, it is more efficient.
    The reason is that we only need one matrix multiplication to compute the keys,
    for instance, `keys` `=` `self.W_key(x)` (the same is true for the queries and
    values). In the `MultiHeadAttentionWrapper`, we needed to repeat this matrix multiplication,
    which is computationally one of the most expensive steps, for each attention head.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MultiHeadAttention` class can be used similar to the `SelfAttention` and
    `CausalAttention` classes we implemented earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The results show that the output dimension is directly controlled by the `d_out`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We have now implemented the `MultiHeadAttention` class that we will use when
    we implement and train the LLM. Note that while the code is fully functional,
    I used relatively small embedding sizes and numbers of attention heads to keep
    the outputs readable.
  prefs: []
  type: TYPE_NORMAL
- en: For comparison, the smallest GPT-2 model (117 million parameters) has 12 attention
    heads and a context vector embedding size of 768\. The largest GPT-2 model (1.5
    billion parameters) has 25 attention heads and a context vector embedding size
    of 1,600\. The embedding sizes of the token inputs and context embeddings are
    the same in GPT models (`d_in` `=` `d_out`).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.3 Initializing GPT-2 size attention modules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using the `MultiHeadAttention` class, initialize a multi-head attention module
    that has the same number of attention heads as the smallest GPT-2 model (12 attention
    heads). Also ensure that you use the respective input and output embedding sizes
    similar to GPT-2 (768 dimensions). Note that the smallest GPT-2 model supports
    a context length of 1,024 tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attention mechanisms transform input elements into enhanced context vector representations
    that incorporate information about all inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A self-attention mechanism computes the context vector representation as a weighted
    sum over the inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a simplified attention mechanism, the attention weights are computed via
    dot products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dot product is a concise way of multiplying two vectors element-wise and then
    summing the products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix multiplications, while not strictly required, help us implement computations
    more efficiently and compactly by replacing nested `for` loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In self-attention mechanisms used in LLMs, also called scaled-dot product attention,
    we include trainable weight matrices to compute intermediate transformations of
    the inputs: queries, values, and keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with LLMs that read and generate text from left to right, we add
    a causal attention mask to prevent the LLM from accessing future tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to causal attention masks to zero-out attention weights, we can
    add a dropout mask to reduce overfitting in LLMs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attention modules in transformer-based LLMs involve multiple instances of
    causal attention, which is called multi-head attention.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a multi-head attention module by stacking multiple instances of
    causal attention modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more efficient way of creating multi-head attention modules involves batched
    matrix multiplications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
