- en: 2 Building a conversational AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 构建对话式人工智能
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building an FAQ conversational AI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建FAQ对话式人工智能
- en: Building a process-oriented conversational AI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建面向流程的对话式人工智能
- en: Using generative AI inside of your conversational AI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的对话式人工智能中使用生成式人工智能
- en: In production, conversational AI can be quite complex, and throughout this book,
    we’ll cover many techniques that address the real-world problems you’ll face as
    you build and deploy your own solutions. In this chapter, we’ll build Cake Bot,
    a conversational AI solution with elements from several different kinds of conversational
    AIs. This will give us a solid foundation for understanding conversational AI
    structure.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，对话式人工智能可能相当复杂，在本书中，我们将涵盖许多解决你在构建和部署自己的解决方案时面临的现实世界问题的技术。在本章中，我们将构建蛋糕机器人（Cake
    Bot），这是一个包含几种不同类型对话式人工智能元素的对话式人工智能解决方案。这将为我们理解对话式人工智能结构提供一个坚实的基础。
- en: We’ll follow a fictitious small American bakery from Ohio called Cake Shop.
    The company makes custom cakes and takes orders for delivery or pickup. They want
    to add a conversational AI solution to their website to help their customers.
    Since they have never built a bot before, they intend to start small but hope
    to quickly expand the scope and capability of their solution. They decide to start
    with an AI solution that answers their most frequently asked questions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跟随一家虚构的美国俄亥俄州小面包店——蛋糕店。这家公司制作定制蛋糕，并接受送货或自取订单。他们想在网站上添加一个对话式人工智能解决方案来帮助他们的客户。由于他们以前从未构建过机器人，他们打算从小规模开始，但希望快速扩大解决方案的范围和能力。他们决定从回答他们最常问的问题的人工智能解决方案开始。
- en: Many of the tasks in this chapter *could* be done with large language models.
    However, this bakery is cautious. They especially want to control the wording
    of responses given for several question types. Thus, their solution will blend
    traditional and generative techniques.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多任务*可以*使用大型语言模型完成。然而，这个面包店非常谨慎。他们特别希望控制对几种问题类型给出的回答措辞。因此，他们的解决方案将结合传统和生成式技术。
- en: We will demonstrate the building process using a conversational AI platform
    (IBM’s watsonx Assistant), and we’ll later fold in a generative AI platform (IBM’s
    watsonx.ai). The key concepts we demonstrate are applicable across many different
    AI platforms. You can easily use your platform of choice for conversational AI
    and generative AI.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用对话式人工智能平台（IBM的watsonx Assistant）来演示构建过程，稍后我们将整合一个生成式人工智能平台（IBM的watsonx.ai）。我们展示的关键概念适用于许多不同的AI平台。你可以轻松地使用你选择的对话式人工智能和生成式人工智能平台。
- en: 2.1 Building an FAQ bot
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 构建FAQ机器人
- en: Most conversational AI builders start with a question-answering bot. Also known
    as FAQ bots, these AI solutions deliver a response directly to a user’s question,
    often without any follow-up questions. The user asks a question, the bot returns
    an answer, and the conversation is done when the user is finished asking questions.
    These bots work especially well when there are a small number of (frequently asked)
    questions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对话式人工智能构建者都是从问题-回答机器人开始的。也称为FAQ机器人，这些AI解决方案直接对用户的提问给出回答，通常不需要后续问题。用户提问，机器人返回答案，当用户完成提问时，对话结束。这些机器人在只有少数（经常问的）问题时特别有效。
- en: In this section, we will build an FAQ bot for Cake Shop. Some questions will
    have a static response that will be the same no matter how the question is asked.
    Other questions will have a dynamic response that will change based on information
    in the question. But before we train the bot on any question-answering, we will
    first put some basic scaffolding in place.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为蛋糕店构建一个常见问题解答（FAQ）机器人。有些问题将有静态回答，无论问题如何提出，回答都将相同。其他问题将有动态回答，根据问题中的信息而变化。但在我们对任何问题-回答进行训练之前，我们首先将建立一些基本框架。
- en: 2.1.1 FAQ bot foundations
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 FAQ机器人基础
- en: Every conversational AI needs to be able to start a conversation and react when
    it doesn’t know what to do. Most conversational AI platforms provide this capability
    by default when creating a new chatbot. It’s worth quickly checking these configurations
    and adapting them to your needs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对话式人工智能都需要能够开始对话并在不知道如何行动时做出反应。大多数对话式人工智能平台在创建新的聊天机器人时默认提供这种功能。快速检查这些配置并根据您的需求进行调整是值得的。
- en: Cake Shop starts building their conversational AI (the “assistant”), and they
    title it “Cake Bot.” From the conversational AI’s main menu, their developer navigates
    to Actions, which lists all the assistant’s capabilities. The first list is titled
    “Created by you” and is empty; the second list is titled “Set by assistant,” and
    it lists the default capabilities, which are outlined in table 2.1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋糕店开始构建他们的对话式人工智能（“助手”），并将其命名为“蛋糕机器人”。从对话式人工智能的主菜单中，他们的开发者导航到“动作”，列出了所有助手的技能。第一个列表标题为“由您创建”，为空；第二个列表标题为“由助手设置”，列出了默认技能，如表2.1所示。
- en: Table 2.1 Default capabilities in a new assistant
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1 新助手的默认技能
- en: '| Capability | Executed when |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 技能 | 执行时 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Greet customer  | The assistant is first opened or engaged with. Opening
    the assistant starts a conversation.  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 欢迎客户 | 助手首次打开或互动。打开助手开始对话。 |'
- en: '| No action matches  | No action can be matched to the user’s message (the
    message is not understood). Other platforms may call this the “fallback intent.”  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 无匹配动作 | 无法匹配到用户的消息（消息不被理解）。其他平台可能称之为“回退意图”。 |'
- en: '| Trigger word detected  | Keywords like profanity are detected.  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 触发词检测 | 检测到侮辱性关键词等。 |'
- en: '| Fallback  | The user needs to leave the chatbot.  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 回退 | 用户需要离开聊天机器人。 |'
- en: The first capability is the most important to customize, as it gives us our
    first chance to personalize the assistant. The default text is “Welcome, how can
    I assist you?” The Cake Shop team changes this text to “Welcome to Cake Bot. How
    can I help you?” This is a minimum level of customization—it would be better to
    include additional information, like what the bot can do for users. However, the
    bot does not have any capabilities yet, so the Cake Shop team leaves this message
    as is.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个功能是最重要的，因为它给了我们第一次定制助手的机会。默认文本是“欢迎，我能帮您什么？”蛋糕店团队将此文本更改为“欢迎来到蛋糕机器人。我能帮您什么？”这是一个最低程度的定制——最好包括额外的信息，比如机器人能为用户做什么。然而，机器人目前还没有任何功能，所以蛋糕店团队保留了这个信息不变。
- en: Next, the “No action matches” action should be reviewed. This action will be
    invoked when the bot does not understand the user. Since the bot has no training
    yet, this action will be the default response to any user input. The default configuration
    is shown in figure 2.1.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，应该审查“无匹配动作”动作。当机器人不理解用户时，将调用此动作。由于机器人还没有接受训练，因此此动作将是针对任何用户输入的默认响应。默认配置如图2.1所示。
- en: '![figure](../Images/CH02_F01_Freed2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH02_F01_Freed2.png)'
- en: Figure 2.1 Default configuration of "No action matches" in the assistant
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1 助手中“无匹配动作”的默认配置
- en: 'This configuration is summarized as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置总结如下：
- en: The action counts how many times it has been invoked in the conversation.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作计数器统计在对话中调用的次数。
- en: If three or less times, the response is “I’m afraid I don’t understand. Please
    rephrase your question.”
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果三次或更少，响应是“恐怕我不理解。请重新措辞您的问题。”
- en: If four or more times, it deflects to a fallback routine. (The default fallback
    routine is to offer a human agent.)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果四次或更多，它将转向回退程序。（默认回退程序是提供人工代理。）
- en: The Cake Shop team decides to reduce this threshold by changing the 3 to a 1\.
    This keeps their users from getting stuck.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋糕店团队决定通过将3改为1来降低这个阈值。这样，他们的用户就不会陷入困境。
- en: Fallback action and connection to a human agent
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 回退动作和连接到人工代理
- en: Most conversational AI platforms have no-code and low-code integrations to connect
    users to a human agent through chat or voice. We will not dive deeper into this,
    since the details are platform-specific. Suffice it to say that this is a common
    pattern. For the sake of this chapter, we will focus on the conversational design
    and AI training.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对话式人工智能平台都有无代码和低代码集成，可以通过聊天或语音将用户连接到人工代理。我们不会深入探讨这一点，因为细节是平台特定的。只需说，这是一个常见的模式。为了本章的目的，我们将专注于对话设计和人工智能训练。
- en: 'At this point, we have a chatbot that does three things:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个聊天机器人，它能做三件事：
- en: When the user opens the chat, they are greeted with “Welcome to Cake Bot. How
    can I help you?”
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户打开聊天时，他们会收到“欢迎来到蛋糕机器人。我能帮您什么？”的问候。
- en: Whatever they say next, the chatbot responds that it doesn’t understand.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论他们接下来说什么，聊天机器人都会回应说它不理解。
- en: Whatever they say after that, the chatbot offers a human agent.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后无论他们说什么，聊天机器人都会提供人工代理。
- en: Boring! Let’s train this bot to answer some questions properly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无聊！让我们训练这个机器人来正确回答一些问题。
- en: 2.1.2 Static question and answering
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 静态问答
- en: Let’s start with a mental model of the chatbot components involved in answering
    questions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从聊天机器人组件的心理模型开始，这些组件参与回答问题。
- en: In some platforms, you can directly connect questions to answers. In others,
    an additional layer is introduced to categorize similar questions into groups
    called *intents*. An intent-based question-answering system gives the builder
    full control over responses generated by the conversational AI. A generalized
    version of this design is shown in figure 2.2, using Cake Bot as our example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些平台上，你可以直接将问题连接到答案。在其他平台上，引入了一个额外的层来将类似的问题分类到称为 *intents* 的组中。基于意图的问答系统让构建者完全控制由对话人工智能生成的响应。图2.2展示了这种设计的通用版本，以Cake
    Bot为例。
- en: '![figure](../Images/CH02_F02_Freed2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH02_F02_Freed2.png)'
- en: Figure 2.2 Question-answering bots map user utterances to intents, which map
    to answers.
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2 问答机器人将用户的 *Utterance* 映射到意图，这些意图映射到答案。
- en: 'Let’s review the terminology in this diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个图中的术语：
- en: '*Utterance*—This is the input provided to the chatbot. For a question-answering
    bot, these are questions.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Utterance*—这是提供给聊天机器人的输入。对于一个问答机器人，这些是问题。'
- en: '*Intent*—This is a logical grouping of utterances with similar meanings.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Intent*—这是具有相似意义的 *Utterance* 的逻辑分组。'
- en: '*Response*—This is the output from the chatbot. For a question-answering bot,
    these are answers.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Response*—这是聊天机器人的输出。对于一个问答机器人，这些是答案。'
- en: For your first chatbot, intents save a lot of time. Notice that, as a builder,
    you do not have to distinguish between questions with similar meaning. “What time
    are you open?” and “What are your hours?” both relate to the operating hours of
    your store. It’s not critical for the bot to differentiate these. We give them
    the same “meaning” via the `#store_hours` intent. “What cakes do you sell?” has
    a different meaning and thus a different intent of `#cake_options`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的第一个聊天机器人，意图可以节省很多时间。注意，作为一个构建者，你不需要区分意义相似的提问。“你什么时候开门？”和“你的营业时间是什么？”都与你的商店的营业时间有关。对于机器人来说，区分这些并不是关键。我们通过
    `#store_hours` 意图给它们相同的“意义”。“你卖什么蛋糕？”有不同的意义，因此有不同的 `#cake_options` 意图。
- en: For each intent your bot serves, the bot is trained with example utterances.
    Modern intent-based systems require as few as five example utterances per intent.
    This is not a bad trade-off; there are nearly an infinite number of ways to ask
    for store hours, and by providing a handful of examples, you can train your bot
    well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的机器人服务的每个意图，机器人都会用示例 *Utterance* 进行训练。现代基于意图的系统每个意图只需要五个示例 *Utterance*。这不是一个糟糕的权衡；询问商店营业时间有几乎无限种方式，通过提供一些示例，你可以很好地训练你的机器人。
- en: 'Intent-based question-answering systems are a blessing and a curse: for each
    intent you train, you can control the response, which offers pros and cons.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基于意图的问答系统既是祝福又是诅咒：对于每个你训练的意图，你可以控制响应，这既提供了优点也带来了缺点。
- en: 'Pros:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: You have complete design control over the response. You can copyedit it, format
    the text, and even include graphical elements. You know the exact contents of
    the response.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对响应有完全的设计控制权。你可以编辑它，格式化文本，甚至包括图形元素。你知道响应的确切内容。
- en: For a small number of intents, this can be done quickly. You can set up your
    first chatbot in as little as an hour.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于少数意图，这可以快速完成。你可以在不到一个小时的时间内设置你的第一个聊天机器人。
- en: 'Cons:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: As the number of intents increases, it becomes more difficult to train the bot
    to recognize them all.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着意图数量的增加，训练机器人识别所有这些意图变得更加困难。
- en: 'The responses do not adapt to nuances in the user’s questions. For “Are you
    open today?” the bot still responds generically: “We’re open every day.”'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应不会适应用户问题的细微差别。对于“你今天开门吗？”这个问题，机器人仍然以通用的方式响应：“我们每天都开门。”
- en: Inaccurate or untuned responses give the user a painful feeling of “chatbot
    doesn’t understand.”
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不准确或未调优的响应会给用户带来“聊天机器人不理解”的痛苦感觉。
- en: 'We’ll address several of these downsides to question-answering bots in the
    next few chapters: how to collect the right data to train your bot (chapter 4),
    how to use that data to train stronger intents (chapter 5), how to supplement
    those intents with answers from documents and generative AI (chapter 6), and how
    to use generative AI for a few more training and testing tasks (chapter 7).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几章中解决这些问题问答机器人的几个缺点：如何收集正确的数据来训练你的机器人（第4章），如何使用这些数据来训练更强的意图（第5章），如何通过文档和生成式人工智能的答案来补充这些意图（第6章），以及如何使用生成式人工智能进行更多训练和测试任务（第7章）。
- en: Let’s start by training our chatbot on its first question-answering capabilities.
    For each one, we need a user intent, a set of related user utterances, and a response.
    The first set of questions and answers we’ll define will cover the background
    on Cake Shop, operating hours for their stores, the kinds of cakes offered, the
    approximate cost of cakes, and information about their Cake Club. These intent-based
    question-answering responses are shown in table 2.2.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.2 Initial set of FAQ intents, with associated utterances and responses
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Intent | Example utterances | Response |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `#background`  | Tell me about Cake Shop What''s the background on your business?'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: History of Cake Shop
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '| Founded by Grandma Cake in 1980, we''ve made over 10,000 cakes for local
    residents!  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `#store_hours`  | Store hours What are your store hours?'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: When are you open?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '| We are open Monday through Friday, 9:00 a.m. to 9:00 p.m.  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `#cake_options`  | Cake options Do you make wedding cakes?'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: What kinds of cakes do you sell?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '| We offer cakes for many occasions, such as weddings, birthdays, anniversaries,
    retirement, and all- occasion cakes.  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `#cost`  | How much does a cake cost? Is there a minimum order value?'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Is there a surcharge for delivery?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '| Our cakes typically cost around $30, with a $5 delivery fee.  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| `#cake_club`  | Cake rewards Cake Club'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Any special promotions or discounts?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '| Our Cake Club rewards program earns you a $10 gift certificate for every
    ten cakes you purchase.  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: In the assistant, we define an action that detects an intent and gives a response—a
    question-answering action. This is the simplest kind of action we can define in
    any conversational AI platform. Figure 2.3 shows the user interface that starts
    this action definition.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH02_F03_Freed2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 User interface to create our first action
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For each of these actions, we need to configure how they start (the user utterances)
    and what they do (respond with an answer). You’ll notice that these are the right-most
    columns in table 2.2\. Some conversational AI platforms also use the intent label
    for the action; ours labels the action based on one of the user utterances that
    triggers it. We start our journey of defining the utterances that trigger the
    `#background` action in figure 2.4.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Note that the user interface points out that the chatbot’s recognition of this
    action will improve with more examples. For the sake of our demo, we will use
    three examples per action, which is enough to get us started. We will demonstrate
    multiple ways to find additional training examples in subsequent chapters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Our question-answering action is almost complete. We have the questions that
    trigger it; now we need to define the chatbot’s response. The response for our
    `#background` action is shown in figure 2.5\. This action has three parts:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '*Conditional logic*—For a static question-answering action, no logic is needed.
    The action only starts when the intent is detected.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Response*—“Assistant says” is the response to the user. Our response is simple
    text.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*响应*—“助手说”是对用户的响应。我们的响应是简单的文本。'
- en: '*Next step*—For a static question-answering action, no next step is needed.
    Giving the answer ends the action.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下一步*—对于静态问答动作，不需要下一步。给出答案就结束了动作。'
- en: '![figure](../Images/CH02_F04_Freed2.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH02_F04_Freed2.png)'
- en: Figure 2.4 Defining the utterances that trigger an action
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4 定义触发动作的表述
- en: '![figure](../Images/CH02_F05_Freed2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH02_F05_Freed2.png)'
- en: Figure 2.5 Defining the response for a question-answering action. The simplest
    form has only one step after detecting the intent—give the response.
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5 定义问答动作的响应。最简单的形式在检测到意图后只有一步——给出响应。
- en: We’ll repeat these action-creation steps for each of the five intents. Each
    action is trained with the examples that trigger it and the response it should
    give. Each of these actions is a single-step action that ends once the answer
    is given.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为五个意图中的每一个重复这些动作创建步骤。每个动作都通过触发它的示例和它应该给出的响应进行训练。这些动作中的每一个都是一个单步动作，一旦给出答案就结束。
- en: When all five actions have been created, we are ready to do some testing. Figure
    2.6 shows the testing interface for our chatbot.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有五个动作都创建完成后，我们就准备好进行一些测试了。图2.6显示了我们的聊天机器人的测试界面。
- en: '![figure](../Images/CH02_F06_Freed2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH02_F06_Freed2.png)'
- en: Figure 2.6 Chat preview link
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6 聊天预览链接
- en: Let’s ask some questions! Figure 2.7 shows the test results for a sample question.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提出一些问题！图2.7显示了样本问题的测试结果。
- en: '![figure](../Images/CH02_F07_Freed2.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH02_F07_Freed2.png)'
- en: Figure 2.7 Example question-answering response from Cake Bot
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7 Cake Bot的示例问答响应
- en: Note that the question asked does not exactly match any of our training examples.
    This indicates that the bot has learned the meaning in the examples. The following
    listing shows additional tests of the bot.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，提出的问题并不完全匹配我们的任何训练示例。这表明机器人已经学会了示例中的含义。以下列表显示了机器人的一些附加测试。
- en: Listing 2.1 Testing Cake Bot with more questions
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1 使用更多问题测试Cake Bot
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a great start for our bot. We can train it on more intents, and we can
    make it more accurate by giving it more examples for those intents. But let’s
    consider something different.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们机器人的一个很好的开始。我们可以对更多的意图进行训练，并且可以通过为这些意图提供更多示例来使其更加准确。但让我们考虑一些不同的事情。
- en: All the question-answering actions we’ve created have been single-step actions.
    The user gets the same response no matter what they ask. In the next section,
    you’ll see how to evolve a static response into a dynamic response based on additional
    information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的所有问答动作都是单步动作。无论用户问什么，他们都会得到相同的响应。在下一节中，你将看到如何根据附加信息将静态响应演变成动态响应。
- en: 2.1.3 Dynamic question and answering
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 动态问答
- en: 'Cake Shop presently has four locations: Columbus, Dublin, Westerville, and
    Grandview. When the bot was first created, all four locations had the same operating
    hours: 9:00 a.m. to 9:00 p.m. on weekdays. Circumstances have shifted—the Columbus
    store needs to open and close one hour earlier (8:00 a.m. to 8:00 p.m.). A single
    chatbot response doesn’t cover all the stores anymore. Now when a user asks about
    store hours, we need to figure out which store they need the hours for. If they
    don’t specify, we’ll need to ask them a clarifying question.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 甜点店目前有四个地点：哥伦布、都柏林、韦斯特维尔和格兰德维尤。当机器人最初创建时，这四个地点的营业时间都是一样的：工作日早上9:00到晚上9:00。情况已经改变——哥伦布的商店需要提前一小时开门和关门（早上8:00到晚上8:00）。单个聊天机器人的响应不再涵盖所有商店。现在当用户询问商店营业时间时，我们需要弄清楚他们需要哪个商店的时间。如果他们没有指定，我们需要问他们澄清问题。
- en: The next listing shows how we want the bot to handle store hours questions in
    a series of sample questions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了我们在一系列样本问题中希望机器人如何处理商店营业时间的问题。
- en: Listing 2.2 Sample conversations for store hours, dependent on location
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.2 根据位置存储时间的示例对话
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 Ambiguous question is now clarified before answering'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 在回答之前澄清了模糊的问题'
- en: '#2 Unambiguous question is answered directly'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 明确的问题直接回答'
- en: We can also draw a flow diagram covering these sample conversations, as shown
    in figure 2.8\. It’s helpful to create a flow diagram and sample conversations
    when your conversation has dynamism. Some of your team members will prefer the
    diagrams, others the conversations, and some will need both.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以绘制一个涵盖这些示例对话的流程图，如图2.8所示。当你的对话具有动态性时，创建流程图和示例对话很有帮助。你的团队成员中有些人可能更喜欢图表，有些人更喜欢对话，有些人可能两者都需要。
- en: '![figure](../Images/CH02_F08_Freed2.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图表](../Images/CH02_F08_Freed2.png)'
- en: Figure 2.8 Process flow for a location-specific `#store_hours` intent
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8特定位置的`#store_hours`意图的处理流程
- en: 'The “store hours” flow can be implemented in three steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “营业时间”流程可以分三步实现：
- en: Display “To view our store hours, please select a location” and a list of locations.
    The user must choose a location.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示“要查看我们的营业时间，请选择一个位置”以及位置列表。用户必须选择一个位置。
- en: If step 1 = “Columbus,” display Columbus hours, and end the action.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果步骤1 = “Columbus”，显示Columbus的营业时间，并结束操作。
- en: Display the hours for the step 1 store, and end the action.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示步骤1商店的营业时间，并结束操作。
- en: 'This works because steps “fall through” in our platform. Here’s how a few conversations
    work:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在我们的平台上，步骤是“逐级传递”的。以下是一些对话的工作方式：
- en: The user types “store hours,” and step 1 fires. The user selects “Columbus,”
    and step 2 fires and completes the action.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入“营业时间”，步骤1被触发。用户选择“Columbus”，步骤2被触发并完成操作。
- en: The user types “store hours,” and step 1 fires. The user selects “Grandview,”
    and the step 2 condition is not met. Step 3 fires and completes the action.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入“营业时间”，步骤1被触发。用户选择“Grandview”，步骤2的条件未满足。步骤3被触发并完成操作。
- en: The user types “store hours for Columbus.” The step 1 exit conditions are met,
    so step 2 fires and completes the action.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入“Columbus的营业时间”。步骤1的退出条件得到满足，因此步骤2被触发并完成操作。
- en: The user types “store hours for Grandview.” The step 1 exit conditions are met,
    and the step 2 condition is not met. Step 3 fires and completes the action.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入“Grandview的营业时间”。满足步骤1的退出条件，但步骤2的条件未满足。步骤3被触发并完成操作。
- en: Figure 2.9 shows how these steps are implemented in our assistant.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9展示了这些步骤在我们助手中的实现方式。
- en: '![figure](../Images/CH02_F09_Freed2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图表](../Images/CH02_F09_Freed2.png)'
- en: Figure 2.9 The three steps for the `#store_hours` action
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9 `#store_hours`动作的三个步骤
- en: Cake Bot is off to a good start. It can answer some basic questions about Cake
    Shop, and it even has a little dynamism. Grandma Cake won’t have to answer so
    many repetitive questions on the phone! But Cake Bot cannot take any action for
    the users yet. We’ll look at that in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Cake Bot起步良好。它可以回答一些关于蛋糕店的基本问题，甚至还有一些活力。奶奶蛋糕不必再在电话上回答那么多的重复问题！但Cake Bot目前还不能为用户执行任何操作。我们将在下一节中探讨这一点。
- en: Exercises
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习
- en: 'Download this chapter’s chatbot code from the book’s GitHub site: [https://github.com/andrewrfreed/EffectiveConversationalAI](https://github.com/andrewrfreed/EffectiveConversationalAI).
    Load the chatbot in watsonx Assistant, and use the Preview panel to test the chatbot’s
    question and answering flows.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书的GitHub网站下载本章的聊天机器人代码：[https://github.com/andrewrfreed/EffectiveConversationalAI](https://github.com/andrewrfreed/EffectiveConversationalAI)。在watsonx
    Assistant中加载聊天机器人，并使用预览面板测试聊天机器人的问答流程。
- en: 'Alternatively, implement Cake Bot in your preferred conversational AI platform:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，在您首选的对话AI平台上实现Cake Bot：
- en: Define a greeting message.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个问候消息。
- en: Define a fallback intent and/or fallback message.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个回退意图和/或回退消息。
- en: Implement the five intents from table 2.2\.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现表2.2中的五个意图。
- en: 2.2 Routing agents and process-oriented bots
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 路由代理和面向过程的机器人
- en: Not all bots are question-answering bots. Q&A bots are great at delivering answers,
    but what if the user needs more than an answer—what if they need the bot to act?
    For Cake Shop, we’d love for customers to be able to order cakes from the bot.
    If all we have is question-answering capability, figure 2.10 is the best we can
    do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有机器人都是问答机器人。问答机器人擅长提供答案，但如果用户需要的不仅仅是答案——如果他们需要机器人执行操作呢？对于蛋糕店来说，我们希望顾客能够通过机器人订购蛋糕。如果我们只有问答能力，那么图2.10就是我们能做的最好了。
- en: '![figure](../Images/CH02_F10_Freed2.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图表](../Images/CH02_F10_Freed2.png)'
- en: Figure 2.10 Cake Shop’s cake order process as question-answering. But it doesn't
    really answer the question!
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10 Cake Shop的蛋糕订购流程作为问答。但这实际上并没有真正回答问题！
- en: The user wants to complete a process but cannot do that inside the bot. They
    only get *instructions* on how to complete the process. A question-answering bot
    is thus often an early iteration of a more capable solution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用户想要完成一个流程，但无法在机器人内部完成。他们只能获得如何完成流程的*说明*。因此，问答机器人通常是更强大解决方案的早期迭代。
- en: 2.2.1 Routing agents
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 路由代理
- en: Cake Shop offers a wide variety of cakes with different flavoring and decoration
    options. There are decoration packages for weddings, graduations, birthdays, and
    more. There are flavoring options including vanilla, chocolate, and strawberry.
    Plus, there are payment and delivery methods. Given all these options, it’s reasonable
    to assume the user may want or need to talk this process through with a human.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋糕店提供各种不同口味和装饰选项的蛋糕。有婚礼、毕业典礼、生日等活动的装饰套餐。有香草、巧克力、草莓等口味选择。此外，还有支付和配送方式。考虑到所有这些选项，合理地假设用户可能想要或需要与人类讨论这个过程。
- en: For many chatbot developers, the next logical iteration of their chatbot is
    a routing agent. The routing agent detects the intent from the user’s utterance
    and determines who can best help fulfill the intent. Figure 2.11 reimagines our
    Cake Bot with routing agent capabilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多聊天机器人开发者来说，他们聊天机器人的下一个逻辑迭代是路由代理。路由代理从用户的表述中检测意图，并确定谁最能帮助满足这个意图。图2.11重新构想了我们带有路由代理功能的蛋糕机器人。
- en: '![figure](../Images/CH02_F11_Freed2.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH02_F11_Freed2.png)'
- en: Figure 2.11 A routing agent detects user intents and routes them to an appropriate
    specialist.
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.11 路由代理检测用户意图并将它们路由到合适的专家。
- en: 'For the original Q&A requests, the bot works as it did before. But for cake-ordering
    requests, this bot does not attempt to answer the question at all—it just routes
    the call to an appropriate specialist. See our implementation in figure 2.12\.
    The action has one step once the intent is detected: route the user to a specialist.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始的问答请求，机器人仍然按照之前的方式工作。但对于蛋糕订购请求，这个机器人根本不尝试回答问题——它只是将电话转接到合适的专家。请参见图2.12中的我们的实现。一旦检测到意图，动作就只有一个步骤：将用户转接到专家。
- en: '![figure](../Images/CH02_F12_Freed2.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH02_F12_Freed2.png)'
- en: Figure 2.12 Routing agent configuration for `#cake_orders`. As soon as the intent
    is detected, the user is deflected to a human specialist.
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.12为`#cake_orders`的路由代理配置。一旦检测到意图，用户就会被转接到人工专家。
- en: This routing agent is just triaging incoming requests, which can be transferred
    to human agents or to specialized AI solutions. The human agents could use the
    telephone or live web chat. In this book, we’ll generically refer to these humans
    as *call center agents*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由代理只是对传入的请求进行初步分类，这些请求可以转接到人工代理或专门的AI解决方案。人工代理可以使用电话或实时网络聊天。在这本书中，我们将这些人类通称为*呼叫中心代理*。
- en: Press 1 for appointments . . .
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 按1预约……
- en: You’ve probably phoned an interactive voice response (IVR) system that recites
    a menu of options and prompts you to select one (“press 1 for appointments”).
    This is also a routing agent. One downside to these systems is the length of time
    it takes to read the menu. A conversational AI routing agent lets you speak your
    intent, increasing the convenience over listening to a lengthy menu.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能拨打过一个交互式语音响应（IVR）系统，它会朗读一个选项菜单并提示你选择一个（“按1预约”）。这也是一个路由代理。这些系统的缺点之一是读取菜单所需的时间长度。对话人工智能路由代理允许你表达你的意图，这比听一个漫长的菜单更方便。
- en: Routing agents let you implement conversational AI solutions iteratively rather
    than needing to handle everything at once.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 路由代理允许您迭代地实现对话人工智能解决方案，而不是需要一次性处理所有事情。
- en: The human agents in routing agent systems often know what type of request they
    are receiving but little else. In figure 2.12, they were only told that the user
    wanted to order a cake. For some process flows with high degrees of complexity
    and sensitivity, this may be ideal. For instance, a “report fraud” intent should
    probably connect to a human right away.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 路由代理系统中的人工代理通常知道他们接收到的请求类型，但除此之外知之甚少。在图2.12中，他们只知道用户想要订购蛋糕。对于一些具有高度复杂性和敏感性的流程，这可能很理想。例如，“报告欺诈”意图可能应该立即连接到人类。
- en: In other scenarios, an early deflection to a human agent is mundane for the
    agent and expensive for the employer. For insurance systems handling claim statuses,
    member IDs and claim dates must be collected before getting to higher value tasks
    like explaining what has happened with a claim. Here the AI assistant could first
    collect the member ID and claim date before directing the conversation to a human.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他场景中，将对话早期转接到人工代理对于代理来说是平凡的，但对于雇主来说却是昂贵的。对于处理索赔状态、成员ID和索赔日期的保险系统，在执行更高价值任务（如解释索赔发生了什么）之前，必须收集这些信息。在这里，人工智能助手可以先收集成员ID和索赔日期，然后再将对话转接到人类。
- en: Thus, the next evolution of a routing agent is to shift more of the work to
    automation. Let’s build this for Cake Bot.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，路由代理的下一步进化是将更多的工作转移到自动化。让我们为蛋糕机器人构建这个功能。
- en: 2.2.2 Transitioning from a routing agent to a process-oriented bot
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 从路由代理过渡到面向过程的机器人
- en: 'The generalized process flow for ordering cakes is shown in figure 2.13\. It
    includes four steps to clarify details about the cake being ordered, then a confirmation
    step, and finally fulfillment. (For brevity, we will omit the fulfillment details
    for the rest of the chapter—example code is available at our GitHub site: [https://github.com/andrewrfreed/EffectiveConversationalAI](https://github.com/andrewrfreed/EffectiveConversationalAI).)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 订购蛋糕的通用流程流程图如图2.13所示。它包括四个步骤，用于明确订购的蛋糕的细节，然后是确认步骤，最后是履行。为了简洁起见，我们将省略本章剩余部分的履行细节——示例代码可在我们的GitHub网站上找到：[https://github.com/andrewrfreed/EffectiveConversationalAI](https://github.com/andrewrfreed/EffectiveConversationalAI)。
- en: '![figure](../Images/CH02_F13_Freed2.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH02_F13_Freed2.png)'
- en: Figure 2.13 Process flow for ordering a cake from Cake Shop
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.13 从蛋糕店订购蛋糕的流程图
- en: With the full process flow designed, we can transition from a routing agent
    toward a process-oriented bot. Cake Bot will handle part of the cake-ordering
    process by collecting a few details before routing to a human agent to complete
    the process. Figure 2.14 shows the design for the first iteration of Cake Bot’s
    transition.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整的过程流程设计完成后，我们可以从路由代理过渡到面向过程的机器人。蛋糕机器人将通过在路由到人工代理完成流程之前收集一些细节来处理部分蛋糕订购流程。图2.14显示了蛋糕机器人过渡的第一迭代的设计。
- en: '![figure](../Images/CH02_F14_Freed2.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH02_F14_Freed2.png)'
- en: Figure 2.14 Transitioning a routing agent to a process-oriented bot. The bot
    now collects two pieces of information before handing off to a human.
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.14 将路由代理过渡到面向过程的机器人。机器人现在在转交给人工之前收集两块信息。
- en: 'Our process used to have one step (figure 2.12). Now we’ll have four:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过程过去只有一步（图2.12）。现在我们将有四步：
- en: The bot will start the process by responding, “I can help with your cake order.”
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器人将通过回复“我可以帮助您订购蛋糕”来启动流程。
- en: Ask which size cake is needed, and provide options (small, medium, large).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问需要哪种尺寸的蛋糕，并提供选项（小、中、大）。
- en: Ask the occasion for the cake, and provide options (birthday, wedding, anniversary,
    retirement, all-occasion).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问蛋糕的场合，并提供选项（生日、婚礼、周年纪念、退休、全场合）。
- en: Transfer the user to a human agent. This is the original first step from the
    routing agent, but the message to the agent has changed from “User wants to order
    a cake” to “User wants to order a <size> <occasion> cake.” The assistant will
    inject the responses from steps 2 and 3 into the message.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户转接到人工代理。这是路由代理的原始第一步，但代理的消息已从“用户想要订购蛋糕”更改为“用户想要订购一个<尺寸> <场合>蛋糕。”助手将步骤2和3的回复注入到消息中。
- en: These steps are executed sequentially. Figure 2.15 shows step 2.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤是顺序执行的。图2.15显示了步骤2。
- en: '![figure](../Images/CH02_F15_Freed2.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH02_F15_Freed2.png)'
- en: Figure 2.15 The step to collect the cake size offers explicit choices to the
    user.
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.15 收集蛋糕尺寸的步骤为用户提供明确的选择。
- en: Note that the bot can offer distinct options to the user as buttons, letting
    the user know which options are available. The bot can also allow the user to
    type their response if they prefer. You can explore these options in the sample
    code provided on the book’s GitHub site.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，机器人可以以按钮的形式向用户提供不同的选项，让用户知道哪些选项可用。机器人还可以允许用户输入他们的回复，如果他们愿意的话。您可以在书中GitHub网站上提供的示例代码中探索这些选项。
- en: Also note that each of these options will support a “fall through.” If the user
    starts the conversation with “I want to order a cake,” they will be asked for
    size and occasion. If they say “I want to order a large anniversary cake,” they
    will skip the size and occasion questions since they already provided that information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这些选项中的每一个都将支持“贯穿到底”。如果用户以“我想订购一个蛋糕”开始对话，他们将被要求提供尺寸和场合。如果他们说“我想订购一个大型周年纪念蛋糕”，他们将跳过尺寸和场合问题，因为他们已经提供了这些信息。
- en: The rest of the cake-ordering process has been implemented on the book’s GitHub
    site following the steps described in this section. A sample conversation is provided
    in the following listing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的蛋糕订购流程已在本节描述的步骤指导下在书的GitHub网站上实现。以下列表提供了一个示例对话。
- en: Listing 2.3 Sample conversations for cake ordering
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.3 饼干订购的示例对话
- en: '[PRE2]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 The confirmation message in step 7 plays back the information collected
    in previous steps.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The order confirmation in step 8 triggers conditional logic for the price
    of the cake.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Cake Bot is getting more capable. It has static question-answering capability
    about cakes, dynamic question-answering capability about store hours, and a process-oriented
    flow for ordering cakes. The Cake Shop team deploys its chatbot and is pleased
    with the results (and the users are pleased with their cakes!). Next, we’ll take
    on our final challenge of the chapter: adding generative AI capability with a
    large language model (LLM).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Refer to this chapter’s chatbot code that you downloaded from the book’s GitHub
    site ([https://github.com/andrewrfreed/EffectiveConversationalAI](https://github.com/andrewrfreed/EffectiveConversationalAI)).
    Load the chatbot in watsonx Assistant, and use the Preview panel to test the chatbot’s
    cake-ordering flow.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, implement Cake Bot’s ordering process in your preferred conversational
    AI platform:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detect the cake-ordering intent.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Route the intent directly to a human agent.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Collect all four cake data points, and conclude with a summary.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3 Responding to the user with generative AI
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cake Bot only uses traditional conversational AI technology so far. The question-answering
    is done by an intent-based classifier. The ordering process is done with a sequential
    series of rules. This has worked well for the needs of Cake Shop so far.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: When the Cake Shop team reviews the performance of the Cake Bot, they see an
    unusual trend. Users are asking the bot for recipes they intend to serve for dinner
    before the cake. There’s no other pattern to recipe requests—there are requests
    for casseroles, salads, stir fries, and more. The team is heartened by the diversity
    of their users but does not know how to handle these requests in the Cake Bot.
    How could they detect all these different types of recipes, let alone respond
    to them all?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent place for the Cake Shop team to incorporate some generative
    AI into their solution. They can use the existing intent mechanism to detect recipe
    requests and then route those to an LLM to generate an answer. They will need
    to integrate an LLM into their chatbot generally and send specific requests to
    that LLM.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how they can do that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1 Integrating with an LLM
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For many conversational AI platforms, the primary way to integrate with external
    systems is through application programming interfaces (APIs). These are ubiquitous
    integration patterns and fortunately are supported by a large variety of generative
    AI platforms that expose LLMs. The specific way APIs are integrated into conversational
    AI will vary by platform. In some platforms, this integration is done with code;
    others are low-code and visual interfaces. Differing platforms have different
    names for their integration capabilities, such as *extensions*, *integrations*,
    and *fulfillments*. Many let you integrate APIs via OpenAPI specifications.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a generative AI platform as an extension to do LLM-based text generation.
    There are four steps to adding an extension in our platform (the details of the
    steps are included in the book’s GitHub repository):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: From the Integrations menu, select Build a Custom Extension.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a name and description, like “Generative AI platform API call.”
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide an OpenAPI specification file. This file documents the capabilities
    of the extension, including the methods it exposes, its required and optional
    parameters, and the responses it provides. OpenAPI specification files are a common
    documentation format for APIs. They are usually provided by generative AI platforms.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide connectivity and authentication details, such as the URL of the API
    implementation and the API key needed to access it.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the extension and visually explore it from inside the assistant. Figure
    2.16 shows the extension for the LLM text generation API in our platform.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH02_F16_Freed2.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 OpenAPI spec for our LLM text generation API with a subset of the
    possible request parameters
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At the time of writing, our text generation API includes 15 input parameters
    and 6 output parameters—more than fit in figure 2.16! There are also a handful
    of parameters available without any customization, like the HTTP status code for
    the response. Other generative AI platforms will have a similar parameter set,
    perhaps with different parameter names or locations. Let’s review the most significant
    parameters:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '`input` (request)—The prompt to the LLM. It will include the instructions,
    context, and data for the LLM. Some of that data may come directly from the user.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model_id` (request)—Identifier of the LLM to use for the task. Most generative
    AI platforms let you pick from several models.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters` (request)—Key-value pairs that tweak the LLM’s behavior. These
    include the decoding method (greedy or sampling), number of output tokens to generate,
    and several other parameters.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generated_text` (response)—The output from the LLM.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use an extension from any step in any action. Earlier in this chapter,
    we used capabilities like “Assistant says,” “Continue to next step,” and “Connect
    to Agent.” For extensions, the capability is called “Use an extension.” Figure
    2.17 shows what that extension invocation looks like for our recipe action. Other
    LLM tasks would look similar but have different configuration values. This parameter
    set is tuned for providing recipes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH02_F17_Freed2.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 Invoking an LLM text-generation API from an action in the assistant
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at how we can connect this all together in Cake Bot.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2 Routing requests to an LLM
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow diagram in figure 2.18 outlines how the recipe generation will be covered
    in Cake Bot. We first create a new action. Just like our question-answering actions,
    we start with some example utterances that trigger this action. Our first three
    utterances are “Show me a recipe for,” “How can I make,” and “Tell me how to bake
    a.” Given the huge variety of possible recipes, we do not include the names of
    the dishes, just the way that recipe requests are likely to look.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH02_F18_Freed2.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 Flow diagram for recipe generation in Cake Bot via LLM
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Step 1 of the new action is to store the entirety of the user’s original utterance
    (from the system variable `input.text`) in a variable called `recipe_query_text`.
    This is a technique we have not done in previous steps. For the cake-ordering
    action, each option had an explicit and finite set of responses. Even if the user
    said, “large cake, please” we only wanted to store “large.” For the recipe request,
    we have no idea what the user will say, so we will capture their entire utterance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 of the action is to define the prompt for the LLM. We concatenate a simple
    system prompt with the user’s request. The next listing demonstrates the expression
    used in building the `recipe_prompt` variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 2.4 Building the recipe prompt, which is stored in the `recipe_prompt`
    variable**'
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Step 3 of the action is to call the LLM. The parameters were shown in figure
    2.17, but let’s dive into the specific values here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '`input`—We assign the `recipe_prompt` variable value as input. This injects
    the user’s recipe request into the generalized prompt format shown in listing
    2.4\.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model_id`—There are many models available, but at the time of writing, mistralai/mixtral-8x7b-instruct-v01
    has performed well on this generation task.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project_id`—This is an identifier from the generative AI platform project
    instance.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_tokens` and `max_tokens`—These are set to `0` and `1000` respectively,
    increased from the defaults of `0` and `200`, because recipes tend to be a bit
    lengthy.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decoding_method`—Set to `greedy` for ease of debugging, so the model responds
    identically if the same input is given.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repetition_penalty`—Set to `1` (no penalty), since recipes on the internet
    typically have some repetition in them.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`—Indicates the minor version of the API requested. We used the default
    at the time of writing: 2023-05-29\.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 4 of the action is to check that the API call was successful, and if so,
    to display the response to the user. We’ll generate a response starting with some
    static text, “Here’s your recipe,” and append the LLM response. We don’t need
    to write any JSON parsing code; the OpenAPI specification tells us we can reference
    the value of `generated_text`. Figure 2.19 shows the action response configuration.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH02_F19_Freed2.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 Displaying the output from the LLM call to the user
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This was a lot of fun to build inside Cake Bot! Listing 2.5 shows one example
    conversation we had with the bot. The recipe is lengthy, so most of it is omitted
    for brevity. Load up Cake Bot and try it for yourself!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.5 Sample abbreviated conversation with Cake Bot
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercises
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Refer to this chapter’s chatbot code that you downloaded from the book’s GitHub
    site ([https://github.com/andrewrfreed/EffectiveConversationalAI](https://github.com/andrewrfreed/EffectiveConversationalAI)).
    Load the chatbot in watsonx Assistant, and follow the instructions to integrate
    with watsonx.ai. Use the Preview panel to test the chatbot’s recipe flow.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, implement Cake Bot’s ordering process in your preferred conversational
    and generative AI platforms:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detect the recipe intent.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a prompt from a set of instructions and the user’s input.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct the LLM’s response to the user.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Question-answering (Q&A) bots are a great way to start building your first conversational
    AI.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training Q&A bots with examples of questions lets you provide predefined answers
    to related groups of questions (intents).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actions start with an intent and can have many outcomes: answering a question,
    deflecting a user to a human agent, asking follow-up questions, and making API
    calls.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A routing agent identifies intents and passes information to human agents. It
    is a great method for incrementally adding capability to a conversational AI while
    leaning on human capability.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversational AI can use a combination of traditional and rules-based techniques
    along with generative AI.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
