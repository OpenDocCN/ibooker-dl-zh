<html><head></head><body><section data-pdf-bookmark="Chapter 9. Understanding Sequence and Time Series Data" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch09_understanding_sequence_and_time_series_data_1748549698134578">
      <h1><span class="label">Chapter 9. </span>Understanding Sequence <span class="keep-together">and Time Series Data</span></h1>
      <p>Time series are everywhere. <a contenteditable="false" data-primary="time series data" data-secondary="about" data-type="indexterm" id="id1413"/><a contenteditable="false" data-primary="Moore’s law" data-type="indexterm" id="id1414"/>You’ve probably seen them in things like weather forecasts, stock prices, and historic trends like Moore’s law. If you’re not familiar with <em>Moore’s law</em>, it predicts that the number of transistors on a microchip will roughly double every two years—and for almost 50 years, it has proven to be an accurate predictor of the future of computing power and cost (see <a data-type="xref" href="#ch09_figure_1_1748549698128120">Figure 9-1</a>).</p>
      <figure><div class="figure" id="ch09_figure_1_1748549698128120">
        <img alt="Moore’s law" src="assets/aiml_0901.png"/>
        <h6><span class="label">Figure 9-1. </span>Moore’s law</h6>
      </div></figure>
      <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>The gaps in <a data-type="xref" href="#ch09_figure_1_1748549698128120">Figure 9-1</a> are missing data for that period of time, but the general trend still holds.</p>
      </div>
      <p><em>Time series data</em> is a set of values that are spaced over time, usually in a particular order or denoting values of a thing at a timestamped point in time. When a time series is plotted on a graph, the <em>x</em>-axis is usually temporal in nature. Often, there are a number of values plotted on the time axis, such as in the example shown in <a data-type="xref" href="#ch09_figure_1_1748549698128120">Figure 9-1</a>, where the number of transistors is one plot and the predicted value from Moore’s law is the other. <a contenteditable="false" data-primary="time series data" data-secondary="multivariate time series" data-type="indexterm" id="id1415"/><a contenteditable="false" data-primary="multivariate time series" data-type="indexterm" id="id1416"/><a contenteditable="false" data-primary="time series data" data-secondary="univariate time series" data-type="indexterm" id="id1417"/><a contenteditable="false" data-primary="univariate time series" data-type="indexterm" id="id1418"/>This is called a <em>multivariate</em> time series. If there’s just a single value—for example, the volume of rainfall over time—then it’s called a <em>univariate</em> time series.</p>
      <p>With Moore’s law, predictions are simple because there’s a fixed and simple rule that allows us to roughly predict the future—a rule that has held for about 50 years.</p>
      <p>But what about a time series like the one shown in <a data-type="xref" href="#ch09_figure_2_1748549698128170">Figure 9-2</a>?</p>
      <figure><div class="figure" id="ch09_figure_2_1748549698128170">
        <img alt="" src="assets/aiml_0902.png"/>
        <h6><span class="label">Figure 9-2. </span>A real-world time series</h6>
      </div></figure>
      <p>While this time series was artificially created (and you’ll see how to do that later in this chapter), it has all the attributes of a complex real-world time series, like a stock chart or a chart depicting seasonal rainfall. Despite their seeming randomness, time series have some common attributes that are helpful in designing ML models that can predict them, as described in the next section.</p>
      <section data-pdf-bookmark="Common Attributes of Time Series" data-type="sect1"><div class="sect1" id="ch09_common_attributes_of_time_series_1748549698134824">
        <h1>Common Attributes of Time Series</h1>
        <p>While time series might appear random and noisy, they often have common attributes that are predictable. In this section, we’ll explore some of them.</p>
        <section data-pdf-bookmark="Trend" data-type="sect2"><div class="sect2" id="ch09_trend_1748549698134897">
          <h2>Trend</h2>
          <p>Time series typically move<a contenteditable="false" data-primary="time series data" data-secondary="attributes" data-tertiary="trend" data-type="indexterm" id="id1419"/><a contenteditable="false" data-primary="trends in time series data" data-type="indexterm" id="id1420"/> in a specific direction. In the case of Moore’s law, it’s easy to see that over time, the values on the <em>y</em>-axis increase and there’s an upward trend. There’s also an upward trend in the time series in <a data-type="xref" href="#ch09_figure_2_1748549698128170">Figure 9-2</a>. Of course, this won’t always be the case: some time series may be roughly level over time, despite seasonal changes, and others may have a downward trend. For example, this is the case in the inverse version of Moore’s law that predicts the price per transistor.</p>
        </div></section>
        <section data-pdf-bookmark="Seasonality" data-type="sect2"><div class="sect2" id="ch09_seasonality_1748549698134958">
          <h2>Seasonality</h2>
          <p>Many time series have a <a contenteditable="false" data-primary="time series data" data-secondary="attributes" data-tertiary="seasonality" data-type="indexterm" id="id1421"/><a contenteditable="false" data-primary="seasonality of time series data" data-type="indexterm" id="id1422"/>repeating pattern over time, with the repeats happening at regular intervals called <em>seasons</em>. Consider, for example, temperature in weather. We typically have four seasons per year, with the temperature being highest in summer. So, if you plotted weather over several years, you’d see peaks happening every four seasons, giving us the concept of seasonality. But this phenomenon isn’t limited to weather—consider, for example, <a data-type="xref" href="#ch09_figure_3_1748549698128196">Figure 9-3</a>, which is a plot of traffic to a website.</p>
          <figure><div class="figure" id="ch09_figure_3_1748549698128196">
            <img alt="" src="assets/aiml_0903.png"/>
            <h6><span class="label">Figure 9-3. </span>Website traffic</h6>
          </div></figure>
          <p>It’s plotted week by week, and you can see regular dips. Can you guess what they are? The site in this case is one that provides information for software developers, and as you would expect, it gets less traffic on weekends! Thus, the time series has a seasonality of five high days and two low days. The data is plotted over several months, with the Christmas and New Year’s holidays roughly in the middle, so you can see an additional seasonality there. If I had plotted it over some years, you’d clearly see the additional end-of-year dip.</p>
          <p>There are many ways that seasonality can manifest in a time series. Traffic to a retail website, for instance, might peak on the weekends.</p>
        </div></section>
        <section class="pagebreak-before" data-pdf-bookmark="Autocorrelation" data-type="sect2"><div class="sect2" id="ch09_autocorrelation_1748549698135016">
          <h2>Autocorrelation</h2>
          <p>Another feature that you may<a contenteditable="false" data-primary="time series data" data-secondary="attributes" data-tertiary="autocorrelation" data-type="indexterm" id="id1423"/><a contenteditable="false" data-primary="autocorrelation in time series data" data-type="indexterm" id="id1424"/> see in time series is predictable behavior after an event. You can see this in <a data-type="xref" href="#ch09_figure_4_1748549698128218">Figure 9-4</a>, in which there are clear spikes, but after each spike, there’s a deterministic decay. This is called <em>autocorrelation</em>.</p>
          <p>In this case, we can see a particular set of behavior that is repeated. Autocorrelations may be hidden in a time series pattern, but they have inherent predictability, so a time series containing many autocorrelations may be predictable.</p>
          <figure><div class="figure" id="ch09_figure_4_1748549698128218">
            <img alt="" src="assets/aiml_0904.png"/>
            <h6><span class="label">Figure 9-4. </span>Autocorrelation</h6>
          </div></figure>
        </div></section>
        <section class="pagebreak-before" data-pdf-bookmark="Noise" data-type="sect2"><div class="sect2" id="ch09_noise_1748549698135074">
          <h2>Noise</h2>
          <p>As its name suggests, <em>noise</em> is a<a contenteditable="false" data-primary="time series data" data-secondary="attributes" data-tertiary="noise" data-type="indexterm" id="id1425"/><a contenteditable="false" data-primary="noise in time series data" data-type="indexterm" id="id1426"/> set of seemingly random perturbations in a time series. These perturbations lead to a high level of unpredictability and can mask trends, seasonal behavior, and autocorrelation. For example, <a data-type="xref" href="#ch09_figure_5_1748549698128240">Figure 9-5</a> shows the same autocorrelation from <a data-type="xref" href="#ch09_figure_4_1748549698128218">Figure 9-4</a> but with a little noise added. Suddenly, it’s much harder to see the autocorrelation and predict values.</p>
          <figure><div class="figure" id="ch09_figure_5_1748549698128240">
            <img alt="" src="assets/aiml_0905.png"/>
            <h6><span class="label">Figure 9-5. </span>Autocorrelated series with added noise</h6>
          </div></figure>
          <p>Given all of these factors, let’s explore how you can make predictions on time series that contain these attributes.</p>
        </div></section>
      </div></section>
      <section class="pagebreak-before less_space" data-pdf-bookmark="Techniques for Predicting Time Series" data-type="sect1"><div class="sect1" id="ch09_techniques_for_predicting_time_series_1748549698135145">
        <h1>Techniques for Predicting Time Series</h1>
        <p>Before we get into ML-based prediction—which is the topic of the next few chapters—we’ll explore some more naive prediction methods. These will enable you to establish a baseline that you can use to measure the accuracy of your ML predictions.</p>
        <section data-pdf-bookmark="Naive Prediction to Create a Baseline" data-type="sect2"><div class="sect2" id="ch09_naive_prediction_to_create_a_baseline_1748549698135217">
          <h2>Naive Prediction to Create a Baseline</h2>
          <p>The most basic method <a contenteditable="false" data-primary="time series data" data-secondary="predicting" data-tertiary="baseline naive prediction" data-type="indexterm" id="ch9naiv"/>to predict a time series is to say that the predicted value at time <em>t</em> + 1 is the same as the value from time <em>t</em>, effectively shifting the time series by a single period.</p>
          <p>Let’s begin by creating a time series that has trend, seasonality, and noise:<a contenteditable="false" data-primary="time series data" data-secondary="creating a synthetic time series" data-type="indexterm" id="id1427"/></p>
          <pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">plot_series</code><code class="p">(</code><code class="n">time</code><code class="p">,</code> <code class="n">series</code><code class="p">,</code> <code class="nb">format</code><code class="o">=</code><code class="s2">"-"</code><code class="p">,</code> <code class="n">start</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code> <code class="n">end</code><code class="o">=</code><code class="kc">None</code><code class="p">):</code>
    <code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">time</code><code class="p">[</code><code class="n">start</code><code class="p">:</code><code class="n">end</code><code class="p">],</code> <code class="n">series</code><code class="p">[</code><code class="n">start</code><code class="p">:</code><code class="n">end</code><code class="p">],</code> <code class="nb">format</code><code class="p">)</code>
    <code class="n">plt</code><code class="o">.</code><code class="n">xlabel</code><code class="p">(</code><code class="s2">"Time"</code><code class="p">)</code>
    <code class="n">plt</code><code class="o">.</code><code class="n">ylabel</code><code class="p">(</code><code class="s2">"Value"</code><code class="p">)</code>
    <code class="n">plt</code><code class="o">.</code><code class="n">grid</code><code class="p">(</code><code class="kc">True</code><code class="p">)</code>
 
<code class="k">def</code> <code class="nf">trend</code><code class="p">(</code><code class="n">time</code><code class="p">,</code> <code class="n">slope</code><code class="o">=</code><code class="mi">0</code><code class="p">):</code>
    <code class="k">return</code> <code class="n">slope</code> <code class="o">*</code> <code class="n">time</code>
 
<code class="k">def</code> <code class="nf">seasonal_pattern</code><code class="p">(</code><code class="n">season_time</code><code class="p">):</code>
    <code class="sd">"""Just an arbitrary pattern, you can change it if you wish"""</code>
    <code class="k">return</code> <code class="n">np</code><code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="n">season_time</code> <code class="o">&lt;</code> <code class="mf">0.4</code><code class="p">,</code>
                    <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">season_time</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">pi</code><code class="p">),</code>
                    <code class="mi">1</code> <code class="o">/</code> <code class="n">np</code><code class="o">.</code><code class="n">exp</code><code class="p">(</code><code class="mi">3</code> <code class="o">*</code> <code class="n">season_time</code><code class="p">))</code>
 
<code class="k">def</code> <code class="nf">seasonality</code><code class="p">(</code><code class="n">time</code><code class="p">,</code> <code class="n">period</code><code class="p">,</code> <code class="n">amplitude</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">phase</code><code class="o">=</code><code class="mi">0</code><code class="p">):</code>
    <code class="sd">"""Repeats the same pattern at each period"""</code>
    <code class="n">season_time</code> <code class="o">=</code> <code class="p">((</code><code class="n">time</code> <code class="o">+</code> <code class="n">phase</code><code class="p">)</code> <code class="o">%</code> <code class="n">period</code><code class="p">)</code> <code class="o">/</code> <code class="n">period</code>
    <code class="k">return</code> <code class="n">amplitude</code> <code class="o">*</code> <code class="n">seasonal_pattern</code><code class="p">(</code><code class="n">season_time</code><code class="p">)</code>
 
<code class="k">def</code> <code class="nf">noise</code><code class="p">(</code><code class="n">time</code><code class="p">,</code> <code class="n">noise_level</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">seed</code><code class="o">=</code><code class="kc">None</code><code class="p">):</code>
    <code class="n">rnd</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">RandomState</code><code class="p">(</code><code class="n">seed</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">rnd</code><code class="o">.</code><code class="n">randn</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">time</code><code class="p">))</code> <code class="o">*</code> <code class="n">noise_level</code>
 
<code class="n">time</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">4</code> <code class="o">*</code> <code class="mi">365</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="s2">"float32"</code><code class="p">)</code>
<code class="n">baseline</code> <code class="o">=</code> <code class="mi">10</code>
<code class="n">series</code> <code class="o">=</code> <code class="n">trend</code><code class="p">(</code><code class="n">time</code><code class="p">,</code> <code class="mf">.05</code><code class="p">)</code>  
<code class="n">baseline</code> <code class="o">=</code> <code class="mi">10</code>
<code class="n">amplitude</code> <code class="o">=</code> <code class="mi">15</code>
<code class="n">slope</code> <code class="o">=</code> <code class="mf">0.09</code>
<code class="n">noise_level</code> <code class="o">=</code> <code class="mi">6</code>
 
<code class="c1"># Create the series</code>
<code class="n">series</code> <code class="o">=</code> <code class="n">baseline</code> <code class="o">+</code> <code class="n">trend</code><code class="p">(</code><code class="n">time</code><code class="p">,</code> <code class="n">slope</code><code class="p">)</code> 
                  <code class="o">+</code> <code class="n">seasonality</code><code class="p">(</code><code class="n">time</code><code class="p">,</code> <code class="n">period</code><code class="o">=</code><code class="mi">365</code><code class="p">,</code> <code class="n">amplitude</code><code class="o">=</code><code class="n">amplitude</code><code class="p">)</code>
<code class="c1"># Update with noise</code>
<code class="n">series</code> <code class="o">+=</code> <code class="n">noise</code><code class="p">(</code><code class="n">time</code><code class="p">,</code> <code class="n">noise_level</code><code class="p">,</code> <code class="n">seed</code><code class="o">=</code><code class="mi">42</code><code class="p">)</code></pre>
          <p>After plotting this, you’ll see something like <a data-type="xref" href="#ch09_figure_6_1748549698128263">Figure 9-6</a>.</p>
          <figure><div class="figure" id="ch09_figure_6_1748549698128263">
            <img alt="A time series showing trend, seasonality, and noise" src="assets/aiml_0906.png"/>
            <h6><span class="label">Figure 9-6. </span>A time series showing trend, seasonality, and noise</h6>
          </div></figure>
          <p>Now that you have the data,<a contenteditable="false" data-primary="time series data" data-secondary="splitting with whole seasons per split" data-type="indexterm" id="id1428"/> you can split it like any data source into a training set, a validation set, and a test set. When there’s some seasonality in the data, as you can see in this case, it’s a good idea when splitting the series to ensure that there are whole seasons in each split. So, for example, if you wanted to split the data in <a data-type="xref" href="#ch09_figure_6_1748549698128263">Figure 9-6</a> into training and validation sets, a good place to do this might be at time step 1,000, which would give you training data up to step 1,000 and validation data after step 1,000.</p>
          <p>However, you don’t actually need to do the split here because you’re just doing a naive forecast where each value <em>t</em> is simply the value at step <em>t</em> – 1, but for the purposes of illustration in the next few figures, we’ll zoom in on the data from time step 1,000 onward.</p>
          <p>To predict the series from a split time period onward, where the period that you want to split from is in the variable <code>split_time</code>, you can use code like this:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">naive_forecast</code> <code class="o">=</code> <code class="n">series</code><code class="p">[</code><code class="n">split_time</code> <code class="err">–</code> <code class="mi">1</code><code class="p">:</code><code class="err">–</code><code class="mi">1</code><code class="p">]</code>
</pre>
          <p><a data-type="xref" href="#ch09_figure_7_1748549698128284">Figure 9-7</a> shows the validation set (from time step 1,000 onward, which you get by setting <code>split_time</code> to <code>1000</code>) with the naive prediction overlaid.</p>
          <figure><div class="figure" id="ch09_figure_7_1748549698128284">
            <img alt="" src="assets/aiml_0907.png"/>
            <h6><span class="label">Figure 9-7. </span>Naive forecast on time series</h6>
          </div></figure>
          <p>It looks pretty good—there is a relationship between the values—and, when charted over time, the predictions appear to closely match the original values. But how would you measure the accuracy?<a contenteditable="false" data-primary="" data-startref="ch9naiv" data-type="indexterm" id="id1429"/></p>
        </div></section>
        <section data-pdf-bookmark="Measuring Prediction Accuracy" data-type="sect2"><div class="sect2" id="ch09_measuring_prediction_accuracy_1748549698135280">
          <h2>Measuring Prediction Accuracy</h2>
          <p>There are a number of ways<a contenteditable="false" data-primary="time series data" data-secondary="predicting" data-tertiary="measuring prediction accuracy" data-type="indexterm" id="id1430"/><a contenteditable="false" data-primary="mean squared error (MSE) for time series" data-type="indexterm" id="id1431"/><a contenteditable="false" data-primary="mean absolute error (MAE) for time series" data-type="indexterm" id="id1432"/> to measure prediction accuracy, but we’ll concentrate on two of them: the <em>mean squared error</em> (MSE) and <em>mean absolute error</em> (MAE).</p>
          <p>With MSE, you simply take the difference between the predicted value and the actual value at time <em>t</em>, square it (to remove negatives), and then find the average of all of them.</p>
          <p>With MAE, you calculate the difference between the predicted value and the actual value at time <em>t</em>, take its absolute value to remove negatives (instead of squaring), and find the average of all of them.</p>
          <p class="pagebreak-before">For the naive forecast you just created based on our synthetic time series, you can get the MSE and MAE like this:</p>
          <pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">torch</code>
<code class="kn">import</code> <code class="nn">torch.nn.functional</code> <code class="k">as</code> <code class="nn">F</code>
 
<code class="c1"># Mean Squared Error</code>
<code class="n">mse</code> <code class="o">=</code> <code class="n">F</code><code class="o">.</code><code class="n">mse_loss</code><code class="p">(</code><code class="n">torch</code><code class="o">.</code><code class="n">tensor</code><code class="p">(</code><code class="n">x_valid</code><code class="p">),</code> <code class="n">torch</code><code class="o">.</code><code class="n">tensor</code><code class="p">(</code><code class="n">naive_forecast</code><code class="p">))</code><code class="o">.</code><code class="n">item</code><code class="p">()</code>
<code class="nb">print</code><code class="p">(</code><code class="n">mse</code><code class="p">)</code>
 
<code class="c1"># Mean Absolute Error</code>
<code class="n">mae</code> <code class="o">=</code> <code class="n">F</code><code class="o">.</code><code class="n">l1_loss</code><code class="p">(</code><code class="n">torch</code><code class="o">.</code><code class="n">tensor</code><code class="p">(</code><code class="n">x_valid</code><code class="p">),</code> <code class="n">torch</code><code class="o">.</code><code class="n">tensor</code><code class="p">(</code><code class="n">naive_forecast</code><code class="p">))</code><code class="o">.</code><code class="n">item</code><code class="p">()</code>
<code class="nb">print</code><code class="p">(</code><code class="n">mae</code><code class="p">)</code>
 </pre>
          <p>I got an MSE of 76.47 and an MAE of 6.89. As with any prediction, if you can reduce the error, you can increase the accuracy of your predictions. We’ll look at how to do that next.</p>
        </div></section>
        <section data-pdf-bookmark="Less Naive Predictions: Using a Moving Average for Prediction" data-type="sect2"><div class="sect2" id="ch09_less_naive_predictions_using_a_moving_average_for_1748549698135346">
          <h2>Less Naive Predictions: Using a Moving Average for Prediction</h2>
          <p>The previous naive prediction<a contenteditable="false" data-primary="time series data" data-secondary="predicting" data-tertiary="moving average as less naive" data-type="indexterm" id="id1433"/><a contenteditable="false" data-primary="moving average for time series prediction" data-type="indexterm" id="id1434"/> took the value at time <em>t</em> – 1 to be the forecasted value at time <em>t</em>. Using a <em>moving average</em> is similar, but instead of just taking the value from <em>t</em> – 1, it takes a group of values (say, 30), averages them out, and sets that average value to be the predicted value at time <em>t</em>. Here’s the code:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="k">def</code> <code class="nf">moving_average_forecast</code><code class="p">(</code><code class="n">series</code><code class="p">,</code> <code class="n">window_size</code><code class="p">):</code>
  <code class="sd">"""Forecasts the mean of the last few values.</code>
<code class="sd">     If window_size=1, then this is equivalent to naive forecast"""</code>
  <code class="n">forecast</code> <code class="o">=</code> <code class="p">[]</code>
  <code class="k">for</code> <code class="n">time</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">series</code><code class="p">)</code> <code class="err">–</code> <code class="n">window_size</code><code class="p">):</code>
    <code class="n">forecast</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">series</code><code class="p">[</code><code class="n">time</code><code class="p">:</code><code class="n">time</code> <code class="o">+</code> <code class="n">window_size</code><code class="p">]</code><code class="o">.</code><code class="n">mean</code><code class="p">())</code>
  <code class="k">return</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="n">forecast</code><code class="p">)</code>

<code class="n">moving_avg</code> <code class="o">=</code> <code class="n">moving_average_forecast</code><code class="p">(</code><code class="n">series</code><code class="p">,</code> <code class="mi">30</code><code class="p">)[</code><code class="n">split_time</code> <code class="o">-</code> <code class="mi">30</code><code class="p">:]</code>

<code class="n">plt</code><code class="o">.</code><code class="n">figure</code><code class="p">(</code><code class="n">figsize</code><code class="o">=</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="mi">6</code><code class="p">))</code>
<code class="n">plot_series</code><code class="p">(</code><code class="n">time_valid</code><code class="p">,</code> <code class="n">x_valid</code><code class="p">)</code>
<code class="n">plot_series</code><code class="p">(</code><code class="n">time_valid</code><code class="p">,</code> <code class="n">moving_avg</code><code class="p">)</code>
</pre>
          <p><a data-type="xref" href="#ch09_figure_8_1748549698128303">Figure 9-8</a> shows the plot of the moving average against the data.</p>
          <figure><div class="figure" id="ch09_figure_8_1748549698128303">
            <img alt="" src="assets/aiml_0908.png"/>
            <h6><span class="label">Figure 9-8. </span>Plotting the moving average</h6>
          </div></figure>
          <p>When I plotted this time series, I got an MSE and MAE of 49 and 5.5, respectively, so it definitely improved the prediction a little. But this approach doesn’t take into account the trend or the seasonality, so we may be able to improve it further with a little analysis.</p>
        </div></section>
        <section data-pdf-bookmark="Improving the Moving-Average Analysis" data-type="sect2"><div class="sect2" id="ch09_improving_the_moving_average_analysis_1748549698135429">
          <h2>Improving the Moving-Average Analysis</h2>
          <p>Given that the seasonality<a contenteditable="false" data-primary="time series data" data-secondary="predicting" data-tertiary="moving average improved" data-type="indexterm" id="id1435"/><a contenteditable="false" data-primary="moving average for time series prediction" data-secondary="differencing to improve" data-type="indexterm" id="id1436"/><a contenteditable="false" data-primary="differencing" data-type="indexterm" id="id1437"/> in this time series is 365 days, you can smooth out the trend and seasonality by using a technique called <em>differencing</em>, which just subtracts the value at <em>t</em> – 365 from the value at <em>t</em>. This will flatten out the diagram. Here’s the code:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">diff_series</code> <code class="o">=</code> <code class="p">(</code><code class="n">series</code><code class="p">[</code><code class="mi">365</code><code class="p">:]</code> <code class="err">–</code> <code class="n">series</code><code class="p">[:</code><code class="o">-</code><code class="mi">365</code><code class="p">])</code>
<code class="n">diff_time</code> <code class="o">=</code> <code class="n">time</code><code class="p">[</code><code class="mi">365</code><code class="p">:]</code>
</pre>

<p>You can now calculate a moving average of <em>these</em> values and add back in the past <span class="keep-together">values:</span></p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">diff_moving_avg</code> <code class="o">=</code> 
    <code class="n">moving_average_forecast</code><code class="p">(</code><code class="n">diff_series</code><code class="p">,</code> <code class="mi">50</code><code class="p">)[</code><code class="n">split_time</code> <code class="err">–</code> <code class="mi">365</code> <code class="err">–</code> <code class="mi">50</code><code class="p">:]</code>

<code class="n">diff_moving_avg_plus_smooth_past</code> <code class="o">=</code> 
    <code class="n">moving_average_forecast</code><code class="p">(</code><code class="n">series</code><code class="p">[</code><code class="n">split_time</code> <code class="err">–</code> <code class="mi">370</code><code class="p">:</code><code class="err">–</code><code class="mi">360</code><code class="p">],</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> 
    <code class="n">diff_moving_avg</code>
</pre>

          <p>When you plot this (see <a data-type="xref" href="#ch09_figure_9_1748549698128324">Figure 9-9</a>), you can already see an improvement in the predicted values: the trend line is very close to the actual values, albeit with the noise smoothed out. Seasonality seems to work, as does the trend.</p>
          <figure><div class="figure" id="ch09_figure_9_1748549698128324">
            <img alt="" src="assets/aiml_0909.png"/>
            <h6><span class="label">Figure 9-9. </span>Improved moving average</h6>
          </div></figure>
          <p>This impression is confirmed when you calculate the MSE and MAE—in this case, I got 40.9 and 5.13, respectively, showing a clear improvement in the predictions.</p>
        </div></section>
      </div></section>
      <section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="ch09_summary_1748549698135496">
        <h1>Summary</h1>
        <p>This chapter introduced time series data and some of the common attributes of time series. You created a synthetic time series and saw how you can start making naive predictions on it, and from these predictions, you established baseline measurements using MSE and MAE. Synthetic data is also a really cool area for exploration—and hopefully, some of the techniques you explored in this chapter will be useful on your learning journey.</p>
        <p>This chapter was a nice break from PyTorch and ML, but in the next chapter, you’ll go back to using ML to see if you can improve on your predictions!</p>
      </div></section>
    </div></section></body></html>