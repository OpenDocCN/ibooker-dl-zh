["```py\nimport pandas as pd\nfrom pulp import *\n\nIngredients = [\"Limestone\", \"Corn\", \"Soybean meal\"]                        ①\n\nPrice = {\"Limestone\": 10.0, \"Corn\": 30.5, \"Soybean meal\": 90.0,}           ②\nCalcium = {\"Limestone\": 0.38, \"Corn\": 0.001, \"Soybean meal\": 0.002,}       ③\nProtein = {\"Limestone\": 0.0, \"Corn\": 0.09, \"Soybean meal\": 0.50,}          ④\nFiber = {\"Limestone\": 0.0, \"Corn\": 0.02, \"Soybean meal\": 0.08,} \n\nmodel = LpProblem(\"Animal_Feed_Mix_Problem\", LpMinimize)                   ⑤\n\ningredient_vars = LpVariable.dicts(\"Ingr\", Ingredients, 0)                 ⑥\n\nmodel += (lpSum([Price[i] * ingredient_vars[i] for i in\n➥ Ingredients]),\"Total Cost of Ingredients per kg\",)                      ⑦\n\nmodel += (lpSum([Calcium[i] * ingredient_vars[i] for i in Ingredients]) >=\n➥ 0.008, \"Minimum calcium\",)                                              ⑧\nmodel += (lpSum([Calcium[i] * ingredient_vars[i] for i in Ingredients]) <= ⑧\n➥ 0.012, \"Maximum calcium\",)                                              ⑧\nmodel += (lpSum([Protein[i] * ingredient_vars[i] for i in Ingredients])    ⑧\n➥ >=0.22, \"Minimum protein\",)                                             ⑧\nmodel += (lpSum([Fiber[i] * ingredient_vars[i] for i in Ingredients])      ⑧\n➥ <=0.05, \"MMaximum fiber\",)                                              ⑧\nmodel += lpSum([ingredient_vars[i] for i in Ingredients]) == 1,            ⑧\n➥ \"Conservation\"                                                          ⑧\n\nmodel.solve()                                                              ⑨\n\nfor v in model.variables():                                                ⑩\n    print(v.name, '=', round(v.varValue,2)*100, '%')                       ⑩\n                                                                           ⑩\nprint('Total cost of the mixture per kg = ', round(value(model.objective), ⑩\n➥ 2), '$')                                                                ⑩\n```", "```py\ndf = pd.read_csv('Blending_problem_data.csv')                              ①\n\ndata = df.to_dict()                                                        ②\n\nmodel = LpProblem(\"Animal_Feed_Mix_Problem\", LpMinimize)                   ③\n\ningredient_vars = LpVariable.dicts(\"Ingr\", data.get('Ingredients'), 0)     ④\n\nmodel += (lpSum([data.get('Price')[i] * ingredient_vars[i] for i in\n➥ data.get('Ingredients')]),\"Total Cost of Ingredients per kg\",)          ⑤\n\nmodel += lpSum([ingredient_vars[i] for i in data.get('Ingredients')]) == 1,\n➥ \"Conservation\"                                                          ⑥\nmodel += (lpSum([data.get('Calcium')[i] * ingredient_vars[i] for i in\n➥ data.get('Ingredients')]) >= 0.008, \"Minimum calcium\",)                 ⑥\nmodel += (lpSum([data.get('Calcium')[i] * ingredient_vars[i] for i in\n➥ data.get('Ingredients')]) <= 0.012, \"Maximum calcium\",)                 ⑥\nmodel += (lpSum([data.get('Protein')[i] * ingredient_vars[i] for i in\n➥ data.get('Ingredients')]) >=0.22, \"Minimum protein\",)                   ⑥\nmodel += (lpSum([data.get('Fiber')[i] * ingredient_vars[i] for i in\n➥ data.get('Ingredients')]) <=0.05, \"MMaximum fiber\",)                    ⑥\n\nmodel.solve()                                                              ⑦\n\nfor v in model.variables():                                                ⑧\n    print(v.name, '=', round(v.varValue,2)*100, '%')                       ⑧\n                                                                           ⑧\nprint('Total cost of the mixture per kg = ', round(value(model.objective),\n➥ 2), '$')                                                                ⑧\n```", "```py\nIngr_Corn = 65.0 %\nIngr_Limestone = 3.0 %\nIngr_Soybean_meal = 32.0 %\nTotal cost of the mixture per kg = 49.16 $\n```", "```py\nfrom optalgotools.algorithms import SimulatedAnnealing\nfrom optalgotools.problems import TSP\npairwise_distances = distances\n\ntsp_US = TSP(dists=pairwise_distances, gen_method='insert',\n➥ init_method='greedy')\nsa=SimulatedAnnealing(max_iter=10000, max_iter_per_temp=10000,\n➥ initial_temp=10000000, final_temp=0.0001,\n➥ cooling_schedule='geometric', cooling_alpha=0.9, debug=1)\n\nsa.run(tsp_US)\nprint(sa.s_best)\n```", "```py\n#!pip install simanneal \nimport math\nimport random\nfrom simanneal import Annealer\n\nclass TravellingSalesmanProblem(Annealer):                              ①\n    def __init__(self, state, distance_matrix):\n        self.distance_matrix = distance_matrix\n        super(TravellingSalesmanProblem, self).__init__(state)\n\n    def move(self):                                                     ②\n        initial_energy = self.energy() \n        a = random.randint(0, len(self.state) - 1)\n        b = random.randint(0, len(self.state) - 1)\n        self.state[a], self.state[b] = self.state[b], self.state[a]\n        return self.energy() - initial_energy\n\n    def energy(self):                                                   ③\n        e = 0\n        for i in range(len(self.state)):\n            e += self.distance_matrix[self.state[i-1]][self.state[i]]\n        return e\n\ninit_state = list(cities)                                               ④\nrandom.shuffle(init_state)                                              ④\n\ntsp = TravellingSalesmanProblem(init_state, distance_matrix)\ntsp.set_schedule(tsp.auto(minutes=0.2))\ntsp.copy_strategy = \"slice\"\nstate, e = tsp.anneal()\n\nwhile state[0] != 'New York City':                                      ⑤\n    state = state[1:] + state[:1]  \n\nprint(\"%i mile route:\" % e)                                             ⑥\nprint(\" ➞  \".join(state))                                              ⑥\n```", "```py\nfig, ax = plt.subplots(figsize=(15,10))\n\nreversed_dict = {key: value[::-1] for key, value in cities.items()}        ①\n\nH = G.copy()                                                               ②\n\nedge_list = list(nx.utils.pairwise(state))\n\nnx.draw_networkx_edges(H, pos=reversed_dict, edge_color=\"gray\", width=0.5) ③\n\nax=nx.draw_networkx(H, pos=reversed_dict, with_labels=True, edgelist=edge_list, \nedge_color=\"red\", node_size=200, width=3,)                                 ④\n\nplt.show()                                                                 ⑤\n```", "```py\nfrom optalgotools.problems import SHEETS                                ①\nfrom optalgotools.algorithms import TabuSearch                          ②\nimport matplotlib.pyplot as plt\n\niphone_case = SHEETS(init_method='greedy')                              ③\n\nts = TabuSearch(max_iter=1000, tabu_tenure=10, neighbor_size=7,\n➥ use_aspiration=True, aspiration_limit=3, use_longterm=False, debug=1,\n➥ maximize=True, penalize=True)                                        ④\n\nts.init_ts(iphone_case)                                                 ⑤\nts.val_cur\n\nts.run(iphone_case, repetition=1)                                       ⑥\nts.val_allbest\n```", "```py\ntasks = pd.DataFrame(columns=['Task', 'Duration'])                           ①\ntasks= pd.read_csv(\"https://raw.githubusercontent.com/Optimization-          ①\nAlgorithms-Book/Code-Listings/main/Appendix%20B/data/ALBP/ALB_TS_DATA2.txt\", ①\nsep =\",\")                                                                    ①\nPrec= pd.read_csv(\"https://raw.githubusercontent.com/Optimization-\n➥Algorithms-Book/Code-                                                      ①\n➥Listings/main/Appendix%20B/data/ALBP/ALB_TS_PRECEDENCE2.txt\", sep =\",\")    ①\nPrec.columns=['TASK', 'IMMEDIATE_PRECEDESSOR']                               ①\n\nCycle_time = 10                                                              ②\n\ntenure = 3\nmax_itr=100\n\nsolution = Initial_Solution(len(tasks))                                      ③\nsoln_init = Make_Solution_Feasible(solution, Prec)                           ④\n\nsol_best, SI_best=tabu_search(max_itr, soln_init, SI_init, tenure, WS,\n➥ tasks, Prec_Matrix, Cycle_time)                                           ⑤\n\nSmoothing_index(sol_best, WS, tasks, Cycle_time, True)                       ⑥\n\nplt = Make_Solution_to_plot(sol_best, WS, tasks, Cycle_time)                 ⑦\nplt.show()                                                                   ⑦\n```", "```py\nThe Smoothing Index value for ['T2', 'T7', 'T6', 'T1', 'T3', 'T4', 'T8',\n➥ 'T9', 'T5'] solution sequence is: 1.0801234497346432 \nThe number of workstations for ['T2', 'T7', 'T6', 'T1', 'T3', 'T4', 'T8',\n➥ 'T9', 'T5'] solution sequence is: 6 \nThe workloads of workstation for ['T2', 'T7', 'T6', 'T1', 'T3', 'T4', 'T8',\n➥ 'T9', 'T5'] solution sequence are: [7\\. 6\\. 5\\. 7\\. 6\\. 6.]\n1.0801234497346432\n```", "```py\nimport random\nimport math\n\nPOPULATION_SIZE = 100\nGENOME_LENGTH = 30\nMUTATION_RATE = 0.1\nCROSSOVER_RATE = 0.8\nGENERATIONS = 100\n\na = 20\nb = 0.2\nc = 2 * math.pi\n```", "```py\ndef decode(genome):\n    x = []\n    for i in range(0, GENOME_LENGTH, 5):\n        binary_string = \"\".join([str(bit) for bit in genome[i:i+5]])\n        x.append(int(binary_string, 2) / 31 * 32 - 16)\n    return x\n```", "```py\n def fitness(genome):\n    x = decode(genome)\n    term1 = -a * math.exp(-b * math.sqrt(sum([(xi ** 2) for xi in x]) /\n➥ len(x)))\n    term2 = -math.exp(sum([math.cos(c * xi) for xi in x]) / len(x))\n    return term1 + term2 + a + math.exp(1)\n```", "```py\ndef crossover(parent1, parent2):\n    child1 = []\n    child2 = []\n    for i in range(GENOME_LENGTH):\n        if random.random() < CROSSOVER_RATE:\n            child1.append(parent2[i])\n            child2.append(parent1[i])\n        else:\n            child1.append(parent1[i])\n            child2.append(parent2[i])\n    return child1, child2\n```", "```py\ndef mutate(genome):\n    for i in range(GENOME_LENGTH):\n        if random.random() < MUTATION_RATE:\n            genome[i] = 1 - genome[i]\n```", "```py\npopulation = [[random.randint(0, 1) for _ in range(GENOME_LENGTH)] for _ in\n➥ range(POPULATION_SIZE)]\n```", "```py\nfor generation in range(GENERATIONS):\n    fitness_scores = [(genome, fitness(genome)) for genome in population] ①\n    fitness_scores.sort(key=lambda x: x[1])\n\n    print(f\"Generation {generation}: Best fitness =\n➥ {fitness_scores[0][1]}\")                                               ②\n\n    parents = [fitness_scores[i][0] for i in range(POPULATION_SIZE // 2)] ③\n\n    next_generation = []                                                  ④\n    for i in range(POPULATION_SIZE // 2):                                 ④\n        parent1 = random.choice(parents)                                  ④\n        parent2 = random.choice(parents)                                  ④\n        child1, child2 = crossover(parent1, parent2)                      ④\n        mutate(child1)                                                    ④\n        mutate(child2)                                                    ④\n        next_generation.append(child1)                                    ④\n        next_generation.append(child2)                                    ④\n\n    population = next_generation                                          ⑤\n```", "```py\nfitness_scores = [(genome, fitness(genome)) for genome in population]\nfitness_scores.sort(key=lambda x: x[1])\nprint(f\"Generation {GENERATIONS}: Best fitness = {fitness_scores[0][1]}\")\n```", "```py\nprint(f\"Best genome = {fitness_scores[0][0]}\")\nprint(f\"Best genome decoded = {decode(fitness_scores[0][0])}\")\nprint(f\"Decision variables in real values = {decode(fitness_scores[0][0])}\")\n```", "```py\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.problems import get_problem\nfrom pymoo.optimize import minimize\n\nproblem = get_problem(\"ackley\", n_var=6) \n\nalgorithm = GA(\n    pop_size=100,\n    eliminate_duplicates=True)\n\nres = minimize(problem,\n               algorithm,\n               seed=1,\n               verbose=False)\n\nprint(\"Best solution found: \\nX = %s\\nF = %s\" % (res.X, res.F))\n```", "```py\nBest solution found: \nX = [ 0.00145857 -0.00011553 0.00033902 -0.00169267 -0.0005825  -0.00547546]\nF = [0.01003609]\n```", "```py\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nfrom pymoo.core.problem import ElementwiseProblem\nfrom pymoo.algorithms.moo.nsga2 import NSGA2\nfrom pymoo.operators.crossover.sbx import SBX\nfrom pymoo.operators.mutation.pm import PolynomialMutation\nfrom pymoo.operators.repair.rounding import RoundingRepair\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling\n\nclass FacilityProblem(ElementwiseProblem):\n\n    def __init__(self):\n        super().__init__(n_var=2,\n                         n_obj=2,\n                         n_ieq_constr=2,\n                         xl=np.array([0,0]),\n                         xu=np.array([5,5]))\n\n    def _evaluate(self, x, out, *args, **kwargs):\n        f1 = math.sqrt((x[0]-2)**2 + (x[1]-1)**2)\n        f2 = -math.sqrt((x[0]-3)**2 + (x[1]-4)**2) \n\n        g1 = x[0]+2*x[1]-6                        ①\n        g2 = 2*x[0]-x[1]-2                        ②\n\n        out[\"F\"] = [f1, f2]\n        out[\"G\"] = [g1, g2]\n\nproblem = FacilityProblem()\n\nalgorithm = NSGA2(\n    pop_size=50,\n    sampling=FloatRandomSampling(),\n    crossover=SBX(prob=0.8),\n    mutation = PolynomialMutation(prob=0.6, repair=RoundingRepair()), \n    eliminate_duplicates=True\n)\n\nfrom pymoo.termination import get_termination\n\ntermination = get_termination(\"n_gen\", 50)\n\nfrom pymoo.optimize import minimize\n\nres = minimize(problem,\n               algorithm,\n               termination,\n               seed=1,\n               save_history=True,\n               verbose=False)\n\nX = res.X\nF = res.F\n```", "```py\nimport numpy as np\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.operators.crossover.sbx import SBX\nfrom pymoo.operators.mutation.pm import PolynomialMutation\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling\nfrom pymoo.core.problem import Problem\nfrom pymoo.optimize import minimize\n\nclass AllOnes(Problem):\n    def __init__(self, n_var):\n        super().__init__(n_var=n_var, n_obj=1, n_constr=0, xl=0, xu=1,\n➥ vtype=int)\n\n    def _evaluate(self, x, out, *args, **kwargs):\n        out[\"F\"] = -np.sum(x, axis=1)\n\nproblem = AllOnes(n_var=10)\nalgorithm = GA(\n    pop_size=100,\n    sampling=FloatRandomSampling(),\n    crossover=SBX(prob=1.0, eta=30, n_offsprings=2),\n    mutation=PolynomialMutation(prob=1.0),\n    eliminate_duplicates=True\n)\n\nres = minimize(problem, algorithm, ('n_gen', 100), seed=1, verbose=True)\n\nprint(\"Sum of the ones in the solution:\", -res.F)\nprint(\"Solution: \", res.X)\n```", "```py\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.operators.crossover.ux import UniformCrossover\nfrom pymoo.operators.mutation.pm import PolynomialMutation\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling\nfrom pymoo.termination.default import DefaultSingleObjectiveTermination\nfrom pymoo.core.problem import Problem\nfrom pymoo.optimize import minimize\n\nclass CargoBike(Problem):                                                   ①\n    def __init__(self, weights, efficiency, capacity):\n        super().__init__(n_var=len(weights), n_obj=1, n_constr=1, xl=0,\n➥ xu=1, vtype=bool)\n        self.weights = weights\n        self.efficiency = efficiency\n        self.capacity = capacity\n\n    def _evaluate(self, x, out, *args, **kwargs):\n        x = np.round(x)  # Ensure X is binary\n        total_weight = np.sum(self.weights * x, axis=1)\n        total_profit = np.sum(self.efficiency * x, axis=1)\n        out[\"F\"] = -total_profit[:, None]\n        out[\"G\"] = np.where(total_weight <= self.capacity, 0, total_weight\n➥ - self.capacity)[:, None]\n\nweights = np.array([14.6, 20, 8.5, 10, 13, 9.6, 4.9, 16.5, 8.77, 7.8])      ②\nprofits = np.array([14.54, 15.26, 5.8, 12.12, 8.2, 7.4, 10.3, 13.5, 6.6,\n➥ 20.9])                                                                   ②\nefficiency = np.array([1.00, 0.76, 0.68, 1.21, 0.63, 0.77, 2.1, 0.82, 0.75,\n➥ 2.68])                                                                   ②\ncapacity = 100                                                              ②\ndf=pd.DataFrame({'Weight (kg)':weights,'Profit ($)':profits,'Efficiency ($/ ②\nKg)':efficiency})                                                           ②\n\nproblem = CargoBike(weights, efficiency, capacity)                          ③\n\nalgorithm = GA(\n    pop_size=200,\n    sampling=FloatRandomSampling(),\n    crossover=UniformCrossover(prob=1.0),\n    mutation=PolynomialMutation(prob=0.5),\n    eliminate_duplicates=True\n)                                                                           ④\n\ntermination = DefaultSingleObjectiveTermination()\n\nres = minimize(problem, algorithm, termination, verbose=True)               ⑤\n\nprint(f\"Best solution found: {res.X}\")                                      ⑥\nprint(f\"Best objective value: {-res.F[0]}\")                                 ⑥\n\nres_bool=np.round(res.X)\nselected_items = df.loc[res_bool.astype(bool), :]\n\nfig, ax1 = plt.subplots()\nax1.bar(1+selected_items.index, selected_items['Efficiency ($/Kg)']) \nax1.set_ylabel('Efficiency ($/Kg)')\nax1.set_ylim(0, 5)\nax1.legend(['Efficiency ($/Kg)'], loc=\"upper left\")\n\nax2 = ax1.twinx()\nax2.bar(1+selected_items.index, selected_items['Weight (kg)'], width=0.5,\n➥ alpha=0.5, color='orange')\nax2.grid(False)\nax2.set_ylabel('Weight (kg)')\nax2.set_ylim(0, 30)\nax2.legend(['Weight (kg)'], loc=\"upper right\")\nplt.show()                                                                  ⑦\n```", "```py\nimport numpy as np\n\nBLOCKS = np.arange(0, 17)                                              ①\nLEVEL23 = np.array([8, 9, 10, 11, 12, 13, 14, 15, 16, 17])             ②\nCOST = np.array([100, 100, 100, 100, 100, 100, 100, 100,\n                 200, 200, 200, 200, 200, 200, \n                 1000, 1000, 1000, 1000])                              ③\n\nVALUE = np.array([200, 0, 0, 0, 0, 0, 300, 0, \n                  0, 500, 0, 200, 0, 0, \n                  0, 0, 1000, 0])                                      ④\n\nPrecedence = np.array([[0,1, 2],\n                [1, 2, 3],\n                [2, 3, 4],\n                [3, 4, 5],\n                [4, 5, 6],\n                [5, 6, 7],\n                [8, 9, 10],\n                [9, 10, 11],\n                [10, 11, 12],\n                [11, 12, 13]])                                         ⑤\n```", "```py\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nG = nx.DiGraph()                                                        ①\n\nG.add_nodes_from(BLOCKS)                                                ②\n\nfor b, arc in zip(LEVEL23, Precedence):                                 ③\n    for predecessor in arc:                                             ③\n        G.add_edge(predecessor, b)                                      ③\n\npos = nx.spring_layout(G)                                               ④\npos.update({0: (0, 0), 1: (0, 1), 2: (0, 2), 3: (1, 0), 4: (1, 1), 5: (1,\n➥ 2), 6: (2, 0), 7: (2, 1), \n            8: (2, 2), 9: (3, 0), 10: (3, 1), 11: (3, 2), 12: (4, 0), 13:\n➥ (4, 1), \n            14: (4, 2), 15: (5, 0), 16: (5, 1), 17: (5, 2)})            ⑤\n\nplt.figure(figsize=(10, 5))                                             ⑥\nnx.draw(G, pos, with_labels=True, node_size=1500, node_color='skyblue', ⑥\n➥ font_size=12, font_weight='bold')                                    ⑥\nplt.title(\"Precedence graph for extraction of blocks in Level 2 and 3\") ⑥\nplt.show()                                                              ⑥\n```", "```py\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.operators.crossover.pntx import PointCrossover\nfrom pymoo.operators.mutation.pm import PolynomialMutation\nfrom pymoo.operators.repair.rounding import RoundingRepair\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling\nfrom pymoo.core.problem import Problem\nfrom pymoo.optimize import minimize\n\nclass OpencastMiningProblem(Problem):\n    def __init__(self):\n        super().__init__(n_var=18, n_obj=1, n_constr=len(LEVEL23), xl=0,\n➥ xu=1)\n\n    def _evaluate(self, X, out, *args, **kwargs):\n        X = np.round(X)\n        profits = np.sum((VALUE - COST) * X, axis=1)\n\n        constraints = np.zeros((X.shape[0], len(LEVEL23)))\n        for i in range(X.shape[0]):\n            for j, b in enumerate(LEVEL23):\n                constraints[i, j] = min(X[i, Precedence[j]-1]) - X[i, b-1]\n\n        out[\"F\"] = profits.reshape(-1, 1)\n        out[\"G\"] = constraints\n```", "```py\nproblem = OpencastMiningProblem()\nalgorithm = GA(\n    pop_size=50,\n    sampling=FloatRandomSampling(),\n    crossover=PointCrossover(prob=0.8, n_points=2),\n    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),\n    eliminate_duplicates=True\n)\n\nres = minimize(problem, algorithm, ('n_gen', 50), seed=1, verbose=True)\n\nprint(\"Best solution found:\\nX =\", res.X)\nprint(\"Objective value =\", -res.F[0])\n```", "```py\nBest solution found:\nX = [0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 0 1]\nObjective value = 4300.0\n```", "```py\nimport numpy as np\nfrom pyswarms.single import GlobalBestPSO\nimport pyswarms as ps\n\ndef objective_function(pos):                                              ①\n    r = np.array([6, 6.5, 8])\n    x0 = np.array([1, 3, 7])\n    y0 = np.array([5, 1, 7])\n\n    x = pos[:, 0]\n    y = pos[:, 1]\n\n    f = np.sum(r - np.sqrt((x0 - x.reshape(-1, 1)) ** 2 + (y0 - y.reshape(-\n➥1, 1)) ** 2), axis=1)\n    return f\n\noptions = {\"c1\": 0.5, \"c2\": 0.5, \"w\": 0.79}                               ②\nbounds = (np.array([0, 0]), np.array([8, 8]))                             ②\n\noptimizer = GlobalBestPSO(n_particles=100, dimensions=2, options=options,\n➥ bounds=bounds)                                                         ③\nbest_cost, best_position = optimizer.optimize(objective_function,\n➥ iters=1000)                                                            ③\n\nprint(\"Best position:\", np.round(best_position,2))                        ④\nprint(\"Best cost:\", np.round(best_cost,3))                                ④\n```", "```py\nimport numpy as np                                                        ①\nimport pyswarms as ps                                                     ①\n\ndef fitness_function(x):                                                  ②\n    n_particles = x.shape[0]                                              ②\n    profit=0                                                              ②\n    for i in range(n_particles):                                          ②\n        profit=-(2*x[i][0] + 3*x[i][1] - (x[i][0] + 1.5*x[i][1]))         ②\n    return profit                                                         ②\n\nnum_particles = 10                                                        ③\nnum_iterations = 100                                                      ③\n\nlb = np.array([50, 75])                                                   ④\nub = np.array([300, 450])                                                 ④\nbounds = (lb, ub)                                                         ④\n\noptions={'w':0.79, 'c1': 1.5, 'c2': 1.3}                                  ⑤\n\noptimizer = ps.single.GlobalBestPSO(n_particles=num_particles,\n➥ dimensions=2, options=options, bounds=bounds)                          ⑥\n\nbest_cost, best_pos = optimizer.optimize(fitness_function,\n➥ iters=num_iterations)                                                  ⑦\n\nbest_pos=np.asarray(best_pos, dtype = 'int') \nprint('###############################################') \nprint('Total profit: ', round(-best_cost, 2), '$') \nprint('Optimal number of small coffees to make: ',best_pos[0]) \nprint('Optimal number of large coffees to make: ', best_pos[1]) \n```", "```py\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pyswarms as ps\n\nfull_time_rates = np.array([30, 35, 40, 45, 50])                            ①\novertime_rates = full_time_rates * 1.5                                      ①\npart_time_rates = np.array([25, 27, 29, 31, 33])                            ①\n\ndef objective_function(x): \n    x1 = x[:, :len(full_time_rates)]                                        ②\n    x2 = x[:, len(full_time_rates):2 * len(full_time_rates)]                ②\n    x3 = x[:, 2 * len(full_time_rates):]                                    ②\n\n    total_cost = np.sum(x1 * full_time_rates) + np.sum(x2 * overtime_rates)\n➥ + np.sum(x3 * part_time_rates)                                           ③\n\n    penalty_x1_x2 = np.maximum(0, 4 - np.sum(x1) - np.sum(x2)) * 10000\n    penalty_x3 = np.maximum(0, 2 - np.sum(x3)) * 10000                      ④\n                                                                            ④\n    total_cost_with_penalty = total_cost + penalty_x1_x2 + penalty_x3       ④\n\n    return total_cost_with_penalty\n\nmin_bound = np.zeros(3 * len(full_time_rates))                              ⑤\nmax_bound = np.full(3 * len(full_time_rates), 10)                           ⑤\nbounds = (min_bound, max_bound)                                             ⑤\noptions = {'w': 0.74, 'c1': 2.05, 'c2': 2.05, 'k': 5, 'p': 1}               ⑥\noptimizer = ps.single.LocalBestPSO(n_particles=30, dimensions=3 *\n➥ len(full_time_rates), options=options, bounds=bounds)                    ⑦\ncost, pos = optimizer.optimize(objective_function, iters=100, verbose=True) ⑧\noptimal_x1 = pos[:len(full_time_rates)]                                     ⑨\noptimal_x2 = pos[len(full_time_rates):2 * len(full_time_rates)]             ⑨\noptimal_x3 = pos[2 * len(full_time_rates):]                                 ⑨\n```", "```py\nimport numpy as np\nimport random\nfrom pymoo.algorithms.soo.nonconvex.pso import PSO\nfrom pymoo.optimize import minimize\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.operators.crossover.pntx import PointCrossover\nfrom pymoo.operators.mutation.pm import PolynomialMutation\nfrom pymoo.operators.repair.rounding import RoundingRepair\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling\nfrom pymoo.core.problem import Problem\nfrom geopy.geocoders import Nominatim\nfrom geopy.distance import geodesic\nimport folium\n```", "```py\nsupply_schools = [1, 6, 7, 8]                             ①\ndemand_schools = [2, 3, 4, 5]                             ②\namount_supply = [20, 30, 15, 35]                          ③\namount_demand = [5, 45, 10, 40]                           ④\nn_var=len(supply_schools)*len(demand_schools)             ⑤\n```", "```py\nnp.random.seed(0)                                                        ①\n\ndef generate_random(number, center_point):\n    lat, lon = center_point                                              ②\n    coords = [(random.uniform(lat - 0.01, lat + 0.01), random.uniform(lon -\n➥ 0.01, lon + 0.01)) for _ in range(number)]\n    return coords\n\nsupply_coords = generate_random(len(supply_schools), [location.latitude,\n➥ location.longitude])                                                  ③\ndemand_coords = generate_random(len(demand_schools), [location.latitude,\n➥ location.longitude])                                                  ④\n\ndistances = []                                                           ⑤\nfor supply in supply_coords:                                             ⑤\n    row = []                                                             ⑤\n    for demand in demand_coords:                                         ⑤\n        row.append(geodesic(supply, demand).kilometers)                  ⑤\n    distances.append(row)                                                ⑤\ndistances = np.array(distances)                                          ⑤\n\ncost_matrix=50*distances\n```", "```py\nclass Transportation_problem(Problem):\n    def __init__(self,\n                 cost_matrix, \n                 amount_supply,\n                 amount_demand\n                 ):\n        super().__init__(n_var=n_var,n_constr=1, vtype=int)\n        self.cost_matrix = cost_matrix\n        self.amount_supply = amount_supply\n        self.amount_demand = amount_demand\n        self.xl = np.array(np.zeros(n_var))\n        self.xu = np.repeat(amount_supply, len(amount_demand))\n\n    def _evaluate(self, X, out, *args, **kwargs):\n        loss = np.zeros((X.shape[0], 1))\n        g = np.zeros((X.shape[0], 1))\n        for i in range(len(X)):\n            soln = X[i].reshape(self.cost_matrix.shape)\n            cost_x = X[i].reshape(self.cost_matrix.shape)\n            cost = cost_x * cost_matrix.T\n            cost = cost.sum()\n            loss[i] = cost         \n            total_supply = soln.sum(axis=1)\n            total_demand = soln.sum(axis=0)  \n            print(\"total_supply: \", total_supply)\n            print(\"total_demand: \", total_demand)\n            g[i] =  np.any(total_supply<self.amount_supply) or\n➥ np.any(total_demand<self.amount_demand)\n        out[\"F\"] = loss\n        out[\"G\"] = g\n```", "```py\nproblem = Transportation_problem(cost_matrix,amount_supply,amount_demand) \nalgorithm = PSO(pop_size=100,repair=RoundingRepair()) \n```", "```py\nres = minimize(problem, algorithm, ('n_gen', 150), seed=1, verbose=False) \n```", "```py\nsoln = res.X                                                             ①\n\nsupply_num=len(amount_supply)                                            ②\ndemand_num=len(amount_demand)                                            ③\n\nfor i in range(supply_num):                                              ④\n    print(f\"Supply School({supply_schools[i]}): {' + [CA]'.join(['soln['+str(j)+']' for j in range(i*supply_num,\n➥ (i+1)*supply_num)])} <= {amount_supply[i]} or {' + '.join(map(str,\n➥ soln[i*supply_num:(i+1)*supply_num]))} <= {amount_supply[i]} or\n➥ {sum(soln[i*supply_num:(i+1)*supply_num])} <= {amount_supply[i]}\")\n\nfor j in range(demand_num):                                              ⑤\n    print(f\"Demand School({demand_schools[j]}): {' +\n➥ '.join(['soln['+str(i*demand_num+j)+']' for i in range(demand_num)])}\n➥ >= {amount_demand[j]} or {' + '.join(map(str, [soln[i*4+j] for i in\n➥ range(demand_num)]))} >= {sum(soln[i*demand_num+j] for i in\n➥ range(demand_num))} or {sum(soln[i*demand_num+j] for i in\n➥ range(demand_num))} >= {amount_demand[j]}\") \n\nprint(f\"Shipping cost =  {round(res.F[0], 2)} $\")                        ⑥\n```", "```py\nSupply School(1): soln[0] + soln[1] + soln[2] + soln[3] <= 20 or 1 + 0 + 14 + 5 <= 20 or 20 <= 20\nSupply School(6): soln[4] + soln[5] + soln[6] + soln[7] <= 30 or 0 + 30 + 0 + 0 <= 30 or 30 <= 30\nSupply School(7): soln[8] + soln[9] + soln[10] + soln[11] <= 15 or 0 + 15 + 0 + 0 <= 15 or 15 <= 15\nSupply School(8): soln[12] + soln[13] + soln[14] + soln[15] <= 35 or 4 + 0 + 0 + 35 <= 35 or 39 <= 35\nDemand School(2): soln[0] + soln[4] + soln[8] + soln[12] >= 5 or 1 + 0 + 0 + 4 >= 5 or 5 >= 5\nDemand School(3): soln[1] + soln[5] + soln[9] + soln[13] >= 45 or 0 + 30 + 15 + 0 >= 45 or 45 >= 45\nDemand School(4): soln[2] + soln[6] + soln[10] + soln[14] >= 10 or 14 + 0 + 0 + 0 >= 14 or 14 >= 10\nDemand School(5): soln[3] + soln[7] + soln[11] + soln[15] >= 40 or 5 + 0 + 0 + 35 >= 40 or 40 >= 40\nShipping cost =  3053.94 $\n```", "```py\ndef normalize(lst):                                                  ①\n    s = sum(lst)\n    return list(map(lambda x: (x/s)*10, lst))\n\nsoln_normalized = normalize(soln)                                    ②\n\ncolors = ['cyan', 'brown', 'orange', 'purple']                       ③\n\nm = folium.Map(location=[location.latitude, location.longitude],\n➥ zoom_start=15, scrollWheelZoom=False, dragging=False)             ④\n\nfor i, coord in zip(supply_schools, supply_coords):\n    folium.Marker(location=coord, icon=folium.Icon(icon=\"home\",\n➥ color='red'), popup=f'Supply School {i+1}').add_to(m)             ⑤\n\nfor i, coord in zip(demand_schools, demand_coords):\n    folium.Marker(location=coord, icon=folium.Icon(icon=\"flag\",\n➥ color='blue'), popup=f'Demand School {i+1}').add_to(m)            ⑥\n\nfor i in range(len(supply_schools)):                                 ⑦\n    for j in range(len(demand_schools)):\n        soln_value = soln[i*len(demand_schools) + j]\n        folium.PolyLine(locations=[supply_coords[i], demand_coords[j]],\n➥ color=colors[i % len(colors)],\n➥  weight=5*soln_normalized[i*len(demand_schools) + j],\n➥ popup=folium.Popup(f'# of microscopes: {soln_value}')).add_to(m)\n\nm                                                                    ⑧\n```", "```py\nsupply_schools = [1, 3]     ①\ndemand_schools = [2, 4]     ②\namount_supply = [20, 30]    ③\namount_demand = [5, 45]     ④\n```", "```py\nimport osmnx as ox\nfrom optalgotools.structures import Node\nfrom optalgotools.routing import cost, draw_route\nimport random\nfrom tqdm.notebook import tqdm\nimport matplotlib.pyplot as plt\n\nreference = (43.661667, -79.395)                                         ①\n\nG = ox.graph_from_point(reference, dist=300, clean_periphery=True,\n➥ simplify=True)                                                        ②\n\norigin = (43.664527, -79.392442)                                         ③\ndestination = (43.659659, -79.397669)                                    ④\n\norigin_id = ox.distance.nearest_nodes(G, origin[1], origin[0])           ⑤\ndestination_id = ox.distance.nearest_nodes(G, destination[1],            ⑤\n➥ destination[0])                                                       ⑤\n\norigin_node = Node(graph=G, osmid=origin_id)                             ⑥\ndestination_node = Node(graph=G, osmid=destination_id)                   ⑥\n\nhighlighted = [destination_id, origin_id]\n\nnc = ['red' if node in highlighted else '#336699' for node in G.nodes()] ⑦\nns = [70 if node in highlighted else 8 for node in G.nodes()]            ⑦\nfig, ax = ox.plot_graph(G, node_size=ns, node_color=nc, node_zorder=2)   ⑧\n```", "```py\nalpha = 1                                                                ①\nbeta = 1                                                                 ②\nn = 500                                                                  ③\nQ = 1                                                                    ④\n\npheremone_concentrations = dict()\nknown_routes = dict()\n\npheremone_concentrations = {(u,v):random.uniform(0,0.5) for [u,v] in\n➥ G.edges()}                                                            ⑤\n\ndef pheremone(level, distance, alpha, beta):                             ⑥\n    return level ** alpha * ((1/distance)) ** beta\n```", "```py\nfor ant in tqdm(range(n)):\n    frontier = [origin_node]                                            ①\n    explored = set()\n    route = []\n    found = False\n\n    while frontier and not found:\n        parent = frontier.pop(0)\n        explored.add(parent)\n\n        children = []\n        children_pheremones = []\n        for child in parent.expand():\n            if child == destination_node:\n                found = True\n                route = child.path()\n                continue\n            if child not in explored:\n                children.append(child)\n                children_pheremones.append(\n                    pheremone(\n                        pheremone_concentrations[(parent.osmid,\n➥ child.osmid)],\n                        child.distance,\n                        alpha,\n                        beta,\n                    )\n                )\n\n        if len(children) == 0:\n            continue  \n\n        transition_probability = [\n            children_pheremones[i] / sum(children_pheremones)\n            for i in range(len(children_pheremones))\n        ]\n\n        chosen = random.choices(children, weights=transition_probability,\n➥ k=1)[0]                                                             ②\n\n        children.pop(children.index(chosen))                           ③\n        frontier.extend(children)                                      ③\n\n        frontier.insert(0, chosen)                                     ④\n\n    for u, v in zip(route[:-1], route[1:]):                            ⑤\n        length_of_edge = G[u][v][0]['length']\n        pheremone_concentrations[(u,v)] += Q/length_of_edge\n\n    route = tuple(route)\n    if route in known_routes:                                          ⑥\n        known_routes[route] += 1\n    else:\n        known_routes[route] = 1\n```", "```py\nbest_route = max(known_routes, key=known_routes.get)\ntimes_used = known_routes[best_route]\nroute = list(best_route)\nprint(\"Cost:\", cost(G,route))\nprint(\"Times used:\",times_used)\ndraw_route(G,route)\n```", "```py\nimport random\n\nmd_range = (41.67, 416.67)                                            ①\nnv_range = (1, 200)                                                   ①\ndelta_range = (1400, 2600)                                            ①\nrr_range = (1, 50)                                                    ①\neta_range = (0.70, 0.85)                                              ①\nrho = 1000                                                            ②\n\ndef ro_pump_power(X):                                                 ③\n    md, nv, delta, rr, eta=X\n    return (md ** 2 + 1200 * md * nv * delta) / (nv * rr * 3600 * eta *\n➥ rho)\n\nnum_ants = 100                                                        ④\nnum_iterations = 300                                                  ④\nevaporation_rate = 0.7                                                ④\npheromone_deposit = 1                                                 ④\ninitial_pheromone = 0.25                                              ④\n\npheromone_matrix = [[initial_pheromone] * 5 for _ in range(num_ants)] ⑤\n\nbest_solution = None                                                  ⑥\nbest_power = float('-inf')                                            ⑥\n\nfor _ in range(num_iterations):\n    solutions = []\n    powers = []\n\n    for ant in range(num_ants):                                       ⑦\n        md = random.uniform(md_range[0], md_range[1]) \n        nv = random.uniform(nv_range[0], nv_range[1]) \n        delta = random.uniform(delta_range[0], delta_range[1]) \n        rr = random.uniform(rr_range[0], rr_range[1]) \n        eta = random.uniform(eta_range[0], eta_range[1]) \n\n        soln=(md, nv, delta, rr, eta)                                 ⑧\n        power = ro_pump_power(soln)                                   ⑧\n\n        solutions.append((md, nv, delta, rr, eta))                    ⑨\n        powers.append(power)                                          ⑨\n\n        if power > best_power:                                        ⑩\n            best_solution = (md, nv, delta, rr, eta)\n            best_power = power\n\n    for ant in range(num_ants):                                       ⑪\n        for i in range(5):\n            pheromone_matrix[ant][i] *= evaporation_rate\n            if solutions[ant][i] == best_solution[i]:\n                pheromone_matrix[ant][i] += pheromone_deposit / powers[ant]\n\nprint(\"Optimal Solution:\")                                            ⑫\nprint(\"Md:\", format(best_solution[0], '.2f'))                         ⑫\nprint(\"Nv:\", format(best_solution[1], '.2f'))                         ⑫\nprint(\"Delta:\", format(best_solution[2], '.2f'))                      ⑫\nprint(\"RR:\", format(best_solution[3], '.2f'))                         ⑫\nprint(\"Eta:\", format(best_solution[4], '.2f'))                        ⑫\nprint(\"Optimal HP:\", format(best_power, '.2f'))                       ⑫\n```", "```py\nOptimal Solution:\nMd: 404.10\nNv: 7.39\nDelta: 2536.93\nRR: 1.05\nEta: 0.76\nOptimal HP: 425.75\n```", "```py\nfrom scipy.optimize import minimize                                    ①\n\ndef ro_pump_power(X):                                                  ②\n    md, nv, delta, rr, eta=X\n    return -(md ** 2 + 1200 * md * nv * delta) / (nv * rr * 3600 * eta *\n➥ rho) \n\nbounds = [md_range, nv_range, delta_range, rr_range, eta_range]        ③\nx0=[200, 100, 2000, 25, 0.75]                                          ④\n\nresult = minimize(ro_pump_power, x0, bounds=bounds, method='SLSQP')    ⑤\n\nprint(\"Optimal Solution:\")                                             ⑥\nprint(\"Md:\", format(result.x[0], '.2f'))                               ⑥\nprint(\"Nv:\", format(result.x[1], '.2f'))                               ⑥\nprint(\"Delta:\", format(result.x[2], '.2f'))                            ⑥\nprint(\"RR:\", format(result.x[3], '.2f'))                               ⑥\nprint(\"Eta:\", format(result.x[4], '.2f'))                              ⑥\nprint(\"Optimal HP:\", format(-result.fun, '.2f'))                       ⑥\n```", "```py\nOptimal Solution:\nMd: 416.67\nNv: 99.98\nDelta: 2600.00\nRR: 1.00\nEta: 0.70\nOptimal HP: 515.88\n```", "```py\nimport numpy as np\nimport random\nimport midaco                                                    ①\nfrom geopy.geocoders import Nominatim\nfrom geopy.distance import geodesic\nimport folium\n\nsupply_schools = [1, 3]                                          ②\ndemand_schools = [2, 4]                                          ③\namount_supply = [20, 30]                                         ④\namount_demand = [5, 45]                                          ⑤\nn_var=len(supply_schools)*len(demand_schools)\nn_constr=len(supply_schools)\n```", "```py\ngeolocator = Nominatim(user_agent=\"SupplyDemand\")                 ①\nlocation = geolocator.geocode(\"Toronto, Ontario\")                 ②\n\ndef generate_random(number, center_point):                        ③\n    lat, lon = center_point\n    coords = [(random.uniform(lat - 0.01, lat + 0.01), random.uniform(lon -\n➥ 0.01, lon + 0.01)) for _ in range(number)]\n    return coords\n\nnp.random.seed(0)                                                 ④\n\nsupply_coords = generate_random(len(supply_schools), \n➥ [location.latitude, location.longitude])                       ⑤\ndemand_coords = generate_random(len(demand_schools), \n➥ [location.latitude, location.longitude])                       ⑥\n\ndistances = []                                                    ⑦\nfor supply in supply_coords:                                      ⑦\n    row = []                                                      ⑦\n    for demand in demand_coords:                                  ⑦\n        row.append(geodesic(supply, demand).kilometers)           ⑦\n    distances.append(row)                                         ⑦\ndistances = np.array(distances)                                   ⑦\n\ncost_matrix=50*distances                                          ⑧\n```", "```py\ndef problem_function(x):\n\n    f = [0.0]*1                                                                            ①\n    g = [0.0]*n_constr                                                                     ②\n\n    f[0] = np.sum(np.multiply(cost_matrix.flatten(), x))                                   ③\n\n    soln=np.reshape(x, (len(supply_schools), len(demand_schools)))                         ④\n\n    total_supply = soln.sum(axis=1)\n    total_demand = soln.sum(axis=0)        \n\n    g[0] = (np.all(total_supply>=amount_supply) and np.all(total_demand>=amount_demand))-1 ⑤\n\n    return f,g                                                                             ⑥\n```", "```py\nkey = b'MIDACO_LIMITED_VERSION___[CREATIVE_COMMONS_BY-NC-ND_LICENSE]' ①\nproblem = {}                                                          ②\noption  = {}                                                          ③\nproblem['@'] = problem_function                                       ④\n```", "```py\nproblem['o']  = 1                     ①\nproblem['n']  = n_var                 ②\nproblem['ni'] = n_var                 ③\nproblem['m']  = n_constr              ④\nproblem['me'] = 0                     ⑤\n```", "```py\nproblem['xl'] = [0.0]*n_var\nproblem['xu'] = [30.0]*n_var\n```", "```py\nproblem['x'] = problem['xl'] \n```", "```py\noption['maxeval'] = 10000             ①\noption['maxtime'] = 60*60*24          ②\n```", "```py\noption['printeval'] = 1000            ①\noption['save2file'] = 1               ②\n```", "```py\noption['parallel'] = 0                ①\n```", "```py\nsolution = midaco.run( problem, option, key)\n```", "```py\nsoln = solution['x']\nsupply_num=len(amount_supply)                                         ①\ndemand_num=len(amount_demand)                                         ②\nfor i in range(supply_num):                                           ③\n    print(f\"Supply School({supply_schools[i]}): {' +\n➥ '.join(['soln['+str(j)+']' for j in range(i*supply_num,\n➥ (i+1)*supply_num)])} <= {amount_supply[i]} or {' + '.join(map(str,\n➥ soln[i*supply_num:(i+1)*supply_num]))} <= {amount_supply[i]} or\n➥ {sum(soln[i*supply_num:(i+1)*supply_num])} <= {amount_supply[i]}\")\nfor j in range(demand_num):                                           ④\n    print(f\"Demand School({demand_schools[j]}): {' + '.join(['soln['+str(i*demand_num+j)+']' for i in range(demand_num)])} >=\n➥ {amount_demand[j]} or {' + '.join(map(str, [soln[i*demand_num+j] for i\n➥ in range(demand_num)]))} >= {sum(soln[i*demand_num+j] for i in\n➥ range(demand_num))} or {sum(soln[i*demand_num+j] for i in\n➥ range(demand_num))} >= {amount_demand[j]}\") \nprint(f\"Shipping cost =  {solution['f']} $\")                          ⑤\n```", "```py\nSupply School(1): soln[0] + soln[1] <= 20 or 0.0 + 30.0 <= 20 or 30.0 <= 20\nSupply School(3): soln[2] + soln[3] <= 30 or 15.0 + 15.0 <= 30 or 30.0 <= 30\nDemand School(2): soln[0] + soln[2] >= 5 or 0.0 + 15.0 >= 15.0 or 15.0 >= 5\nDemand School(4): soln[1] + soln[3] >= 45 or 30.0 + 15.0 >= 45.0 or 45.0 >= 45\nShipping cost =  [1919.3192442452619] $\n```", "```py\ndef normalize(lst):                                                 ①\n    s = sum(lst)\n    return list(map(lambda x: (x/s)*10, lst))\n\nsoln_normalized = normalize(soln)                                   ②\n\ncolors = ['cyan', 'brown', 'orange', 'purple']                      ③\n\nm = folium.Map(location=[location.latitude, location.longitude],\n➥ zoom_start=15, scrollWheelZoom=False, dragging=False)            ④\n\nfor i, coord in zip(supply_schools, supply_coords):\n    folium.Marker(location=coord, icon=folium.Icon(icon=\"home\",\n➥ color='red'), popup=f'Supply School {i+1}').add_to(m)            ⑤\n\nfor i, coord in zip(demand_schools, demand_coords):\n    folium.Marker(location=coord, icon=folium.Icon(icon=\"flag\",\n➥ color='blue'), popup=f'Demand School {i+1}').add_to(m)           ⑥\n\nfor i in range(len(supply_schools)):                                ⑦\n    for j in range(len(demand_schools)):\n        soln_value = soln[i*len(demand_schools) + j]\n        folium.PolyLine(locations=[supply_coords[i], demand_coords[j]],\n➥ color=colors[i % len(colors)],\n➥  weight=5*soln_normalized[i*len(demand_schools) + j],\n➥ popup=folium.Popup(f'# of microscopes: {soln_value}')).add_to(m)\n\nm                                                                   ⑧\n```", "```py\nimport numpy as np\nimport pandas as pd\nfrom collections import defaultdict\nfrom haversine import haversine\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport random\nfrom minisom import MiniSom\n\ncities = {\n    'New York City': (40.72, -74.00),\n    'Philadelphia': (39.95, -75.17),       \n    'Baltimore': (39.28, -76.62),\n    'Charlotte': (35.23, -80.85),\n    'Memphis': (35.12, -89.97),\n    'Jacksonville': (30.32, -81.70),\n    'Houston': (29.77, -95.38),\n    'Austin': (30.27, -97.77),\n    'San Antonio': (29.53, -98.47),\n    'Fort Worth': (32.75, -97.33),\n    'Dallas': (32.78, -96.80),\n    'San Diego': (32.78, -117.15),\n    'Los Angeles': (34.05, -118.25),\n    'San Jose': (37.30, -121.87),\n    'San Francisco': (37.78, -122.42),    \n    'Indianapolis': (39.78, -86.15),\n    'Phoenix': (33.45, -112.07),       \n    'Columbus': (39.98, -82.98), \n    'Chicago': (41.88, -87.63),\n    'Detroit': (42.33, -83.05)\n}                                                                        ①\n\ndistance_matrix = defaultdict(dict)                                      ②\nfor ka, va in cities.items():                                            ②\n    for kb, vb in cities.items():                                        ②\n        distance_matrix[ka][kb] = 0.0 if kb == ka else haversine((va[0],\n➥ va[1]), (vb[0], vb[1]))                                               ②\n\ndistances = pd.DataFrame(distance_matrix)                                ③\ncity_names=list(distances.columns)                                       ③\n\ndistances=distances.values                                               ④\n```", "```py\nN_neurons = city_count*2                                                  ①\n\nsom = MiniSom(1, N_neurons, 2, sigma=10, learning_rate=.5,\n              neighborhood_function='gaussia   n', random_seed=50)        ②\nsom.random_weights_init(points)                                           ③\n```", "```py\nplt.figure(figsize=(10, 9))\nfor i, iterations in enumerate(range(5, 61, 5)):\n    som.train(points, iterations, verbose=False, random_order=False)\n    plt.subplot(3, 4, i+1)\n    plt.scatter(x,y)\n    visit_order = np.argsort([som.winner(p)[1] for p in points])\n    visit_order = np.concatenate((visit_order, [visit_order[0]]))\n    plt.plot(points[visit_order][:,0], points[visit_order][:,1])\n    plt.title(\"iterations: {i};\\nerror: {e:.3f}\".format(i=iterations,                                                         ➥ e=som.quantization_error(points)))\n    plt.xticks([])\n    plt.yticks([])\nplt.tight_layout()\nplt.show()\n```", "```py\nimport numpy as np\n\nnum_arms = 3                                                   ①\nnum_trials = 10000                                             ②\n\nmu = [7, 10, 6]                                                ③\nsigma = [0.45, 0.65, 0.35]                                     ③\n\ncounts = np.zeros(num_arms)                                    ④\nrewards = np.zeros(num_arms)                                   ④\n\na = np.random.choice(num_arms)                                 ⑤\n\neps = 0.1                                                      ⑥\n\nfor t in range(num_trials):\n    if np.random.rand() > eps:                                 ⑦\n        a = np.argmax(rewards / (counts + 1e-5))               ⑧\n    else:                                                      ⑨\n        a = np.random.choice(num_arms)                         ⑨\n\n    reward = np.random.normal(mu[a], sigma[a]) \n\n    counts[a] += 1\n    rewards[a] += reward\n\nestimates = rewards / counts                                   ⑩\n                                                               ⑩\nprint(\"Estimated click-through rates: \", estimates)            ⑩\n```", "```py\nfrom stable_baselines3.common.env_util import make_vec_env\nfrom stable_baselines3 import A2C\nfrom stable_baselines3.common.evaluation import evaluate_policy\nimport matplotlib.pyplot as plt\nfrom IPython.display import display, clear_output\n\nenv = make_vec_env(\"Taxi-v3\", n_envs=1, seed=0)               ①\nprint('Number of states:{}'.format(env.observation_space))    ②\nprint('Number of actions:{}'.format(env.action_space))        ②\n\nmodel = A2C(policy=\"MlpPolicy\", env=env, verbose=True)        ③\n\nmodel.learn(total_timesteps=10000, progress_bar=True)         ④\n```", "```py\nimages = []                                                  ①\nvec_env = model.get_env()                                    ②\nobs = vec_env.reset()                                        ③\n\nfor i in tqdm(range(300)): \n    action, _states = model.predict(obs, deterministic=True) ④\n    obs, rewards, dones, info = vec_env.step(action)         ⑤\n    state_img = vec_env.render(\"rgb_array\")                  ⑥\n    fig = plt.figure()\n    plt.imshow(state_img)\n    plt.axis('off')\n    display(fig)\n    images.append(fig)\n    clear_output(wait=True)                                  ⑦\n    plt.close()\n```", "```py\nimport vowpalwabbit\nimport torch\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport random\nimport numpy as np\n\nflight_types = ['domestic', 'international']                         ①\npassenger_classes = ['business', 'economy', 'mix']                   ①\n\nflight_routes = ['direct', 'fuel_efficient', 'turbulence_avoidance'] ②\nmeal_services = ['full_meal', 'simple_meal', 'snacks_beverages']     ②\nentertainment_options = ['movies_music', 'in_flight_wifi', 'combo']  ②\n\ndef reward_function(shared_context, flight_route, meal_service,\n➥ entertainment_option):                                            ③\n    if flight_route == 'direct':\n        route_reward = np.random.normal(loc=0.9, scale=0.05)\n    elif flight_route == 'fuel_efficient':\n        route_reward = np.random.normal(loc=0.8, scale=0.05)\n    else: \n        route_reward = np.random.normal(loc=0.7, scale=0.05)\n\n    if meal_service == 'full_meal':\n        meal_reward = np.random.normal(loc=0.9, scale=0.05)\n    elif meal_service == 'simple_meal':\n        meal_reward = np.random.normal(loc=0.8, scale=0.05)\n    else:  \n        meal_reward = np.random.normal(loc=0.7, scale=0.05)\n\n    if entertainment_option == 'movies_music':\n        entertainment_reward = np.random.normal(loc=0.9, scale=0.05)\n    elif entertainment_option == 'in_flight_wifi':\n        entertainment_reward = np.random.normal(loc=0.8, scale=0.05)\n    else\n        entertainment_reward = np.random.normal(loc=0.7, scale=0.05)\n\n    reward = (route_reward + meal_reward + entertainment_reward) / 3.0\n\n    return reward\n```", "```py\ndef generate_combinations(shared_context, flight_routes, meal_services,\n➥ entertainment_options):\n    examples = [f\"shared |FlightType {shared_context[0]} PassClass\n➥ {shared_context[1]}\"]\n    descriptions = []\n    for route in flight_routes:\n        for meal in meal_services:\n            for entertainment in entertainment_options:\n                examples.append(f\"|Action route={route} meal={meal}\n➥ entertainment={entertainment}\")\n                descriptions.append((route, meal, entertainment))\n    return examples, descriptions\n\ndef sample_truck_pmf(pmf):\n    pmf_tensor = torch.tensor(pmf)\n    index = torch.multinomial(pmf_tensor, 1).item()\n    chosen_prob = pmf[index]\n\n    return index, chosen_prob\n```", "```py\ncb_vw = vowpalwabbit.Workspace(\n    \"--cb_explore_adf --epsilon 0.2 --interactions AA AU AAU -l 0.05 –\n➥power_t 0\",\n    quiet=True,\n)\n```", "```py\nnum_iterations = 2500                                                                 ①\ncb_rewards = []                                                                       ②\nfor _ in range(num_iterations): \n    shared_context = (random.choice(flight_types),\n➥ random.choice(passenger_classes))                                                  ③\n    examples, indices = generate_combinations(\n        shared_context, flight_routes, meal_services, entertainment_options\n    )                                                                                 ④\n    cb_prediction = cb_vw.predict(examples)                                           ⑤\n    chosen_index, prob = sample_truck_pmf(cb_prediction)                              ⑥\n    route, meal, entertainment = indices[chosen_index]                                ⑦\n    reward = reward_function(shared_context, route, meal, entertainment)\n    cb_rewards.append(reward)                                                         ⑧\n    examples[chosen_index + 1] = f\"0:{-1*reward}:{prob} {examples[chosen_index + 1]}\" ⑨\n    cb_vw.learn(examples)                                                             ⑩\ncb_vw.finish()                                                                        ⑪\n```", "```py\nplt.plot(pd.Series(cb_rewards).expanding().mean())\nplt.xlabel(\"Iterations\")\nplt.ylabel(\"Average reward\")\nplt.show()\n```", "```py\ndef test_model(shared_context, flight_routes, meal_services,\n➥ entertainment_options):\n    examples, _ = generate_combinations(shared_context, flight_routes,\n➥ meal_services, entertainment_options)                             ①\n    cb_prediction = cb_vw.predict(examples)                          ②\n    chosen_index, prob = sample_truck_pmf(cb_prediction)             ③\n    chosen_action = examples[chosen_index + 1]                       ④\n    route, meal, entertainment = indices[chosen_index]               ⑤\n    expected_reward = reward_function(shared_context, route, meal,\n➥ entertainment)                                                    ⑥\n    print(\"Chosen Action:\", chosen_action)                           ⑦\n    print(\"Expected Reward:\", expected_reward)                       ⑦\n\ntest_shared_context = ('domestic', 'business')                       ⑧\n\ntest_model(test_shared_context, flight_routes, meal_services,\n➥ entertainment_options)                                            ⑨\n```", "```py\nChosen Action: |Action route=fuel_efficient meal=full_meal entertainment=movies_music\nExpected Reward: 0.87\n```", "```py\nmodel = \"learning_tsp/pretrained/tsp_20-50/rl-ar-var-20pnn-gnn-max_20200313T002243\"\n# model = \"learning_tsp/pretrained/tspsl_20-50/sl-ar-var-20pnn-gnn-max_20200308T172931\"\n```"]