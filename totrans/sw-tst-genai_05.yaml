- en: 4 AI-assisted testing for developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. AI 辅助开发者测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Developing unit tests and production code with GitHub Copilot
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Copilot 开发单元测试和生产代码
- en: Developing unit tests and production code with ChatGPT
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ChatGPT 开发单元测试和生产代码
- en: According to a poll on dev ecosystems conducted by JetBrains in 2022, 81% of
    respondents have a developer-to-QA ratio greater than one to one. Forty percent
    reported that they had “less than 1 QA per 10 developers,” and only 1% reported
    that they had “more QAs than developers” (see [www.jetbrains.com/lp/devecosystem-2022/testing](https://www.jetbrains.com/lp/devecosystem-2022/testing).)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JetBrains 在 2022 年进行的一项关于开发生态系统的调查，81% 的受访者拥有超过一比一的开发者与质量保证人员（QA）比例。40% 的受访者表示他们“每
    10 个开发者只有不到 1 个 QA”，而只有 1% 的受访者表示他们“QA 人员比开发者多”（见 [www.jetbrains.com/lp/devecosystem-2022/testing](https://www.jetbrains.com/lp/devecosystem-2022/testing)）。
- en: Understanding and building in quality is essential to delivering value to our
    users, yet the ratio between development and testing is nearly always imbalanced,
    and this is so for many reasons. Some organizational leaders choose to educate
    developers to build in quality with the support of quality coaches, and others
    simply don’t want to invest in roles that advocate for testing and quality. Either
    way, this situation puts pressure on everyone on a team to deliver high-quality
    applications. So, how can artificial intelligence (AI) tools help relieve this
    pressure?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和构建质量对于向用户提供价值至关重要，然而开发和测试之间的比例几乎总是不平衡，这有多种原因。一些组织领导者选择通过质量教练的支持来教育开发者构建质量，而其他人则根本不想投资于倡导测试和质量的职位。无论如何，这种情况都会给团队中的每个人带来压力，要求他们交付高质量的应用程序。那么，人工智能（AI）工具如何帮助缓解这种压力呢？
- en: This chapter will specifically focus on how large language model (LLM) AIs,
    such as GitHub Copilot and ChatGPT, can help developers build quality into our
    work. Rather than thinking of these AI tools as replacements for developers and
    testers, we’ll learn how they can guide us as we carry out activities that build
    in quality as we develop, as well as demonstrate how we can use AI tools to improve
    quality and identify risks when testing is a limited resource to take advantage
    of.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将特别关注大型语言模型（LLM）AI，如 GitHub Copilot 和 ChatGPT，如何帮助开发者将质量融入我们的工作中。我们不会将这些 AI
    工具视为开发者和测试人员的替代品，而是学习它们如何在执行构建质量的活动时引导我们，以及展示我们如何使用 AI 工具在测试资源有限的情况下提高质量并识别风险。
- en: Setting up Copilot
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Copilot
- en: In this chapter, we’ll be looking at examples of GitHub Copilot in use. To familiarize
    yourself with Copilot before we try out these examples, you can find installation
    and operation instructions in appendix B.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 GitHub Copilot 的使用示例。在我们尝试这些示例之前，您可以在附录 B 中找到安装和操作说明。
- en: 4.1 Examining the rise of the automated developer
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 检查自动化开发者的崛起
- en: In April 2023, Similarweb, a market competition analysis company, reported that
    Stack Overflow’s traffic in the preceding month had dropped by 14%. According
    to Similarweb, the cause was a rise in developers switching from Stack Overflow
    to tools such as GitHub’s Copilot and ChatGPT (see [https://mng.bz/5Oy4](https://mng.bz/5Oy4)).
    Whether this is a sign of an ongoing trend of developers jumping ship or an anomaly
    that will eventually balance out, reports such as this one demonstrate the sweeping
    changes that LLM-based AI tools (LLMs) are introducing to the role of a developer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 2023 年 4 月，市场竞争分析公司 Similarweb 报告称，Stack Overflow 在前一个月的流量下降了 14%。根据 Similarweb，原因是开发者从
    Stack Overflow 转向 GitHub 的 Copilot 和 ChatGPT 等工具（见 [https://mng.bz/5Oy4](https://mng.bz/5Oy4)）。这究竟是开发者跳槽的持续趋势的迹象，还是最终会平衡的异常情况，此类报告表明基于
    LLM 的 AI 工具（LLMs）正在对开发者角色带来广泛的变化。
- en: As a tester, it’s an interesting change to witness. For many years, as test
    automation tools became more advanced, I had discussions with developers about
    whether testing could be replaced by automated testing tools. Now, with LLMs that
    are trained against billions of lines of code from public and private repositories,
    conversations have turned toward whether developer roles can be automated. For
    example, a tool such as ChatGPT can be sent a prompt such as
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试人员，看到这种有趣的变化是很吸引人的。多年来，随着测试自动化工具的日益先进，我与开发者们讨论过是否可以用自动化测试工具取代测试。现在，随着训练了来自公共和私有代码库数十亿行代码的大型语言模型（LLM），对话已经转向是否可以自动化开发者的角色。例如，可以将
    ChatGPT 发送如下提示：
- en: '|'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![logo-MW](../../OEBPS/Images/logo-MW.png)'
- en: '| Write me some Java code that sends an HTTP request to a booking API |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 写一些Java代码，用于向预订API发送HTTP请求 |'
- en: 'and it will then use its billions of trained weights and balances to return
    a working code example like this one:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将利用其数十亿经过训练的权重和平衡来返回一个像这样的工作代码示例：
- en: '|'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: From just one basic prompt, we can use LLMs to create workable code (updating
    the `apiUrl` to a real API returned a positive result). So, it’s not surprising
    that there are tools that combine prompts attempting to automate development work.
    Tools such as AutoGPT ([https://github.com/Significant-Gravitas/AutoGPT](https://github.com/Significant-Gravitas/AutoGPT))
    and MetaGPT ([https://github.com/geekan/MetaGPT](https://github.com/geekan/MetaGPT))
    have appeared to work as autonomous agents, generating their own prompts based
    on initial questions to solve complex problems. Although these tools are in their
    infancy, it’s clear why the more hyperbolic claims of developers being automated
    out of their role are bandied about.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一个基本的提示，我们就可以使用LLM（大型语言模型）来创建可工作的代码（将`apiUrl`更新为真实的API返回了积极的结果）。因此，并不奇怪会有工具结合提示，试图自动化开发工作。例如，AutoGPT
    ([https://github.com/Significant-Gravitas/AutoGPT](https://github.com/Significant-Gravitas/AutoGPT))
    和 MetaGPT ([https://github.com/geekan/MetaGPT](https://github.com/geekan/MetaGPT))
    作为自主代理出现，根据初始问题生成自己的提示来解决复杂问题。尽管这些工具还处于起步阶段，但很明显为什么开发者被自动化取代的夸张说法会被广泛传播。
- en: As someone who has spent much of his career explaining why test automation is
    not a suitable replacement, it’s tempting to enjoy the schadenfreude of seeing
    developers defending their roles in the same way, but instead, it’s more valuable
    to learn from the experiences of testers and the automation topic. Just as a tester’s
    role can’t be fully automated, neither can a developer’s role. A development role
    is more than just the code that is produced. The solutions that developers create
    are a product of analytical skills, problem-solving, and design thinking. LLM
    tools give the impression of having these skills, which is not true.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位大部分职业生涯都在解释为什么测试自动化不适合作为替代方案的人来说，看到开发者以同样的方式捍卫他们的角色可能会让人感到一种幸灾乐祸的乐趣，但更重要的是从测试人员和自动化主题的经验中学习。正如测试人员的角色不能完全自动化一样，开发者的角色也不能。开发角色不仅仅是产生的代码。开发者创建的解决方案是分析技能、问题解决和设计思维的结果。LLM工具给人一种拥有这些技能的印象，但这并不真实。
- en: 'Instead, developers find success with LLM tools by using them to enhance their
    own abilities: they may use tools such as Copilot to quickly and effectively create
    code that they want to build or seek advice from ChatGPT to solve issues or learn
    new APIs. These principles can also be applied to improving a developer’s ability
    to build quality into an application. By combining techniques such as test-driven
    design (TDD) or the power of LLMs, developers can increase their productivity
    while ensuring that their analytical and design skills lead the charge. To help
    demonstrate this symbiosis, let’s explore the following two examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，开发者通过使用这些LLM工具来增强自己的能力而取得成功：他们可能会使用Copilot等工具快速有效地创建他们想要构建的代码，或者向ChatGPT寻求帮助以解决问题或学习新的API。这些原则也可以应用于提高开发者将质量构建到应用程序中的能力。通过结合测试驱动设计（TDD）或LLM的力量等技术，开发者可以提高他们的生产力，同时确保他们的分析和设计技能处于领先地位。为了帮助展示这种共生关系，让我们探讨以下两个示例：
- en: Using Copilot to rapidly generate unit checks and production code for TDD loops
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Copilot快速生成TDD循环的单元测试和生产代码
- en: Emulating pairing with a simulated developer, courtesy of ChatGPT
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟开发者的配对，得益于ChatGPT
- en: Through the examples, you’ll learn to set up and use these LLM tools, as well
    as appreciate the balance that is possible to strike between the power of AI and
    the abilities of developers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，你将学会设置和使用这些LLM工具，以及欣赏在AI的力量和开发者的能力之间可能达到的平衡。
- en: Experiences may vary
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 经验可能有所不同
- en: Given that Copilot relies on predictive algorithms that are frequently trained
    on newly added code and updated APIs/libraries, it’s worth highlighting that the
    output and experience you have when following the upcoming examples may be different
    from what has been recorded. Keep in mind that the goal of this chapter is not
    to replicate the examples 100%, but rather for you to become comfortable with
    using LLMs to assist our work in a way that helps us build in quality.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Copilot 依赖于经常在新增代码和更新的 API/libraries 上进行训练的预测算法，因此值得强调的是，您在遵循即将到来的示例时所获得的输出和体验可能与记录的内容不同。请记住，本章的目标不是100%复制示例，而是让您熟悉使用
    LLMs 以帮助我们以有助于构建质量的方式辅助我们的工作。
- en: 4.2 Pairing with LLMs
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 与 LLMs 配对
- en: We’ve already seen that LLMs are probabilistic in nature, and as a result, it
    can be useful to think of them as outputting simulations of roles rather than
    inhabiting specific roles. An LLM has no more awareness of being a software tester
    than it does of being a restauranteur. But with prompt engineering, we can create
    prompts that frame an LLM’s probabilistic output to simulate a role, helping us
    to create rubber ducks to interact with. This can be useful in a development capacity
    when testing resources are limited in either availability or capability. So, let’s
    take a look at a couple of sample prompts we can use to elicit feedback that can
    help us improve the quality of our work and our products.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 LLMs 具有概率性本质，因此，将其视为输出角色模拟而不是占据特定角色可能是有用的。LLM 对自己是软件测试员的认识并不比自己是餐厅老板的认识更多。但是，通过提示工程，我们可以创建提示，将
    LLM 的概率性输出框架化以模拟角色，帮助我们创建橡皮鸭进行互动。这在测试资源在可用性或能力方面有限的情况下，在开发能力方面非常有用。因此，让我们看看一些我们可以使用的样本提示，以获取有助于我们改进工作质量和产品的反馈。
- en: Wait, what—rubber duck?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么——橡皮鸭？
- en: 'When facing a problem that we have no solution for, it can help to verbalize
    the problem to others to find an answer. By articulating the problem to another
    person, we sometimes find that the solution presents itself to us. However, there
    isn’t always an opportunity to speak with colleagues; therefore, some developers
    will verbalize their issues to a rubber duck (or another item). Although we’re
    sharing our challenges with an inanimate object, the experience is the same: verbalizing
    our challenges tricks our brains into finding solutions.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 面对没有解决方案的问题时，向他人口头描述问题以寻找答案可能会有所帮助。通过向另一个人阐述问题，我们有时会发现解决方案自然呈现在我们面前。然而，并不总是有机会与同事交谈；因此，一些开发者会将他们的问题口头描述给橡皮鸭（或其他物品）。尽管我们是在与一个无生命的物体分享我们的挑战，但体验是相同的：口头描述我们的挑战会让我们的大脑找到解决方案。
- en: 4.2.1 Analyzing ideas
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 分析想法
- en: Our first prompt is inspired by the shift-left testing mindset that some teams
    apply to help build quality into applications as early as possible. *Shift-left*
    testing means bringing testing analysis earlier into the development process,
    ideally around the point at which ideas are being discussed and details clarified.
    This process results in many questions being asked that help us identify issues
    earlier, deliver valuable features, and improve the quality of our products. Shift-left
    activities are an invaluable approach to improving quality and should be encouraged
    regardless of the use of AI in the development process. However, by introducing
    LLMs into the process, we can use prompts to generate questions that might reveal
    assumptions or misunderstandings or questions that we can simply disregard.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个提示灵感来源于一些团队采用的左移测试思维模式，以帮助尽早将质量构建到应用程序中。*左移*测试意味着将测试分析提前到开发过程中，理想情况下是在讨论想法和澄清细节的点。这个过程导致我们提出许多问题，帮助我们尽早识别问题，交付有价值的特性，并提高我们产品的质量。左移活动是提高质量的无价方法，应鼓励使用，无论在开发过程中是否使用
    AI。然而，通过将 LLM 引入过程，我们可以使用提示生成可能揭示假设或误解或我们可以简单忽略的问题。
- en: 'Let’s take a look at a sample prompt that can be used to rapidly generate questions
    that might be useful. We use delimiters to inform the LLM where the data to analyze
    is found:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个可以快速生成可能有用问题的样本提示。我们使用分隔符来告知 LLM 数据分析的位置：
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a software testing expert. Analyze the text delimited by triple hashes
    and generate questions that will clarify ambiguities in the text. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 你是一位软件测试专家。分析由三个井号分隔的文本，并生成问题以澄清文本中的歧义。 |'
- en: 'We then set a series of rules around how questions are asked and output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置一系列关于如何提问和输出的规则：
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![MW 标志](../../OEBPS/Images/logo-MW.png)'
- en: '|    *   Questions will be generated by using the What, Where, Why, When, Who
    and How heuristic   *   Multiple questions can be identified for each quality
    characteristic   *   The quality characteristics we care about are: Accuracy,
    Security and Accessibility   *   Output questions in the format of Question -
    Explanation |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|   使用“什么、哪里、为什么、何时、谁和如何”启发式方法生成问题   *   每个质量特性都可以识别出多个问题   *   我们关心的质量特性是：准确性、安全性和可访问性  
    *   以“问题 - 解释”的格式输出问题|'
- en: 'Few-shot prompting allows us to create an example of how we expect the output
    to look:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 少样本提示允许我们创建一个示例，展示我们期望的输出外观：
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![MW 标志](../../OEBPS/Images/logo-MW.png)'
- en: '| Example:What does relevant mean?The acceptance criteria says relevant search
    results, but how do we determine what is relevant and what isn’t? |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 示例：什么是相关？验收标准说相关搜索结果，但我们如何确定什么是相关的，什么不是？|'
- en: 'We then enter the data for analysis into the delimited section of the prompt:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将用于分析的数据输入到提示词的分隔部分：
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![MW 标志](../../OEBPS/Images/logo-MW.png)'
- en: '| ###As a B&B ownerI want to be able to manage user accessSo that I can allow
    different levels of access to multiple usersFeatures:   −   DB is configured with
    an Admin user   −   Guests are asked to create an account to make a booking  
    −   Admin can see the accounts created on the platform and can delete them###
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| ### 作为一家B&B的业主，我希望能够管理用户访问，以便我可以允许不同级别的访问权限给多个用户功能：   −   数据库配置了管理员用户   −  
    客人被要求创建账户以进行预订   −   管理员可以看到平台上创建的账户并可以删除它们### |'
- en: The prompt outlines instructions for an LLM to analyze a user story and acceptance
    criteria and return a list of questions for us to consider. Notice how we also
    provide context in the quality characteristics instruction. If we want to focus
    on different characteristics, we can update these as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 提示词概述了如何让一个大型语言模型分析用户故事和验收标准，并返回一个我们需要考虑的问题列表。注意我们也在质量特性说明中提供了上下文。如果我们想关注不同的特性，我们也可以更新这些内容。
- en: 'Entering this prompt into ChatGPT returned the following result:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将此提示输入到ChatGPT返回以下结果：
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI 标志](../../OEBPS/Images/logo-openai.png)'
- en: '| Accuracy:   1.  What criteria are used to determine the accuracy of user
    access management?Explanation: The text mentions managing user access, but it
    doesn’t specify how accuracy is ensured in granting different levels of access
    to multiple users.   2.  How is the system ensuring that the right access levels
    are assigned to users?Explanation: The text refers to allowing different levels
    of access to multiple users, but it doesn’t explain the mechanism for guaranteeing
    the accuracy of access permissions.Security:   1.  Who has access to the database
    configured with an Admin user?Explanation: The text mentions configuring the database
    with an Admin user, but it doesn’t specify who has access to this Admin account
    and how its security is maintained.   2.  How is the platform protecting user
    account information and data?Explanation: The text talks about guests creating
    accounts for bookings, but it lacks details about the security measures implemented
    to safeguard user data.   3.  What security measures are in place to prevent unauthorized
    access to user accounts?Explanation: The text mentions that Admin can see and
    delete accounts, but it doesn’t explain how unauthorized access to such account
    management functionalities is prevented.Accessibility:   1.  What levels of accessibility
    are provided to different types of users?Explanation: The text mentions managing
    user access with different levels, but it doesn’t clarify what those levels are
    and how they vary based on user types.   2.  How are guests guided to create accounts
    for booking, and is the process accessible to all users?Explanation: The text
    states that guests are asked to create accounts, but it doesn’t specify how this
    process is carried out and if it meets accessibility standards.   3.  What measures
    are taken to ensure the platform’s accessibility for users with disabilities?Explanation:
    The text doesn’t provide information on how accessibility is addressed for users
    with disabilities, and it’s essential to understand the measures taken to accommodate
    their needs.   4.  Where can we find information about the platform’s accessibility
    features?Explanation: The text mentions nothing about the platform’s accessibility
    features, so it would be helpful to know where this information is available.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 准确度：1. 确定用户访问管理准确性的标准是什么？说明：文本提到了管理用户访问，但没有具体说明如何确保为多个用户授予不同访问级别时的准确性。2.
    系统是如何确保为用户分配正确的访问级别的？说明：文本提到了为多个用户允许不同级别的访问，但没有解释保证访问权限准确性的机制。安全：1. 哪些人可以访问配置了管理员用户的数据库？说明：文本提到了使用管理员用户配置数据库，但没有具体说明谁可以访问这个管理员账户以及如何维护其安全性。2.
    平台是如何保护用户账户信息和数据的？说明：文本提到了客人创建账户进行预订，但缺乏关于保护用户数据所采取的安全措施的细节。3. 为了防止未经授权访问用户账户，采取了哪些安全措施？说明：文本提到管理员可以查看和删除账户，但没有解释如何防止对这种账户管理功能的未经授权访问。可访问性：1.
    为不同类型的用户提供哪些级别的可访问性？说明：文本提到了使用不同级别的用户访问管理，但没有明确说明这些级别是什么以及它们如何根据用户类型而变化。2. 客人是如何被引导创建预订账户的，这个过程对所有用户都是可访问的吗？说明：文本指出客人被要求创建账户，但没有具体说明这个过程是如何进行的以及它是否符合可访问性标准。3.
    为了确保平台对残疾人士的可访问性，采取了哪些措施？说明：文本没有提供有关如何解决残疾人士可访问性的信息，了解为满足他们的需求所采取的措施是至关重要的。4.
    我们在哪里可以找到有关平台可访问性功能的信息？说明：文本没有提到有关平台可访问性功能的信息，因此了解这些信息在哪里可以获得将是有帮助的。|'
- en: 'Reading through the response, we can see that there is an interesting collection
    of questions ranging in quality. For example, consider this question:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读响应后，我们可以看到有一系列有趣的问题，质量参差不齐。例如，考虑以下问题：
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| How are guests guided to create accounts for booking, and is the process
    accessible to all users?Explanation: The text states that guests are asked to
    create accounts, but it doesn’t specify how this process is carried out and if
    it meets accessibility standards. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 客人是如何被引导创建预订账户的，这个过程对所有用户都是可访问的吗？说明：文本指出客人被要求创建账户，但没有具体说明这个过程是如何进行的以及它是否符合可访问性标准。|'
- en: This is a helpful question that encourages us to consider in more detail the
    statement “Guests are asked to create an account to make a booking, ”found in
    our user story. We could consider this question and think about how we would design
    the booking process to make it accessible to all types of users.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有助于我们更详细地考虑在用户故事中找到的声明“客人被要求创建账户以进行预订”的问题。我们可以考虑这个问题，并思考我们如何设计预订流程，使其对所有类型的用户都易于访问。
- en: However, other questions are perhaps not quite as good. For example,
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他问题可能并不完全一样好。例如，
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| What criteria are used to determine the accuracy of user access management?Explanation:
    The text mentions managing user access, but it doesn’t specify how accuracy is
    ensured in granting different levels of access to multiple users. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 使用什么标准来确定用户访问管理的准确性？说明：文本提到了管理用户访问，但没有具体说明如何确保向多个用户授予不同访问级别时的准确性。|'
- en: What makes this question problematic is its reference to the quality characteristic
    *accuracy*. Typically, accuracy would be more focused on the accuracy of data
    processed or stored (think bank interest rate calculations). Instead, the phrase
    “accuracy of user access” feels like an odd way to describe the rules set around
    users and what they can access. Ultimately, it’s up to us to evaluate each question
    for suitability and use. Some questions can encourage us to build products that
    are more closely aligned with what a user wants and help us avoid errors, whereas
    other generated questions will either make little sense or cover topics already
    considered.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个问题成为问题的是其对质量特性*准确性*的引用。通常，准确性会更关注处理或存储的数据的准确性（想想银行利率计算）。相反，“用户访问的准确性”这个短语感觉像是一种奇特的方式来描述围绕用户及其可以访问的内容设定的规则。最终，评估每个问题的适宜性和使用取决于我们。一些问题可以鼓励我们构建更符合用户需求的产品，并帮助我们避免错误，而其他生成的问题可能没有意义或覆盖已考虑的主题。
- en: We’ll come back to this prompt and how we might use it during the development
    of a feature, but first, let’s take a look at how we can repurpose this prompt
    to review our code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到这个提示以及我们如何在开发功能时使用它，但首先，让我们看看我们如何重新利用这个提示来审查我们的代码。
- en: 4.2.2 Analyzing code
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 分析代码
- en: 'Just as we can prompt an LLM to analyze written-down ideas, we can also have
    it review code and help us identify risks. Using this prompt is akin to simulating
    the role of a developer or tester that you are pairing with by having them analyze
    your work as you develop to offer suggestions for consideration. Let’s check out
    a prompt that could be of use for this type of activity. We use delimiters to
    signal where the code will be, as well as check for assumptions if no code is
    given:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以提示一个LLM分析写下的想法一样，我们也可以让它审查代码并帮助我们识别风险。使用这种提示类似于模拟你与开发者或测试人员配对时的角色，让他们在你开发过程中分析你的工作，并提出考虑的建议。让我们看看一个可能适用于此类活动的提示。我们使用分隔符来指示代码的位置，以及在没有提供代码的情况下检查假设：
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a software testing expert. Analyze the code delimited by triple hashes
    and identify risks that might impact the code. If no code is provided, respond
    with “No risks could be found.” |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 你是一位软件测试专家。分析由三个井号分隔的代码，并识别可能影响代码的风险。如果没有提供代码，请回答“没有发现风险。”|'
- en: 'We then provide instructions around quality characteristics and output structure:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后提供有关质量特性和输出结构的说明：
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '|    *   Risks must be related to the quality characteristics: Performance,
    security and interoperability   *   Multiple risks can be identified for each
    quality characteristic   *   Output identified risks in the format of Risk - Quality
    Characteristic - Explanation |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|   *   风险必须与质量特性相关：性能、安全性和互操作性   *   每个质量特性都可以识别出多个风险   *   以风险 - 质量特性 - 说明的格式识别出已确定的风险
    |'
- en: 'Few-shot prompting allows us to give an example of output structure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 少样本提示允许我们给出输出结构的示例：
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| Example:Overflow - Security - Adding in large integers as parameters might
    cause the method to trigger a buffer overflow.Code is provided within the instructed
    delimiters:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '| 示例：溢出 - 安全性 - 将大整数作为参数添加可能会导致方法触发缓冲区溢出。代码在指定的分隔符内提供：'
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'After I sent the prompt with the sample code and quality characteristics to
    ChatGPT, the following output was returned:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我将带有示例代码和品质特性的提示发送给ChatGPT后，返回了以下输出：
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI标志](../../OEBPS/Images/logo-openai.png)'
- en: '| Based on the provided code snippet, let’s analyze the potential risks that
    might affect the quality characteristics of Performance, Security, and Interoperability:  
    •   Performance - Nested Validation:   −   Risk: The nested validation checks
    (`dateCheckValidator.isValid` and `bookingDB.checkForBookingConflict`) may lead
    to performance issues, especially when dealing with a large number of bookings.  
    −   Explanation: If the system has to process a substantial amount of bookings,
    the nested validation can result in increased execution time and resource consumption.  
    •   Performance - Message Posting:   −   Risk: The message posting (`messageRequests.postMessage`)
    might introduce performance bottlenecks, affecting the overall system responsiveness.  
    −   Explanation: If the message posting process involves network communication
    or I/O operations, it could slow down the execution of the `createBooking` method.  
    •   Security - SQL Injection:   −   Risk: The code is susceptible to SQL injection
    attacks as it directly uses the `bookingToCreate` object in the database queries.  
    −   Explanation: Malicious input in the `bookingToCreate` object could manipulate
    the SQL queries and compromise the integrity and security of the database.   •  
    Security - Inadequate Authorization:   −   Risk: The code does not perform explicit
    authorization checks before creating bookings, potentially allowing unauthorized
    users to create bookings.   −   Explanation: Lack of proper authorization checks
    can lead to unauthorized access and misuse of the system’s booking creation functionality.  
    •   Interoperability - Platform Dependencies:   −   Risk: The code might have
    dependencies on specific platforms or libraries, limiting its interoperability
    with other systems or environments.   −   Explanation: If the `MessageBuilder`
    or `messageRequests` rely on platform-specific features or external libraries,
    it could cause issues when running the code in different environments.   •   Interoperability
    - Error Codes:   −   Risk: The code returns HTTP status codes directly, which
    may not be compatible with other systems that expect different error code formats.  
    −   Explanation: If external systems expect error codes in a different format
    (e.g., JSON or XML), using HTTP status codes may hinder interoperability. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 根据提供的代码片段，让我们分析可能影响性能、安全性和互操作性的潜在风险：   •   性能 - 嵌套验证：   −   风险：嵌套验证检查（`dateCheckValidator.isValid`和`bookingDB.checkForBookingConflict`）可能会导致性能问题，尤其是在处理大量预订时。  
    −   说明：如果系统需要处理大量的预订，嵌套验证可能会导致执行时间增加和资源消耗增加。   •   性能 - 消息发布：   −   风险：消息发布（`messageRequests.postMessage`）可能会引入性能瓶颈，影响整个系统的响应速度。  
    −   说明：如果消息发布过程涉及网络通信或I/O操作，可能会减慢`createBooking`方法的执行速度。   •   安全 - SQL注入：   −  
    风险：代码容易受到SQL注入攻击，因为它直接在数据库查询中使用`bookingToCreate`对象。   −   说明：`bookingToCreate`对象中的恶意输入可能会操纵SQL查询，并危害数据库的完整性和安全性。  
    •   安全 - 权限不足：   −   风险：代码在创建预订之前没有执行显式的授权检查，可能允许未经授权的用户创建预订。   −   说明：缺乏适当的授权检查可能导致未经授权的访问和系统预订创建功能的滥用。  
    •   互操作性 - 平台依赖性：   −   风险：代码可能依赖于特定的平台或库，限制了它与其它系统或环境的互操作性。   −   说明：如果`MessageBuilder`或`messageRequests`依赖于特定平台的功能或外部库，可能会在不同环境中运行代码时引起问题。  
    •   互操作性 - 错误代码：   −   风险：代码直接返回HTTP状态码，这可能与期望不同错误代码格式的其他系统不兼容。   −   说明：如果外部系统期望不同的错误代码格式（例如，JSON或XML），使用HTTP状态码可能会阻碍互操作性。
    |'
- en: 'Similar to the previous prompt, which generated questions around written requirements,
    the quality of these different risks varies. For example, the risk “Performance
    - Message Posting” feels quite abstract, as we can see in its explanation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的提示类似，它生成了关于书面要求的问题，这些不同风险的质量各不相同。例如，风险“性能 - 消息发布”感觉相当抽象，正如我们可以在其说明中看到的那样：
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI标志](../../OEBPS/Images/logo-openai.png)'
- en: '| If the message posting process involves network communication or I/O operations,
    it could slow down the execution of the `createBooking` method. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: 如果消息发布过程涉及网络通信或I/O操作，可能会减慢`createBooking`方法的执行速度。
- en: Suggesting risks around network communication or I/O operations feels vague
    because it might refer to a range of implementations, some of which might relate
    to our work and some that might not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络通信或I/O操作周围提出风险感觉模糊，因为它可能指代一系列实现，其中一些可能与我们的工作相关，而另一些则可能不相关。
- en: 'However, other risks are more concrete and potentially useful—for example,
    “Security - Inadequate Authorization,” which highlights the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他风险更具体且可能更有用——例如，“安全 - 授权不足”，它突出了以下内容：
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI标志](../../OEBPS/Images/logo-openai.png)'
- en: '| The code does not perform explicit authorization checks before creating bookings,
    potentially allowing unauthorized users to create bookings. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 代码在创建预订之前不执行显式的授权检查，可能允许未经授权的用户创建预订。|'
- en: This risk feels more concrete because it refers to actions that are carried
    out in our method and the absence of potentially important checks within it. Of
    course, we may carry out authorization checks elsewhere, but the information it
    has given highlighted an explicit activity that we might need to discuss further
    to improve the security of our booking feature.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风险感觉更具体，因为它指的是在我们方法中执行的动作以及其中可能缺失的重要检查。当然，我们可能在其他地方执行授权检查，但该信息所提供的信息突显了一个可能需要进一步讨论以改进预订功能安全性的明确活动。
- en: Generating more ideas
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 生成更多想法
- en: So far, we’ve looked at singular prompts to send to LLMs, which gives us useful
    responses to review. But what if we want to solicit more questions and risks?
    We simply ask by submitting an additional prompt, such as “Generate more questions”
    or “Identify further risks.” Be wary, though, as this has diminishing returns.
    An LLM will try to fulfill our requests at the risk of increasing hallucinations.
    So, as options start to dry out, we may see more suggestions that are less connected
    to the ideas and code we wanted feedback on in the first place.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注向LLM发送的单一提示，这为我们提供了有用的响应以供审查。但如果我们想征求更多问题和风险呢？我们只需提交一个额外的提示，例如“生成更多问题”或“识别进一步的风险”。但请注意，这会带来递减的回报。LLM会尝试满足我们的请求，但可能会增加幻觉。因此，当选项开始枯竭时，我们可能会看到更多与最初我们想要反馈的想法和代码不太相关的建议。
- en: 4.2.3 Recognizing that a simulation is better than nothing at all
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 认识到模拟总比没有好
- en: When testing is discussed, the focus is typically on the production and execution
    of test cases. But a highly trained and experienced tester delivers value by using
    their critical and lateral thinking skills and asks questions that help view solutions
    in new ways and reveal potential problems. The prompts we’ve looked at can offer
    a simulation of that process. However, it’s important to remember that LLMs don’t
    have these critical and lateral thinking skills and that the questions and risks
    generated come from the instruction of our prompts. Instead, these types of prompts
    can offer a lightweight way to simulate the experience of pairing with testers
    or other developers when the opportunity to pair is unavailable. The key is to
    develop an eye for generated questions to determine which are of use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论测试时，重点通常放在测试用例的生产和执行上。但一个训练有素且经验丰富的测试人员通过运用他们的批判性和横向思维技能，提出有助于以新方式看待解决方案并揭示潜在问题的问题。我们已查看的提示可以提供该过程的模拟。然而，重要的是要记住，LLM没有这些批判性和横向思维技能，而且生成的问题和风险来自我们提示的指令。相反，这类提示可以提供一种轻量级的方式来模拟与测试人员或其他开发人员配对的经验，当没有配对机会时。关键是培养对生成问题的洞察力，以确定哪些是有用的。
- en: 4.3 Building in quality with AI assistance
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用AI辅助构建质量
- en: So far, we’ve looked at prompts as singular activities, but now, let’s turn
    our attention to how the prompts we’ve recently learned and other LLM assistant
    tools can be used in conjunction with TDD to help us build in quality.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将提示视为单一活动，但现在，让我们转向关注我们最近学到的提示和其他LLM辅助工具如何与TDD结合使用，以帮助我们构建质量。
- en: Although TDD is not strictly a testing activity when compared to other testing
    activities, TDD that is carried out correctly helps guide developers to build
    quality into products. To recap, the process of TDD is to use unit-checking tools
    to first create failing checks and then just enough production code to make the
    check *pass* (and fix any other checks that may have failed). Once all our checks
    are passing, we can refactor our production code while ensuring all our checks
    are green. Once that’s complete, we start the loop again until our work is complete,
    as demonstrated in figure 4.1.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与其它测试活动相比，TDD 并非严格意义上的测试活动，但正确执行的 TDD 有助于指导开发者将质量融入产品。为了回顾，TDD 的过程是首先使用单元检查工具创建失败的检查，然后编写足够的生产代码以使检查*通过*（并修复可能失败的任何其他检查）。一旦所有我们的检查都通过，我们可以在确保所有检查都是绿色的同时重构我们的生产代码。一旦完成，我们再次开始循环，直到我们的工作完成，如图
    4.1 所示。
- en: '![](../../OEBPS/Images/CH04_F01_Winteringham2.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F01_Winteringham2.png)'
- en: Figure 4.1 The red/green/refactor TDD cycle
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 红绿重构 TDD 循环
- en: What’s all this about checks?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些关于检查的讨论是什么意思？
- en: In our Automation in Testing training, Richard Bradshaw and I make a distinction
    between human-led and tool-led testing. We call the latter type *automated checking*
    because the tools can only assert explicit actions or data that we codify into
    our automation. This distinction helps us better appreciate that automated tools
    such as unit-checking frameworks are excellent at rapidly checking small, specific
    changes in a product but are unable to tell us more about a system beyond its
    assertions. Humans, however, are slower and less deterministic in testing, although
    we are much more efficient at identifying many events happening simultaneously.
    Hence, this is why tools check and humans test. One is not better than the other,
    and hopefully, this book will demonstrate that we can have the best success when
    combining both.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试自动化培训中，理查德·布拉德肖和我区分了以人为导向和以工具为导向的测试。我们将后者称为*自动化检查*，因为工具只能断言我们编码到自动化中的明确动作或数据。这种区分帮助我们更好地理解，自动化工具如单元检查框架在快速检查产品中的小而具体的更改方面非常出色，但无法告诉我们关于系统更多超出其断言的信息。然而，人类在测试中较慢且不太确定，尽管我们在识别同时发生的许多事件方面效率更高。因此，这就是为什么工具检查而人类测试的原因。一个并不比另一个更好，希望这本书能证明当我们结合两者时，我们可以取得最佳的成功。
- en: This approach enables us to design products that are highly testable while ensuring
    we deliver what the business or end user desires.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使我们能够设计高度可测试的产品，同时确保我们交付业务或最终用户所期望的产品。
- en: Although its benefits are manifold (improving code design, making it more testable,
    and most importantly, improving its quality), some developers find it hard to
    adopt the TDD approach, believing that it slows down development as we create
    unit checks for each specific section of production code added to our system.
    However, with tools such as Copilot, we can learn how to establish a balance in
    which the tools enable us to rapidly create unit checks and build in quality.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其好处是多方面的（改进代码设计，使其更易于测试，最重要的是，提高其质量），但一些开发者发现很难采用 TDD 方法，认为它减慢了开发速度，因为我们为系统添加的每个特定部分的生产代码创建单元检查。然而，有了像
    Copilot 这样的工具，我们可以学习如何建立平衡，使工具能够快速创建单元检查并构建质量。
- en: Setting up Copilot
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Copilot
- en: This chapter assumes that you have installed and configured the Copilot plugin
    within your IDE. If you haven’t already completed the setup process, you can find
    installation instructions in appendix B.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已在您的 IDE 中安装并配置了 Copilot 插件。如果您尚未完成设置过程，您可以在附录 B 中找到安装说明。
- en: 4.4 Creating our first TDD loop with LLMs
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用 LLMs 创建我们的第一个 TDD 循环
- en: 'To demonstrate, let’s undergo the process of creating part of a feature for
    a sample timesheet manager:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，让我们经历创建样本时间表管理器部分功能的过程：
- en: As a timesheet user, I want to be able to track time against specific projects
    so that I can keep a history of how much time I have spent working on individual
    projects.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为时间表用户，我希望能够跟踪特定项目的时间，以便我可以保留我在各个项目上花费的时间历史记录。
- en: 'Features:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能：
- en: Time is tracked in half hour units.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间以半小时为单位进行跟踪。
- en: To complete a timesheet, a project and amount of time must be entered.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要完成时间表，必须输入项目和花费的时间。
- en: Only I should be able to see my tracked time.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有我应该能够看到我跟踪的时间。
- en: 'You can review the test and production code created as part of this example
    in the following GitHub repository: [https://mng.bz/6YMG](https://mng.bz/6YMG).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 GitHub 仓库中查看本示例中创建的测试和生产代码：[https://mng.bz/6YMG](https://mng.bz/6YMG)。
- en: 4.4.1 Preparing the work
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 准备工作
- en: 'Before starting to create my timesheet manager feature, I wanted to think about
    how I would go about building it. To get help with this process and encourage
    me to think about the solution from various angles, I took the first prompt we
    explored earlier in this chapter and entered my context into it. Specifically,
    I changed the quality characteristics to accuracy and consistency and added the
    user story into the delimited section at the bottom of the prompt:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建我的时间表管理功能之前，我想考虑我将如何构建它。为了帮助我进行这个过程并鼓励我从不同角度思考解决方案，我使用了本章早期探索的第一个提示，并将我的上下文输入其中。具体来说，我将质量特性更改为准确性和一致性，并将用户故事添加到提示底部分隔的段落中：
- en: '|'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![MW 标志](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a software testing expert. Analyze the text delimited by triple hashes
    and generate questions that will clarify ambiguities in the text.   *   Questions
    will be generated by using the What, Where, Why, When, Who and How heuristic  
    *   Multiple questions can be identified for each quality characteristic   *  
    The quality characteristics we care about are: Accuracy and Consistency   *  
    Output questions in the format of Question - ExplanationExample:What does relevant
    mean?The acceptance criteria say relevant search results, but how do we determine
    what is relevant and what isn’t?###As a timesheet userI want to be able to track
    time against specific projectsSo that I can keep a history of how much time I
    have spent working on individual projectsFeatures:   −   Time is tracked in half
    hour units   −   To complete a timesheet a project and amount of time must be
    entered   −   Only I should be able to see my tracked time### |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 您是一位软件测试专家。分析由三个井号分隔的文本，并生成将澄清文本中模糊性的问题。   *   问题将通过使用 What（什么）、Where（哪里）、Why（为什么）、When（何时）、Who（谁）和
    How（如何）启发式方法生成   *   每个质量特性都可以识别出多个问题   *   我们关心的质量特性是：准确性和一致性   *   以“问题 - 例子”的格式输出问题。示例：什么是相关的意思？验收标准说相关搜索结果，但我们如何确定什么是相关的，什么不是？###
    作为时间表用户我想要能够跟踪特定项目的时间，以便我可以记录我在各个项目上花费的时间历史记录功能：   −   时间以半小时为单位跟踪   −   要完成时间表，必须输入项目和时长  
    −   只有我应该能够看到我跟踪的时间### |'
- en: 'Sending this prompt to ChatGPT returned the following response:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将此提示发送到 ChatGPT 返回以下响应：
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI 标志](../../OEBPS/Images/logo-openai.png)'
- en: '| Accuracy:   •   What is the required precision for tracking time in half-hour
    units? - The text mentions that time is tracked in half-hour units. It’s important
    to know the level of accuracy required for this tracking.   •   How will the system
    handle invalid time entries? - Since time must be entered to complete a timesheet,
    what measures are in place to ensure that only valid time entries are accepted?  
    •   What validation mechanisms are in place to prevent users from entering incorrect
    time data? - To maintain accuracy, it’s essential to know how the system will
    validate and handle potential data entry errors.   •   How will the system handle
    time zone differences for users in different locations? - This is important to
    ensure that the tracked time is consistent and accurate for users in various time
    zones.Consistency:   •   Where will the history of tracked time be stored and
    accessed? - To ensure consistency, it’s important to know where the data will
    be stored and how users can access it.   •   What are the rules for displaying
    and formatting tracked time information? - Consistency in displaying the tracked
    time across the system is crucial for a seamless user experience.   •   Who is
    responsible for verifying and maintaining the consistency of tracked time data?
    – It’s essential to assign responsibility for data integrity and consistency to
    avoid discrepancies.   •   When and how often will the timesheet data be synchronized
    or updated? - Ensuring consistency in real-time updates or scheduled syncs is
    vital to avoid discrepancies between users’ data.   •   How will the system handle
    potential conflicts if multiple users try to update the same project’s timesheet
    simultaneously? - Maintaining consistency in data updates when multiple users
    are involved is critical to prevent data loss or inaccuracies.   •   What security
    measures are in place to protect the data and ensure its integrity? - Consistency
    also involves safeguarding the data from unauthorized access or tampering. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 准确性：   •   跟踪半小时单位时间所需的精度是多少？ - 文中提到时间是以半小时为单位进行跟踪的。了解这种跟踪所需的精度是很重要的。   •  
    系统将如何处理无效的时间条目？ - 由于必须输入时间才能完成时间表，有哪些措施可以确保只接受有效的时间条目？   •   有哪些验证机制可以防止用户输入错误的时间数据？
    - 为了保持准确性，了解系统将如何验证和处理潜在的数据输入错误是至关重要的。   •   系统将如何处理不同地点的用户的时间区域差异？ - 这对于确保不同时区的用户跟踪的时间一致和准确是很重要的。  
    |'
- en: What are quality characteristics?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '| 一致性：   •   跟踪时间的历史记录将存储在哪里，如何访问？ - 为了确保一致性，了解数据将存储在哪里以及用户如何访问它是很重要的。   •  
    显示和格式化跟踪时间信息的规则是什么？ - 在整个系统中一致地显示跟踪时间对于无缝的用户体验至关重要。   •   谁负责验证和维护跟踪时间数据的一致性？
    - 将数据完整性和一致性责任分配给个人是避免差异的必要条件。   •   时间表数据何时以及多久更新一次？ - 确保实时更新或计划同步的一致性对于避免用户数据之间的差异至关重要。  
    •   如果多个用户同时尝试更新同一项目的时表，系统将如何处理潜在的冲突？ - 当涉及多个用户时，保持数据更新的致性对于防止数据丢失或不准确至关重要。  
    •   有哪些安全措施可以保护数据并确保其完整性？ - 一致性还涉及保护数据免受未经授权的访问或篡改。   |'
- en: Quality means very different things to different people and is a multifaceted
    concept. Therefore, when attempting to understand what quality means to a stakeholder
    or end user, we break out ways of thinking about it into different characteristics.
    For example, quality characteristics might include look and feel, usability, compliance,
    and much more. Different projects will have different quality characteristics
    that we prioritize, and it’s up to us as teams to identify what quality characteristics
    are of priority to us and our users.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 质量对不同的人意味着不同的事情，是一个多方面的概念。因此，当我们试图理解质量对利益相关者或最终用户意味着什么时，我们将对它的思考方式分解为不同的特性。例如，质量特性可能包括外观和感觉、可用性、合规性以及更多。不同的项目将会有不同的质量特性，我们需要优先考虑，并且作为团队，我们需要确定对我们和我们的用户来说哪些质量特性是优先的。
- en: 'From here, I read each of the questions sent back to me and noted the ones
    that stood out as raising points I hadn’t considered. Let’s go through some of
    them and explore my thinking behind each one:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我阅读了我收到的每一个问题，并记下了那些突出显示了我未曾考虑过的观点。让我们来探讨一些这些问题，并了解我对每个问题的思考：
- en: '|'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 质量特性是什么？
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| How will the system handle invalid time entries? / What validation mechanisms
    are in place to prevent users from entering incorrect time data? |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 系统将如何处理无效的时间条目？/ 有哪些验证机制可以防止用户输入错误的时间数据？ |'
- en: These two questions felt very similar, but they highlighted that I will, at
    some point, need to add date–time handling into the code to prevent problems around
    invalid entries.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题感觉非常相似，但它们突出了我将在某个时候需要将日期时间处理添加到代码中，以防止无效输入引起的问题。
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| How will the system handle time zone differences for users in different locations?
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 对于位于不同位置的用户的时区差异，系统将如何处理？ |'
- en: It’s a good question, but not relevant to this work as I plan to just track
    the amount of time carried out and not when it was carried out (at least for now).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好问题，但与这项工作不相关，因为我计划只跟踪执行的时间量，而不是执行的时间（至少目前是这样）。
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| What are the rules for displaying and formatting tracked time information?
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 显示和格式化跟踪时间信息的规则是什么？ |'
- en: Connected to the previous question, I opted for simply tracking the amount of
    time that had elapsed and not specifically when it had occurred, meaning that
    the displaying of information is relatively straightforward.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到前一个问题，我选择简单地跟踪已经过去的时间量，而不是具体发生的时间，这意味着信息的显示相对简单。
- en: '|'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| How will the system handle potential conflicts if multiple users try to update
    the same project’s timesheet simultaneously? |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 如果多个用户同时尝试更新同一项目的工时表，系统将如何处理潜在的冲突？ |'
- en: At this time, there is no multiple-user feature, although it might be introduced
    later, so I make a note to consider this for future iterations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，系统中没有多用户功能，尽管它可能以后会被引入，所以我记下在未来的迭代中考虑这一点。
- en: Many more questions could be asked and addressed, but what this process demonstrates
    is that, by generating different questions, I am required to think about various
    aspects of this feature’s design. Some I can choose to rule out, or shelve for
    later conversation, and some help me to improve the quality of my feature by raising
    my awareness to validation and date–time formatting.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以提出和解决更多的问题，但这个过程展示的是，通过生成不同的问题，我需要思考这个功能设计的各个方面。有些我可以选择排除，或者留待以后讨论，而有些则通过提高我对验证和日期时间格式化的认识来帮助我提高功能的品质。
- en: '4.4.2 Loop 1: Save a timesheet entry'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 循环1：保存工时条目
- en: With the questions from the previous prompt in my mind, I start my first loop
    by creating an empty maven project within my IDE before heading to the `pom.xml`
    to add my required dependencies. I require JUnit 5 to build my unit checks, so
    I entered the comment
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中想着之前提示中的问题，我开始我的第一个循环，在IDE中创建一个空的maven项目，然后前往`pom.xml`添加我需要的依赖项。我需要JUnit
    5来构建我的单元测试，所以我输入了以下注释
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Copilot returns the following code block:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot返回以下代码块：
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'At the time of writing, the proposed version of `junit-jupiter-engine` is an
    older version, so I update to `5.9.2` as shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`junit-jupiter-engine`建议的版本是一个较旧的版本，所以我更新到`5.9.2`，如下所示：
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This required update is a good example of how data provenance can affect what
    is being suggested. While constantly being trained on code that is being pushed
    to GitHub, Copilot runs the risk of lagging behind the latest versions of libraries
    and APIs. So, we need to be vigilant when adding in dependencies via AI code assistants
    to ensure they are suggesting the version we want.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个需要更新的例子很好地说明了数据来源如何影响建议的内容。虽然Copilot不断在GitHub上推送的代码上进行训练，但它可能会落后于库和API的最新版本。因此，当我们通过AI代码助手添加依赖项时，我们需要保持警惕，以确保它们建议的是我们想要的版本。
- en: Furthermore, what is demonstrated here is how the Copilot IDE plugin will take
    code (or in this case a code comment) I have written, add it to a prompt, and
    then send it to the Copilot LLM to process. The LLM then sends back to the IDE
    plugin a suggestion of what to enter next, and the plugin then presents me with
    the suggestion. I now have the option to either accept the suggestion by hitting
    Tab or continue to write my own code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里展示的是Copilot IDE插件如何将我编写的代码（或在这种情况下是一个代码注释）添加到一个提示中，并将其发送到Copilot LLM进行处理。LLM随后将建议的下一步输入发送回IDE插件，插件然后向我展示这个建议。我现在可以选择通过按Tab键接受建议，或者继续编写我自己的代码。
- en: Much like other LLMs, Copilot is triggered by prompts. But unlike a chat-based
    LLM (such as ChatGPT), Copilot is tuned to process code-based rather than text-based
    prompts. This distinction is important because it highlights both the benefits
    of different types of fine-tuned LLMs for different activities, as well as the
    need to write prompts that work for different prompt types. This is why TDD and
    AI assistants are an interesting combination to work with. The unit checks we
    create not only frame the design of our work but also serve as prompts to inform
    how we want to implement features.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他LLM类似，Copilot通过提示被触发。但与基于聊天的LLM（如ChatGPT）不同，Copilot调整以处理基于代码的提示而不是基于文本的提示。这种区别很重要，因为它突出了不同类型的微调LLM对不同活动的益处，以及编写适用于不同提示类型的提示的需要。这就是为什么TDD和AI助手是一个有趣的组合。我们创建的单元检查不仅框定了我们的工作设计，还作为提示，告诉我们如何实现功能。
- en: 'For example, for our first check, I prompt Copilot to create my first unit
    check for me by adding the following comment into a new class titled `TimesheetTest`
    in `src/test/java`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们的第一个检查，我提示Copilot为我创建第一个单元检查，通过在`src/test/java`中一个名为`TimesheetTest`的新类中添加以下注释：
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This triggers Copilot to suggest the following unit check:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这触发了Copilot建议以下单元检查：
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Looking at this suggested check, we see that it has the necessary details we
    require. It’s given the class I intend to build a sensible name of `Timesheet`
    and suggested the method `submitTimesheet` with the correct parameters of project
    name and hours. This check is enough of a prompt that when I create a new class
    `Timesheet` in `src/main/java`, Copilot suggests
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这个建议的检查，我们看到它包含了我们所需要的必要细节。它为我要构建的类提供了一个合理的名称`Timesheet`，并建议了具有正确参数（项目名称和小时数）的`submitTimesheet`方法。这个检查足够作为提示，当我创建一个名为`Timesheet`的新类在`src/main/java`中时，Copilot建议
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The unit check served as a prompt to Copilot to create my production code, and
    although what has been produced is not exactly exciting, the check has been fulfilled.
    We can also see that Copilot works by building prompts on prompts to get to what
    we want. First, I created a prompt in the form of a code comment to help Copilot
    suggest the code for the unit check, and then that unit check served as a prompt
    for the suggested production code. As the unit checks grow, so will the prompts
    and directions to Copilot on what to build. Now, let’s look at how I used this
    process to build out the `submitTimesheet` method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 单元检查作为提示，促使Copilot创建我的生产代码，尽管产生的代码并不那么令人兴奋，但检查已经完成。我们还可以看到，Copilot通过构建提示来达到我们想要的结果。首先，我创建了一个代码注释形式的提示，以帮助Copilot为单元检查建议代码，然后这个单元检查作为建议生产代码的提示。随着单元检查的增加，对Copilot的提示和构建指导也将增加。现在，让我们看看我是如何使用这个过程来构建`submitTimesheet`方法的。
- en: '4.4.3 Loop 2: Retrieve a timesheet entry'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 循环2：检索时间表条目
- en: 'With the first loop, I created the skeleton of my project, but at the moment,
    the actual production code bears little fruit. So, with the second loop, I looked
    to add more features to the `Timesheet` class to help flesh out the `submitTimesheet`
    method. Again, I start by adding a new comment prompt to `TimesheetTest`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过第一个循环，我创建了项目的骨架，但到目前为止，实际的生产代码几乎没有成果。因此，在第二个循环中，我试图向`Timesheet`类添加更多功能，以帮助完善`submitTimesheet`方法。再次，我首先向`TimesheetTest`添加一个新的注释提示：
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'And upon creating a new line, Copilot returned the following check as a suggestion:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新行后，Copilot返回以下检查作为建议：
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This time, the generated check is using the `submitTimesheet` method to create
    some data that I can then verify using the newly created `getTimesheets` method.
    So, heading over to the `Timesheet` class, I use Copilot to generate the necessary
    `getTimesheets` method, which returns
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，生成的检查是通过`submitTimesheet`方法创建一些数据，然后我可以使用新创建的`getTimesheets`方法进行验证。所以，我转向`Timesheet`类，使用Copilot生成必要的`getTimesheets`方法，它返回
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Although it’s helpful that it created the method signature for me, the internals
    of the method are not so useful. However, I add the following to the top of the
    class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它为我创建了方法签名很有帮助，但方法内部并不那么有用。然而，我在类的顶部添加了以下内容：
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Then I return to the `submitTimesheet` method and remove `return true` from
    inside the method. When I enter the keyword `if` into the statement, Copilot returns
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我回到 `submitTimesheet` 方法并从方法内部移除 `return true`。当我将关键字 `if` 输入到语句中时，Copilot
    返回
- en: '|'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This is a useful demonstration of how a project requires a degree of warmup
    before the LLM can return more accurate suggestions when working with Copilot.
    By returning to the `submitTimesheet` method, removing its contents, and then
    waiting for Copilot to respond, I get a refreshed response from Copilot based
    on the new details I’ve provided. Just as a prompt for a chat LLM requires clear
    and explicit details, so does Copilot. The initial stock methods that were returned
    from Copilot for `Timesheet` are likely because there is little context to work
    with. Essentially, the prompts sent to Copilot lack information. But as I create
    new unit checks and additional code to show our intent in our code, the suggestions
    become more useful.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的演示，说明了在 LLM 与 Copilot 一起工作时，项目需要一定的预热过程，才能返回更准确的建议。通过返回到 `submitTimesheet`
    方法，移除其内容，然后等待 Copilot 响应，我得到了 Copilot 基于我提供的新细节的刷新响应。正如一个聊天 LLM 需要清晰和明确的信息一样，Copilot
    也是如此。Copilot 返回的 `Timesheet` 的初始库存方法可能是因为缺乏上下文。基本上，发送给 Copilot 的提示缺乏信息。但随着我创建新的单元检查和额外的代码来展示我们在代码中的意图，建议变得更加有用。
- en: 'This is also demonstrated when I delete the `getTimesheets` method entirely.
    With the new `HashMap` added to the class, my updated code prompts Copilot to
    return an updated version of the method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我完全删除 `getTimesheets` 方法时，这也得到了演示。随着新添加到类中的 `HashMap`，我的更新代码提示 Copilot 返回方法的更新版本：
- en: '|'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Running both of my unit checks after this loop, I can see both checks are passing
    and now have working code that is a bit more feature rich than when I started
    the loop.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环之后运行我的两个单元检查，我可以看到两个检查都通过了，现在有了一个比开始循环时功能更丰富的有效代码。
- en: '4.4.4 Loop 3: Calculating times for a project'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 循环 3：计算项目的工时
- en: 'For the final loop, I went back to the questions returned from ChatGPT and
    thought about the question:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后的循环，我回到了 ChatGPT 返回的问题，并思考了以下问题：
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| How will the system handle potential conflicts if multiple users try to update
    the same project’s timesheet simultaneously? |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 如果多个用户同时尝试更新同一项目的工时表，系统将如何处理潜在的冲突？|'
- en: 'Although there is no functionality for multiple users at this point in the
    project, the question from ChatGPT did make me think about how to handle multiple
    timesheet submissions to the same project. So, I created my third unit check to
    handle this scenario by once again creating a code comment to prompt Copilot for
    another unit check:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个项目的这个阶段还没有为多个用户添加功能，但 ChatGPT 提出的问题确实让我思考了如何处理向同一项目提交多个工时表的情况。因此，我创建了第三个单元检查来处理这种情况，再次创建一个代码注释来提示
    Copilot 进行另一个单元检查：
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'It returned the following unit check:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回了以下单元检查：
- en: '|'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This time, the suggested check is close, but I want the `Timesheet` class to
    return a total, not have a total processed within the unit check itself. So, I
    opted to update the check to explicitly state there is a method for getting total
    timesheet hours:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，建议的检查很接近，但我希望 `Timesheet` 类返回一个总数，而不是在单元检查本身内部处理总数。因此，我选择更新检查，明确指出有一个获取总工时小时数的方法：
- en: '|'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Heading back over to `Timesheet` and waiting for Copilot, the LLM returns the
    following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `Timesheet` 并等待 Copilot，LLM 返回以下代码：
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This allows the code to compile, but my new unit check fails because the project
    count isn’t being updated. Instead, because I am using a `HashMap`, the count
    is being overwritten. I need to update `submitTimesheet` to handle duplicate projects,
    which I do by dropping the following comment into `submitTimesheet`, just after
    the initial `if` statement:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许代码编译，但我的新单元检查失败了，因为项目计数没有被更新。相反，因为我使用了 `HashMap`，计数被覆盖了。我需要更新 `submitTimesheet`
    来处理重复的项目，我通过在 `submitTimesheet` 中，初始 `if` 语句之后插入以下注释来完成这项工作：
- en: '|'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Dropping in the code comment returns the following suggested code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代码注释返回以下建议的代码：
- en: '|'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This expands the `submitTimesheet` function to allow it to increase the duration
    of existing projects in a timesheet:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这扩展了`submitTimesheet`函数，使其能够增加时间表中的现有项目的持续时间：
- en: '|'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-plugin.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-plugin.png)'
- en: '|'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A final run of my three-unit checks confirms that they are all passing and that
    I have all the features I want in my `Timesheet` class. However, the code is starting
    to become more complex, so I turn my attention to refactoring my code with the
    use of ChatGPT.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我对三个单元检查的最终运行确认它们都通过了，并且我在我的`Timesheet`类中拥有所有我想要的功能。然而，代码开始变得更为复杂，所以我将注意力转向使用ChatGPT重构我的代码。
- en: 4.4.5 Refactoring code
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 代码重构
- en: 'One benefit of pairing with others is the ability for a pair partner to see
    potential problems and risks that we might not see. However, in the absence of
    a pair partner, I chose to use the second of the prompts we explored earlier in
    this chapter—specifically, the prompt that analyzes code and returns suggestions.
    Taking the prompt and adding my code and the quality characteristics’ accuracy
    and consistency, I sent the following prompt to ChatGPT. I slightly updated the
    instructions to make it clear I am providing Java code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 与他人配对的一个好处是配对伙伴可以看到我们可能看不到的潜在问题和风险。然而，在没有配对伙伴的情况下，我选择了使用本章之前探索的第二个提示——具体来说，是分析代码并返回建议的提示。将提示与我的代码以及质量特性的准确性和一致性结合起来，我向ChatGPT发送了以下提示。我稍微更新了说明，使其明确我正在提供Java代码：
- en: '|'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a software testing expert. Analyze the Java code delimited by triple
    hashes and identify risks that might impact the code. If no code is provided,
    respond with “No risks could be found” |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 你是一位软件测试专家。分析由三个井号分隔的Java代码，并识别可能影响代码的风险。如果没有提供代码，则回答“没有找到风险” |'
- en: 'I update the additional instructions with my quality characteristics:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我根据我的质量特性更新了附加说明：
- en: '|'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|    *   Risks must be related to the quality characteristics: Accuracy and
    Consistency   *   Multiple risks can be identified for each quality characteristic  
    *   Output identified risks in the format of Risk - Quality Characteristic - Explanation
    |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|   *   风险必须与质量特性相关：准确性 和 一致性   *   每个质量特性都可以识别出多个风险   *   以“风险 - 质量特性 - 说明”的格式输出识别出的风险
    |'
- en: 'An example is provided to demonstrate the format of the response:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，用于展示响应的格式：
- en: '|'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Example:Overflow - Security - Adding in large integers as parameters might
    cause the method to trigger a buffer overflow. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 示例：溢出 - 安全 - 将大整数作为参数添加可能会导致方法触发缓冲区溢出。 |'
- en: 'The code I created from my earlier loops is added in the delimited section:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我从之前的循环中创建的代码被添加到分隔区域：
- en: '|'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Sending the prompt returned the following risks that I might want to consider:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 发送提示后返回了以下我可能需要考虑的风险：
- en: '|'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Risk 1 - Accuracy - `submitTimesheet` method can overwrite existing duration:The
    `submitTimesheet` method allows adding a new duration to an existing project’s
    total if the project already exists in the timesheets. However, this approach
    may not always ensure accuracy. If the user intends to submit a correction or
    update the duration for a specific project, this method will not provide accurate
    results. It merely adds the new duration to the existing one without considering
    the possibility of editing or deleting a previous entry.Risk 2 - Consistency -
    Null key in timesheets HashMap:The timesheets HashMap allows null keys. This might
    lead to inconsistency issues when querying for timesheet information by project
    name. If a project with a null name is mistakenly added to the timesheets, it
    may cause issues in subsequent operations, leading to unexpected behavior.Risk
    3 - Consistency - Lack of validation for project names:The `submitTimesheet` method
    does not validate the project name before adding it to the timesheets HashMap.
    This lack of validation might result in inconsistent data, such as duplicate or
    improperly formatted project names. For example, if two different variations of
    the same project name (e.g., `"ProjectA"` and `"projecta"`) are added, the system
    might treat them as separate projects, leading to inconsistencies in reporting
    or querying.Risk 4 - Accuracy - `getTotalTimesheetHours` method may throw `NullPointer-Exception`:The
    `getTotalTimesheetHours` method directly calls `timesheets.get(projectName)`,
    which may throw a `NullPointerException` if the given `projectName` is not present
    in the timesheets HashMap. This can lead to inaccurate results if the method is
    used without checking for the existence of the project name in the timesheets
    before calling this method.Risk 5 - Accuracy - Return type of `getTotalTimesheetHours`
    method:The `getTotalTimesheetHours` method returns an int data type, which might
    lead to accuracy issues if the actual total timesheet hours for a project exceed
    the maximum value that an int can hold. This can result in data loss due to overflow
    if the sum of durations for a project exceeds `Integer.MAX_VALUE`.Risk 6 - Consistency
    - Lack of synchronization in a multi-threaded environment:If this `Timesheet`
    class is used in a multi-threaded environment, there is a risk of inconsistent
    behavior since the methods of this class are not synchronized. This can lead to
    data corruption or incorrect calculations if multiple threads concurrently access
    and modify the timesheets HashMap. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 风险 1 - 准确性 - `submitTimesheet` 方法可能覆盖现有持续时间：`submitTimesheet` 方法允许在项目已存在于时间表的情况下，向现有项目的总持续时间添加新的持续时间。然而，这种方法并不总是能保证准确性。如果用户打算提交更正或更新特定项目的持续时间，此方法将不会提供准确的结果。它只是将新的持续时间添加到现有的持续时间上，而不考虑编辑或删除先前条目的可能性。风险
    2 - 一致性 - 时间表 HashMap 中的空键：时间表 HashMap 允许空键。在按项目名称查询时间表信息时，这可能会导致不一致的问题。如果错误地将一个空名称的项目添加到时间表中，可能会在后续操作中引起问题，导致意外行为。风险
    3 - 一致性 - 缺乏对项目名称的验证：`submitTimesheet` 方法在将其添加到时间表 HashMap 之前不验证项目名称。这种缺乏验证可能会导致不一致的数据，例如重复或不正确格式的项目名称。例如，如果添加了同一项目名称的不同变体（例如，“ProjectA”和“projecta”），系统可能会将它们视为不同的项目，导致报告或查询中的不一致。风险
    4 - 准确性 - `getTotalTimesheetHours` 方法可能抛出 `NullPointerException`：`getTotalTimesheetHours`
    方法直接调用 `timesheets.get(projectName)`，如果给定的 `projectName` 不存在于时间表 HashMap 中，可能会抛出
    `NullPointerException`。如果在调用此方法之前没有检查项目名称是否存在于时间表中，这可能导致不准确的结果。风险 5 - 准确性 - `getTotalTimesheetHours`
    方法的返回类型：`getTotalTimesheetHours` 方法返回 int 数据类型，如果实际的总时间表小时数超过 int 可以持有的最大值，可能会导致准确性问题。如果项目的持续时间总和超过
    `Integer.MAX_VALUE`，这可能导致溢出，从而造成数据丢失。风险 6 - 一致性 - 多线程环境中的缺乏同步：如果在多线程环境中使用此 `Timesheet`
    类，由于此类的方法没有同步，因此存在不一致行为的风险。如果多个线程同时访问和修改时间表 HashMap，可能会导致数据损坏或计算错误。|'
- en: 'Unlike the questions prompt, this response appears to call out specific items
    of my code and gives reasons for how things might go wrong. With this response,
    I have the following options:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 与问题提示不同，这个响应似乎指出了我的代码中的具体项目，并给出了可能出错的原因。有了这个响应，我有以下选择：
- en: Review each risk on a case-by-case basis and then mitigate the ones I feel are
    important and ignore the others.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据每个案例逐一审查风险，然后减轻我认为重要的风险，忽略其他风险。
- en: Ignore the proposed risks entirely, or perhaps send another prompt to ChatGPT
    to see whether there are more risks.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全忽略所提出的风险，或者也许可以向 ChatGPT 发送另一个提示，看看是否有更多的风险。
- en: Use the response from ChatGPT as a prompt in and of itself to help me refactor
    my code.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ChatGPT 的响应本身用作提示，以帮助我重构我的代码。
- en: 'For the purposes of this demonstration, I chose to go with the third option
    and send an additional prompt to ChatGPT:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我选择了第三个选项，并向 ChatGPT 发送了额外的提示：
- en: '|'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![MW 标志](../../OEBPS/Images/logo-MW.png)'
- en: '| Refactor the code to mitigate the risks suggested. Check to see that each
    risk has been mitigated before outputting the solution. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 重构代码以减轻所建议的风险。在输出解决方案之前，检查每个风险是否已被减轻。|'
- en: 'Notice how I used the time-to-think principle to get the LLM to check whether
    each risk has actually been mitigated by the refactored code it suggested. This
    helps increase the likelihood that the code that’s returned will be useful. Sending
    this prompt to ChatGPT returned the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我是如何使用思考时间原则来让 LLM 检查它所建议的重构代码是否实际上减轻了每个风险的。这有助于增加返回的代码有用的可能性。将此提示发送到 ChatGPT
    返回了以下代码：
- en: '|'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI 标志](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Changes HashMap to ConcurrentHashMap❷ Adds in additional code to lowercase
    project names❸ Converts the int data type to long |
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 HashMap 改为 ConcurrentHashMap❷ 添加额外的代码将项目名称转换为小写❸ 将 int 数据类型转换为 long |
- en: To check whether these modifications hold up, I copied the suggested code into
    `Timesheet`, modified `testCalculateTotalHoursWorked` to take a `long` instead
    of an `int` in `TimesheetTest`, and discovered that my checks still pass and I
    refactored my code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查这些修改是否有效，我将建议的代码复制到 `Timesheet` 中，将 `TimesheetTest` 中的 `testCalculateTotalHoursWorked`
    修改为使用 `long` 而不是 `int`，并发现我的检查仍然通过，并且我已经重构了我的代码。
- en: 'However, has this improved my code? To confirm, I run the original code analysis
    prompt with my updated code again and receive new risks:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这有没有改善我的代码？为了确认，我再次运行了带有更新代码的原始代码分析提示，并收到了新的风险：
- en: '|'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI 标志](../../OEBPS/Images/logo-openai.png)'
- en: '| Risk - Accuracy - Case Sensitivity Issue:Explanation: The method `submitTimesheet`
    converts the `projectName` to lowercase before using it as a key in the timesheets
    map. This conversion might lead to inaccurate data retrieval if there are projects
    with the same name but different letter cases (e.g., `"ProjectA"` and `"projecta"`
    will be considered the same project).Risk - Consistency - Inconsistent Data Entry:Explanation:
    The `submitTimesheet` method does not enforce consistent data entry for `projectName`
    values. If different users enter project names in various formats (e.g., `"Project
    A"`, `"project-A"`, `"project_A"`), it could lead to multiple entries for what
    should be the same project in the timesheets map.Risk - Accuracy - Missing Validation
    for Duration:Explanation: Although the method `submitTimesheet` checks for a positive
    duration, it does not handle cases where the duration is 0 or negative. This could
    lead to incorrect data being recorded in the timesheets map.Risk - Consistency
    - Lack of Input Sanitization:Explanation: The `submitTimesheet` method does not
    sanitize the `projectName` input, which could lead to inconsistent data due to
    invalid characters or unexpected inputs.Risk - Accuracy - Potential Data Loss:Explanation:
    The method `submitTimesheet` returns a boolean value, but it does not provide
    any feedback or error handling mechanism if the submission fails. This lack of
    feedback could lead to data loss if the submission fails silently, and the user
    is not aware of the issue. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 风险 - 准确性 - 案例敏感性问题：说明：方法 `submitTimesheet` 在将其用作时间表映射中的键之前将 `projectName`
    转换为小写。这种转换可能会导致如果存在具有相同名称但不同字母大小写的项目（例如，`"ProjectA"` 和 `"projecta"` 将被视为同一项目）时数据检索不准确。风险
    - 一致性 - 数据输入不一致：说明：`submitTimesheet` 方法不强制执行 `projectName` 值的一致数据输入。如果不同的用户以不同的格式（例如，`"Project
    A"`、`"project-A"`、`"project_A"`）输入项目名称，则可能导致在时间表映射中为应该是同一项目的多个条目。风险 - 准确性 - 缺少对持续时间的验证：说明：尽管
    `submitTimesheet` 方法检查持续时间是否为正数，但它不处理持续时间是 0 或负数的情况。这可能导致在时间表映射中记录错误的数据。风险 - 一致性
    - 缺乏输入清理：说明：`submitTimesheet` 方法不清理 `projectName` 输入，这可能导致由于无效字符或意外输入而导致数据不一致。风险
    - 准确性 - 可能的数据丢失：说明：`submitTimesheet` 方法返回一个布尔值，但如果提交失败，它不提供任何反馈或错误处理机制。如果提交静默失败且用户未意识到问题，这种缺乏反馈可能导致数据丢失。|'
- en: What is interesting in this response is I can confirm that some risks have been
    mitigated such as
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个响应中有趣的是，我可以确认一些风险已被减轻，例如
- en: '|'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI 标志](../../OEBPS/Images/logo-openai.png)'
- en: '| Risk 5 - Accuracy - Return type of `getTotalTimesheetHours` method:The `getTotalTimesheetHours`
    method returns an int data type, which might lead to accuracy issues if the actual
    total timesheet hours for a project exceed the maximum value that an int can hold.
    This can result in data loss due to overflow if the sum of durations for a project
    exceeds `Integer.MAX_VALUE`. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 风险5 - 准确性 - `getTotalTimesheetHours`方法的返回类型：`getTotalTimesheetHours`方法返回int数据类型，如果实际项目总时间表小时数超过int可以持有的最大值，可能会导致准确性问题。如果项目持续时间的总和超过`Integer.MAX_VALUE`，这可能导致数据丢失，因为会发生溢出。|'
- en: 'However, it appears that there are still some risks that haven’t mitigated.
    For example, in the first list of risks I received the following risk:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，似乎还有一些风险尚未得到缓解。例如，在第一份风险列表中，我收到了以下风险：
- en: '|'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Risk 3 - Consistency - Lack of validation for project names:The `submitTimesheet`
    method does not validate the project name before adding it to the timesheets HashMap.
    This lack of validation might result in inconsistent data, such as duplicate or
    improperly formatted project names. For example, if two different variations of
    the same project name (e.g., `"ProjectA"` and `"projecta"`) are added, the system
    might treat them as separate projects, leading to inconsistencies in reporting
    or querying. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 风险3 - 一致性 - 项目名称验证缺失：`submitTimesheet`方法在将项目名称添加到时间表HashMap之前没有进行验证。这种验证缺失可能导致不一致的数据，例如重复或不正确格式的项目名称。例如，如果添加了同一项目名称的不同变体（例如，“ProjectA”和“projecta”），系统可能会将它们视为不同的项目，导致报告或查询中的不一致。|'
- en: 'It was handled by ChatGPT implementing a `lowerCase` method to help sanitize
    the project name. However, on the second analysis, I was returned the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由ChatGPT通过实现一个`lowerCase`方法来帮助清理项目名称来处理的。然而，在第二次分析中，我得到了以下结果：
- en: '|'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Risk - Consistency - Inconsistent Data Entry:Explanation: The `submitTimesheet`
    method does not enforce consistent data entry for `projectName` values. If different
    users enter project names in various formats (e.g., `"Project A"`, `"project-A"`,
    `"project_A"`), it could lead to multiple entries for what should be the same
    project in the timesheets map. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 风险 - 一致性 - 不一致的数据录入：说明：`submitTimesheet`方法没有强制执行`projectName`值的一致性数据录入。如果不同的用户以不同的格式（例如，“Project
    A”，“project-A”，“project_A”）输入项目名称，可能会导致在时间表映射中出现多个应属于同一项目的条目。|'
- en: This risk is very similar to the original, allegedly mitigated, risk. It feels
    like this additional risk around inconsistent data entry should have been handled
    properly when my code was refactored. I could once again ask the LLM to refactor
    my code for me, but instead given the potential for going around in circles with
    the LLM, it would be sensible for me to take the lead and fix the problems myself.
    This is an important skill to develop—knowing when to rely on an LLM and when
    to take charge.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风险与原始的、据说已经缓解的风险非常相似。感觉这种关于不一致数据录入的额外风险应该在代码重构时得到妥善处理。我再次可以要求LLM为我重构代码，但鉴于与LLM可能陷入循环的风险，我亲自带头解决问题会更明智。这是需要培养的重要技能——知道何时依赖LLM，何时亲自负责。
- en: The reason this choice is important can be highlighted by one of the other suggested
    risks that came from the second round of analysis. Specifically,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择之所以重要，可以通过分析中提出的其他建议风险之一来强调。具体来说，
- en: '|'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Risk - Accuracy - Missing Validation for Duration:Explanation: Although the
    method `submitTimesheet` checks for a positive duration, it does not handle cases
    where the duration is 0 or negative. This could lead to incorrect data being recorded
    in the timesheets map. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 风险 - 准确性 - 持续时间的验证缺失：说明：尽管`submitTimesheet`方法检查持续时间是否为正数，但它没有处理持续时间等于0或负数的情况。这可能导致在时间表映射中记录错误的数据。|'
- en: 'This sounds like a convincing risk, but it’s a demonstration of a hallucination.
    As the code stands, if the duration is ≥0, the method simply returns false and
    bails out of the timesheet storage:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一个令人信服的风险，但它却是一个幻觉的展示。按照目前的代码，如果持续时间≥0，该方法将简单地返回false并退出时间表存储：
- en: '|'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: LLMs can be biased sometimes to prioritize giving an answer regardless of its
    quality, meaning the more times we ask an LLM to analyze our code, the more likely
    it will start to generate hallucinations to give the impression that it’s producing
    useful results rather than returning with a response that no useful information
    can be shared. This is why we must keep careful tabs on when it’s beneficial to
    use an LLM.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有时LLM可能会偏向于优先给出答案，而不考虑其质量，这意味着我们要求LLM分析我们的代码的次数越多，它就越有可能开始产生幻觉，以给人留下它正在产生有用结果的印象，而不是返回没有有用信息可以分享的响应。这就是为什么我们必须仔细监控何时使用LLM是有益的。
- en: At this point, I chose to stop the use case as what we’ve covered demonstrates
    the way in which different types of LLMs can help me in different ways. Copilot
    offers the ability to rapidly generate code, but it requires code-based prompts
    to help it with its suggestions. What this means is that if we’re working on a
    fresh project that has very little production code for our LLM to analyze, we’re
    more likely to get results from Copilot that aren’t useful to us. So, to improve
    the quality of the output from Copilot, we give it more context using unit checks.
    This helps not only guide Copilot in the building of our code, but also provides
    us with the benefits of TDD including well-designed, testable code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我选择停止使用用例，因为我们所涵盖的内容展示了不同类型的LLM如何以不同的方式帮助我。Copilot提供了快速生成代码的能力，但它需要基于代码的提示来帮助它提出建议。这意味着如果我们正在处理一个全新的项目，其中几乎没有用于我们的LLM分析的生产代码，那么我们更有可能从Copilot那里得到对我们无用的结果。因此，为了提高Copilot输出的质量，我们通过单元测试提供更多的上下文。这不仅有助于引导Copilot构建我们的代码，还为我们提供了TDD（测试驱动开发）的好处，包括设计良好的、可测试的代码。
- en: With ChatGPT, we’ve demonstrated that it can be a useful tool for analysis when
    prompted correctly. Building prompts able to analyze ideas and code and suggest
    risks and improvements can rapidly offer us alternative perspectives to consider,
    which we can then either act upon or reject. Utilizing the LLM as a simulation
    of a role that advocates quality can help us improve our work.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ChatGPT，我们已经证明，当正确提示时，它可以是一个有用的分析工具。构建能够分析想法和代码、提出风险和改进的提示，可以迅速为我们提供考虑的替代视角，我们随后可以选择采取行动或拒绝。利用LLM作为倡导质量的角色的模拟可以帮助我们改进我们的工作。
- en: 4.5 Improving documentation and communication with LLMs
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 使用LLM改进文档和沟通
- en: It might not seem so, but communicating the work we’ve done through code comments
    and release notes can contribute significantly to product quality. By sharing
    new developments and changes to code bases, we can help fellow developers understand
    how our work affects theirs, guide testers in what to focus on when testing our
    work, and even help how users view our products (for example, Slack’s early release
    notes helped market their tooling with their clear communication and humor).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来不太明显，但通过代码注释和发布说明来传达我们所做的工作可以显著提高产品质量。通过分享代码库的新发展和变化，我们可以帮助其他开发者理解我们的工作如何影响他们，指导测试人员在测试我们的工作时关注什么，甚至帮助用户如何看待我们的产品（例如，Slack的早期发布说明通过清晰的沟通和幽默帮助他们推广工具）。
- en: Despite these benefits, documentation and release notes are sometimes left to
    languish at the end of a development cycle or are ignored entirely. This makes
    sense, given the time required to write and maintain code comments and release
    notes that are useful and relevant, especially when there is time pressure to
    be constantly delivering new features. However, with the use of LLMs, we can reduce
    that time overhead while ensuring we generate useful documentation that creates
    value for future readers. So, let’s take a look at some useful prompts that can
    rapidly generate documentation for us.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些好处，但文档和发布说明有时会被留到开发周期的最后，或者完全被忽视。考虑到编写和维护有用且相关的代码注释和发布说明所需的时间，这是有道理的，尤其是在有压力不断交付新功能的时候。然而，使用LLM，我们可以减少这种时间开销，同时确保我们生成对未来的读者有价值的文档。因此，让我们看看一些可以快速为我们生成文档的有用提示。
- en: 4.5.1 Generating code comments
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 生成代码注释
- en: 'Although we should always strive to create code arranged in a way that is fluent
    and easy to parse, regardless of experience with a code base, code comments can
    provide the extra detail that prevents code misuse and speeds up development.
    This is even more important if we’re releasing APIs that will be used by others.
    (I’ve on many occasions wasted time trying to understand how a library works from
    poorly documented API docs.) The challenge is to get the right balance in code
    comments: too few, and the person reading your code is left to fend for themselves;
    too much, and we create more work for ourselves in maintaining code and comments
    to ensure they align.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们应该始终努力创建流畅且易于解析的代码，无论对代码库的经验如何，代码注释可以提供额外的细节，防止代码误用并加快开发速度。如果我们发布的API将被他人使用，这一点尤为重要。（我曾在许多场合浪费时间试图从文档不佳的API文档中理解库的工作原理。）挑战在于在代码注释中找到正确的平衡：注释太少，阅读你代码的人将不得不自行应对；注释太多，我们在维护代码和注释以确保它们一致时将产生更多的工作。
- en: 'So, instead, let’s take a look at a prompt that can take care of the process
    of annotating our work with comments for us. I use the check-the-solution tactics
    to ensure the code is not altered:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看一个可以为我们处理用注释标注我们工作的过程的提示。我使用检查解决方案的策略来确保代码没有被更改：
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a Java Developer. Update the code delimited by three hashes and add
    in code comments to explain how the code works. Check that no parts of the code
    have been changed before outputting the completed code commented code. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 你是一位Java开发者。更新由三个井号分隔的代码，并添加代码注释来解释代码的工作原理。在输出完整的带注释代码之前，请检查代码的任何部分都没有被更改。
    |'
- en: 'Next, I use delimiter tactics to state where the code is:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我使用分隔符策略来指出代码的位置：
- en: '|'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In this prompt, we use the usual delimiter tactics to provide our code that
    we would like to see commented, but we also want to ensure that the LLM doesn’t
    change our code to make it align with the comments it creates. So, we also make
    it explicit within the prompt to check that no parts of the code have been changed
    before outputting the completed commented code. Sending this prompt with our example
    code from earlier to ChatGPT returned the following commented code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个提示中，我们使用通常的分隔符策略来提供我们希望看到注释的代码，但我们还想要确保大型语言模型（LLM）在输出完整的带注释代码之前不会更改我们的代码以使其与创建的注释相匹配。因此，我们在提示中也明确指出，在输出完整的带注释代码之前，请检查代码的任何部分都没有被更改。将我们之前提供的示例代码发送到ChatGPT后，返回了以下带注释的代码：
- en: '|'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: As we can see, the methods and sections of code within them have now been annotated
    with comments to give us more detail. What stands out most are comments such as
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码中的方法和代码段现在已经被注释标注，以提供更多细节。最引人注目的是如下注释：
- en: '|'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The comment provides not only references to what `ConcurrentHashMap` is used
    for, but also highlights that all project names will be stored in lowercase, a
    reference to part of the code inside `submitTimesheet`, which does stand in contrast
    to comments like these that feel a little unnecessary:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注释不仅提供了关于`ConcurrentHashMap`用途的参考，还强调了所有项目名称都将存储为小写，这是对`submitTimesheet`内部代码的一部分的引用，这与这些感觉有点不必要的注释形成对比：
- en: '|'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Once again, we choose what to use. Although the prompt we’ve used has provided
    us with comments, we’ve observed that some are probably more useful than others.
    Thus, our role changes from being the author of comments to an editor, selecting
    and tweaking the comments that seem the most useful.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们选择使用什么。虽然我们使用的提示已经为我们提供了注释，但我们观察到其中一些可能比其他的有用。因此，我们的角色从注释的作者转变为编辑，选择和调整看起来最有用的注释。
- en: Maintaining code comments with prompts
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提示维护代码注释
- en: What makes this process so useful is that when we inevitably come to a point
    in which our code changes and our comments need updating, we simply can run the
    prompt again with our updated code to regenerate our comments to incorporate our
    changes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个过程如此有用的原因是，当我们不可避免地到达代码更改而注释需要更新的时候，我们只需再次运行提示并使用更新的代码来重新生成注释，以包含我们的更改。
- en: 'A final observation is that although the comments can be useful for someone
    reading our code directly, what if we want to provide more structured documentation
    in the form of, say, Javadoc? In that case, we can modify the prompt and use structured
    data tactics to create a prompt. We’ll use an updated prompt with structured data
    tactics for Javadoc:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最后的观察是，尽管注释对于直接阅读我们代码的人来说可能很有用，但如果我们想以Javadoc等形式提供更结构化的文档呢？在这种情况下，我们可以修改提示并使用结构化数据策略来创建一个提示。我们将使用带有结构化数据策略的更新提示来生成Javadoc：
- en: '|'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a Java Developer. Update the code delimited by three hashes and add
    in code comments in a Javadoc format to explain how the code works. Check that
    no parts of the code have been changed before outputting the completed code commented
    code. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 你是一位Java开发者。更新以下由三个井号分隔的代码，并添加Javadoc格式的代码注释来解释代码的工作原理。在输出完整的带注释代码之前，请检查代码的任何部分都没有被更改。|'
- en: 'We then provide the code using delimiter tactics:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后提供使用分隔符策略的代码：
- en: '|'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Sending this prompt with our example code to ChatGPT produces
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 将此提示与我们的示例代码一起发送到ChatGPT产生
- en: '|'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Using this prompt, we’ve improved the quality of some of the comments and also
    created Javadoc-friendly comments that can be used to document our code for external
    users. Now we only have to tweak and edit at the points we see fit.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个提示，我们提高了某些注释的质量，并创建了Javadoc友好的注释，这些注释可以用来为外部用户记录我们的代码。现在我们只需要调整和编辑我们认为合适的地方。
- en: 4.5.2 Generating release notes
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 生成发布说明
- en: 'Just as we can use a LLM to modify our code to add comments, we can also use
    LLMs to transform our code base into release notes that can be consumed by others
    in the team and beyond. To do this, we create a new prompt with the following
    details; we check the solution tactics to ensure the release notes are legible:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以使用大型语言模型（LLM）来修改我们的代码以添加注释一样，我们也可以使用LLM将我们的代码库转换成可以被团队内外其他人消费的发布说明。为此，我们创建了一个包含以下细节的新提示；我们检查解决方案策略以确保发布说明可读：
- en: '|'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a Java Developer. Convert the code delimited by three hashes into
    a bullet-pointed set of release notes that describes how the code works. Check
    that the release notes can be read by someone who has no experience with the code
    created before outputting it. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 你是一位Java开发者。将以下由三个井号分隔的代码转换为以项目符号形式呈现的发布说明，描述代码的工作原理。在输出之前，请检查发布说明是否可以被没有使用过之前创建的代码的人阅读。
    |'
- en: 'We add an additional instruction to reduce the wordiness of the release notes:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个额外的指令来减少发布说明的冗长性：
- en: '|'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|    *   Only output the release notes. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|   *   仅输出发布说明。|'
- en: 'Then we use delimiter tactics to state where the code is:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用分隔符策略来指明代码的位置：
- en: '|'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The prompt follows a similar pattern to the previous code comment-focused prompt,
    but this time, instead of asking it to inject comments into our code, we instruct
    that the code be transformed into natural language release notes. For example,
    sending the prompt with the sample code to ChatGPT returned
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 该提示遵循与之前针对代码注释的提示相似的格式，但这次，我们不是要求它向我们的代码中注入注释，而是指示将代码转换为自然语言的发布说明。例如，将包含示例代码的提示发送到ChatGPT返回
- en: '|'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Release Notes:   *   The code defines a Java class named `Timesheet` that
    is used to manage timesheet data.   *   It uses a `ConcurrentHashMap` to store
    timesheet entries, where project names (in lowercase) are associated with their
    respective durations (in hours).   *   The `submitTimesheet` method allows users
    to submit timesheet entries. It requires a project name and a positive duration
    as parameters. If these conditions are met, it stores the duration associated
    with the project name in the map. If not, it returns false.   *   The `getTimesheets`
    method returns a collection of all recorded timesheet durations.   *   The `getTotalTimesheetHours`
    method allows users to retrieve the total duration for a specific project name
    (case-insensitive). If the project name is not found, it returns 0.Note: Ensure
    that project names are provided in lowercase when using the `submitTimesheet`
    method to avoid case sensitivity issues when retrieving total timesheet hours.
    |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 发布说明：   *   该代码定义了一个名为 `Timesheet` 的 Java 类，用于管理时间表数据。   *   它使用 `ConcurrentHashMap`
    来存储时间表条目，其中项目名称（小写）与其相应的持续时间（小时）相关联。   *   `submitTimesheet` 方法允许用户提交时间表条目。它需要一个项目名称和正持续时间作为参数。如果满足这些条件，它将在映射中存储与项目名称关联的持续时间。如果不满足，则返回
    false。   *   `getTimesheets` 方法返回所有记录的时间表持续时间集合。   *   `getTotalTimesheetHours`
    方法允许用户检索特定项目名称的总持续时间（不区分大小写）。如果找不到项目名称，则返回 0。注意：在使用 `submitTimesheet` 方法时，请确保提供小写的项目名称，以避免在检索总时间表小时数时出现大小写敏感问题。
    |'
- en: 'The result we get is in a completely different format compared to our original
    code that attempts to detail what our code base does. Reviewing the output, it
    does feel quite technical, which makes sense considering we’ve asked for detailed
    notes on a small amount of code. However, even these release notes can be of use
    because we can adapt an earlier prompt for suggesting risks to analyze the notes.
    We use delimiters to signal where the release notes will be:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果与我们的原始代码完全不同的格式，原始代码试图详细说明我们的代码库做了什么。审查输出，它确实感觉相当技术性，这是有道理的，因为我们要求对一小段代码提供详细的说明。然而，即使这些发布说明也可能有用，因为我们可以根据早期提示的风险分析来调整提示。我们使用分隔符来指示发布说明的位置：
- en: '|'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| You are a software testing expert. Analyze the release notes delimited by
    triple hashes and identify risks that might impact the code. If no code is provided,
    respond with “No risks could be found.” |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 您是一位软件测试专家。分析由三重哈希分隔的发布说明，并识别可能影响代码的风险。如果没有提供代码，请回答“没有找到风险。” |'
- en: 'We then provide instructions around quality characteristics and output structure:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后提供有关质量特性和输出结构的说明：
- en: '|'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '|    *   Risks must be related to the quality characteristics: Performance,
    security and interoperability   *   Multiple risks can be identified for each
    quality characteristic   *   Output identified risks in the format of Risk - Quality
    Characteristic - Explanation |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|    *   风险必须与质量特性相关：性能、安全性和互操作性   *   每个质量特性都可以识别出多个风险   *   以“风险 - 质量特性 -
    说明”的格式输出已识别的风险 |'
- en: Few-shot prompting allows us to give an example of output structure
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 少样本提示允许我们给出输出结构的示例
- en: '|'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| Example:Overflow - Security - Adding in large integers as parameters might
    cause the method to trigger a buffer overflow. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| 示例：溢出 - 安全性 - 将大整数作为参数添加可能会导致方法触发缓冲区溢出。 |'
- en: 'Release notes are provided within the instructed delimiters:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 发布说明位于指定的分隔符内：
- en: '|'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/logo-MW.png)'
- en: '| ###Release Notes:   *   The code defines a Java class named `Timesheet` that
    is used to manage timesheet data.   *   It uses a `ConcurrentHashMap` to store
    timesheet entries, where project names (in lowercase) are associated with their
    respective durations (in hours).   *   The `submitTimesheet` method allows users
    to submit timesheet entries. It requires a project name and a positive duration
    as parameters. If these conditions are met, it stores the duration associated
    with the project name in the map. If not, it returns false.   *   The `getTimesheets`
    method returns a collection of all recorded timesheet durations.   *   The `getTotalTimesheetHours`
    method allows users to retrieve the total duration for a specific project name
    (case-insensitive). If the project name is not found, it returns 0.Note: Ensure
    that project names are provided in lowercase when using the `submitTimesheet`
    method to avoid case sensitivity issues when retrieving total timesheet hours.###
    |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| ### 发布说明：   *   代码定义了一个名为 `Timesheet` 的 Java 类，用于管理考勤数据。   *   它使用 `ConcurrentHashMap`
    存储考勤条目，其中项目名称（小写）与其相应的持续时间（小时）相关联。   *   `submitTimesheet` 方法允许用户提交考勤条目。它需要项目名称和正数持续时间作为参数。如果满足这些条件，它将在映射中存储与项目名称关联的持续时间。如果不满足，则返回
    false。   *   `getTimesheets` 方法返回所有记录的考勤持续时间集合。   *   `getTotalTimesheetHours`
    方法允许用户检索特定项目名称的总持续时间（不区分大小写）。如果找不到项目名称，则返回 0。注意：在使用 `submitTimesheet` 方法时，请确保提供小写项目名称，以避免在检索总考勤小时数时出现大小写敏感问题。###
    |'
- en: 'Using this prompt in ChatGPT returned the following suggested risks:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此提示在 ChatGPT 返回以下建议风险：
- en: '|'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Concurrent Modification - Performance - The use of `ConcurrentHashMap` may
    not be suitable for high concurrent access, leading to performance bottlenecks
    if there are frequent modifications to the timesheet entries by multiple users
    simultaneously.Lack of Input Validation - Security - The `submitTimesheet` method
    lacks proper input validation. It only checks for positive durations but does
    not validate the project name, making it vulnerable to injection attacks or other
    malicious input.Case Sensitivity - Interoperability - The requirement to provide
    project names in lowercase may lead to interoperability issues when integrating
    with systems that expect case-insensitive input or have different naming conventions.No
    Authentication/Authorization - Security - The release notes do not mention any
    authentication or authorization mechanisms, which can pose security risks if unauthorized
    users can submit or access timesheet data.Data Exposure - Security - The `getTimesheets`
    method provides access to all recorded timesheet durations, which might expose
    sensitive information if not properly restricted or authenticated. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 并发修改 - 性能 - 使用 `ConcurrentHashMap` 可能不适合高并发访问，如果多个用户同时频繁修改考勤条目，可能会导致性能瓶颈。输入验证不足
    - 安全 - `submitTimesheet` 方法缺少适当的输入验证。它只检查正数持续时间，但不验证项目名称，使其容易受到注入攻击或其他恶意输入的攻击。大小写敏感
    - 互操作性 - 需要使用小写字母提供项目名称的要求，在集成期望不区分大小写输入或具有不同命名约定的系统时可能导致互操作性问题。无身份验证/授权 - 安全
    - 发布说明中没有提及任何身份验证或授权机制，如果未经授权的用户可以提交或访问考勤数据，可能会带来安全风险。数据暴露 - 安全 - `getTimesheets`
    方法提供了对所有记录的考勤持续时间的访问，如果不适当限制或验证，可能会暴露敏感信息。 |'
- en: Of course, this might be an unnecessary step if we can directly ask an LLM to
    suggest risks based on the code directly, but it does demonstrate the power of
    LLM’s ability to transform data from one format to another.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们可以直接要求大型语言模型（LLM）根据代码直接提出风险，这可能是一个不必要的步骤，但它确实展示了 LLM 将数据从一种格式转换为另一种格式的强大能力。
- en: 4.6 Maintaining a balance with code assistants
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 与代码助手保持平衡
- en: The perspective on the value that tools such as Copilot and ChatGPT offer depends
    on individuals. For some, it means the automation of development and the loss
    of many roles, and for others, it’s nothing but an advanced tool that randomly
    picks suggested code. What this chapter demonstrates is the ongoing theme that
    their worth and usefulness lie somewhere between those two extremes.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 Copilot 和 ChatGPT 这样的工具所提供的价值的看法取决于个人。对于一些人来说，这意味着开发和许多职位的自动化，而对于另一些人来说，它只是一个随机选择建议代码的高级工具。这一章所展示的是，它们的价值和用途介于这两个极端之间。
- en: These models, trained on masses of data from Stack Overflow and GitHub repositories,
    are very sophisticated in what they suggest for both production and test code.
    But they still require direction from us humans—direction that is guided by our
    abilities to communicate with stakeholders, analyze requirements, and design implementation.
    How well we can use AI tools in development depends on honing our complementary
    skills, which can be summarized by using the area-of-effect model shown in figure
    4.2.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型在Stack Overflow和GitHub存储库的大量数据上训练，在建议生产代码和测试代码方面非常复杂。但它们仍然需要我们人类的指导——这种指导是由我们与利益相关者沟通、分析需求和设计实现的能力所引导的。我们能在多大程度上在开发中使用AI工具，取决于我们磨练互补技能的能力，这可以通过图4.2所示的影响区域模型来总结。
- en: A balanced approach can help us deliver features faster but still ensure that
    we build in quality. So, our goal is to maintain that balance in situations in
    which we may need to rely on our own abilities or the features of our tools. Sometimes,
    code assistants won’t be able to suggest the correct implementation, and we need
    to take charge. This gives us more control but does sacrifice speed. At other
    times, we can rely on code assistant tools to reference vast amounts of data to
    suggest new design ideas through unit checks or conversations. However, we want
    to ensure that we keep our TDD loops focused on design and not on test coverage.
    Too many unit checks, and we lose sight of our design and end up in a box-checking
    activity.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡的方法可以帮助我们更快地交付功能，但仍然确保我们构建的质量。因此，我们的目标是保持这种平衡，在可能需要依赖我们自身能力或工具特性的情况下。有时，代码助手可能无法建议正确的实现，我们需要承担责任。这给了我们更多的控制权，但牺牲了速度。在其他时候，我们可以依赖代码助手工具通过单元检查或对话来参考大量数据，以提出新的设计想法。然而，我们希望确保我们保持TDD循环专注于设计，而不是测试覆盖率。单元检查过多，我们就会失去对设计的关注，最终陷入检查框子的活动中。
- en: '![](../../OEBPS/Images/CH04_F02_Winteringham2.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F02_Winteringham2.png)'
- en: Figure 4.2 An area-of-effect model, updated to demonstrate the skills of a human
    and the abilities of code assistant tools
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：影响区域模型，更新以展示人类技能和代码助手工具的能力
- en: Summary
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The majority of generative AI tools currently on the market rely on LLMs trained
    with vast amounts of data scraped from the internet.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前市场上大多数生成式AI工具都依赖于使用从互联网上抓取的大量数据训练的LLMs。
- en: LLMs are sophisticated algorithms that apply statistical analysis to our requests
    to determine what output they should respond with.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLMs是复杂的算法，它们通过对我们的请求进行统计分析，以确定它们应该响应什么输出。
- en: Copilot is a coding assistant tool that uses the OpenAI GPT-4 and is trained
    on code stored on GitHub.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot是一个使用OpenAI GPT-4的编码助手工具，它是在GitHub上存储的代码上训练的。
- en: Copilot works within an IDE and reads your code as a prompt to suggest what
    to add next into test code and production code.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot在IDE中工作，并将你的代码作为提示来建议接下来应该添加到测试代码和生产代码中的内容。
- en: Tools such as Copilot can work well with the TDD red/green/refactor loop to
    help us rapidly create unit checks and production code.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如Copilot之类的工具可以很好地与TDD的红色/绿色/重构循环一起工作，帮助我们快速创建单元检查和生产代码。
- en: To help Copilot return code that is valuable, we need to guide it with prompts.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助Copilot返回有价值的代码，我们需要通过提示来引导它。
- en: Success with AI code assistants depends on our understanding of our abilities
    and the features of code assistant tools.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI代码助手的成功取决于我们对自身能力和代码助手工具特性的理解。
- en: There is push–pull relationship between how much we are leading versus the tooling
    leading design.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们主导与工具主导的设计之间存在推拉关系。
- en: We must be aware of the tradeoffs when the balance shifts from humans to tools
    leading.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当平衡从人类转向工具主导时，我们必须意识到其中的权衡。
