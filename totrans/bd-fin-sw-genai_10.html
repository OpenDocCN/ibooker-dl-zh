<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">8</span> </span><span class="chapter-title-text">Exceptions</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header"><span class="CharOverride-2">This chapter covers</span><span class="CharOverride-2"/></h3>
<ul>
<li class="readable-text" id="p2"><span class="CharOverride-3">Initial feedback from the MVP</span></li>
<li class="readable-text" id="p3"><span class="CharOverride-3">Planning and addressing user requests</span></li>
<li class="readable-text" id="p4"><span class="CharOverride-3">Identifying different types of exceptions</span></li>
<li class="readable-text" id="p5"><span class="CharOverride-3">Updating the dashboard</span></li>
<li class="readable-text" id="p6"><span class="CharOverride-3">Ensuring our UI is responsive</span></li>
</ul>
</div>
<div class="readable-text" id="p7">
<p>In chapter 7, we successfully launched our minimum viable product (MVP) to our user base to help solicit feedback and drive enhancements to the product. The feedback varied significantly—from users who loved the new direction of the dashboard to those who expressed their dissatisfaction, feeling it was missing too much functionality although it was not meant to be a full replacement yet. The business now wants us to both capitalize on what went well and address some of the missing functionality the users are currently clamoring for. </p>
</div>
<div class="readable-text intended-text" id="p8">
<p>By far, the biggest need recognized in our MVP was having a wider variety of ACH-related exceptions and making their handling possible within the user interface. This chapter identifies different categories of exceptions and ways to identify and potentially recover from them. </p>
</div>
<div class="readable-text" id="p9">
<h2 class="readable-text-h2"><span class="num-string">8.1</span> Planning enhancements</h2>
</div>
<div class="readable-text" id="p10">
<p>The benefit of providing our target audience with an MVP is that we can get feedback from them and then use it to determine which features need to be added to the software. This advantage allows us to concentrate on items that deliver the most value. In this instance, we want to focus on providing a way to view ACH exceptions in the UI, as well as to search through our loaded files, which will help us find a much-needed and practical enhancement to the application as users must be aware of exceptions that prevent further processing of ACH files. This is especially valuable because we focus on Prearranged Payment and Deposit (PPD) ACH transactions, meaning that payroll and bill payments are at risk of not being processed. </p>
</div>
<div class="readable-text intended-text" id="p11">
<p>Depending on our circumstances, we may have a normal sprint to complete our work, or if the need is dire enough, we may be expected to turn around changes and fixes sooner. We will also likely see user stories written for these items, such as</p>
</div>
<ul>
<li class="readable-text" id="p12">As an operator, I want to be able to view processing exceptions and be aware of potential ACH problems that need to be resolved so that transactions are not delayed in posting to a customer’s account.</li>
<li class="readable-text" id="p13">As an operator, I want to be able to search for specific transactions so I can research items for customer inquiries.</li>
</ul>
<div class="readable-text" id="p14">
<p>In either case, providing stakeholders with a timeline or Gantt chart for the project can be beneficial. These visualizations are especially helpful if we find ourselves with a hard deadline. We often work backward from that deadline, trying to complete the expected tasks, while fitting them all within the allotted time. Of course, the required timeframe may not be possible, and having it laid out for management is a great way to help make our case for more time should we need it. Again, we rely on PlantUML to provide us with a simple Gantt chart we can share with the stakeholders. The following listing shows the required syntax.</p>
</div>
<div class="browsable-container listing-container" id="p15">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.1<span class="CharOverride-4"> </span>PlantUML syntax for a Gantt chart</h5>
<div class="code-area-container">
<pre class="code-area">@startgantt
saturday are closed  #1
sunday are closed    

header ACH Dashboard Enhancements - Round 1 #2

Project starts 2024-08-01 
-- Exceptions Enhancement -- #3
[Database Design] starts 2024-08-01 and lasts 2 days #4
[Exception API Design] starts at [Database Design]'s#5
<span class="CharOverride-6">➥</span> end and lasts 2 days  #5
[ACH Processor] starts at [Exception API Design]'s #5
<span class="CharOverride-6">➥</span> end and lasts 3 days #5
[UI Exception Changes] starts at [ACH Processor]'s #5
<span class="CharOverride-6">➥</span> end and lasts 3 days #5

-- UI Enhancement –
[Update fields screen] starts at 2024-08-01 and lasts 3 days
[Update batch screen] starts at [Update fields screen]'s
<span class="CharOverride-6">➥</span> end and lasts 3 days
[Sprint Complete] happens at [UI Exception Changes]'s end
@endgantt</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Excludes weekends from our chart because we do not want to work overtime</span>
<br/>#2 
     <span class="CharOverride-5">A header for the chart</span>
<br/>#3 
     <span class="CharOverride-5">Creates a visual </span>
<span class="CharOverride-5">break in the chart</span>
<br/>#4 
     <span class="CharOverride-5">Creates a task with a start time and duration</span>
<br/>#5 
     <span class="CharOverride-5">Tasks can be dependent on other tasks.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p16">
<p>This listing produces the chart shown in figure 8.1. As we mentioned, such charts are helpful for visualizing the work and are often appreciated by project stakeholders.</p>
</div>
<div class="browsable-container figure-container" id="p17">
<img alt="A diagram of a project  Description automatically generated" height="434" src="../Images/CH08_F01_Kardell.png" style="width: 100%; max-width: max-content;" width="483"/>
<h5 class="figure-container-h5">Figure 8.1 A Gantt Chart for our enhancements</h5>
</div>
<div class="readable-text" id="p18">
<p>Now that we have outlined the initial work for this sprint, we can start tackling the steps needed to add exceptions to our application.</p>
</div>
<div class="readable-text" id="p19">
<h2 class="readable-text-h2"><span class="num-string">8.2</span> Exceptions and warnings</h2>
</div>
<div class="readable-text" id="p20">
<p>Remember that we prefer working here in short development cycles, as shown in figure 8.2. In step 1, we need to create an ACH file with our desired exception condition, which means we will be updating the <code>ach_file_creation.feature</code> and associated test_create_ach_files.py<code> </code>to support creating files with our desired exception. In step 2, we support the new exception by updating the ach_file_processor.py, either by diving right in and starting to work on it or by creating unit tests in a more test-driven development (TDD) fashion. Finally, in step 3, we update the actual UI for the dashboard to support viewing and displaying of the exceptions. </p>
</div>
<div class="readable-text intended-text" id="p21">
<p>Although the steps are going to be covered in separate sections, note that we would likely be working on each individual exception through these general steps. And as we work through each exception, we will notice improvements/refinements that can be made. </p>
</div>
<div class="browsable-container figure-container" id="p22">
<img alt="A diagram of a software system  Description automatically generated" height="250" src="../Images/CH08_F02_Kardell.png" style="width: 100%; max-width: max-content;" width="446"/>
<h5 class="figure-container-h5">Figure 8.2 Flowchart representing our short development cycle</h5>
</div>
<div class="readable-text" id="p23">
<p>First, we need to define exactly what we mean when we use the terms “exception,” “error,” and “warning.” They may seem somewhat interchangeable, but for our purposes, we would like to provide some background information on what we have in mind when talking about each. Please bear in mind that these are our own definitions and not a reflection of any fintech or Nacha standards.</p>
</div>
<ul>
<li class="readable-text" id="p24"><em>Erro</em><em>r</em>—A condition that prevents processing from taking place. We can think of errors as conditions such as an incomplete file upload or a bug in our software that causes processing to halt. Some conditions would cause an error, such as having a record with a record type code that does not exist in the ACH standard (e.g., record type code 2) because we do not have a place for this record in the database.</li>
<li class="readable-text" id="p25"><em>Exceptio</em><em>n</em>—A business condition that would prevent file processing, which could include an improperly formatted file, invalid data in the file, or conditions the business has defined that should stop processing. Examples of these business conditions may be transactions over certain amounts, flagged customers, or other transaction activity that may cause concern.</li>
<li class="readable-text" id="p26"><em>Warnin</em><em>g</em>—A business condition that requires notification but does not necessarily prevent the file from being processed. Warnings may allow us to show leniency in enforcing ACH rules for files or customers. For instance, if the count on a control record is incorrect, the business may allow this discrepancy and process the file anyway.</li>
</ul>
<div class="readable-text" id="p27">
<p>As we can see, there are slight differences in the conditions and responses for these different categories. We should also have the recovery or research steps documented clearly in case an error is encountered. We have been involved in supporting software in the middle of the night where an explicit check was done within the code but without any indication of why the condition may occur, how to resolve it, or whether it is important. More than once, it was not important enough to stop the processing, and the code would be commented out so the check could be bypassed. This story illustrates the need to determine the severity of exceptions, and when and where they should be reported. Figure 8.3 shows a flowchart that can help you when deciding whether an exception needs to halt processing or it can be handled differently.</p>
</div>
<div class="browsable-container figure-container" id="p28">
<img alt="A diagram of a flowchart  Description automatically generated" height="330" src="../Images/CH08_F03_Kardell.png" style="width: 100%; max-width: max-content;" width="867"/>
<h5 class="figure-container-h5"><span class="">Figure 8.3</span><span class=""> </span><span class="">Flow chart for deciding how to handle errors</span></h5>
</div>
<div class="readable-text" id="p29">
<p>To summarize, we should be thinking about</p>
</div>
<ul>
<li class="readable-text" id="p30">Whether this is a problem that requires halting processing</li>
<li class="readable-text" id="p31">Whether it can be reported to the user in a timely manner</li>
<li class="readable-text" id="p32">Whether this is something that can wait but does need to be resolved eventually</li>
</ul>
<div class="readable-text" id="p33">
<p>Too often, we may create alerts, messages, and reports that are ignored and dismissed by users before corrective action is taken. It can be a balancing act as different products or business needs require different approaches.</p>
</div>
<div class="readable-text intended-text" id="p34">
<p>From our software and development perspective, we must consider these different types of errors and warnings. It is also important to understand that the Federal Reserve has their own way of looking at a file’s ACH status. These statuses can be <code>accept</code>, <code>pend</code>, or <code>reject</code> and are exactly what you might expect:</p>
</div>
<ul>
<li class="readable-text" id="p35"><code>accept</code>—The file is good and has been accepted by the Federal Reserve.</li>
<li class="readable-text" id="p36"><code>pend</code>—The financial institution must confirm that the file should be accepted or rejected. This usually happens when there is some potential exception that may occur due to the formatting or contents of the file.</li>
<li class="readable-text" id="p37"><code>reject</code>—A condition/error causes the file to be rejected. This is an error state we may also end up with when the financial institution chooses to reject a file that was previously in a <code>pend</code> state or when the Federal Reserve flat-out rejects a file.</li>
</ul>
<div class="readable-text" id="p38">
<p>It should be noted that when files are corrected, there should be an audit trail. If a file is modified, the originator of the file may need to be notified. Otherwise, these changes may lead to confusion when attempting to research problems. We can imagine trying to speak with someone about a file where the file ID was corrected from a numeric to a letter without any indication it was done. It could lead to some frustrating interactions, with someone at the financial institution claiming not to see a file although the user clearly sees the transaction hitting their account.</p>
</div>
<div class="readable-text" id="p39">
<h2 class="readable-text-h2"><span class="num-string">8.3</span> Creating ACH files with exceptions</h2>
</div>
<div class="readable-text" id="p40">
<p>As part of the MVP in chapter 7, we created the <code>ach_file_creation.feature</code> that allowed us to easily create well-formatted files using the BDD-style syntax (known as Gherkin). Recall that it allowed us to create files as shown:</p>
</div>
<div class="browsable-container listing-container" id="p41">
<div class="code-area-container">
<pre class="code-area">  Scenario: Create an ACH file with a single batch and a single debit
    Given I want to create an ACH file named "ppd-single-debit.ach"
    And I want to have an immediate destination of "123456789"
    And I want to have an immediate origin of "987654321"
    And I want to have 1 batch with ACH debits only
<span class="CharOverride-6">➥</span> and a standard entry class code of "PPD"
    And I want 1 entries per batch with random amounts between 100 and 100
    And I want to use individual names of "John Doe"
    And I want to have company name "My Company"
<span class="CharOverride-6">➥</span> and company id "1234567890"
    When my ACH is created
    Then I should have a file named "ppd-single-debit.ach"
    And there should be 1 batch in the file
    And there should be 1 entries in the file</pre>
</div>
</div>
<div class="readable-text" id="p42">
<p>This works well for that happy path that we often start with, but now we need to expand our code to address some possible exceptions so we can work on building the required functionality. In some cases, our syntax may help enforce proper formatting of the ACH file, and that’s obviously a good thing. We want the creation process to be easier than creating something by hand, but now we also want to add some flexibility to the files. Eventually, we may accept CSV or other formatted files that would make customizing the fields easy. For now, we can look to expand and hopefully improve our syntax.</p>
</div>
<div class="readable-text" id="p43">
<h3 class="readable-text-h3"><span class="num-string">8.3.1</span> Creating ACH files with file-level exceptions</h3>
</div>
<div class="readable-text" id="p44">
<p>File-level errors and warnings will have to do with either the file header (type 1) or the file trailer (type 9) records. Many of the exceptions we might encounter stem from formatting problems with the file, and we would like to be able to introduce the following exceptions:</p>
</div>
<ul>
<li class="readable-text" id="p45"><em>File ID is not an uppercase letter in the range from A to Z or a number</em>. If it is a lowercase letter, the file could be rejected, or the financial institution could decide to fix it since it is a minor problem and easily corrected. </li>
<li class="readable-text" id="p46"><em>The immediate destination should be our bank’s routing number</em>. This is important because we obviously want to ensure we are processing the correct file for the correct bank. If we were to receive a file that was intended for another institution, it could be categorized as information leakage, unauthorized disclosure, or inadvertent data sharing. Regardless of what we call it, there are serious implications in terms of customer privacy, and we may have legal and regulatory obligations. While a seemingly innocuous problem (e.g., the field didn’t match), it would be an all-hands-on-deck type event. In FinTech, there are all kinds of places where this may occur, especially when dealing with multitenant environments. For example, it could occur when storing/retrieving images, displaying transactions in a mobile or internet banking application, sending statements, or communicating to incorrect or unauthorized addresses. This change also requires us to maintain a list of routing numbers associated with the bank since we need to be able to validate them. Because of bank mergers or acquisitions, it may be possible for banks to have more than one routing number. </li>
<li class="readable-text" id="p47"><span class="CharOverride-7">Blocking factor should never change but would be an error if it did.</span> This gives us a chance to update our syntax to support setting fields and using the <code>get(field,</code> <code>default value)</code> so we do not need to have a lot of different syntax, which could then be expanded to support <code>padding-left</code>/<code>right</code>, <code>fill</code> <code>value</code>, and <code>length</code>.</li>
<li class="readable-text" id="p48"><span class="CharOverride-7">Record size is similar to the blocking factor, and we always expect a 094</span>. In theory, this field could be used to change the record format length, but in practice, systems typically just assume the 94 bytes and do not use the record size to read different-sized records. This does allow us to expand our checks to become more generic, exchanging constraints imposed by specific contexts and allowing more flexibility, but with that greater power comes more responsibility in knowing how to use it. For instance, we are adjusting the field offset for what is needed by Python. We could have left it starting at 1, so it aligned better with the ACH documentation and changed offsets within the code. </li>
<li class="readable-text" id="p49"><em>File totals</em>. The file trailer record should match the computed totals for the file</li>
<li class="readable-text" id="p50"><em>File hashing</em>. Each batch control has a hash value that is added up, truncating the result as necessary to keep the 10 lower-order digits (rightmost digits).</li>
</ul>
<div class="readable-text" id="p51">
<h3 class="readable-text-h3"><span class="num-string">8.3.2</span> Creating ACH files with batch-level exceptions</h3>
</div>
<div class="readable-text" id="p52">
<p>As we parse more of the file, we need to consider batch-level exceptions. These are specific to the batch records, and while they share some similarities to other exceptions, we may find they do not necessarily cause the entire file to be rejected. Instead, the batch itself could potentially be rejected by the system. In turn, that could cause the entire file to be rejected, or the financial institution could simply require the originator to send a new file. Some examples of batch-level exceptions are the following:</p>
</div>
<ul>
<li class="readable-text" id="p53">An invalid effective date would cause a batch error as this is the necessary information for correctly posting the file. So, whether it is missing or formatted incorrectly, there is no way to recover it, and a new file is needed. </li>
<li class="readable-text" id="p54">Invalid batch totals on the control record would cause a warning. In practice, this usually causes a file to be rejected, but it would also be possible to correct the given file so that the totals match the entries for the file to be accepted.</li>
<li class="readable-text" id="p55">Bad Standard Entry Codes (SEC) on a batch will cause an error and the batch to be rejected. There is a set list of viable SEC codes that can be used, and some of them change the parsing of the records. We have been focused on the SEC code of PPD (used in payrolls, bill payments, pensions, etc.) and will continue to do so in this chapter.</li>
</ul>
<div class="readable-text" id="p56">
<h3 class="readable-text-h3"><span class="num-string">8.3.3</span> Creating ACH files with entry-level exceptions</h3>
</div>
<div class="readable-text" id="p57">
<p>Entry-level exceptions are interesting because aside from the usual formatting exception, they can be related more to the account in our system. Covering these exceptions requires more functionality in the system, but to give you a better idea of what we mean, let’s cover some of the common entry exceptions:</p>
</div>
<ul>
<li class="readable-text" id="p58"><em>Invalid account numbe</em><em>r</em>—It could be related to formatting or simply not found on the system.</li>
<li class="readable-text" id="p59"><em>Invalid amoun</em><em>t</em>—The amounts are formatted (e.g., such as including the decimal or containing spaces).</li>
<li class="readable-text" id="p60"><em>Insufficient funds (NSF</em><em>)</em>—An account does not have funding for the transaction. This opens a lot of interesting possibilities for our project, from maintaining customer and account tables to assessing fees for transactions that cannot be processed. </li>
</ul>
<div class="readable-text" id="p61">
<h3 class="readable-text-h3"><span class="num-string">8.3.4</span> Clean-up of our file creation syntax</h3>
</div>
<div class="readable-text" id="p62">
<p>With the need to create additional files, we will be revisiting the BDD-style syntax we used to create our files. Often, this is a great place to gain some experience in refactoring code and finding little improvements to make the syntax or code more robust. Because these are normally internal facing, we can gain experience by reworking existing code and seeing the potential effects it may have.</p>
</div>
<div class="readable-text intended-text" id="p63">
<p>For instance, we had the line <code>@then(parsers.re('I</code> <code>should</code> <code>have</code> <code>a</code> <code>file</code> <code>named "(?P&lt;expected_file_name&gt;.*)"'))</code>, but there is no need to specify the filename again. Not only does it cause potential problems if we copy/paste a scenario to create a similar one, but it is just unnecessary typing. Instead, since we already have the filename stored, we can update it to become <code>@then("I</code> <code>should</code> <code>have</code> <code>a</code> <code>file</code> <code>of</code> <code>the</code> <code>same</code> <code>name")</code>. Then the code can pull in the stored filename from <code>setup_info['filename']</code> to perform the check.</p>
</div>
<div class="readable-text intended-text" id="p64">
<p>Another improvement we can look at is cleaning up the way we parsed the strings from some of our statements. We originally used regular expressions to capture the strings being used, and while that is not necessarily a problem, it does add a layer of potential confusion. We are reminded about the famous quote from Jamie Zawinski: “Some people when confronted with a problem think, 'I know, I’ll use regular expressions.’ Now they have two problems.” To fix this, we can replace our regular expressions such as <code>@given(parsers.re(r'I</code> <code>want</code> <code>to</code> <code>create</code> <code>an</code> <code>ACH</code> <code>file</code> <code>named</code> <code>"(?P&lt;filename&gt;.*)"'))</code> with a far simpler <code>@given(parsers.parse('I</code> <code>want</code> <code>to</code> <code>create</code> <code>an</code> <code>ACH file</code> <code>named</code> <code>\"{filename}\"'))</code>. Keeping our code simple ensures it’s more maintainable and less error-prone to updates when we return to it in a year or two to add more improvements.</p>
</div>
<div class="readable-text intended-text" id="p65">
<p>What other improvements can be made? Remember that we should look to balance functionality and need. We can probably add a lot of bells and whistles, but if they go unused, was that really worth the extra work? That balance is especially important when talking about internal tools that do not necessarily add value that clients can see. Our stakeholders are unlikely to be impressed if we have a full-function ACH creation utility but nothing for them to actually process those files with! </p>
</div>
<div class="readable-text" id="p66">
<h2 class="readable-text-h2"><span class="num-string">8.4</span> Expanding the ACH processing for exceptions</h2>
</div>
<div class="readable-text" id="p67">
<p>When adding the exceptions to the parser, we’ll follow a TDD approach by creating a test that will validate the intended exception has been added to the database. With the TDD approach, we expect this test to fail, and then we’ll work on adding the required logic to have a passing test. This approach may not be for everyone, but we would encourage you to try it out, if nothing else, just for a different perspective on development.</p>
</div>
<div class="readable-text" id="p68">
<h3 class="readable-text-h3"><span class="num-string">8.4.1</span> ACH exceptions in the database</h3>
</div>
<div class="readable-text" id="p69">
<p>Originally, we stored some exception text in the database. However, we may want some finer controls and less redundant data. Therefore, we create a database type called <code>ach_exception_severity</code> to limit the entries that can be used when creating exceptions. The use of an <code>ENUM</code> allows us to ensure consistency in the type and reduce redundancy in our database. The downside is that <code>ENUM</code>s are not part of the SQL standard, and therefore, they may not be implemented in your relational database management system (RDBMS). While these examples assume the use of a Postgres database (which supports <code>ENUM</code>s), it is also possible to mimic this functionality with a separate table that provides the values we would use for the <code>ENUM</code> and a foreign key relationship in that table.</p>
</div>
<div class="readable-text intended-text" id="p70">
<p>The following listing shows the creation of the <code>ENUM</code> type and our new <code>ach_exception_codes</code> table we use to store extended descriptions of the errors. </p>
</div>
<div class="browsable-container listing-container" id="p71">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.2<span class="CharOverride-4"> </span>Creating the database <code>ENUM</code> and exception code table</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TYPE ach_exception_severity AS ENUM
<span class="CharOverride-6">➥</span> ('error', 'warning', 'info'); #1

CREATE TABLE ach_exception_codes (
    ach_exception_codes_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    exception_code VARCHAR(3) NOT NULL UNIQUE,
    exception_severity ACH_EXCEPTION_SEVERITY NOT NULL, #2
    exception_description VARCHAR(255) NOT NULL
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Creates the ach_exception_severity type</span>
<br/>#2 
     <span class="CharOverride-5">Uses our type as the datatype for a field</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p72">
<p>Next, we create an exceptions table to keep track of our exceptions. There are a few approaches to this, where we have multiple tables for each specific entry (similar to having multiple ACH record types) and then tie them together with a view. However, here, we demonstrate using a single table that can hold references to other tables which contain the record we could look up the exception with. The following listing contains the <code>CREATE</code> <code>TABLE</code> statement. The important difference from our previous tables is that we use foreign key constraints, which allow <code>NULL</code> for the <code>ach_records_type_5_id</code> and <code>ach_records_type_6_id</code> fields because this information will only be populated when we have a record of that type with an exception. Note that every exception will be associated with a file, so we expect <code>ach_files_id</code> to be populated every time; therefore, we still have a <code>NOT NULL</code> constraint.</p>
</div>
<div class="browsable-container listing-container" id="p73">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.3<span class="CharOverride-4"> </span>Creating the exceptions table</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TABLE ach_exceptions (
    ach_exceptions_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ach_files_id UUID NOT NULL 
       REFERENCES ach_files(ach_files_id) 
       ON DELETE CASCADE ON UPDATE CASCADE,
    ach_records_type_5_id UUID    #1
       REFERENCES ach_records_type_5(ach_records_type_5_id)  #1
       ON DELETE CASCADE ON UPDATE CASCADE,  #1
    ach_records_type_6_id UUID REFERENCES     #1
       ach_records_type_6(ach_records_type_6_id)   #1
       ON DELETE CASCADE ON UPDATE CASCADE,  #1
    record_number NUMERIC NOT NULL,
    exception_code VARCHAR(3) NOT NULL REFERENCES  #2
    <span>ach_exception_codes(exception_code)             </span> #2
<span>                                </span>ON UPDATE CASCADE   
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">These fields are not always used and can be NULL.</span>
<br/>#2 
     <span class="CharOverride-5">The exception code details are referenced in ach_exception_codes.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p74">
<p>Adding data to our table is part of the database startup. We do this because these are standard errors we can consider being shipped with the product. Often, we find these types of tables or settings that are part of the setup for a financial institution.</p>
</div>
<div class="browsable-container listing-container" id="p75">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.4<span class="CharOverride-4"> </span>Adding data to the exceptions table</h5>
<div class="code-area-container">
<pre class="code-area">INSERT INTO ach_exception_codes (exception_code,#1
  exception_severity, exception_description)  #2
VALUES ('001', 'error', 'Record length is not 94 characters');  #2
INSERT INTO ach_exception_codes
 (exception_code, exception_severity, exception_description)
 VALUES ('002', 'error', 'Record type was an unexpected value');
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Each exception needs to be inserted into the database.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p76">
<p>Adding this type of persistent data is necessary for the dashboard; however, it does add a level of complexity. Our tests become dependent on these tables being defined and the data populated. We also ran into a problem because our unit tests were truncating all tables to ensure the database was clean. The following listing shows the changes to a portion of the truncate script so that we can understand the needed changes to the <code>SqlUtils.truncate_all()</code>. We may want to consider updating the name (or at the very least the documentation) so that it is understood that <code>truncate_all</code> is not actually truncating all data anymore.</p>
</div>
<div class="browsable-container listing-container" id="p77">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.5<span class="CharOverride-4"> </span>Updating the <code>truncate</code> script</h5>
<div class="code-area-container">
<pre class="code-area">EXECUTE (
   SELECT 'TRUNCATE TABLE ' || 
          string_agg(quote_ident(table_name), ', ') || 
          ' CASCADE'
   FROM information_schema.tables
   WHERE table_schema = 'public'
   AND table_type = 'BASE TABLE'
   AND table_name NOT IN ( 'ach_exception_codes', #1
                       'ach_recovery_options',    #1
                       'bank_routing_numbers')   
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">We have tables that need to be skipped from our truncate logic </span>
<span class="CharOverride-5">as they contain hardcoded values.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p78">
<p>Although we may not be overly burdened by this approach now, there will likely come a time when we’ll have to manage the test database a bit better. A popular option is to use Testcontainers (<a href="https://testcontainers.com/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/testcontainers.com/</span></a>), which allows us to create temporary Docker containers that contain our database and will not persist beyond the lifespan of our test. This provides obvious advantages when dealing with unit testing, especially when it comes to tests run within the CI/CD pipeline.</p>
</div>
<div class="readable-text" id="p79">
<h3 class="readable-text-h3"><span class="num-string">8.4.2</span> Recovery options</h3>
</div>
<div class="readable-text" id="p80">
<p>Before updating the ACH parser to support our new exceptions, let’s take a moment to consider the flip side of logging exceptions—what to do when they are encountered! We want to consider exactly how users should recover from a problem. This can be especially true when dealing with loading transactions, which the dashboard could eventually be involved with. Since an ACH file is used to move money around, if our file fails to load or otherwise has error conditions, we may need to consider implications to user’s accounts. In other words, it may not be enough to just load a file and try again. We need to be able to ensure transactions will not be posted to the account again, resulting in customers being either credited or debited multiple times. At this point, our concerns do not need to be centered around those details, but it is important to provide some help to the user. </p>
</div>
<div class="readable-text intended-text" id="p81">
<p>One scenario that comes to mind is encountering an exception being thrown, which involved comparing totals from two parts of the system. If the totals did not match, the processing halted, resulting in a call to a developer at 2 am. The concern was not an exception making us work at odd hours. If a critical processing exception occurs, we can expect occasional problems. Rather, the concern was about the recovery steps that should be taken when the error was encountered—there were none! The result was multiple developers having to get involved to figure out what needed to be done. It was determined the check could be safely bypassed, and we could follow up and investigate further the following day. Eventually, it was found the audit records were not written out as expected, which resulted in the totals being off, but the problem recurred several times before that was discovered.</p>
</div>
<div class="readable-text intended-text" id="p82">
<p>While we do not have such concerns with our project right now, it would certainly be nice to provide users with some additional information. After all, the dashboard may eventually require its own internal help system, or perhaps a look at the exception will offer some advice on what actions can be taken. The following listing shows the creation of an <code>ach_recovery_options</code> table tied back to the <code>ach_exception_codes</code> table, allowing multiple entries to be associated with an exception code.</p>
</div>
<div class="browsable-container listing-container" id="p83">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.6<span class="CharOverride-4"> </span>ACH recovery options table</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TABLE ach_recovery_options (
    ach_recovery_options_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    exception_code VARCHAR(3) NOT NULL REFERENCES  #1
       <span>ach_exception_codes(exception_code) ON UPDATE CASCADE, </span>
<span>    </span>recovery_option VARCHAR NOT NULL #2
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Each recovery option should reference a specific exception.</span>
<br/>#2 
     <span class="CharOverride-5">The recovery option is simply text that the users can review for help.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p84">
<p>We can then prepopulate the table with our recovery options as part of our startup. The following listing shows some possible recovery options being inserted into the database.</p>
</div>
<div class="browsable-container listing-container" id="p85">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.7<span class="CharOverride-4"> </span>Prepopulating the recovery options</h5>
<div class="code-area-container">
<pre class="code-area">INSERT INTO ach_recovery_options (exception_code, recovery_option)
<span class="CharOverride-6">➥</span> VALUES ('001', 'Request a corrected file from the originator');
INSERT INTO ach_recovery_options (exception_code, recovery_option)
<span class="CharOverride-6">➥</span> VALUES ('002', 'Request a corrected file from the originator');
INSERT INTO ach_recovery_options (exception_code, recovery_option)
<span class="CharOverride-6">➥</span> VALUES ('004', 'Specify a new File ID Modifier');</pre>
</div>
</div>
<div class="readable-text" id="p86">
<p>The recovery options could certainly be expanded. However, at this point, we just want to ensure recovery and help is a consideration in our development. We should all be aware of the importance of clean code and comments to help us understand the code when we have to dive back into it in 6 to 12 months. Just as important is making sure that our software is usable by the end-user. Otherwise, we may find ourselves having to provide support for problems that users should be able to fix themselves. Defining help within the application and considering more extensive documentation and troubleshooting in a tool such as Confluence can be helpful to end-users and support staff. In the end, it will free you up to spend more time developing, and that is what we are all here for!</p>
</div>
<div class="readable-text" id="p87">
<h2 class="readable-text-h2"><span class="num-string">8.5</span> Updating the ACH parser</h2>
</div>
<div class="readable-text" id="p88">
<p>With the database capable of supporting better exception handling, we can now work on updating the ACH parsing to write our exceptions. Many exceptions that we might encounter from a formatting perspective can be handled through Pydantic. We can continue to add constraints and validation to our Pydantic definitions, which will take many of the more tedious tasks out of our hands. Other exceptions may rely on examining more than just the fields of our record. For instance, ensuring that trace numbers are ascending is something that we would prefer to do outside of Pydantic.</p>
</div>
<div class="readable-text" id="p89">
<h3 class="readable-text-h3"><span class="num-string">8.5.1</span> Creating unit tests for the exceptions</h3>
</div>
<div class="readable-text" id="p90">
<p>We have already shown how to update our BDD-style syntax to create files with the needed errors. Then we can create the basic layout, as shown in the following listing. This approach should work just fine for testing, regardless of whether an exception was encountered.</p>
</div>
<div class="browsable-container listing-container" id="p91">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.8<span class="CharOverride-4"> </span>Test for invalid immediate destination</h5>
<div class="code-area-container">
<pre class="code-area">def test_incorrect_immediate_destination(parser):
    ach_filename = "invalid_immediate_destination.ach" #1
    dir_path = os.path.dirname(os.path.realpath(__file__))  #2
    file_path = os.path.join(dir_path, "data", "bad_files",  #2
                                             ach_filename)  #2

    expected_exceptions_count: int = 1 
    expected_exceptions_code: str = #2
       AchExceptions.INVALID_IMMEDIATE_DESTINATION.value

    ach_files_id = 
       SqlUtils.create_ach_file_record(filename, "123456789") #3

    parser.parse(ach_files_id, file_path) #4
    exceptions = SqlUtils.get_exceptions() #5

    assert (          #6
        len(exceptions) == expected_exceptions_count #6
    ), f"Expected {expected_exceptions_count}, #6
<span class="CharOverride-6">➥</span> but got {len(exceptions)}"  #6
 #6
    assert (  #6
        exceptions[0] == expected_exceptions_code #6
    ), f"Expected {expected_exceptions_code}, #6
<span class="CharOverride-6">➥</span> but got {exceptions[0]}"  #6</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Defines initial variables so we can obtain a file to load</span>
<br/>#2 
     <span class="CharOverride-5">We use an ENUM value so that the exception codes remain flexible.</span>
<br/>#3 
     <span class="CharOverride-5">Inserts a needed dummy record for our insert</span>
<br/>#4 
     <span class="CharOverride-5">Parses the file which loads it into the database</span>
<br/>#5 
     <span class="CharOverride-5">Gets the exceptions</span>
<br/>#6 
     <span class="CharOverride-5">Asserts that we have our one expected exception</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p92">
<p>Considering the previous sample, we may notice that much of that code will be the same for each test. This is a perfect opportunity to recall that refactoring is one of the TDD phases. In this instance, we can refactor the code so that the processing of the file is generalized to one routine, and we call that with the expected values, as shown in the following listing. This approach still works well for these basic tests where we just want to confirm the exception has been caught. Since the <code>assert</code> raises an exception, we still see our error thrown from within the <code>test_incorrect_file_id_modifier</code> method.</p>
</div>
<div class="browsable-container listing-container" id="p93">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.9<span class="CharOverride-4"> </span>Refactored test</h5>
<div class="code-area-container">
<pre class="code-area">def test_incorrect_file_id_modifier(parser):
    process_file_and_verify_exception(       #1
       ach_filename = "invalid_file_id.ach",  #1
       expected_exceptions_count = 1,     #1
       expected_exceptions_code =  #1
          AchExceptions.INVALID_FILE_ID_MODIFIER.value,  #1
       parser = parser)  #1

def process_file_and_verify_exception(ach_filename: str, #2
   expected_exceptions_count: int,   #2
   expected_exceptions_code: str,  #2
 #2
parser: AchFileProcessor):  #2
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">We create a function and pass the needed variables to it.</span>
<br/>#2 
     <span class="CharOverride-5">The called function contains the same logic of parsing and asserting the desired variables.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p94">
<p>With these basic tests, we can easily start adding exceptions to our code. Of course, more extensive testing will be done at some point, but this is a great way to get moving in the right direction.</p>
</div>
<div class="readable-text" id="p95">
<h3 class="readable-text-h3"><span class="num-string">8.5.2</span> Supporting the exceptions in our parser</h3>
</div>
<div class="readable-text" id="p96">
<p>To begin writing our exceptions, we have to add a schema that can hold the exception information. By providing the UUID for the file, batch, and entry, we have flexibility in reporting the exception at different levels. For instance, when an amount is invalid, we can drill down directly to the record causing the problem because we have access to the UUID for the file, batch, and entry. Compare that with if we only had the <code>ach_files_id</code> that caused the exception. If we had thousands of records in the file, we would have our work cut out for us, determining the offending record. The following listing shows our ACH exception schema. We have excluded the field definitions to keep things simple.</p>
</div>
<div class="browsable-container listing-container" id="p97">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.10<span class="CharOverride-4"> </span>The ACH exception schema</h5>
<div class="code-area-container">
<pre class="code-area">class AchExceptionSchema(BaseModel):
    ach_exceptions_id: Optional[UUID4] = Field(…)
    ach_files_id: UUID4 = Field(…)  #1
    ach_batch_id: Optional[UUID4] = Field(…)
    ach_entry_id: Optional[UUID4] = Field(…)
    record_number: int = Field(…) #2
    exception_code: str = Field(…) #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">We always associate exceptions with a particular file.</span>
<br/>#2 
     <span class="CharOverride-5">The record number helps locate the unparsed record.</span>
<br/>#3 
     <span class="CharOverride-5">The exception code helps locate the error details.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p98">
<p>We then continue creating our <code>AchExceptionsSql</code> class that has the usual <code>insert_record</code> and <code>get_record</code> methods. We could have named these <code>insert_exception</code> and <code>get_exception</code>, but to stay consistent with the other methods, we keep it similar to our existing code.</p>
</div>
<div class="browsable-container listing-container" id="p99">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.11<span class="CharOverride-4"> </span>ACH exceptions SQL</h5>
<div class="code-area-container">
<pre class="code-area">class AchExceptionsSql: #1
    @staticmethod
    def insert_record(ach_file_exception: AchExceptionSchema) -&gt; UUID:
        with get_db_connection() as conn:
            result = conn.execute(
                """
           INSERT INTO ach_exceptions #2
<span class="CharOverride-6">➥</span> (ach_files_id, record_number,  #2
              exception_code)  #2
           VALUES (%(ach_files_id)s,   #2
<span class="CharOverride-6">➥</span>%(record_number)s, %(exception_code)s)  #2
           RETURNING ach_exceptions_id #2
            """,
                ach_file_exception.model_dump()
            )

        return result.fetchone()[0] #3

    @staticmethod
    def get_record(ach_exception_id: UUID) -&gt; AchExceptionSchema:
        with get_db_connection
<span class="CharOverride-6">➥</span>(row_factory=class_row(AchExceptionSchema)) as conn:
            result = conn.execute(
                """
                SELECT * FROM ach_exceptions #4
                WHERE ach_exceptions_id = %s
                """,
                [ach_exception_id]
            )

            return result.fetchone()</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">The exception class </span>
<span class="CharOverride-5">containing any SQL calls</span>
<br/>#2 
     <span class="CharOverride-5">Standard SQL to insert and return </span>
<span class="CharOverride-5">the newly added ID</span>
<br/>#3 
     <span class="CharOverride-5">Returns the first field from our results, which is the ID</span>
<br/>#4 
     <span class="CharOverride-5">Standard SQL to </span>
<span class="CharOverride-5">read the exceptions</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p100">
<p>Now that we can create exception records, we can simply call an <code>_add_exception</code> routine from ach_file_processor.py wherever we need to write out exceptions. Listing 8.12 shows this exception routine. Notice that we take the <code>AchExceptionSchema</code> and the unparsed line as parameters. We chose to take the line as an optional parameter and write it out to an invalid record table. This is because we split out the individual record types in our database earlier. To accommodate conditions where we may have a record that could not be parsed because it was not a valid type, we still want to store it somewhere.</p>
</div>
<div class="browsable-container listing-container" id="p101">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.12<span class="CharOverride-4"> </span>Adding an exception method</h5>
<div class="code-area-container">
<pre class="code-area">    @staticmethod #1
    def _add_exception(exception: AchExceptionSchema, #1
<span class="CharOverride-6">➥</span> unparsed_record=None) -&gt; None: 
        sql = AchExceptionsSql()
        sql.insert_record(exception)
        if unparsed_record is not None: #2
            sql_invalid_rec = AchRecordsSqlTypeInvalid()  #2
            sql_invalid_rec.insert_record #2
<span class="CharOverride-6">➥</span>(AchRecordTypeInvalidSchema(  #2
                ach_files_id=exception.ach_files_id,  #2
                unparsed_record=unparsed_record,  #2
                sequence_number=exception.record_number,  #2
            ))</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Our function to call when we have an exception during processing</span>
<br/>#2 
     <span class="CharOverride-5">When a record has been passed, we need to write it to a special database table since we could not determine the correct table for it (e.g., a record type that does not exist).</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p102">
<p>With the ability to create exceptions, we need to update our parsing methods to return a custom validation error. The individual field parsing does not change, but we want to capture the validation error and wrap it with a custom error.</p>
</div>
<div class="browsable-container listing-container" id="p103">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.13<span class="CharOverride-4"> </span>Updating parse routine</h5>
<div class="code-area-container">
<pre class="code-area">    @staticmethod
    def parse_file_header(
            ach_records_type_1_id: UUID, record: str
    ) -&gt; AchFileHeaderSchema:
        try:  #1
            return AchFileHeaderSchema(  #1
…  #1
            ) 
        except ValidationError as e: #2
            raise AchParsingValidationError( #3
   message='Error parsing file header',  #3
   validation_errors=e.errors())  </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Tries to parse the </span>
<span class="CharOverride-5">header with Pydantic</span>
<br/>#2 
     <span class="CharOverride-5">Catches when a validation error is encountered</span>
<br/>#3 
     <span class="CharOverride-5">Creates a custom error that </span>
<span class="CharOverride-5">stores our ACH related information using the raise keyword</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p104">
<p>The custom <code>AchParsingValidationError</code> is shown in the following listing. The purpose of the custom error is that we can translate the encountered errors to their equivalent <code>AchException</code> codes, which facilitates writing them to the database.</p>
</div>
<div class="browsable-container listing-container" id="p105">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.14<span class="CharOverride-4"> </span>Custom ACH parsing error</h5>
<div class="code-area-container">
<pre class="code-area">class AchParsingValidationError(Exception): #1
…
    def get_exception_codes(self) -&gt; list[str]: #2
        exception_codes = []   
        for error in self.validation_errors: #3
            if error['loc'][0] == 'file_id_modifier': #4
exception_codes.append(AchExceptions.  #4
<span class="CharOverride-6">➥</span>INVALID_FILE_ID_MODIFIER.value)  #4
            elif error['loc'][0] == 'immediate_destination':   #4
exception_codes.append(AchExceptions.  #4
<span class="CharOverride-6">➥</span>INVALID_IMMEDIATE_DESTINATION.value)  #4
        return exception_codes</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Our error is a subclass of Exception.</span>
<br/>#2 
     <span class="CharOverride-5">Defines a function to get a list of exceptions</span>
<br/>#3 
     <span class="CharOverride-5">Processes each </span>
<span class="CharOverride-5">validation from the array </span>
<span class="CharOverride-5">self.validation_errors</span>
<br/>#4 
     <span class="CharOverride-5">Translates the field having a problem </span>
<span class="CharOverride-5">to one of our exception codes</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p106">
<p>Then we can update the individual parsing of the record to add the exceptions when encountered.</p>
</div>
<div class="browsable-container listing-container" id="p107">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.15<span class="CharOverride-4"> </span>Updates to handle validation errors</h5>
<div class="code-area-container">
<pre class="code-area">case "1":
   ach_record = AchRecordType1Schema(
      ach_files_id=ach_file_id,
      unparsed_record=line,
      sequence_number=sequence_number)
   ach_record_id = AchRecordsSqlType1().insert_record(ach_record)
   current_file_header_id = ach_record_id
   try:  #1
      self._parse_file_header(ach_record_id, line)  
   except AchParsingValidationError as e:  #2
      for exception_code in e.get_exception_codes():  #2
         self._add_exception(AchExceptionSchema(  #2
            ach_files_id=ach_file_id,   #2
            record_number=sequence_number,  #2
            exception_code=exception_code,  #2
            ))  #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">We try to parse </span>
<span class="CharOverride-5">the record.</span>
<br/>#2 
     <span class="CharOverride-5">For each error we find, it writes out an exception.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p108">
<p>That provides a basic outline for handling of exceptions in the ACH parser. The same formula applies to the remaining record types. </p>
</div>
<div class="readable-text" id="p109">
<h3 class="readable-text-h3"><span class="num-string">8.5.3</span> Validation in Pydantic</h3>
</div>
<div class="readable-text" id="p110">
<p>Much of field-level validation will happen in Pydantic. Let’s take a look at some of the exceptions and how we can do them in Pydantic.</p>
</div>
<div class="readable-text intended-text" id="p111">
<p>First, we would like to address the file ID modifier on the type 1 record. This should be an uppercase letter from A to Z or a numeric value from 0 to 9, which we can easily specify in Pydantic.</p>
</div>
<div class="browsable-container listing-container" id="p112">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.16<span class="CharOverride-4"> </span>Pydantic validation of the file ID modifier</h5>
<div class="code-area-container">
<pre class="code-area">file_id_modifier: Annotated[str, 
   StringConstraints(
      pattern=r'^[A-Z0-9]$', #1
      min_length=1, #2
      max_length=1)] </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">We define a regular expression pattern to validate against.</span>
<br/>#2 
     <span class="CharOverride-5">We also limit the field size, although the pattern itself should be enough.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p113">
<p>Another condition to cover is the immediate destination. We know that this should match the routing number of our bank. We do not necessarily want to hardcode these values into our code because they can change (although not often), but as previously mentioned, banks that go through acquisitions and mergers may gain (or lose) routing numbers. Therefore, we want a way to have Pydantic validate the immediate destination based on a list of values known at runtime. </p>
</div>
<div class="readable-text intended-text" id="p114">
<p>This task is accomplished through a <code>field_validator</code> annotation in Pydantic. For our purposes, we will hook this into a database call, which lets us validate the field against a list of allowed values in our database.</p>
</div>
<div class="browsable-container listing-container" id="p115">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.17<span class="CharOverride-4"> </span>Pydantic field validator for immediate destination</h5>
<div class="code-area-container">
<pre class="code-area"><span>@field_validator('immediate_destination') </span>#1
<span>@classmethod   </span>
<span>def validate_immediate_destination(cls, v):</span>
<span>   </span>try:
      if BankRoutingSql().valid_bank_routing_number(v): #2
         return v
      else:  #3
         raise ValueError('immediate_destination #3
<span class="CharOverride-6">➥</span> is not a valid routing number') 
   except Exception: #4
      raise ValueError('Unable to validate #4
<span class="CharOverride-6">➥</span> immediate_destination') </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Uses the field_validator and classmethod annotations</span>
<br/>#2 
     <span class="CharOverride-5">Uses SQL to check the bank routing number and return it if valid</span>
<br/>#3 
     <span class="CharOverride-5">Otherwise, raises a ValueError </span>
<span class="CharOverride-5">as it was not found</span>
<br/>#4 
     <span class="CharOverride-5">Handles any unexpected errors </span>
<span class="CharOverride-5">with a ValueError as well</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p116">
<p>To support this, we have to create a simple table that contains the routing numbers we want to consider as our bank routing numbers. Depending on the number of records we expect to validate, having to perform a database query for each record (and possibly multiple fields) may be inefficient. In our case, there should only be a single ACH file header record in any file that we load. So, we are not overly concerned about the effects on performance, but these types of potential problems should be kept in mind.</p>
</div>
<div class="readable-text intended-text" id="p117">
<p>Once we start validating the immediate origin, we need to go through and correct many of our tests where we had a number that was valid but did not exist in our database. There will be an additional clean-up of unit tests to handle the exceptions and expanding of parameters passed to the routines so that we can log the exceptions. When these methods start getting too complex, it will be time to split them into their own record-type classes away from the parser itself.</p>
</div>
<div class="readable-text" id="p118">
<h2 class="readable-text-h2"><span class="num-string">8.6</span> Updating the APIs</h2>
</div>
<div class="readable-text" id="p119">
<p>After passing the unit tests with the ACH parsing and handling our errors, we can jump over to the dashboard to see things in action. Unfortunately, if you try to load one of the exception files, you will not see it on the dashboard. What happened? </p>
</div>
<div class="readable-text intended-text" id="p120">
<p>We already have BDD syntax for the API endpoint that supports loading a file and checking the results, so no new code will be needed to support the test shown in the next listing. Having the flexibility to create new tests without having to write any new code is one of the benefits of BDD and a flexible syntax that powers it. Running this test does indeed show no records being returned. </p>
</div>
<div class="browsable-container listing-container" id="p121">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.18<span class="CharOverride-4"> </span>Testing our API with an invalid file</h5>
<div class="code-area-container">
<pre class="code-area">Scenario: I should get a file even when
<span class="CharOverride-6">➥</span> it has an exception #1
   Given that I have a clean database #2
   And that I have posted the file "invalid_file_id.ach" 
   When I request a list of files #3
   Then I should have a file that includes the
<span class="CharOverride-6">➥</span> file "invalid_file_id.ach" #4</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Defines a scenario</span>
<br/>#2 
     <span class="CharOverride-5">Sets up the database and processes an ACH file</span>
<br/>#3 
     <span class="CharOverride-5">Executes the API</span>
<br/>#4 
     <span class="CharOverride-5">Checks for our included file</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p122">
<p>Another great benefit of having tests is that we can simply add a breakpoint to the endpoint and rerun the test in a debug mode, which then allows us to step through the code. If you take the time to do this, you should see that no results are being returned from the query.</p>
</div>
<div class="readable-text intended-text" id="p123">
<p>The queries are not able to handle the parsed record (<code>ach_file_headers</code> or <code>ach_file_control_records</code>) not being found. Because we used <code>INNER</code> <code>JOIN</code>, the record must exist in the database to be returned.</p>
</div>
<div class="browsable-container listing-container" id="p124">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.19<span class="CharOverride-4"> </span>Using <code>INNER JOIN</code> in our original query</h5>
<div class="code-area-container">
<pre class="code-area">SELECT af.ach_files_id AS id,
                       af.file_name AS filename,
                       af.created_at AS date,    
                       afh.immediate_origin_name AS originator,                 
                       afcr.total_debit_entry_dollar_amount AS debit_total, 
                       afcr.total_credit_entry_dollar_amount
<span class="CharOverride-6">➥</span> AS credit_total,
                FROM ach_files AS af
                INNER JOIN ach_records_type_1 AS art1 USING (ach_files_id)
                INNER JOIN ach_records_type_9 AS art9 USING
                                     (ach_records_type_1_id)
                INNER JOIN ach_file_headers AS afh USING  #1
                                     (ach_records_type_1_id)  #2
                INNER JOIN ach_file_control_records AS afcr USING #2
                                           (ach_records_type_9_id)   #2
                ORDER BY af.created_at DESC</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">INNER JOINs on these files may cause records not to be returned when exceptions occur.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p125">
<p>Both the <code>ach_file_headers</code> and <code>ach_file_control_records</code> are needed in the query. Now that we have started adding our exceptions and not writing out parsed records, we will also need to be more aware of these queries. Since there is no guarantee that this feature will be present, we should use a <code>LEFT</code> <code>JOIN</code> to return a result. The following listing shows updating both parsed versions of our query to use the <code>LEFT</code> <code>JOIN</code>. Depending on the workflow we use to work through this problem, we may not want to make changes to both tables until we have tests to verify them.</p>
</div>
<div class="browsable-container listing-container" id="p126">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.20<span class="CharOverride-4"> </span>Updating our queries to <code>LEFT JOIN</code></h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">INNER JOIN ach_records_type_1 AS art1 USING (ach_files_id)
INNER JOIN ach_records_type_9 AS art9 USING (ach_records_type_1_id)sd
<strong>LEFT JOIN</strong> ach_file_control_records AS afcr#1
<span class="CharOverride-6">➥</span> USING (ach_records_type_9_id)  #1
<strong>LEFT JOIN</strong> ach_file_headers AS afh #1
<span class="CharOverride-6">➥</span> USING (ach_records_type_1_id) 
ORDER BY af.created_at DESC</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Updating our queries to LEFT JOIN resolves the problem by keeping the data in the left table.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p127">
<p>With the updates to the query, we now see our tests passing. We may also look at these queries and think that we have spent all the previous sections adding exceptions, but we neither have any APIs handling them nor have we updated any of our existing APIs to consider them as well.</p>
</div>
<div class="readable-text intended-text" id="p128">
<p>When thinking about including exceptions in our dashboard, we will likely want APIs that can help us with the following:</p>
</div>
<ul>
<li class="readable-text" id="p129"><em>Return all exception</em><em>s</em>—Regardless of whether we are looking for all exceptions ever or just exceptions encountered today, we need some insight into the exceptions that have been encountered. Also, if we are interested in allowing users to perform maintenance on the exceptions (change exception levels), this is a good starting point.</li>
<li class="readable-text" id="p130"><em>Return exceptions for a fil</em><em>e</em>—There will certainly be a need to get exceptions for a specific file.</li>
</ul>
<div class="readable-text" id="p131">
<p>There are more use cases for our APIs, but these should be sufficient to get us moving with some of the APIs. One design choice we will have to make is the endpoint layout. Do we create a new endpoint so that our exceptions are like our existing <code>/files</code> endpoint (something similar to <code>/api/v1/exceptions</code>), or are exceptions part of our files (something similar to <code>/api/v1/files/exceptions</code>). Will we use a combination of the two? Since the exceptions will be associated with the loaded files, we keep our exceptions associated with the <code>/files</code> endpoints.</p>
</div>
<div class="readable-text intended-text" id="p132">
<p>Next, we want to ensure that our exception APIs are returning the expected data. For instance, when we load the invalid_file_id.ach, we expect an error code and message that will be returned from the database. We can use most of our existing code in the test_file_api.py and only include a few other steps. Starting with this, we can create a test we then verify against. We created a new file named ach_files_exception_endpoint.feature<code> </code>that stores our exception features.</p>
</div>
<div class="browsable-container listing-container" id="p133">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.21<span class="CharOverride-4"> </span>Testing our exceptions API</h5>
<div class="code-area-container">
<pre class="code-area">Feature: Exceptions returned for files
  Test the functionality of the exception returned for loaded ACH files

  Scenario: I get a list of exceptions for a file #1
    Given that I have a clean database #2
    And that I have posted the file "invalid_file_id.ach" 
    When I request a list of exceptions for the#3
<span class="CharOverride-6">➥</span> file "invalid_file_id.ach"  #3
    Then I should receive an error of "004" and a #3
<span class="CharOverride-6">➥</span> message of "Invalid File ID Modifier" </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Sets up a scenario for the exceptions API</span>
<br/>#2 
     <span class="CharOverride-5">Ensures an empty </span>
<span class="CharOverride-5">database and loads the file</span>
<br/>#3 
     <span class="CharOverride-5">Calls the API and validates the exception</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p134">
<p>To support the new <code>When</code> clause, we must add code that will request a list of files so that we can determine the UUID. After that, we use the obtained ID to make a request to the exception endpoint. To avoid any unexpected errors, we could also ensure that we have one record returned from the response, as well as a valid response code. However, since we have cleared the database and only loaded a single file, it should be an exceptional condition that causes this to break.</p>
</div>
<div class="browsable-container listing-container" id="p135">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.22<span class="CharOverride-4"> </span>Adding a new <code>When</code> clause</h5>
<div class="code-area-container">
<pre class="code-area">@when(parsers.parse('I request a list of exceptions
<span class="CharOverride-6">➥</span> for the file \"{filename}\"'))
def get_list_of_exceptions_for_file(api_response, filename):
    response = client.get("/api/v1/files/")  #1
    assert response.status_code == 200, response.text
    file_id = response.json()[0]["id"] #2
    response = client.get #3
<span class="CharOverride-6">➥</span>(f"/api/v1/files/{file_id}/exceptions")  #4
    <span>assert response.status_code == 200, response.text</span>
<span>    </span>api_response["response"] = response.json() #4</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Gets a list of files and ensures that it worked</span>
<br/>#2 
     <span class="CharOverride-5">Extracts the file_id from the response</span>
<br/>#3 
     <span class="CharOverride-5">Uses the file_id we just extracted from the response, makes another API call to </span>
<span class="CharOverride-5">our exceptions API, and validates the HTTP response</span>
<br/>#4 
     <span class="CharOverride-5">Saves the response </span>
<span class="CharOverride-5">for use in other steps</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p136">
<p>We have our stored API response, and now we want to ensure that we are getting the expected error code and message from our response. Why are we validating both the error code and the message text coming back? Should the error code not be the determining factor? On the one hand, the consumer of the API should rely on the error code and not the error message description. On the other hand, we want to ensure that both the error code and description match our expectations. Furthermore, we may want to identify when the description changes as maybe some consumers of our API work directly with the description rather than with the error code. Perhaps the API was incorrect at some point and returned the same error code for different <br/>errors. </p>
</div>
<div class="readable-text intended-text" id="p137">
<p>To work around the error, the consumers may have directly interrogated the description, and changes to it may break the API. Of course, if we make a change to that API, we may choose to change the version so that consumers can move to the updated API when they are ready. With all that said, we just need to be aware that changes can affect end-users in unexpected ways. We have seen instances where customers have implemented their own scraping of log messages for their own purposes. When those messages (even though they were internal to the application) changed, the infrastructure broke. In the end, the messages needed to be put back in place. So, be very careful—seemingly innocuous changes may cause problems. </p>
</div>
<div class="browsable-container listing-container" id="p138">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.23<span class="CharOverride-4"> </span>Adding a new <code>Then</code> clause</h5>
<div class="code-area-container">
<pre class="code-area">@then(parsers.parse('I should receive an error 
<span class="CharOverride-6">➥</span> of \"{error_code}\" and a message of \"{error_message}\"')) 
def check_error_code_exists_on_response(error_code, 
<span class="CharOverride-6">➥</span> error_message, api_response):
    assert any( 
        error_code == response["exception_code"]
<span class="CharOverride-6">➥</span> for response in
api_response["response"] 
    ), f"Expected {error_code} in" 
<span class="CharOverride-6">➥</span> f" {api_response['response']}" 
    assert any(#1
        error_message == response["description"]
<span class="CharOverride-6">➥</span> for response in api_response["response"]
    ), f"Expected {error_message} in" f" {api_response['response']}"</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Using any, we can search for a field in our response. This tactic is convenient when dealing with an array of values and we do not know the order of the response.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p139">
<p>We now have tests for these APIs to determine whether they are returning data successfully. As a programming challenge, can you create the logic behind these APIs and get the tests to pass?</p>
</div>
<div class="readable-text intended-text" id="p140">
<p>We create the endpoint for the exceptions <code>/{file_id}/exceptions</code> as shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p141">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.24<span class="CharOverride-4"> </span>An exceptions endpoint for a file</h5>
<div class="code-area-container">
<pre class="code-area">@router.get(   #1
    path="/{file_id}/exceptions",  #1
    response_model=list[AchExceptionsResponse],  #1
    summary="Retrieve ACH File Exceptions",  #1
    description="Retrieve the exceptions in an ACH file.",  #1
    response_description=  #1
<span class="CharOverride-6">➥</span>"The exceptions in the requested ACH file.",  #1
    tags=["ACH Files"],  #1
)
async def read_exceptions_for_file(file_id: UUID) -&gt;  #2
list[AchExceptionsResponse]:  #2
    return AchExceptionsSql() #2
<span class="CharOverride-6">➥</span>.get_exceptions_response(file_id)  #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Our API details that will be used for OpenAPI documentation</span>
<br/>#2 
     <span class="CharOverride-5">The actual function</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p142">
<p>Next, we create the <code>get_exceptions_response</code> method.</p>
</div>
<div class="browsable-container listing-container" id="p143">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.25<span class="CharOverride-4"> </span>The <code>get_exceptions_response</code> method</h5>
<div class="code-area-container">
<pre class="code-area">    @staticmethod
    def get_exceptions_response(ach_files_id: UUID = None) -&gt; list[AchExceptionsResponse]:
        query_parameters = []
        sql = """
                    SELECT #1
                        afe.ach_exceptions_id AS id, 
                        afe.ach_files_id AS file_id, 
                        afe.ach_records_type_5_id AS batch_id, 
                        afe.ach_records_type_6_id AS entry_id, 
                        afe.record_number AS record_number, 
                        <span>afe.exception_code AS exception_code, </span>
<span>                        aec.exception_description AS description</span>
<span>                    FROM ach_exceptions AS afe </span>#2
<span>                    INNER JOIN ach_exception_codes AS aec  </span>#3
<span>                                      USING (exception_code) </span>
<span>        </span>"""
        if ach_files_id is not None:    #4
            sql += " WHERE afe.ach_files_id = %s"  #4
            query_parameters.append(ach_files_id)  #4

        with get_db_connection(row_factory=class_row(AchExceptionsResponse)) as conn:
            result = conn.execute(sql, query_parameters) #5
            return result.fetchall() </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Standard SELECT statement with our desired fields</span>
<br/>#2 
     <span class="CharOverride-5">Our initial table is the ach_exceptions.</span>
<br/>#3 
     <span class="CharOverride-5">Joins our exceptions with the exception codes for more details</span>
<br/>#4 
     <span class="CharOverride-5">If we received a specific ach_files_id, then use that to filter our results by appending a WHERE clause.</span>
<br/>#5 
     <span class="CharOverride-5">Executes the query and returns the results</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p144">
<p>Our test should be passing. If we step through the code and examine the response that we receive, we should see the <code>batch_id</code> and <code>entry_id</code> are both set to <code>None</code>, as shown in the example response.</p>
</div>
<div class="browsable-container listing-container" id="p145">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.26<span class="CharOverride-4"> </span>Example response</h5>
<div class="code-area-container">
<pre class="code-area">[{…, 'batch_id': None, 'entry_id': None,
<span class="CharOverride-6">➥</span> 'record_number': 1, 'exception_code': '004',…}]</pre>
</div>
</div>
<div class="readable-text" id="p146">
<p>We may consider updating our SQL query to set those returned values to empty strings by using <code>COALESCE</code>—for example, <code>COALESCE(afe.ach_records_type_5_id,</code> <code>'') AS batch_id</code>. However, because we have defined our Pydantic models to expect a UUID, and the empty string is not a valid UUID, we will receive an <code>InvalidText­Representation</code> error. Because we are returning JSON, a better alternative may be to drop this value from the response. Note that this may not always be the best option. For instance, if we wanted to note the explicit absence of the value, it may be desirable to return something to indicate the value is missing. However, for our purpose, dropping the value works just fine. The following listing shows how to drop the <code>None</code> value from our response. Since we are not interested in it, we will see that our UI will handle the missing value without our help.</p>
</div>
<div class="browsable-container listing-container" id="p147">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.27<span class="CharOverride-4"> </span>Dropping <code>None</code> values from our model</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">@router.get(
    path="/{file_id}/exceptions",
    response_model=list[AchExceptionsResponse],
    summary="Retrieve ACH File Exceptions",
    description="Retrieve the exceptions in an ACH file.",
    response_description="The exceptions in the requested ACH file.",
<strong>    response_model_exclude_none=True, </strong>#1
    tags=["ACH Files"],
)</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Drops the fields containing None</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p148">
<p>With the <code>response_model_exclude_none</code> set to <code>True</code>, we should be ready to move on to the UI to start taking advantage of our exception API. Now that we have declared several endpoints within files.py, we want to ensure that we are paying attention to the order we declare them in. We make sure that we are going from general endpoints such as <code>/files</code> and <code>/exceptions</code> to more specific, such as <code>/{file_id}/exceptions</code>. If we encounter a <code>422</code> <code>error</code>, it could be an indication that FastAPI has picked up the wrong endpoint to use.</p>
</div>
<div class="readable-text" id="p149">
<h3 class="readable-text-h3"><span class="num-string">8.6.1</span> Retrieving an unparsed record</h3>
</div>
<div class="readable-text" id="p150">
<p>Another piece of functionality we need for the dashboard is the ability to retrieve an unparsed record from the database. As we have seen, when there is a parsing exception, we are not writing the parsed record out. It will be helpful to an end-user if they can see what the record causing the exception looked like. Of course, they could pull up the file themselves and look at it, but that is not very user friendly. We would also recommend passing the record back all the time (which would make this request more straightforward) because the unparsed record could contain nonpublic information (NPI) data. By creating this as a separate endpoint that returns the record, say when a button or icon is clicked, we can call out to the specific endpoint to retrieve the data, which allows us to take preventative measures such as</p>
</div>
<ul>
<li class="readable-text" id="p151">Hiding the button to display the record when the user is not authenticated.</li>
<li class="readable-text" id="p152">Creating an audit trail when the information is viewed</li>
<li class="readable-text" id="p153">Preventing needless data from being returned since users will not always need to see the unparsed record</li>
</ul>
<div class="readable-text" id="p154">
<p>We can start by creating a scenario to test this approach.</p>
</div>
<div class="browsable-container listing-container" id="p155">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.28<span class="CharOverride-4"> </span>Scenario for an unparsed record</h5>
<div class="code-area-container">
<pre class="code-area">Scenario: I get the unparsed record for a
<span class="CharOverride-6">➥</span> specific exception #1
    Given that I have a clean database
    And that I have posted the file "invalid_file_id.ach"
    When I request the unparsed record for the exception code "004"
    Then I should receive an
<span class="CharOverride-6">➥</span> unparsed record of "1…i…XXXXX" #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Scenario for an unparsed records API</span>
<br/>#2 
     <span class="CharOverride-5">Contains the entire unparsed record</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p156">
<p>The following code creates a step that helps support the retrieval of the unparsed record for a given exception. We assume that we are only getting one file returned and that the only exception is the one we want. Later, we may need to make the code more robust, but there is no need for now.</p>
</div>
<div class="browsable-container listing-container" id="p157">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.29<span class="CharOverride-4"> </span>Step definition for retrieving an unparsed record</h5>
<div class="code-area-container">
<pre class="code-area">@when('I request the unparsed record for the exception code "004"')
def request_unparsed_record(api_response):
    response = client.get("/api/v1/files/") #1
    assert response.status_code == 200, response.text #1
    file_id = response.json()[0]["id"]  #1
    response = client #1
<span class="CharOverride-6">➥</span>.get(f"/api/v1/files/{file_id}/exceptions")  #1
    <span>assert response.status_code == 200, response.text</span> #1
<span>    exception_id = response.json()[0]["id"] </span> #1
<span>    response =  </span> #1
<span> client.get(f</span><span>"</span><span>/api/v1/files/{file_id} </span> #1
<span class="CharOverride-6">➥</span><span>/exceptions/{exception_id}") </span> #1
<span>    assert response.status_code == 200, response.text</span> #1
<span>    </span>api_response["response"] = response.json() #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Similarly to previous API tests, we must make several calls to drill down to the data we are interested in. With each API call, we must validate a successful 200 response code before moving on to prevent errors in subsequent calls.</span>
<br/>#2 
     <span class="CharOverride-5">We store the results of our final API call for further use.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p158">
<p>If we run this code, we are likely to get a <code>404</code> <code>error</code> since we have not defined an endpoint. You should see one of the <code>client.get</code> calls failing with the error:</p>
</div>
<div class="browsable-container listing-container" id="p159">
<div class="code-area-container">
<pre class="code-area">Expected :200
Actual   :404</pre>
</div>
</div>
<div class="readable-text" id="p160">
<p>What steps need to be taken to fix this error? </p>
</div>
<ul>
<li class="readable-text" id="p161">We need to create a new route to get the unparsed record for a given <code>exception_id</code> in the files.py.</li>
<li class="readable-text" id="p162">We update the ach_exceptions_sql.py to return the <code>unparsed_record</code> from the database.</li>
</ul>
<div class="readable-text" id="p163">
<p>We will cover this code in chapter 9 when talking about auditing. For now, feel free to take a shot at completing it.</p>
</div>
<div class="readable-text" id="p164">
<h2 class="readable-text-h2"><span class="num-string">8.7</span> Insights into exceptions with the UI</h2>
</div>
<div class="readable-text" id="p165">
<p>In previous sections, we have built the ability to create exception files, identify those exceptions, log them appropriately, and finally return the information from an API. Now, we can look at how to incorporate viewing the exceptions in our dashboard. We likely want to provide the users with successively more specific views that drill down into the exceptions. For example,</p>
</div>
<ul>
<li class="readable-text" id="p166">Exceptions for all files are useful for operations to get a sense of the exceptions in the system and for analyzing the number/types of exceptions being encountered.</li>
<li class="readable-text" id="p167">Exceptions for a specific file could be useful for determining if the file needs to be removed and reprocessed.</li>
<li class="readable-text" id="p168">Exceptions for a specific batch are useful for determining if a particular company is having a problem. Also, a file could still be processed with only a specific batch being rejected.</li>
<li class="readable-text" id="p169">Exceptions for a specific entry may be useful to work with a client or company to resolve what caused an exception.</li>
</ul>
<div class="readable-text" id="p170">
<p>Is it necessary to provide all these views? Certainly, the customers will have their input, and the business will provide us with direction. In addition, the business will take our input as well. Some of these may be easier or more efficient, depending on how things are set up. In our case, we can easily provide exceptions for all files and specific files, so we will start there.</p>
</div>
<div class="readable-text" id="p171">
<h3 class="readable-text-h3"><span class="num-string">8.7.1</span> Showing all the exceptions</h3>
</div>
<div class="readable-text" id="p172">
<p>The easiest way to get insight into all exceptions is to provide a navigation button on the left-hand side of the screen to view all our exceptions for the day (we say “day,” but we are going to leave filtering by day as an exercise for you). Remember that, eventually, to provide a better UX, we need to offer users the ability to search and filter. Multiple ACH files will be loaded daily and users will soon become overwhelmed, or the dashboard will become unresponsive if we are not careful with the amount of data we are pushing to the user. When we get to the point where the number of exceptions starts causing problems with the performance and UX, we will need to look at limiting the data by providing pagination, searching capabilities, and other strategies to limit the data being retrieved at a time.</p>
</div>
<div class="readable-text intended-text" id="p173">
<p>With that in mind, we can review updating NavButtons.tsx to navigate to the exceptions page.</p>
</div>
<div class="browsable-container listing-container" id="p174">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.30<span class="CharOverride-4"> </span>Adding the error navigation to the dashboard</h5>
<div class="code-area-container">
<pre class="code-area">&lt;ListItemButton onClick={() =&gt; route.push("/exceptions")}&gt;
   &lt;ListItemIcon&gt;
      &lt;Error/&gt;
   &lt;/ListItemIcon&gt;
   &lt;ListItemText primary="Exceptions"/&gt;
&lt;/ListItemButton&gt;</pre>
</div>
</div>
<div class="readable-text" id="p175">
<p>Once we have the button, we will need to create the actual page. The page should meet the following requirements:</p>
</div>
<ul>
<li class="readable-text" id="p176">Displays a list of all exceptions</li>
<li class="readable-text" id="p177">Allows viewing the record causing the exception</li>
<li class="readable-text" id="p178">Enables navigation to the file when the row is clicked</li>
</ul>
<div class="readable-text" id="p179">
<p>Those are some straightforward requirements. Let’s see how to accomplish them. First, we want to display the exceptions using a DataGrid element as we did for some of the other data on our pages. Recall that the DataGrid element from Material UI (MUI) allows us to sort, search, and filter, making it fully functional with very little work on our part. The following listing shows the basic API call used to retrieve exceptions from <span class="Hyperlink">http:</span><span class="Hyperlink">/</span><span class="Hyperlink">/localhost:8000/api/v1/files/exceptions</span> and populate them to our <br/>DataGrid.</p>
</div>
<div class="browsable-container listing-container" id="p180">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.31<span class="CharOverride-4"> </span>API Calls to populate the DataGrid</h5>
<div class="code-area-container">
<pre class="code-area">…
    const [entries, setEntries] = useState&lt;AchExceptionsResponse[]&gt;([]);
…
    useEffect(() =&gt; {
        const apiUrl = process.env #1
<span class="CharOverride-6">➥</span>.NEXT_PUBLIC_API_URL ?? ''; 
        axios.get&lt;AchExceptionsResponse[]&gt; #2
<span class="CharOverride-6">➥</span>(`${apiUrl}/files/exceptions`,  #2
            {    #2
            headers: {  #2
                'Content-Type': 'application/json' #2
            }  #2
        })  #2
            .then(response =&gt; {  #2
                console.log(`Response data <br/>${JSON.stringify(response.data)}`);  #2
                setEntries(response.data);  #2
            })  #2
            .catch(error =&gt; {  #2
                console.log(error);  #2
            });  #2
    }, []); #2
… #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">The URL for our API</span>
<br/>#2 
     <span class="CharOverride-5">Axios call to get all exceptions</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p181">
<p>With DataGrid, we are taking another approach to show additional functionality (listing 8.32). We define a column consisting of an info icon and use <code>renderCell</code> to add the icon. This can be a handy way to control the contents of the cell, especially in the case where we are not mapping something directly to our table. We also make use of another function—the <code>valueGetter</code>—to convert the date we receive using our <code>convertDateFormat</code> we have defined previously.</p>
</div>
<div class="browsable-container listing-container" id="p182">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.32<span class="CharOverride-4"> </span>Defining the DataGrid</h5>
<div class="code-area-container">
<pre class="code-area">…
    const columns: GridColDef[] = [
        {field: 'view', headerName: 'View', 
<span class="CharOverride-6">➥</span> sortable: false, width: 10, renderCell: (params) =&gt; (
                &lt;IconButton  #1
                    onClick={(e) =&gt; {  #1
                        e.preventDefault();  #1
                        setIsOpen(true);  #1
                    }}  #1
                    color="primary"  #1
                    <span>▶</span> #1
<span>                    &lt;InfoIcon /&gt; </span> #1
<span>                &lt;/IconButton&gt; </span> #1
<span>            )},</span>
<span>        </span>{field: 'file_name', headerName: 'Filename', width: 150},
        {field: 'created_at', headerName: 'Date',
<span class="CharOverride-6">➥</span> width: 150, valueGetter: (params) =&gt; convertDateFormat(params.value)},
        {field: 'record_number', headerName: 'Record Number', width: 150},
        {field: 'exception_code', headerName: 'Code', width: 10},
        {field: 'description', headerName: 'Description', width: 300},
    ]
…
&lt;DataGrid columns={columns} rows={entries}/&gt; #2
… 
            &lt;AlertMessage open={isOpen} setOpen={setIsOpen} #3
      message="Exception Record" title="Record Exception" /&gt; 
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Defines a clickable icon that can be used to show the unparsed record</span>
<br/>#2 
     <span class="CharOverride-5">The grid of exceptions uses the MUI DataGrid component.</span>
<br/>#3 
     <span class="CharOverride-5">Reuses our AlertMessage component and shows the exception record</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p183">
<p>With our API and DataGrid complete, we should now be able to upload a file with an exception, navigate to this page, and see our exception listed. When the info icon is clicked, we render a static message as a placeholder. Instead of that static message, let’s use an API call instead to retrieve the actual record so we can display the unparsed record. Why not return the unparsed record when we pass the list of exceptions back? We could certainly do that; however, there are a few reasons to avoid it:</p>
</div>
<ol>
<li class="readable-text" id="p184"><em>Passing back unnecessary dat</em><em>a</em>—Since it is unlikely that a user is going to click on every exception in the list, a lot of that data will remain unused.</li>
<li class="readable-text" id="p185"><em>Separation of dutie</em><em>s</em>—We want this API to function as an overview of our exceptions. Returning the data using a separate API call helps keep the code for the API and SQL simpler. </li>
<li class="readable-text" id="p186"><em>Security consideration</em><em>s</em>—The unparsed records could have account numbers and other sensitive NPI data that we do not want to be passed back all the time. By making it a separate API call, we can control who may be able to view those details and also log exactly when someone views that data.</li>
</ol>
<div class="readable-text" id="p187">
<p>With the understanding that showing the unparsed record could open up showing NPI data, we can make a call to get the unparsed record and display it in the alert box. Of course, we may eventually want to make use of the other details we have for the exception and create a better-formatted window. For now, simply displaying the record in question is enough. We can use the <code>params.row</code> to retrieve the needed information from the row that was clicked. The following listing shows the updated code that goes into the icon button.</p>
</div>
<div class="browsable-container listing-container" id="p188">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.33<span class="CharOverride-4"> </span>The updated icon button</h5>
<div class="code-area-container">
<pre class="code-area">&lt;IconButton
   onClick={(e) =&gt; {
      e.preventDefault();
      const fileId = params.row.file_id; #1
      const exceptionId = params.row.id; 
      const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? ''; #2
      axios.get&lt;AchExceptionDetailsResponse&gt;( #3
         `${apiUrl}/files/${fileId}/exceptions/ 
<span class="CharOverride-6">➥</span>${exceptionId}`, { 
         headers: { 
            'Content-Type': 'application/json'
         } 
      }) 
      .then(response =&gt; { #4
         setUnparsedRecord(response.data.unparsed_record);  #4
         setIsOpen(true);  #4
      })  #4
      .catch(error =&gt; { #5
         setUnparsedRecord(error.message)  #5
         setIsOpen(true);  #5
      });  #5
   }}
color="primary"&gt;
…
&lt;/IconButton&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Retrieves the IDs for both the file and exception for the row</span>
<br/>#2 
     <span class="CharOverride-5">Our API URL</span>
<br/>#3 
     <span class="CharOverride-5">Axios call to get the unparsed record</span>
<br/>#4 
     <span class="CharOverride-5">Upon response, sets the unparsed record and the Boolean for the dialog</span>
<br/>#5 
     <span class="CharOverride-5">If there is an error, shows it in the dialog instead</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p189">
<p>We now have a way to view exceptions and the record causing the error. That should be useful to our end-users. However, should they click on exceptions whenever an ACH file is uploaded? Let’s update our initial Recent ACH Uploads screen to have an indicator next to the filename when it is a file that has exceptions. </p>
</div>
<div class="readable-text" id="p190">
<h3 class="readable-text-h3"><span class="num-string">8.7.2</span> A visual cue for exceptions</h3>
</div>
<div class="readable-text" id="p191">
<p>When we first view our dashboard, there should be some indication that a loaded file has exceptions. We do this by updating our dashboard to include an icon whenever a file contains exceptions. We make the following updates:</p>
</div>
<ol>
<li class="readable-text" id="p192">SQL query needs to return a Boolean value indicating a file has exceptions.</li>
<li class="readable-text" id="p193">API needs to return the new field as <code>has_exceptions</code>.</li>
<li class="readable-text" id="p194">UI needs to check this field to display an icon when it is true.</li>
</ol>
<div class="readable-text" id="p195">
<p>We first create a couple of test scenarios so that we can work on the first two items on our list. The following listing shows the newly added scenarios.</p>
</div>
<div class="browsable-container listing-container" id="p196">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.34<span class="CharOverride-4"> </span>Scenarios testing <code>has_exceptions</code></h5>
<div class="code-area-container">
<pre class="code-area">  Scenario: I should not have any exceptions
    Given that I have a clean database
    And that I have posted the file "sample.ach"
    When I request a list of files
    Then the has_exceptions field should be False

  Scenario: I should get a file even when it has an exception
    Given that I have a clean database
    And that I have posted the file "invalid_file_id.ach"
    When I request a list of files
    Then I should have a response that includes
<span class="CharOverride-6">➥</span> the file "invalid_file_id.ach"
    And the has_exceptions field should be True</pre>
</div>
</div>
<div class="readable-text" id="p197">
<p>The <code>get_files_response</code> can be updated to include the <code>has_exceptions</code> field. The following listing shows how we use a Common Table Expression (CTE) to get a list of unique <code>ach_files_id</code> values and then convert those to a Boolean value to use in <code>has_exceptions</code>.</p>
</div>
<div class="browsable-container listing-container" id="p198">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.35<span class="CharOverride-4"> </span>Updating SQL for <code>get_files_response</code></h5>
<div class="code-area-container">
<pre class="code-area">WITH exceptions AS (  #1
   SELECT DISTINCT(afe.ach_files_id)  #1
   FROM ach_exceptions AS afe #1
)  #1
SELECT af.ach_files_id AS id,
       af.file_name AS filename,
       af.created_at AS date,    
       afh.immediate_origin_name AS originator,                 
       afcr.total_debit_entry_dollar_amount AS debit_total, 
       afcr.total_credit_entry_dollar_amount AS credit_total,
       CASE #2
          WHEN exceptions.ach_files_id IS NOT NULL THEN TRUE #3
       ELSE FALSE #3
       END AS has_exceptions #3
       FROM ach_files AS af
INNER JOIN ach_records_type_1 AS art1 USING (ach_files_id)
INNER JOIN ach_records_type_9 AS art9 USING (ach_records_type_1_id)
LEFT JOIN ach_file_headers AS afh USING (ach_records_type_1_id)
LEFT JOIN ach_file_control_records AS afcr USING (ach_records_type_9_id) 
LEFT JOIN exceptions USING (ach_files_id) #3
ORDER BY af.created_at DESC
LIMIT %s
OFFSET %s   </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Creates a CTE to get the distinct file IDs</span>
<br/>#2 
     <span class="CharOverride-5">Uses a case statement to set a Boolean field called has_exceptions</span>
<br/>#3 
     <span class="CharOverride-5">Since not every file has exceptions, uses LEFT JOIN</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p199">
<p>And now we can update the UI to support the new <code>has_exceptions</code> field as well. </p>
</div>
<div class="browsable-container listing-container" id="p200">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.36<span class="CharOverride-4"> </span>Updated API mapping</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">const transformedData: AchFiles[] = response.data.map
<span class="CharOverride-6">➥</span>((row: AchFilesResponse) =&gt; ({
   id: row.id,
   date: row.date,
   filename: row.filename,
   originator: row.originator,
   creditTotal: new Decimal(row.credit_total),
   debitTotal: new Decimal(row.debit_total),
<strong>   hasExceptions: row.has_exceptions </strong>#1
}));</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">The new field to determine if a file has exceptions</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p201">
<p>And the updated RecentAchUploads.tsx</p>
</div>
<div class="browsable-container listing-container" id="p202">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.37<span class="CharOverride-4"> </span>Displaying an error icon</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">import {ErrorOutlineOutlined} from "@mui/icons-material";
…
&lt;TableCell&gt;
   &lt;Link onClick={() =&gt; route.push(`/fileDetails/${file.id}`)} 
         sx={{ cursor: 'pointer' }}&gt;{file.filename}&lt;/Link&gt;
<strong>      {file.hasExceptions &amp;&amp;</strong>
<span class="CharOverride-6">➥</span><strong> &lt;ErrorOutlineOutlined color="error" /&gt;} </strong>#1
&lt;/TableCell&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">If a file has exceptions, displays </span>
<span class="CharOverride-5">an icon to indicate it has them</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p203">
<p>With that, when an ACH file with exceptions is uploaded, there should be a visual indication on our Recent ACH Uploads, as shown in figure 8.4.</p>
</div>
<div class="browsable-container figure-container" id="p204">
<img alt="A close-up of a computer screen  Description automatically generated" height="188" src="../Images/CH08_F04_Kardell.png" style="width: 100%; max-width: max-content;" width="875"/>
<h5 class="figure-container-h5"><span class="">Figure 8.4</span><span class=""> </span><span class="">Visual indication of a file error</span></h5>
</div>
<div class="readable-text" id="p205">
<h2 class="readable-text-h2"><span class="num-string">8.8</span> Additional UI changes</h2>
</div>
<div class="readable-text" id="p206">
<p>Now that we have the basic structure of our exception viewing, we can take care of a few other requests that came from users during the initial MVP evaluation. </p>
</div>
<ol>
<li class="readable-text" id="p207">The files screen should also show the specific exceptions for that file. This should follow after our initial exception handling. We can refactor our UI exception page to become a component and pass the needed exception information into it.</li>
<li class="readable-text" id="p208">The batch screen should contain a component with statistics such as totals and a line-item breakdown of the transaction codes.</li>
<li class="readable-text" id="p209">Our listing of the items in the batch should contain the applications they are associated with, such as Checking, Savings, and so forth. While the transaction codes relate to those applications, ensuring they are included in our DataGrid will provide a better UX.</li>
<li class="readable-text" id="p210">Our screens should be more responsive to size changes. Currently, our components are stacked in a column, and we would like to have them use up the available width as well.</li>
</ol>
<div class="readable-text" id="p211">
<h3 class="readable-text-h3"><span class="num-string">8.8.1</span> Creating an exceptions component</h3>
</div>
<div class="readable-text" id="p212">
<p>We can refactor our page to create an exception component, which will help prevent code duplication when we want to present errors elsewhere. The exception information that we need to display is the same, regardless of whether we want to view all exceptions or just filter them by file. On the one hand, that means we could easily copy and paste that existing page to create a new page or component that filters on our file, and we would be done. On the other hand, we could create a common exception component that both pages can use, passing to it either the full list of exceptions or one that has been filtered for a particular file. As we have stated previously, whenever feasible, we want to avoid duplicating work as that may pay off in the short term by getting something out the door, but future maintenance becomes difficult and tedious as fixes must be applied multiple times. The following listing shows the results of pulling the DataGrid and the associated calls from the original page into a stand-alone component.</p>
</div>
<div class="browsable-container listing-container" id="p213">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.38<span class="CharOverride-4"> </span>Stand-alone exception component</h5>
<div class="code-area-container">
<pre class="code-area">…
interface ExceptionsProps {
    exceptions: AchExceptionsResponse[];
}

export default function Exceptions({exceptions}:
<span class="CharOverride-6">➥</span> Readonly&lt;ExceptionsProps&gt;) {

    const [isOpen, setIsOpen] = useState(false);
    const [unparsedRecord, setUnparsedRecord] = useState('');
    const columns: GridColDef[] = [
…
           &lt;DataGrid columns={columns} rows={exceptions}/&gt;
…
           &lt;AlertMessage open={isOpen} setOpen={setIsOpen}
<span class="CharOverride-6">➥</span> message={unparsedRecord} title="Unparsed Record" /&gt;
…</pre>
</div>
</div>
<div class="readable-text" id="p214">
<p>With our new exceptions component, we can include it in the existing <code>fileDetails</code> page by calling the <code>/file/{fileId}/exceptions</code> endpoint to get a list of exceptions for the file we are viewing and passing the results to our new component. The following listing shows the required changes.</p>
</div>
<div class="browsable-container listing-container" id="p215">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.39<span class="CharOverride-4"> </span>Using our new component</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">…
import Exceptions from "@/app/components/Exceptions";
import {AchExceptionsResponse} from "@/app/interfaces/AchExceptionsResponse"; 
…  axios.get&lt;AchExceptionsResponse[]&gt;(`${apiUrl}/files/
<span class="CharOverride-6">➥</span>${fileId}/exceptions`, {
            headers: {
                'Content-Type': 'application/json'
            }
        })
            .then(response =&gt; {
                console.log(`Response data ${JSON.stringify(response.data)}`);
                setExceptions(response.data); #1
            })
            .catch(error =&gt; {
                <span>console.log(error);</span>
<span>            });</span>

<span>    }, []);</span>
<span>…</span>
<strong>      &lt;Exceptions exceptions={exceptions} /&gt; </strong>#2
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Sets the returned exceptions</span>
<br/>#2 
     <span class="CharOverride-5">Includes our new component passing the exceptions to it</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p216">
<p>We love how by creating components, it becomes so easy to import and use them anywhere we may need them. The only thing we want to stress about this is to be careful about the data that a component may need or fetch. We may have to evaluate whether we want to pass data to it or have it request data itself. As we saw previously with the dashboard, sometimes we can save redundant API calls by passing the required data in. We did leave the fetching of our unparsed records within the component because those are occasional calls that are best encapsulated in the component.</p>
</div>
<div class="readable-text" id="p217">
<h3 class="readable-text-h3"><span class="num-string">8.8.2</span> Batch statistics component</h3>
</div>
<div class="readable-text" id="p218">
<p>We can now tackle the batch statistics component. This request is meant to give users a quick overview of some important aspects of the batch, as shown in figure 8.5. </p>
</div>
<div class="browsable-container figure-container" id="p219">
<img alt="A screenshot of a statistics  Description automatically generated" height="305" src="../Images/CH08_F05_Kardell.png" style="width: 100%; max-width: max-content;" width="260"/>
<h5 class="figure-container-h5"><span class="">Figure 8.5</span><span class=""> </span><span class="">Batch statistics component</span></h5>
</div>
<div class="readable-text" id="p220">
<p>While charts and graphs provide nice visualizations and can help compare large amounts of data, we will use a simple list for this component as we only need to provide a handful of totals for our overview.</p>
</div>
<div class="readable-text intended-text" id="p221">
<p>We will continue to use the existing <code>AchBatch­EntriesResponse</code> for this component. Using a simple list and items from MUI, we can create our component. We use the <code>ListItemText</code> for displaying primary and secondary text. We also create some of the elements with <code>createListItems</code> and include them in the render. The following listing shows our basic component.</p>
</div>
<div class="browsable-container listing-container" id="p222">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.40<span class="CharOverride-10"> </span>The<code> AchBatchStatistics</code> component</h5>
<div class="code-area-container">
<pre class="code-area">export default function AchBatchStatistics({entries}:
<span class="CharOverride-6">➥</span> Readonly&lt;AchBatchStatisticsProps&gt;) {

    const computedBatchStatistics = #1
<span class="CharOverride-6">➥</span> computeBatchStatistics(entries);  #1
    const computedBatchTotals =  #1
<span class="CharOverride-6">➥</span> computeBatchTotals(entries);  #1
    const listItems =  #1
<span class="CharOverride-6">➥</span> createListItems(computedBatchStatistics);  #1

    return (
        &lt;&gt;
           &lt;Title&gt;Batch Statistics&lt;/Title&gt;
           &lt;List dense={true}&gt;
              &lt;ListItem key="creditTotal"&gt;
                 &lt;ListItemText 
                    primary="Credit Total" 
                secondary={`${formatCurrency(computedBatchTotals.credit)}`} 
                 /&gt;
              &lt;/ListItem&gt;
              &lt;ListItem key="debitsTotal"&gt;
                 &lt;ListItemText
                    primary="Debit Total" 
                secondary={`${formatCurrency(computedBatchTotals.debit)}`} 
                 /&gt;
              &lt;/ListItem&gt;
              &lt;ListItem key="otherTotal"&gt;
                 &lt;ListItemText 
                    primary="Other Total" 
                 secondary={`${formatCurrency(computedBatchTotals.other)}`} 
                 /&gt;
              &lt;/ListItem&gt;
                 {listItems} #2
              &lt;/List&gt;
        &lt;/&gt;
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Helper functions to collect, aggregate, and format data as necessary</span>
<br/>#2 
     <span class="CharOverride-5">Includes any additional ListItem elements</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p223">
<p>In the following listing, we created the <code>computeBatchTotals</code> function to provide a sum of our debits, credits, and other amounts. We will end up supporting additional transaction codes, but for now, we will only be considering the transaction codes 22 and 27. Also, because the <code>AchBatchEntriesResponse</code> had formatted the amounts, we needed to strip those characters away. Ideally, we would like to go back and not have the response format those amounts, but that may not always be practical.</p>
</div>
<div class="browsable-container listing-container" id="p224">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.41<span class="CharOverride-4"> </span>The <code>computeBatchTotals </code>function</h5>
<div class="code-area-container">
<pre class="code-area">function computeBatchTotals
<span class="CharOverride-6">➥</span>(entries: AchBatchEntriesResponse[]): BatchTotals {
    const totals: BatchTotals = {  #1
        debit: new Decimal(0),  #1
        credit: new Decimal(0),  #1
        other: new Decimal(0)  #1
    };  #1
    entries.forEach(entry =&gt; {
        const cleanAmount = entry.amount.replace(/[$,]/g, ''); #2
        const amount = new Decimal(cleanAmount);
        if (entry.transaction_code === 22) {
            totals.debit = totals.debit.plus(amount);
        } else if (entry.transaction_code === 27) {
            totals.credit = totals.credit.plus(amount);
        } else {
            totals.other = totals.other.plus(amount);
        }
    });
    return totals; #3

}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Initializes the </span>
<span class="CharOverride-5">BatchTotals object</span>
<br/>#2 
     <span class="CharOverride-5">We need to remove the currency formatting.</span>
<br/>#3 
     <span class="CharOverride-5">Returns the BatchTotals object</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p225">
<p>In listing 8.42, we also create the <code>computeBatchStatistics</code> function that contains counts and amounts for each transaction. For simplicity’s sake of the code and testing, we create another function that spins through the entries in the batch. We group the items by their description because we will make use of that when we display them.</p>
</div>
<div class="browsable-container listing-container" id="p226">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.42<span class="CharOverride-4"> </span>The <code>computeBatchStatistics f</code>unction</h5>
<div class="code-area-container">
<pre class="code-area">function computeBatchStatistics
<span class="CharOverride-6">➥</span>(entries: AchBatchEntriesResponse[]):
<span class="CharOverride-6">➥</span> Map&lt;string, BatchStatistics&gt; {
    const countMap = new Map&lt;string, BatchStatistics&gt;(); #1
    entries.forEach(entry =&gt; {  #2
        const cleanAmount = entry.amount.replace(/[$,]/g, ''); #3
        const stats = countMap.get(entry.transaction_description)  #4
<span class="CharOverride-6">➥</span> || { count: 0, amount: new Decimal(0) }; 
        stats.count += 1; #5
        stats.amount = stats.amount.plus(cleanAmount); #6
        countMap.set(entry.transaction_description, stats); #7
    });
    return countMap;
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Defines a new map of the BatchStatistics</span>
<br/>#2 
     <span class="CharOverride-5">Each entry in the batch will be processed.</span>
<br/>#3 
     <span class="CharOverride-5">Removes the formatting from the amount</span>
<br/>#4 
     <span class="CharOverride-5">Tries to get an entry for the description; if not found, initializes one</span>
<br/>#5 
     <span class="CharOverride-5">Increments the count</span>
<br/>#6 
     <span class="CharOverride-5">Uses the plus method from the Decimal package to maintain the amount</span>
<br/>#7 
     <span class="CharOverride-5">Saves the entry</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p227">
<p>We are ready to add the <code>BatchStatistics</code> we returned to our component. We dynamically create our <code>ListItem</code> elements in a function named <code>createListItems</code>, which takes our map of items and returns an array of React elements, as the following listing shows. With this approach, we can create as many elements as needed and return them in one swoop. Of course, we would need to be careful not to create too many elements, or otherwise create something that will not provide a meaningful user experience.</p>
</div>
<div class="browsable-container listing-container" id="p228">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.43<span class="CharOverride-4"> </span>The c<code>reateListItems</code> function</h5>
<div class="code-area-container">
<pre class="code-area">…
interface BatchStatistics { #1
    count: number;  #1
    amount: Decimal;  #1
}  #1
…
function createListItems
<span class="CharOverride-6">➥</span>(entries: Map&lt;string, BatchStatistics&gt;): React.ReactNode[] {
    const listItems: React.ReactNode[] = []; #2
    entries.forEach((entry: BatchStatistics, key: string) =&gt; {
        const listItem = (&lt;ListItem key={key}&gt; #3
            &lt;ListItemText primary={key}   #3
                  secondary={`Count: ${entry.count} Amount:  #3
${formatCurrency(entry.amount)}`} /&gt;  #3
        &lt;/ListItem&gt;); 
        listItems.push(listItem); #4
    });
    return listItems; #5
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Defines an interface so that we can easily reference our data</span>
<br/>#2 
     <span class="CharOverride-5">Creates an empty </span>
<span class="CharOverride-5">array of nodes</span>
<br/>#3 
     <span class="CharOverride-5">Creates a ListItem </span>
<span class="CharOverride-5">element</span>
<br/>#4 
     <span class="CharOverride-5">Adds it to the array</span>
<br/>#5 
     <span class="CharOverride-5">Returns the array</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p229">
<p>Finally, we can add some unit testing to this component. While we could have started with this approach, we also want to show that adding unit tests can be done at other points in our development as well. Typically, we add these unit tests at the point where we realize that we need something extra to process the data being returned. To make our testing easier, we will need to export the functions we used within the component. That may present opportunities to refactor the code to further remove the logic from the component, but for now, we will not take it that far.</p>
</div>
<div class="browsable-container listing-container" id="p230">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.44<span class="CharOverride-4"> </span>Jest test for <code>computBatchTotals</code></h5>
<div class="code-area-container">
<pre class="code-area">…
describe('Compute Batch Totals', () =&gt; {
   it('Has a debit for 1', () =&gt; {
      const achBatchEntriesResponse: #1
<span class="CharOverride-6">➥</span> AchBatchEntriesResponse[] = [{  #1
         id: 'test1',  #1
         transaction_code: 27,  #1
         application: "Checking",  #1
         transaction_description: "Debit",  #1
         amount: "1.00",  #1
         individual_name: "John Doe",  #1
         account_number_last_4: "*********1234",  #1
         addenda_count: 0 #1
      }]  #1
      const result = computeBatchTotals #2
<span class="CharOverride-6">➥</span>(achBatchEntriesResponse) 
      expect(result.debit.toNumber())   #3
                         .toBe(new Decimal("1").toNumber()) 
})</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Creates mock data</span>
<br/>#2 
     <span class="CharOverride-5">Passes it to our computeBatchTotals routine</span>
<br/>#3 
     <span class="CharOverride-5">Validates the result</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p231">
<p>From there, we can add additional entries for the same transaction code, different transaction codes, and anything else we may be interested in testing. This is a great way to test some of the edge cases that may require us to deliberately provide data, especially if we need to test exception conditions. With this basic test, we can create additional tests and start evaluating test coverage before moving on to our next enhancement request.</p>
</div>
<div class="readable-text" id="p232">
<h3 class="readable-text-h3"><span class="num-string">8.8.3</span> Adding the application</h3>
</div>
<div class="readable-text" id="p233">
<p>A relatively straightforward request is to add an application column, as shown in figure 8.6. While it is possible to determine the application from the transaction code for a better UX, we can provide the mapping as part of our returned data.</p>
</div>
<div class="browsable-container figure-container" id="p234">
<img alt="" height="244" src="../Images/CH08_F06_Kardell.png" style="width: 100%; max-width: max-content;" width="867"/>
<h5 class="figure-container-h5"><span class="">Figure 8.6</span><span class=""> </span><span class="">The batch entry screen with the added column</span></h5>
</div>
<div class="readable-text" id="p235">
<p>This type of request allows us to work through all the pieces of our application, letting us get another taste of the full stack experience using BDD. We can create a feature file named ach_entries_endpoint.feature containing the scenario, as shown in the following listing. </p>
</div>
<div class="browsable-container listing-container" id="p236">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.45<span class="CharOverride-4"> </span>Our feature file and scenario</h5>
<div class="code-area-container">
<pre class="code-area">Feature: The /files/{fileId}/batches/{batchId}/entries endpoint
  Test returning entries for a batch

  Scenario: I want to check the entries for a Checking Application
    Given that I have a clean database
    And that I have posted the file "ppd-single-credit.ach"
    When I request entries for a file and batch
    Then I should have a response that includes all
<span class="CharOverride-6">➥</span> applications of "Checking"</pre>
</div>
</div>
<div class="readable-text" id="p237">
<p>The scenario shares some similarities with how we tested the files endpoint; however, we chose to create a separate step definition file to support this feature. This decision allows us to keep the scenario-specific steps isolated and gives us the ability to test only this particular feature. The following listing shows some of the step definitions that support running the scenario.</p>
</div>
<div class="browsable-container listing-container" id="p238">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.46<span class="CharOverride-4"> </span>Step definitions for our feature</h5>
<div class="code-area-container">
<pre class="code-area">…
scenarios("../features/ach_entries_endpoint.feature")
…
@when('I request entries for a file and batch')
def request_unparsed_record(api_response):
    <span>response = client.get("/api/v1/files/")</span>
<span>    assert response.status_code == 200, response.text</span>
<span>    file_id = response.json()[0]["id"]</span>
<span>    response = client.get(f"/api/v1/files/{file_id}/batches")</span>
<span>    assert response.status_code == 200, response.text</span>
<span>    </span>batch_id = response.json()[0]["id"]
    response = client.get(f"/api/v1/files/{file_id}/
<span class="CharOverride-6">➥</span>batches/{batch_id}/entries")
    assert response.status_code == 200, response.text
    api_response["response"] = response.json()


@then(parsers.parse('I should have a response
<span class="CharOverride-6">➥</span> that includes all applications of \"{application}\"'))
def response_that_includes_file(application, api_response):
    assert all(
        response["application"] == application for
<span class="CharOverride-6">➥</span> response in api_response["response"]
    ), f"Expected {application} in" f" {api_response['response']}"
…</pre>
</div>
</div>
<div class="readable-text" id="p239">
<p>With the ability to test the endpoint, we can now work on ensuring the application will be returned as part of the API. We can tackle these steps in several different orders, but we chose to start by updating the <code>AchBatchEntriesResponse</code> to include the application field, as shown in the following listing. This field is not coming from the database, and it is not technically part of the ACH file layout. Therefore, we limit the maximum length of the field to the longest word we plan on having there, which is “checking.”</p>
</div>
<div class="browsable-container listing-container" id="p240">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.47<span class="CharOverride-4"> </span>The updated <code>AchBatchEntriesResponse</code></h5>
<div class="code-area-container">
<pre class="code-area">…
application: str = Field(
   default=...,
   description="The application that the entry is associated with.",
   title="Application",
   max_length=8, #1
)
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Sets the max length for this field to the longest text we expect</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p241">
<p>Next, we update our query to pass back the application name based on the transaction code using a <code>CASE</code> statement, as shown in listing 8.48. As mentioned, there is some freedom in application naming. We could potentially choose to group both checking and savings accounts under the name Demand Deposit Accounts (DDA), which is another term used in the financial industry. The actual name for the application would be something that the business provides to us. We like having a bit more granularity in the application name, so we chose to use the names “Savings,” “Checking,” “GL” for General Ledger, “Loan,” and “Unknown” (to identify any transaction codes that we may have missed or in case of an incorrect transaction code in the database).</p>
</div>
<div class="browsable-container listing-container" id="p242">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.48<span class="CharOverride-4"> </span>Updated query to support the <code>transaction_code</code></h5>
<div class="code-area-container">
<pre class="code-area">CASE 
   WHEN aepd.transaction_code IN (31, 32, 33,
<span class="CharOverride-6">➥</span> 34, 36, 37, 38, 39) #1
      THEN 'Savings' #1
   WHEN aepd.transaction_code IN (21, 22, 23, #1
<span class="CharOverride-6">➥</span> 24, 26, 27, 28, 29)   #1
      THEN 'Checking' #1
   WHEN aepd.transaction_code IN (41, 42, 43, 46, 47, 48)   #1
      THEN 'GL' #1
   WHEN aepd.transaction_code IN (51, 52, 53, 55, 56 )  #1
      THEN 'Loan' #1
   ELSE 'Unknown' #1
END AS application,  #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Maps transaction codes to the application</span>
<br/>#2 
     <span class="CharOverride-5">Names the resulting column as application</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p243">
<p>Finally, we want to update our DataGrid to add the column. With all the heavy lifting already done by the server, we simply need to add the column and update the interface to include the application as well.</p>
</div>
<div class="browsable-container listing-container" id="p244">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.49<span class="CharOverride-4"> </span>Added column and field</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">const columns: GridColDef[] = [
…
   { <strong>field: 'application',  </strong>#1
<strong>     headerName: 'Application',  </strong> #1
<strong>     width: 150}, </strong>
…
export interface AchBatchEntriesResponse {
…
    application: string;
…
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Includes the application column in our columns definition</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p245">
<p>We should now be able to navigate to our dashboard and drill down to see the application column being populated. This small example is a great way to illustrate why we love full stack development. We were able to work on unit testing, Python, APIs, and Typescript!</p>
</div>
<div class="readable-text" id="p246">
<h3 class="readable-text-h3"><span class="num-string">8.8.4</span> Making our UI more responsive</h3>
</div>
<div class="readable-text" id="p247">
<p>Currently, our dashboard components are stacked on top of each other. The MUI package that we have been using for our components provides options for controlling the layout that will help make our dashboard more responsive. We replace the <code>Box</code> elements that we wrapped our components in with a <code>Grid</code> container and <code>Grid</code> items. In addition, there are attributes <code>xs</code>, <code>sm</code>, <code>md</code>, <code>lg</code>, and <code>xl</code> that can be used to provide breakpoints based on screen size. This means that we can customize our layouts for all different screen sizes. The following listing shows an example of using a grid with various breakpoints. The given items will be displayed in a column when the screen is small, and when expanded, it will contain more items per row, with all nine items in a single row when the screen is wide enough to accommodate them.</p>
</div>
<div class="browsable-container listing-container" id="p248">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.50<span class="CharOverride-4"> </span>Example of a responsive grid</h5>
<div class="code-area-container">
<pre class="code-area">import React from 'react';
import { Paper, Typography } from '@mui/material';
import Grid from '@mui/material/Unstable_Grid2'; #1


const ResponsiveCards = () =&gt; {
    return (
        &lt;Grid container spacing={2} sx={{pl: 1, pr: 1}}&gt;  #2
            {[1,2,3,4,5,6,7,8,9].map((value) =&gt; ( #3
                &lt;Grid xs={12} sm={6} md={4} 
<span class="CharOverride-6">➥</span>lg={2} xl={1} key={value} &gt; #4
                    &lt;Paper elevation={3} sx={{ padding: 2 }}&gt;
                        &lt;Typography variant="h5" component="h3"&gt;
                            Card {value}
                        &lt;/Typography&gt;
                        &lt;Typography component="p"&gt;
                            This is some content
<span class="CharOverride-6">➥</span> inside card number {value}.
                        &lt;/Typography&gt;
                    &lt;/Paper&gt;
                &lt;/Grid&gt;
            ))}
        &lt;/Grid&gt;
    );
};
export default ResponsiveCards;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Uses the latest </span>
<span class="CharOverride-5">Grid element</span>
<br/>#2 
     <span class="CharOverride-5">Defines a container grid</span>
<br/>#3 
     <span class="CharOverride-5">Defines nine elements</span>
<br/>#4 
     <span class="CharOverride-5">Grid elements are different sizes based on breakpoints.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p249">
<p>After exploring the responsiveness of the layout, we can apply the same approach to our existing components. Using the <code>Grid</code> elements to clean up some of our existing layout, we move the paper elements into our components, leaving us with just the layout elements in our page.tsx components (not counting the API calls and other needed functions). The following listing shows an example of the resulting page.tsx for the batch details screen.</p>
</div>
<div class="browsable-container listing-container" id="p250">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.51<span class="CharOverride-4"> </span>The page.tsx for batch details</h5>
<div class="code-area-container">
<pre class="code-area">return (
   &lt;Box sx={{ display: 'flex' }}&gt;
      &lt;CssBaseline /&gt;
      &lt;StandardNavigation /&gt;
      &lt;Grid container spacing={{ xs: 2, md: 3 }} #1
            columns={{ xs: 4, sm: 8, md: 12 }}   #1
            sx={{mt: 8, pl: 1, pr: 1}}&gt;  #1
         &lt;Grid xs={12} sm={6} key={1} &gt; #2
            &lt;AchTransactionCodesPieChart entries={entries} /&gt;  #2
         &lt;/Grid&gt; #B #2
         &lt;Grid xs={12} sm={6} key={2} &gt;  #2
            &lt;AchBatchStatistics entries={entries}/&gt;  #2
         &lt;/Grid&gt;  #2
         &lt;Grid xs={12} key={3} &gt;  #2
            &lt;Paper sx={{ minWidth: 1075 }}&gt;  #2
               &lt;Title&gt;Batch Entries&lt;/Title&gt;  #2
               &lt;DataGrid columns={columns} rows={entries} /&gt;  #2
            &lt;/Paper&gt;
         &lt;/Grid&gt;
      &lt;/Grid&gt;
   &lt;/Box&gt;
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-5">Defines a container</span>
<br/>#2 
     <span class="CharOverride-5">Places each of our components in a Grid element</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p251">
<p>Breakpoints can be used with other attributes as well. For instance, if we wanted to adjust the amount of <code>margin-top</code>, we could set it based on the screen size, as shown in the next listing. Notice how the margin is set to a smaller value of 4 for smaller screens and then to 12 for larger ones. </p>
</div>
<div class="browsable-container listing-container" id="p252">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.52<span class="CharOverride-4"> </span>The <code>margin-top</code> based on screen size</h5>
<div class="code-area-container">
<pre class="code-area">mt: {
   xs: 4,
   sm: 4,
   md: 12,
   lg: 12,
   xl: 12
},</pre>
</div>
</div>
<div class="readable-text" id="p253">
<p>Breakpoints offer a powerful way to help with our layout and design. We can update the default values (pixels) for each breakpoint and even rename them, as shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p254">
<h5 class="listing-container-h5 browsable-container-h5">Listing 8.53<span class="CharOverride-4"> </span>Customizing breakpoints</h5>
<div class="code-area-container">
<pre class="code-area">const theme = createTheme({
  breakpoints: {
    values: {
      mobile: 0,
      tablet: 640,
      laptop: 1024,
      desktop: 1200,
    },
  },
});</pre>
</div>
</div>
<div class="readable-text" id="p255">
<p>This chapter covered a lot, focusing on providing feedback when uploading a file that is not formatted properly. Exception handling provides a way to gracefully handle unexpected situations within the software, giving us a chance to alert the user and recover as appropriate.</p>
</div>
<div class="readable-text intended-text" id="p256">
<p>We started by looking at how we could expand our file-creation syntax to support adding these exceptions. Expanding the ability to produce files allows for easier and more robust file creation, which in turn gives us more files to load into our dashboard. </p>
</div>
<div class="readable-text intended-text" id="p257">
<p>In terms of ACH handling and Pydantic, we focused on how defining our fields provided us with validation without the need for a lot of code. We were able to limit the field length, validate formatting with regular expressions, and even go back to a database to validate entries. We also added support for handling exceptions, which allowed us to get another taste of full stack development—by updating the backend, providing APIs to allow access to data, and finally providing UI elements to view the data. </p>
</div>
<div class="readable-text intended-text" id="p258">
<p>Finally, we had the chance to expand our UI by adding new components, refactoring what was already being used, and looking at how to manipulate our layouts using breakpoints in MUI. </p>
</div>
<div class="readable-text" id="p259">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p260">After launching the MVP, user feedback highlighted both positive reception and areas for improvement, particularly the need for handling a wider variety of ACH-related exceptions.</li>
<li class="readable-text" id="p261">Planning enhancements involves prioritizing features based on user feedback and working on a timeline to implement ACH exceptions and search functionality.</li>
<li class="readable-text" id="p262">Exceptions in ACH processing can be categorized into errors, exceptions, and warnings, each with different severity and handling implications.</li>
<li class="readable-text" id="p263">Creating ACH files with exceptions involves extending BDD syntax to support file, batch, and entry-level exceptions for more robust testing and processing.</li>
<li class="readable-text" id="p264">Enhancing exception handling in ACH parsing includes using Pydantic for field validation and storing detailed exception information in the database.</li>
<li class="readable-text" id="p265">Exceptions API development focuses on enabling effective reporting and search capabilities, providing insights into file-specific errors.</li>
<li class="readable-text" id="p266">The UI is updated to display exceptions, incorporating components for viewing and filtering errors, with features such as DataGrid for interactive data presentation.</li>
<li class="readable-text" id="p267">Additional UI enhancements include creating reusable components, statistics for batches, and improving layout responsiveness using the MUI grid system.</li>
<li class="readable-text" id="p268">Utilizing unit testing and BDD helps ensure robustness and flexibility in handling ACH exceptions, while UI updates enhance UX and interaction with data.</li>
</ul>
</div></body></html>