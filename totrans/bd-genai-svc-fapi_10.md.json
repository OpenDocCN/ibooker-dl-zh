["```py\n$ docker run -p 5432:5432  \\  ![1](assets/1.png) ![2](assets/2.png)\n\t-e POSTGRES_USER=fastapi \\\n\t-e POSTGRES_PASSWORD=mysecretpassword \\\n\t-e POSTGRES_DB=backend_db \\\n\t-e PGDATA=/var/lib/postgresql/data \\ ![3](assets/3.png)\n    -v \"$(pwd)\"/dbstorage:/var/lib/postgresql/data \\ ![4](assets/4.png)\n    postgres:latest ![1](assets/1.png)\n```", "```py\n$ pip install alembic sqlalchemy psycopg3\n```", "```py\n# entities.py\n\nfrom datetime import UTC, datetime\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\n\nclass Base(DeclarativeBase): ![1](assets/1.png)\n    pass\n\nclass Conversation(Base): ![2](assets/2.png)\n    __tablename__ = \"conversations\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str] = mapped_column() ![3](assets/3.png)\n    model_type: Mapped[str] = mapped_column(index=True) ![4](assets/4.png)\n    created_at: Mapped[datetime] = mapped_column(default=datetime.now(UTC))\n    updated_at: Mapped[datetime] = mapped_column(\n        default=datetime.now(UTC), onupdate=datetime.now(UTC) ![5](assets/5.png)\n    )\n\n    messages: Mapped[list[\"Message\"]] = relationship(\n        \"Message\", back_populates=\"conversation\", cascade=\"all, delete-orphan\" ![6](assets/6.png)\n    )\n\nclass Message(Base): ![7](assets/7.png)\n    __tablename__ = \"messages\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    conversation_id: Mapped[int] = mapped_column(\n        ForeignKey(\"conversations.id\", ondelete=\"CASCADE\"), index=True ![6](assets/6.png)\n    )\n    prompt_content: Mapped[str] = mapped_column()\n    response_content: Mapped[str] = mapped_column()\n    prompt_tokens: Mapped[int | None] = mapped_column()\n    response_tokens: Mapped[int | None] = mapped_column()\n    total_tokens: Mapped[int | None] = mapped_column()\n    is_success: Mapped[bool | None] = mapped_column()\n    status_code: Mapped[int | None] = mapped_column() ![8](assets/8.png) ![9](assets/9.png)\n    created_at: Mapped[datetime] = mapped_column(default=datetime.now(UTC))\n    updated_at: Mapped[datetime] = mapped_column(\n        default=datetime.now(UTC), onupdate=datetime.now(UTC)\n    )\n\n    conversation: Mapped[\"Conversation\"] = relationship(\n        \"Conversation\", back_populates=\"messages\"\n    )\n```", "```py\n# database.py\n\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom entities import Base\n\ndatabase_url = ( ![1](assets/1.png)\n    \"postgresql+psycopg://fastapi:mysecretpassword@localhost:5432/backend_db\"\n)\nengine = create_async_engine(database_url, echo=True) ![2](assets/2.png)\n\nasync def init_db() -> None:\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all) ![3](assets/3.png)\n\n# main.py\n\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom database import engine, init_db\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    # other startup operations within the lifespan\n    ...\n    yield\n    await engine.dispose() ![4](assets/4.png)\n\napp = FastAPI(lifespan=lifespan)\n```", "```py\n# database.py\n\nfrom typing import Annotated\nfrom fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker\nfrom database import engine\n\nasync_session = async_sessionmaker(\n    bind=engine, class_=AsyncSession, autocommit=False, autoflush=False ![1](assets/1.png)\n)\nasync def get_db_session(): ![2](assets/2.png)\n    try:\n        async with async_session() as session: ![3](assets/3.png)\n            yield session ![4](assets/4.png)\n    except:\n        await session.rollback() ![5](assets/5.png)\n        raise\n    finally:\n        await session.close() ![6](assets/6.png)\n\nDBSessionDep = Annotated[AsyncSession, Depends(get_db_session)] ![7](assets/7.png)\n```", "```py\n# schemas.py\n\nfrom datetime import datetime\nfrom pydantic import BaseModel, ConfigDict\n\nclass ConversationBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True) ![1](assets/1.png)\n\n    title: str\n    model_type: str\n\nclass ConversationCreate(ConversationBase): ![2](assets/2.png)\n    pass\n\nclass ConversationUpdate(ConversationBase): ![2](assets/2.png)\n    pass\n\nclass ConversationOut(ConversationBase): ![2](assets/2.png)\n    id: int\n    created_at: datetime\n    updated_at: datetime\n```", "```py\n# main.py\n\nfrom typing import Annotated\nfrom database import DBSessionDep\nfrom entities import Conversation\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom schemas import ConversationCreate, ConversationOut, ConversationUpdate\nfrom sqlalchemy import select\n\n...\n\nasync def get_conversation(\n    conversation_id: int, session: DBSessionDep ![1](assets/1.png)\n) -> Conversation:\n    async with session.begin(): ![2](assets/2.png)\n        result = await session.execute(\n            select(Conversation).where(Conversation.id == conversation_id)\n        )\n        conversation = result.scalars().first()\n    if not conversation:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Conversation not found\",\n        )\n    return conversation\n\nGetConversationDep = Annotated[Conversation, Depends(get_conversation)]\n\n@app.get(\"/conversations\")\nasync def list_conversations_controller(\n    session: DBSessionDep, skip: int = 0, take: int = 100\n) -> list[ConversationOut]:\n    async with session.begin():\n        result = await session.execute(\n            select(Conversation).offset(skip).limit(take) ![3](assets/3.png)\n        )\n    return [\n        ConversationOut.model_validate(conversation)\n        for conversation in result.scalars().all()\n    ]\n\n@app.get(\"/conversations/{id}\")\nasync def get_conversation_controller(\n    conversation: GetConversationDep,\n) -> ConversationOut:\n    return ConversationOut.model_validate(conversation) ![4](assets/4.png)\n\n@app.post(\"/conversations\", status_code=status.HTTP_201_CREATED)\nasync def create_conversation_controller(\n    conversation: ConversationCreate, session: DBSessionDep\n) -> ConversationOut:\n    new_conversation = Conversation(**conversation.model_dump())\n    async with session.begin():\n        session.add(new_conversation)\n        await session.commit() ![5](assets/5.png)\n        await session.refresh(new_conversation)\n    return ConversationOut.model_validate(new_conversation)\n\n@app.put(\"/conversations/{id}\", status_code=status.HTTP_202_ACCEPTED)\nasync def update_conversation_controller(\n    updated_conversation: ConversationUpdate,\n    conversation: GetConversationDep,\n    session: DBSessionDep,\n) -> ConversationOut:\n    for key, value in updated_conversation.model_dump().items():\n        setattr(conversation, key, value)\n    async with session.begin():\n        await session.commit() ![5](assets/5.png)\n        await session.refresh(conversation)\n    return ConversationOut.model_validate(conversation)\n\n@app.delete(\"/conversations/{id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_conversation_controller(\n    conversation: GetConversationDep, session: DBSessionDep\n) -> None:\n    async with session.begin():\n        await session.delete(conversation)\n        await session.commit() ![5](assets/5.png)\n```", "```py\n# repositories/interfaces.py\n\nfrom abc import ABC, abstractmethod\nfrom typing import Any\n\nclass Repository(ABC): ![1](assets/1.png)\n    @abstractmethod\n    async def list(self) -> list[Any]:\n        pass\n\n    @abstractmethod\n    async def get(self, uid: int) -> Any:\n        pass\n\n    @abstractmethod\n    async def create(self, record: Any) -> Any:\n        pass\n\n    @abstractmethod\n    async def update(self, uid: int, record: Any) -> Any:\n        pass\n\n    @abstractmethod\n    async def delete(self, uid: int) -> None:\n        pass\n```", "```py\n# repositories/conversations.py\n\nfrom entities import Conversation\nfrom repositories.interfaces import Repository\nfrom schemas import ConversationCreate, ConversationUpdate\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass ConversationRepository(Repository): ![1](assets/1.png)\n    def __init__(self, session: AsyncSession) -> None:\n        self.session = session\n\n    async def list(self, skip: int, take: int) -> list[Conversation]:\n        async with self.session.begin():\n            result = await self.session.execute(\n                select(Conversation).offset(skip).limit(take)\n            )\n        return [r for r in result.scalars().all()]\n\n    async def get(self, conversation_id: int) -> Conversation | None:\n        async with self.session.begin():\n            result = await self.session.execute(\n                select(Conversation).where(Conversation.id == conversation_id)\n            )\n        return result.scalars().first()\n\n    async def create(self, conversation: ConversationCreate) -> Conversation:\n        new_conversation = Conversation(**conversation.model_dump())\n        async with self.session.begin():\n            self.session.add(new_conversation)\n            await self.session.commit()\n            await self.session.refresh(new_conversation)\n        return new_conversation\n\n    async def update(\n        self, conversation_id: int, updated_conversation: ConversationUpdate\n    ) -> Conversation | None:\n        conversation = await self.get(conversation_id)\n        if not conversation:\n            return None\n        for key, value in updated_conversation.model_dump().items():\n            setattr(conversation, key, value)\n        async with self.session.begin():\n            await self.session.commit()\n            await self.session.refresh(conversation)\n        return conversation\n\n    async def delete(self, conversation_id: int) -> None:\n        conversation = await self.get(conversation_id)\n        if not conversation:\n            return\n        async with self.session.begin():\n            await self.session.delete(conversation)\n            await self.session.commit()\n```", "```py\n# routers/conversations.py\n\nfrom typing import Annotated\nfrom fastapi import APIRouter, Depends, FastAPI, HTTPException, status\n...  # Other imports\nfrom repositories import ConversationRepository\n\n...  # Other controllers and dependency implementations\n\nrouter = APIRouter(prefix=\"/conversations\") ![1](assets/1.png)\n\nasync def get_conversation(\n    conversation_id: int, session: SessionDep\n) -> Conversation:\n    conversation = await ConversationRepository(session).get(conversation_id) ![2](assets/2.png)\n    if not conversation:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Conversation not found\",\n        )\n    return conversation\n\nGetConversationDep = Annotated[Conversation, Depends(get_conversation)]\n\n@router.get(\"\")\nasync def list_conversations_controller(\n    session: SessionDep, skip: int = 0, take: int = 100\n) -> list[ConversationOut]:\n    conversations = await ConversationRepository(session).list(skip, take)\n    return [ConversationOut.model_validate(c) for c in conversations]\n\n@router.get(\"/{id}\")\nasync def get_conversation_controller(\n    conversation: GetConversationDep,\n) -> ConversationOut:\n    return ConversationOut.model_validate(conversation) ![2](assets/2.png)\n\n@router.post(\"\", status_code=status.HTTP_201_CREATED)\nasync def create_conversation_controller(\n    conversation: ConversationCreate, session: SessionDep\n) -> ConversationOut:\n    new_conversation = await ConversationRepository(session).create(\n        conversation\n    ) ![2](assets/2.png)\n    return ConversationOut.model_validate(new_conversation)\n\n@router.put(\"/{id}\", status_code=status.HTTP_202_ACCEPTED)\nasync def update_conversation_controller(\n    conversation: GetConversationDep,\n    updated_conversation: ConversationUpdate,\n    session: SessionDep,\n) -> ConversationOut:\n    updated_conversation = await ConversationRepository(session).update( ![2](assets/2.png)\n        conversation.id, updated_conversation\n    )\n    return ConversationOut.model_validate(updated_conversation)\n\n@router.delete(\"/{id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_conversation_controller(\n    conversation: GetConversationDep, session: SessionDep\n) -> None:\n    await ConversationRepository(session).delete(conversation.id)\n\n# main.py\n\nfrom routers.conversations import router as conversations_router\n\napp.include_router(conversations_router) ![1](assets/1.png)\n```", "```py\n# services/conversations.py\n\nfrom entities import Message\nfrom repositories.conversations import ConversationRepository\nfrom sqlalchemy import select\n\nclass ConversationService(ConversationRepository):\n    async def list_messages(self, conversation_id: int) -> list[Message]:\n        result = await self.session.execute(\n            select(Message).where(Message.conversation_id == conversation_id)\n        )\n        return [m for m in result.scalars().all()]\n\n# routers/conversations.py\n\nfrom database import DBSessionDep\nfrom entities import Message\nfrom fastapi import APIRouter\nfrom schemas import MessageOut\nfrom services.conversations import ConversationService\n\nrouter = APIRouter(prefix=\"/conversations\")\n\n@router.get(\"/{conversation_id}/messages\") ![1](assets/1.png)\nasync def list_conversation_messages_controller(\n    conversation: GetConversationDep,\n    session: DBSessionDep,\n) -> list[Message]:\n    messages = await ConversationService(session).list_messages(conversation.id)\n    return [MessageOut.model_validate(m) for m in messages]\n```", "```py\n$ alembic init\n```", "```py\nproject/\n    alembic.ini\n    alembic/\n        env.py ![1](assets/1.png) README\n        script.py.mako\n        versions/ ![2](assets/2.png) <migration .py files will appear here>\n```", "```py\n# alembic/env.py\n\nfrom entities import Base\nfrom settings import AppSettings\n\nsettings = AppSettings()\ntarget_metadata = Base\ndb_url = str(settings.pg_dsn)\n\n...\n```", "```py\n$ alembic revision --autogenerate -m \"Initial Migration\"\n```", "```py\n# alembic/versions/24c35f32b152.py\n\nfrom datetime import UTC, datetime\nimport sqlalchemy as sa\nfrom alembic import op\n\n\"\"\"\nRevision ID: 2413cf32b712 Revises:\nCreate Date: 2024-07-11 12:30:17.089406\n\"\"\"\n\n# revision identifiers, used by Alembic.\nrevision = \"24c35f32b152\"\ndown_revision = None\nbranch_labels = None\n\ndef upgrade():\n    op.create_table(\n        \"conversations\",\n        sa.Column(\"id\", sa.BigInteger, primary_key=True),\n        sa.Column(\"title\", sa.String, nullable=False),\n        sa.Column(\"model_type\", sa.String, index=True, nullable=False),\n        sa.Column(\n            \"created_at\", sa.DateTime, default=datetime.now(UTC), nullable=False\n        ),\n        sa.Column(\n            \"updated_at\",\n            sa.DateTime,\n            default=datetime.now(UTC),\n            onupdate=datetime.now(UTC),\n            nullable=False,\n        ),\n    )\n\n    op.create_table(\n        \"messages\",\n        sa.Column(\"id\", sa.BigInteger, primary_key=True),\n        sa.Column(\n            \"conversation_id\",\n            sa.BigInteger,\n            sa.ForeignKey(\"conversations.id\", ondelete=\"CASCADE\"),\n            index=True,\n            nullable=False,\n        ),\n        sa.Column(\"prompt_content\", sa.Text, nullable=False),\n        sa.Column(\"response_content\", sa.Text, nullable=False),\n        sa.Column(\"prompt_tokens\", sa.Integer, nullable=True),\n        sa.Column(\"response_tokens\", sa.Integer, nullable=True),\n        sa.Column(\"total_tokens\", sa.Integer, nullable=True),\n        sa.Column(\"is_success\", sa.Boolean, nullable=True),\n        sa.Column(\"status_code\", sa.Integer, nullable=True),\n        sa.Column(\n            \"created_at\", sa.DateTime, default=datetime.now(UTC), nullable=False\n        ),\n        sa.Column(\n            \"updated_at\",\n            sa.DateTime,\n            default=datetime.now(UTC),\n            onupdate=datetime.now(UTC),\n            nullable=False,\n        ),\n    )\n\ndef downgrade():\n    op.drop_table(\"messages\")\n    op.drop_table(\"conversations\")\n```", "```py\n$ alembic upgrade head\n```", "```py\n# main.py\n\nfrom itertools import tee\nfrom database import DBSessionDep\nfrom entities import Message\nfrom fastapi import BackgroundTasks, Depends\nfrom fastapi.responses import StreamingResponse\nfrom repositories.conversations import Conversation\nfrom repositories.messages import MessageRepository\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nasync def store_message( ![1](assets/1.png)\n    prompt_content: str,\n    response_content: str,\n    conversation_id: int,\n    session: AsyncSession,\n) -> None:\n    message = Message(\n        conversation_id=conversation_id,\n        prompt_content=prompt_content,\n        response_content=response_content,\n    )\n    await MessageRepository(session).create(message)\n\n@app.get(\"/text/generate/stream\")\nasync def stream_llm_controller(\n    prompt: str,\n    background_task: BackgroundTasks,\n    session: DBSessionDep,\n    conversation: Conversation = Depends(get_conversation), ![2](assets/2.png)\n) -> StreamingResponse:\n    # Invoke LLM and obtain the response stream\n    ...\n    stream_1, stream_2 = tee(response_stream) ![3](assets/3.png)\n    background_task.add_task(\n        store_message, prompt, \"\".join(stream_1), conversation.id, session\n    ) ![4](assets/4.png)\n    return StreamingResponse(stream_2)\n```", "```py\nfrom entities import Conversation\nfrom openai import AsyncClient\nfrom repositories.conversations import ConversationRepository\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nasync_client = AsyncClient(...)\n\nasync def create_conversation(\n    initial_prompt: str, session: AsyncSession\n) -> Conversation:\n    completion = await async_client.chat.completions.create(\n        messages=[\n            {\n                \"role\": \"system\",\n                \"content\": \"Suggest a title for the conversation \"\n                           \"based on the user prompt\",\n            },\n            {\n                \"role\": \"user\",\n                \"content\": initial_prompt,\n            },\n        ],\n        model=\"gpt-3.5-turbo\",\n    )\n    title = completion.choices[0].message.content\n    conversation = Conversation(\n        title=title,\n        # add other conversation properties\n        ...\n    )\n    return await ConversationRepository(session).create(conversation)\n```"]