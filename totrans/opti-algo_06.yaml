- en: 5 Simulated annealing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 模拟退火
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing trajectory-based optimization algorithms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍轨迹型优化算法
- en: Understanding the simulated annealing algorithm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模拟退火算法
- en: Solving function optimization as an example of continuous optimization problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数优化为例，解决连续优化问题
- en: Solving puzzle game problems like Sudoku as an example of constraint-satisfaction
    problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以数独游戏问题为例，解决约束满足问题
- en: Solving permutation problems like TSP as an example of discrete problems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以TSP（旅行商问题）为例，解决离散问题
- en: Solving a real-world delivery semi-truck routing problem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决现实世界的半挂车配送路线问题
- en: In this chapter, we’ll look at simulated annealing as a trajectory-based metaheuristic
    optimization technique. We’ll discuss different elements of this algorithm and
    its adaptation aspects. A number of case studies will be presented to show the
    ability of this metaheuristic algorithm to solve continuous and discrete optimization
    problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨模拟退火作为一种轨迹型元启发式优化技术。我们将讨论该算法的不同元素及其适应性方面。将展示一些案例研究，以展示这种元启发式算法解决连续和离散优化问题的能力。
- en: 5.1 Introducing trajectory-based optimization
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 轨迹型优化介绍
- en: Imagine yourself on a hiking trip looking for the lowest valley in a rugged
    landscape that has many valleys and hills. You don’t have access to global information
    or a map that shows the location of the lowest valley. You start your hiking journey
    by randomly choosing a direction. You keep moving step by step until you get stuck
    in a local valley surrounded by hills. You are not highly satisfied with the location,
    as you believe that there is a lower valley in the area that may be behind the
    hills. Your curiosity drives you to move up one of the hills to find the lowest
    valley.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你自己在一次徒步旅行中寻找一个崎岖地形中众多山谷和山丘中的最低谷。你没有全局信息或显示最低谷位置的地图。你通过随机选择一个方向开始徒步旅行。你一步步地移动，直到你被困在一个被山丘包围的局部山谷中。你对这个位置并不十分满意，因为你相信在这个区域可能还有更低的山谷，可能就在山丘后面。你的好奇心驱使你爬上一座山丘，以寻找最低谷。
- en: This is exactly what simulated annealing (SA) does. The basic idea of the SA
    algorithm is to use a stochastic search that follows a trial-and-error approach,
    accepting changes that improve the objective function and also keeping some changes
    that are not ideal. In a minimization problem, for example, any better moves or
    changes that decrease the value of the objective function will be accepted. However,
    some moves that increase the objective function will also be accepted with a certain
    probability. SA is a trajectory-based metaheuristic algorithm that can be used
    to find the global optimum solution for complex optimization problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是模拟退火（SA）所做的事情。模拟退火算法的基本思想是使用一种随机搜索，遵循试错方法，接受能改进目标函数的变化，同时也保留一些不理想的变化。例如，在最小化问题中，任何能降低目标函数值的移动或变化都将被接受。然而，某些增加目标函数值的移动也会以一定的概率被接受。SA是一种轨迹型元启发式算法，可用于寻找复杂优化问题的全局最优解。
- en: Generally speaking, *metaheuristic algorithms* can be classified into *trajectory-based*
    and *population-based* algorithms, as shown in figure 5.1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，*元启发式算法*可以分为*轨迹型*和*种群型*算法，如图5.1所示。
- en: '![](../Images/CH05_F01_Khamis.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Khamis.png)'
- en: Figure 5.1 Exploration and exploitation of optimization algorithms
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 优化算法的探索与开发
- en: '*Trajectory-based metaheuristic algorithms* or *S-metaheuristics*, such as
    SA or tabu search, use a single search agent that moves through the search space
    in a piecewise style. A better move or solution is always accepted, while a not-so-good
    move can be accepted with a certain probability. The steps, or moves, trace a
    trajectory in the search space, with a nonzero probability that this trajectory
    can reach the global optimum.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*轨迹型元启发式算法*或*S元启发式算法*，如SA或禁忌搜索，使用单个搜索代理以分段方式在搜索空间中移动。更好的移动或解决方案总是被接受，而不太好的移动可以以一定的概率被接受。步骤或移动在搜索空间中绘制出轨迹，该轨迹有非零概率达到全局最优。'
- en: In contrast, *population-based algorithms* or *P-metaheuristics*, such as genetic
    algorithms, particle swarm optimization, and ant colony optimization, use multiple
    agents to search for an optimal or near-optimal global solution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，*种群型算法*或*P元启发式算法*，如遗传算法、粒子群优化和蚁群优化，使用多个代理来搜索最优或近似最优的全局解。
- en: Due to the large diversity of initial populations, population-based algorithms
    are naturally more exploration-based, whereas single or trajectory-based algorithms
    are more exploitation-based. The following section explains the SA algorithm in
    more detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于初始种群具有很大的多样性，基于种群的算法自然更偏向于探索，而基于单个或轨迹的算法则更偏向于利用。下一节将更详细地解释SA算法。
- en: 5.2 The simulated annealing algorithm
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 模拟退火算法
- en: Whether you need to solve a complex nonlinear nondifferential function optimization
    problem, a puzzle game like Sudoku, an academic course scheduling problem, a travelling
    salesman problem (TSP), a network design problem, a task allocation problem, a
    circuit partitioning and placement problem, a production planning and scheduling
    problem, or even a tennis tournament planning problem, SA can be used as a generic
    solver for these different continuous and discrete optimization problems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你需要解决的是复杂的非线性非微分函数优化问题，还是像数独这样的谜题游戏，学术课程排课问题，旅行商问题（TSP），网络设计问题，任务分配问题，电路划分和放置问题，生产计划和调度问题，甚至是网球锦标赛规划问题，SA都可以作为这些不同连续和离散优化问题的通用求解器。
- en: Let’s first look at the details of this solver before we use it to solve different
    problems. We’ll start by shedding some light on the physical annealing process,
    which was the inspiration for SA.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用它来解决不同问题之前，让我们先看看这个求解器的细节。我们将首先了解一下物理退火过程，这是SA的灵感来源。
- en: 5.2.1 Physical annealing
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 物理退火
- en: Annealing, as a heat treatment process, has been used for centuries across various
    industries, including metallurgy, glassmaking, and ceramics. For example, in the
    context of making glass bottles, annealing removes the stresses and strains in
    the glass resulting from shaping. This is an important step, and if it’s not done,
    the glass may shatter due to the buildup of tension caused by uneven cooling.
    After the bottles have cooled to room temperature, they are inspected and finally
    packaged.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 退火作为一种热处理过程，在包括冶金、玻璃制造和陶瓷在内的各个行业中已经使用了几个世纪。例如，在制造玻璃瓶的背景下，退火消除了由于成型而产生的玻璃中的应力和应变。这是一个重要的步骤，如果不这样做，玻璃可能会因为冷却不均匀而产生的张力积累而破碎。在瓶子冷却到室温后，它们会被检查并最终包装。
- en: Annealing alters a material, causing changes in its properties, such as strength
    and hardness. This process heats the material to above the recrystallization temperature,
    maintains a suitable temperature, and then cools the material. As the temperature
    reduces, the mobility of molecules reduces, with the tendency that molecules will
    align themselves in a crystalline structure (figure 5.2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 退火会改变材料的性质，如强度和硬度。这个过程将材料加热到高于再结晶温度，保持适当的温度，然后冷却材料。随着温度的降低，分子的流动性降低，分子倾向于以晶体结构（图5.2）排列自己。
- en: '![](../Images/CH05_F02_Khamis.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F02_Khamis.png)'
- en: Figure 5.2 The effect of temperature on the mobility of the molecules
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 温度对分子流动性的影响
- en: The aligned structure is the minimum energy state for the system. To ensure
    that this alignment is obtained, cooling must occur at a sufficiently slow rate.
    If the substance is cooled too rapidly, a noncrystalline state with irregular
    three-dimensional patterns may be reached, as illustrated in figure 5.3\. Quartz,
    sodium chloride, diamond, and sugar are examples of crystalline solids that have
    a regular order for the arrangement of constituent particles, atoms, ions, or
    molecules. Glass, rubber, pitch, and many plastics are examples of noncrystalline
    amorphous solids. As you may know, quartz crystals are harder than glass thanks
    to their symmetrical molecular structure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐结构是系统的最低能量状态。为了确保这种对齐能够实现，冷却必须以足够慢的速度进行。如果物质冷却得太快，可能会达到具有不规则三维图案的非晶态，如图5.3所示。石英、氯化钠、钻石和糖是具有规则排列的构成粒子、原子、离子或分子的晶体固体例子。玻璃、橡胶、沥青和许多塑料是非晶体非晶态固体的例子。正如你可能知道的，由于它们的对称分子结构，石英晶体比玻璃硬。
- en: '![](../Images/CH05_F03_Khamis.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F03_Khamis.png)'
- en: 'Figure 5.3 Physical annealing. Left: a metal with a crystalline structure.
    Right: an amorphous metal with a disordered atomic-scale structure.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 物理退火。左：具有晶体结构的金属。右：具有无序原子尺度结构的非晶态金属。
- en: Note The annealing process involves the careful control of the temperature and
    cooling rate, often called the annealing or cooling schedule. The annealing time
    should be long enough for the material to undergo the required transformation.
    If the difference in the temperature rate of change between the outside and inside
    of a material is too big, this may cause defects and cracks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：退火过程涉及对温度和冷却速率的仔细控制，通常称为退火或冷却计划。退火时间应足够长，以便材料完成所需的转变。如果材料内外温度变化率差异太大，这可能会导致缺陷和裂纹。
- en: The fact that the aligned structure represents the minimum energy state for
    the system inspired scientists to think about mimicking this process to solve
    optimization problems. *Simulated* annealing is a computational model that mimics
    the physical annealing process. In the context of mathematical optimization, the
    minimum of an objective function represents the minimum energy of the system.
    SA is an algorithmic implementation of the cooling process, used to find the optimum
    of an objective function. Table 5.1 outlines the analogy between SA and the physical
    annealing process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐结构代表系统最低能量状态的事实启发了科学家们思考如何模仿这个过程来解决优化问题。*模拟*退火是一种模仿物理退火过程的计算模型。在数学优化的背景下，目标函数的最小值代表系统的最低能量。模拟退火是冷却过程的算法实现，用于寻找目标函数的最优值。表5.1概述了模拟退火与物理退火过程之间的类比。
- en: Table 5.1 The physical annealing and simulated annealing analogy
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 物理退火和模拟退火类比
- en: '| Physical annealing | Simulated annealing |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 物理退火 | 模拟退火 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| State of a material | Solution of an optimization problem |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 材料状态 | 优化问题的解 |'
- en: '| The energy of a state | The cost of a solution |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 状态的能量 | 解的成本 |'
- en: '| Temperature | Control parameter (temperature) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 温度 | 控制参数（温度） |'
- en: '| High temperature makes molecules move freely | High temperature favors search
    space exploration |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 高温使分子自由移动 | 高温有利于搜索空间探索 |'
- en: '| Low temperature restricts molecules’ motion | Low temperature leads to exploiting
    the search space |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 低温限制分子的运动 | 低温导致利用搜索空间 |'
- en: '| Gradual cooling helps to reduce stress and increase homogeneity and structural
    stability. | Gradual cooling helps to avoid getting stuck in suboptimal local
    minima and to find the globally optimal or near-optimal solution. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 逐渐冷却有助于减少应力并增加均匀性和结构稳定性。 | 逐渐冷却有助于避免陷入次优局部最小值，并找到全局最优或近似最优解。 |'
- en: In 1953, the first computational model that replicated the physical process
    of annealing was introduced. This model was presented as a universal method for
    computing the properties of substances that can be considered collections of individual
    molecules interacting with each other. S. Kirkpatrick et al. were trailblazers
    in utilizing SA for optimization, as described in their paper "Optimization by
    Simulated Annealing" [1]. The following subsection explains the steps involved
    in the SA algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1953年，第一个复制物理退火过程的计算模型被引入。该模型被提出作为一种计算物质性质的通用方法，这些物质可以被认为是相互作用的单个分子的集合。S. Kirkpatrick等人是利用模拟退火进行优化的先驱，如他们在论文《模拟退火优化》[1]中所描述。以下小节解释了模拟退火算法中涉及到的步骤。
- en: 5.2.2 SA pseudocode
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 模拟退火伪代码
- en: SA employs a Markov chain-based random search approach, which not only accepts
    new solutions that decrease the objective function (assuming a minimization problem)
    but can also accept probabilistic solutions that increase objective function values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟退火采用基于马尔可夫链的随机搜索方法，不仅接受降低目标函数（假设为最小化问题）的新解，还可以接受增加目标函数值的概率解。
- en: Markov chain
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链
- en: The Markov property, named after Russian mathematician Andrey Markov (1856–1922),
    is a memoryless random process. This means that the next state depends only on
    the current state and not on the sequence of events that preceded it. A Markov
    chain (MC) is a stochastic or probabilistic model that describes a sequence of
    possible moves in which the probability of each move depends only on the state
    attained in the previous move. This means that the transition from one state to
    another depends only on the current fully observable state and a transition probability.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫性质，以俄罗斯数学家安德烈·马尔可夫（1856-1922）的名字命名，是一个无记忆的随机过程。这意味着下一个状态只取决于当前状态，而不取决于之前的事件序列。马尔可夫链（MC）是一个随机或概率模型，描述了一系列可能的移动，其中每个移动的概率只取决于前一个移动达到的状态。这意味着从一个状态到另一个状态的转移只取决于当前完全可观察的状态和转移概率。
- en: Following this memoryless random process, the transition between the current
    known state A, for example, to a next neighboring state B is governed by a transition
    probability as illustrated in the following figure. Markov chains are used in
    different domains such as stochastic optimization, economy, speech recognition,
    weather prediction, and control systems. It's also worth mentioning that Google’s
    PageRank algorithm uses a Markov chain to model the behavior of users navigating
    the web. SymPy provides a Python implementation for a finite discrete time-homogeneous
    Markov chain through the class `sympy.stats.DiscreteMarkovChain`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这个无记忆的随机过程，当前已知状态A到下一个邻近状态B之间的转移由以下图示的转移概率控制。马尔可夫链在不同的领域中被使用，如随机优化、经济、语音识别、天气预报和控制系统。值得一提的是，Google的PageRank算法使用马尔可夫链来模拟用户在网上的行为。SymPy通过`sympy.stats.DiscreteMarkovChain`类提供了一个有限离散时间同质马尔可夫链的Python实现。
- en: '![](../Images/CH05_F03_UN01_Khamis.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F03_UN01_Khamis.png)'
- en: Markov chain—*p[AB]*, *p[BA]*, *p[BC]*, and *p[CB]* are transition probabilities
    between the states A, B, and C.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链—*p[AB]*、*p[BA]*、*p[BC]*和*p[CB]*是状态A、B和C之间的转移概率。
- en: As illustrated in figure 5.4, a new neighboring solution or state *x[k]* is
    always accepted if it’s an improving solution (i.e., *f*(*x[k]*) < *f*(*x[i]*)).
    An improving solution is a solution that gives a lower value for the objective
    function if we’re dealing with a minimization problem or gives a higher value
    in the case of a maximization problem. In the case of non-improving solutions,
    such as *x[j]*, the solution can still be probabilistically accepted as a way
    to avoid the risk of getting trapped in a local minimum. This contrasts with a
    greedy algorithm’s tendency to accept only improving solutions, making greedy
    algorithms more susceptible to getting stuck in local minima.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如图5.4所示，如果一个新的邻近解或状态 *x[k]* 是一个改进的解（即 *f*(*x[k]*) < *f*(*x[i]*)），那么它总是被接受。改进的解是指在最小化问题中给出目标函数更低值的解，或者在最大化问题中给出更高值的解。对于非改进解，例如
    *x[j]*，解决方案仍然可以以概率接受，作为避免陷入局部最优的风险的一种方式。这与贪婪算法倾向于只接受改进解的趋势形成对比，使得贪婪算法更容易陷入局部最优。
- en: '![](../Images/CH05_F04_Khamis.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F04_Khamis.png)'
- en: Figure 5.4 Transition probability, assuming a minimization problem. As solution
    *x[k]* is an improving move, it is always accepted, and as solution *x[j]* is
    non-improving, it may be probabilistically accepted based on the transition probability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 转移概率，假设是一个最小化问题。由于解 *x[k]* 是一个改进的移动，它总是被接受，而由于解 *x[j]* 是非改进的，它可能基于转移概率以概率接受。
- en: Temperature *T* appears in the transition probability and controls the exploration
    and exploitation in the search space. At high temperatures, non-improving moves
    will have a good chance of being accepted, but as the temperature decreases, the
    probability of accepting worse moves decreases. We’ll discuss this in more detail
    in the following subsections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 温度 *T* 出现在转移概率中，并控制搜索空间中的探索和利用。在高温下，非改进的移动有很好的机会被接受，但随着温度的降低，接受更差移动的概率会降低。我们将在以下小节中更详细地讨论这一点。
- en: The steps in SA can be summarized in the following pseudocode.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟退火算法的步骤可以总结如下伪代码。
- en: Algorithm 5.1 The SA algorithm
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 算法5.1 模拟退火算法
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: SA has the advantages of ease of use and the ability to provide optimal or near-optimal
    solutions for a wide range of continuous and discrete problems. The main drawbacks
    of this algorithm are the need to tune many parameters and the occasional slow
    convergence of the algorithm to the optimal or near-optimal solutions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SA算法具有易用性和为广泛连续和离散问题提供最优或近似最优解的能力。该算法的主要缺点是需要调整许多参数，以及算法偶尔会缓慢收敛到最优或近似最优解。
- en: Aside from this original SA algorithm—classical simulated annealing (CSA)—various
    variants have been proposed to improve the algorithm's performance. For example,
    fast simulated annealing (FSA) is a semi-local search and consists of occasional
    long jumps. Dual annealing is a stochastic global optimization algorithm that
    is useful for dealing with complex nonlinear optimization problems. It is based
    on the combined classical simulated annealing and fast simulated annealing algorithms.
    The generalized simulated annealing (GSA) algorithm uses a distorted Cauchy-Lorentz
    visiting distribution [2].
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个原始的SA算法——经典模拟退火（CSA）之外，还提出了各种变体来提高算法的性能。例如，快速模拟退火（FSA）是一种半局部搜索，由偶尔的长跳跃组成。双重退火是一种用于处理复杂非线性优化问题的随机全局优化算法。它基于经典模拟退火和快速模拟退火算法的组合。广义模拟退火（GSA）算法使用扭曲的柯西-洛伦兹访问分布[2]。
- en: Quantum annealing (QA)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 量子退火（QA）
- en: In quantum mechanics, a quantum particle is treated as an electromagnetic wave
    that can penetrate with a certain probability through a potential barrier. Due
    to the wave nature of matter on the quantum level, there is indeed some probability
    that a quantum particle can traverse such a barrier if the barrier is thin enough.
    This phenomenon is known as quantum tunneling. The quantum tunneling effect is
    a phenomenon whereby wave functions or particles can penetrate through a supposedly
    impassable barrier even if the total energy of the particle is less than the barrier
    height.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子力学中，量子粒子被视为一种可以以一定概率穿透势垒的电磁波。由于量子层面上物质的波动性质，如果势垒足够薄，量子粒子确实有可能穿越这样的势垒。这种现象称为量子隧穿。量子隧穿效应是一种现象，其中波函数或粒子可以穿透一个看似不可逾越的势垒，即使粒子的总能量小于势垒高度。
- en: As illustrated in the following figure, SA uses a thermal jump to push the search
    particle out of the local valley to avoid getting trapped in local minima. QA,
    on the other hand, searches an energy landscape to find an optimal or near-optimal
    solution by applying quantum effects. Instead of just walking through the landscape
    of the function, quantum annealing can tunnel through. This allows the algorithm
    to escape from local minima using quantum tunneling (tunnel effect) instead of
    the thermal jumps used in SA.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，SA使用热跃迁将搜索粒子推出局部山谷，以避免陷入局部最小值。另一方面，QA通过应用量子效应在能量景观中搜索，以找到最优或近似最优解。量子退火不仅可以通过函数的景观漫步，还可以通过隧道。这允许算法通过量子隧道（隧道效应）而不是SA中使用的热跃迁来逃离局部最小值。
- en: '![](../Images/CH05_F04_UN02_Khamis.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH05_F04_UN02_Khamis.png)'
- en: Simulated annealing versus quantum annealing
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟退火与量子退火
- en: 'In QA, a number of candidate states are initialized with equal weights. Quantum-mechanical
    probability is used to change adiabatically and gradually the amplitudes of all
    states in parallel. For more information and an example of quantum annealers,
    see the D-Wave implementation: [https://docs.dwavesys.com/docs/latest/c_gs_2.html](https://docs.dwavesys.com/docs/latest/c_gs_2.html).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在QA中，多个候选状态以相等的权重初始化。使用量子力学概率来平行地逐渐改变所有状态振幅。有关更多信息及量子退火器的示例，请参阅D-Wave实现：[https://docs.dwavesys.com/docs/latest/c_gs_2.html](https://docs.dwavesys.com/docs/latest/c_gs_2.html)。
- en: The following subsections explain the different components of the SA algorithm,
    starting with the transition probability that allows SA to accept or reject non-improving
    moves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子节将解释SA算法的不同组件，从允许SA接受或拒绝非改进移动的转换概率开始。
- en: 5.2.3 Acceptance probability
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 接受概率
- en: Unlike hill climbing (see section 4.3.1), SA probabilistically allows downward
    steps, controlled by the current temperature and how bad the move is. In SA, better
    moves are always accepted. As shown in figure 5.4, non-improving moves can be
    probabilistically accepted based on the Boltzmann-Gibbs distribution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与爬山法（参见第 4.3.1 节）不同，SA 以概率允许向下步骤，由当前温度和移动的糟糕程度控制。在 SA 中，总是接受更好的移动。如图 5.4 所示，非改进的移动可以根据玻尔兹曼-吉布斯分布以概率接受。
- en: 'In thermodynamics, a state at a temperature *t* has a probability of an increase
    in the energy magnitude Δ*E* given by the Boltzmann-Gibbs distribution as in equation
    5.1:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在热力学中，温度为 *t* 的状态具有能量幅度增加 Δ*E* 的概率，该概率由玻尔兹曼-吉布斯分布给出，如方程 5.1 所示：
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F04_UN02_Khamis-EQ01.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F04_UN02_Khamis-EQ01.png)'
- en: '| 5.1 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 5.1 |'
- en: where *k* is the Boltzmann constant, which is the proportionality factor that
    relates the average relative kinetic energy of particles in a gas with the thermodynamic
    temperature of the gas, and which has the value of 1.380,649 × 10^(-23) m² kg
    s^(-2) K^(-1). However, there’s no need to use this constant in a computational
    model that mimics the physical annealing process, so it’s replaced by 1.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *k* 是玻尔兹曼常数，它是将气体中粒子的平均相对动能与气体的热力学温度相关联的比例系数，其值为 1.380,649 × 10^(-23) m²
    kg s^(-2) K^(-1)。然而，在模拟物理退火过程的计算模型中，无需使用此常数，因此它被替换为 1。
- en: 'Moreover, the change in the energy can be replaced by the change in the objective
    function as a way to quantify the search progress toward the optimal or near-optimal
    state. So Δ*E* can be linked with the change of the objective function using equation
    5.2:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，能量的变化可以用目标函数的变化来代替，作为量化搜索过程向最优或近似最优状态进展的方法。因此，Δ*E* 可以通过方程 5.2 与目标函数的变化联系起来：
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F04_UN02_Khamis-EQ02.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F04_UN02_Khamis-EQ02.png)'
- en: '| 5.2 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 5.2 |'
- en: where *γ* is a real constant. For simplicity, and without altering the core
    meaning, we can use *k* = 1 and *γ* = 1. Thus, the transition probability *p*
    simply becomes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *γ* 是一个实数常数。为了简化，并且不改变核心意义，我们可以使用 *k* = 1 和 *γ* = 1。因此，转换概率 *p* 简单地变为
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F04_UN02_Khamis-EQ03.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F04_UN02_Khamis-EQ03.png)'
- en: '| 5.3 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 5.3 |'
- en: where *T* is the temperature of the system. To determine whether or not we accept
    a change, we usually use a random number *r* in the interval [0,1] as a threshold.
    Thus, if *p* > *r*, or *p* = *e*^((–Δ)*^f* ^/*^T*^) > *r*, the move is accepted.
    Otherwise, the move is rejected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *T* 是系统的温度。为了确定是否接受变化，我们通常使用区间 [0,1] 内的随机数 *r* 作为阈值。因此，如果 *p* > *r*，或者 *p*
    = *e*^((–Δ)*^f* ^/*^T*^) > *r*，则移动被接受。否则，移动被拒绝。
- en: If *P[ij]* is the probability of moving from point *x[i]* to *x[j]*, then *P[ij]*
    is calculated using
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *P[ij]* 是从点 *x[i]* 移动到 *x[j]* 的概率，那么 *P[ij]* 是通过以下方式计算的
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F04_UN02_Khamis-EQ04a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F04_UN02_Khamis-EQ04a.png)'
- en: '| 5.4 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 5.4 |'
- en: The probability *P[ij]* is called transition or acceptance probability. Accepting
    non-improving moves probabilistically makes the algorithm able to avoid getting
    trapped in some local minima. If the acceptance probability is set to 0, SA behaves
    similarly to hill climbing, as it will only accept solutions that are better than
    the current one. Conversely, if the acceptance probability is set to 1, SA becomes
    more exploratory, as it will always accept worse solutions, making it more akin
    to a random search.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*P[ij]* 概率被称为转换或接受概率。以概率接受非改进的移动使得算法能够避免陷入某些局部最小值。如果接受概率设置为 0，模拟退火 (SA) 的行为类似于爬山法，因为它只会接受比当前解更好的解。相反，如果接受概率设置为
    1，SA 变得更具探索性，因为它将始终接受更差的解，这使得它更类似于随机搜索。'
- en: The probability of accepting a worse state is a function of both the temperature
    of the system and the change in the cost function. As the temperature decreases,
    the probability of accepting worse moves decreases. Temperature can be seen as
    a parameter to balance the exploration and the exploitation in the search space.
    At high temperatures, the acceptance probability is high, which means that the
    algorithm accepts most of the moves to explore the parameter space. On the other
    hand, when the temperature is low, the acceptance probability is low, meaning
    that the algorithm restricts exploration. As shown in figure 5.5, if *T* = 0,
    no non-improving moves are accepted. In this case, SA is converted into hill climbing.
    As can be seen, the cooling process has an important effect on the search progress.
    The next section will present the different components of the cooling schedules
    used in SA.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接受较差状态的概率是系统温度和成本函数变化的一个函数。随着温度降低，接受较差移动的概率降低。温度可以看作是平衡搜索空间中探索和利用的一个参数。在高温下，接受概率高，这意味着算法接受大多数移动来探索参数空间。另一方面，当温度低时，接受概率低，意味着算法限制探索。如图5.5所示，如果*T*
    = 0，则不接受任何非改进移动。在这种情况下，SA转化为爬山法。可以看出，冷却过程对搜索进度有重要影响。下一节将介绍SA中使用的不同冷却调度组件。
- en: '![](../Images/CH05_F05_Khamis.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F05_Khamis.png)'
- en: Figure 5.5 Change of acceptance probability with the temperature and the change
    in the objective function. The objective function change is the difference in
    the objective function’s value between the current solution and a candidate solution.
    In minimization problems, a positive objective function change indicates that
    the candidate solution is worse than the current solution. The acceptance probability
    gets lower as the objective function change increases. At high temperatures, SA
    tends to explore more by accepting non-improving moves. As the temperature gets
    lower, the algorithm restricts exploration, favoring exploitation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5展示了接受概率随温度和目标函数变化的变化。目标函数的变化是指当前解与候选解之间目标函数值的差异。在最小化问题中，目标函数的正变化表示候选解比当前解更差。随着目标函数变化的增加，接受概率会降低。在高温下，SA倾向于通过接受非改进移动来探索更多。随着温度降低，算法限制探索，偏向于利用。
- en: Given that the Boltzmann-based acceptance probability takes significant computational
    time (~1/3 of the SA computations), lookup tables or non-exponential probability
    formulas can be used instead. A lookup table can be generated by performing the
    exponential calculations offline only once for a range of values for changes in
    *f* and *T*. Other non-exponential probability formulas, such as *p*(Δ*f*) = 1
    – Δ*f*/*T*, can be used as an acceptance probability. This formula should be normalized
    to make sure that the maximum value is 1 and the minimum value is 0\.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于玻尔兹曼的接受概率需要大量的计算时间（约占总SA计算的1/3），可以使用查找表或非指数概率公式来代替。可以通过离线进行指数计算，仅针对*f*和*T*的变化范围生成查找表。其他非指数概率公式，如*p*(Δ*f*)
    = 1 – Δ*f*/*T*，也可以用作接受概率。此公式应归一化，以确保最大值为1，最小值为0。
- en: In a computational model like SA, there is no need to strictly mimic the thermodynamic
    models that govern the physical annealing process. Figure 5.6 shows the difference
    between exponential and non-exponential acceptance probability functions. The
    code is available in the book’s GitHub repo. The difference between exponential
    and non-exponential acceptance probability functions is small for small changes
    in the objective function—you can experiment with this using the provided code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似于模拟退火（SA）的计算模型中，没有必要严格模仿控制物理退火过程的动力学模型。图5.6展示了指数和非指数接受概率函数之间的差异。代码可在本书的GitHub仓库中找到。对于目标函数的小幅变化，指数和非指数接受概率函数之间的差异很小——你可以通过提供的代码进行实验。
- en: '![](../Images/CH05_F06_Khamis.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F06_Khamis.png)'
- en: Figure 5.6 Exponential versus non-exponential acceptance probability
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 指数与非指数接受概率
- en: As temperature is part of the acceptance probability, it plays an important
    role in controlling the behavior of SA. The following subsection looks at how
    we can control the temperature to achieve a trade-off between exploration and
    exploitation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于温度是接受概率的一部分，它在控制SA的行为中起着重要作用。以下小节将探讨我们如何控制温度，以在探索和利用之间达到权衡。
- en: 5.2.4 The annealing process
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 退火过程
- en: 'The annealing process in SA involves the careful control of temperature and
    the cooling rate, often called the *annealing schedule*. This process involves
    defining the following parameters:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟退火中的退火过程涉及对温度和冷却速率的仔细控制，通常称为*退火计划*。这个过程包括定义以下参数：
- en: Starting temperature
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始温度
- en: Temperature decrement following a cooling schedule
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照冷却计划后的温度递减
- en: Number of iterations at each temperature
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个温度下的迭代次数
- en: Final temperature
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终温度
- en: This is shown in figure 5.7.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这在图5.7中显示。
- en: '![](../Images/CH05_F07_Khamis.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Khamis.png)'
- en: Figure 5.7 Annealing process parameters
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7退火过程参数
- en: The following subsections provide in-depth information about each of these parameters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节提供了关于这些参数的深入了解。
- en: Initial temperature
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 初始温度
- en: The choice of the right initial temperature is crucially important. As shown
    in equation 5.4, for a given change Δ*f*
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的初始温度至关重要。如方程5.4所示，对于给定的变化 Δ*f*
- en: If *T* is too high (*T* → ∞), then *p* → 1, which means almost all the changes
    will be accepted and the algorithm will behave like a random search algorithm.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *T* 过高 (*T* → ∞)，则 *p* → 1，这意味着几乎所有的变化都将被接受，算法将表现得像随机搜索算法。
- en: If *T* is too low (*T* → 0), then any Δ*f* > 0 (worse solution assuming a minimization
    problem) will rarely be accepted as *p* → 0, and thus the diversity of the solution
    is limited, but any improvement (i.e., any Δ*f* < 0 in the case of a minimization
    problem) will almost always be accepted. In this case, SA behaves like a local
    search and may easily become trapped in local minima.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *T* 太低 (*T* → 0)，则任何 Δ*f* > 0（在最小化问题中假设为更差的解）很少被接受，因为 *p* → 0，因此解的多样性有限，但任何改进（即，在最小化问题中任何
    Δ*f* < 0）几乎总是被接受。在这种情况下，模拟退火表现得像局部搜索，可能很容易陷入局部最小值。
- en: 'To find a suitable starting temperature, we can use any available information
    about the objective function. If we know the maximum change max(Δ*f*) of the objective
    function, we can use this to estimate an initial temperature *T[o]* for a given
    acceptance probability *p[o]* using equation 5.5:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到一个合适的起始温度，我们可以使用关于目标函数的任何可用信息。如果我们知道目标函数的最大变化 max(Δ*f*)，我们可以使用这个来估计给定接受概率
    *p[o]* 的初始温度 *T[o]*，使用方程5.5：
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F07_Khamis-EQ05.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Khamis-EQ05.png)'
- en: '| 5.5 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 5.5 |'
- en: 'If the potential maximum alteration of the objective function is unknown, we
    can use the following heuristic approach:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标函数的最大潜在变化未知，我们可以使用以下启发式方法：
- en: Initiate evaluations at a very high temperature to allow for nearly all changes
    to be accepted.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以非常高的温度开始评估，以便接受几乎所有变化。
- en: Reduce the temperature quickly until roughly 50% to 60% of the inferior moves
    are accepted.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速降低温度，直到大约50%到60%的较差移动被接受。
- en: Use this temperature as the new initial temperature *T[o]* for proper and relatively
    slow cooling processing.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个温度作为新的初始温度 *T[o]*，进行适当且相对缓慢的冷却处理。
- en: Temperature decrement
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 温度递减
- en: 'The cooling schedule is the rate at which the temperature is systematically
    decreased as the algorithm proceeds. This schedule is among the tunable parameters
    of SA. The following cooling schedules are commonly used:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 冷却计划是随着算法的进行系统性地降低温度的速率。这是模拟退火的可调参数之一。以下是一些常用的冷却计划：
- en: '*Linear cooling schedule*—The temperature is decremented linearly using equation
    5.6:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性冷却计划*—使用方程5.6线性递减温度：'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F07_Khamis-EQ06.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Khamis-EQ06.png)'
- en: '| 5.6 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 5.6 |'
- en: where *T[o]* is the initial temperature, *i* is the pseudo time for iterations,
    and *β* is the cooling rate, which should be chosen in such a way that *T* → 0
    when *i* → *i[f]* (or the maximum number *N* of iterations). This usually gives
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *T[o]* 是初始温度，*i* 是迭代的伪时间，*β* 是冷却速率，应该选择的方式是当 *i* → *i[f]*（或最大迭代次数 *N*）时 *T*
    → 0。这通常给出
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F07_Khamis-EQ07.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Khamis-EQ07.png)'
- en: '| 5.7 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 5.7 |'
- en: This cooling schedule is simple and easy to implement, but may not be the best
    choice for all types of problems. Moreover, it requires prior knowledge or assumptions
    about the maximum number of iterations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种冷却计划简单易行，但可能不是所有类型问题的最佳选择。此外，它需要关于最大迭代次数的先验知识或假设。
- en: '*Linear-inverse cooling schedule*—In linear-inverse cooling, the temperature
    decreases quickly at high temperatures and more gradually at low temperatures,
    as per equation 5.8\. In this equation, *α* is the cooling factor and should be
    between 0 and 1:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性逆冷却计划*—在线性逆冷却中，温度在高温时迅速下降，在低温时逐渐下降，如方程5.8所示。在这个方程中，*α*是冷却因子，应该在0和1之间：'
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F07_Khamis-EQ08.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Khamis-EQ08.png)'
- en: '| 5.8 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 5.8 |'
- en: '*Geometric cooling schedule*—A geometric cooling schedule essentially decreases
    the temperature by a cooling factor 0 < *α* < 1 following equation 5.9:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*几何冷却计划*—几何冷却计划本质上是通过冷却因子0 < *α* < 1根据方程5.9降低温度：'
- en: '|'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F07_Khamis-EQ09.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Khamis-EQ09.png)'
- en: '| 5.9 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 5.9 |'
- en: The cooling process should be slow enough to allow the system to stabilize easily.
    In practice, *α* = 0.7 ~ 0.95 is commonly used. The higher the value of *α*, the
    longer it will take to reach the final (low) temperature. The main advantage of
    the geometric method is that *T* → 0 when *i* → ∞, and thus there is no need to
    specify the maximum number of iterations. Moreover, the geometric annealing schedule
    provides more gradual cooling, as shown in figure 5.8.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 冷却过程应该足够慢，以便系统可以轻松稳定。在实践中，*α* = 0.7 ~ 0.95是常用的。*α*的值越高，达到最终（低）温度所需的时间就越长。几何方法的主要优点是当*i*趋向于无穷大时，*T*趋向于0，因此不需要指定最大迭代次数。此外，几何退火计划提供了更平缓的冷却，如图5.8所示。
- en: '*Logarithmic cooling schedule*—In this cooling schedule, the temperature is
    decreased logarithmically according to equation 5.10:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对数冷却计划*—在这个冷却计划中，温度根据方程5.10以对数方式降低：'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F07_Khamis-EQ10.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Khamis-EQ10.png)'
- en: '| 5.10 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 5.10 |'
- en: where *α* > 1. Theoretically, this cooling process asymptotically converges
    toward the global minimum. However, it requires prohibitive computing time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *α* > 1。从理论上讲，这个冷却过程趋向于全局最小值的渐近收敛。然而，它需要巨大的计算时间。
- en: '*Exponential cooling schedule*—In this cooling schedule, the temperature is
    decreased exponentially according to equation 5.11:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指数冷却计划*—在这个冷却计划中，温度根据方程5.11以指数方式降低：'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F07_Khamis-EQ11.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Khamis-EQ11.png)'
- en: '| 5.11 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 5.11 |'
- en: where *α* is the cooling factor and *n* is the dimensionality of the model space.
    In this cooling process, the temperature is decreased very quickly during the
    first iterations, but the speed of the exponential decay is slowed down later
    and can be controlled using the cooling factor.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *α*是冷却因子，*n*是模型空间的维度。在这个冷却过程中，温度在最初的迭代中迅速下降，但指数衰减的速度后来会减慢，并且可以通过冷却因子来控制。
- en: '![](../Images/CH05_F08_Khamis.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F08_Khamis.png)'
- en: Figure 5.8 Different SA cooling schedules
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8不同的SA冷却计划
- en: As you can see, these cooling schedules are all monotonically decreasing functions
    that don’t explicitly take into consideration how the search is progressing. In
    section 5.2.5, we’ll look at a nonmonotonic adaptive cooling schedule.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些冷却计划都是单调递减的函数，并没有明确考虑搜索的进展情况。在第5.2.5节中，我们将探讨一种非单调自适应冷却计划。
- en: Iterations at each temperature
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个温度下的迭代次数
- en: Before applying the cooling schedule (i.e., decreasing the temperature), it
    is important to allow a sufficient number of iterations at each temperature level
    to stabilize the system at that temperature. Typically, this is achieved by using
    a constant value. For example, the number of iterations at each temperature might
    be exponential to the problem size (e.g., the number of cities in TSP as a discrete
    problem or the dimensionality of a mathematical function in the case of continuous
    problems). However, this value can be altered dynamically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用冷却计划（即，降低温度）之前，允许在每个温度级别进行足够数量的迭代以在该温度下稳定系统是很重要的。通常，这是通过使用一个恒定值来实现的。例如，每个温度下的迭代次数可能与问题规模呈指数关系（例如，TSP问题中城市的数量作为离散问题或连续问题中数学函数的维度）。然而，这个值可以动态地改变。
- en: One way to accomplish this is by limiting the number of iterations during the
    exploration phase of the search at the beginning, when the temperature is high.
    For example, when the temperature is high, we could perform a small number of
    iterations at each temperature and then implement the cooling process. As the
    search continues and the temperature decreases, we can shift toward exploitation
    by conducting a larger number of iterations at lower temperatures.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法是在搜索的探索阶段限制初始高温时的迭代次数。例如，当温度高时，我们可以在每个温度下进行少量迭代，然后实施冷却过程。随着搜索的继续和温度的降低，我们可以在较低温度下进行更多迭代，从而转向利用。
- en: Final temperature
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最终温度
- en: 'It is usual to let the temperature decrease until it reaches zero. However,
    this can make the algorithm run a lot longer, especially when certain cooling
    schedules, such as geometric cooling, are used. In reality, it is not necessary
    to let the temperature reach zero if the chances of accepting a non-improving
    move at the current temperature are almost the same as if the temperature were
    zero. Therefore, the stopping criteria can be either of the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会让温度降低直到为零。然而，这可能会使算法运行时间更长，尤其是在使用某些冷却计划，如几何冷却时。实际上，如果当前温度下接受非改进移动的概率几乎与温度为零时相同，则没有必要让温度达到零。因此，停止标准可以是以下两种之一：
- en: A suitably low temperature (*T[f]* = 10^(–10) ~ 10^(–5))
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个合适的低温（*T[f]* = 10^(–10) ~ 10^(–5)）
- en: When the system reaches a “frozen” or minimum energy state (assuming a minimization
    problem), where neither better nor worse moves are accepted
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统达到“冻结”或最小能量状态（假设是优化问题），既不接受更好的移动也不接受更差的移动时。
- en: 5.2.5 Adaptation in SA
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 SA中的自适应
- en: Several parameters in SA can be used to make the algorithm more adaptive to
    the search’s progress. The initial temperature, the cooling schedule, and the
    number of iterations per temperature are the most critical of these parameters.
    Other components include the cost function, the method of generating neighborhood
    solutions, and the acceptance probability.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SA中的一些参数可以用来使算法更适应搜索的进程。这些参数中最关键的是初始温度、冷却计划和每温度下的迭代次数。其他组件包括成本函数、生成邻域解的方法和接受概率。
- en: As illustrated in figure 5.9, the initial temperature can be used to control
    the exploration and exploitation behavior of SA. A high temperature leads to a
    high level of exploration, and a low temperature results in exploitative behavior
    (i.e., restricting the search around neighbors).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如图5.9所示，初始温度可以用来控制SA的探索和利用行为。高温导致高水平的探索，而低温则导致利用行为（即限制在邻居周围的搜索）。
- en: '![](../Images/CH05_F09_Khamis.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F09_Khamis.png)'
- en: Figure 5.9 Effect of temperature in SA. High temperatures result in more exploration,
    whereas a low temperature restricts the exploration and leads to more exploitation
    in the search space.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 SA中温度的影响。高温导致更多的探索，而低温则限制探索并导致搜索空间中更多的利用。
- en: You can think about it in terms of the movement of molecules. Assume that the
    molecule is the search agent. At high temperatures, the molecule moves freely
    in the search space, exploring different solutions. At low temperatures, the movement
    of the molecule becomes limited, so the exploration is restricted, and the search
    agent focuses on a specific part of the search space. With high temperatures at
    the beginning of the search, SA oscillates due to the exploration behavior that
    makes the algorithm accept non-improving moves with high probability. As the search
    progresses and the temperature gets lower, the algorithm starts to stabilize due
    to the exploitation behavior that makes the algorithm accept fewer non-improving
    moves and instead focus on the elite improving solutions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从分子的运动来思考这个问题。假设分子是搜索代理。在高温下，分子在搜索空间中自由移动，探索不同的解决方案。在低温下，分子的运动变得有限，因此探索受到限制，搜索代理专注于搜索空间的一个特定部分。在搜索开始时的高温下，由于探索行为使算法以高概率接受非改进移动，SA会因振荡而波动。随着搜索的进行和温度的降低，算法开始由于利用行为而稳定下来，这种利用行为使算法接受较少的非改进移动，并专注于精英改进解决方案。
- en: It is always recommended that you start with a high temperature and gradually
    decrease it as the search progresses. However, the right initial temperature is
    problem-dependent. You can try different values and see which leads to better
    solutions. Some researchers suggest doing this adaptively, using other search
    methods or metaheuristics, such as a genetic algorithm.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 始终建议您从高温开始，随着搜索的进行逐渐降低温度。然而，正确的初始温度取决于问题。您可以尝试不同的值，看看哪个能导致更好的解决方案。一些研究人员建议自适应地这样做，使用其他搜索方法或元启发式算法，如遗传算法。
- en: 'Cooling schedules can also be used to make the algorithm more adaptive. Different
    cooling schedules can be used in different phases of the search, taking into consideration
    that most useful work is done in the middle of the schedule. Reheating can also
    be tried if no progress is observed. Cooling may take place every time a move
    (or a specific number of moves) is accepted. A nonmonotonic adaptive cooling schedule
    can be tried, where an adaptive factor is used, based on the difference between
    the current solution objective and the best objective achieved by the algorithm
    up to that moment, according to the following formula:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 冷却计划也可以用来使算法更具适应性。可以在搜索的不同阶段使用不同的冷却计划，考虑到最有用的工作通常在计划的中部完成。如果观察到没有进展，也可以尝试重新加热。冷却可以在每次接受移动（或特定数量的移动）时发生。可以尝试非单调的自适应冷却计划，其中使用一个自适应因子，基于当前解决方案的目标与算法到那时为止实现的最佳目标之间的差异，根据以下公式：
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH05_F09_Khamis-EQ12.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F09_Khamis-EQ12.png)'
- en: '| 5.12 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 5.12 |'
- en: where *T* is the system temperature at each state transition, *T*(*i*) is the
    current temperature, *f[i]* is the value of the objective function at iteration
    *i*, and *f*^* is the best value of the objective function obtained so far.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *T* 是每个状态转换时的系统温度，*T*(*i*) 是当前温度，*f[i]* 是迭代 *i* 时目标函数的值，*f*^* 是迄今为止获得的目标函数的最佳值。
- en: Another adaptation parameter is the number of iterations per temperature. This
    number can be adaptively changed by allowing a small number of iterations at high
    temperatures and allowing a large number of iterations at low temperatures to
    fully explore the local optimum.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个适应参数是每个温度下的迭代次数。这个数字可以通过在高温度下允许少量迭代和在低温度下允许大量迭代来自适应地改变，以充分探索局部最优解。
- en: The adaptation ability of the SA algorithm can be also influenced by the objective
    function and the representation of problem constraints utilized. As a general
    rule, it is advisable to steer clear of cost functions that yield the same result
    for multiple states (e.g., the number of edges incorporated in a TSP route). This
    type of function does not guide the search because it may not change in the objective
    function from one state to another.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: SA算法的适应能力也可能受到目标函数和问题约束表示的影响。一般来说，建议避免产生多个状态相同结果的成本函数（例如，在TSP路中包含的边的数量）。这种类型的函数不会引导搜索，因为它可能不会在目标函数从一个状态到另一个状态时发生变化。
- en: For example, imagine two feasible routes with the same number of edges (i.e.,
    Δ*f* = 0). Counting on the number of edges as a cost function wouldn’t be a good
    idea. However, many problems have constraints that can be represented in the cost
    function using reward or penalty terms. One way to make the algorithm more adaptive
    is to dynamically change the weighting of the reward and penalty terms. In the
    initial phase, the constraints can be relaxed more than in the advanced phases
    of the search.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象两条具有相同边数的可行路线（即，Δ*f* = 0）。依赖边的数量作为成本函数并不是一个好主意。然而，许多问题都有可以使用奖励或惩罚项表示的约束。使算法更具适应性的方法之一是动态改变奖励和惩罚项的权重。在搜索的初始阶段，约束可以比搜索的高级阶段更宽松。
- en: 'There have been numerous efforts to make the selection and control of SA parameters
    totally adaptive. One example of such an effort was proposed by Ingber in “Adaptive
    simulated annealing (ASA): Lessons learned” [3]. ASA automatically adjusts the
    algorithm parameters that control the temperature schedule, requiring the user
    to only specify the cooling rate. The method uses a linear random combination
    of previously accepted steps and parameters to estimate new steps and parameters.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 已有众多努力使SA参数的选择和控制完全自适应。这种努力的例子之一是由Ingber在“自适应模拟退火（ASA）：经验教训” [3] 中提出的。ASA自动调整控制温度计划的算法参数，只需用户指定冷却速率。该方法使用先前接受的步骤和参数的线性随机组合来估计新的步骤和参数。
- en: An ASA algorithm with greedy search (ASA-GS) is proposed by Geng et al. to solve
    the TSP [4]. ASA-GS is based on the classical SA algorithm and utilizes a greedy
    search technique to speed up the convergence rate. ASA utilizes dynamic adjustments
    in parameters like the temperature cooling coefficient, greedy search iterations,
    compulsive accept instances, and probability of accepting a new solution. These
    adaptive parameter controls aim to enhance the trade-off between quality and time
    efficiency.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Geng等人提出了一种带有贪婪搜索的ASA算法（ASA-GS）来解决TSP问题[4]。ASA-GS基于经典的SA算法，并利用贪婪搜索技术来加速收敛速度。ASA利用动态调整参数，如温度冷却系数、贪婪搜索迭代次数、强制接受实例以及接受新解决方案的概率。这些自适应参数控制旨在增强质量和时间效率之间的权衡。
- en: SA finds extensive application across various domains. Its utility extends to
    solving diverse optimization problems encompassing nonlinear function optimization,
    TSP, academic course scheduling, network design, task allocation, circuit partitioning
    and placement, robot motion planning, and vehicle routing, as well as resource
    allocation and scheduling. The following sections show how you can use SA to solve
    continuous and discrete optimization problems in different domains.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: SA在各个领域都有广泛的应用。它的效用扩展到解决各种优化问题，包括非线性函数优化、TSP、学术课程安排、网络设计、任务分配、电路划分和放置、机器人运动规划、车辆路径以及资源分配和调度。以下各节将展示如何在不同领域使用SA来解决连续和离散优化问题。
- en: 5.3 Function optimization
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 函数优化
- en: 'As an example of continuous optimization problems, let’s consider the following
    simple function optimization problem: find *x* which minimizes *f*(*x*) = (*x*
    – 6)², subject to the constraint 0 ≤ *x* ≤ 31.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为连续优化问题的例子，让我们考虑以下简单的函数优化问题：在约束条件 0 ≤ *x* ≤ 31 下，找到 *x* 以最小化 *f*(*x*) = (*x*
    – 6)²。
- en: 'We can start with an initial random solution from the range of *x*. Different
    neighboring solutions can be generated by adding a random floating value chosen
    from a Gaussian or normal distribution with a given mean and standard deviation.
    The `random.gauss()` function in Python can be used as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 *x* 的范围内开始一个初始随机解决方案。可以通过添加一个从高斯或正态分布中选择的随机浮点值来生成不同的邻近解决方案，该分布具有给定的均值和标准差。以下是如何在Python中使用
    `random.gauss()` 函数的示例：
- en: '[PRE1]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Assume that the initial temperature *T*[0] = 5, the number of iterations per
    temperature is 2, and the geometric cooling factor *α* = 0.85. Let’s carry out
    a few hand iterations to show how SA can solve this problem:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设初始温度 *T*[0] = 5，每个温度的迭代次数为2，几何冷却因子 *α* = 0.85。让我们进行几次手动迭代，以展示SA如何解决这个问题：
- en: '*Initialization*—An initial solution is randomly generated, and its cost is
    evaluated as follows: *x* = 2 and *f*(2) = 16.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化*—随机生成一个初始解决方案，并按以下方式评估其成本：*x* = 2 和 *f*(2) = 16。'
- en: '*Iteration 1*—A new solution *x* = 2.25 is generated by adding a random value
    from a Gaussian distribution using the following code:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代1*—通过以下代码使用高斯分布添加一个随机值来生成一个新的解决方案 *x* = 2.25：'
- en: '[PRE2]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*f*(2.25) = 14.06 is an improving solution and so is accepted.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(2.25) = 14.06 是一个改进的解决方案，因此被接受。'
- en: '*Iteration 2*—A new solution is generated by adding a random value to the last
    accepted solution from the previous iteration. The new solution *x* =2.25 – 1.07
    = 1.18, *f*(1.18) = 23.23 is a non-improving solution, so the acceptance probability
    must be calculated: *p* = *e*^(–Δf /T) = *e*^(–(23.23 – 14.06)/5) = 0.1597. We
    generate a random number *r* between (0,1), and let’s say it was *r* = 0.37. As
    *p* ≯ *r*, we reject this solution.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代2*—通过向上一迭代中最后接受的解决方案添加一个随机值来生成一个新的解决方案。新的解决方案 *x* = 2.25 – 1.07 = 1.18，*f*(1.18)
    = 23.23 是一个非改进的解决方案，因此必须计算接受概率：*p* = *e*^(–Δf /T) = *e*^(–(23.23 – 14.06)/5) =
    0.1597。我们生成一个介于 (0,1) 之间的随机数 *r*，假设它是 *r* = 0.37。由于 *p* ≯ *r*，我们拒绝这个解决方案。'
- en: '*Iteration 3*—We update the temperature because we have used the initial temperature
    *T[0]* = 5 for two iterations so far. Following geometric cooling, the new temperature
    is *T[1]* = *T[o] α^i* = 5*0.85¹ = 4.25. We’ll use this value for two iterations
    starting with this iteration. We’ll now generate a new solution based on the last
    accepted solution by adding a random value from a Gaussian distribution. The new
    solution is *x* = 2.25 + 1.57 = 3.82 with *f*(3.82) = 4.75. This is an improving
    solution, so it’s accepted, and the search continues.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代 3*—我们更新了温度，因为我们已经使用了初始温度 *T[0]* = 5 进行了两次迭代。按照几何冷却，新的温度是 *T[1]* = *T[o]
    α^i* = 5*0.85¹ = 4.25。我们将从这次迭代开始使用这个值进行两次迭代。现在我们将基于最后一个接受的解生成一个新的解，通过添加高斯分布的随机值。新的解是
    *x* = 2.25 + 1.57 = 3.82，且 *f*(3.82) = 4.75。这是一个改进的解，因此它被接受，搜索继续。'
- en: SciPy provides Python implementations for SA algorithms and other algorithms
    to handle mathematical optimization problems. `scipy.optimize.anneal` is deprecated
    in SciPy, and a `dual_annealing()` function is available instead. The following
    listing shows the Bohachevsky function (which has the formula *f*(*x[1]*,*x[2]*)
    = *x[1]*² + 2*x[2]*² – 0.3cos(3*πx[1]*) – 0.4cos(3*πx[2]*) + 0.7) solution using
    the SciPy dual annealing algorithm. The complete listing is available in the book’s
    GitHub repo.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 为 SA 算法和其他处理数学优化问题的算法提供了 Python 实现。`scipy.optimize.anneal` 在 SciPy 中已弃用，取而代之的是
    `dual_annealing()` 函数。以下列表展示了使用 SciPy 双重退火算法求解 Bohachevsky 函数（该函数的公式为 *f*(*x[1]*,*x[2]*)
    = *x[1]*² + 2*x[2]*² – 0.3cos(3*πx[1]*) – 0.4cos(3*πx[2]*) + 0.7）的解。完整的列表可在本书的
    GitHub 仓库中找到。
- en: Listing 5.1 Function optimization using `scipy.optimize.dual_annealing`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 使用 `scipy.optimize.dual_annealing` 进行函数优化
- en: '[PRE3]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Define the objective function or functions (e.g., Bohachevsky function).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义目标函数或函数（例如，Bohachevsky 函数）。
- en: ② Define the boundary constraints of the decision variables.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义决策变量的边界约束。
- en: ③ Perform the dual annealing search.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 执行双重退火搜索。
- en: ④ Print the dual annealing solution.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 打印双重退火解。
- en: 'MEALPY is another Python library that provides implementations of different
    nature-inspired metaheuristic algorithms (see appendix A for more details). As
    a continuation, the following code shows the Bohachevsky function solution using
    MEALPY SA (the complete version of listing 5.1 is available in the book’s GitHub
    repo):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: MEALPY 是另一个提供不同自然启发式元启发式算法实现的 Python 库（更多详细信息请见附录 A）。作为延续，以下代码展示了使用 MEALPY SA（列表
    5.1 的完整版本可在本书的 GitHub 仓库中找到）求解 Bohachevsky 函数的解：
- en: '[PRE4]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Define the problem
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义问题
- en: ② Define the MEALPY algorithm parameters to perform an SA search using MEALPY.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义 MEALPY 算法参数以使用 MEALPY 进行 SA 搜索。
- en: ③ Define a MEALPY SA solver.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义 MEALPY SA 求解器。
- en: ④ Solve the problem using a defined solver.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用定义的求解器解决问题。
- en: ⑤ Print the MEALPY SA solution.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 打印 MEALPY SA 解。
- en: Figure 5.10 shows the Bohachevsky function’s solution. The performance of the
    algorithm depends mainly on its parameter tuning and stopping criteria. MEALPY
    runs a parallel version of SA and exposes many parameters to be tuned.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 展示了 Bohachevsky 函数的解。算法的性能主要取决于其参数调整和停止标准。MEALPY 运行 SA 的并行版本，并公开了许多可调整的参数。
- en: '![](../Images/CH05_F10_Khamis.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F10_Khamis.png)'
- en: Figure 5.10 Solution of a continuous function optimization problem using SA.
    The cross in the center is the optimal solution. The triangle is the solution
    obtained by MEALPY SA. The dot is the SciPy dual annealing solution.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 使用 SA 解决连续函数优化问题的解。中心处的十字是最佳解。三角形是 MEALPY SA 获得的解。点是 SciPy 双重退火解。
- en: Note Appendix A shows how to use SA in other Python packages to solve mathematical
    optimization problems.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意附录 A 展示了如何在其他 Python 包中使用 SA 解决数学优化问题。
- en: Let’s implement an SA algorithm from scratch so we can gain more control and
    better handle different types of continuous and discrete optimization problems.
    In our implementation in the optalgotools package, we decouple the problem definition
    from the solver so we can use the solvers to handle different problems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头实现 SA 算法，这样我们可以获得更多的控制，并更好地处理不同类型的连续和离散优化问题。在我们的 optalgotools 包实现中，我们将问题定义与求解器解耦，这样我们就可以使用求解器来处理不同的问题。
- en: Let’s apply our implementation to find the global minimum of the aforementioned
    simple function optimization problem and of more complex function optimization
    problems as well. There are several complex mathematical functions in multidimensional
    space, such as Rosenbrock’s function, the Ackley function, the Rastrigin function,
    the Schaffer function, the Schwefel function, the Langermann function, the Levy
    function, the Bukin function, the Eggholder function, the cross-in-tray function,
    the drop wave function, and the Griewank function. Examples of function optimization
    test problems and datasets can be found in appendix B.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.2 shows how SA can be used to solve the following mathematical functions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*A simple quadratic equation*—This is what we used in the hand iterations.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Bohachevsky function (global minimum 0)*—This is a 2D unimodal function
    with a bowl shape. This function is known to be continuous, convex, separable,
    differentiable, nonmultimodal, nonrandom, and nonparametric, so derivate-based
    solvers can efficiently handle it. Note that a function whose variables can be
    separated is known as a *separable function*. Nonrandom functions contain no random
    variables. Nonparametric functions assume that the data distribution cannot be
    defined in terms of a finite set of parameters.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Bukin function*—This function has many local minima, all of which lie
    on a ridge, and one global minimum *f*(*x[0]*) = 0 at *x[0]* = *f*(−10,1). This
    function is continuous, convex, nonseparable, nondifferentiable, multimodal, nonrandom,
    and nonparametric. This requires a derivative-free solver (also known as a black-box
    solver) such as SA.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Gramacy & Lee function*—This is a 1D function with multiple local minima
    and local and global trends. This function is continuous, nonconvex, separable,
    differentiable, nonmultimodal, nonrandom, and nonparametric.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Griewank 1D, 2D, and 3D functions*—These have many widespread local minima.
    These functions are continuous, nonconvex, separable, differentiable, multimodal,
    nonrandom, and nonparametric.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our implementation, these are the SA parameters:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'A maximum number of iterations: `max_iter=1000`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maximum iterations per temperature: `max_iter_per_temp=100`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An initial temperature: `initial_temp=1000`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A final temperature: `final_temp=0.0001`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A cooling schedule: `cooling_schedule=''geometric''` (available options: `''linear''`,
    `''geometric''`, `''logarithmic''`, `''exponential''`, `''linear_inverse''`)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A cooling factor: `cooling_alpha=0.9`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A debug option: `debug=1` (`debug=1` prints the initial and final solution;
    `debug=2` provides hand-iteration tracing)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to change these settings and observe their effect on the performance
    of the algorithm.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.2 Continuous function optimization using SA
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Quadratic function SA-based solution
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: ② Bohachevsky SA-based solution
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: ③ Bukin SA-based solution
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: ④ Gramacy & Lee SA-based solution
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Griewank 1D SA-based solution
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Griewank 2D SA-based solution
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Griewank 3D SA-based solution
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of the output for the Bukin function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As can be seen, SA is able to handle different multidimensional, nonlinear function
    optimization problems. This stochastic global optimization algorithm is able to
    adapt to the landscape of the objective function and avoid getting trapped in
    local minima. However, in the case of multidimensional functions such as Griewank
    2D and 3D, SA takes time to converge. The following sections show how SA can handle
    discrete problems such as Sudoku and TSP.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Solving Sudoku
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sudoku, also known as Su Doku, is one of the most popular number puzzles of
    all time. This game is adapted from a mathematical concept called a *Latin square*.
    The first version of the Sudoku puzzle was created by a retired architect named
    Howard Garns and appeared in the late 1970s as a puzzle in *Dell Pencil Puzzles
    and Word Games*. The game subsequently showed up in Japan in 1984 under the name
    “Sudoku,” which is abbreviated from the Japanese “Sūji wa dokushin ni kagiru,”
    which means the numbers (or digits) must remain single. Nowadays, Sudoku games
    are popular around the globe and are published in game websites, puzzle booklets,
    and newspapers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The Sudoku game can be seen as a constraint-satisfaction problem (CSP) that
    is solved by correctly filling a 9 × 9 grid with digits so that each column, each
    row, and each of the nine 3 × 3 subgrids (aka “boxes,” “blocks,” or “regions”)
    contain all of the digits from 1 to 9\. Any row or column or 3 × 3 subgrid shouldn't
    contain more than one of the same number from 1 to 9\.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Aside from entertainment, Sudoku is used in real-life applications such as developmental
    psychology and steganography. For example, several studies have showed that solving
    Sudoku or crosswords or other brain games may help in keeping your brain 10 years
    younger and can slow down the progression of conditions such as Alzheimer’s. Sudoku
    can also be used as a tool to improve problem-solving skills, critical thinking,
    and attention. Finally, steganography is the technique of hiding images, messages,
    files, or other secret data within something that isn’t a secret. In secret data
    delivery applications, digital images can be used to conceal secret data. The
    Sudoku puzzle is then used to modify selected pixel pairs in the cover image,
    based on a specially designed reference matrix, to insert secret digits.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Latin square
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Latin squares were devised in the 10th century by Arabic numerologists who dealt
    with the mystical power of numbers. Islamic amulets, known as wafq majazi, from
    the 13th century have been found, and they were sketched in the margins of a 16th
    century Arabic medical text. The name “Latin” was inspired by the famous Swiss
    mathematician Leonhard Euler (1707–1783) who used Latin letters as symbols in
    the squares.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'A *Latin square* is an *n* × *n* array filled with *n* different numbers, symbols,
    or colors arranged in such a way that no orthogonal (row or column) contains the
    same number, symbol, or color twice. An example of a 4 × 4 Latin square is shown
    here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*拉丁方*是一个*n* × *n*的数组，填充了*n*个不同的数字、符号或颜色，以这样的方式排列，即任何正交（行或列）都不会包含相同的数字、符号或颜色两次。这里展示了一个4
    × 4拉丁方的例子：'
- en: '![](../Images/CH05_F10_UN03_Khamis.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F10_UN03_Khamis.png)'
- en: Latin squares are different from *magic squares*. A magic square is a square
    array of positive integers 1, 2, ..., *n*² arranged such that the sum of the *n*
    numbers in any horizontal, vertical, or main diagonal line is always the same
    number. Sudoku is based on Latin squares. In fact, any solution to a Sudoku puzzle
    is a Latin square. KenKen and KenDoku are other number puzzles based on an enhanced
    version of Latin squares and require some degree of arithmetic skills.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 拉丁方与*幻方*不同。幻方是一个正整数1, 2, ..., *n*²的平方数组，这些数按照这样的方式排列，即任何水平、垂直或主对角线上的*n*个数的和总是相同的数。数独基于拉丁方。事实上，任何数独谜题的解决方案都是一个拉丁方。KenKen和KenDoku是基于拉丁方增强版本的其它数字谜题，需要一定程度的算术技能。
- en: Generally speaking, the search space of Sudoku is huge. There are 6.671 × 10^(21)
    possible solvable Sudoku grids that yield a unique result [5]. According to Encyclopedia
    Britannica, if each human on earth solves one Sudoku puzzle every second, they
    wouldn’t get through all of them until about the year 30,992\. However, taking
    out symmetries, such as rotations, reflections, permuting columns and rows, and
    swapping digits, the number of essentially different Sudoku grids is reduced to
    5,472,730,538 ≈5.473 × 10⁹ [6]. The generalized *n* × *n* Sudoku problem is an
    NP-complete problem. However, some instances, such as standard 9 × 9 Sudoku, are
    not NP-complete. Constant-time algorithms exist to solve some instances of 9 ×
    9 Sudoku, in *O*(1) time, as each and every 9 × 9 Sudoku can be listed, enumerated,
    and indexed in a finite dictionary or a lookup table used to find a solution.
    However, these algorithms cannot handle arbitrary generalized *n* × *n* Sudoku
    problems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，数独的搜索空间非常庞大。存在6.671 × 10^(21)种可能的可解数独网格，它们会产生一个唯一的结果[5]。根据大英百科全书，如果地球上每个人每秒解决一个数独谜题，他们要到大约30,992年才能全部解决。然而，去除对称性，例如旋转、反射、列和行的排列以及数字的交换，本质上不同的数独网格数量减少到5,472,730,538
    ≈5.473 × 10⁹[6]。广义的 *n* × *n* 数独问题是一个NP完全问题。然而，一些实例，例如标准的9 × 9数独，并不是NP完全的。存在常数时间算法可以解决一些9
    × 9数独的实例，在*O*(1)时间内解决，因为每个9 × 9数独都可以在一个有限的字典或查找表中列出、枚举和索引，以找到解决方案。然而，这些算法无法处理任意的广义
    *n* × *n* 数独问题。
- en: Backtracking, dancing links, and Crook’s pencil-and-paper are common algorithms
    for solving Sudoku, especially if the size of the problem is small. *Backtracking*
    is mainly a classical depth-first search that tests a whole branch until that
    branch violates the rules or returns a solution.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯法、舞链法和克罗克的纸笔法是解决数独的常见算法，尤其是当问题规模较小时。*回溯法*主要是一种经典的深度优先搜索，它会测试整个分支，直到该分支违反规则或返回一个解决方案。
- en: '*Dancing links* (DLX), invented by Donald Knuth in 2000, uses algorithm X to
    solve Sudoku puzzles, handled as exact cover problems. In the exact cover problem,
    given a binary matrix (i.e., a matrix composed only of 0 and 1), it is necessary
    to find a set of rows containing exactly one 1 in each column. Algorithm X, a
    recursive search algorithm, is applied to solve the exact cover problem using
    the backtracking method.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*舞链法*（DLX），由唐纳德·克努斯于2000年发明，使用算法X来解决数独谜题，将其作为精确覆盖问题处理。在精确覆盖问题中，给定一个二元矩阵（即仅由0和1组成的矩阵），需要找到一组行，每列恰好包含一个1。算法X，一种递归搜索算法，通过回溯法应用于解决精确覆盖问题。'
- en: In *Crook’s pencil-and-paper algorithm*, all possible numbers in each cell are
    listed. This list of numbers is called marking-up of the cell. We then try to
    find out if there is a row, column, or block with only one possible value throughout
    the row, column, or block. Once found, we fill in this cell with this number and
    update the markups in any affected row, column, or box. The next step is to find
    preemptive sets. As described in Crook’s paper, a preemptive set is composed of
    numbers from the set [1,2,…,9] and is a set of size *m*, 2 ≤ *m* ≤ 9, whose numbers
    are potential occupants of *m* cells exclusively, where exclusively means that
    no other numbers in the set [1,2,…,9], other than the members of the preemptive
    set, are potential occupants of those *m* cells. The last step is to eliminate
    possible numbers outside preemptive sets.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking algorithms are commonly used to solve search and optimization problems
    by recursion. The backtracking algorithm builds a feasible solution or a set of
    feasible solutions incrementally. Given a 9 × 9 Sudoku board, the algorithm visits
    all the empty cells following depth-first traversal order, filling the digits
    incrementally, and it backtracks when a number is not found to be valid. The following
    figure illustrates the backtracking algorithm steps for a 9 × 9 Sudoku puzzle.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F10_UN04_Khamis.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: Backtracking steps for a 9 × 9 Sudoku puzzle
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The next listing shows how a 9 × 9 Sudoku is solved using the SA algorithm.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.3 Solving Sudoku using SA
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Import the SA solver.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: ② Import a Sudoku problem.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create a SA solver with the selected parameters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a hard 9 × 9 Sudoku (available variants include trivial, easy, medium,
    hard, and evil).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Solve the Sudoku using the backtracking algorithm.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Solve the Sudoku using SA.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: You can try different variants of Sudoku by changing the puzzle configuration.
    In easy Sudoku problems, cells contain more prefilled numbers than medium or hard
    ones. Evil Sudoku is the highest level of puzzle difficulty. Table 5.2 compares
    the time it takes for SA, backtracking, and the Python Linear Programming (PuLP)
    library to solve different instances of 9 × 9 Sudoku puzzles. PuLP provides linear
    and mixed programming solvers. The default solver used in PuLP is Cbc (COIN-OR
    branch and cut), which is an open source solver for mixed integer linear programming
    problems. More information about PuLP is available in appendix A.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.2 SA versus backtracking versus PuLP in solving a 9 × 9 Sudoku puzzle
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '| Time to find the solution(s) | Trivial | Easy | Medium | Hard | Evil |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| Backtracking | 0.01 | 0.01 | 0.11 | 0.69 | 1.58 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| PuLP | 0.69 | 0.12 | 0.11 | 0.13 | 0.12 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| Classical SA | 0.10 | 0.07 | 0.01 | 3:17 | Suboptimal in 3:16 |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: As you can see, classical SA does not outperform the backtracking approach and
    is much slower in the case of hard and evil instances of Sudoku problems. PuLP
    is efficiently able to handle different variants of Sudoku in a consistent time,
    compared to backtracking and SA.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In the case of evil Sudoku, SA converges to a suboptimal solution despite trying
    different parameter settings. Given that this is a constraint-satisfaction problem,
    the notion of suboptimality is not valid, as a suboptimal solution is an invalid
    solution. This means that SA doesn’t manage to solve the evil instance of Sudoku.
    Being a well-structured problem, 9 × 9 Sudoku with different levels of difficulty
    can be easily solved using a backtracking algorithm. Generally speaking, if the
    problem is well-structured with a well-known algorithm solution, metaheuristics
    approaches don’t usually outperform these classical and more deterministic approaches.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Solving TSP
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As described in section 2.1.1, the traveling salesman problem (TSP) is used
    as a platform for the study of general methods that can be applied to a wide range
    of discrete optimization problems. Consider solving the instance of TSP shown
    in figure 5.11 using SA. In this TSP, a traveling salesman must visit five cities
    and return home, making a loop (a round trip).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F11_Khamis.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 TSP for five cities—there are 5!/2 = 60 possible tours, assuming
    symmetric TSP. The weights on the edges of the graph represent the travel distances
    between the cities.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the following values: initial temperature = 500, final temperature =
    50, a linear decrement rate of 50, and one iteration at each temperature. A TSP
    solution takes the form of a permutation as follows: Solution = [ 1, 3, 4, 2,
    5]. The objective function is the total distance of the route. Swapping is a suitable
    operator that can be used to generate neighboring solutions:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '*Iteration 0*—The initial solution is Solution = [ 1, 3, 4, 2, 5], cost = 2
    + 4 + 5 + 5 + 12 = 28, as shown in figure 5.12.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F12_Khamis.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 SA iteration 0 of a 5-city TSP
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '*Iteration 1*—To generate a candidate solution, select two random cities (e.g.,
    2 and 3), and swap them. This results in a new solution [ 1, 2, 4, 3, 5] with
    a cost of 35 (figure 5.13).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F13_Khamis.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 SA iteration 1 of a 5-city TSP
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the new solution has a longer tour length, it will be conditionally accepted,
    according to a probability of *p* = *e*^–^Δ*^f* ^/*^T* = *e*^(–(35–28) /)*^T*
    = *e*^(–7 /)*^T* (at higher temperatures, there’s a higher probability of acceptance).
    We pick a random value *r* within 0 and 1\. If *P* > *r*, we accept this solution.
    Otherwise, we reject this solution. Assuming the new solution was not accepted,
    we generate a different one, starting from the initial solution:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '*Iteration 2*—A solution is generated by swapping cities 2 and 5 in the initial
    solution. The tour length of the candidate solution is 18 (figure 5.14).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F14_Khamis.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 SA iteration 2 of a 5-city TSP
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Since this solution has a shorter tour length, it will be accepted, and the
    search continues until the termination criteria are met. The following listing
    shows an SA solution for this simple TSP problem.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.4 Solving TSP using SA
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Create an instance of a TSP problem.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: ② Create an instance of the SA solver.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: ③ Run the SA solver, and show the results in each iteration.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now consider some benchmark instances of TSP, such as Berlin52 from TSPLIB
    ([http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/)).
    This dataset contains 52 locations in the city of Berlin. The shortest route obtained
    for the Berlin52 dataset is 7,542\. The next listing shows how we can solve this
    TSP instance using our SA implementation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.5 Solving the Berlin52 TSP using SA
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Permanent URL for the Berlin52 dataset
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a TSP object for Berlin52.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create an SA model.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: ④ Run SA, and evaluate the best solution distance.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Plot the route.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the output:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Figure 5.15 shows the route generated by SA for Belin52 TSP.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F15_Khamis.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 Solution of Belin52 using SA
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the near-optimal solution found by SA is 8,106.88\. This value
    is a bit higher than the best-known solution for the Berlin52 TSP, which is 7,542\.
    Parameter tuning and algorithm adaptation can help improve the results. For example,
    Geng et al.’s “Solving the traveling salesman problem based on an adaptive simulated
    annealing algorithm with greedy search” paper discusses using three kinds of mutations
    (vertex insert mutation, block insert mutation, and block reverse mutation) with
    different probabilities during the search to improve the accuracy of SA in solving
    TSP problems. Moreover, parameters such as the cooling coefficient of the temperature,
    the times of greedy search used to speed up the convergence rate, the times of
    compulsive accept, and the probability of accepting a new solution, can be adapted
    according to the size of the TSP instances. An implementation of this adaptive
    algorithm is available from this GitHub repo: [https://github.com/ildoonet/simulated-annealing-for-tsp](https://github.com/ildoonet/simulated-annealing-for-tsp).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect of the algorithm’s parameters can be studied, such as the initial
    temperature, the cooling schedule, the number of iterations per temperature, and
    the final temperature. For example, SA was applied for the Berlin52 TSP instance
    with the following settings:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of iterations = 1200
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of iterations per each temperature T = 500
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T*[initial]* = 150
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T*[final]* = 0.01
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear cooling
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our implementation supports the following methods for mutating a new solution
    from an old one:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '`random_swap`—Swap two cities in the path. This can be done multiple times
    for the same solution by using `num_swaps`. Also, the swap can be done in a smaller
    window of the whole path using `swap_wind = [1 - n]`. For example, suppose the
    route is [A, B, C, D, F]. Swapping two random cities, like B and F, will result
    in a new route [A, F, C, D, B].'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse`—Reverse the order of a subset of the cities with either a random
    length, using `rand_len`, or using `rev_len`, which has a default of 2\. For example,
    starting with the solution [A, B, C, D, F], if we apply `reverse` with length
    3, we can get a new solution [A, D, C, B, F].'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert`—Pick a random city, remove it from the path, and reinsert it before
    a different random city. For example, starting from the solution [A, B, C, D,
    F], we could pick city B and insert it before city F so we get a new solution
    [A, C, D, B, F].'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutate`—Randomly pick a number of consecutive cities from the current solution,
    and shuffle them. For example, starting from the solution [A, B, C, D, F], we
    may pick C, D, F and shuffle them so we get a new solution [A, B, F, C, D].'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation also supports two methods of initializing the path:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '`random`—This means the path is generated completely randomly.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`greedy`—This tries to select a possibly suboptimal initial path by selecting
    the pairwise shortest distances between cities. This will not lead to the shortest
    path, but it may be better than the random initialization.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is worth noting that the results of the SA algorithm may not be exactly
    repeatable. Due to the randomness included in the algorithm, each time you run
    the algorithm, you may get slightly different results. To avoid this, the `run`
    function included in the `SimulatedAnnealing` class contains a `repetition` argument
    that allows you to report the best solution generated out of multiple runs, as
    follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can set repetition to be 10, so the algorithm reports the best solution
    generated out of 10 runs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Solving a delivery semi-truck routing problem
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s consider a more real-life example of TSP. Assume that Walmart Supercenters
    are points of interest (POIs) to be visited by a delivery semi-truck. The vehicle
    will start from Walmart Supercenter number 3001, located at 270 Kingston Rd. E
    in Ajax, Ontario. It is required to find the shortest possible route the truck
    can follow to visit each POI only once and get back to the home location. There
    are 18 Walmart Supercenters in the selected part of the Greater Toronto Area (GTA),
    as shown in figure 5.16\. This results in 18! possible routes to visit these stores
    located in Durham Region, York Region, and Toronto, Ontario.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F16_Khamis.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 Selected Walmart Supercenters in the Greater Toronto Area (GTA)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The GPS coordinates (longitude and latitude) of each POI and the addresses are
    available on the POI Factory website ([www.poi-factory.com/node/25560](http://www.poi-factory.com/node/25560))
    and are included in the Walmart_United States&Canada.csv file that can be downloaded
    for free (for noncommercial use) after registration. Google Places API, Here Places
    API, and SafeGraph on ArcGIS Marketplace can also be used to get data about points
    of interest such as hospitals, restaurants, retail stores, and grocery stores.
    Appendix B provides more details about open data sources.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The OSMnx library is used in this example to create a NetworkX graph that represents
    the supercenter locations. Pyrosm can also be used instead of OSMnx. The shortest
    distances between these locations are computed using the NetworkX built-in function
    `shortest_path`, which uses Dijkstra’s algorithm as a default method (see section
    3.4.1). Supercenter locations are rendered on OpenStreetMap based on their GPS
    coordinates using the folium library. Appendix A provides more details about these
    libraries.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, the problem solver is decoupled from the problem object.
    We start by creating a TSP object for this discrete problem. We then create an
    SA object to solve the TSP problem. An initial solution is generated using the
    `mutate` method. As shown in figure 5.17, this initial solution is far from optimal.
    The total length of the initial route is 593.88 km, and this route is not convenient
    or easy to follow in practice.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F17_Khamis.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 Initial solution for the Walmart delivery semi-truck route with
    a total distance of 593.88 km
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run SA with the following parameters:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of iterations = 10000
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum interaction per temperature = 100
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial temperature = 85
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final temperature = 0.0001
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear cooling schedule
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other cooling schedules could also be used. For example, geometric cooling can
    generate consistent, superior-quality, and timely solutions compared to other
    schemes. However, this is one of the algorithm parameters that can be tuned, as
    it sometimes depends on the nature of the problem. Figure 5.18 shows the shortest
    route with a total distance of 227.17 km.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH05_F18_Khamis.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 SA solution for the Walmart delivery semi-truck route with a total
    distance of 227.17 km
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The next listing is a snippet of the code used to generate the shortest route
    for the delivery semi-truck using SA. The complete code is available in the book’s
    GitHub repo.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.6 Generating a Walmart delivery semi-truck route using SA
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Load a list of all Walmart locations in Ontario.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: ② Select cities that are in Durham Region, York Region, or Toronto.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: ③ Select Walmart stores that are in the preceding list and are Supercenters.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: ④ Get the lat. and long. locations of the preceding set of Walmarts, and create
    a graph of roads that connects them and that is within 42 km.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Calculate the distances between the Walmart locations using the graph.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Create a TSP object for the problem.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Create an SA object to help solve the TSP problem.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Get an initial random solution, and check its length
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Run SA, and evaluate the best solution distance.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we separated the solver class from the problem object in optalgotools.
    The solver is imported from `algorithms`, and the problem is an instance of the
    TSP problem in the `problems` class. This implementation allows you to change
    the problem instances and tune the parameters of the algorithm to reach an optimal
    or near-optimal solution. You may consider trying the adaptation aspects of SA
    explained in section 5.2.5 to figure out their effect on the algorithm’s performance
    in terms of the length of the obtained route and the run time (CPU time and wall-clock
    time).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: A metaheuristic algorithm like SA seeks optimal or near-optimal solutions at
    a reasonable computational cost, but it cannot guarantee either their feasibility
    or degree of optimality. With proper parameter tuning, the algorithm can provide
    acceptable solutions without further postprocessing. In the next chapter, we will
    discuss tabu search as another trajectory-based optimization algorithm.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metaheuristic algorithms can be broadly classified into trajectory-based algorithms
    and population-based algorithms. A trajectory-based metaheuristic algorithm, or
    S-metaheuristic, uses a single search agent that moves through the design or search
    space in a piecewise style. Population-based algorithms, or P-metaheuristics,
    use multiple agents to search for an optimal or near-optimal global solution.
    Simulated annealing is a trajectory-based metaheuristic algorithm.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulated annealing mimics the annealing process in material processing, where
    a metal cools and freezes into a crystalline state with the minimum energy and
    larger crystal size so as to reduce the defects in metallic structures. The annealing
    process involves the careful control of temperature and cooling rate, often called
    the annealing schedule.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulated annealing runs a series of moves under different thermodynamic conditions
    and always accepts improving moves and can probabilistically accept non-improving
    moves.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The acceptance probability is proportional to the temperature. A high temperature
    increases the chance of accepting non-improving moves to favor exploration of
    the search space at the beginning of the search. As the search progresses, the
    temperature is decremented to restrict exploration and favor exploitation.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the temperature goes to zero, SA acts greedily like hill climbing, and as
    the temperature goes to infinity, SA behaves like a random walk. The temperature
    should decrease gradually to achieve the best trade-off between exploration and
    exploitation.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulated annealing is a stochastic search algorithm and a derivative-free solver
    that can be used when derivative information is unavailable, unreliable, or prohibitively
    expensive. SA seeks optimal or near-optimal solutions at a reasonable computational
    cost but it cannot guarantee either the feasibility or degree of optimality.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptive simulated annealing can dynamically change its parameters with the
    search progress to control the exploration and exploitation behavior.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulated annealing is an easy-to-implement probabilistic approximation algorithm
    that can be used to solve continuous and discrete problems in different domains.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
