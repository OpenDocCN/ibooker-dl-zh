<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div class="readable-text" id="p1"> 
   <h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">10</span></span> <span class="chapter-title-text">Agent reasoning and evaluation</span></h1> 
  </div> 
  <div class="introduction-summary"> 
   <h3 class="introduction-header sigil_not_in_toc">This chapter covers</h3> 
   <ul> 
    <li class="readable-text" id="p2">Using various prompt engineering techniques to extend large language model functions</li> 
    <li class="readable-text" id="p3">Engaging large language models with prompt engineering techniques that engage reasoning</li> 
    <li class="readable-text" id="p4">Employing an evaluation prompt to narrow and identify the solution to an unknown problem </li> 
   </ul> 
  </div> 
  <div class="readable-text" id="p5"> 
   <p>Now that we’ve examined the patterns of memory and retrieval that define the semantic memory component in agents, we can take a look at the last and most instrumental component in agents: planning. Planning encompasses many facets, from reasoning, understanding, and evaluation to feedback.</p> 
  </div> 
  <div class="readable-text intended-text" id="p6"> 
   <p>To explore how LLMs can be prompted to reason, understand, and plan, we’ll demonstrate how to engage reasoning through prompt engineering and then expand that to planning. The planning solution provided by the Semantic Kernel (SK) encompasses multiple planning forms. We’ll finish the chapter by incorporating adaptive feedback into a new planner.</p> 
  </div> 
  <div class="readable-text intended-text" id="p7"> 
   <p>Figure 10.1 demonstrates the high-level prompt engineering strategies we’ll cover in this chapter and how they relate to the various techniques we’ll cover. Each of the methods showcased in the figure will be explored in this chapter, from the basics of solution/direct prompting, shown in the top-left corner, to self-consistency and tree of thought (ToT) prompting, in the bottom right.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p8">  
   <img alt="figure" src="../Images/10-1.png" width="1009" height="914"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.1</span> How the two planning prompt engineering strategies align with the various techniques</h5>
  </div> 
  <div class="readable-text" id="p9"> 
   <h2 class="readable-text-h2" id="sigil_toc_id_136"><span class="num-string">10.1</span> Understanding direct solution prompting</h2> 
  </div> 
  <div class="readable-text" id="p10"> 
   <p><em>Direct solution prompting</em> is generally the first form of prompt engineering that users employ when asking LLMs questions or solving a particular problem. Given any LLM use, these techniques may seem apparent, but they are worth reviewing to establish the foundation of thought and planning. In the next section, we’ll start from the beginning, asking questions and expecting answers.</p> 
  </div> 
  <div class="readable-text" id="p11"> 
   <h3 class="readable-text-h3" id="sigil_toc_id_137"><span class="num-string">10.1.1</span> Question-and-answer prompting</h3> 
  </div> 
  <div class="readable-text" id="p12"> 
   <p>For the exercises in this chapter, we’ll employ prompt flow to build and evaluate the various techniques. (We already extensively covered this tool in chapter 9, so refer to that chapter if you need a review.) Prompt flow is an excellent tool for understanding how these techniques work and exploring the flow of the planning and reasoning process.</p> 
  </div> 
  <div class="readable-text intended-text" id="p13"> 
   <p>Open Visual Studio Code (VS Code) to the <code>chapter</code> <code>10</code> source folder. Create a new virtual environment for the folder, and install the <code>requirements.txt</code> file. If you need help setting up a chapter’s Python environment, refer to appendix B.</p> 
  </div> 
  <div class="readable-text intended-text" id="p14"> 
   <p>We’ll look at the first flow in the <code>prompt_flow/question-answering-prompting</code> folder. Open the <code>flow.dag.yaml</code> file in the visual editor, as shown in figure 10.2. On the right side, you’ll see the flow of components. At the top is the <code>question_answer</code> LLM prompt, followed by two <code>Embedding</code> components and a final LLM prompt to do the evaluation called <code>evaluate</code>.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p15">  
   <img alt="figure" src="../Images/10-2.png" width="1012" height="524"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.2</span> The <code>flow.dag.yaml</code> file, open in the visual editor, highlighting the various components of the flow</h5>
  </div> 
  <div class="readable-text" id="p16"> 
   <p>The breakdown in listing 10.1 shows the structure and components of the flow in more detail using a sort of YAML-shortened pseudocode. You can also see the input and outputs to the various components and a sample output from running the flow.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p17"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.1</span> <code>question-answer-prompting</code> flow</h5> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">   Inputs:
        context  : the content to ask the question about
        question : question asked specific to the content
        expected : the expected answer

<strong>   </strong>LLM: Question-Answer (the prompt used to ask the question)
        inputs:
               context and question
        outputs: 
               the prediction/answer to the question

   Embeddings: uses an LLM embedding model to create the embedding 
representation of the text

     Embedding_predicted: embeds the output of the Question-Answer LLM
     Embedding_expected: embeds the output of the expected answer

<strong>   </strong>Python: Evaluation (Python code to measure embedding similarity)
     Inputs:
            Embedding_predicted output
            Embedding_expected output
     Outputs: 
            the similarity score between predicted and expected

   Outputs:
        context: -&gt; input.context
        question: -&gt; input.question
     expected: -&gt; input.expected
     predicted: -&gt; output.question_answer
     evaluation_score: output.evaluation

### Example Output
{
    "context": "Back to the Future (1985)…",
    "evaluation_score": 0.9567478002354606,
    "expected": "Marty traveled back in time 30 years.",
    "predicted": "Marty traveled back in time 30 years from 1985 to 1955 
in the movie \"Back to the Future.\"",
    "question": "How far did Marty travel back in time in the movie 
Back to the Future (1985)"
}</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p18"> 
   <p>Before running this flow, make sure your LLM block is configured correctly. This may require you to set up a connection to your chosen LLM. Again, refer to chapter 9 if you need a review on how to complete this. You’ll need to configure the LLM and <code>Embedding</code> blocks with your connection if you’re not using OpenAI.</p> 
  </div> 
  <div class="readable-text intended-text" id="p19"> 
   <p>After configuring your LLM connection, run the flow by clicking the Play button from the visual editor or using the Test (Shift-F5) link in the YAML editor window. If everything is connected and configured correctly, you should see output like that in listing 10.1.</p> 
  </div> 
  <div class="readable-text intended-text" id="p20"> 
   <p>Open the <code>question_answer.jinja2</code> file in VS Code, as shown in listing 10.2. This listing shows the basic question-and-answer-style prompt. In this style of prompt, the system message describes the basic rules and provides the context to answer the question. In chapter 4, we explored the retrieval augmented generation (RAG) pattern, and this prompt follows a similar pattern.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p21"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.2</span> <code>question_answer.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:
Answer the users question based on the context below. Keep the answer 
short and concise. Respond "Unsure about answer" if not sure about the 
answer.

Context: {{context}}    <span class="aframe-location"/> #1

user:
Question: {{question}}    <span class="aframe-location"/> #2</pre> 
    <div class="code-annotations-overlay-container">
     #1 Replace with the content LLM should answer the question about.
     <br/>#2 Replace with the question.
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p22"> 
   <p>This exercise shows the simple method of using an LLM to ask questions about a piece of content. Then, the question response is evaluated using a similarity matching score. We can see from the output in listing 10.1 that the LLM does a good job of answering a question about the context. In the next section, we’ll explore a similar technique that uses direct prompting.</p> 
  </div> 
  <div class="readable-text" id="p23"> 
   <h3 class="readable-text-h3" id="sigil_toc_id_138"><span class="num-string">10.1.2</span> Implementing few-shot prompting</h3> 
  </div> 
  <div class="readable-text" id="p24"> 
   <p><em>Few-shot prompting</em> is like question-and-answer prompting, but the makeup of the prompt is more about providing a few examples than about facts or context. This allows the LLM to bend to patterns or content not previously seen. While this approach sounds like question and answer, the implementation is quite different, and the results can be powerful.</p> 
  </div> 
  <div class="callout-container sidebar-container"> 
   <div class="readable-text" id="p25"> 
    <h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Zero-shot, one-shot, and few-shot learning</h5> 
   </div> 
   <div class="readable-text" id="p26"> 
    <p>One holy grail of machine learning and AI is the ability to train a model on as few items as possible. For example, in traditional vision models, millions of images are fed into the model to help identify the differences between a cat and a dog.</p> 
   </div> 
   <div class="readable-text" id="p27"> 
    <p>A <em>one-shot</em> model is a model that requires only a single image to train it. For example, a picture of a cat can be shown, and then the model can identify any cat image. A <em>few-shot</em> model requires only a few things to train the model. And, of course, <em>zero-shot</em> indicates the ability to identify something given no previous examples. LLMs are efficient learners and can do all three types of learning.</p> 
   </div> 
  </div> 
  <div class="readable-text" id="p28"> 
   <p>Open <code>prompt_flow/few-shot-prompting/flow.dag.yaml</code> in VS Code and the visual editor. Most of the flow looks like the one pictured earlier in figure 10.2, and the differences are highlighted in listing 10.3, which shows a YAML pseudocode representation. The main differences between this and the previous flow are the inputs and LLM prompt.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p29"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.3</span> <code>few-shot-prompting</code> flow</h5> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area"><strong>   </strong>Inputs:
       statement  : introduces the context and then asks for output
       expected : the expected answer to the statement
<strong>  </strong> LLM: few_shot (the prompt used to ask the question)
       inputs:statement
       outputs: the prediction/answer to the statement

<strong>   </strong>Embeddings: uses an LLM embedding model to create the embedding 
representation of the text

        Embedding_predicted: embeds the output of the few_shot LLM
        Embedding_expected: embeds the output of the expected answer

   Python: Evaluation (Python code to measure embedding similarity)
        Inputs:
               Embedding_predicted output
               Embedding_expected output
        Outputs: the similarity score between predicted and expected

Outputs:
        statement: -&gt; input.statement
        expected: -&gt; input.expected
        predicted: -&gt; output.few_shot
        evaluation_score: output.evaluation

### Example Output
{
    "evaluation_score": 0.906647282920417,    <span class="aframe-location"/> #1
    "expected": "We ate sunner and watched the setting sun.",
    "predicted": "After a long hike, we sat by the lake 
and enjoyed a peaceful sunner as the sky turned 
brilliant shades of orange and pink.",    <span class="aframe-location"/> #2
    "statement": "A sunner is a meal we eat in Cananda 
at sunset, please use the word in a sentence"    <span class="aframe-location"/> #3
}</pre> 
    <div class="code-annotations-overlay-container">
     #1 Evaluation score represents the similarity between expected and predicted.
     <br/>#2 Uses sunner in a sentence
     <br/>#3 This is a false statement but the intent is to get the LLM to use the word as if it was real.
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p30"> 
   <p>Run the flow by pressing Shift-F5 or clicking the Play/Test button from the visual editor. You should see output like listing 10.3 where the LLM has used the word <em>sunner</em> (a made-up term) correctly in a sentence given the initial statement.</p> 
  </div> 
  <div class="readable-text intended-text" id="p31"> 
   <p>This exercise demonstrates the ability to use a prompt to alter the behavior of the LLM to be contrary to what it has learned. We’re changing what the LLM understands to be accurate. Furthermore, we then use that modified perspective to elicit the use of a made-up word.</p> 
  </div> 
  <div class="readable-text intended-text" id="p32"> 
   <p>Open the <code>few_shot.jinja2</code> prompt in VS Code, shown in listing 10.4. This listing demonstrates setting up a simple persona, that of an eccentric dictionary maker, and then providing examples of words it has defined and used before. The base of the prompt allows for the LLM to extend the examples and produce similar results using other words.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p33"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.4</span> <code>few_shot.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:
You are an eccentric word dictionary maker. You will be asked to 

construct a sentence using the word.
The following are examples that demonstrate how to craft a sentence using 
the word.
A "whatpu" is a small, furry animal native to Tanzania. 
An example of a sentence that uses the word whatpu is:    <span class="aframe-location"/> #1
We were traveling in Africa and we saw these very cute whatpus.
To do a "farduddle" means to jump up and down really fast. An example of a 
sentence that uses the word farduddle is:
I was so excited that I started to farduddle.    <span class="aframe-location"/> #2

Please only return the sentence requested by the user.  <span class="aframe-location"/> #3

user:
{{statement}}   <span class="aframe-location"/> #4</pre> 
    <div class="code-annotations-overlay-container">
     #1 Demonstrates an example defining a made-up word and using it in a sentence
     <br/>#2 Demonstrates another example
     <br/>#3 A rule to prevent the LLM from outputting extra information
     <br/>#4 The input statement defines a new word and asks for the use.
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p34"> 
   <p>You may say we’re forcing the LLM to hallucinate here, but this technique is the basis for modifying behavior. It allows prompts to be constructed to guide an LLM to do everything contrary to what it learned. This foundation of prompting also establishes techniques for other forms of altered behavior. From the ability to alter the perception and background of an LLM, we’ll move on to demonstrate a final example of a direct solution in the next section.</p> 
  </div> 
  <div class="readable-text" id="p35"> 
   <h3 class="readable-text-h3" id="sigil_toc_id_139"><span class="num-string">10.1.3</span> Extracting generalities with zero-shot prompting</h3> 
  </div> 
  <div class="readable-text" id="p36"> 
   <p><em>Zero-shot prompting or learning</em> is the ability to generate a prompt in such a manner that allows the LLM to generalize. This generalization is embedded within the LLM and demonstrated through zero-shot prompting, where no examples are given, but instead a set of guidelines or rules are given to guide the LLM.</p> 
  </div> 
  <div class="readable-text intended-text" id="p37"> 
   <p>Employing this technique is simple and works well to guide the LLM to generate replies given its internal knowledge and no other contexts. It’s a subtle yet powerful technique that applies the knowledge of the LLM to other applications. This technique, combined with other prompting strategies, is proving effective at replacing other language classification models—models that identify the emotion or sentiment in text, for example.</p> 
  </div> 
  <div class="readable-text intended-text" id="p38"> 
   <p>Open <code>prompt_flow/zero-shot-prompting/flow.dag.yaml</code> in the VS Code prompt flow visual editor. This flow is again almost identical to that shown earlier in figure 10.1 but differs slightly in implementation, as shown in listing 10.5.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p39"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.5</span> <code>zero-shot-prompting</code> flow</h5> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area"><strong>   </strong>Inputs:
        statement  : the statement to be classified
        expected : the expected classification of the statement

    LLM: zero_shot (the prompt used to classify)
        inputs: statement
        outputs: the predicted class given the statement

    Embeddings: uses an LLM embedding model to create the embedding 
representation of the text

    Embedding_predicted: embeds the output of the zero_shot LLM
    Embedding_expected: embeds the output of the expected answer

    Python: Evaluation (Python code to measure embedding similarity)
        Inputs:
               Embedding_predicted output
             Embedding_expected output
          Outputs: the similarity score between predicted and expected

   Outputs:
        statement: -&gt; input.statement
        expected: -&gt; input.expected
        predicted: -&gt; output.few_shot
        evaluation_score: output.evaluation

   ### Example Output
{
       "evaluation_score": 1,    <span class="aframe-location"/> #1
       "expected": "neutral",
       "predicted": "neutral",
       "statement": "I think the vacation is okay. "    <span class="aframe-location"/> #2
   }</pre> 
    <div class="code-annotations-overlay-container">
     #1 Shows a perfect evaluation score of 1.0
     <br/>#2 The statement we’re asking the LLM to classify
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p40"> 
   <p>Run the flow by pressing Shift-F5 within the VS Code prompt flow visual editor. You should see output similar to that shown in listing 10.5.</p> 
  </div> 
  <div class="readable-text intended-text" id="p41"> 
   <p>Now open the <code>zero_shot.jinja2</code> prompt as shown in listing 10.6. The prompt is simple and uses no examples to extract the sentiment from the text. What is especially interesting to note is that the prompt doesn’t even mention the phrase sentiment, and the LLM seems to understand the intent.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p42"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.6</span> <code>zero_shot.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:
Classify the text into neutral, negative or positive. 
Return on the result and nothing else.    <span class="aframe-location"/> #1

user:
{{statement}}    <span class="aframe-location"/> #2</pre> 
    <div class="code-annotations-overlay-container">
     #1 Provides essential guidance on performing the classification
     <br/>#2 The statement of text to classify
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p43"> 
   <p>Zero-shot prompt engineering is about using the ability of the LLM to generalize broadly based on its training material. This exercise demonstrates how knowledge within the LLM can be put to work for other tasks. The LLM’s ability to self-contextualize and apply knowledge can extend beyond its training. In the next section, we extend this concept further by looking at how LLMs can reason.</p> 
  </div> 
  <div class="readable-text" id="p44"> 
   <h2 class="readable-text-h2" id="sigil_toc_id_140"><span class="num-string">10.2</span> Reasoning in prompt engineering</h2> 
  </div> 
  <div class="readable-text" id="p45"> 
   <p>LLMs like ChatGPT were developed to function as chat completion models, where text content is fed into the model, whose responses align with completing that request. LLMs were never trained to reason, plan, think, or have thoughts.</p> 
  </div> 
  <div class="readable-text intended-text" id="p46"> 
   <p>However, much like we demonstrated with the examples in the previous section, LLMs can be prompted to extract their generalities and be extended beyond their initial design. While an LLM isn’t designed to reason, the training material fed into the model provides an understanding of reasoning, planning, and thought. Therefore, by extension, an LLM understands what reasoning is and can employ the concept of reasoning.</p> 
  </div> 
  <div class="callout-container sidebar-container"> 
   <div class="readable-text" id="p47"> 
    <h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Reasoning and planning</h5> 
   </div> 
   <div class="readable-text" id="p48"> 
    <p><em>Reasoning</em> is the ability of an intellect, artificial or not, to understand the process of thought or thinking through a problem. An intellect can understand that actions have outcomes, and it can use this ability to reason through which action from a set of actions can be applied to solve a given task.</p> 
   </div> 
   <div class="readable-text" id="p49"> 
    <p><em>Planning</em> is the ability of the intellect to reason out the order of actions or tasks and apply the correct parameters to achieve a goal or outcome—the extent to which an intellectual plan depends on the scope of the problem. An intellect may combine multiple levels of planning, from strategic and tactical to operational and contingent.</p> 
   </div> 
  </div> 
  <div class="readable-text" id="p50"> 
   <p>We’ll look at another set of prompt engineering techniques that allow or mimic reasoning behavior to demonstrate this reasoning ability. Typically, when evaluating the application of reasoning, we look to having the LLM solve challenging problems it wasn’t designed to solve. A good source of such is based on logic, math, and word problems.</p> 
  </div> 
  <div class="readable-text intended-text" id="p51"> 
   <p>Using the time travel theme, what class of unique problems could be better to solve than understanding time travel? Figure 10.3 depicts one example of a uniquely challenging time travel problem. Our goal is to acquire the ability to prompt the LLM in a manner that allows it to solve the problem correctly.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p52">  
   <img alt="figure" src="../Images/10-3.png" width="1012" height="589"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.3</span> The complexity of the time travel problems we intend to solve using LLMs with reasoning and planning</h5>
  </div> 
  <div class="readable-text intended-text" id="p53"> 
   <p>Time travel problems are thought exercises that can be deceptively difficult to solve. The example in figure 10.3 is complicated to solve for <span class="aframe-location"/>an LLM, but the part it gets wrong may surprise you. The next section will use reasoning in prompts to solve these unique problems.</p> 
  </div> 
  <div class="readable-text" id="p54"> 
   <h3 class="readable-text-h3" id="sigil_toc_id_141"><span class="num-string">10.2.1</span> Chain of thought prompting</h3> 
  </div> 
  <div class="readable-text" id="p55"> 
   <p><em>Chain of thought</em> (CoT)prompting is a prompt engineering technique that employs the one-shot or few-shot examples that describe the reasoning and the steps to accomplish a desired goal. Through the demonstration of reasoning, the LLM can generalize this principle and reason through similar problems and goals. While the LLM isn’t trained with the goal of reasoning, we can elicit the model to reason, using prompt engineering.</p> 
  </div> 
  <div class="readable-text intended-text" id="p56"> 
   <p>Open <code>prompt_flow/chain-of-thought-prompting/flow.dag.yaml</code> in the VS Code prompt flow visual editor. The elements of this flow are simple, as shown in figure 10.4. With only two LLM blocks, the flow first uses a CoT prompt to solve a complex question; then, the second LLM prompt evaluates the answer.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p57">  
   <img alt="figure" src="../Images/10-4.png" width="912" height="789"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.4</span> The flow of the CoT</h5>
  </div> 
  <div class="readable-text intended-text" id="p58"> 
   <p>Listing 10.7 shows the YAML pseudocode that describes the blocks and the inputs/outputs of the flow in more detail. The default problem statement in this example isn’t the same as in figure 10.3.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p59"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.7</span> <code>chain-of-thought-prompting</code> flow</h5> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">   Inputs:
        statement  : the statement problem to be solved
        expected : the expected solution to the problem

<strong>  </strong> LLM: cot (the prompt used to solve the problem)
        inputs: statement
        outputs: the predicted answer given the problem statement

<strong>   </strong>LLM: evaluate_answer (the prompt used to evaluate the solution)
        inputs:
               statement: -&gt; input.statement
               expected: -&gt; input.expected
               predicted: -&gt; output.cot

        outputs: a score of how well the problem was answered


   Outputs:
        statement: -&gt; input.statement
        expected: -&gt; input.expected
        predicted: -&gt; output.cot
        evaluation_score: output.evaluate_answer

   ### Example Output
{
    "evaluation_score": "0.5",    <span class="aframe-location"/> #1
    "expected": "After the final jump, Max finds himself 
in the year 1980 and he is 75 years old.",    <span class="aframe-location"/> #2
    "predicted": " Max starts in the year 2300 and 
travels backward in 40-year increments, spending 5 years 
in each period. The journeys will be as follows:
\n\n- From 2300 to 2260: Max is 25 + 5 = 30 years old.
\n- From 2260 to 2220: Max is 30 + 5 = 35 years old.
\n- From 2220 to 2180: Max is 35 + 5 = 40 years old.
\n- From 2180 to 2140: Max is 40 + 5 = 45 years old.
\n- From 2140 to 2100: Max is 45 + 5 = 50 years old.
\n- From 2100 to 2060: Max is 50 + 5 = 55 years old.
\n- From 2060 to 2020: Max is 55 + 5 = 60 years old.
\n- From 2020 to 1980: Max is 60 + 5 = 65 years old.
\n- From 1980 to 1940: Max is 65 + 5 = 70 years old.
\n- From 1940 to 1900: Max is 70 + 5"    <span class="aframe-location"/> #3
}</pre> 
    <div class="code-annotations-overlay-container">
     #1 The evaluated score for the given solution
     <br/>#2 The expected answer for the problem
     <br/>#3 The predicted answer shows the reasoning steps and output.
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p60"> 
   <p>Dig into the inputs and check the problem statement; try to evaluate the problem yourself. Then, run the flow by pressing Shift-F5. You should see output similar to that shown in listing 10.7.</p> 
  </div> 
  <div class="readable-text intended-text" id="p61"> 
   <p>Open the <code>cot.jinja2</code> prompt file as shown in listing 10.8. This prompt gives a few examples of time travel problems and then the thought-out and reasoned solution. The process of showing the LLM the steps to complete the problem provides the reasoning mechanism.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p62"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.8</span> <code>cot.jinja2</code> </h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:
"In a time travel movie, Sarah travels back in time to 
prevent a historic event from happening. She arrives 
2 days before the event. After spending a day preparing, 
she attempts to change the event but realizes she has 
actually arrived 2 years early, not 2 days. She then 
decides to wait and live in the past until the event's 
original date. How many days does Sarah spend in the past 
before the day of the event?"    <span class="aframe-location"/> #1

Chain of Thought:    <span class="aframe-location"/> #2

    Initial Assumption: Sarah thinks she has arrived 2 days before the event.
    Time Spent on Preparation: 1 day spent preparing.
    Realization of Error: Sarah realizes she's actually 2 years early.
    Conversion of Years to Days: 
2 years = 2 × 365 = 730 days (assuming non-leap years).
    Adjust for the Day Spent Preparing: 730 - 1 = 729 days.
    Conclusion: Sarah spends 729 days in the past before the day of the event.

"In a sci-fi film, Alex is a time traveler who decides 
to go back in time to witness a famous historical battle 
that took place 100 years ago, which lasted for 10 days. 
He arrives three days before the battle starts. However, 
after spending six days in the past, he jumps forward in 
time by 50 years and stays there for 20 days. Then, he 
travels back to witness the end of the battle. How many 
days does Alex spend in the past before he sees the end of
 the battle?"    <span class="aframe-location"/> #3

Chain of Thought:    <span class="aframe-location"/> #4

    Initial Travel: Alex arrives three days before the battle starts.
    Time Spent Before Time Jump: Alex spends six days in the past. 
The battle has started and has been going on for 3 days (since he 
arrived 3 days early and has now spent 6 days, 3 + 3 = 6).
    First Time Jump: Alex jumps 50 years forward and stays for 20 days.
 This adds 20 days to the 6 days he's already spent in the past 
(6 + 20 = 26).
    Return to the Battle: When Alex returns, he arrives back on the same 
day he left (as per time travel logic). The battle has been going on for 
3 days now.
    Waiting for the Battle to End: The battle lasts 10 days. Since he's 
already witnessed 3 days of it, he needs to wait for 7 more days.
    Conclusion: Alex spends a total of 3 (initial wait) + 3 (before the 
first jump) + 20 (50 years ago) + 7 (after returning) = 33 days in the 
past before he sees the end of the battle.
Think step by step but only show the final answer to the statement.

user:
{{statement}}    <span class="aframe-location"/> #5</pre> 
    <div class="code-annotations-overlay-container">
     #1 A few example problem statements
     <br/>#2 The solution to the problem statement, output as a sequence of reasoning steps
     <br/>#3 A few example problem statements
     <br/>#4 The solution to the problem statement, output as a sequence of reasoning steps
     <br/>#5 The problem statement the LLM is directed to solve
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p63"> 
   <p>You may note that the solution to figure 10.3 is also provided as an example in listing 10.8. It’s also helpful to go back and review listing 10.7 for the reply from the LLM about the problem. From this, you can see the reasoning steps the LLM applied to get its final answer.</p> 
  </div> 
  <div class="readable-text intended-text" id="p64"> 
   <p>Now, we can look at the prompt that evaluates how well the solution solved the problem. Open <code>evaluate_answer.jinja2</code>, shown in listing 10.9, to review the prompt used. The prompt is simple, uses zero-shot prompting, and allows the LLM to generalize how it should score the expected and predicted. We could provide examples and scores, thus changing this to an example of a few-shot classification.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p65"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.9</span> <code>evaluate_answer.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:

Please confirm that expected and predicted results are 
the same for the given problem.    <span class="aframe-location"/> #1
Return a score from 0 to 1 where 1 is a perfect match and 0 is no match.
Please just return the score and not the explanation.    <span class="aframe-location"/> #2

user:
Problem: {{problem}}    <span class="aframe-location"/> #3

Expected result: {{expected}}    <span class="aframe-location"/> #4

Predicted result: {{predicted}}    <span class="aframe-location"/> #5</pre> 
    <div class="code-annotations-overlay-container">
     #1 The rules for evaluating the solution
     <br/>#2 Direction to only return the score and nothing else
     <br/>#3 The initial problem statement
     <br/>#4 The expected or grounded answer
     <br/>#5 The output from the CoT prompt earlier
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p66"> 
   <p>Looking at the LLM output shown earlier in listing 10.7, you can see why the evaluation step may get confusing. Perhaps a fix to this could be suggesting to the LLM to provide the final answer in a single statement. In the next section, we move on to another example of prompt reasoning.</p> 
  </div> 
  <div class="readable-text" id="p67"> 
   <h3 class="readable-text-h3" id="sigil_toc_id_142"><span class="num-string">10.2.2</span> Zero-shot CoT prompting</h3> 
  </div> 
  <div class="readable-text" id="p68"> 
   <p>As our time travel demonstrates, CoT prompting can be expensive in terms of prompt generation for a specific class of problem. While not as effective, there are techniques similar to CoT that don’t use examples and can be more generalized. This section will examine a straightforward phrase employed to elicit reasoning in LLMs.</p> 
  </div> 
  <div class="readable-text intended-text" id="p69"> 
   <p>Open <code>prompt_flow/zero-shot-cot-prompting/flow.dag.yaml</code> in the VS Code prompt flow visual editor. This flow is very similar to the previous CoT, as shown in figure 10.4. The next lsting shows the YAML pseudocode that describes the flow.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p70"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.10</span> <code>zero-shot-CoT-prompting</code> flow</h5> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">   Inputs:
        statement  : the statement problem to be solved
        expected : the expected solution to the problem

<strong>   </strong>LLM: cot (the prompt used to solve the problem)
        inputs: statement
        outputs: the predicted answer given the problem statement

<strong>   </strong>LLM: evaluate_answer (the prompt used to evaluate the solution)
        inputs:
               statement: -&gt; input.statement
               expected: -&gt; input.expected
               predicted: -&gt; output.cot

         outputs: a score of how well the problem was answered


    Outputs:
        statement: -&gt; input.statement
        expected: -&gt; input.expected
        predicted: -&gt; output.cot
        evaluation_score: output.evaluate_answer

    ### Example Output
   {
       "evaluation_score": "1",    <span class="aframe-location"/> #1
       "expected": "After the final jump, <span class="">↪</span>
          <span class="">↪</span> Max finds himself in the year 1980 and 
   he is 75 years old.",    <span class="aframe-location"/> #2
       "predicted": "Max starts in… <span class="">↪</span>
          <span class="">↪</span> Therefore, after the final jump, <span class="">↪</span>
          <span class="">↪</span> Max is 75 years old and in the year 1980.",    <span class="aframe-location"/> #3
       "statement": "In a complex time travel …"    <span class="aframe-location"/> #4
   }</pre> 
    <div class="code-annotations-overlay-container">
     #1 The final evaluation score
     <br/>#2 The expected answer
     <br/>#3 The predicted answer (the steps have been omitted showing the final answer)
     <br/>#4 The initial problem statement
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p71"> 
   <p>Run/test the flow in VS Code by pressing Shift-F5 while in the visual editor. The flow will run, and you should see output similar to that shown in listing 10.10. This exercise example performs better than the previous example on the same problem.</p> 
  </div> 
  <div class="readable-text intended-text" id="p72"> 
   <p>Open the <code>cot.jinja2</code> prompt in VS Code, as shown in listing 10.11. This is a much simpler prompt than the previous example because it only uses zero-shot. However, one key phrase turns this simple prompt into a powerful reasoning engine. The line in the prompt <code>Let’s</code> <code>think</code> <code>step</code> <code>by</code> <code>step</code> triggers the LLM to consider internal context showing reasoning. This, in turn, directs the LLM to reason out the problem in steps.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p73"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.11</span> <code>cot.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:
You are an expert in solving time travel problems.
You are given a time travel problem and you have to solve it.
Let's think step by step.    <span class="aframe-location"/> #1
Please finalize your answer in a single statement.    <span class="aframe-location"/> #2

user:
{{statement}}    <span class="aframe-location"/> #3</pre> 
    <div class="code-annotations-overlay-container">
     #1 A magic line that formulates reasoning from the LLM
     <br/>#2 Asks the LLM to provide a final statement of the answer
     <br/>#3 The problem statement the LLM is asked to solve
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p74"> 
   <p>Similar phrases asking the LLM to think about the steps or asking it to respond in steps also extract reasoning. We’ll demonstrate a similar but more elaborate technique in the next section.</p> 
  </div> 
  <div class="readable-text" id="p75"> 
   <h3 class="readable-text-h3" id="sigil_toc_id_143"><span class="num-string">10.2.3</span> Step by step with prompt chaining</h3> 
  </div> 
  <div class="readable-text" id="p76"> 
   <p>We can extend the behavior of asking an LLM to think step by step into a chain of prompts that force the LLM to solve the problem in steps. In this section, we look at a technique called <em>prompt chaining</em> that forces an LLM to process problems in steps.</p> 
  </div> 
  <div class="readable-text intended-text" id="p77"> 
   <p>Open the <code>prompt_flow/prompt-chaining/flow.dag.yaml</code> file in the visual editor, as shown in figure 10.5. Prompt chaining breaks up the reasoning method used to solve a problem into chains of prompts. This technique forces the LLM to answer the problem in terms of steps.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p78">  
   <img alt="figure" src="../Images/10-5.png" width="1100" height="958"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.5</span> The prompt chaining flow</h5>
  </div> 
  <div class="readable-text" id="p79"> 
   <p>Listing 10.12 shows the YAML pseudocode that describes the flow in a few more details. This flow chains the output of the first LLM block into the second and then from the second into the third. Forcing the LLM to process the problem this way uncovers the reasoning pattern, but it can also be overly verbose.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p80"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.12</span> <code>prompt-chaining</code> flow</h5> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">   Inputs:
        statement  : the statement problem to be solved

   LLM: decompose_steps (the prompt used to decompose the problem)
        inputs: 
               statement: -&gt; input.statement    <span class="aframe-location"/> #1

        outputs: the breakdown of steps to solve the problem

   LLM: calculate_steps (the prompt used to calculate the steps)
        inputs:
               statement: -&gt; input.statement
               decompose_steps: -&gt; output.decompose_steps    <span class="aframe-location"/> #2

               outputs: the calculation for each step
   LLM: calculate_solution (attempts to solve the problem)
        inputs:
               statement: -&gt; input.statement
               decompose_steps: -&gt; output.decompose_steps
               calculate_steps: -&gt; output.calculate_steps    <span class="aframe-location"/> #3

         outputs: the final solution statement

   Outputs:
        statement: -&gt; input.statement
        decompose_steps: -&gt; output.decompose_steps
        calculate_steps: -&gt; output.calculate_steps
        calculate_solution: -&gt; output.calculate_solution

   ### Example Output
{
    "calculate_steps": "1. The days spent by Alex",
    "decompose_steps": "To figure out the …",
    "solution": "Alex spends 13 days in the <span class="">↪</span>
           <span class="">↪</span> past before the end of the battle.",    <span class="aframe-location"/> #4
    "statement": "In a sci-fi film, Alex …"    
}</pre> 
    <div class="code-annotations-overlay-container">
     #1 Start of the chain of prompts
     <br/>#2 Output from the previous step injected into this step
     <br/>#3 Output from two previous steps injected into this step
     <br/>#4 The final solution statement, although wrong, is closer.
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p81"> 
   <p>Run the flow by pressing Shift-F5 from the visual editor, and you’ll see the output as shown in listing 10.12. The answer is still not correct for the Alex problem, but we can see all the work the LLM is doing to reason out the problem.</p> 
  </div> 
  <div class="readable-text intended-text" id="p82"> 
   <p>Open up all three prompts: <code>decompose_steps.jinja2</code>, <code>calculate_steps.jinja2</code>, and <code>calculate_solution.jinja2</code> (see listings 10.13, 10.14, and 10.15, respectively). All three prompts shown in the listings can be compared to show how outputs chain together.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p83"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.13</span> <code>decompose_steps.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:
You are a problem solving AI assistant.
Your job is to break the users problem down into smaller steps and list 
the steps in the order you would solve them.
Think step by step, not in generalities.
Do not attempt to solve the problem, just list the steps.<span class="aframe-location"/> #1

user:
{{statement}}    <span class="aframe-location"/> #2</pre> 
    <div class="code-annotations-overlay-container">
     #1 Forces the LLM to list only the steps and nothing else
     <br/>#2 The initial problem statement
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="browsable-container listing-container" id="p84"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.14</span> <code>calculate_steps.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:
You are a problem solving AI assistant.
You will be given a list of steps that solve a problem.
Your job is to calculate the output for each of the steps in order.
Do not attempt to solve the whole problem,
just list output for each of the steps.    <span class="aframe-location"/> #1
Think step by step.    <span class="aframe-location"/> #2

user:
{{statement}}

{{steps}}    <span class="aframe-location"/> #3</pre> 
    <div class="code-annotations-overlay-container">
     #1 Requests that the LLM not solve the whole problem, just the steps
     <br/>#2 Uses the magic statement to extract reasoning
     <br/>#3 Injects the steps produced by the decompose_steps step
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="browsable-container listing-container" id="p85"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.15</span> <code>calculate_solution.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:
You are a problem solving AI assistant.
You will be given a list of steps and the calculated output for each step.
Use the calculated output from each step to determine the final 
solution to the problem.
Provide only the final solution to the problem in a 
single concise sentence. Do not include any steps 
in your answer.    <span class="aframe-location"/> #1

user:
{{statement}}

{{steps}}    <span class="aframe-location"/> #2

{{calculated}}    <span class="aframe-location"/> #3</pre> 
    <div class="code-annotations-overlay-container">
     #1 Requests that the LLM output the final answer and not any steps
     <br/>#2 The decomposed steps
     <br/>#3 The calculated steps
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p86"> 
   <p>In this exercise example, we’re not performing any evaluation and scoring. Without the evaluation, we can see that this sequence of prompts still has problems solving our more challenging time travel problem shown earlier in figure 10.3. However, that doesn’t mean this technique doesn’t have value, and this prompting format solves some complex problems well.</p> 
  </div> 
  <div class="readable-text intended-text" id="p87"> 
   <p>What we want to find, however, is a reasoning and planning methodology that can solve such complex problems consistently. The following section moves from reasoning to evaluating the best solution.</p> 
  </div> 
  <div class="readable-text" id="p88"> 
   <h2 class="readable-text-h2" id="sigil_toc_id_144"><span class="num-string">10.3</span> Employing evaluation for consistent solutions</h2> 
  </div> 
  <div class="readable-text" id="p89"> 
   <p>In the previous section, we learned that even the best-reasoned plans may not always derive the correct solution. Furthermore, we may not always have the answer to confirm if that solution is correct. The reality is that we often want to use some form of evaluation to determine the efficacy of a solution.</p> 
  </div> 
  <div class="readable-text intended-text" id="p90"> 
   <p>Figure 10.6 shows a comparison of the prompt engineering strategies that have been devised as a means of getting LLMs to reason and plan. We’ve already covered the two on the left: zero-shot direct prompting and CoT prompting. The following example exercises in this section will look at self-consistency with the CoT and ToT techniques.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p91">  
   <img alt="figure" src="../Images/10-6.png" width="1012" height="474"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.6</span> Comparing the various prompt engineering strategies to enable reasoning and planning from LLMs</h5>
  </div> 
  <div class="readable-text intended-text" id="p92"> 
   <p>We’ll continue to focus on the complex time travel problem to compare these more advanced methods that expand on reasoning and planning with evaluation. In the next section, we’ll evaluate self-consistency.</p> 
  </div> 
  <div class="readable-text" id="p93"> 
   <h3 class="readable-text-h3" id="sigil_toc_id_145"><span class="num-string">10.3.1</span> Evaluating self-consistency prompting</h3> 
  </div> 
  <div class="readable-text" id="p94"> 
   <p>Consistency in prompting is more than just lowering the temperature parameter we send to an LLM. Often, we want to generate a consistent plan or solution and still use a high temperature to better evaluate all the variations to a plan. By evaluating multiple different plans, we can get a better sense of the overall value of a solution.</p> 
  </div> 
  <div class="readable-text intended-text" id="p95"> 
   <p><em>Self-consistent prompting</em> is the technique of generating multiple plans/solutions for a given problem. Then, those plans are evaluated, and the more frequent or consistent plan is accepted. Imagine three plans generated, where two are similar, but the third is different. Using self-consistency, we evaluate the first two plans as the more consistent answer.</p> 
  </div> 
  <div class="readable-text intended-text" id="p96"> 
   <p>Open <code>prompt_flow/self-consistency-prompting/flow.dag.yaml</code> in the VS Code prompt flow visual editor. The flow diagram shows the simplicity of the prompt generation flow in figure 10.7. Next to it in the diagram is the self-consistency evaluation flow.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p97">  
   <img alt="figure" src="../Images/10-7.png" width="1009" height="729"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.7</span> The self-consistency prompt generation beside the evaluation flow</h5>
  </div> 
  <div class="readable-text intended-text" id="p98"> 
   <p>Prompt flow uses a direct acyclic graph (DAG) format to execute the flow logic. DAGs are an excellent way of demonstrating and executing flow logic, but because they are <em>acyclic,</em> meaning they can’t repeat, they can’t execute loops. However, because prompt flow provides a batch processing mechanism, we can use that to simulate loops or repetition in a flow.</p> 
  </div> 
  <div class="readable-text intended-text" id="p99"> 
   <p>Referring to figure 10.6, we can see that self-consistency processes the input three times before collecting the results and determining the best plan/reply. We can apply this same pattern but use batch processing to generate the outputs. Then, the evaluation flow will aggregate the results and determine the best answer.</p> 
  </div> 
  <div class="readable-text intended-text" id="p100"> 
   <p>Open the <code>self-consistency-prompting/cot.jinja2</code> prompt template in VS Code (see listing 10.16). The listing was shortened, as we’ve seen parts before. This prompt uses two (few-shot prompt) examples of a CoT to demonstrate the thought reasoning to the LLM.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p101"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.16</span> <code>self-consistency-prompting/cot.jinja2</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">system:

"In a time travel movie, Sarah travels back… "    <span class="aframe-location"/> #1

Chain of Thought:

    Initial Assumption: …    <span class="aframe-location"/> #2
    Conclusion: Sarah spends 729 days in the past before the day of the event.

"In a complex time travel movie plot, Max, a 25 year old…"    <span class="aframe-location"/> #3

Chain of Thought:
    Starting Point: Max starts …    <span class="aframe-location"/> #4
    Conclusion: After the final jump, 
Max finds himself in the year 1980 and he is 75 years old.
Think step by step,
 but only show the final answer to the statement.    <span class="aframe-location"/> #5

user:
{{statement}}</pre> 
    <div class="code-annotations-overlay-container">
     #1 The Sarah time travel problem
     <br/>#2 Sample CoT, cut for brevity
     <br/>#3 The Max time travel problem
     <br/>#4 Sample CoT, cut for brevity
     <br/>#5 Final guide and statement to constrain output
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p102"> 
   <p>Open the <code>self-consistency-prompting/flow.dag.yaml</code> file in VS Code. Run the example in batch mode by clicking Batch Run (the beaker icon) from the visual editor. Figure 10.8 shows the process step by step: </p> 
  </div> 
  <ol> 
   <li class="readable-text" id="p103"> Click Batch Run. </li> 
   <li class="readable-text" id="p104"> Select the JSON Lines (JSONL) input. </li> 
   <li class="readable-text" id="p105"> Select <code>statements.jsonl</code>. </li> 
   <li class="readable-text" id="p106"> Click the Run link.<span class="aframe-location"/> </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p107">  
   <img alt="figure" src="../Images/10-8.png" width="927" height="774"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.8</span> The step-by-step process of launching a batch process</h5>
  </div> 
  <div class="readable-text print-book-callout" id="p108"> 
   <p><span class="print-book-callout-head">TIP</span>  If you need to review the process, refer to chapter 9, which covers this process in more detail.</p> 
  </div> 
  <div class="readable-text" id="p109"> 
   <p>Listing 10.17 shows the JSON output from executing the flow in batch mode. The <code>statements.jsonl</code> file has five identical Alex time travel problem entries. Using identical entries allows us to simulate the prompt executing five times on the duplicate entry.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p110"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.17</span> <code>self-consistency-prompting</code> batch execution output</h5> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">{
    "name": "self-consistency-prompting_default_20240203_100322_912000",
    "created_on": "2024-02-03T10:22:30.028558",
    "status": "Completed",
    "display_name": "self-consistency-prompting_variant_0_202402031022",
    "description": null,
    "tags": null,
    "properties": {
        "flow_path": "…prompt_flow/self-consistency-prompting",    <span class="aframe-location"/> #1
        <strong>"output_path"</strong>: "…/.promptflow/.runs/self-
<span class="">↪</span> consistency-prompting_default_20240203_100322_912000",    <span class="aframe-location"/> #2
        "system_metrics": {
            "total_tokens": 4649,
            "prompt_tokens": 3635,
            "completion_tokens": 1014,
            "duration": 30.033773
        }
    },
    "flow_name": "self-consistency-prompting",
    "data": "…/prompt_flow/self-consistency-prompting/
<span class="">↪</span> statements.jsonl",    <span class="aframe-location"/> #3
    "output": "…/.promptflow/.runs/self-consistency-<span class="">↪</span>
<span class="">↪</span> prompting_default_20240203_100322_912000/flow_outputs"
}</pre> 
    <div class="code-annotations-overlay-container">
     #1 The path where the flow was executed from
     <br/>#2 The folder containing the outputs of the flow (note this path)
     <br/>#3 The data used to run the flow in batch
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p111"> 
   <p>You can view the flow produced by pressing the Ctrl key and clicking the output link, highlighted in listing 10.17. This will open another instance of VS Code, showing a folder with all the output from the run. We now want to check the most consistent answer. Fortunately, the evaluation feature in prompt flow can help us identify consistent answers using similarity matching.</p> 
  </div> 
  <div class="readable-text intended-text" id="p112"> 
   <p>Open <code>self-consistency-evaluation/flow.dag.yaml</code> in VS Code (see figure 10.7). This flow embeds the predicted answer and then uses an aggregation to determine the most consistent answer.</p> 
  </div> 
  <div class="readable-text intended-text" id="p113"> 
   <p>From the flow, open <code>consistency.py</code> in VS Code, as shown in listing 10.18. The code for this tool function calculates the cosine similarity for all pairs of answers. Then, it finds the most similar answer, logs it, and outputs that as the answer.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p114"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.18</span> <code>consistency.py</code></h5> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">from promptflow import tool
from typing import List
import numpy as np
from scipy.spatial.distance import cosine
@tool
def consistency(texts: List[str],
                embeddings: List[List[float]]) -&gt; str:
    if len(embeddings) != len(texts):
        raise ValueError("The number of embeddings <span class="">↪</span>
       <span class="">↪</span> must match the number of texts.")

    mean_embedding = np.mean(embeddings, axis=0)    <span class="aframe-location"/> #1
    similarities = [1 - cosine(embedding, mean_embedding) <span class="">↪</span>
                <span class="">↪</span> for embedding in embeddings]    <span class="aframe-location"/> #2
    most_similar_index = np.argmax(similarities)    <span class="aframe-location"/> #3

    from promptflow import log_metric
    log_metric(key="highest_ranked_output", value=texts[most_similar_index])    <span class="aframe-location"/> #4

    return texts[most_similar_index]    <span class="aframe-location"/> #5</pre> 
    <div class="code-annotations-overlay-container">
     #1 Calculates the mean of all the embeddings
     <br/>#2 Calculates cosine similarity for each pair of embeddings
     <br/>#3 Finds the index of the most similar answer
     <br/>#4 Logs the output as a metric
     <br/>#5 Returns the text for the most similar answer
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p115"> 
   <p>We need to run the evaluation flow in batch mode as well. Open <code>self-consistency-evaluation/flow.dag.yaml</code> in VS Code and run the flow in batch mode (beaker icon). Then, select Existing Run as the flow input, and when prompted, choose the top or the last run you just executed as input.</p> 
  </div> 
  <div class="readable-text intended-text" id="p116"> 
   <p>Again, after the flow completes processing, you’ll see an output like that shown in listing 10.17. Ctrl-click on the output folder link to open a new instance of VS Code showing the results. Locate and open the <code>metric.json</code> file in VS Code, as shown in figure 10.9.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p117">  
   <img alt="figure" src="../Images/10-9.png" width="1012" height="682"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.9</span> The VS Code is open to the batch run output folder. Highlighted are the <code>metrics.json</code> file and the output showing the most similar answer.</h5>
  </div> 
  <div class="readable-text intended-text" id="p118"> 
   <p>The answer shown in figure 10.9 is still incorrect for this run. You can continue a few more batch runs of the prompt and/or increase the number of runs in a batch and then evaluate flows to see if you get better answers. This technique is generally more helpful for more straightforward problems but still demonstrates an inability to reason out complex problems.</p> 
  </div> 
  <div class="readable-text intended-text" id="p119"> 
   <p>Self-consistency uses a reflective approach to evaluate the most likely thought. However, the most likely thing is certainly not always the best. Therefore, we must consider a more comprehensive approach in the next section.</p> 
  </div> 
  <div class="readable-text" id="p120"> 
   <h3 class="readable-text-h3" id="sigil_toc_id_146"><span class="num-string">10.3.2</span> Evaluating tree of thought prompting</h3> 
  </div> 
  <div class="readable-text" id="p121"> 
   <p>As mentioned earlier, ToT prompting, as shown in figure 10.6, combines self-evaluation and prompt chaining techniques. As such, it breaks down the sequence of planning into a chain of prompts, but at each step in the chain, it provides for multiple evaluations. This creates a tree that can be executed and evaluated at each level, breadth-first, or from top to bottom, depth-first.</p> 
  </div> 
  <div class="readable-text intended-text" id="p122"> 
   <p>Figure 10.10 shows the difference between executing a tree using breadth-first or depth-first. Unfortunately, due to the DAG execution pattern of prompt flow, we can’t quickly implement the depth-first method, but breadth-first works just fine.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p123">  
   <img alt="figure" src="../Images/10-10.png" width="1100" height="699"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.10</span> Breadth-first vs. depth-first execution on a ToT pattern</h5>
  </div> 
  <div class="readable-text" id="p124"> 
   <p>Open <code>tree-of-thought-evaluation/flow.dag.yaml</code> in VS Code. The visual of the flow is shown in figure 10.11. This flow functions like a breadth-first ToT pattern—the flow chains together a series of prompts asking the LLM to return multiple plans at each step.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p125">  
   <img alt="figure" src="../Images/10-11.png" width="1012" height="659"/> 
   <h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.11</span> ToT pattern expressed and prompt flow</h5>
  </div> 
  <div class="readable-text" id="p126"> 
   <p>Because the flow executes in a breadth-first style, each level output of the nodes is also evaluated. Each node in the flow uses a pair of semantic functions—one to generate the answer and the other to evaluate the answer. The semantic function is a custom Python flow block that processes multiple inputs and generates multiple outputs.</p> 
  </div> 
  <div class="readable-text intended-text" id="p127"> 
   <p>Listing 10.19 shows the <code>semantic_function.py</code> tool. This general tool is reused for multiple blocks in this flow. It also demonstrates the embedding functionality from the SK for direct use within prompt flow.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p128"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.19</span> <code>semantic_function.py</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">@tool
def my_python_tool(
    input: str,
    input_node: int,
    history: str,
    semantic_function: str,
    evaluation_function: str,
    function_name: str,
    skill_name: str,
    max_tokens: int,
    temperature: float,
    deployment_name: str,
    connection: Union[OpenAIConnection, 
                      AzureOpenAIConnection],    <span class="aframe-location"/> #1
) -&gt; str:
    if input is None or input == "":    <span class="aframe-location"/> #2
        return ""

    kernel = sk.Kernel(log=sk.NullLogger())
    # code for setting up the kernel and LLM connection omitted


    function = kernel.create_semantic_function(
                             semantic_function,                                               
                             function_name=function_name,
                             skill_name=skill_name,
                             max_tokens=max_tokens,
                             temperature=temperature,
                             top_p=0.5)    <span class="aframe-location"/> #3
    evaluation = kernel.create_semantic_function(
                             evaluation_function,        
                             function_name="Evaluation",
                             skill_name=skill_name,
                             max_tokens=max_tokens,
                             temperature=temperature,
                             top_p=0.5)    <span class="aframe-location"/> #4

    async def main():
        query = f"{history}\n{input}"
        try:
            eval = int((await evaluation.invoke_async(query)).result)
            if eval &gt; 25:    <span class="aframe-location"/> #5
                return await function.invoke_async(query)   <span class="aframe-location"/> #6
        except Exception as e:
            raise Exception("Evaluation failed", e)

       try:
        result = asyncio.run(main()).result
        return result
    except Exception as e:
        print(e)
        return ""</pre> 
    <div class="code-annotations-overlay-container">
     #1 Uses a union to allow for different types of LLM connections
     <br/>#2 Checks to see if the input is empty or None; if so, the function shouldn’t be executed.
     <br/>#3 Sets up the generation function that creates a plan
     <br/>#4 Sets up the evaluation function
     <br/>#5 Runs the evaluate function and determines if the input is good enough to continue
     <br/>#6 If the evaluation score is high enough, generates the next step
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p129"> 
   <p>The semantic function tool is used in the tree’s experts, nodes, and answer blocks. At each step, the function determines if any text is being input. If there is no text, the block returns with no execution. Passing no text to a block means that the previous block failed evaluation. By evaluating before each step, ToT short-circuits the execution of plans it deems as not being valid.</p> 
  </div> 
  <div class="readable-text intended-text" id="p130"> 
   <p>This may be a complex pattern to grasp at first, so go ahead and run the flow in VS Code. Listing 10.20 shows just the answer node output of a run; these results may vary from what you see but should be similar. Nodes that return no text either failed evaluation or their parents did.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p131"> 
   <h5 class="listing-container-h5 browsable-container-h5 sigil_not_in_toc"><span class="num-string">Listing 10.20</span> Output from <code>tree-of-thought-evaluation</code> flow</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">{
    "answer_1_1": "",    <span class="aframe-location"/> #1
    "answer_1_2": "",
    "answer_1_3": "",
    "answer_2_1": "Alex spends a total of 29 days in the past before he 
sees the end of the battle.",
    "answer_2_2": "",    <span class="aframe-location"/> #2
    "answer_2_3": "Alex spends a total of 29 days in the past before he 
sees the end of the battle.",
    "answer_3_1": "",    <span class="aframe-location"/> #3
    "answer_3_2": "Alex spends a total of 29 days in the past before he 
sees the end of the battle.",
    "answer_3_3": "Alex spends a total of 9 days in the past before he 
sees the end of the battle.",</pre> 
    <div class="code-annotations-overlay-container">
     #1 Represents that the first node plans weren’t valid and not executed
     <br/>#2 The plan for node 2 and answer 2 failed evaluation and wasn’t run.
     <br/>#3 The plan for this node failed to evaluate and wasn’t run.
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p132"> 
   <p>The output in listing 10.20 shows how only a select set of nodes was evaluated. In most cases, the evaluated nodes returned an answer that could be valid. Where no output was produced, it means that the node itself or its parent wasn’t valid. When sibling nodes all return empty, the parent node fails to evaluate.</p> 
  </div> 
  <div class="readable-text intended-text" id="p133"> 
   <p>As we can see, ToT is valid for complex problems but perhaps not very practical. The execution of this flow can take up to 27 calls to an LLM to generate an output. In practice, it may only do half that many calls, but that’s still a dozen or more calls to answer a single problem.</p> 
  </div> 
  <div class="readable-text" id="p134"> 
   <h2 class="readable-text-h2" id="sigil_toc_id_147"><span class="num-string">10.4</span> Exercises</h2> 
  </div> 
  <div class="readable-text" id="p135"> 
   <p>Use the following exercises to improve your knowledge of the material:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p136"> <em>Exercise 1</em>—Create Direct Prompting, Few-Shot Prompting, and Zero-Shot Prompting </li> 
  </ul> 
  <div class="readable-text list-body-item" id="p137"> 
   <p><em>Objective </em>—Create three different prompts for an LLM to summarize a recent scientific article: one using direct prompting, one with few-shot prompting, and the last employing zero-shot prompting. </p> 
  </div> 
  <div class="readable-text list-body-item" id="p138"> 
   <p><em>Tasks:</em></p> 
  </div> 
  <ul> 
   <li class=" buletless-item" style="list-style-type: none;"> 
    <ul> 
     <li class="readable-text" id="p139"> Compare the effectiveness of the summaries generated by each approach. </li> 
     <li class="readable-text" id="p140"> Compare the accuracy of the summaries generated by each approach. </li> 
    </ul></li> 
   <li class="readable-text" id="p141"> <em>Exercise 2</em>—Craft Reasoning Prompts </li> 
  </ul> 
  <div class="readable-text list-body-item" id="p142"> 
   <p><em>Objective </em>—Design a set of prompts that require the LLM to solve logical puzzles or riddles.</p> 
  </div> 
  <div class="readable-text list-body-item" id="p143"> 
   <p><em>Tasks:</em></p> 
  </div> 
  <ul> 
   <li class=" buletless-item" style="list-style-type: none;"> 
    <ul> 
     <li class="readable-text" id="p144"> Focus on how the structure of your prompt can influence the LLM’s reasoning process. </li> 
     <li class="readable-text" id="p145"> Focus on how the same can influence the correctness of its answers. </li> 
    </ul></li> 
   <li class="readable-text" id="p146"> <em>Exercise 3</em>—Evaluation Prompt Techniques </li> 
  </ul> 
  <div class="readable-text list-body-item" id="p147"> 
   <p><em>Objective </em>—Develop an evaluation prompt that asks the LLM to predict the outcome of a hypothetical experiment.</p> 
  </div> 
  <div class="readable-text list-body-item" id="p148"> 
   <p><em>Task:</em></p> 
  </div> 
  <ul> 
   <li class=" buletless-item" style="list-style-type: none;"> 
    <ul> 
     <li class="readable-text" id="p149"> Create a follow-up prompt that evaluates the LLM’s prediction for accuracy and provides feedback on its reasoning process. </li> 
    </ul></li> 
  </ul> 
  <div class="readable-text" id="p150"> 
   <h2 class="readable-text-h2" id="sigil_toc_id_148">Summary</h2> 
  </div> 
  <ul> 
   <li class="readable-text" id="p151"> Direct solution prompting is a foundational method of using prompts to direct LLMs toward solving specific problems or tasks, emphasizing the importance of clear question-and-answer structures. </li> 
   <li class="readable-text" id="p152"> Few-shot prompting provides LLMs with a few examples to guide them in handling new or unseen content, highlighting its power in enabling the model to adapt to unfamiliar patterns. </li> 
   <li class="readable-text" id="p153"> Zero-shot learning and prompting demonstrate how LLMs can generalize from their training to solve problems without needing explicit examples, showcasing their inherent ability to understand and apply knowledge in new contexts. </li> 
   <li class="readable-text" id="p154"> Chain of thought prompting guides the LLMs through a reasoning process step by step to solve complex problems, illustrating how to elicit detailed reasoning from the model. </li> 
   <li class="readable-text" id="p155"> Prompt chaining breaks down a problem into a series of prompts that build upon each other, showing how to structure complex problem-solving processes into manageable steps for LLMs. </li> 
   <li class="readable-text" id="p156"> Self-consistency is a prompt technique that generates multiple solutions to a problem and selects the most consistent answer through evaluation, emphasizing the importance of consistency in achieving reliable outcomes. </li> 
   <li class="readable-text" id="p157"> Tree of thought prompting combines self-evaluation and prompt chaining to create a comprehensive strategy for tackling complex problems, allowing for a systematic exploration of multiple solution paths. </li> 
   <li class="readable-text" id="p158"> Advanced prompt engineering strategies provide insights into sophisticated techniques such as self-consistency with CoT and ToT, offering methods to increase the accuracy and reliability of LLM-generated solutions.<span class=" link-like"/> </li> 
  </ul>
 </div></div></body></html>