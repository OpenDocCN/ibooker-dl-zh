- en: Chapter 4\. Image Tensors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 图像张量
- en: “But he who dares not grasp the thorn
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “但是那些不敢抓住荆棘的人
- en: Should never crave the rose.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 永远不应该渴望玫瑰。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Anne Brontë
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — 安妮·勃朗特
- en: In the previous chapter, you created and destroyed simple tensors. However,
    our data was minuscule. As you might guess, printing tensors can take you only
    so far and in so many dimensions. You’re going to need to learn how to deal with
    large tensors, which are more common. This is, of course, true in the world of
    images! This is an exciting chapter because you’ll start working with real data,
    and we’ll be able to see the effects of your tensor operations immediately.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建并销毁了简单的张量。然而，我们的数据很小。正如你可能猜到的，打印张量只能带你走到这么远，而且在这么多维度上。你需要学会如何处理更常见的大张量。当然，在图像世界中这是真实的！这是一个令人兴奋的章节，因为你将开始处理真实数据，我们将能够立即看到你的张量操作的效果。
- en: We’ll also get to utilize some existing best practices. As you recall, in the
    previous chapter, you converted a tic-tac-toe game to tensors. During this exercise
    with a simple 3 x 3 grid, you identified one method for converting a game’s state,
    but another person might have come up with a completely different strategy. We’ll
    need to identify some common practices and tricks of the trade, so you don’t have
    to reinvent the wheel every time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将利用一些现有的最佳实践。正如你回忆的，在上一章中，你将一个井字棋游戏转换为张量。在这个简单的3 x 3网格的练习中，你确定了一种转换游戏状态的方法，但另一个人可能会想出完全不同的策略。我们需要确定一些常见的做法和行业诀窍，这样你就不必每次都重新发明轮子。
- en: 'We will:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将：
- en: Identify what makes a tensor an image tensor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别张量是什么使其成为图像张量
- en: Build some images by hand
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动构建一些图像
- en: Use fill methods to create large tensors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用填充方法创建大张量
- en: Convert existing images to tensors and back
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有图像转换为张量，然后再转换回来
- en: Manipulate image tensors in useful ways
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以有用的方式操作图像张量
- en: When you finish this chapter, you’ll be confident in managing real-world image
    data, and a lot of this knowledge will apply to managing tensors in general.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成本章时，你将能够自信地处理真实世界的图像数据，而这些知识很多都适用于一般张量的管理。
- en: Visual Tensors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉张量
- en: You might assume that when an image is converted into a tensor, that resulting
    tensor will be rank two. If you’ve forgotten what a rank-two tensor looks like,
    review [Chapter 3](ch03.html#the_chapter_3). It’s easy to picture a 2D image as
    a 2D tensor, except that pixel color generally can’t be stored as a single number.
    A rank-two tensor works only with grayscale images. The most common practice for
    a colored pixel is to represent it as three separate values. Those who were raised
    with paints were taught to use red, yellow, and blue, but us nerds prefer the
    red, green, blue (RGB) system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会假设当图像转换为张量时，得到的张量将是二阶的。如果你忘记了二阶张量是什么样子，请查看[第3章](ch03.html#the_chapter_3)。很容易将一个2D图像想象成一个2D张量，只是像素颜色通常不能存储为单个数字。二阶张量仅适用于灰度图像。彩色像素的最常见做法是将其表示为三个独立的值。那些从小就接触颜料的人被教导使用红色、黄色和蓝色，但我们这些书呆子更喜欢红色、绿色、蓝色（RGB）系统。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The RGB system is another instance of art imitating life. The human eye uses
    RGB, which is based on an “additive” color system—a system of emitting light,
    like computer screens do. Your art teacher probably used yellow over green to
    help lighten up paints that darken as you add more in a “subtractive” color system,
    like paint on paper.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RGB系统是艺术模仿生活的另一个例子。人眼使用RGB，这是基于“加法”颜色系统——一种发射光的系统，就像计算机屏幕一样。你的美术老师可能用黄色覆盖绿色来帮助淡化随着添加更多而变暗的颜料的颜色，这是一种“减法”颜色系统，就像纸上的颜料一样。
- en: A pixel is commonly colored by the ordered amounts of red, green, and blue within
    the confines of a singular byte. This `0-255` array of values looks like `[255,
    255, 255]` for integers and like `#FFFFFF` for most websites seeking a hexadecimal
    version of the same three values. When our tensor is the data type `int32`, this
    is the interpretation method that is used. When our tensor is `float32`, the values
    are assumed to be in the range `0-1`. So, an integer `[255, 255, 255]` represents
    pure white, but in float form the equivalent would be `[1, 1, 1]`. This also means
    `[1, 1, 1]` is pure white in a `float32` tensor and interpreted as next to black
    in an `int32` tensor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个像素通常是由红色、绿色和蓝色的有序量来着色，这些量在一个字节内。这个`0-255`值数组看起来像`[255, 255, 255]`对于整数，对于大多数寻求相同三个值的十六进制版本的网站来说，看起来像`#FFFFFF`。当我们的张量是数据类型`int32`时，这是使用的解释方法。当我们的张量是`float32`时，假定值在`0-1`范围内。因此，一个整数`[255,
    255, 255]`代表纯白，但在浮点形式中等价的是`[1, 1, 1]`。这也意味着`[1, 1, 1]`在`float32`张量中是纯白的，并且在`int32`张量中被解释为接近黑色。
- en: Depending on the tensor data type, you get two color extremes from a pixel encoded
    as `[1, 1, 1]`, as shown in [Figure 4-1](#color111).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据张量数据类型的不同，从一个像素编码为`[1, 1, 1]`，你会得到两种颜色极端，如[图4-1](#color111)所示。
- en: '![Color depends on tensor type](assets/ltjs_0401.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![颜色取决于张量类型](assets/ltjs_0401.png)'
- en: Figure 4-1\. Significant color difference from the same data
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1。相同数据的显著颜色差异
- en: This means to store images you’ll need a 3D tensor. You’ll need each three-value
    pixel stored at given width and height. Just as you saw in the tic-tac-toe problem,
    you’ll have to identify what’s the best format to do so. In TensorFlow and TensorFlow.js,
    it’s common practice to store the RGB values in the final dimension of a tensor.
    It’s also customary to store the values across height, then width, and then color
    dimension. This might seem odd for images, but referencing rows and then columns
    is the classic organizational reference order of matrices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要存储图像，你将需要一个三维张量。你需要将每个三值像素存储在给定的宽度和高度上。就像你在井字棋问题中看到的那样，你将不得不确定最佳的格式来做到这一点。在TensorFlow和TensorFlow.js中，将RGB值存储在张量的最后一个维度是一种常见做法。也习惯性地将值沿着高度、宽度，然后颜色维度进行存储。这对于图像来说可能看起来有点奇怪，但引用行然后列是矩阵的经典组织参考顺序。
- en: Warning
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Most of the world will mention an image size as width by height. A 1024 x 768
    image is `1024px` wide and `768px` high, but as we just stated, TensorFlow image
    tensors store height first, which can be a little confusing. That same image would
    be a `[768, 1024, 3]` tensor. This often confuses developers who are new to visual
    tensors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人会按照宽度乘以高度来提及图像尺寸。一个1024 x 768的图像宽度为`1024px`，高度为`768px`，但正如我们刚刚所述，TensorFlow图像张量首先存储高度，这可能有点令人困惑。同样的图像将是一个`[768,
    1024, 3]`张量。这经常会让对视觉张量新手的开发人员感到困惑。
- en: So if you wanted to make a 4 x 3 checkerboard of pixels, you could create that
    image by hand with a 3D array with the shape `[3, 4, 3]`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想要制作一个4 x 3的像素棋盘，你可以手动创建一个形状为`[3, 4, 3]`的3D数组。
- en: 'The code would be as simple as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将会是以下简单的形式：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A 4 x 3 pixel image would be pretty small, but if we zoomed in a few hundred
    times, we would be able to see the pixels we just created. The resulting image
    would look like [Figure 4-2](#fourbythreechecker).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个4 x 3像素的图像可能会很小，但如果我们放大几百倍，我们将能够看到我们刚刚创建的像素。生成的图像看起来会像[图4-2](#fourbythreechecker)。
- en: '![A simple 4 x 3 image](assets/ltjs_0402.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的4 x 3图像](assets/ltjs_0402.png)'
- en: Figure 4-2\. The checkered 4 x 3 TensorFlow.js image
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-2。4 x 3的TensorFlow.js棋盘图像
- en: You’re not limited to RGB, as you might have expected; adding a fourth value
    to the RGB dimension of a tensor will add an alpha channel. Much like in web color,
    `#FFFFFF00` would be white at zero opacity, and a tensor pixel with a red, green,
    blue, alpha (RGBA) value of `[1, 1, 1, 0]` would be similarly transparent. A 1024
    x 768 image with transparency would be stored in a tensor with the shape `[768,
    1024, 4]`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于RGB，正如你可能期望的那样；在张量的RGB维度中添加第四个值将添加一个alpha通道。就像在Web颜色中一样，`#FFFFFF00`将是白色的零不透明度，具有红色、绿色、蓝色、alpha（RGBA）值为`[1,
    1, 1, 0]`的张量像素也将是类似透明的。一个带有透明度的1024 x 768图像将存储在一个形状为`[768, 1024, 4]`的张量中。
- en: As a corollary to the two aforementioned systems, if the final channel has only
    one value instead of three or four, the resulting image would be grayscale.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前述两个系统的推论，如果最终通道只有一个值而不是三个或四个，生成的图像将是灰度的。
- en: 'Our black-and-white checkered pattern example from earlier could be significantly
    condensed using that last bit of knowledge. Now we can build the same image but
    with the tensor, with code like so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的黑白棋盘图案示例可以通过使用最后的知识大大简化。现在我们可以用张量构建相同的图像，代码如下：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And yes, if you simply remove those inner brackets and move this to a simple
    2D tensor, that will work, too!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，如果你简单地去掉那些内部括号并将其移动到一个简单的2D张量中，那也是可以的！
- en: Quick Image Tensors
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速图像张量
- en: I know there’s a line of people beating down your door to hand-draw images,
    pixel by pixel, so you might be surprised to learn some people find writing little
    1s and 0s tedious. Of course, you could create arrays using `Array.prototype.fill`
    and then use that to fill arrays to create sizable 3D tensor constructors, but
    it’s worth noting that TensorFlow.js comes with that functionality built in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道有一大群人在你的门口排队逐个像素地手绘图像，所以你可能会惊讶地发现有些人觉得写一些小的1和0很烦人。当然，你可以使用`Array.prototype.fill`创建数组，然后使用它来填充数组以创建可观的3D张量构造器，但值得注意的是，TensorFlow.js已经内置了这个功能。
- en: It’s a common need to create large tensors with already populated values. In
    fact, if you were to continue working on our recommendation system from [Chapter 3](ch03.html#the_chapter_3),
    you would need to utilize these exact features.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有预填充值的大张量是一个常见的需求。实际上，如果你继续从[第3章](ch03.html#the_chapter_3)的推荐系统中工作，你将需要利用这些确切的功能。
- en: As it is now, you can use the methods `tf.ones`, `tf.zeros`, and `tf.fill` to
    create large tensors by hand. Both `tf.ones` and `tf.zeros` take a shape as a
    parameter, and then they construct that shape with every value equal to `1` or
    `0`, respectively. So, the code `tf.zeros([768, 1024, 1])` would create a 1024
    x 768 black image. The optional second parameter would be the data type for the
    generated tensor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`tf.ones`、`tf.zeros`和`tf.fill`方法手动创建大张量。`tf.ones`和`tf.zeros`都接受一个形状作为参数，然后构造该形状，每个值都等于`1`或`0`。因此，代码`tf.zeros([768,
    1024, 1])`将创建一个1024 x 768的黑色图像。可选的第二个参数将是生成的张量的数据类型。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Often, you can run an empty image made with `tf.zeros` through a model to preallocate
    memory. The result is immediately thrown away, and subsequent calls are much faster.
    This is often called *model warming*, and it’s a speedup trick you might see when
    developers are looking for things to allocate while waiting for a webcam or network
    data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过使用`tf.zeros`创建一个空图像，通过模型预先分配内存。结果会立即被丢弃，后续调用会快得多。这通常被称为*模型预热*，当开发人员在等待网络摄像头或网络数据时寻找要分配的内容时，你可能会看到这种加速技巧。
- en: As you might imagine, `tf.fill` takes a shape, and then the second parameter
    is the value to fill that shape with. You might be tempted to pass a tensor as
    the second parameter, essentially raising the rank of the resulting generated
    tensor, but it’s important to note that this will not work. For a juxtaposition
    of what does and doesn’t work, see [Table 4-1](#fill_fails_table).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，`tf.fill`接受一个形状，然后第二个参数是用来填充该形状的值。你可能会想要将一个张量作为第二个参数传递，从而提高生成的张量的秩，但重要的是要注意这样做是行不通的。关于什么有效和无效的对比，请参见[表4-1](#fill_fails_table)。
- en: 'Table 4-1\. Fill params: scalar versus vector'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1。填充参数：标量与向量
- en: '| This works |  | This fails |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 这有效 |  | 这无效 |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `tf.fill([2, 2], 1)` |  | `tf.fill([2, 2], [1, 1, 1])` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `tf.fill([2, 2], 1)` |  | `tf.fill([2, 2], [1, 1, 1])` |'
- en: Your second parameter must be a single value to fill the tensor of the shape
    you gave. This nontensor value is often called a *scalar*. To recap, the code
    `tf.fill([200, 200, 4], 0.5)` would create a 200 x 200 gray semitransparent square,
    as illustrated in [Figure 4-3](#rgba_half).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第二个参数必须是一个单一值，用来填充你给定形状的张量。这个非张量值通常被称为*标量*。总之，代码`tf.fill([200, 200, 4], 0.5)`将创建一个200
    x 200的灰色半透明正方形，如[图4-3](#rgba_half)所示。
- en: '![A fill of 0.5](assets/ltjs_0403.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![一个填充为0.5的图像](assets/ltjs_0403.png)'
- en: Figure 4-3\. Alpha channel image tensor with background
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3\. 带背景的Alpha通道图像张量
- en: If you’re disappointed that you can’t fill a tensor with some elegant color
    other than grayscale, have I got a treat for you! Our next way to create large
    tensors not only lets you fill with tensors, but it also enables you to fill with
    patterns.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对不能用优雅的颜色填充张量感到失望，那么我有一个惊喜给您！我们下一个创建大张量的方法不仅可以让您用张量填充，还可以让您用图案填充。
- en: Let’s return to the 4 x 3 checkered image you made earlier. You hand-coded 12
    pixel values. If you wanted to make a 200 x 200 checkered image, that would be
    40,000 pixel values for simple grayscale. Instead, we’ll use the `.tile` method
    to expand a simple 2 x 2 tensor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到您之前制作的4 x 3的方格图像。您手工编码了12个像素值。如果您想制作一个200 x 200的方格图像，那将是40,000个像素值用于简单的灰度。相反，我们将使用`.tile`方法来扩展一个简单的2
    x 2张量。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO1-1)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO1-1)'
- en: The checker pattern is a 2D black-and-white tensor. This could be any elegant
    pattern or color.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 方格图案是一个二维的黑白张量。这可以是任何优雅的图案或颜色。
- en: '[![2](assets/2.png)](#co_image_tensors_CO1-2)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO1-2)'
- en: The tile size is 100 x 100 because the repeated pattern is 2 x 2, which results
    in a 200 x 200 image tensor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 瓷砖大小为100 x 100，因为重复的图案是2 x 2，这导致了一个200 x 200的图像张量。
- en: Checkered pixels are hard for a human eye to see. The checkered pattern can
    look gray without zooming in. Much like how printed dots make up multiple colors
    for magazines, you can see the checkered pattern clearly once you zoom in, like
    in [Figure 4-4](#ten_x).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人眼来说，方格像素很难看清楚。不放大的情况下，方格图案可能看起来灰色。就像印刷点组成杂志的多种颜色一样，一旦放大，您就可以清楚地看到方格图案，就像在[图4-4](#ten_x)中一样。
- en: '![Result of using tile](assets/ltjs_0404.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用瓷砖的结果](assets/ltjs_0404.png)'
- en: Figure 4-4\. Checkered 200 x 200 tensor with 10x zoom
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-4\. 10倍放大的200 x 200方格张量
- en: Lastly, if all these methods are far too structured for your taste, you can
    unleash the chaos! While JavaScript has no built-in method to generate arrays
    of random values, TensorFlow.js has a [wide variety of methods](https://oreil.ly/tg46b)
    to do precisely this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果所有这些方法对您的口味来说都太结构化，您可以释放混乱！虽然JavaScript没有内置方法来生成随机值数组，但TensorFlow.js有[各种各样的方法](https://oreil.ly/tg46b)可以精确地做到这一点。
- en: For simplicity, my favorite is called `.randomUniform`. This tensor method takes
    a shape and also optionally a min, max, and data type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '简单起见，我最喜欢的是`.randomUniform`。这个张量方法接受一个形状，还可以选择一个最小值、最大值和数据类型。 '
- en: If you want to build a 200 x 200 random static of grayscale colors, you can
    use `tf.randomUniform([200, 200, 1])` or even `tf.randomUniform([200, 200, 1],
    0, 255, 'int32')`. Both of these will make the same (as same as random can be)
    result.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想构建一个200 x 200的灰度颜色的随机静态图像，您可以使用`tf.randomUniform([200, 200, 1])`或者`tf.randomUniform([200,
    200, 1], 0, 255, 'int32')`。这两者将产生相同的（尽可能相同的）结果。
- en: '[Figure 4-5](#static) shows some example output.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-5](#static)显示了一些示例输出。'
- en: '![200 x 200 random ](assets/ltjs_0405.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![200 x 200随机](assets/ltjs_0405.png)'
- en: Figure 4-5\. 200 x 200 random value-filled tensor
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-5\. 200 x 200随机值填充的张量
- en: JPGs and PNGs and GIFs, Oh My!
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPG、PNG和GIF，哦我的天啊！
- en: OK, Gant! You’ve been talking about images for a bit now, but we can’t see them;
    all we see are tensors. How does a tensor turn into an actual visible image? And
    probably more important for machine learning, how does an existing image turn
    into a tensor?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，甘特！您已经谈论了一段时间的图像，但我们看不到它们；我们只看到张量。张量如何变成实际可见的图像？而对于机器学习来说，现有的图像如何变成张量？
- en: As you might have intuited, this will vary significantly according to where
    the JavaScript is running, specifically the client and server. To decode an image
    to a tensor and back on a browser, you’ll be limited and empowered by the magic
    of the browser’s built-in functionality for a sandbox. Conversely, images on a
    server running Node.js will not be sandboxed but lack easy visual feedback.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经直觉到的那样，这将根据JavaScript运行的位置（特别是客户端和服务器）而有很大不同。要在浏览器上将图像解码为张量，然后再转换回来，您将受到浏览器内置功能的限制和赋予的力量。相反，在运行Node.js的服务器上的图像将不受限制，但缺乏易于的视觉反馈。
- en: Fear not! You will cover both of these options in this section so you can confidently
    apply TensorFlow.js to images, regardless of the medium.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕！在本节中，您将涵盖这两个选项，这样您就可以自信地将TensorFlow.js应用于图像，无论媒介如何。
- en: 'We’ll review the following common scenarios in detail:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细审查以下常见情况：
- en: 'Browser: tensor to image'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器：张量到图像
- en: 'Browser: image to tensor'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器：图像到张量
- en: 'Node.js: tensor to image'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js：张量到图像
- en: 'Node.js: image to tensor'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js：图像到张量
- en: 'Browser: Tensor to Image'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器：张量到图像
- en: For visualizing, modifying, and saving images, you will utilize HTML elements
    and a canvas. Let’s start by giving us a way to visualize all the graphical lessons
    we’ve learned. We’ll render a tensor to a canvas in a browser.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化、修改和保存图像，您将利用HTML元素和画布。让我们从给我们一种可视化我们学到的所有图形课程的方法开始。我们将在浏览器中将一个张量渲染到画布上。
- en: First, create a 400 x 400 tensor of random noise, and then convert the tensor
    to an image in the browser. To accomplish this, you will use `tf.browser.toPixels`.
    This method takes a tensor as the first parameter, and optionally a canvas to
    draw to for the second parameter. It returns a promise that resolves when the
    render is complete.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个400 x 400的随机噪声张量，然后在浏览器中将张量转换为图像。为了实现这一点，您将使用`tf.browser.toPixels`。该方法将张量作为第一个参数，可选地为第二个参数提供一个画布以绘制。它返回一个在渲染完成时解析的Promise。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At first glance, having the canvas be an optional parameter is quite confusing.
    It’s worth noting that the promise resolves with a `Uint8ClampedArray` of the
    tensor as a parameter, so it’s a good way to have a “canvas ready” value created,
    even if you don’t have an active canvas in mind. It will likely decrease in utility
    as [the concept of an OffscreenCanvas](https://oreil.ly/gaiVn) moves from experimental
    mode to an actual supported web API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，将canvas作为可选参数是相当令人困惑的。值得注意的是，promise将以`Uint8ClampedArray`的形式解析为张量作为参数，因此这是一个很好的方式来创建一个“准备好的canvas”值，即使您没有特定的canvas在脑海中。随着[OffscreenCanvas的概念](https://oreil.ly/gaiVn)从实验模式转变为实际支持的Web
    API，它可能会减少实用性。
- en: 'To set up our first ever canvas render, you’ll need to have a canvas in our
    HTML with an ID that you can reference. For those of us who are familiar with
    the complexity of HTML load order, you’ll need the canvas to exist *before* you
    attempt to access it from our JavaScript (or follow any best practice for your
    site, like checking for a document-ready state):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们的第一个画布渲染，您需要在我们的HTML中有一个带有ID的画布，以便您可以引用它。对于那些熟悉HTML加载顺序复杂性的人来说，您需要在尝试从JavaScript中访问它之前使画布存在*之前*（或者遵循您网站的任何最佳实践，比如检查文档准备就绪状态）：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And now you can access this canvas by ID and pass it to our `browser.toPixels`
    method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以通过ID访问此画布，并将其传递给我们的`browser.toPixels`方法。
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO2-1)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO2-1)'
- en: Creating an RGB 400 x 400 image tensor
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个RGB 400 x 400图像张量
- en: '[![2](assets/2.png)](#co_image_tensors_CO2-2)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO2-2)'
- en: Grabbing a reference to our canvas in the Document Object Model (DOM)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档对象模型（DOM）中获取对我们画布的引用
- en: '[![3](assets/3.png)](#co_image_tensors_CO2-3)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO2-3)'
- en: Calling `browser.toPixels` with our tensor and canvas
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的张量和画布调用`browser.toPixels`
- en: If this code were run in an async function, you could have simply awaited the
    `browser.toPixels` call and then cleaned up. Without utilizing the promise or
    async functionality, the `dispose` would most assuredly win the possible race
    condition and cause an error.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此代码在异步函数中运行，您可以简单地等待`browser.toPixels`调用，然后清理。如果不使用promise或异步功能，`dispose`几乎肯定会赢得可能的竞争条件并导致错误。
- en: 'Browser: Image to Tensor'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器：图像到张量
- en: As you may have guessed, `browser.toPixels` has a counterpart named `browser.fromPixels`.
    This method takes an image and converts it to a tensor. Fortunately for us, the
    input for `browser.fromPixels` is quite dynamic. You can pass in a wide variety
    of elements, from JavaScript ImageData to Image objects, to HTML elements like
    `<img>`, `<canvas>`, and even `<video>`. This makes it pretty simple to encode
    any image into a tensor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的，`browser.toPixels`有一个名为`browser.fromPixels`的对应方法。此方法将获取图像并将其转换为张量。对于我们来说，`browser.fromPixels`的输入非常动态。您可以传入各种元素，从JavaScript
    ImageData到Image对象，再到HTML元素如`<img>`、`<canvas>`，甚至`<video>`。这使得将任何图像编码为张量变得非常简单。
- en: As a second parameter, you can even identify the number of channels you’d like
    for an image (1, 3, 4), so you can optimize for the data you care about. For example,
    if you were identifying handwriting, there’s no real need for RBG. You can get
    a grayscale tensor immediately from our tensor conversion!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个参数，您甚至可以确定您想要的图像通道数（1、3、4），因此您可以优化您关心的数据。例如，如果您要识别手写，那么就没有真正需要RGB。您可以立即从我们的张量转换中获得灰度张量！
- en: To set up our image to tensor conversion, you’ll explore the two most common
    inputs. You’ll convert a DOM element, and you’ll convert an in-memory element,
    too. The in-memory element will load an image via URL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们的图像到张量转换，您将探索两种最常见的输入。您将转换一个DOM元素，也将转换一个内存元素。内存元素将通过URL加载图像。
- en: Warning
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you’ve been opening *.html* files locally up to this point, this is where
    that will stop working. You’ll need to actually use a web server like 200 OK!
    or one of the other mentioned hosting solutions to access images loaded by URL.
    See [Chapter 2](ch02.html#the_chapter_2) if you get stuck.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止您一直在本地打开*.html*文件，那么这里将停止工作。您需要实际使用像200 OK！这样的Web服务器或其他提到的托管解决方案来访问通过URL加载的图像。如果遇到困难，请参阅[第2章](ch02.html#the_chapter_2)。
- en: To load an image from the DOM, you simply need a reference to that item on the
    DOM. In the source code associated with this book, I’ve set up an example to access
    two images. The simplest way to follow along is to read [Chapter 4 on GitHub](https://oreil.ly/ZzWPP).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要从DOM加载图像，您只需要在DOM上引用该项。在与本书相关的源代码中，我设置了一个示例来访问两个图像。跟随的最简单方法是阅读[GitHub上的第4章](https://oreil.ly/ZzWPP)。
- en: 'Let’s set our DOM image up with a simple `img` tag and `id`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的`img`标签和`id`设置我们的DOM图像：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Yes, that’s a strange image of me I decided to use. I have adorable dogs, but
    they are shy and have refused to sign a release to be models for my book. Being
    a dog lover can be “ruff.” Now that you have an image, let’s write the simple
    JavaScript to reference the desired image element.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，那是我决定使用的一张奇怪的图片。我有可爱的狗，但它们很害羞，拒绝签署发布协议成为我书中的模特。作为一个爱狗人士可能会很“艰难”。现在您有了一张图片，让我们写一个简单的JavaScript来引用所需的图像元素。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Be sure the `document` is finished loading before trying to access the image
    element. Otherwise, you might get a cryptic message like “The source width is
    0.” This happens most frequently on implementations with no JavaScript frontend
    framework. In situations where there’s nothing awaiting the DOM load event, I
    suggest subscribing to the `window`’s load event before trying to access the DOM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试访问图像元素之前，请确保`document`已经加载完成。否则，您可能会收到类似“源宽度为0”的神秘消息。这在没有JavaScript前端框架的实现中最常见。在没有任何东西等待DOM加载事件的情况下，我建议在尝试访问DOM之前订阅`window`的加载事件。
- en: 'With the `img` in place and the DOM loaded, you can call `browser.fromPixels`
    for results:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`img`放置并DOM加载完成后，您可以调用`browser.fromPixels`获取结果：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO3-1)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO3-1)'
- en: Grabbing a reference to the `img` tag.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 获取对`img`标签的引用。
- en: '[![2](assets/2.png)](#co_image_tensors_CO3-2)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO3-2)'
- en: Creating a tensor from the image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从图像创建张量。
- en: '[![3](assets/3.png)](#co_image_tensors_CO3-3)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO3-3)'
- en: 'Logging proof that we now have a tensor! This prints the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 记录证明我们现在有了一个张量！这将打印以下内容：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Warning
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'If you are getting an error similar to `Failed to execute ''getImageData''
    on ''CanvasRenderingContext2D'': The canvas has been tainted by cross-origin data.`,
    this means you’re trying to load an image from another server rather than local.
    For security reasons browsers protect against this. See the next example for loading
    external images.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您遇到类似于 `Failed to execute ''getImageData'' on ''CanvasRenderingContext2D'':
    The canvas has been tainted by cross-origin data.` 的错误，这意味着您正在尝试从另一个服务器加载图像而不是本地。出于安全原因，浏览器会防止这种情况发生。查看下一个示例以加载外部图像。'
- en: 'Perfect! But what if our image is not in an element on our page? So long as
    the server allows cross-origin loading (`Access-Control-Allow-Origin "*"`), you’ll
    be able to dynamically load and process external images. This is where the [JavaScript
    Image object example](https://oreil.ly/dSjiI) comes in. We can convert an image
    into a tensor like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！但是如果我们的图像不在页面的元素中怎么办？只要服务器允许跨域加载 (`Access-Control-Allow-Origin "*"`)，您就可以动态加载和处理外部图像。这就是
    [JavaScript 图像对象示例](https://oreil.ly/dSjiI) 的用武之地。我们可以这样将图像转换为张量：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO4-1)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO4-1)'
- en: Create a new Image web API object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Image web API 对象。
- en: '[![2](assets/2.png)](#co_image_tensors_CO4-2)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO4-2)'
- en: This is not necessary here because the file is on the server, but you commonly
    need to set this to access external URLs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这在这里是不必要的，因为文件在服务器上，但通常需要设置此选项以访问外部 URL。
- en: '[![3](assets/3.png)](#co_image_tensors_CO4-3)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO4-3)'
- en: Give the path to the image.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 给出图像的路径。
- en: '[![4](assets/4.png)](#co_image_tensors_CO4-4)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_image_tensors_CO4-4)'
- en: Wait for the image to fully load into the object before you try to turn it into
    a tensor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 等待图像完全加载到对象中，然后再尝试将其转换为张量。
- en: '[![5](assets/5.png)](#co_image_tensors_CO4-5)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_image_tensors_CO4-5)'
- en: Convert the image to a tensor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像转换为张量。
- en: '[![6](assets/6.png)](#co_image_tensors_CO4-6)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_image_tensors_CO4-6)'
- en: 'Print our tensor shape to make sure everything went as planned. This prints
    the following: `Successful conversion from Image() to a 578,500,3 tensor`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打印我们的张量形状以确保一切按计划进行。这将打印以下内容：`从 Image() 成功转换为 578,500,3 张量`。
- en: By combining the two previous methods, you can have a single page that shows
    one image element and prints the values of two tensors to the console (see [Figure 4-6](#successful_conversions)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合两种先前的方法，您可以创建一个单页面，其中显示一个图像元素并将两个张量的值打印到控制台（参见 [图 4-6](#successful_conversions)）。
- en: '![screenshot of working code](assets/ltjs_0406.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![工作代码的截图](assets/ltjs_0406.png)'
- en: Figure 4-6\. The console log of two images becoming tensors
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-6\. 两个图像变成张量的控制台日志
- en: By the logs of the images, you can see both of them are 500-pixel-wide RGB.
    If you modify the second parameter, you can easily convert either of these images
    to grayscale or RGBA. You’ll get into modifying our image tensors later in this
    chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图像的日志，您可以看到它们都是 500 像素宽的 RGB 图像。如果修改第二个参数，您可以轻松地将这些图像中的任何一个转换为灰度或 RGBA。您将在本章后面修改我们的图像张量。
- en: 'Node: Tensor to Image'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node：张量到图像
- en: In Node.js, there’s no canvas for rendering, just the quiet efficiency of writing
    files. You’ll be saving a random 400 x 400 RGB with `tfjs-node`. While image tensors
    are pixel-by-pixel values, typical image formats are much smaller. JPG and PNGs
    have various compression techniques, headers, features, and more. The resulting
    file internals will look nothing like our pretty 3D image tensors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中，没有用于渲染的画布，只有安静高效地写文件。您将使用 `tfjs-node` 保存一个随机的 400 x 400 RGB。虽然图像张量是逐像素的值，但典型的图像格式要小得多。JPG
    和 PNG 具有各种压缩技术、头部、特性等。生成的文件内部看起来与我们漂亮的 3D 图像张量完全不同。
- en: Once tensors are converted to their encoded file formats, you’ll use the Node.js
    filesystem library (`fs`) to write the file out. Now that you have a plan, let’s
    explore the features and settings to save a tensor to JPG and PNG.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦张量转换为它们的编码文件格式，您将使用 Node.js 文件系统库 (`fs`) 将文件写出。现在您已经有了一个计划，让我们探索保存张量到 JPG
    和 PNG 的功能和设置。
- en: Writing JPGs
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 JPG
- en: To encode a tensor into a JPG, you will use a method called `node.encodeJpeg`.
    This method takes an Int32 representation of the image and some options and returns
    a promise with the resulting data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要将张量编码为 JPG，您将使用一个名为 `node.encodeJpeg` 的方法。此方法接受图像的 Int32 表示和一些选项，并返回一个包含结果数据的
    promise。
- en: The first hiccup you might notice is that the input tensor *must* be that Int32
    encoding with values of `0-255`, where the browser could handle float and integer
    values. Perhaps this is an excellent opportunity for an open source contributor!?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到的第一个问题是，输入张量 *必须* 是具有值 `0-255` 的 Int32 编码，而浏览器可以处理浮点和整数值。也许这是一个优秀的开源贡献者的绝佳机会！？
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Any `Float32` tensor with values `0-1` can be transformed into a new tensor
    by multiplying by 255 and then converting to `int32` with code like so: `myTensor.mul(255).asType(''int32'')`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有值 `0-1` 的 `Float32` 张量都可以通过将其乘以 255 然后转换为 `int32` 的代码来转换为新的张量，例如：`myTensor.mul(255).asType('int32')`。
- en: 'Writing a JPG from a tensor, as found in [*chapter4/node/node-encode*, in Chapter
    4 on GitHub](https://oreil.ly/Nn9nX), can be as simple as this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从张量中写入 JPG，就像在[*GitHub 的第 4 章节中的 *chapter4/node/node-encode*](https://oreil.ly/Nn9nX)中发现的那样，可以简单地这样做：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO5-1)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO5-1)'
- en: You create random RGB pixels for a 400 x 400 image tensor.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 400 x 400 的图像张量，其中包含随机的 RGB 像素。
- en: '[![2](assets/2.png)](#co_image_tensors_CO5-2)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO5-2)'
- en: '`node.encodeJpeg` is called with the tensor input.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用张量输入调用 `node.encodeJpeg`。
- en: '[![3](assets/3.png)](#co_image_tensors_CO5-3)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO5-3)'
- en: The resulting data is written with the filesystem library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的数据将使用文件系统库写入。
- en: 'Because the file you’re writing is a JPG, there’s a wide variety of configuration
    options you can enable. Let’s write another image and modify the defaults along
    the way:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您要写入的文件是JPG，您可以启用各种配置选项。让我们再写入另一张图片，并在此过程中修改默认设置：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO6-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO6-1)'
- en: '`format`: you can override the default color channels with `grayscale` or `rgb`
    instead of matching the input tensor.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`：您可以使用`grayscale`或`rgb`覆盖默认的颜色通道，而不是匹配输入张量。'
- en: '[![2](assets/2.png)](#co_image_tensors_CO6-2)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO6-2)'
- en: '`quality`: adjust the quality of the JPG. Lower numbers degrade quality, usually
    for size.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`quality`：调整JPG的质量。较低的数字会降低质量，通常是为了减小文件大小。'
- en: '[![3](assets/3.png)](#co_image_tensors_CO6-3)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO6-3)'
- en: '`progressive`: JPGs have the ability to load from the top down, or slowly become
    clear as a progressive load. Setting this to true enables progressive load format.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`progressive`：JPG具有从上到下加载或逐渐清晰的渐进加载能力。将其设置为true可以启用渐进加载格式。'
- en: '[![4](assets/4.png)](#co_image_tensors_CO6-4)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_image_tensors_CO6-4)'
- en: '`optimizeSize`: spend a few extra cycles to optimize an image size without
    modifying the quality.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimizeSize`：花费一些额外的周期来优化图像大小，而不会修改质量。'
- en: '[![5](assets/5.png)](#co_image_tensors_CO6-5)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_image_tensors_CO6-5)'
- en: '`chromaDownsampling`: this is a trick where lighting is more important in the
    encoding than colors. It modifies the raw distribution of the data so it’s clearer
    to the human eye.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`chromaDownsampling`：这是一个技巧，其中照明比颜色更重要。它修改了数据的原始分布，使其对人眼更清晰。'
- en: '[![6](assets/6.png)](#co_image_tensors_CO6-6)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_image_tensors_CO6-6)'
- en: '`densityUnit`: choose either pixels per inch or centimeter; a strange few fight
    the metric system.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`densityUnit`：选择每英寸或每厘米的像素；一些奇怪的人反对公制系统。'
- en: '[![7](assets/7.png)](#co_image_tensors_CO6-7)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_image_tensors_CO6-7)'
- en: '`xDensity`: set the pixels-per-density unit on the x-axis.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`xDensity`：设置x轴上的像素密度单位。'
- en: '[![8](assets/8.png)](#co_image_tensors_CO6-8)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_image_tensors_CO6-8)'
- en: '`yDensity`: set the pixels-per-density unit on the y-axis.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`yDensity`：设置y轴上的像素密度单位。'
- en: '[![9](assets/9.png)](#co_image_tensors_CO6-9)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_image_tensors_CO6-9)'
- en: '`xmpMetadata`: this is a nonvisible message to store in the image metadata.
    Generally, this is reserved for licensing and scavenger hunts.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`xmpMetadata`：这是一个非可见的消息，存储在图像元数据中。通常，这是为许可和寻宝活动保留的。'
- en: Depending on why you’re writing the JPG, you can adequately configure or ignore
    these options from Node.js! [Figure 4-7](#jpgsizes) shows the file size difference
    of the two JPGs you just created.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您写入JPG的原因，您可以充分配置或忽略这些选项来自Node.js！[图4-7](#jpgsizes)显示了您刚刚创建的两个JPG文件的文件大小差异。
- en: '![two JPG file sizes](assets/ltjs_0407.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![两个JPG文件大小](assets/ltjs_0407.png)'
- en: Figure 4-7\. File sizes of our two examples
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-7\. 我们两个示例的文件大小
- en: Writing PNGs
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入PNG
- en: The features for writing a PNG are significantly more limited than a JPG. As
    you might have guessed, we’ll have a friendly method that helps us along the way,
    and it’s called `node.encodePng`. Just like our friend the JPG, this method expects
    an integer representation of our tensor with values ranging `0-255`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 写入PNG的功能明显比JPG有限得多。正如您可能猜到的那样，我们将有一个友好的方法来帮助我们，它被称为`node.encodePng`。就像我们的朋友JPG一样，该方法期望我们的张量的整数表示，值范围在`0-255`之间。
- en: 'We can easily write a PNG with the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地写入PNG如下：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The PNG parameters aren’t nearly as advanced. You have only one new parameter,
    and it’s a cryptic one! The second parameter to `node.encodePng` is a compression
    setting. This value can be anywhere between `-1` and `9`. The default value is
    `1`, which means a little compression, and `9` means max compression.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PNG参数并不那么先进。您只有一个新参数，而且它是一个神秘的参数！`node.encodePng`的第二个参数是一个压缩设置。该值可以在`-1`和`9`之间任意取值。默认值为`1`，表示轻微压缩，而`9`表示最大压缩。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You might think `-1` means no compression, but from experimenting, `0` means
    no compression. Actually, `-1` activates max compression. So, -1 and 9 are effectively
    the same.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为`-1`表示无压缩，但通过实验，`0`表示无压缩。实际上，`-1`激活了最大压缩。因此，-1和9实际上是相同的。
- en: 'Since PNGs are terrible at compressing randomness, you can set this second
    parameter to `9` and get a file around the same size as the default setting:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PNG在压缩随机性方面表现糟糕，您可以将第二个参数设置为`9`，得到与默认设置大小相近的文件：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you’d like to see an actual file size difference, try printing something
    easy to compress, like `tf.zeros`. Regardless, you can now generate PNG files
    from tensors with ease.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到实际的文件大小差异，请尝试打印一些易于压缩的内容，比如`tf.zeros`。无论如何，您现在可以轻松地从张量生成PNG文件。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If your tensor utilizes an alpha channel, you cannot use formats like JPG; you’ll
    have to save a PNG to preserve that data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的张量使用了alpha通道，您不能使用JPG等格式；您将不得不保存为PNG以保留这些数据。
- en: 'Node: Image to Tensor'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node：图像到张量
- en: Node.js is a fantastic tool for training a machine learning model because of
    the direct file access and speed of decoding images. Decoding into a tensor on
    Node.js is quite similar to the encoding process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个出色的工具，用于训练机器学习模型，因为它具有直接的文件访问和解码图像的速度。在Node.js上将图像解码为张量与编码过程非常相似。
- en: Node provides [functions for decoding BMP, JPG, PNG, and even GIF file formats](https://oreil.ly/pRjb5).
    However, as you might expect, there is also a generic `node.decodeImage` method,
    which is capable of doing the simple identification lookup and conversion of any
    of these files automatically. You’ll use `decodeImage` for now and leave `decodeBMP`,
    etc., for you to review as needed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Node提供了解码BMP、JPG、PNG甚至GIF文件格式的功能。但是，正如您可能期望的那样，还有一个通用的`node.decodeImage`方法，能够自动进行简单的识别查找和转换。您现在将使用`decodeImage`，并留下`decodeBMP`等待您需要时查看。
- en: The simplest decode for an image is to pass the file directly into the command.
    To do this, you can use the standard Node.js libraries `fs` and `path`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像的最简单解码是直接将文件传递给命令。为此，您可以使用标准的Node.js库`fs`和`path`。
- en: This example code depends on a single *cake.jpg* file for loading and decoding
    into a tensor. The code and image resources used in this demo are available at
    [*chapter4/node/node-decode* in Chapter 4 on GitHub](https://oreil.ly/k8jjE).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码依赖于一个名为*cake.jpg*的文件进行加载和解码为张量。此演示中使用的代码和图像资源可在GitHub的第4章[*chapter4/node/node-decode*](https://oreil.ly/k8jjE)中找到。
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO7-1)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO7-1)'
- en: You load the designated file into memory using the filesystem library.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用文件系统库将指定的文件加载到内存中。
- en: '[![2](assets/2.png)](#co_image_tensors_CO7-2)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO7-2)'
- en: You decode the image into a tensor that matches the imported image’s number
    of color channels.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您将图像解码为与导入图像的颜色通道数量相匹配的张量。
- en: '[![3](assets/3.png)](#co_image_tensors_CO7-3)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO7-3)'
- en: You decode this image into a grayscale tensor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您将此图像解码为灰度张量。
- en: As we mentioned earlier, the decoding process also allows the decoding of GIF
    files. One obvious question is, “Which frame of the GIF?” For this, you can choose
    either all frames or the first frame for animated GIFs. The `node.decodeImage`
    method has a flag that allows you to identify what you prefer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，解码过程还允许解码GIF文件。一个明显的问题是，“GIF的哪一帧？”为此，您可以选择所有帧或动画GIF的第一帧。`node.decodeImage`方法有一个标志，允许您确定您的偏好。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Physicists often argue about the fourth dimension being or not being time. Regardless
    of the debates on 4D Minkowski spacetime being a reality, it is a proven reality
    for animated GIFs! To represent animated GIFs in a tensor, you use a rank-four
    tensor.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学家经常争论第四维是时间还是不是时间。不管关于4D闵可夫斯基时空是否是现实的争论，对于动画GIF来说，这是一个已被证明的现实！为了表示动画GIF，您使用一个四阶张量。
- en: 'This example code decodes an animated GIF. The example GIF you’re going to
    use is a 500 x 372 animated GIF with 20 frames:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码解码了一个动画GIF。您将要使用的示例GIF是一个500 x 372的动画GIF，有20帧：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For the `node.decodeImage` parameters, you’re providing the image data, followed
    by three channels for color, as an `int32` result tensor, and the final parameter
    is `true`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`node.decodeImage`参数，您提供图像数据，接着是三个颜色通道，作为一个`int32`结果张量，最后一个参数是`true`。
- en: Passing `true` lets the method know to unroll animated GIFs and return a 4D
    tensor, where `false` would clip this down to 3D.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`true`让方法知道展开动画GIF并返回一个4D张量，而`false`会将其剪裁为3D。
- en: Our resulting tensor shape, as you might have expected, is `[20, 372, 500, 3]`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果张量形状，正如您可能期望的那样，是`[20, 372, 500, 3]`。
- en: Common Image Modifications
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的图像修改
- en: Importing images into tensors for training is powerful but rarely direct. When
    images are used for machine learning, they generally have some common modifications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像导入张量进行训练是强大的，但很少是直接的。当图像用于机器学习时，它们通常有一些常见的修改。
- en: 'Common modifications include:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的修改包括：
- en: Being mirrored for data augmentation
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被镜像以进行数据增强
- en: Resizing to the expected input size
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整大小以符合预期的输入大小
- en: Cropping out faces or other desired portions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪出脸部或其他所需部分
- en: You’ll perform many of these operations in machine learning, and you’ll see
    these skills being utilized in the next two chapters. The capstone project in
    [Chapter 12](ch12.html#the_chapter_12) will depend on this skill extensively.
    Let’s take a moment to implement a few of these everyday operations to round out
    your comfort with image tensors.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在机器学习中执行许多这些操作，并且您将在接下来的两章中看到这些技能被使用。[第12章](ch12.html#the_chapter_12)的毕业项目将大量依赖这项技能。让我们花点时间来实现一些这些日常操作，以完善您对图像张量的舒适度。
- en: Mirroring Image Tensors
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像图像张量
- en: If you’re trying to train a model on identifying cats, you can double your dataset
    by mirroring your existing cat photos. Slightly adjusting training images to augment
    datasets is a common practice.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在尝试训练一个识别猫的模型，您可以通过镜像您现有的猫照片来使数据集翻倍。微调训练图像以增加数据集是一种常见做法。
- en: To flip tensor data for an image, you have two options. One is to modify the
    image tensor’s data in a way that flips the image along the width axis. The other
    way is to use `tf.image.flipLeftRight`, which is commonly used for batches of
    images. Let’s do both.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要为图像翻转张量数据，您有两个选项。一种是以一种方式修改图像张量的数据，使图像沿宽度轴翻转。另一种方法是使用`tf.image.flipLeftRight`，这通常用于图像批次。让我们两者都做一下。
- en: To flip a single image, you can use `tf.reverse` and specify you want to flip
    only the axis that holds the pixels for the width of an image. As you already
    know, this is the second axis of the image, and thus the index you will pass is
    `1`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要翻转单个图像，您可以使用`tf.reverse`并指定您只想翻转包含图像宽度像素的轴。正如您已经知道的，这是图像的第二个轴，因此您将传递的索引是`1`。
- en: 'In the corresponding source code for this chapter, you display an image and
    then mirror that image in a canvas right next to it. You can access this example
    at [*simple/simple-image-manipulation/mirror.html* on GitHub](https://oreil.ly/83b9B).
    The full code for this operation looks like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的相应源代码中，您显示一幅图像，然后在旁边的画布上镜像该图像。您可以在GitHub的[*simple/simple-image-manipulation/mirror.html*](https://oreil.ly/83b9B)中访问此示例。此操作的完整代码如下：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO8-1)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO8-1)'
- en: The reverse function flips the axis index `1` to reverse the image.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: reverse函数将轴索引`1`翻转以反转图像。
- en: Because you understand the underlying data, it was trivial to apply this transformation
    to your image. You can experiment with flipping along the height or even RGB axis.
    Any data can be reversed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您了解底层数据，将此转换应用于您的图像是微不足道的。您可以尝试沿高度或甚至RGB轴翻转。任何数据都可以被反转。
- en: '[Figure 4-8](#lemonade) shows the result of `tf.reverse` on axis `1`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 4-8](#lemonade)显示了在轴`1`上使用`tf.reverse`的结果。'
- en: '![Reversing a single axis](assets/ltjs_0408.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![翻转单个轴](assets/ltjs_0408.png)'
- en: Figure 4-8\. tf.reverse for lemonadeTensor with axis set to 1
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-8。tf.reverse用于轴设置为1的lemonadeTensor
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Reverse and other data manipulation methods are not unique to images. You could
    use this to augment nonvisual datasets like tic-tac-toe and similar games.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 反转和其他数据操作方法并不局限于图像。您可以使用这些方法来增强非视觉数据集，如井字棋和类似的游戏。
- en: We should also review the other method of mirroring an image, because this method
    can handle mirroring a group of images, and this exposes some pretty important
    concepts when it comes to image data. After all, our goal is to rely on the optimization
    of tensors as much as possible and to stay away from JavaScript iterative looping.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该回顾另一种镜像图像的方法，因为这种方法可以处理一组图像的镜像，并且在处理图像数据时暴露了一些非常重要的概念。毕竟，我们的目标是尽可能依赖张量的优化，并尽量远离JavaScript的迭代循环。
- en: The second way you can mirror an image is to use `tf.image.flipLeftRight`. This
    method is geared toward handling batches of images, and batches of 3D tensors
    are basically 4D tensors. For our demo, you’ll take one image and make it a batch
    of one.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种镜像图像的方法是使用`tf.image.flipLeftRight`。这种方法旨在处理一组图像，并且一组3D张量基本上是4D张量。对于我们的演示，您将取一张图像并将其制作成一组一张的批次。
- en: To expand the dimensionality of a single 3D image, you can use `tf.expandDims`,
    and then when you’re looking to reverse that (throw away the unnecessary bracket),
    you can use `tf.squeeze`. This way, you can move a 3D image to 4D for batch processing
    and back. This seems a bit silly with a single image, but it’s an excellent exercise
    in the concept of understanding batches and changing dimensions of tensors.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展单个3D图像的维度，您可以使用`tf.expandDims`，然后当您想要反转它（丢弃不必要的括号）时，您可以使用`tf.squeeze`。这样，您可以将3D图像移动到4D以进行批处理，然后再次缩小。对于单个图像来说，这似乎有点愚蠢，但这是一个很好的练习，可以帮助您理解批处理和张量维度变化的概念。
- en: So, a 200 x 200 RGB image starts as `[200, 200, 3]`, and then you expand it,
    essentially making it a stack of one. The resulting shape becomes `[1, 200, 200,
    3]`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个200 x 200的RGB图像起始为`[200, 200, 3]`，然后您扩展它，实质上使其成为一个堆叠。结果形状变为`[1, 200, 200,
    3]`。
- en: 'You can perform `tf.image.flipLeftRight` on a single image with the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码在单个图像上执行`tf.image.flipLeftRight`：
- en: '[PRE16]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO9-1)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO9-1)'
- en: The dimensions of the tensor are expanded.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 张量的维度被扩展。
- en: '[![2](assets/2.png)](#co_image_tensors_CO9-2)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO9-2)'
- en: Import the 3D image as a tensor.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将3D图像导入为张量。
- en: '[![3](assets/3.png)](#co_image_tensors_CO9-3)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO9-3)'
- en: As of the writing of this section, `image.flipLeftRight` expects images to be
    a `float32` tensor. This may change in the future.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本节时，`image.flipLeftRight`期望图像是一个`float32`张量。这可能会在未来发生变化。
- en: '[![4](assets/4.png)](#co_image_tensors_CO9-4)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_image_tensors_CO9-4)'
- en: Flip the image batch and then squeeze it down into a 3D tensor again when you’re
    done.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转图像批次，然后在完成后将其压缩回3D张量。
- en: '[![5](assets/5.png)](#co_image_tensors_CO9-5)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_image_tensors_CO9-5)'
- en: The `image.flipLeftRight` returned `0-255` values, so you’ll need to make sure
    our tensor you send to `browser.toPixels` is an `int32`, so it renders correctly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`image.flipLeftRight`返回`0-255`的值，因此您需要确保发送给`browser.toPixels`的张量是`int32`，这样它才能正确渲染。'
- en: That was a bit more complicated than our use of `tf.reverse`, but each strategy
    has its own benefits and drawbacks. It’s essential to take full advantage of the
    speed and massive calculation capabilities of tensors whenever possible.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们使用`tf.reverse`更复杂一些，但每种策略都有其自身的优点和缺点。在可能的情况下，充分利用张量的速度和巨大计算能力是至关重要的。
- en: Resizing Image Tensors
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整图像张量的大小
- en: Lots of AI models expect a specific input image size. That means that while
    your users upload 700 x 900 images, the model is looking for a tensor that is
    256 x 256\. Resizing images is at the core of dealing with image input.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 许多AI模型期望特定的输入图像尺寸。这意味着当您的用户上传700 x 900像素的图像时，模型正在寻找一个尺寸为256 x 256的张量。调整图像大小是处理图像输入的核心。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Resizing image tensors for input is a common practice for most models. This
    means any image that is wildly out of proportion to the desired input, like a
    panoramic photo, will likely perform terribly when it is resized for input.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 调整图像张量的大小以用于输入是大多数模型的常见做法。这意味着任何与期望输入严重不成比例的图像，如全景照片，当调整大小以用于输入时可能表现糟糕。
- en: 'TensorFlow.js has two excellent methods for resizing images, and both support
    batches of images: `image.resizeNearestNeighbor` and `image.resizeBilinear`. I
    recommend that you use `image.resizeBilinear` for any visual resizing and save
    `image.resizeNearestNeighbor` for when the specific pixel values of an image cannot
    be compromised or interpolated. There is a small speed difference, `image.resizeNearestNeighbor`
    being around 10x faster than `image.resizeBilinear`, but the difference is still
    measured in milliseconds per resize.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow.js有两种优秀的方法用于调整图像大小，并且两者都支持图像批处理：`image.resizeNearestNeighbor`和`image.resizeBilinear`。我建议您在进行任何视觉调整时使用`image.resizeBilinear`，并将`image.resizeNearestNeighbor`保留用于当图像的特定像素值不能被破坏或插值时。速度上有一点小差异，`image.resizeNearestNeighbor`比`image.resizeBilinear`快大约10倍，但差异仍然以每次调整的毫秒数来衡量。
- en: To put it bluntly, `resizeBilinear` blurs and `resizeNearestNeighbor` pixelates
    when they have to extrapolate for new data. Let’s upscale an image with both methods
    and compare. You can access this example at [*simple/simple-image-manipulation/resize.html*](https://oreil.ly/ieQLD).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 直白地说，`resizeBilinear`会模糊，而`resizeNearestNeighbor`会像素化，当它们需要为新数据进行外推时。让我们使用这两种方法放大图像并进行比较。您可以在[*simple/simple-image-manipulation/resize.html*](https://oreil.ly/ieQLD)中查看此示例。
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO10-1)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO10-1)'
- en: Increase an image size 4x so you can see the difference between these two.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像大小增加4倍，以便您可以看到这两者之间的差异。
- en: '[![2](assets/2.png)](#co_image_tensors_CO10-2)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO10-2)'
- en: Resize using the nearest neighbor algorithm.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最近邻算法调整大小。
- en: '[![3](assets/3.png)](#co_image_tensors_CO10-3)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO10-3)'
- en: The third parameter is `alignCorners`; just always set this to true.^([1](ch04.html#idm45049247514216))
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是`alignCorners`；请始终将其设置为true。^([1](ch04.html#idm45049247514216))
- en: '[![4](assets/4.png)](#co_image_tensors_CO10-4)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_image_tensors_CO10-4)'
- en: Resize with the bilinear algorithm.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双线性算法调整大小。
- en: '[![5](assets/5.png)](#co_image_tensors_CO10-5)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_image_tensors_CO10-5)'
- en: Always set this to `true` (see *3*).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将此设置为`true`（参见*3*）。
- en: '[![6](assets/6.png)](#co_image_tensors_CO10-6)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_image_tensors_CO10-6)'
- en: As of this writing, `resizeBilinear` returns a `float32`, which you have to
    convert.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，`resizeBilinear`返回一个`float32`，你需要进行转换。
- en: If you look closely at the result in [Figure 4-9](#resize), you can see sharp
    pixelation for the nearest neighbor and a softening blur for bilinear.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察[图4-9](#resize)中的结果，你会看到最近邻的像素呈现锐利的像素化，而双线性的呈现柔和的模糊效果。
- en: '![Resize methods](assets/ltjs_0409.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![调整大小方法](assets/ltjs_0409.png)'
- en: Figure 4-9\. Emoji with resize methods (for image license see [Appendix C](app03.html#appendix_c))
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-9\. 使用调整大小方法的表情符号（有关图像许可证，请参见[附录C](app03.html#appendix_c)）
- en: Warning
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Resizing with the nearest neighbor algorithm can be maliciously manipulated.
    If someone knew your final image size, they could construct a wicked image that
    looks different only at that resize. It’s called *adversarial preprocessing*.
    For more information see [*https://scaling-attacks.net*](https://scaling-attacks.net).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最近邻算法调整大小可能会被恶意操纵。如果有人知道你最终的图像尺寸，他们可以构建一个看起来只在那个调整大小时不同的邪恶图像。这被称为*对抗性预处理*。更多信息请参见[*https://scaling-attacks.net*](https://scaling-attacks.net)。
- en: If you want to see a stark contrast, you should try resizing the 4 x 3 image
    you created at the beginning of this chapter with both methods. Can you guess
    which method would create a checkerboard at the new size and which would not?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到鲜明对比，你应该尝试使用两种方法调整本章开头创建的4 x 3图像的大小。你能猜到哪种方法会在新尺寸上创建一个棋盘格，哪种方法不会吗？
- en: Cropping Image Tensors
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 裁剪图像张量
- en: For our final round of essential image tensor tasks, we’ll crop an image. I’d
    like to note, just like our mirror exercise earlier, there is a batch-friendly
    version of cropping large groups of images called `image.cropAndResize`. Know
    that this method exists and that you can utilize it for gathering and normalizing
    sections of images for training, e.g., grabbing all the faces detected in a photo
    and resizing them to the same input size for a model.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后一轮的基本图像张量任务中，我们将裁剪一幅图像。我想指出，就像我们之前的镜像练习一样，有一种适用于批量裁剪大量图像的版本，称为`image.cropAndResize`。知道这种方法的存在，你可以利用它来收集和规范化图像的部分用于训练，例如，抓取照片中检测到的所有人脸并将它们调整到相同的输入尺寸以供模型使用。
- en: For now, you’ll just do a simple example of carving out some tensor data from
    a 3D tensor. If you were to imagine this in space, it would be like carving a
    small rectangle slice from a larger rectangle cake.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你只需从3D张量中裁剪出一些张量数据的简单示例。如果你想象这在空间中，就像从一个更大的矩形蛋糕中切出一个小矩形薄片。
- en: 'You can carve out whatever portion you want in any axis by giving a starting
    position and size of our slice. You can access this example at [*simple/simple-image-manipulation/crop.html*
    on GitHub](https://oreil.ly/QDmBD). To crop a single image, use the following
    code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给定切片的起始位置和大小，你可以在任何轴上裁剪出你想要的任何部分。你可以在GitHub上的[*simple/simple-image-manipulation/crop.html*](https://oreil.ly/QDmBD)找到这个例子。要裁剪单个图像，请使用以下代码：
- en: '[PRE18]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_image_tensors_CO11-1)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_image_tensors_CO11-1)'
- en: Start `0` pixels down, `40` pixels over, and at the red channel.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从下方`0`像素开始，向右`40`像素，并且在红色通道上。
- en: '[![2](assets/2.png)](#co_image_tensors_CO11-2)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_image_tensors_CO11-2)'
- en: Grab the next `265` pixels height, `245` pixels width, and all three RGB values.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 获取接下来的`265`像素高度，`245`像素宽度，以及所有三个RGB值。
- en: '[![3](assets/3.png)](#co_image_tensors_CO11-3)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_image_tensors_CO11-3)'
- en: Pass everything into the `tf.slice` method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容传入`tf.slice`方法。
- en: The result is an exact crop of the original image, as you can see in [Figure 4-10](#crop).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是原始图像的精确裁剪，你可以在[图4-10](#crop)中看到。
- en: '![Crop tensor with slice](assets/ltjs_0410.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![使用切片裁剪张量](assets/ltjs_0410.png)'
- en: Figure 4-10\. Using `tf.slice` to crop a single image tensor
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-10\. 使用`tf.slice`裁剪单个图像张量
- en: New Image Tools
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的图像工具
- en: You just learned three of the most important image manipulation methods, but
    this is no limitation to what you can do. New AI models will require new image
    tensor functionality, and for that reason, TensorFlow.js and assistive libraries
    are continuously adding methods for handling and processing images. Now you can
    feel more comfortable utilizing and leaning on these tools in singular and batch
    forms.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了三种最重要的图像操作方法，但这并不意味着你的能力有所限制。新的AI模型将需要新的图像张量功能，因此，TensorFlow.js和辅助库不断添加用于处理和处理图像的方法。现在，你可以更加自如地在单个和批量形式中利用和依赖这些工具。
- en: Chapter Review
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节回顾
- en: 'Encoding and decoding images from an editable tensor gives you the ability
    to do pixel-by-pixel manipulation on a level few people could ever do. Of course,
    you’ve learned visual tensors for our goals in AI/ML, but there’s a significant
    bonus in the fact that if you wanted, you could experiment with wild image manipulation
    ideas. If you so desired, you could do any of the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从可编辑张量中编码和解码图像使你能够进行逐像素的操作，这是很少有人能做到的。当然，你已经学会了为了我们在AI/ML中的目标而学习视觉张量，但事实上，如果你愿意，你可以尝试各种疯狂的图像操作想法。如果你愿意，你可以做以下任何一种：
- en: Tile a pixel pattern of your making
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 铺设一个你自己设计的像素图案
- en: Subtract an image from another for an artistic design
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一幅图像中减去一幅图像以进行艺术设计
- en: Hide a message inside an image by manipulating pixel values
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过操纵像素值在图像中隐藏一条消息
- en: Code fractals or other mathematical visualizations
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写分形代码或其他数学可视化
- en: Remove a background image color like a green screen
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去除背景图像颜色，就像绿幕一样
- en: In this chapter, you harnessed the ability to create, load, render, modify,
    and save large tensors of structured data. Dealing with image tensors is not only
    easy; it’s quite rewarding. You’re ready for whatever comes your way.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你掌握了创建、加载、渲染、修改和保存大型结构化数据张量的能力。处理图像张量不仅简单，而且非常有益。你已经准备好迎接任何挑战。
- en: 'Chapter Challenge: Sorting Chaos'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节挑战：排序混乱
- en: 'Using the methods you learned in this chapter and previous chapters, you can
    do some pretty exciting and interesting things with tensors. While this challenge
    doesn’t have any specific utility that I can think of, it’s a fun exploration
    of what you’ve covered. As an exercise on lessons learned, muse over this problem:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您在本章和之前章节学到的方法，您可以用张量做一些非常令人兴奋和有趣的事情。虽然这个挑战没有我能想到的特定实用性，但它是对您所学内容的有趣探索。作为对所学课程的练习，请思考以下问题：
- en: How can you generate a random 400 x 400 grayscale tensor and then sort the random
    pixels along an axis?
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如何生成一个随机的400 x 400灰度张量，然后沿一个轴对随机像素进行排序？
- en: If you complete this challenge, the resulting tensor image will look like [Figure 4-11](#sorted).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成了这个挑战，生成的张量图像将会像[图4-11](#sorted)那样。
- en: '![A random noise tensor sorted](assets/ltjs_0411.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![一个随机噪声张量排序](assets/ltjs_0411.png)'
- en: Figure 4-11\. 400 x 400 randomness sorted across the width axis
  id: totrans-295
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-11\. 沿宽度轴排序的400 x 400随机性
- en: You can solve this problem using methods learned so far in this book. If you
    get stuck, review the [TensorFlow.js online documentation](https://js.tensorflow.org/api/latest).
    Searching the documentation for key terms will point you in the right direction.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用本书中学到的方法来解决这个问题。如果遇到困难，请查阅[TensorFlow.js在线文档](https://js.tensorflow.org/api/latest)。在文档中搜索关键词将指引您正确方向。
- en: You can find the answer to this challenge in [Appendix B](app02.html#appendix_b).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[附录B](app02.html#appendix_b)中找到这个挑战的答案。
- en: Review Questions
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Let’s review the lessons you’ve learned from the code you’ve written in this
    chapter. Take a moment to answer the following questions:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下您在本章编写的代码中学到的知识。请花点时间回答以下问题：
- en: If an image tensor contains values `0-255`, what kind of data type is needed
    for it to render correctly?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个图像张量包含值`0-255`，为了正确渲染它需要什么类型的数据？
- en: What would a 2 x 2 red `Float32` look like in tensor form?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个2 x 2的红色`Float32`在张量形式中会是什么样子？
- en: What would `tf.fill([100, 50, 1], 0.2)` create as an image tensor?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tf.fill([100, 50, 1], 0.2)`会创建什么样的图像张量？'
- en: 'True or false: to hold an RGBA image, you must use a rank-four image tensor.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：要保存一个RGBA图像，您必须使用一个四阶图像张量。
- en: 'True or false: `randomUniform`, if given the same input, will create the same
    output.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：`randomUniform`如果给定相同的输入，将会创建相同的输出。
- en: What is the method you should use to convert an image to a tensor in the browser?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中将图像转换为张量应该使用什么方法？
- en: When encoding a PNG in Node.js, what number should you use in the second parameter
    to get max compression?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Node.js中对PNG进行编码时，第二个参数应该使用什么数字以获得最大压缩？
- en: If you want to flip an image tensor upside down, how could you do that?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要将图像张量上下翻转，您该如何做？
- en: Which is faster?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个更快？
- en: Looping over a collection of images and resizing them
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历一组图像并调整它们的大小
- en: Batching a group of images as a rank-four tensor and resizing the entire tensor
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一组图像作为四阶张量进行批处理并调整整个张量的大小
- en: 'What is the rank and size of the result for:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下结果的秩和大小是多少：
- en: '[PRE19]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Solutions to these exercises are available in [Appendix A](app01.html#book_appendix).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的解决方案可以在[附录A](app01.html#book_appendix)中找到。
- en: ^([1](ch04.html#idm45049247514216-marker)) TensorFlow has a mistaken implementation
    of `alignCorners` that can be [problematic](https://oreil.ly/Ir9Gy).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#idm45049247514216-marker)) TensorFlow对`alignCorners`的实现存在错误，可能会有[问题](https://oreil.ly/Ir9Gy)。
