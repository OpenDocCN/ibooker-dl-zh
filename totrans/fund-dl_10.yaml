- en: Chapter 10\. Generative Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章. 生成模型
- en: Generative models attempt to understand the *latent*, or underlying, process
    that produces the data we see. For example, when breaking down images of digits
    in the MNIST dataset, we can interpret some attributes of the underlying process
    generating each image as the digit itself (a discrete variable ranging from zero
    through nine), the orientation or angle at which it will be drawn, the size of
    the resulting image, the thickness of the lines, and some noise component (all
    of which are continuous variables). So far, we’ve been concerned with *discriminative*
    models, either in the regression or classification setting. In the classification
    setting, discriminative models take as input an example such as an image from
    the MNIST dataset and attempt to determine the most likely digit category, from
    zero through nine, that the input belongs to. Generative models instead attempt
    to fully model the data distribution, and in the process may implicitly try to
    learn some of the features mentioned previously to generate images that look as
    if they were originally from the MNIST dataset. Note that generative modeling
    is a harder problem than discriminative modeling, as a discriminative model may,
    for example, need to learn only a few features well to distinguish between different
    digits in the MNIST dataset to a satisfactory degree. Generative models come in
    many varieties, and in this chapter, we provide a glimpse into a vast research
    landscape that has begun to blossom only in the past decade.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 生成模型试图理解产生我们所看到的数据的*潜在*或基础过程。例如，在分解MNIST数据集中的数字图像时，我们可以将生成每个图像的潜在过程的一些属性解释为数字本身（从零到九的离散变量）、将绘制图像的方向或角度、生成图像的大小、线条的粗细以及一些噪声成分（所有这些都是连续变量）。到目前为止，我们关注的是*鉴别*模型，无论是在回归还是分类设置中。在分类设置中，鉴别模型将MNIST数据集中的图像作为输入，并尝试确定输入最有可能属于的数字类别，从零到九。生成模型则尝试完全建模数据分布，并在此过程中可能隐含地尝试学习先前提到的一些特征，以生成看起来就像最初来自MNIST数据集的图像。请注意，生成建模比鉴别建模更难，因为例如，鉴别模型可能只需要很好地学习几个特征，以令人满意地区分MNIST数据集中不同数字之间的差异。生成模型有许多种类，在本章中，我们提供了一个瞥见过去十年才开始蓬勃发展的广阔研究领域。
- en: Generative Adversarial Networks
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成对抗网络
- en: '*Generative Adversarial Networks*, or GANs for short, are a form of generative
    model designed to produce realistic samples of entities, such as images, from
    noise. They were introduced by Goodfellow et al. in 2014.^([1](ch10.xhtml#idm45934165113648))
    For the remainder of this section, we will assume we are working with an image
    dataset such as MNIST or CIFAR-10\. The original GAN architecture is broken down
    into two neural networks: the *discriminator* and the *generator.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成对抗网络*，简称GANs，是一种旨在从噪声中生成逼真实体样本（如图像）的生成模型。它们由Goodfellow等人于2014年提出。在本节的其余部分，我们将假设我们正在处理图像数据集，如MNIST或CIFAR-10。原始的GAN架构被分解为两个神经网络：*鉴别器*和*生成器*。'
- en: The generator takes in samples from some noise distribution, such as a multivariate
    Gaussian distribution, and outputs an image. The discriminator is tasked with
    predicting whether this image was produced by the generator or was sampled from
    the original dataset. As the generator gets better and better at producing images
    that look real, the discriminator has a harder time determining whether a given
    image was produced by the generator or sampled from the dataset. We can think
    of these two networks as participating in a game, competing against each other
    to develop. Each network evolves until the generator can eventually produce images
    that look as if they were drawn directly from the original dataset, and the discriminator
    cannot distinguish between the two sets of images, i.e., predicts that any image
    is from the dataset with probability <math alttext="one-half"><mfrac><mn>1</mn>
    <mn>2</mn></mfrac></math> .
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器从一些噪声分布（如多元高斯分布）中获取样本，并输出一幅图像。鉴别器的任务是预测这幅图像是由生成器生成的，还是从原始数据集中抽样的。随着生成器越来越擅长生成看起来真实的图像，鉴别器越来越难以确定给定图像是由生成器生成的还是从数据集中抽样的。我们可以将这两个网络看作参与一场游戏，彼此竞争以发展。每个网络都会不断演化，直到生成器最终能够生成看起来就像直接从原始数据集中绘制出来的图像，而鉴别器无法区分这两组图像，即预测任何图像来自数据集的概率为1/2。
- en: More rigorously, we define the data distribution to be <math alttext="p Subscript
    data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> . Although we can
    never really know the true data distribution, in practice we generally think of
    it as being approximated well enough by the dataset we have on hand ( <math alttext="p
    Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    is just a uniform distribution over all of the images present in the dataset and
    zero likelihood associated with all images that are not in the dataset).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更严格地说，我们定义数据分布为p_data(x)。虽然我们永远无法真正了解真实的数据分布，但在实践中，我们通常认为我们手头的数据集足够好地近似了它（p_data(x)只是数据集中所有图像的均匀分布，并且与不在数据集中的所有图像相关联的可能性为零）。
- en: We additionally define the distribution parametrized by the generator to be
    <math alttext="p Subscript g Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    . The random variable *x* represents an entity such as an image, a collection
    of pixels that can each be thought of as their own random variables. The generator,
    which we also refer to as *G*, defines <math alttext="p Subscript g Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> by mapping samples from the noise distribution,
    which we will refer to as *p(z)*, to the data space, which consists of all possible
    images (not just those in the dataset). It is important to keep in mind that *G*
    itself is a deterministic function, but implicitly defines a distribution by acting
    on the noise distribution. Note that this distribution is implicit because we
    can generate samples from it only via *G(z),* rather than being an explicit distribution
    we can work with directly and query an image for its likelihood. [Figure 10-1](#the_discriminator_is_tasked_with_determining_whether_any_input)
    shows the typical GAN architecture.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们另外定义由生成器参数化的分布为<p<sub>g</sub>(x)>。随机变量*x*代表一个实体，比如一幅图像，一个由每个像素组成的集合，每个像素可以被视为自己的随机变量。我们也称之为*G*的生成器通过将从噪声分布中采样的样本映射到数据空间来定义<p<sub>g</sub>(x)，我们将其称为*p(z)*，数据空间包括所有可能的图像（不仅仅是数据集中的图像）。重要的是要记住*G*本身是一个确定性函数，但通过作用于噪声分布隐含地定义了一个分布。请注意，这个分布是隐含的，因为我们只能通过*G(z)*生成样本，而不能直接使用它并查询图像的可能性。[图10-1](#the_discriminator_is_tasked_with_determining_whether_any_input)展示了典型的GAN架构。
- en: '![](Images/fdl2_1001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1001.png)'
- en: Figure 10-1\. The discriminator determines whether any input image was sampled
    from the dataset or generator. The generator’s goal is to trick the discriminator
    into believing its images were sampled from the dataset.
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1。鉴别器确定任何输入图像是从数据集还是生成器中采样的。生成器的目标是欺骗鉴别器，使其相信其图像是从数据集中采样的。
- en: An optimal generator for a given dataset would also parametrize <math alttext="p
    Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , as this would perfectly confuse even the best discriminator. In other words,
    if the generator parametrizes the exact same distribution as that of the dataset
    and it is equally likely to sample from either the generator or the dataset, then
    no discriminator would be able to tell where the query originated from, as both
    are always equally likely. We formalize this intuition in the next paragraph.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定数据集的最佳生成器还会参数化<p<sub>data</sub>(x)，因为这将完全混淆甚至最好的鉴别器。换句话说，如果生成器参数化与数据集完全相同的分布，并且从生成器或数据集中采样的可能性相等，那么没有鉴别器能够告诉查询的来源，因为两者始终是同等可能的。我们将在下一段正式表达这种直觉。
- en: 'Thinking back to [Chapter 2](ch02.xhtml#fundamentals-of-proba), given a generator
    that parametrizes the same distribution as the dataset, we have <math alttext="p
    left-parenthesis x vertical-bar y equals generator right-parenthesis equals p
    left-parenthesis x vertical-bar y equals dataset right-parenthesis comma for-all
    x"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo> <mo>,</mo> <mo>∀</mo> <mi>x</mi></mrow></math>
    , where *y* is a Bernoulli random variable over the two options: generator or
    dataset. Note that we use <math alttext="p Subscript g Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> and <math alttext="p left-parenthesis
    x vertical-bar y equals generator right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow></math>
    interchangeably, and <math alttext="p Subscript data Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> and <math alttext="p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></math>
    interchangeably, since they mean the same thing. The latter option of each allows
    us to keep in mind we are working with conditional probabilities. Again, assuming
    that sampling from the generator and sampling from the dataset are equally likely,
    or <math alttext="p left-parenthesis y equals generator right-parenthesis equals
    p left-parenthesis y equals dataset right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo> <mo>=</mo> <mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></math>
    , we can use Bayes’ Rule to obtain the equality: <math alttext="p left-parenthesis
    y equals generator vertical-bar x right-parenthesis equals p left-parenthesis
    y equals dataset vertical-bar x right-parenthesis comma for-all x"><mrow><mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mo>∀</mo> <mi>x</mi></mrow></math>
    . Since there are only two options, as *y* is a Bernoulli random variable, we
    are left with the perfectly confused discriminator alluded to earlier that predicts
    any image to be sampled from the dataset with probability <math alttext="one-half"><mfrac><mn>1</mn>
    <mn>2</mn></mfrac></math> .'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第2章](ch02.xhtml#fundamentals-of-proba)，假设有一个生成器参数化与数据集相同的分布，我们有<math alttext="p
    left-parenthesis x vertical-bar y equals generator right-parenthesis equals p
    left-parenthesis x vertical-bar y equals dataset right-parenthesis comma for-all
    x"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo> <mo>,</mo> <mo>∀</mo> <mi>x</mi></mrow></math>，其中*y*是一个伯努利随机变量，有两个选项：生成器或数据集。请注意，我们可以互换使用<math
    alttext="p Subscript g Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>和<math
    alttext="p left-parenthesis x vertical-bar y equals generator right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo></mrow></math>，以及<math alttext="p Subscript data Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>和<math alttext="p left-parenthesis x
    vertical-bar y equals dataset right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></math>，因为它们表示相同的含义。每个后者选项让我们记住我们正在处理条件概率。再次假设从生成器采样和从数据集采样是同等可能的，或<math
    alttext="p left-parenthesis y equals generator right-parenthesis equals p left-parenthesis
    y equals dataset right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>generator</mtext> <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi>
    <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></math>，我们可以使用贝叶斯定理得到等式：<math
    alttext="p left-parenthesis y equals generator vertical-bar x right-parenthesis
    equals p left-parenthesis y equals dataset vertical-bar x right-parenthesis comma
    for-all x"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mo>∀</mo>
    <mi>x</mi></mrow></math>。由于只有两个选项，因为*y*是一个伯努利随机变量，我们得到了之前提到的完全混淆的鉴别器，预测任何图像被从数据集中采样的概率为<math
    alttext="one-half"><mfrac><mn>1</mn> <mn>2</mn></mfrac></math>。
- en: 'Knowing our end goal, we can now go about designing an objective function for
    training our generator and discriminator in tandem. In the original GAN paper,
    the objective presented was:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们的最终目标后，我们现在可以开始设计一个目标函数，用于同时训练我们的生成器和鉴别器。在原始的GAN论文中，提出的目标是：
- en: <math alttext="upper V left-parenthesis upper G comma upper D right-parenthesis
    equals double-struck upper E Subscript x tilde p Sub Subscript data Subscript
    left-parenthesis x right-parenthesis Baseline left-bracket log upper D left-parenthesis
    x right-parenthesis right-bracket plus double-struck upper E Subscript z tilde
    p left-parenthesis z right-parenthesis Baseline left-bracket log left-parenthesis
    1 minus upper D left-parenthesis upper G left-parenthesis z right-parenthesis
    right-parenthesis right-bracket"><mrow><mi>V</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><mi>z</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper V left-parenthesis upper G comma upper D right-parenthesis
    equals double-struck upper E Subscript x tilde p Sub Subscript data Subscript
    left-parenthesis x right-parenthesis Baseline left-bracket log upper D left-parenthesis
    x right-parenthesis right-bracket plus double-struck upper E Subscript z tilde
    p left-parenthesis z right-parenthesis Baseline left-bracket log left-parenthesis
    1 minus upper D left-parenthesis upper G left-parenthesis z right-parenthesis
    right-parenthesis right-bracket"><mrow><mi>V</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><mi>z</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
- en: '*G(z)* represents the mapping from the noise distribution to the data space
    described earlier, and *D(x)* represents the score assigned to the input image.
    *D(x)* is interpreted as the probability that the input image was drawn from the
    dataset. Of course, the discriminator *D* would like to maximize this objective—this
    corresponds with assigning high probabilities to images drawn from the dataset
    rather than images produced by the generator *G*. *G*, on the other hand, would
    like to minimize this objective, since that corresponds with producing realistic
    images, or even images that look exactly like those from the dataset, that confuse
    *D* and cause it to return a high score for these generator-produced images. This
    idea of maximizing the objective for one network and minimizing the objective
    for the other is termed *minimax,* and the optimization procedure looks like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*G(z)*代表从噪声分布到数据空间的映射，*D(x)*代表分配给输入图像的分数。*D(x)*被解释为输入图像来自数据集的概率。当然，鉴别器*D*希望最大化这个目标——这对应于为从数据集中绘制的图像分配高概率，而不是由生成器*G*生成的图像。另一方面，*G*希望最小化这个目标，因为这对应于生成逼真的图像，甚至是与数据集中的图像完全相同的图像，这会让*D*感到困惑，并导致它为这些生成器生成的图像返回高分数。这种最大化一个网络的目标和最小化另一个网络的目标的想法被称为*minimax*，优化过程如下：'
- en: <math alttext="min Subscript upper G Baseline max Subscript upper D Baseline
    double-struck upper E Subscript x tilde p Sub Subscript data Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log upper D left-parenthesis x right-parenthesis
    right-bracket plus double-struck upper E Subscript z tilde p left-parenthesis
    z right-parenthesis Baseline left-bracket log left-parenthesis 1 minus upper D
    left-parenthesis upper G left-parenthesis z right-parenthesis right-parenthesis
    right-bracket"><mrow><msub><mtext>min</mtext> <mi>G</mi></msub> <msub><mtext>max</mtext>
    <mi>D</mi></msub> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><mi>z</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="min Subscript upper G Baseline max Subscript upper D Baseline
    double-struck upper E Subscript x tilde p Sub Subscript data Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log upper D left-parenthesis x right-parenthesis
    right-bracket plus double-struck upper E Subscript z tilde p left-parenthesis
    z right-parenthesis Baseline left-bracket log left-parenthesis 1 minus upper D
    left-parenthesis upper G left-parenthesis z right-parenthesis right-parenthesis
    right-bracket"><mrow><msub><mtext>min</mtext> <mi>G</mi></msub> <msub><mtext>max</mtext>
    <mi>D</mi></msub> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><mi>z</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
- en: 'The paper goes on to show that, for a fixed generator *G,* the optimal discriminator
    trained under this objective would output the following score:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 论文继续展示，对于固定生成器*G*，在这个目标下训练的最优鉴别器将输出以下得分：
- en: <math alttext="StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis
    Over p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis
    Over p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
- en: for a given image *x*. First, we consider why this should even describe the
    behavior of an optimal discriminator given a fixed generator. Before we get into
    the “why,” it’s important to keep in mind that *D* can be alternatively represented
    as <math alttext="p Subscript theta Baseline left-parenthesis y equals dataset
    vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , or the discriminator’s belief that the image was drawn from the dataset. Here
    <math alttext="theta"><mi>θ</mi></math> represents the parameters, or weights,
    of *D.* When we perform an update operation such as gradient descent, <math alttext="theta"><mi>θ</mi></math>
    represents the set of weights that is being updated. It is important to keep in
    mind that this distribution is distinct from <math alttext="p left-parenthesis
    y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    mentioned earlier—the latter is the true probability that a given image was sampled
    from the dataset.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的图像*x*。首先，我们考虑为什么这应该描述一个固定生成器下最优鉴别器的行为。在我们深入“为什么”之前，重要的是要记住*D*可以被另外表示为<math
    alttext="p Subscript theta Baseline left-parenthesis y equals dataset vertical-bar
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>，或者鉴别器认为图像是从数据集中抽取的信念。这里<math
    alttext="theta"><mi>θ</mi></math>代表*D*的参数或权重。当我们执行诸如梯度下降的更新操作时，<math alttext="theta"><mi>θ</mi></math>代表正在更新的权重集。重要的是要记住，这个分布与之前提到的<math
    alttext="p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></math>是不同的——后者是给定图像从数据集中抽取的真实概率。
- en: The optimal discriminator can never know the exact origin of the image unless
    it is impossible for the generator to have produced the image, i.e., <math alttext="p
    Subscript g Baseline left-parenthesis x right-parenthesis equals 0"><mrow><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>
    . We can quantify the uncertainty in the discriminator’s prediction as a function
    of the image’s likelihood under the data distribution, or <math alttext="p Subscript
    data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> , and the image’s
    likelihood under the distribution defined by *G*, or <math alttext="p Subscript
    g Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> . If the image’s likelihood
    under the distribution defined by the generator is less than that of the data
    distribution, it makes sense that the optimal discriminator should be swayed accordingly
    and should score the image closer to one than zero.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最优鉴别器永远无法准确知道图像的确切来源，除非生成器无法产生图像，即<math alttext="p Subscript g Baseline left-parenthesis
    x right-parenthesis equals 0"><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>。我们可以量化鉴别器预测的不确定性，作为图像在数据分布下的可能性函数，或者<math
    alttext="p Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>，以及在*G*定义的分布下的图像可能性函数，或者<math
    alttext="p Subscript g Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>。如果图像在生成器定义的分布下的可能性小于数据分布下的可能性，那么最优鉴别器应该相应地受到影响，并且应该将图像评分更接近于一而不是零。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that a quick back-of-the-envelope check shows that this property is true
    for the score <math alttext="StartFraction p Subscript data Baseline left-parenthesis
    x right-parenthesis Over p Subscript data Baseline left-parenthesis x right-parenthesis
    plus p Subscript g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
    . But why is this the exact proportion by which the property is true? Let’s take
    a more concrete look at the score <math alttext="StartFraction p Subscript data
    Baseline left-parenthesis x right-parenthesis Over p Subscript data Baseline left-parenthesis
    x right-parenthesis plus p Subscript g Baseline left-parenthesis x right-parenthesis
    EndFraction"><mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
    and determine why this is the optimal function of the two probabilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个快速的估算显示这个性质对于得分<math alttext="StartFraction p Subscript data Baseline
    left-parenthesis x right-parenthesis Over p Subscript data Baseline left-parenthesis
    x right-parenthesis plus p Subscript g Baseline left-parenthesis x right-parenthesis
    EndFraction"><mfrac><msub><mi>p</mi> <mtext>data</mtext></msub> <mo>(</mo><mi>x</mi><mo>)</mo>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></math>是真实的。但为什么这个性质的确切比例是真实的呢？让我们更具体地看一下得分<math
    alttext="StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis
    Over p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mo>(</mo><mi>x</mi><mo>)</mo> <mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></math>并确定为什么这是两个概率的最优函数。
- en: 'Taking some inspiration from our discussion regarding the perfectly confused
    discriminator, we can alternatively express the proposed optimal discriminator
    score in terms of conditional probabilities:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们关于完全混淆的鉴别器的讨论中获得一些启示，我们可以用条件概率的术语来表达所提出的最优鉴别器得分：
- en: <math alttext="StartFraction p left-parenthesis x vertical-bar y equals dataset
    right-parenthesis Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    plus p left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction"><mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></math>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction p left-parenthesis x vertical-bar y equals dataset
    right-parenthesis Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    plus p left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction"><mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></math>
- en: 'Additionally, making the same assumption regarding equal likelihood of sampling
    from the dataset versus sampling from the generator ( <math alttext="p left-parenthesis
    y equals dataset right-parenthesis equals p left-parenthesis y equals generator
    right-parenthesis equals 0.5"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi>
    <mo>=</mo> <mtext>generator</mtext> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mo>.</mo>
    <mn>5</mn></mrow></math> ), we can get to a much more interpretable representation
    of the optimal score:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设从数据集中抽样与从生成器中抽样具有相同的概率（<math alttext="p left-parenthesis y equals dataset
    right-parenthesis equals p left-parenthesis y equals generator right-parenthesis
    equals 0.5"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn></mrow></math>），我们可以得到一个更具解释性的最优得分表示：
- en: <math alttext="upper D Superscript asterisk Baseline left-parenthesis x right-parenthesis
    equals StartFraction p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis plus
    p left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction"><mrow><msup><mi>D</mi>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper D Superscript asterisk Baseline left-parenthesis x right-parenthesis
    equals StartFraction p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis plus
    p left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction"><mrow><msup><mi>D</mi>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></mrow></math>
- en: <math alttext="equals StartFraction p left-parenthesis x vertical-bar y equals
    dataset right-parenthesis asterisk p left-parenthesis y equals dataset right-parenthesis
    Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis asterisk
    p left-parenthesis y equals dataset right-parenthesis plus p left-parenthesis
    x vertical-bar y equals generator right-parenthesis asterisk p left-parenthesis
    y equals generator right-parenthesis EndFraction"><mrow><mo>=</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals StartFraction p left-parenthesis x vertical-bar y equals
    dataset right-parenthesis asterisk p left-parenthesis y equals dataset right-parenthesis
    Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis asterisk
    p left-parenthesis y equals dataset right-parenthesis plus p left-parenthesis
    x vertical-bar y equals generator right-parenthesis asterisk p left-parenthesis
    y equals generator right-parenthesis EndFraction"><mrow><mo>=</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></mrow></math>
- en: <math alttext="equals StartFraction p left-parenthesis x comma y equals dataset
    right-parenthesis Over p left-parenthesis x right-parenthesis EndFraction"><mrow><mo>=</mo>
    <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals StartFraction p left-parenthesis x comma y equals dataset
    right-parenthesis Over p left-parenthesis x right-parenthesis EndFraction"><mrow><mo>=</mo>
    <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mrow></math>
- en: <math alttext="equals p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mo>=</mo>
    <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></math>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mo>=</mo>
    <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></math>
- en: The denominator in the third equality is a result of having marginalized out
    *y.* The final result is just the conditional probability of having sampled from
    the dataset given the input image. It makes sense that the optimal discriminator,
    <math alttext="p Subscript theta Sub Superscript asterisk Baseline left-parenthesis
    y equals dataset vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi> <msup><mi>θ</mi>
    <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> , should strive to match
    the true probability that the input image was drawn from the dataset, <math alttext="p
    left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></math> .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个等式中的分母是通过边缘化*y*得到的结果。最终结果只是在给定输入图像的情况下从数据集中抽样的条件概率。最优鉴别器，<math alttext="p
    Subscript theta Sub Superscript asterisk Baseline left-parenthesis y equals dataset
    vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi> <msup><mi>θ</mi> <mo>*</mo></msup></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math>，应该努力匹配输入图像来自数据集的真实概率，<math alttext="p left-parenthesis
    y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></math>。
- en: 'Now, we consider why the minimax objective defined earlier is maximized by
    <math alttext="p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></math> , or the true conditional probability of having drawn
    from the dataset given an image *x,* under the assumption of a fixed generator.
    Let’s take a closer look at the objective and try to reformulate it in a more
    informative manner that may provide us with some insight:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们考虑为什么之前定义的极小极大目标由<math alttext="p left-parenthesis y equals dataset vertical-bar
    x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></math>或在固定生成器的假设下给定图像*x*时从数据集中抽样的真实条件概率最大化。让我们仔细观察目标，并尝试以更具信息性的方式重新表述它，这可能为我们提供一些见解：
- en: <math alttext="upper V left-parenthesis upper G comma upper D right-parenthesis
    equals double-struck upper E Subscript x tilde p Sub Subscript data Subscript
    left-parenthesis x right-parenthesis Baseline left-bracket log upper D left-parenthesis
    x right-parenthesis right-bracket plus double-struck upper E Subscript z tilde
    p left-parenthesis z right-parenthesis Baseline left-bracket log left-parenthesis
    1 minus upper D left-parenthesis upper G left-parenthesis z right-parenthesis
    right-parenthesis right-bracket"><mrow><mi>V</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><mi>z</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper V left-parenthesis upper G comma upper D right-parenthesis
    equals double-struck upper E Subscript x tilde p Sub Subscript data Subscript
    left-parenthesis x right-parenthesis Baseline left-bracket log upper D left-parenthesis
    x right-parenthesis right-bracket plus double-struck upper E Subscript z tilde
    p left-parenthesis z right-parenthesis Baseline left-bracket log left-parenthesis
    1 minus upper D left-parenthesis upper G left-parenthesis z right-parenthesis
    right-parenthesis right-bracket"><mrow><mi>V</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><mi>z</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log p
    Subscript theta Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis
    right-bracket plus double-struck upper E Subscript p Sub Subscript phi Subscript
    left-parenthesis x vertical-bar y equals generator right-parenthesis Baseline
    left-bracket log left-parenthesis 1 minus p Subscript theta Baseline left-parenthesis
    y equals dataset vertical-bar x right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log p
    Subscript theta Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis
    right-bracket plus double-struck upper E Subscript p Sub Subscript phi Subscript
    left-parenthesis x vertical-bar y equals generator right-parenthesis Baseline
    left-bracket log left-parenthesis 1 minus p Subscript theta Baseline left-parenthesis
    y equals dataset vertical-bar x right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log p
    Subscript theta Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis
    right-bracket plus double-struck upper E Subscript p Sub Subscript phi Subscript
    left-parenthesis x vertical-bar y equals generator right-parenthesis Baseline
    left-bracket log left-parenthesis p Subscript theta Baseline left-parenthesis
    y equals generator vertical-bar x right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log p
    Subscript theta Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis
    right-bracket plus double-struck upper E Subscript p Sub Subscript phi Subscript
    left-parenthesis x vertical-bar y equals generator right-parenthesis Baseline
    left-bracket log left-parenthesis p Subscript theta Baseline left-parenthesis
    y equals generator vertical-bar x right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: As usual, we have formulated the objective in terms of conditional probabilities.
    To get from the first equality to the second, we note that taking the expectation
    with respect to the noise distribution *p(z)* and then applying a function such
    as *G* to each sample is equivalent to just taking the expectation with respect
    to the distribution over the data space defined by *G’s* mapping. This is similar
    in spirit to a concept we discussed in [Chapter 2](ch02.xhtml#fundamentals-of-proba),
    where random variables can be functions of other random variables. Also note the
    addition of the letter <math alttext="phi"><mi>φ</mi></math> starting from the
    second line—this letter represents the parameters, or weights, of *G.*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们已经用条件概率的术语制定了目标。从第一个等式到第二个等式，我们注意到，对于噪声分布*p(z)*的期望值，然后对每个样本应用*G*等函数，等效于对由*G*的映射定义的数据空间上的分布取期望值。这在精神上类似于我们在[第2章](ch02.xhtml#fundamentals-of-proba)中讨论过的一个概念，即随机变量可以是其他随机变量的函数。还要注意从第二行开始添加字母<math
    alttext="phi"><mi>φ</mi></math> ——这个字母代表*G*的参数或权重。
- en: 'Taking a closer look at the final expression, we start to see an awful lot
    of similarities between the objective and the concepts of entropy and cross entropy
    introduced in [Chapter 2](ch02.xhtml#fundamentals-of-proba). It turns out that
    we can manipulate the objective slightly without affecting the best <math alttext="theta"><mi>θ</mi></math>
    here to obtain a sum of the negatives of two cross-entropy terms:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察最终表达式，我们开始看到目标与熵和交叉熵的概念之间有很多相似之处，这些概念在[第2章](ch02.xhtml#fundamentals-of-proba)中介绍过。原来，我们可以稍微调整目标，而不影响最佳的θ，从而获得两个交叉熵项的负和的总和：
- en: <math alttext="theta Superscript asterisk Baseline equals argmin Subscript theta
    Baseline upper V left-parenthesis upper G comma upper D right-parenthesis"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <mi>V</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="theta Superscript asterisk Baseline equals argmin Subscript theta
    Baseline upper V left-parenthesis upper G comma upper D right-parenthesis"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <mi>V</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals argmin Subscript theta Baseline double-struck upper E
    Subscript x tilde p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    Baseline left-bracket log p Subscript theta Baseline left-parenthesis y equals
    dataset vertical-bar x right-parenthesis right-bracket plus double-struck upper
    E Subscript p Sub Subscript phi Subscript left-parenthesis x vertical-bar y equals
    generator right-parenthesis Baseline left-bracket log left-parenthesis p Subscript
    theta Baseline left-parenthesis y equals generator vertical-bar x right-parenthesis
    right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mtext>argmin</mtext>
    <mi>θ</mi></msub> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals argmin Subscript theta Baseline double-struck upper E
    Subscript x tilde p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    Baseline left-bracket log p Subscript theta Baseline left-parenthesis y equals
    dataset vertical-bar x right-parenthesis right-bracket plus double-struck upper
    E Subscript p Sub Subscript phi Subscript left-parenthesis x vertical-bar y equals
    generator right-parenthesis Baseline left-bracket log left-parenthesis p Subscript
    theta Baseline left-parenthesis y equals generator vertical-bar x right-parenthesis
    right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mtext>argmin</mtext>
    <mi>θ</mi></msub> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals argmin Subscript theta Baseline minus upper H left-parenthesis
    p left-parenthesis x comma y equals dataset right-parenthesis comma p Subscript
    theta Baseline left-parenthesis x comma y equals dataset right-parenthesis right-parenthesis
    minus upper H left-parenthesis p left-parenthesis x comma y equals generator right-parenthesis
    comma p Subscript theta Baseline left-parenthesis x comma y equals generator right-parenthesis
    right-parenthesis"><mrow><mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub>
    <mo>-</mo> <mi>H</mi> <mrow><mo>(</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>,</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo>
    <mi>H</mi> <mrow><mo>(</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>generator</mtext> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals argmin Subscript theta Baseline minus upper H left-parenthesis
    p left-parenthesis x comma y equals dataset right-parenthesis comma p Subscript
    theta Baseline left-parenthesis x comma y equals dataset right-parenthesis right-parenthesis
    minus upper H left-parenthesis p left-parenthesis x comma y equals generator right-parenthesis
    comma p Subscript theta Baseline left-parenthesis x comma y equals generator right-parenthesis
    right-parenthesis"><mrow><mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub>
    <mo>-</mo> <mi>H</mi> <mrow><mo>(</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>,</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo>
    <mi>H</mi> <mrow><mo>(</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>generator</mtext> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: As discussed in [Chapter 2](ch02.xhtml#fundamentals-of-proba), the cross entropy
    between two distributions is minimized when the two distributions are exactly
    the same—here we are doing the equivalent by simply maximizing the negative cross
    entropy instead. Thus, <math alttext="theta"><mi>θ</mi></math> achieves the optimal
    set of weights <math alttext="theta Superscript asterisk"><msup><mi>θ</mi> <mo>*</mo></msup></math>
    when <math alttext="p Subscript theta Baseline left-parenthesis x comma y equals
    dataset right-parenthesis equals p left-parenthesis x comma y equals dataset right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></mrow></math>
    and <math alttext="p Subscript theta Baseline left-parenthesis x comma y equals
    generator right-parenthesis equals p left-parenthesis x comma y equals generator
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow> <mo>=</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo></mrow></mrow></math> .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](ch02.xhtml#fundamentals-of-proba)中讨论的那样，两个分布之间的交叉熵在两个分布完全相同时被最小化——在这里，我们通过简单地最大化负交叉熵来实现等效。因此，<math
    alttext="theta"><mi>θ</mi></math> 在<math alttext="theta Superscript asterisk"><msup><mi>θ</mi>
    <mo>*</mo></msup></math>时实现了最优权重集<math alttext="theta Superscript asterisk"><msup><mi>θ</mi>
    <mo>*</mo></msup></math>，当<math alttext="p Subscript theta Baseline left-parenthesis
    x comma y equals dataset right-parenthesis equals p left-parenthesis x comma y
    equals dataset right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo></mrow></mrow></math>和<math alttext="p Subscript
    theta Baseline left-parenthesis x comma y equals generator right-parenthesis equals
    p left-parenthesis x comma y equals generator right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>generator</mtext> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow></mrow></math>。
- en: As our final step, we’d like to show that at <math alttext="theta Superscript
    asterisk"><msup><mi>θ</mi> <mo>*</mo></msup></math> , <math alttext="p Subscript
    theta Sub Superscript asterisk Baseline left-parenthesis y equals dataset vertical-bar
    x right-parenthesis equals p left-parenthesis y equals dataset vertical-bar x
    right-parenthesis"><mrow><msub><mi>p</mi> <msup><mi>θ</mi> <mo>*</mo></msup></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> as
    promised. We already know that <math alttext="p Subscript theta Sub Superscript
    asterisk Baseline left-parenthesis x comma y equals dataset right-parenthesis
    equals p left-parenthesis x comma y equals dataset right-parenthesis"><mrow><msub><mi>p</mi>
    <msup><mi>θ</mi> <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>)</mo></mrow></mrow></math> from our prior work. Dividing by *p(x)* on both
    sides leaves us with the desired result.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的最后一步，我们希望展示在<math alttext="theta Superscript asterisk"><msup><mi>θ</mi>
    <mo>*</mo></msup></math>时，<math alttext="p Subscript theta Sub Superscript asterisk
    Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis equals
    p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi>
    <msup><mi>θ</mi> <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math>，正如承诺的那样。我们已经知道<math alttext="p Subscript theta
    Sub Superscript asterisk Baseline left-parenthesis x comma y equals dataset right-parenthesis
    equals p left-parenthesis x comma y equals dataset right-parenthesis"><mrow><msub><mi>p</mi>
    <msup><mi>θ</mi> <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>)</mo></mrow></mrow></math>来自我们之前的工作。在两边都除以*p(x)*后，我们得到了期望的结果。
- en: 'So far, we have assumed a fixed *G*, and shown various properties regarding
    the optimal *D.* Unfortunately, we can’t assume a fixed *G* in practice, as we
    must train the generator as well as the discriminator. But now that we have shown
    some properties regarding the optimal *D,* we can begin to talk about the properties
    *G* must satisfy to achieve the global optimum—a generator that can perfectly
    confuse even the optimal discriminator. If we assume an optimal discriminator
    and plug in its score <math alttext="StartFraction p Subscript data Baseline left-parenthesis
    x right-parenthesis Over p Subscript data Baseline left-parenthesis x right-parenthesis
    plus p Subscript g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
    to the objective *V(G,D),* we obtain an objective that is solely dependent on
    the parameters, or weights, of *G*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经假设了一个固定的*G*，并展示了关于最优*D*的各种属性。不幸的是，在实践中我们不能假设一个固定的*G*，因为我们必须训练生成器和鉴别器。但是现在我们已经展示了一些关于最优*D*的属性，我们可以开始讨论*G*必须满足的属性，以实现全局最优——一个甚至可以完全混淆最优鉴别器的生成器。如果我们假设一个最优鉴别器，并将其得分<math
    alttext="StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis
    Over p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>代入目标*V(G,D)*，我们得到一个仅依赖于*G*的参数或权重的目标：
- en: <math alttext="upper C left-parenthesis upper G right-parenthesis equals double-struck
    upper E Subscript x tilde p Sub Subscript data Subscript left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p Subscript data Baseline left-parenthesis
    x right-parenthesis Over p Subscript data Baseline left-parenthesis x right-parenthesis
    plus p Subscript g Baseline left-parenthesis x right-parenthesis EndFraction right-bracket
    plus double-struck upper E Subscript x tilde p Sub Subscript g Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log left-parenthesis 1 minus StartFraction
    p Subscript data Baseline left-parenthesis x right-parenthesis Over p Subscript
    data Baseline left-parenthesis x right-parenthesis plus p Subscript g Baseline
    left-parenthesis x right-parenthesis EndFraction right-parenthesis right-bracket"><mrow><mi>C</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow> <mo>+</mo>
    <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mtext>log</mtext>
    <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C left-parenthesis upper G right-parenthesis equals double-struck
    upper E Subscript x tilde p Sub Subscript data Subscript left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p Subscript data Baseline left-parenthesis
    x right-parenthesis Over p Subscript data Baseline left-parenthesis x right-parenthesis
    plus p Subscript g Baseline left-parenthesis x right-parenthesis EndFraction right-bracket
    plus double-struck upper E Subscript x tilde p Sub Subscript g Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log left-parenthesis 1 minus StartFraction
    p Subscript data Baseline left-parenthesis x right-parenthesis Over p Subscript
    data Baseline left-parenthesis x right-parenthesis plus p Subscript g Baseline
    left-parenthesis x right-parenthesis EndFraction right-parenthesis right-bracket"><mrow><mi>C</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow> <mo>+</mo>
    <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mtext>log</mtext>
    <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript x tilde p Sub Subscript
    data Subscript left-parenthesis x right-parenthesis Baseline left-bracket log
    StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis Over
    p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction right-bracket plus
    double-struck upper E Subscript x tilde p Sub Subscript g Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log StartFraction p Subscript g Baseline
    left-parenthesis x right-parenthesis Over p Subscript data Baseline left-parenthesis
    x right-parenthesis plus p Subscript g Baseline left-parenthesis x right-parenthesis
    EndFraction right-bracket"><mrow><mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow> <mo>+</mo>
    <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mtext>log</mtext>
    <mfrac><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript x tilde p Sub Subscript
    data Subscript left-parenthesis x right-parenthesis Baseline left-bracket log
    StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis Over
    p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction right-bracket plus
    double-struck upper E Subscript x tilde p Sub Subscript g Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log StartFraction p Subscript g Baseline
    left-parenthesis x right-parenthesis Over p Subscript data Baseline left-parenthesis
    x right-parenthesis plus p Subscript g Baseline left-parenthesis x right-parenthesis
    EndFraction right-bracket"><mrow><mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow> <mo>+</mo>
    <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mtext>log</mtext>
    <mfrac><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log StartFraction
    p left-parenthesis x vertical-bar y equals dataset right-parenthesis Over p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis plus p Subscript phi Baseline
    left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction
    right-bracket plus double-struck upper E Subscript x tilde p Sub Subscript phi
    Subscript left-parenthesis x vertical-bar y equals generator right-parenthesis
    Baseline left-bracket log StartFraction p Subscript phi Baseline left-parenthesis
    x vertical-bar y equals generator right-parenthesis Over p left-parenthesis x
    vertical-bar y equals dataset right-parenthesis plus p Subscript phi Baseline
    left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction
    right-bracket"><mrow><mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow>
    <mrow><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log StartFraction
    p left-parenthesis x vertical-bar y equals dataset right-parenthesis Over p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis plus p Subscript phi Baseline
    left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction
    right-bracket plus double-struck upper E Subscript x tilde p Sub Subscript phi
    Subscript left-parenthesis x vertical-bar y equals generator right-parenthesis
    Baseline left-bracket log StartFraction p Subscript phi Baseline left-parenthesis
    x vertical-bar y equals generator right-parenthesis Over p left-parenthesis x
    vertical-bar y equals dataset right-parenthesis plus p Subscript phi Baseline
    left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction
    right-bracket"><mrow><mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow>
    <mrow><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow></mrow></math>
- en: We can now minimize this objective by optimizing over the generator weights
    <math alttext="phi"><mi>φ</mi></math> . We refer you to the original GAN paper
    for the rigorous derivation. However, as one might expect by now, it turns out
    that the optimal distribution *G* represents, or <math alttext="p Subscript g
    Sub Superscript asterisk Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <msup><mi>g</mi> <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , is equal to <math alttext="p Subscript data Baseline left-parenthesis x right-parenthesis
    comma for-all x"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>,</mo> <mo>∀</mo> <mi>x</mi></mrow></math> .
    This matches our original intuition regarding the perfectly confused discriminator
    and shows that the objective function proposed in the original GAN paper does
    indeed theoretically converge to this global optimum.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过优化生成器权重<math alttext="phi"><mi>φ</mi></math> 来最小化这个目标。我们建议您参考原始GAN论文进行严格推导。然而，正如现在可能已经预料到的那样，最优分布*G*代表，或者
    <math alttext="p Subscript g Sub Superscript asterisk Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <msup><mi>g</mi> <mo>*</mo></msup></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>，等于 <math alttext="p
    Subscript data Baseline left-parenthesis x right-parenthesis comma for-all x"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mo>∀</mo> <mi>x</mi></mrow></math>。这符合我们最初对完全迷惑鉴别器的直觉，并显示原始GAN论文中提出的目标函数确实在理论上收敛到这个全局最优解。
- en: Now that we have an optimal generator and discriminator, how do we perform image
    generation? All we need to do is sample from our noise distribution *p(z)* and
    run each sample through the generator. The generator, being optimal, should produce
    images that look as if they were drawn from the dataset itself. It may come as
    a surprise to you that the discriminator is no longer needed in this phase—but
    it has served its purpose. The discriminator played a key role in competing with
    the generator, each evolving until the latter could produce images that perfectly
    confused the discriminator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个最优的生成器和鉴别器，我们如何进行图像生成呢？我们只需要从我们的噪声分布*p(z)*中抽样，并将每个样本通过生成器运行。生成器，作为最优解，应该生成看起来就像是从数据集本身中绘制的图像。也许让你惊讶的是，在这个阶段鉴别器不再需要了，但它已经发挥了作用。鉴别器在与生成器竞争中发挥了关键作用，每个都在演变，直到后者能够生成完全迷惑鉴别器的图像。
- en: Note that unlike the standard interpretation of generative modeling, *z* does
    not represent a set of latent variables from which the data is generated. *z*
    simply plays the role of being a random variable distributed as one of our standard
    distributions, such as a uniform distribution or a standard multivariate Gaussian
    distribution, which are easy to sample from. *G,* when fully trained and optimal,
    is a complex, differentiable function that transforms samples from *p(z)* into
    samples from <math alttext="p Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , which approximates *p(x)*. In the next section, we will see the parallels between
    *G(z)* and the reparametrization trick, which also allows us to sample from a
    distribution by transforming samples (via a differentiable function) from a distribution
    that is easier to sample from.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与生成建模的标准解释不同，*z*并不代表一组生成数据的潜在变量。*z*只是扮演一个随机变量的角色，分布为我们的标准分布之一，比如均匀分布或标准多元高斯分布，这些分布易于抽样。当完全训练和优化时，*G*是一个复杂的、可微分的函数，将从*p(z)*中抽样的样本转换为从
    <math alttext="p Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    中抽样的样本，这个分布近似于*p(x)*。在下一节中，我们将看到*G(z)*和重参数化技巧之间的相似之处，这也允许我们通过从易于抽样的分布中转换样本（通过一个可微分函数）来抽样。
- en: Variational Autoencoders
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变分自动编码器
- en: In parallel to the introduction of GANs, Kingma and Welling introduced the *Variational
    Autoencoder*, or VAE for short, in their seminal paper, “Auto-Encoding Variational
    Bayes,” from 2014.^([2](ch10.xhtml#idm45934168472352)) The idea behind the VAE
    is more strongly rooted in probabilistic modeling than the aforementioned GAN.
    The VAE assumes there exists a set of unobserved latent variables, which we denote
    as *z*, that generate the data we see, which we denote as *x*. More formally,
    we say there exists a joint probability distribution *p(x,z)* over the latent
    variables *z* and the observed data *x* that factors as <math alttext="p left-parenthesis
    x vertical-bar z right-parenthesis p left-parenthesis z right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo> <mi>p</mi> <mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow></math> (see [Figure 10-2](#img1002)). Thinking back to [Chapter 2](ch02.xhtml#fundamentals-of-proba),
    this factorization is quite intuitive. Given the predefined roles of *z* and *x,*
    the universe in which *z* takes on some value and *x* is generated from this setting
    of *z* makes much more sense than the other way around.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与GAN的引入同时，Kingma和Welling在他们2014年的开创性论文“自动编码变分贝叶斯”中引入了*变分自动编码器*，简称VAE。VAE的理念更多地根植于概率建模，而不是前面提到的GAN。VAE假设存在一组未观察到的潜在变量，我们将其表示为*z*，生成我们看到的数据，我们将其表示为*x*。更正式地说，我们说存在一个联合概率分布*p(x,z)*，覆盖潜在变量*z*和观察到的数据*x*，这个分布可以分解为
    <math alttext="p left-parenthesis x vertical-bar z right-parenthesis p left-parenthesis
    z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi>
    <mo>)</mo> <mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo></mrow></math>（见[图10-2](#img1002)）。回想[第2章](ch02.xhtml#fundamentals-of-proba)，这种分解是非常直观的。考虑到*z*和*x*的预定义角色，*z*取某个值并且*x*从这个*z*的设置中生成的宇宙比另一种方式更有意义。
- en: '![](Images/fdl2_1002.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1002.png)'
- en: Figure 10-2\. z represents the latent variables from which every instance of
    *x* is generated. The arrow pointing from z to x signifies this relationship.
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-2。z代表生成每个*x*实例的潜在变量。从z指向x的箭头表示这种关系。
- en: '*x* could represent any sort of continuous or discrete data, including images.
    We additionally know the domain of *x* due to our knowledge of the dataset. *z,*
    on the other hand, is much more elusive. We have no idea what *z* looks like,
    so we make some initial assumptions about it. For example, we may assume that
    it initially takes the form of a Gaussian distribution, i.e., *p(z)* is Gaussian.
    Again, thinking back to [Chapter 2](ch02.xhtml#fundamentals-of-proba), we say
    that *p(z),* or our prior on *z,* is Gaussian.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we think about such a data-generation process, some natural probabilistic
    questions (should) come to mind. For example, what is the distribution <math alttext="p
    left-parenthesis z vertical-bar x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>z</mi> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></math> , or the posterior of
    *z* having known *x*? As we observe data, our beliefs regarding the underlying
    parameters often change. Take the coin flip experiment from [Chapter 2](ch02.xhtml#fundamentals-of-proba)
    as an example. We initially assumed a 50-50 chance of flipping heads, where the
    50-50 can be thought of as our latent parameter <math alttext="alpha"><mi>α</mi></math>
    —the parameter dictating the data generation procedure of sequences of heads and
    tails. This is a little simplified—in reality, we initially have a distribution
    over <math alttext="alpha"><mi>α</mi></math> , the probability of flipping heads,
    which is our prior distribution. Of course, the domain of the prior is the range
    [0,1], where it is logical to design the prior <math alttext="p left-parenthesis
    alpha right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>α</mi> <mo>)</mo></mrow></math>
    such that <math alttext="p left-parenthesis alpha equals 0.5 right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>α</mi> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mo>)</mo></mrow></math>
    is larger than all other settings of <math alttext="alpha"><mi>α</mi></math> .
    As we observed sequences of flips, we updated our prior via Bayes’ Theorem. In
    a similar manner, we initially assume *p(z)* to be a Gaussian distribution with
    some mean and variance; but as we observe data, we recalculate our belief in the
    form of a posterior, *p(z|x)* (see [Figure 10-3](#img1003)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Another question naturally comes to mind: what is the distribution *p(x|z),*
    or the likelihood of the data *x* given a certain setting of the latent variables
    *z*? In the coin flip setting, *p(x|z)* is easy to think about. Due to our complete
    knowledge of the experiment, we know the probability of any sequence is just the
    product of the probability of each flip, which is directly defined by *z*. In
    more intricate settings such as images, however, we can assume the relationship
    between the data *x* and the latent variables *z* is much more complicated than
    that. For example, when looking at images, it is clear that the value of a given
    pixel is quite affected by the values of its neighboring pixels and sometimes
    even by pixels much farther than one might think. The simple independence assumption
    we have for coin flips will not suffice for our purposes. This is just one reason
    why we can’t simply use a method like Bayes’ Theorem to learn a posterior over
    *z*—it requires much more knowledge regarding the system than what is immediately
    available to us.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fdl2_1003.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Here we have the coin flip experiment, where the prior is designed
    such that 0.5 has the highest likelihood. Once we see a series of heads and tails,
    the posterior shifts to the right due to there being more heads than tails.
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In variational autoencoders, we encode these distributions as neural networks,
    which can be seen as complex, nonlinear functions that can accurately model the
    relationships between latent variables *z* and the observed data *x*. We denote
    the neural network that outputs a distribution over the data given a setting of
    the latent variables, also termed the *decoder,* as <math alttext="p Subscript
    theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    , where <math alttext="theta"><mi>θ</mi></math> represents the weights of the
    neural network. In other words, the setting of <math alttext="theta"><mi>θ</mi></math>
    , in addition to the predetermined architecture of the neural network, completely
    define the model’s belief of the true distribution <math alttext="p left-parenthesis
    x vertical-bar z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo>
    <mi>z</mi> <mo>)</mo></mrow></math> . We optimize <math alttext="theta"><mi>θ</mi></math>
    to achieve a setting that is closest to that of the true distribution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在变分自动编码器中，我们将这些分布编码为神经网络，可以看作是复杂的非线性函数，可以准确地建模潜在变量z和观察数据x之间的关系。我们将输出给定潜在变量设置下数据分布的神经网络，也称为解码器，表示为<pθ(x|z)，其中θ代表神经网络的权重。换句话说，θ的设置，除了神经网络的预定架构外，完全定义了模型对真实分布p(x|z)的信念。我们优化θ以实现与真实分布最接近的设置。
- en: We additionally encode the posterior over *z*, or *p(z|x),* as a neural network.
    We denote this neural network, termed the *encoder,* as <math alttext="q Subscript
    phi Baseline left-parenthesis z vertical-bar x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    . Similarly to the decoder, we optimize <math alttext="phi"><mi>φ</mi></math>
    to achieve a setting that is closest to that of the true posterior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将后验z|x或p(z|x)编码为神经网络。我们将这个神经网络称为编码器，表示为qφ(z|x)。与解码器类似，我们优化φ以实现与真实后验最接近的设置。
- en: Kingma and Welling made some key observations that made the variational autoencoder
    a practical means for generative modeling ([Figure 10-4](#fig1004)). The first
    was that the *evidence lower bound* (ELBO for short), which is a lower bound on
    the true log likelihood of the data <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> , could be reformulated in a way
    that allowed for tractable optimization over the encoder and decoder parameters.
    The second was a reparametrization trick that enabled the computation of a low
    variance estimate of the gradient with respect to the parameters of the encoder,
    <math alttext="phi"><mi>φ</mi></math> . Although this may sound like a lot of
    jargon right now, we will go into each of these key observations in much more
    detail and concretely motivate the encoder-decoder architecture.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kingma和Welling做出了一些关键观察，使变分自动编码器成为生成建模的实用手段（图10-4）。第一点是*证据下界*（ELBO简称），它是数据真实对数似然的一个下界，可以重新表述为一种允许在编码器和解码器参数上进行可处理优化的方式。第二点是一种重新参数化技巧，使得能够计算关于编码器参数φ的梯度的低方差估计。尽管现在这听起来像是很多行话，我们将更详细地讨论这些关键观察，并具体说明编码器-解码器架构。
- en: '![](Images/fdl2_1004.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1004.png)'
- en: Figure 10-4\. The overall VAE architecture presented in Kingma and Welling.
    Note that both z and the image after the decoder are both samples from the encoder
    distribution and decoder distribution, respectively.
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-4。Kingma和Welling提出的整体VAE架构。请注意，z和解码器后的图像都是来自编码器分布和解码器分布的样本。
- en: 'Let’s assume we have observed some data *x*, where each individual example
    can be denoted as <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> . Note that we are still
    under the assumption that there exist some set of latent variables *z* generating
    the data we’ve seen. We split our analysis over the observed data into one over
    each individual example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> . We know there exists
    a true posterior over the latent variables <math alttext="p left-parenthesis z
    vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> , but we have no idea what that true posterior is. We
    assume it can be approximated by some distribution over the latent variables <math
    alttext="q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> , where *q* is a family of distributions in which
    optimization is much easier but complex enough to accurately model the true posterior.
    An example would be a multilayer neural network, which, as we’ve already seen,
    can be efficiently optimized via gradient descent and can represent complex, nonlinear
    functions. Note that each example <math alttext="x Superscript left-parenthesis
    i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    we’ve seen has some true probability of occurrence, which we can write as <math
    alttext="p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> . We instead work with <math alttext="log p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> , since this allows us to do some convenient decomposition
    into terms we’ve encountered before and doesn’t affect the verity of the optimization
    process:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们观察到一些数据 *x*，其中每个个体示例可以表示为 <math alttext="x 上标左括号 i 右括号"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>。请注意，我们仍然假设存在一组潜在变量 *z*
    生成我们所见的数据。我们将我们对观察到的数据的分析分为对每个个体示例 <math alttext="x 上标左括号 i 右括号"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> 的分析。我们知道存在一个真实的潜在变量后验
    <math alttext="p 左括号 z 竖线 x 上标左括号 i 右括号 Baseline 右括号"><mrow><mi>p</mi> <mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math>，但我们不知道真实的后验是什么。我们假设它可以通过一些潜在变量的分布来近似 <math alttext="q
    下标 phi Baseline 左括号 z 竖线 x 上标左括号 i 右括号 Baseline 右括号"><mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>，其中 *q* 是一个分布族，优化更容易，但足够复杂以准确建模真实的后验。一个例子是多层神经网络，正如我们已经看到的，可以通过梯度下降有效优化，并且可以表示复杂的非线性函数。请注意，我们所见的每个示例
    <math alttext="x 上标左括号 i 右括号"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    都有一定的发生概率，我们可以写为 <math alttext="p 左括号 x 上标左括号 i 右括号 Baseline 右括号"><mrow><mi>p</mi>
    <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math>。我们改为使用 <math alttext="log p 左括号 x 上标左括号 i 右括号 Baseline
    右括号"><mrow><mo form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math>，因为这使我们能够对我们之前遇到的项进行方便的分解，并且不会影响优化过程的真实性：
- en: <math alttext="log p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis equals log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="log p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis equals log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    plus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis minus log q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis"><mrow><mo>=</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>+</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    plus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis minus log q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis"><mrow><mo>=</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>+</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline comma z right-parenthesis minus
    log p left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis plus log q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    minus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow>
    <mo>+</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline comma z right-parenthesis minus
    log p left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis plus log q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    minus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow>
    <mo>+</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline comma z right-parenthesis
    Over q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis EndFraction right-bracket plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log StartFraction q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis Over p left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis EndFraction right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo><mi>z</mi><mo>)</mo></mrow>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><mi>p</mi><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline comma z right-parenthesis
    Over q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis EndFraction right-bracket plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log StartFraction q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis Over p left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis EndFraction right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo><mi>z</mi><mo>)</mo></mrow>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><mi>p</mi><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
- en: = <math alttext="ELBO plus KL left-parenthesis q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    StartAbsoluteValue EndAbsoluteValue p left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-parenthesis"><mrow><mtext>ELBO</mtext>
    <mo>+</mo> <mtext>KL</mtext> <mo>(</mo> <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>|</mo> <mo>|</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>)</mo></mrow></math>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: = <math alttext="ELBO 加 KL 左括号 q 下标 phi Baseline 左括号 z 竖线 x 上标左括号 i 右括号 Baseline
    右括号 StartAbsoluteValue EndAbsoluteValue p 左括号 z 竖线 x 上标左括号 i 右括号 Baseline 右括号
    右括号"><mrow><mtext>ELBO</mtext> <mo>+</mo> <mtext>KL</mtext> <mo>(</mo> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>|</mo> <mo>|</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>)</mo></mrow></math>
- en: 'The first step is to express the marginal likelihood of the individual example
    <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> as a function of the
    example itself and the latent factors *z.* As we learned earlier, the marginal
    likelihood can be broken down into a quotient of the joint distribution <math
    alttext="p left-parenthesis z comma x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>,</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>
    and the conditional distribution <math alttext="p left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> . The log function allows us to separate this quotient
    into a difference between the logs of the two terms. In the second step, we use
    a little trick that allows us to conveniently insert the approximate posterior
    into the equality—adding and subtracting the same term shouldn’t affect the equality.
    In the third step, we insert an expectation with respect to the approximate posterior.
    Why is this allowed? Well, a priori we know that <math alttext="log p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> is a constant. It is just the log of the probability
    of the example occurring under the true distribution, which is fixed. Thus, taking
    the expectation on both sides doesn’t change anything about the left side of the
    equation, since the expectation of a constant is just the constant itself. On
    the right side, we have now gotten closer to expressing the log of the marginal
    likelihood in terms that we’ve seen before. In the second to last step, we combine
    logs back into quotients and use the linearity of expectation to arrive at a sum
    of two terms: (1) the KL divergence between the approximate posterior and the
    true posterior, and (2) the ELBO, or the evidence lower bound.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将单个示例<math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>的边际似然表达为示例本身和潜在因子*z*的函数。正如我们之前学到的，边际似然可以分解为联合分布<math
    alttext="p left-parenthesis z comma x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>,</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>和条件分布<math
    alttext="p left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>|</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>的商。对数函数使我们能够将这个商分解为两个项的对数之间的差异。在第二步中，我们使用一个小技巧，使我们可以方便地将近似后验插入等式中——添加和减去相同的项不应影响等式。在第三步中，我们插入了对近似后验的期望。为什么允许这样做？嗯，我们事先知道<math
    alttext="log p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mo form="prefix">log</mo> <mi>p</mi> <mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>是一个常数。它只是在真实分布下发生示例的概率的对数，是固定的。因此，在等式的左侧进行期望不会改变任何东西，因为常数的期望就是常数本身。在右侧，我们现在已经更接近以前看到的用术语表达边际似然的对数。在倒数第二步中，我们将对数组合成商，并利用期望的线性性得到两个项的和：(1)
    近似后验与真实后验之间的KL散度，以及(2) ELBO，或证据下界。
- en: 'By now, you may have noticed that the form of the KL divergence is slightly
    different than what we encountered in [Chapter 2](ch02.xhtml#fundamentals-of-proba).
    Recall the standard KL divergence presented earlier, where the true distribution
    was *p(x)* and its approximation was *q(x)*. The KL divergence we defined was
    the difference between the cross entropy of the two distributions and the entropy
    of the true distribution, which was expressed as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到KL散度的形式与我们在[第2章](ch02.xhtml#fundamentals-of-proba)中遇到的略有不同。回想一下之前介绍的标准KL散度，其中真实分布是*p(x)*，其近似值是*q(x)*。我们定义的KL散度是两个分布的交叉熵与真实分布的熵之间的差异，表达如下：
- en: <math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p left-parenthesis x right-parenthesis
    Over q left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>𝔼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p left-parenthesis x right-parenthesis
    Over q left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>𝔼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
- en: We can see that the KL divergence in this derivation is the exact opposite.
    The expectation is with respect to the approximate posterior rather than the true
    posterior, and the numerator and denominator are flipped. Essentially what we
    see is <math alttext="double-struck upper E Subscript q left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction q left-parenthesis x right-parenthesis
    Over p left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>𝔼</mi>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
    instead of <math alttext="double-struck upper E Subscript p left-parenthesis x
    right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis x
    right-parenthesis Over q left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>𝔼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
    . We call this the *reverse KL divergence,* since the roles of the model and the
    truth have been switched, and is the quantity we attempt to minimize in VAEs.
    Although this does not have as clean a physical interpretation as the standard
    KL, note that the reverse KL divergence is *just a type of KL divergence* and
    retains all the properties we discussed in [Chapter 2](ch02.xhtml#fundamentals-of-proba).Thus,
    optimizing the reverse KL divergence still achieves a unique global minimum of
    zero when <math alttext="q left-parenthesis x right-parenthesis equals p left-parenthesis
    x right-parenthesis comma for-all x"><mrow><mi>q</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo>
    <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mo>∀</mo> <mi>x</mi></mrow></math>
    , so it is a valid objective to be optimizing over as it reaches its unique minimum
    when the approximate posterior is exactly the same as the true posterior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在这个推导中KL散度是完全相反的。期望是针对近似后验而不是真实后验，分子和分母被颠倒了。基本上我们看到的是<math alttext="double-struck
    upper E Subscript q left-parenthesis x right-parenthesis Baseline left-bracket
    log StartFraction q left-parenthesis x right-parenthesis Over p left-parenthesis
    x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>𝔼</mi> <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
    而不是<math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p left-parenthesis x right-parenthesis
    Over q left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>𝔼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
    。我们称之为*反向KL散度*，因为模型和真相的角色已经交换，这是我们在VAE中试图最小化的量。尽管这没有像标准KL那样清晰的物理解释，但请注意，反向KL散度*只是一种KL散度*，并保留了我们在[第2章](ch02.xhtml#fundamentals-of-proba)中讨论的所有属性。因此，优化反向KL散度仍然在<math
    alttext="q left-parenthesis x right-parenthesis equals p left-parenthesis x right-parenthesis
    comma for-all x"><mrow><mi>q</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo>
    <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mo>∀</mo> <mi>x</mi></mrow></math>时实现零的唯一全局最小值，因此它是一个有效的优化目标，因为当近似后验与真实后验完全相同时，它达到其唯一最小值。
- en: 'The reality, however, is that the true posterior <math alttext="p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> is still unknown to us. As a result, we can’t directly
    minimize any KL divergence with the true posterior. This is where the ELBO plays
    a key role. As we discussed earlier, <math alttext="log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo form="prefix">log</mo>
    <mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> is a constant. Thus, minimizing the reverse KL divergence
    is the same as maximizing the ELBO. The name evidence lower bound should make
    more sense now—as we maximize this term, it provides a better and better lower
    bound on the true log probability of the example. If we can develop a methodology
    for maximizing the ELBO efficiently, we should be well on our way to developing
    a generative model. Let’s reformulate the ELBO into terms that might be easier
    to work with:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实是真实后验<math alttext="p left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> 对我们仍然是未知的。因此，我们无法直接最小化任何KL散度与真实后验。这就是ELBO发挥关键作用的地方。正如我们之前讨论的，<math
    alttext="log p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mo form="prefix">log</mo> <mi>p</mi> <mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>是一个常数。因此，最小化反向KL散度等同于最大化ELBO。现在证据下界这个名字应该更有意义了——随着我们最大化这个项，它提供了一个越来越好的真实示例对数概率的下界。如果我们能够开发一种有效地最大化ELBO的方法，我们就应该在开发生成模型的道路上走得更顺利。让我们重新表述ELBO，使其更容易处理：
- en: <math alttext="double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline comma z right-parenthesis
    Over q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis EndFraction right-bracket equals
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis right-bracket"><mrow><msub><mi>𝔼</mi> <mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo><mi>z</mi><mo>)</mo></mrow>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline comma z right-parenthesis
    Over q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis EndFraction right-bracket equals
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis right-bracket"><mrow><msub><mi>𝔼</mi> <mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo><mi>z</mi><mo>)</mo></mrow>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    plus log p left-parenthesis z right-parenthesis minus log q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>+</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    plus log p left-parenthesis z right-parenthesis minus log q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>+</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket plus double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis z right-parenthesis
    minus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket plus double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis z right-parenthesis
    minus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket minus double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis Over p left-parenthesis z right-parenthesis
    EndFraction right-bracket"><mrow><mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow> <mo>-</mo> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></mfrac>
    <mo>]</mo></mrow></mrow></math>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket minus double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis Over p left-parenthesis z right-parenthesis
    EndFraction right-bracket"><mrow><mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow> <mo>-</mo> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></mfrac>
    <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals minus upper K upper L left-parenthesis q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue p left-parenthesis
    z right-parenthesis right-parenthesis plus double-struck upper E Subscript q Sub
    Subscript phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket"><mrow><mrow><mo>=</mo> <mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals minus upper K upper L left-parenthesis q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue p left-parenthesis
    z right-parenthesis right-parenthesis plus double-struck upper E Subscript q Sub
    Subscript phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket"><mrow><mrow><mo>=</mo> <mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></math>
- en: At this point, we can start to see the beginnings of an architecture and an
    optimization procedure for maximizing the ELBO. For example, the first term is
    just the reverse KL divergence between the approximate posterior and the prior,
    which we already assumed to be a Gaussian distribution. We can use a neural network,
    or encoder, to represent the approximate posterior. The reverse KL divergence
    acts as a regularization term on the approximate posterior, since maximizing the
    negative of the reverse KL is the same as minimizing the reverse KL. Regularization
    prevents the approximate posterior from straying too far from the prior distribution.
    This is desirable since we have witnessed only a single example, and thus we don’t
    want our belief over the latent variables to shift too much from our prior. The
    second term is the expected true log likelihood of the example given a setting
    of latent variables *z,* where *z* is sampled from the approximate posterior.
    Wanting to maximize this quantity with respect to <math alttext="phi"><mi>φ</mi></math>
    is intuitively reasonable. This influences the approximate posterior to assign
    higher likelihoods to settings of *z* that, in turn, explain the input example
    <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> as well as possible.
    The balancing act between regularization, which prevents overfitting, and maximum
    likelihood estimation, which on its own would reach an optimum where <math alttext="q
    Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> is just a point mass over the setting of *z* that
    best describes <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> , is a classic optimization
    procedure you’ve likely encountered in many data science and machine learning
    problems.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以开始看到一个架构和一个最大化ELBO的优化过程的开端。例如，第一项只是近似后验和先验之间的反向KL散度，我们已经假设为高斯分布。我们可以使用一个神经网络，或编码器，来表示近似后验。反向KL散度作为一个正则化项作用在近似后验上，因为最大化反向KL的负值等同于最小化反向KL。正则化防止近似后验偏离先验分布太远。这是可取的，因为我们只见过一个例子，因此我们不希望我们对潜在变量的信念从我们的先验中偏离太多。第二项是给定潜在变量*z*的设置的例子的期望真实对数似然，其中*z*是从近似后验中抽样的。希望相对于
    <math alttext="phi"><mi>φ</mi></math> 最大化这个数量是直观合理的。这影响近似后验分配更高的可能性给*z*的设置，反过来，解释输入例子
    <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>。在正则化和最大似然估计之间的平衡，防止过拟合，以及最大似然估计本身会达到一个最优点，其中
    <math alttext="q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> 只是一个最好描述 <math alttext="x Superscript left-parenthesis
    i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    的*z*设置的点质量，是一个经典的优化过程，你可能在许多数据科学和机器学习问题中遇到过。
- en: 'However, as noted earlier, we unfortunately don’t have access to the true conditional
    distribution <math alttext="p left-parenthesis x vertical-bar z right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></math> . Instead,
    we attempt to learn it using a second neural network—the decoder. We denote the
    parameters of the decoder as <math alttext="theta"><mi>θ</mi></math> and let the
    decoder represent the distribution <math alttext="p Subscript theta Baseline left-parenthesis
    x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> . In summary,
    we perform the following optimization procedure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如前面所指出的，我们不幸地无法访问真实的条件分布 <math alttext="p left-parenthesis x vertical-bar
    z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi>
    <mo>)</mo></mrow></math>。相反，我们尝试使用第二个神经网络——解码器来学习它。我们将解码器的参数表示为 <math alttext="theta"><mi>θ</mi></math>，并让解码器表示分布
    <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>。总之，我们执行以下优化过程：
- en: <math alttext="phi Superscript asterisk Baseline comma theta Superscript asterisk
    Baseline equals argmax Subscript phi comma theta Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log p Subscript theta Baseline left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket"><mrow><msup><mi>φ</mi> <mo>*</mo></msup> <mo>,</mo> <msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmax</mtext> <mrow><mi>φ</mi><mo>,</mo><mi>θ</mi></mrow></msub>
    <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="phi Superscript asterisk Baseline comma theta Superscript asterisk
    Baseline equals argmax Subscript phi comma theta Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log p Subscript theta Baseline left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket"><mrow><msup><mi>φ</mi> <mo>*</mo></msup> <mo>,</mo> <msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmax</mtext> <mrow><mi>φ</mi><mo>,</mo><mi>θ</mi></mrow></msub>
    <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: 'We’ve already discussed why this is a valid optimization procedure for the
    encoder parameters <math alttext="phi"><mi>φ</mi></math> , assuming that <math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis
    equals p left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    . Of course, this assumption is not satisfied at the beginning of training. However,
    as training progresses and <math alttext="theta"><mi>θ</mi></math> becomes more
    and more optimal, we eventually arrive at the desired theoretical optimization.
    But the question still remains: why is this a valid optimization procedure for
    <math alttext="theta"><mi>θ</mi></math> ? If we assume the encoder represents
    the true posterior distribution, we’d want to maximize the likelihood of recovering
    the original example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> from our encoder samples
    *z*. Of course, just like the optimization of <math alttext="phi"><mi>φ</mi></math>
    , our assumption about the approximate posterior is not satisfied at the beginning
    of training—but as training progresses and two networks improve jointly, we hope
    to eventually reach our goal.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过为什么这是对编码器参数φ的有效优化过程，假设pθ|x,z=p|x,z。当然，在训练开始时，这个假设并不成立。然而，随着训练的进行和θ变得越来越优化，我们最终会达到期望的理论优化。但问题仍然存在：为什么这是对θ的有效优化过程？如果我们假设编码器代表真实的后验分布，我们希望最大化从我们的编码器样本*z*中恢复原始示例xi的可能性。当然，就像对φ的优化一样，我们对近似后验的假设在训练开始时并不成立，但随着训练的进行和两个网络共同改进，我们希望最终达到我们的目标。
- en: 'This leads us into how to actually carry out the optimization. For <math alttext="theta"><mi>θ</mi></math>
    , it turns out we can use standard minibatch gradient descent techniques directly:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们如何实际进行优化。对于θ，事实证明我们可以直接使用标准的小批量梯度下降技术：
- en: <math alttext="normal nabla Subscript theta Baseline minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis plus double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>∇</mi>
    <mi>θ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript theta Baseline minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis plus double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>∇</mi>
    <mi>θ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript theta Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript theta Baseline double-struck upper E Subscript q Sub Subscript
    phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>θ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>∇</mi>
    <mi>θ</mi></msub> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript theta Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript theta Baseline double-struck upper E Subscript q Sub Subscript
    phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>θ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>∇</mi>
    <mi>θ</mi></msub> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript theta Baseline double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <mi>θ</mi></msub> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript theta Baseline double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <mi>θ</mi></msub> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket normal nabla Subscript theta
    Baseline log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>∇</mi> <mi>θ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket normal nabla Subscript theta
    Baseline log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>∇</mi> <mi>θ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="almost-equals StartFraction 1 Over n EndFraction sigma-summation
    Underscript j equals 1 Overscript n Endscripts normal nabla Subscript theta Baseline
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><mo>≈</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>∇</mi> <mi>θ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="almost-equals StartFraction 1 Over n EndFraction sigma-summation
    Underscript j equals 1 Overscript n Endscripts normal nabla Subscript theta Baseline
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><mo>≈</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>∇</mi> <mi>θ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: The first equality arises from the fact that the gradient of a sum of terms
    is equal to the sum of the gradients of each of the terms. Since the first term
    is not a function of <math alttext="theta"><mi>θ</mi></math> , its gradient with
    respect to <math alttext="theta"><mi>θ</mi></math> is 0, leading us to the second
    equality. From there we have the standard minibatch gradient estimate derivation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个等式源于一个事实，即一组项的梯度等于每个项的梯度之和。由于第一项不是θ的函数，它对θ的梯度为0，导致我们得到第二个等式。从那里我们有了标准的小批量梯度估计推导。
- en: 'The optimization with respect to <math alttext="phi"><mi>φ</mi></math> is not
    as simple. If we try to do the same for <math alttext="phi"><mi>φ</mi></math>
    as we did for <math alttext="theta"><mi>θ</mi></math> , we run into an unforeseen
    issue:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于φ的优化并不那么简单。如果我们尝试对φ做与θ相同的操作，我们会遇到一个意想不到的问题：
- en: <math alttext="normal nabla Subscript phi Baseline minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis plus double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>∇</mi>
    <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript phi Baseline minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis plus double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>∇</mi>
    <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript phi Baseline double-struck upper E Subscript q Sub Subscript
    phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>∇</mi>
    <mi>φ</mi></msub> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript phi Baseline double-struck upper E Subscript q Sub Subscript
    phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>∇</mi>
    <mi>φ</mi></msub> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript phi Baseline integral q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo>∫</mo> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript phi Baseline integral q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo>∫</mo> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    integral normal nabla Subscript phi Baseline q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo> <mo>∫</mo></mrow> <msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    integral normal nabla Subscript phi Baseline q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo> <mo>∫</mo></mrow> <msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
- en: 'In the last step, we can’t express the second term as an expectation. This
    is because the gradient is with respect to the parameters of the distribution
    from which we are sampling. We can’t simply switch the order of the expectation
    and gradient as we did for <math alttext="theta"><mi>θ</mi></math> . To get around
    this, we make the following observation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们无法将第二项表示为期望。这是因为梯度是针对我们抽样的分布的参数。我们不能像对θ那样简单地交换期望和梯度的顺序。为了解决这个问题，我们做出以下观察：
- en: <math alttext="normal nabla Subscript phi Baseline q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis equals normal nabla Subscript phi Baseline q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis asterisk StartFraction q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis Over q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    EndFraction"><mrow><msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>*</mo> <mfrac><mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow> <mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></mfrac></mrow></math>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript phi Baseline q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis equals normal nabla Subscript phi Baseline q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis asterisk StartFraction q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis Over q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    EndFraction"><mrow><msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>*</mo> <mfrac><mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow> <mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></mfrac></mrow></math>
- en: <math alttext="equals q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    asterisk StartFraction normal nabla Subscript phi Baseline q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis Over q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    EndFraction"><mrow><mo>=</mo> <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>*</mo> <mfrac><mrow><msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac></mrow></math>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    asterisk StartFraction normal nabla Subscript phi Baseline q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis Over q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    EndFraction"><mrow><mo>=</mo> <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>*</mo> <mfrac><mrow><msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac></mrow></math>
- en: <math alttext="equals q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    normal nabla Subscript phi Baseline log q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo>=</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <msub><mi>∇</mi>
    <mi>φ</mi></msub> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    normal nabla Subscript phi Baseline log q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo>=</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <msub><mi>∇</mi>
    <mi>φ</mi></msub> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
- en: 'With a bit of calculus and algebra, we have derived an equivalent form for
    the gradient. If we substitute this reformulation into the step we were stuck
    on:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点微积分和代数，我们得到了梯度的等价形式。如果我们将这种重述替换到我们卡住的步骤中：
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    integral q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis normal nabla Subscript
    phi Baseline log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo> <mo>∫</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    integral q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis normal nabla Subscript
    phi Baseline log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo> <mo>∫</mo></mrow> <msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket normal nabla Subscript phi Baseline log
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis log p Subscript theta Baseline
    left-parenthesis x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar
    z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>∇</mi> <mi>φ</mi></msub>
    <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket normal nabla Subscript phi Baseline log
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis log p Subscript theta Baseline
    left-parenthesis x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar
    z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>∇</mi> <mi>φ</mi></msub>
    <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="almost-equals normal nabla Subscript phi Baseline minus upper
    K upper L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    StartAbsoluteValue EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis
    plus StartFraction 1 Over n EndFraction sigma-summation Underscript j equals 1
    Overscript n Endscripts normal nabla Subscript phi Baseline log q Subscript phi
    Baseline left-parenthesis z equals z Subscript j Baseline vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><mo>≈</mo>
    <msub><mi>∇</mi> <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>j</mi></msub> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="almost-equals normal nabla Subscript phi Baseline minus upper
    K upper L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    StartAbsoluteValue EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis
    plus StartFraction 1 Over n EndFraction sigma-summation Underscript j equals 1
    Overscript n Endscripts normal nabla Subscript phi Baseline log q Subscript phi
    Baseline left-parenthesis z equals z Subscript j Baseline vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><mo>≈</mo>
    <msub><mi>∇</mi> <mi>φ</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>j</mi></msub> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: We can now use standard minibatch gradient estimation techniques to optimize
    our objective with respect to <math alttext="phi"><mi>φ</mi></math> . The observation
    we made is a well-known technique in the machine learning community termed the
    *log trick.* We will see this technique used again later in the chapter on reinforcement
    learning when we introduce the policy gradient method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用标准的小批量梯度估计技术来优化我们关于φ的目标。我们所做的观察是机器学习社区中一个众所周知的技术，称为*log技巧*。在强化学习章节中介绍策略梯度方法时，我们将再次看到这种技术的应用。
- en: 'Now that we have fully dissected the first observation that Kingma and Welling
    made, we now move to the second: the computation of a low variance estimate of
    the gradient with respect to <math alttext="phi"><mi>φ</mi></math> . As we mentioned
    earlier, the log trick allows us to estimate this gradient. However, this estimate
    has been shown to be of high variance. This means that if we were to run trials
    where, in each trial, we draw a few samples <math alttext="z Subscript j"><msub><mi>z</mi>
    <mi>j</mi></msub></math> from the approximate posterior and estimate the gradient
    with respect to <math alttext="phi"><mi>φ</mi></math> , we would expect to see
    vastly different estimates of the gradient across trials. Of course, this is undesirable,
    as we’d like trials for the same input example to be consistent with each other
    to have any confidence in our training procedure. We could try to ameliorate this
    by drawing many samples from the approximate posterior for each example, but this
    becomes computationally prohibitive for relatively little gain.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全剖析了Kingma和Welling提出的第一个观察，我们现在转向第二个观察：计算相对于 <math alttext="phi"><mi>φ</mi></math>
    的梯度的低方差估计。正如我们之前提到的，对数技巧使我们能够估计这个梯度。然而，已经证明这种估计具有很高的方差。这意味着如果我们进行试验，在每次试验中，我们从近似后验中抽取一些样本
    <math alttext="z Subscript j"><msub><mi>z</mi> <mi>j</mi></msub></math> 并估计相对于
    <math alttext="phi"><mi>φ</mi></math> 的梯度，我们预计在不同试验中会看到梯度的估计大不相同。当然，这是不可取的，因为我们希望对于相同的输入示例，试验之间保持一致，以对我们的训练过程有信心。我们可以尝试通过为每个示例从近似后验中抽取许多样本来改善这一点，但这对于相对较小的收益而言在计算上是不可行的。
- en: Kingma and Welling proposed an alternative method to the log trick for getting
    around the issue of taking the gradient with respect to the weights of the network
    parametrizing distribution from which we are sampling. This method is called the
    *reparametrization trick*, and it allows us to compute a low variance estimate
    of the gradient, as opposed to the log trick. Why this is the case is beyond the
    scope of this text, but we refer you to the vast amount of academic literature
    that exists on this and similar topics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kingma和Welling提出了一种绕过使用网络权重参数化分布的梯度的问题的对数技巧的替代方法。这种方法被称为*重新参数化技巧*，它允许我们计算梯度的低方差估计，与对数技巧相反。为什么会这样超出了本文的范围，但我们建议您参考存在于这个和类似主题上的大量学术文献。
- en: 'The reparametrization trick involves assuming the approximate posterior takes
    on some form, such as a multivariate Gaussian distribution, and then expressing
    this distribution as a function of another distribution that has no dependence
    on the weights of the encoder. Let’s assume that <math alttext="q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> takes on the form <math alttext="upper N left-parenthesis
    z semicolon ModifyingAbove mu With caret Subscript phi Baseline comma ModifyingAbove
    sigma With caret Subscript phi Superscript 2 Baseline upper I right-parenthesis"><mrow><mi>N</mi>
    <mo>(</mo> <mi>z</mi> <mo>;</mo> <msub><mover accent="true"><mi>μ</mi> <mo>^</mo></mover>
    <mi>φ</mi></msub> <mo>,</mo> <msubsup><mover accent="true"><mi>σ</mi> <mo>^</mo></mover>
    <mi>φ</mi> <mn>2</mn></msubsup> <mi>I</mi> <mo>)</mo></mrow></math> . This represents
    a multivariate Gaussian distribution where each component <math alttext="z Subscript
    i"><msub><mi>z</mi> <mi>i</mi></msub></math> is independent of all other components
    and <math alttext="z Subscript i Baseline tilde upper N left-parenthesis mu Subscript
    phi comma i Baseline comma sigma Subscript phi comma i Superscript 2 Baseline
    right-parenthesis"><mrow><msub><mi>z</mi> <mi>i</mi></msub> <mo>∼</mo> <mi>N</mi>
    <mrow><mo>(</mo> <msub><mi>μ</mi> <mrow><mi>φ</mi><mo>,</mo><mi>i</mi></mrow></msub>
    <mo>,</mo> <msubsup><mi>σ</mi> <mrow><mi>φ</mi><mo>,</mo><mi>i</mi></mrow> <mn>2</mn></msubsup>
    <mo>)</mo></mrow></mrow></math> , <math alttext="for-all i"><mrow><mo>∀</mo> <mi>i</mi></mrow></math>
    . We use <math alttext="phi"><mi>φ</mi></math> in the subscript to explicitly
    show the approximate posterior’s dependence on the parameters of the encoder through
    its mean and variance vectors, which are defined by the encoder. In its current
    form, we run into the issue of not being able to switch the order of the expectation
    and the gradient that we encountered earlier. Using the reparametrization trick,
    we can rewrite the sampling procedure as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重新参数化技巧涉及假设近似后验服从某种形式，比如多元高斯分布，然后将这个分布表示为另一个分布的函数，该分布不依赖于编码器的权重。假设 <math alttext="q
    Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi> <mi>φ</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> 采用形式 <math alttext="upper N left-parenthesis z
    semicolon ModifyingAbove mu With caret Subscript phi Baseline comma ModifyingAbove
    sigma With caret Subscript phi Superscript 2 Baseline upper I right-parenthesis"><mrow><mi>N</mi>
    <mo>(</mo> <mi>z</mi> <mo>;</mo> <msub><mover accent="true"><mi>μ</mi> <mo>^</mo></mover>
    <mi>φ</mi></msub> <mo>,</mo> <msubsup><mover accent="true"><mi>σ</mi> <mo>^</mo></mover>
    <mi>φ</mi> <mn>2</mn></msubsup> <mi>I</mi> <mo>)</mo></mrow></math> 。这代表一个多元高斯分布，其中每个分量
    <math alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math> 独立于所有其他分量，并且
    <math alttext="z Subscript i Baseline tilde upper N left-parenthesis mu Subscript
    phi comma i Baseline comma sigma Subscript phi comma i Superscript 2 Baseline
    right-parenthesis"><mrow><msub><mi>z</mi> <mi>i</mi></msub> <mo>∼</mo> <mi>N</mi>
    <mrow><mo>(</mo> <msub><mi>μ</mi> <mrow><mi>φ</mi><mo>,</mo><mi>i</mi></mrow></msub>
    <mo>,</mo> <msubsup><mi>σ</mi> <mrow><mi>φ</mi><mo>,</mo><mi>i</mi></mrow> <mn>2</mn></msubsup>
    <mo>)</mo></mrow></mrow></math>，对于所有 i。我们在下标中使用 <math alttext="phi"><mi>φ</mi></math>
    明确显示近似后验依赖于编码器参数的均值和方差向量，这些向量由编码器定义。在当前形式中，我们遇到了无法交换期望和梯度顺序的问题。使用重新参数化技巧，我们可以将抽样过程重写为：
- en: <math alttext="z tilde upper N left-parenthesis ModifyingAbove mu With caret
    Subscript phi Baseline comma ModifyingAbove sigma With caret Subscript phi Superscript
    2 Baseline upper I right-parenthesis left right double arrow z equals ModifyingAbove
    mu With caret Subscript phi Baseline plus ModifyingAbove sigma With caret Subscript
    phi Baseline asterisk epsilon comma epsilon tilde upper N left-parenthesis 0 comma
    upper I right-parenthesis"><mrow><mi>z</mi> <mo>∼</mo> <mi>N</mi> <mrow><mo>(</mo>
    <msub><mover accent="true"><mi>μ</mi> <mo>^</mo></mover> <mi>φ</mi></msub> <mo>,</mo>
    <msubsup><mover accent="true"><mi>σ</mi> <mo>^</mo></mover> <mi>φ</mi> <mn>2</mn></msubsup>
    <mi>I</mi> <mo>)</mo></mrow> <mo>⇔</mo> <mi>z</mi> <mo>=</mo> <msub><mover accent="true"><mi>μ</mi>
    <mo>^</mo></mover> <mi>φ</mi></msub> <mo>+</mo> <msub><mover accent="true"><mi>σ</mi>
    <mo>^</mo></mover> <mi>φ</mi></msub> <mo>*</mo> <mi>ϵ</mi> <mo>,</mo> <mi>ϵ</mi>
    <mo>∼</mo> <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>I</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="z tilde upper N left-parenthesis ModifyingAbove mu With caret
    Subscript phi Baseline comma ModifyingAbove sigma With caret Subscript phi Superscript
    2 Baseline upper I right-parenthesis left right double arrow z equals ModifyingAbove
    mu With caret Subscript phi Baseline plus ModifyingAbove sigma With caret Subscript
    phi Baseline asterisk epsilon comma epsilon tilde upper N left-parenthesis 0 comma
    upper I right-parenthesis"><mrow><mi>z</mi> <mo>∼</mo> <mi>N</mi> <mrow><mo>(</mo>
    <msub><mover accent="true"><mi>μ</mi> <mo>^</mo></mover> <mi>φ</mi></msub> <mo>,</mo>
    <msubsup><mover accent="true"><mi>σ</mi> <mo>^</mo></mover> <mi>φ</mi> <mn>2</mn></msubsup>
    <mi>I</mi> <mo>)</mo></mrow> <mo>⇔</mo> <mi>z</mi> <mo>=</mo> <msub><mover accent="true"><mi>μ</mi>
    <mo>^</mo></mover> <mi>φ</mi></msub> <mo>+</mo> <msub><mover accent="true"><mi>σ</mi>
    <mo>^</mo></mover> <mi>φ</mi></msub> <mo>*</mo> <mi>ϵ</mi> <mo>,</mo> <mi>ϵ</mi>
    <mo>∼</mo> <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>I</mi> <mo>)</mo></mrow></mrow></math>
- en: We highly encourage you to work out why the sampling procedure can be rewritten
    in this manner using the definition of the Gaussian distribution. It will be easier
    to consider the univariate case first, where *X* is a standard Gaussian random
    variable, and then show *Y = c*X* is a Gaussian random variable with mean zero
    and variance <math alttext="c squared"><msup><mi>c</mi> <mn>2</mn></msup></math>
    . Then, consider the general univariate case where *X* is any Gaussian random
    variable, and show *Y = X + c* is a Gaussian random variable with mean *E[X]*
    + *c* and variance *Var(X)*. Putting these steps together will get you to the
    reformulated sampling procedure described previously.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈鼓励您通过高斯分布的定义来解释为什么采样过程可以以这种方式重写。首先考虑单变量情况会更容易，其中*X*是一个标准高斯随机变量，然后展示*Y =
    c*X*是一个均值为零，方差为<math alttext="c squared"><msup><mi>c</mi> <mn>2</mn></msup></math>的高斯随机变量。然后，考虑*X*是任意高斯随机变量的一般单变量情况，并展示*Y
    = X + c*是一个均值为*E[X]* + *c*，方差为*Var(X)*的高斯随机变量。将这些步骤结合起来，您将得到先前描述的重构采样过程。
- en: 'In summary, we have expressed the approximate posterior as a function of a
    distribution that is independent of <math alttext="phi"><mi>φ</mi></math> , along
    with a mean vector and a standard deviation vector that are dependent on <math
    alttext="phi"><mi>φ</mi></math> . We term the random variable <math alttext="epsilon"><mi>ϵ</mi></math>
    an *auxiliary random variable.* Plugging this reformulation into our troublesome
    gradient expression from earlier:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们将近似后验表示为与<math alttext="phi"><mi>φ</mi></math>无关的分布函数，以及依赖于<math alttext="phi"><mi>φ</mi></math>的均值向量和标准差向量。我们将随机变量<math
    alttext="epsilon"><mi>ϵ</mi></math>称为*辅助随机变量*。将这种重构插入我们先前的棘手梯度表达式中：
- en: <math alttext="normal nabla Subscript phi Baseline double-struck upper E Subscript
    q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub Superscript
    left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline left-bracket
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>∇</mi>
    <mi>φ</mi></msub> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript phi Baseline double-struck upper E Subscript
    q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub Superscript
    left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline left-bracket
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>∇</mi>
    <mi>φ</mi></msub> <msub><mi>𝔼</mi> <mrow><msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline double-struck upper
    E Subscript epsilon tilde upper N left-parenthesis 0 comma upper I right-parenthesis
    Baseline left-bracket log p Subscript theta Baseline left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar g Subscript phi Baseline
    left-parenthesis epsilon right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>𝔼</mi> <mrow><mi>ϵ</mi><mo>∼</mo><mi>N</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline double-struck upper
    E Subscript epsilon tilde upper N left-parenthesis 0 comma upper I right-parenthesis
    Baseline left-bracket log p Subscript theta Baseline left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar g Subscript phi Baseline
    left-parenthesis epsilon right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <mi>φ</mi></msub> <msub><mi>𝔼</mi> <mrow><mi>ϵ</mi><mo>∼</mo><mi>N</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript epsilon tilde upper N
    left-parenthesis 0 comma upper I right-parenthesis Baseline left-bracket normal
    nabla Subscript phi Baseline log p Subscript theta Baseline left-parenthesis x
    Superscript left-parenthesis i right-parenthesis Baseline vertical-bar g Subscript
    phi Baseline left-parenthesis epsilon right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><mi>ϵ</mi><mo>∼</mo><mi>N</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript epsilon tilde upper N
    left-parenthesis 0 comma upper I right-parenthesis Baseline left-bracket normal
    nabla Subscript phi Baseline log p Subscript theta Baseline left-parenthesis x
    Superscript left-parenthesis i right-parenthesis Baseline vertical-bar g Subscript
    phi Baseline left-parenthesis epsilon right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><mi>ϵ</mi><mo>∼</mo><mi>N</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="almost-equals StartFraction 1 Over n EndFraction sigma-summation
    Underscript j equals 1 Overscript n Endscripts normal nabla Subscript phi Baseline
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar g Subscript phi Baseline left-parenthesis
    epsilon Subscript j Baseline right-parenthesis right-parenthesis"><mrow><mo>≈</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <msub><mi>ϵ</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="almost-equals StartFraction 1 Over n EndFraction sigma-summation
    Underscript j equals 1 Overscript n Endscripts normal nabla Subscript phi Baseline
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar g Subscript phi Baseline left-parenthesis
    epsilon Subscript j Baseline right-parenthesis right-parenthesis"><mrow><mo>≈</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>∇</mi> <mi>φ</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <msub><mi>ϵ</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: Where <math alttext="g Subscript phi Baseline left-parenthesis epsilon right-parenthesis
    equals ModifyingAbove mu With caret Subscript phi Baseline plus ModifyingAbove
    sigma With caret Subscript phi Baseline asterisk epsilon"><mrow><msub><mi>g</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mover
    accent="true"><mi>μ</mi> <mo>^</mo></mover> <mi>φ</mi></msub> <mo>+</mo> <msub><mover
    accent="true"><mi>σ</mi> <mo>^</mo></mover> <mi>φ</mi></msub> <mo>*</mo> <mi>ϵ</mi></mrow></math>
    . We rewrote *z* as <math alttext="g Subscript phi Baseline left-parenthesis epsilon
    right-parenthesis"><mrow><msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi>
    <mo>)</mo></mrow></mrow></math> to explicitly show that the dependence on the
    encoder parameters is now only through the deterministic function applied to the
    sampling distribution, rather than the sampling distribution itself. This allows
    us to switch the order of the expectation and the gradient seamlessly, thereby
    lending it to standard minibatch gradient estimation techniques.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<math alttext="g Subscript phi Baseline left-parenthesis epsilon right-parenthesis
    equals ModifyingAbove mu With caret Subscript phi Baseline plus ModifyingAbove
    sigma With caret Subscript phi Baseline asterisk epsilon"><mrow><msub><mi>g</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mover
    accent="true"><mi>μ</mi> <mo>^</mo></mover> <mi>φ</mi></msub> <mo>+</mo> <msub><mover
    accent="true"><mi>σ</mi> <mo>^</mo></mover> <mi>φ</mi></msub> <mo>*</mo> <mi>ϵ</mi></mrow></math>。我们将*z*重写为<math
    alttext="g Subscript phi Baseline left-parenthesis epsilon right-parenthesis"><mrow><msub><mi>g</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow></mrow></math>，明确显示了对编码器参数的依赖现在仅通过应用于采样分布的确定性函数，而不是采样分布本身。这使我们能够无缝切换期望和梯度的顺序，从而使其适用于标准的小批量梯度估计技术。
- en: How does this change manifest itself in the encoder architecture? Earlier, when
    using the log trick, we could directly parametrize the approximate posterior via
    the encoder. Now, we instead have the encoder, for each example <math alttext="x
    Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    , output a vector of means <math alttext="ModifyingAbove mu With caret Subscript
    phi"><msub><mover accent="true"><mi>μ</mi> <mo>^</mo></mover> <mi>φ</mi></msub></math>
    , a vector of standard deviations <math alttext="ModifyingAbove sigma With caret
    Subscript phi"><msub><mover accent="true"><mi>σ</mi> <mo>^</mo></mover> <mi>φ</mi></msub></math>
    , and sample <math alttext="epsilon"><mi>ϵ</mi></math> from a standard Gaussian
    distribution that is completely separate from the encoder-decoder VAE architecture.
    Note that the reparametrization technique comes with its own restrictions—we must
    assume a form for the approximate posterior, in this case a Gaussian, that allows
    us to define a differentiable function such as <math alttext="g Subscript phi"><msub><mi>g</mi>
    <mi>φ</mi></msub></math> . However, there’s no guarantee the true posterior is
    Gaussian—it is most likely a complex distribution that cannot be represented as
    functions of our standard distributions. This is a trade-off we must make to achieve
    a low variance gradient estimate for tractable optimization ([Figure 10-5](#fig1005)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化如何体现在编码器架构中？早期，当使用对数技巧时，我们可以通过编码器直接参数化近似后验。现在，我们改为编码器，对于每个示例<math alttext="x
    Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>，输出均值向量<math
    alttext="ModifyingAbove mu With caret Subscript phi"><msub><mover accent="true"><mi>μ</mi>
    <mo>^</mo></mover> <mi>φ</mi></msub></math>，标准差向量<math alttext="ModifyingAbove
    sigma With caret Subscript phi"><msub><mover accent="true"><mi>σ</mi> <mo>^</mo></mover>
    <mi>φ</mi></msub></math>，并从与编码器-解码器VAE架构完全分离的标准高斯分布中采样<math alttext="epsilon"><mi>ϵ</mi></math>。请注意，重新参数化技术有其自身的限制——我们必须假设近似后验的形式，本例中为高斯分布，这使我们能够定义一个可微函数，如<math
    alttext="g Subscript phi"><msub><mi>g</mi> <mi>φ</mi></msub></math>。然而，并没有保证真实后验是高斯分布——它很可能是一个复杂的分布，无法表示为我们标准分布的函数。这是我们必须做出的权衡，以获得可处理的优化的低方差梯度估计（[图10-5](#fig1005)）。
- en: '![](Images/fdl2_1005.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1005.png)'
- en: Figure 10-5\. What the encoder looks like after the inclusion of reparametrization.
    It returns a mean and standard deviation vector, which we can combine with ϵ to
    generate the setting of z. The purpose of the circle versus rectangles is to show
    that the only sampling is happening for ϵ, completely independent of the encoder
    architecture. The mean and standard deviation vectors are produced deterministically
    from the input image. In addition, z is deterministic once we know the value of
    ϵ.
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-5。在重新参数化后编码器的外观。它返回一个均值和标准差向量，我们可以将其与 ϵ 结合起来生成 z 的设置。圆形与矩形之间的区别在于 ϵ 的抽样是唯一发生的，完全独立于编码器架构。均值和标准差向量是确定性地从输入图像中产生的。此外，一旦我们知道
    ϵ 的值，z 就是确定性的。
- en: 'Note that the training procedure for a VAE is quite simple—the beast was in
    the motivation and mathematics behind the architecture and optimization. All we
    need to do is:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，VAE 的训练过程非常简单——其复杂性在于架构和优化背后的动机和数学。我们需要做的只是：
- en: Sample an example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> from the dataset.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据集中抽样一个示例 <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>。
- en: Run <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> through the encoder
    network to generate a vector of means <math alttext="ModifyingAbove mu With caret
    Subscript phi"><msub><mover accent="true"><mi>μ</mi> <mo>^</mo></mover> <mi>φ</mi></msub></math>
    and a vector of standard deviations <math alttext="ModifyingAbove sigma With caret
    Subscript phi"><msub><mover accent="true"><mi>σ</mi> <mo>^</mo></mover> <mi>φ</mi></msub></math>
    .
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编码器网络运行 <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> 生成一个均值向量 <math alttext="ModifyingAbove
    mu With caret Subscript phi"><msub><mover accent="true"><mi>μ</mi> <mo>^</mo></mover>
    <mi>φ</mi></msub></math> 和一个标准差向量 <math alttext="ModifyingAbove sigma With caret
    Subscript phi"><msub><mover accent="true"><mi>σ</mi> <mo>^</mo></mover> <mi>φ</mi></msub></math>。
- en: Sample <math alttext="epsilon"><mi>ϵ</mi></math> and calculate the result of
    <math alttext="g Subscript phi Baseline left-parenthesis epsilon right-parenthesis"><mrow><msub><mi>g</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽样 <math alttext="epsilon"><mi>ϵ</mi></math> 并计算 <math alttext="g Subscript
    phi Baseline left-parenthesis epsilon right-parenthesis"><mrow><msub><mi>g</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow></mrow></math>
    的结果。
- en: Run the result through the decoder network, which now represents the distribution
    <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z equals
    g Subscript phi Baseline left-parenthesis epsilon right-parenthesis right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo>
    <msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>ϵ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></math> .
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过解码器网络运行结果，现在表示分布 <math alttext="p Subscript theta Baseline left-parenthesis
    x vertical-bar z equals g Subscript phi Baseline left-parenthesis epsilon right-parenthesis
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>g</mi> <mi>φ</mi></msub> <mrow><mo>(</mo>
    <mi>ϵ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>。
- en: Query this distribution with our initial example <math alttext="x Superscript
    left-parenthesis i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    and take the log of the resulting likelihood. This will be our *decoder loss.*
    If you took multiple samples of <math alttext="epsilon"><mi>ϵ</mi></math> in step
    3, run the above procedure for each sample, and average to get the decoder loss.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们的初始示例 <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> 查询这个分布，并取结果似然的对数。这将是我们的
    *解码器损失*。如果在步骤3中对 <math alttext="epsilon"><mi>ϵ</mi></math> 进行了多次抽样，请对每个样本运行上述过程，并取平均值以获得解码器损失。
- en: Sum the decoder loss with <math alttext="minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis"><mrow><mo>-</mo> <mi>K</mi>
    <mi>L</mi> <mo>(</mo> <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>|</mo> <mo>|</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></math> , the *encoder loss,* to get a final
    loss. Use the negative of the final loss in the next step since we want to maximize
    it instead of minimize it.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解码器损失与 *编码器损失* <math alttext="minus upper K upper L left-parenthesis q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis"><mrow><mo>-</mo> <mi>K</mi>
    <mi>L</mi> <mo>(</mo> <msub><mi>q</mi> <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>|</mo> <mo>|</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></math> 相加，得到最终损失。在下一步中使用最终损失的负值，因为我们希望最大化它而不是最小化它。
- en: Perform classical SGD/minibatch gradient descent to update <math alttext="phi"><mi>φ</mi></math>
    and <math alttext="theta"><mi>θ</mi></math> .
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行经典的 SGD/小批量梯度下降来更新 <math alttext="phi"><mi>φ</mi></math> 和 <math alttext="theta"><mi>θ</mi></math>。
- en: Now that we have covered how to train a VAE, how do we utilize it as a generative
    model once it is trained? Note that we initially defined the generative process
    as <math alttext="p left-parenthesis x vertical-bar z right-parenthesis p left-parenthesis
    z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi>
    <mo>)</mo> <mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo></mrow></math> , where we
    start with some setting of the latent variables *z* sampled from the prior distribution
    and map *z* to an instance *x* in the data space via the conditional likelihood.
    We’ve already learned this generative process in the form of <math alttext="p
    Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    , or the decoder, and assumed the prior distribution <math alttext="p left-parenthesis
    z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo></mrow></math>
    to be a multivariate standard Gaussian at the beginning. To generate samples from
    a VAE, we sample <math alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>
    from the prior distribution *p(z),* pass this sample through the decoder so it
    now represents the distribution <math alttext="p Subscript theta Baseline left-parenthesis
    x vertical-bar z equals z Subscript i Baseline right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo>
    <msub><mi>z</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math> , and finally
    sample <math alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>
    from <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar
    z equals z Subscript i Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math> . Note that we no longer need
    the approximate posterior at this step—however, it played a key role in the training
    of the decoder and is still useful in understanding how our latent variable distribution
    shifts after witnessing an example from the dataset.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何训练VAE，那么一旦训练完成，我们如何将其用作生成模型呢？请注意，我们最初将生成过程定义为<math alttext="p left-parenthesis
    x vertical-bar z right-parenthesis p left-parenthesis z right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo> <mi>p</mi> <mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow></math>，其中我们从先验分布中对潜在变量*z*进行采样，并通过条件似然将*z*映射到数据空间中的实例*x*。我们已经学习了这个生成过程的形式<math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>，或者解码器，并假设先验分布<math
    alttext="p left-parenthesis z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow></math>最初是一个多元标准高斯分布。要从VAE生成样本，我们从先验分布*p(z)*中采样<math alttext="z
    Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>，将此样本通过解码器，使其现在表示分布<math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z equals z
    Subscript i Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>，最后从<math alttext="p Subscript
    theta Baseline left-parenthesis x vertical-bar z equals z Subscript i Baseline
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>中采样<math
    alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>。请注意，在这一步我们不再需要近似后验
    - 但是，在解码器的训练中起着关键作用，并且在理解我们的潜在变量分布在看到数据集中的示例后如何变化方面仍然很有用。
- en: Implementing a VAE
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现VAE
- en: In this section, we will build a VAE from scratch in PyTorch. We will additionally
    provide some example training and testing code on the famous MNIST digits dataset.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将在PyTorch中从头开始构建一个VAE。我们还将提供一些在著名的MNIST数字数据集上进行训练和测试的示例代码。
- en: 'Before we begin, here is a list of the packages you will need to reproduce
    this section on your own:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，这里是您需要的软件包列表，以便自己重现本节内容：
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s start with the encoder. As we discussed in the previous section, the encoder
    is a neural network that outputs a vector of means and a vector of standard deviations.
    Each index represents a univariate Gaussian, and the entire vector represents
    a multivariate Gaussian where each component is independent from the others. Though
    we are working with image data, for the sake of simplicity we convert each image
    into a vector by flattening it at the start. This allows us to apply standard,
    fully connected layers on the input. Since each image in the MNIST dataset is
    of size 28 × 28, each resulting representation is a 784-dimensional vector. We
    also need to decide on the number of components, or latent variables, we will
    use to represent the latent space. We can treat the number of components as a
    hyperparameter—if we notice that the decoder log likelihoods of input examples
    are consistently low even after a significant amount of training, this may indicate
    an approximate posterior that is not expressive enough. Increasing the number
    of components and retraining in this case is advisable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编码器开始。正如我们在上一节中讨论的，编码器是一个神经网络，它输出一组均值向量和一组标准差向量。每个索引代表一个单变量高斯分布，整个向量代表一个多元高斯分布，其中每个分量与其他分量独立。虽然我们处理的是图像数据，但为了简单起见，我们在开始时将每个图像展平为一个向量。这使我们能够在输入上应用标准的全连接层。由于MNIST数据集中的每个图像大小为28×28，因此每个结果表示是一个784维向量。我们还需要决定用于表示潜在空间的成分或潜在变量的数量。我们可以将成分的数量视为超参数
    - 如果我们注意到即使经过大量训练，输入示例的解码器对数似然仍然一直很低，这可能表明近似后验不够表达。在这种情况下增加成分的数量并重新训练是明智的。
- en: 'Here is example code for an encoder:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个编码器的示例代码：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the sake of simplicity, we leave out nonlinearities between the layers
    for now. Our encoder consists of two levels of layers. The first level operates
    on the input, embedding the vector into a lower dimensional representation. The
    second level operates on the 200-d representation and consists of two independent
    layers: one for determining the means of each of the univariate Gaussian components,
    and one for determining the standard deviations of each of the univariate Gaussian
    components. Here, we use 20 components. As we stated earlier, we assume <math
    alttext="q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> takes the form of a multivariate Gaussian, where
    each component is independent of the others. Note that attempting to learn a full
    covariance matrix is computationally prohibitive (amongst other concerns), as
    its size grows quadratically with the number of components.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们暂时忽略层之间的非线性。我们的编码器由两个级别的层组成。第一级别对输入进行操作，将向量嵌入到较低维度的表示中。第二级别对200维表示进行操作，由两个独立的层组成：一个用于确定每个单变量高斯分量的均值，一个用于确定每个单变量高斯分量的标准差。在这里，我们使用20个分量。正如我们之前所述，我们假设<math
    alttext="q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>φ</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>采用多元高斯的形式，其中每个分量独立于其他分量。请注意，尝试学习完整的协方差矩阵在计算上是不可行的（除其他问题外），因为其大小随分量数量的增加呈二次增长。
- en: 'Here is example code for a decoder:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解码器的示例代码：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, we leave out the nonlinearities for the sake of simplicity. The decoder
    operates on the sampled *z*, which we know is a 20-d vector. The rest of the decoder
    architecture is symmetrical to the encoder, and outputs a distribution over the
    input data. Although not in the code just yet, there is a final sigmoid layer
    that will be applied to the output of the `recon_output` layer which, recall,
    squashes each input dimension into the range (0,1). Since we are working with
    the discrete MNIST dataset where each pixel is represented as either a zero or
    a one, the output of the final sigmoid layer is used to represent a Bernoulli
    distribution for each pixel. Recall the Bernoulli distribution from [Chapter 2](ch02.xhtml#fundamentals-of-proba),
    represented as *Ber(p),* where *p* is the probability of returning a one and 1
    *– p* is the the probability of returning a zero.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们再次忽略非线性。解码器操作采样的*z*，我们知道它是一个20维向量。解码器的其余架构与编码器对称，并输出输入数据的分布。尽管代码中还没有，但最终会应用一个sigmoid层到`recon_output`层的输出上，回想一下，它将每个输入维度压缩到范围(0,1)。由于我们使用离散的MNIST数据集，其中每个像素表示为零或一，最终sigmoid层的输出用于表示每个像素的伯努利分布。回想一下[第2章](ch02.xhtml#fundamentals-of-proba)中的伯努利分布，表示为*Ber(p)*，其中*p*是返回一的概率，1-*p*是返回零的概率。
- en: 'More formally, we have that the decoder likelihood distribution <math alttext="p
    Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    can be rewritten as a product over each pixel:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地，我们有解码器的似然分布<math alttext="p Subscript theta Baseline left-parenthesis x
    vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>可以重写为每个像素的乘积：
- en: <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z
    right-parenthesis equals product Underscript j equals 1 Overscript 784 Endscripts
    p Subscript theta Baseline left-parenthesis x Subscript j Baseline vertical-bar
    z right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>∏</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup> <msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>|</mo>
    <mi>z</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z
    right-parenthesis equals product Underscript j equals 1 Overscript 784 Endscripts
    p Subscript theta Baseline left-parenthesis x Subscript j Baseline vertical-bar
    z right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>∏</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup> <msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>|</mo>
    <mi>z</mi> <mo>)</mo></mrow></mrow></math>
- en: where <math alttext="p left-parenthesis x Subscript j Baseline vertical-bar
    z right-parenthesis equals upper B e r left-parenthesis decoder left-parenthesis
    z right-parenthesis Subscript j Baseline right-parenthesis"><mrow><mi>p</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mi>j</mi></msub> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>B</mi> <mi>e</mi> <mi>r</mi> <mrow><mo>(</mo> <mtext>decoder</mtext> <msub><mrow><mo>(</mo><mi>z</mi><mo>)</mo></mrow>
    <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<math alttext="p left-parenthesis x Subscript j Baseline vertical-bar z right-parenthesis
    equals upper B e r left-parenthesis decoder left-parenthesis z right-parenthesis
    Subscript j Baseline right-parenthesis"><mrow><mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>j</mi></msub> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>B</mi>
    <mi>e</mi> <mi>r</mi> <mrow><mo>(</mo> <mtext>decoder</mtext> <msub><mrow><mo>(</mo><mi>z</mi><mo>)</mo></mrow>
    <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: Note that decoder(*z*) represents the 784-d vector after applying the sigmoid
    layer. For a given pixel <math alttext="x Subscript j Superscript left-parenthesis
    i right-parenthesis"><msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></math>
    in the input example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> , we’d like its corresponding
    probability *p* to be close to one if <math alttext="x Subscript j Superscript
    left-parenthesis i right-parenthesis Baseline equals 1"><mrow><msubsup><mi>x</mi>
    <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>=</mo> <mn>1</mn></mrow></math>
    , and its corresponding probability *p* to be close to zero if <math alttext="x
    Subscript j Superscript left-parenthesis i right-parenthesis Baseline equals 0"><mrow><msubsup><mi>x</mi>
    <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>=</mo> <mn>0</mn></mrow></math>
    . As you may recall from the previous section, we work with <math alttext="log
    p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><mo
    form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> , which reduces to <math
    alttext="sigma-summation Underscript j equals 1 Overscript 784 Endscripts log
    p Subscript theta Baseline left-parenthesis x Subscript j Baseline vertical-bar
    z right-parenthesis"><mrow><msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mn>784</mn></msubsup> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，decoder(*z*)表示应用Sigmoid层后的784维向量。对于输入示例<math alttext="x Subscript j Superscript
    left-parenthesis i right-parenthesis"><msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></math>
    中的给定像素<math alttext="x Subscript j Superscript left-parenthesis i right-parenthesis"><msubsup><mi>x</mi>
    <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></math> ，我们希望其对应的概率*p*在<math
    alttext="x Subscript j Superscript left-parenthesis i right-parenthesis Baseline
    equals 1"><mrow><msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup>
    <mo>=</mo> <mn>1</mn></mrow></math>时接近于1，而在<math alttext="x Subscript j Superscript
    left-parenthesis i right-parenthesis Baseline equals 0"><mrow><msubsup><mi>x</mi>
    <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>=</mo> <mn>0</mn></mrow></math>时接近于0。正如您可能从上一节中记得的那样，我们使用<math
    alttext="log p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><mo
    form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> ，这可以简化为<math alttext="sigma-summation
    Underscript j equals 1 Overscript 784 Endscripts log p Subscript theta Baseline
    left-parenthesis x Subscript j Baseline vertical-bar z right-parenthesis"><mrow><msubsup><mo>∑</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> 。
- en: 'Now, we can put the encoder and decoder together into a single VAE architecture:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将编码器和解码器放在一起，构建一个单一的VAE架构：
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The call to encode is followed by the call to decode in the forward function.
    Note that decode uses only a single sample from the approximate posterior, as
    we found that a single sample is sufficient for the MNIST dataset, but this can
    be easily modified to work for multiple samples. To calculate the reverse KL,
    the forward function returns the results of the encode call in addition to the
    decoder likelihood distribution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前向函数中，对encode的调用后面是对decode的调用。请注意，decode仅使用来自近似后验的单个样本，因为我们发现对于MNIST数据集，单个样本就足够了，但这可以很容易地修改为适用于多个样本。为了计算反向KL散度，前向函数返回了encode调用的结果以及解码器的似然分布的结果。
- en: 'Here is example code for computing the loss:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是计算损失的示例代码：
- en: '[PRE4]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We recommend you take a look at the PyTorch documentation for `nn.BCELoss`
    and verify that it is indeed computing the negative log likelihood of the input
    example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> : <math alttext="minus
    sigma-summation Underscript j equals 1 Overscript 784 Endscripts log p Subscript
    theta Baseline left-parenthesis x Subscript j Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis"><mrow><mo>-</mo> <msubsup><mo>∑</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msubsup><mi>x</mi> <mi>j</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    . We also recommend you verify that the `kl_loss` term is the reverse KL divergence
    between two Gaussian distributions as derived in Kingma and Welling. Returning
    the sum of the negative log likelihood and the reverse KL divergence as a final
    loss term gets us to the end of step 6 from the previous section. Finally, for
    some training code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您查看PyTorch文档中关于`nn.BCELoss`的内容，并验证它是否确实计算了输入示例<math alttext="x Superscript
    left-parenthesis i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    的负对数似然： <math alttext="minus sigma-summation Underscript j equals 1 Overscript
    784 Endscripts log p Subscript theta Baseline left-parenthesis x Subscript j Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis"><mrow><mo>-</mo>
    <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> 。我们还建议您验证`kl_loss`项是否是Kingma和Welling中推导的两个高斯分布之间的反向KL散度。将负对数似然和反向KL散度的总和作为最终损失项返回，使我们达到了上一节中第6步的结尾。最后，一些训练代码：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we train the VAE for 10 epochs, saving the state of the VAE at the end
    of each epoch. Note that we set some hyperparameters fixed here, such as the learning
    rate of the optimizer and the number of latent variables. We recommend writing
    some validation code, in addition to the training code presented here, to select
    the best hyperparameter settings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们训练VAE 10个epochs，保存每个epoch结束时的VAE状态。请注意，我们在这里固定了一些超参数，比如优化器的学习率和潜变量的数量。我们建议编写一些验证代码，除了这里呈现的训练代码，以选择最佳的超参数设置。
- en: 'Finally, how can we test the generative capabilities of our fully trained VAE?
    We know that the generative process can be written as *p(z)p(x|z),* where we first
    draw a sample <math alttext="z Subscript j"><msub><mi>z</mi> <mi>j</mi></msub></math>
    from our prior, run the sample through the decoder so the decoder’s likelihood
    distribution now represents <math alttext="p Subscript theta Baseline left-parenthesis
    x vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo>
    <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math> , and sample
    <math alttext="x Subscript j"><msub><mi>x</mi> <mi>j</mi></msub></math> from this
    distribution. Here is the code that puts this logic into action:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们如何测试我们完全训练的VAE的生成能力？我们知道生成过程可以写成*p(z)p(x|z)*，其中我们首先从先验中抽取一个样本<math alttext="z
    Subscript j"><msub><mi>z</mi> <mi>j</mi></msub></math>，将样本通过解码器运行，使解码器的似然分布现在表示为<math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z equals z
    Subscript j Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>，然后从该分布中抽取<math alttext="x Subscript
    j"><msub><mi>x</mi> <mi>j</mi></msub></math>。以下是将此逻辑付诸实践的代码：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `for` loop generates 100 samples from the approximate posterior, and for
    each of those samples, a sample from the corresponding decoder likelihood distribution
    over the input data. The last couple of lines of code allow us to save the samples
    in a 10 × 10 grid, depicted in [Figure 10-6](#hundred_samples_from_a_vae_trained_on_the_mnist_dataset).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环从近似后验中生成100个样本，对于每个样本，从相应的解码器似然分布中抽取输入数据的样本。代码的最后几行允许我们将样本保存在一个10×10的网格中，如[图10-6](#hundred_samples_from_a_vae_trained_on_the_mnist_dataset)所示。'
- en: '![](Images/fdl2_1006.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1006.png)'
- en: Figure 10-6\. 100 samples from a VAE trained on the MNIST dataset for 10 epochs.
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-6. 在MNIST数据集上训练的VAE生成的100个样本，训练了10个epochs。
- en: Though the images are a bit blurry, we can make out digits in most of the samples.
    With more complex architectures such as RNNs, hyperparameter tuning, and longer
    training times, we will surely see even better results. In the next section, we
    introduce a slightly different take on generative models that has recently been
    achieving popularity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图像有点模糊，我们仍然可以看出大多数样本中的数字。通过使用更复杂的架构，如RNN、超参数调整和更长的训练时间，我们肯定会看到更好的结果。在下一节中，我们将介绍一种略有不同的生成模型方法，最近越来越受欢迎。
- en: Score-Based Generative Models
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于分数的生成模型
- en: In this section, we approach generative modeling through a slightly different
    lens than what we have encountered so far. In an optimally trained GAN, we first
    sample from some noise distribution *p(z)* and run this sample <math alttext="z
    Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math> through a generator *G,*
    which deterministically transforms <math alttext="z Subscript i"><msub><mi>z</mi>
    <mi>i</mi></msub></math> into a sample <math alttext="x Subscript i"><msub><mi>x</mi>
    <mi>i</mi></msub></math> from the true data distribution (where we approximate
    the true data distribution *p(x)* using our dataset, <math alttext="p Subscript
    data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> ). Though *G* itself
    is a deterministic function, *G(z)* is a random variable distributed as the true
    data distribution. In summary, we have implicitly defined a distribution over
    our domain via the generator’s action on samples from *p(z)*, and a way of sampling
    from the true data distribution via a simpler distribution *p(z)*, such as a multivariate
    Gaussian distribution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过一个略有不同的视角来接近生成建模，这与我们迄今为止遇到的情况有所不同。在经过最佳训练的GAN中，我们首先从一些噪声分布*p(z)*中抽样，然后将这个样本<math
    alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>通过一个生成器*G*，将<math
    alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>确定性地转换为一个样本<math
    alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>，这个样本来自真实数据分布（我们使用我们的数据集近似真实数据分布*p(x)*，<math
    alttext="p Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>）。虽然*G*本身是一个确定性函数，*G(z)*是一个随机变量，其分布与真实数据分布相同。总之，我们通过生成器对*p(z)*中的样本的操作隐式地定义了我们域上的分布，以及通过一个简单的分布*p(z)*（如多元高斯分布）从真实数据分布中抽样的方法。
- en: VAEs are more explicit in their probabilistic modeling. We define *z* to be
    a set of latent variables that generate the data we see, *x.* We explicitly learn
    a conditional distribution over the data <math alttext="p Subscript theta Baseline
    left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    via the decoder, which we can sample from. In an optimally trained VAE, <math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis
    equals p left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    , is the true conditional likelihood of the data. To generate data using an optimally
    trained VAE, we first sample a setting of the latent variables from *p(z)* and
    run this sample <math alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>
    through the decoder, which now parametrizes the distribution <math alttext="p
    left-parenthesis x vertical-bar z equals z Subscript i Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>i</mi></msub>
    <mo>)</mo></mrow></math> . This is an explicit probability distribution we can
    now sample from.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: VAEs在其概率建模方面更为明确。我们定义*z*为生成我们看到的数据*x*的一组潜在变量。我们明确地学习数据的条件分布<math alttext="p
    Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>通过解码器，我们可以从中抽样。在经过最佳训练的VAE中，<math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis
    equals p left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>，是数据的真实条件概率。要使用经过最佳训练的VAE生成数据，我们首先从*p(z)*中抽样一组潜在变量的设置，然后将这个样本<math
    alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>通过解码器运行，解码器现在参数化了分布<math
    alttext="p left-parenthesis x vertical-bar z equals z Subscript i Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>i</mi></msub>
    <mo>)</mo></mrow></math>。这是一个明确的概率分布，我们现在可以从中抽样。
- en: Note that although GANs and VAEs themselves are quite distinct, both of their
    architectures and actions involve an additional distribution *p(z) (*whether that
    is a noise distribution in GANs or a prior over latent variables in VAEs). Is
    there a way of sampling from the true data distribution without the additional
    distribution? Score-based generative models attempt to do just that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管GAN和VAE本身是非常不同的，但它们的架构和操作都涉及到一个额外的分布*p(z)*（无论是GAN中的噪声分布还是VAE中潜在变量的先验）。有没有一种方法可以从真实数据分布中抽样而不需要额外的分布？基于分数的生成模型试图做到这一点。
- en: One method of sampling from a probability distribution is an iterative process
    called *Langevin dynamics.* This process is actually an instance of a class of
    algorithms referred to as *Markov Chain Monte Carlo (MCMC)* algorithms. Motivating
    MCMC algorithms and proving why they sample from probability distributions in
    an unbiased manner are beyond the scope of this section, but we refer you to the
    vast amount of academic literature that exists on this topic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从概率分布中抽样的一种方法是一种称为*Langevin动力学*的迭代过程。这个过程实际上是一类算法的一个实例，被称为*马尔可夫链蒙特卡罗（MCMC）*算法。激励MCMC算法并证明它们以无偏的方式从概率分布中抽样超出了本节的范围，但我们建议您参考关于这个主题的大量学术文献。
- en: 'Langevin dynamics follows the process defined as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Langevin动力学遵循以下定义的过程：
- en: <math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis Baseline
    equals x Superscript left-parenthesis i right-parenthesis Baseline plus eta normal
    nabla Subscript x Baseline log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis plus StartRoot 2 eta EndRoot epsilon
    comma epsilon tilde upper N left-parenthesis 0 comma upper I right-parenthesis"><mrow><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup> <mo>=</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>+</mo>
    <mi>η</mi> <msub><mi>∇</mi> <mi>x</mi></msub> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>+</mo> <msqrt><mrow><mn>2</mn> <mi>η</mi></mrow></msqrt>
    <mi>ϵ</mi> <mo>,</mo> <mi>ϵ</mi> <mo>∼</mo> <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mi>I</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis Baseline
    equals x Superscript left-parenthesis i right-parenthesis Baseline plus eta normal
    nabla Subscript x Baseline log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis plus StartRoot 2 eta EndRoot epsilon
    comma epsilon tilde upper N left-parenthesis 0 comma upper I right-parenthesis"><mrow><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup> <mo>=</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>+</mo>
    <mi>η</mi> <msub><mi>∇</mi> <mi>x</mi></msub> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>+</mo> <msqrt><mrow><mn>2</mn> <mi>η</mi></mrow></msqrt>
    <mi>ϵ</mi> <mo>,</mo> <mi>ϵ</mi> <mo>∼</mo> <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mi>I</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> here represents a sample
    from *p(x),* and this dynamics equation shows us how to generate the next sample
    <math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    given our current sample.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里表示从*p(x)*中抽取的样本，这个动态方程向我们展示了如何生成下一个样本<math alttext="x Superscript left-parenthesis
    i plus 1 right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>，给定我们当前的样本。
- en: Note that if we were to remove the Gaussian noise component at the end of the
    dynamics equation, we would just be following the gradient to a maximum of *p(x),*
    i.e., performing gradient ascent with some step-size <math alttext="eta"><mi>η</mi></math>
    . The intuition behind this dynamics equation is that the addition of the noise
    component prevents us from simply reaching the maximum *x* and instead allows
    us to explore regions with high probability, thereby exploring regions of low
    probability less ([Figure 10-7](#fig1007)). Again, why this produces samples from
    *p(x)* in an unbiased manner is beyond the scope of this text, but we highly encourage
    you to learn more from the academic literature.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们在动态方程的末尾去除高斯噪声成分，我们将只是沿着*p(x)*的梯度向最大值移动，即，使用一些步长<math alttext="eta"><mi>η</mi></math>执行梯度上升。这个动态方程背后的直觉是，噪声成分的添加阻止我们简单地到达最大值*x*，而是允许我们探索高概率区域，从而探索低概率区域较少（[图10-7](#fig1007)）。再次强调，为什么这种方式以无偏的方式产生*p(x)*的样本超出了本文的范围，但我们强烈鼓励您从学术文献中了解更多。
- en: '![](Images/fdl2_1007.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1007.png)'
- en: Figure 10-7\. We use f here to represent a Gaussian distribution with mean (and
    also maximum) at the origin. Each of the contours represents locations with equal
    likelihood. As we can see from the diagram, the gradient points directly toward
    the maximum, but adding a bit of noise allows us to explore and sample from high-density
    regions without converging to the maximum.
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-7。这里我们使用*f*来表示一个均值（也是最大值）在原点的高斯分布。每个等高线代表具有相等概率的位置。从图中可以看出，梯度直接指向最大值，但添加一点噪声使我们能够探索和从高密度区域中抽样，而不会收敛到最大值。
- en: Although we use the gradient of the log probability instead of the gradient
    of the probability, the value(s) of *x* that maximizes <math alttext="log p left-parenthesis
    x right-parenthesis"><mrow><mo form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></math> is the same as the value(s) of *x* that maximizes *p(x)*
    due to the log’s concaveness. More generally, the log’s concaveness also preserves
    the ordering relationships between all possible values of *x,* i.e., if <math
    alttext="p left-parenthesis x 1 right-parenthesis greater-than-or-equal-to p left-parenthesis
    x 2 right-parenthesis"><mrow><mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>≥</mo> <mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></mrow></math> , then <math alttext="log p left-parenthesis x
    1 right-parenthesis greater-than-or-equal-to log p left-parenthesis x 2 right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>≥</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></mrow></math> , and vice
    versa. For that reason, as we saw in [“Implementing a VAE”](#vae-sect), these
    sorts of optimization processes tend to not be affected meaningfully by the inclusion
    of the log.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用对数概率的梯度而不是概率的梯度，但最大化 <math alttext="log p left-parenthesis x right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    的值与最大化 *p(x)* 的值相同，因为对数的凹性。更一般地，对数的凹性也保留了所有可能的 *x* 值之间的顺序关系，即，如果 <math alttext="p
    left-parenthesis x 1 right-parenthesis greater-than-or-equal-to p left-parenthesis
    x 2 right-parenthesis"><mrow><mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>≥</mo> <mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></mrow></math>，那么 <math alttext="log p left-parenthesis x 1 right-parenthesis
    greater-than-or-equal-to log p left-parenthesis x 2 right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>≥</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></mrow></math>，反之亦然。因此，正如我们在[“实现VAE”](#vae-sect)中看到的那样，这些优化过程往往不会受到对数的影响。
- en: However, the main issue with Langevin dynamics, as we’ve encountered before
    with other generative models, is that we don’t know *p(x),* let alone the gradient
    of its log! But there may be a way to model <math alttext="normal nabla Subscript
    x Baseline log p left-parenthesis x right-parenthesis"><mrow><msub><mi>∇</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math> , which we call <math alttext="p left-parenthesis
    x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    ’s *score function*, directly. This would allow us to simply plug the score directly
    into the Langevin dynamics equation and draw samples from *p(x)* as if we knew
    *p(x)* all along. This is the idea of score-based generative modeling.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与Langevin动力学的主要问题，正如我们之前在其他生成模型中遇到的那样，我们不知道 *p(x)*，更不用说其对数的梯度了！但也许有一种方法可以对
    <math alttext="normal nabla Subscript x Baseline log p left-parenthesis x right-parenthesis"><mrow><msub><mi>∇</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math>，我们称之为 <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> 的*分数函数*，进行建模。这将使我们能够将分数直接插入Langevin动力学方程，并从
    *p(x)* 中抽样，就好像我们一直知道 *p(x)* 一样。这就是基于分数的生成建模的想法。
- en: For a moment, let’s forget the problem of sampling from an unknown distribution
    *p(x)* and instead consider the problem of learning *p(x)*. From now until the
    end of this section, we will consider only the problems of learning and sampling
    from continuous probability distributions. In the same vein of explicitly learning
    approximate probability distributions like in VAEs, we can try to approximate
    *p(x)* with a learned version <math alttext="p Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> , where <math alttext="theta"><mi>θ</mi></math>
    represents the parameters of the learned model. What we envision is a learned
    function, such as a neural network, that takes as input an example *x* and outputs
    a likelihood <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    . However, there is no way to ensure that <math alttext="integral p Subscript
    theta Baseline left-parenthesis x right-parenthesis d x equals 1"><mrow><mo>∫</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>1</mn></mrow></math> , which is a necessary
    condition of any probability distribution.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时忘记从未知分布 *p(x)* 中抽样的问题，而是考虑学习 *p(x)* 的问题。从现在到本节结束，我们将只考虑学习和从连续概率分布中抽样的问题。与显式学习近似概率分布的VAE类似，我们可以尝试用学习版本
    <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    来近似 *p(x)*，其中 <math alttext="theta"><mi>θ</mi></math> 表示学习模型的参数。我们设想的是一个学习函数，比如一个神经网络，它以示例
    *x* 作为输入，并输出一个似然度 <math alttext="p Subscript theta Baseline left-parenthesis x
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math>。然而，没有办法确保 <math alttext="integral p Subscript
    theta Baseline left-parenthesis x right-parenthesis d x equals 1"><mrow><mo>∫</mo>
    <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>1</mn></mrow></math>，这是任何概率分布的必要条件。
- en: Instead, we settle for learning what we call an unnormalized probability distribution
    <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    . This is a function that takes an example *x* and outputs an unnormalized likelihood.
    We can, in theory, represent the normalized probability distribution <math alttext="p
    Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    via <math alttext="StartFraction q Subscript theta Baseline left-parenthesis x
    right-parenthesis Over upper Z left-parenthesis theta right-parenthesis EndFraction"><mfrac><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mi>Z</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow></mfrac></math>
    , where <math alttext="upper Z left-parenthesis theta right-parenthesis equals
    integral q Subscript theta Baseline left-parenthesis x right-parenthesis d x"><mrow><mi>Z</mi>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mo>∫</mo> <msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>
    . Unfortunately, this integral is generally intractable and has no closed form
    solution. Of course, there are exceptions to the rule. For example, <math alttext="upper
    Z left-parenthesis theta right-parenthesis equals sigma asterisk StartRoot 2 pi
    EndRoot"><mrow><mi>Z</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>σ</mi> <mo>*</mo> <msqrt><mrow><mn>2</mn> <mi>π</mi></mrow></msqrt></mrow></math>
    for a univariate Gaussian distribution, where <math alttext="theta equals left-parenthesis
    mu comma sigma right-parenthesis"><mrow><mi>θ</mi> <mo>=</mo> <mo>(</mo> <mi>μ</mi>
    <mo>,</mo> <mi>σ</mi> <mo>)</mo></mrow></math> are the mean and standard deviation
    of the Gaussian. But if we’d like to model more expressive distributions via a
    neural network, for example, it is almost always impossible to tractably calculate
    <math alttext="upper Z left-parenthesis theta right-parenthesis"><mrow><mi>Z</mi>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></math> , which we will also refer to as
    the *partition function.*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只能学习我们称之为非归一化概率分布的函数 <math alttext="q Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>。这是一个接受一个示例 *x* 并输出非归一化可能性的函数。理论上，我们可以通过
    <math alttext="StartFraction q Subscript theta Baseline left-parenthesis x right-parenthesis
    Over upper Z left-parenthesis theta right-parenthesis EndFraction"><mfrac><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mi>Z</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow></mfrac></math>
    来表示归一化概率分布 <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>，其中
    <math alttext="upper Z left-parenthesis theta right-parenthesis equals integral
    q Subscript theta Baseline left-parenthesis x right-parenthesis d x"><mrow><mi>Z</mi>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mo>∫</mo> <msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>。不幸的是，这个积分通常是难以处理的，没有闭合形式的解。当然，也有例外。例如，对于一元高斯分布，<math
    alttext="upper Z left-parenthesis theta right-parenthesis equals sigma asterisk
    StartRoot 2 pi EndRoot"><mrow><mi>Z</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>σ</mi> <mo>*</mo> <msqrt><mrow><mn>2</mn> <mi>π</mi></mrow></msqrt></mrow></math>，其中
    <math alttext="theta equals left-parenthesis mu comma sigma right-parenthesis"><mrow><mi>θ</mi>
    <mo>=</mo> <mo>(</mo> <mi>μ</mi> <mo>,</mo> <mi>σ</mi> <mo>)</mo></mrow></math>
    是高斯分布的均值和标准差。但是，如果我们想通过神经网络来建模更具表现力的分布，几乎总是不可能可靠地计算 <math alttext="upper Z left-parenthesis
    theta right-parenthesis"><mrow><mi>Z</mi> <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></math>，我们也将其称为*分区函数*。
- en: How can we go about learning such an unnormalized probability distribution?
    Researchers have presented many approaches for learning <math alttext="q Subscript
    theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> throughout the history
    of machine learning and inference, but one particular method starts to bridge
    the gap between learning an unnormalized probability distribution and sampling
    from its normalized version via a process like Langevin dynamics. *Score matching*,
    or the idea of learning <math alttext="q Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> via minimizing the difference between
    the score function of <math alttext="q Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> and the score function of the true
    distribution <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> , was first proposed by Hyvarinen
    in 2005.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何学习这样一个非归一化概率分布？研究人员在机器学习和推理的历史上提出了许多学习 <math alttext="q Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> 的方法，但一种特定的方法开始弥合学习非归一化概率分布和从其归一化版本中抽样之间的差距，比如通过类似Langevin动力学的过程。*分数匹配*，或者学习
    <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    的想法通过最小化 <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    的得分函数与真实分布 <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> 的得分函数之间的差异，最初由Hyvarinen在2005年提出。
- en: Here, we show that minimizing the difference as stated is equivalent to minimizing
    the difference between the score function of <math alttext="p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> and the score function
    of <math alttext="p left-parenthesis x right-parenthesis colon"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>:</mo></mrow></math>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了将差异最小化等同于最小化<math alttext="p Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>的得分函数和<math alttext="p left-parenthesis
    x right-parenthesis colon"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>:</mo></mrow></math>的得分函数之间的差异。
- en: <math alttext="normal nabla Subscript x Baseline log q Subscript theta Baseline
    left-parenthesis x right-parenthesis equals normal nabla Subscript x Baseline
    log left-parenthesis p Subscript theta Baseline left-parenthesis x right-parenthesis
    asterisk upper Z left-parenthesis theta right-parenthesis right-parenthesis"><mrow><msub><mi>∇</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>∇</mi> <mi>x</mi></msub>
    <mo form="prefix">log</mo> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>*</mo> <mi>Z</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript x Baseline log q Subscript theta Baseline
    left-parenthesis x right-parenthesis equals normal nabla Subscript x Baseline
    log left-parenthesis p Subscript theta Baseline left-parenthesis x right-parenthesis
    asterisk upper Z left-parenthesis theta right-parenthesis right-parenthesis"><mrow><msub><mi>∇</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>∇</mi> <mi>x</mi></msub>
    <mo form="prefix">log</mo> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>*</mo> <mi>Z</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript x Baseline log p Subscript theta
    Baseline left-parenthesis x right-parenthesis plus normal nabla Subscript x Baseline
    log upper Z left-parenthesis theta right-parenthesis"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>∇</mi> <mi>x</mi></msub>
    <mo form="prefix">log</mo> <mi>Z</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript x Baseline log p Subscript theta
    Baseline left-parenthesis x right-parenthesis plus normal nabla Subscript x Baseline
    log upper Z left-parenthesis theta right-parenthesis"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>∇</mi> <mi>x</mi></msub>
    <mo form="prefix">log</mo> <mi>Z</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript x Baseline log p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript x Baseline log p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><mo>=</mo> <msub><mi>∇</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: It turns out that the score function of <math alttext="q Subscript theta Baseline
    left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> is the same as the
    score function of <math alttext="p Subscript theta Baseline left-parenthesis x
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math> , <math alttext="for-all x"><mrow><mo>∀</mo> <mi>x</mi></mrow></math>
    . This is because the log first separates the product of <math alttext="q Subscript
    theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> and the partition
    function into a sum of logs, and finally the gradient with respect to *x* eliminates
    the log of the partition function, since this term is solely dependent on the
    weights <math alttext="theta"><mi>θ</mi></math> and is not a function of *x* itself.
    Thus, the optimal <math alttext="theta"><mi>θ</mi></math> that minimizes the proposed
    difference is equivalent to the optimal <math alttext="theta"><mi>θ</mi></math>
    that minimizes the difference in scores between <math alttext="p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> and *p(x)*. The following
    is the optimization procedure, which we call *explicit score matching:*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，<math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>的得分函数与<math
    alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>的得分函数相同，<math
    alttext="for-all x"><mrow><mo>∀</mo> <mi>x</mi></mrow></math>。这是因为对数首先将<math alttext="q
    Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>和分区函数的乘积分离为对数的和，最后关于*x*的梯度消除了分区函数的对数，因为这个项仅取决于权重<math
    alttext="theta"><mi>θ</mi></math>，而不是*x*本身的函数。因此，最小化所提出的差异的最优<math alttext="theta"><mi>θ</mi></math>等同于最小化<math
    alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>和*p(x)*之间得分的差异。以下是我们称之为*显式得分匹配*的优化过程。
- en: <math alttext="upper J left-parenthesis theta right-parenthesis equals double-struck
    upper E Subscript p left-parenthesis x right-parenthesis Baseline left-bracket
    one-half StartAbsoluteValue EndAbsoluteValue normal nabla Subscript x Baseline
    log q Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    nabla Subscript x Baseline log p left-parenthesis x right-parenthesis StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mi>J</mi>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>∇</mi> <mi>x</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>-</mo> <msub><mi>∇</mi> <mi>x</mi></msub> <msubsup><mrow><mo form="prefix">log</mo><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper J left-parenthesis theta right-parenthesis equals double-struck
    upper E Subscript p left-parenthesis x right-parenthesis Baseline left-bracket
    one-half StartAbsoluteValue EndAbsoluteValue normal nabla Subscript x Baseline
    log q Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    nabla Subscript x Baseline log p left-parenthesis x right-parenthesis StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mi>J</mi>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>∇</mi> <mi>x</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>-</mo> <msub><mi>∇</mi> <mi>x</mi></msub> <msubsup><mrow><mo form="prefix">log</mo><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: '*<math alttext="theta Superscript asterisk Baseline equals argmin Subscript
    theta Baseline upper J left-parenthesis theta right-parenthesis"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <mi>J</mi>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*<math alttext="theta Superscript asterisk Baseline equals argmin Subscript
    theta Baseline upper J left-parenthesis theta right-parenthesis"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <mi>J</mi>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>*'
- en: The reason for the leading <math alttext="one-half"><mfrac><mn>1</mn> <mn>2</mn></mfrac></math>
    is to simplify the resulting gradient (cancels out with the 2 that will be pulled
    down from the square of the norm). Note that we have completely removed the dependence
    on the partition function in our analysis, and we now have a way to (1) learn
    an unnormalized distribution <math alttext="q Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> , and (2) calculate the score of <math
    alttext="p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> via our neural network. For item 1, in the case
    where we find a setting <math alttext="theta"><mi>θ</mi></math> that results in
    <math alttext="upper J left-parenthesis theta right-parenthesis equals 0"><mrow><mi>J</mi>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math> , <math alttext="p
    Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    and *p(x)* are the same for all *x* since their gradients are the same for all
    *x.* Of course, in general, two functions that have the same gradients everywhere
    can still be different functions by being off from each other by a nonzero constant.
    However, in our case, these two functions cannot be off by a nonzero constant
    since they are both probability distributions that must sum to one. Thus, we have
    a valid optimization procedure for learning an unnormalized distribution that,
    when normalized, should approximate the true distribution well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 领先的 <math alttext="one-half"><mfrac><mn>1</mn> <mn>2</mn></mfrac></math> 的原因是为了简化结果的梯度（与将从范数的平方中下拉的2相互抵消）。请注意，在我们的分析中完全消除了对分区函数的依赖，现在我们有了一种方法来（1）学习一个未归一化的分布
    <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>，以及（2）通过我们的神经网络计算
    <math alttext="p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> 的得分。对于第一项，在我们找到一个导致 <math alttext="upper J left-parenthesis
    theta right-parenthesis equals 0"><mrow><mi>J</mi> <mo>(</mo> <mi>θ</mi> <mo>)</mo>
    <mo>=</mo> <mn>0</mn></mrow></math> 的设置 <math alttext="theta"><mi>θ</mi></math>
    的情况下，<math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    和 *p(x)* 对于所有 *x* 都是相同的，因为它们对于所有 *x* 的梯度都是相同的。当然，在一般情况下，两个在任何地方具有相同梯度的函数仍然可以通过相互偏离一个非零常数而成为不同的函数。然而，在我们的情况下，这两个函数不能通过非零常数偏离，因为它们都是必须总和为一的概率分布。因此，我们有一个有效的优化过程来学习一个未归一化的分布，当归一化时，应该很好地逼近真实分布。
- en: 'To perform item 2, in theory all we would need to do is first run our example
    <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> through our neural network
    to get <math alttext="q Subscript theta Baseline left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> , take the log of <math alttext="q Subscript theta
    Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis Baseline
    right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></math>
    , and backpropagate this result through our network all the way back to the input.
    We’ve already shown that the resultant score is equivalent to the score of <math
    alttext="p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> . Going forward, we will refer to the score function
    of <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    (and <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    ) as <math alttext="normal upper Psi Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>Ψ</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> , and the score function of <math alttext="p
    left-parenthesis x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    as <math alttext="normal upper Psi left-parenthesis x right-parenthesis"><mrow><mi>Ψ</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> . Using our new notation, we rewrite
    the explicit score matching objective as:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行项目2，理论上我们只需要首先通过我们的神经网络运行示例<math alttext="x Superscript left-parenthesis i
    right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>，得到<math
    alttext="q Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>，取<math alttext="q Subscript theta Baseline left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>的对数，并将这个结果反向传播到输入端。我们已经证明了结果分数等同于<math alttext="p
    Subscript theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></math>的分数。接下来，我们将把<math
    alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>（和<math
    alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>）的分数函数称为<math
    alttext="normal upper Psi Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>Ψ</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>，以及<math
    alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></math>的分数函数称为<math alttext="normal upper Psi left-parenthesis
    x right-parenthesis"><mrow><mi>Ψ</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>。使用我们的新符号，我们将显式分数匹配目标重写为：
- en: <math alttext="theta Superscript asterisk Baseline equals argmin Subscript theta
    Baseline double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal upper
    Psi Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    upper Psi left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msup><mi>θ</mi> <mo>*</mo></msup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <msub><mi>𝔼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>Ψ</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>-</mo> <msubsup><mrow><mi>Ψ</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="theta Superscript asterisk Baseline equals argmin Subscript theta
    Baseline double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal upper
    Psi Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    upper Psi left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msup><mi>θ</mi> <mo>*</mo></msup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <msub><mi>𝔼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>Ψ</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>-</mo> <msubsup><mrow><mi>Ψ</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: 'Although we have gotten around the issue of the partition function, we still
    have no idea what <math alttext="normal upper Psi left-parenthesis x right-parenthesis"><mrow><mi>Ψ</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> is. Hyvarinen, in 2005, in addition
    to proposing the notion of explicit score matching, proved an amazing property
    regarding explicit score matching (satisfied under certain weak regularity conditions):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经解决了分区函数的问题，但我们仍然不知道<math alttext="normal upper Psi left-parenthesis x
    right-parenthesis"><mrow><mi>Ψ</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>是什么。Hyvarinen在2005年提出了显式分数匹配的概念，并证明了关于显式分数匹配的一个惊人性质（在某些弱正则条件下满足）：
- en: <math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal upper
    Psi Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    upper Psi left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket equals double-struck upper E
    Subscript p left-parenthesis x right-parenthesis Baseline left-bracket one-half
    StartAbsoluteValue EndAbsoluteValue normal upper Psi Subscript theta Baseline
    left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue Subscript
    2 Superscript 2 Baseline plus sigma-summation Underscript i equals 1 Overscript
    d Endscripts normal nabla Subscript x Sub Subscript i Subscript Baseline normal
    upper Psi Subscript theta comma i Baseline left-parenthesis x right-parenthesis
    plus c right-bracket"><mrow><msub><mi>𝔼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>Ψ</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>-</mo> <msubsup><mrow><mi>Ψ</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo> <mo>=</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo></mrow>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo> <mo>|</mo></mrow> <msub><mi>Ψ</mi>
    <mi>θ</mi></msub> <msubsup><mrow><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <msub><mi>∇</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <msub><mi>Ψ</mi> <mrow><mi>θ</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>c</mi> <mo>]</mo></mrow></mrow></math>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal upper
    Psi Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    upper Psi left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket equals double-struck upper E
    Subscript p left-parenthesis x right-parenthesis Baseline left-bracket one-half
    StartAbsoluteValue EndAbsoluteValue normal upper Psi Subscript theta Baseline
    left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue Subscript
    2 Superscript 2 Baseline plus sigma-summation Underscript i equals 1 Overscript
    d Endscripts normal nabla Subscript x Sub Subscript i Subscript Baseline normal
    upper Psi Subscript theta comma i Baseline left-parenthesis x right-parenthesis
    plus c right-bracket"><mrow><msub><mi>𝔼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>Ψ</mi> <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>-</mo> <msubsup><mrow><mi>Ψ</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo> <mo>=</mo></mrow> <msub><mi>𝔼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo></mrow>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo> <mo>|</mo></mrow> <msub><mi>Ψ</mi>
    <mi>θ</mi></msub> <msubsup><mrow><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <msub><mi>∇</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <msub><mi>Ψ</mi> <mrow><mi>θ</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>c</mi> <mo>]</mo></mrow></mrow></math>
- en: Where <math alttext="normal upper Psi Subscript theta comma i Baseline left-parenthesis
    x right-parenthesis equals normal nabla Subscript x Sub Subscript i Baseline log
    p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>Ψ</mi>
    <mrow><mi>θ</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>∇</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> —the score function is just a length
    *d* vector (assuming *x* is of *d* dimensions), where each index <math alttext="i"><mi>i</mi></math>
    corresponds with the partial derivative of the log probability with respect to
    <math alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math> . <math
    alttext="c"><mi>c</mi></math> is a constant that has no dependence on <math alttext="theta"><mi>θ</mi></math>
    , so it can simply be ignored during optimization. This is a method the community
    has come to know as *implicit score matching.*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<math alttext="normal upper Psi Subscript theta comma i Baseline left-parenthesis
    x right-parenthesis equals normal nabla Subscript x Sub Subscript i Baseline log
    p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>Ψ</mi>
    <mrow><mi>θ</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>∇</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>——分数函数只是一个长度为*d*的向量（假设*x*是*d*维），其中每个索引<math
    alttext="i"><mi>i</mi></math>对应于对*log*概率关于<math alttext="x Subscript i"><msub><mi>x</mi>
    <mi>i</mi></msub></math>的偏导数。*c*是一个与<math alttext="theta"><mi>θ</mi></math>无关的常数，因此在优化过程中可以简单忽略。这是社区已知的一种方法，称为*隐式分数匹配*。
- en: 'Note that the equivalent expression has no dependence on the true probability
    distribution, and thus we can directly optimize <math alttext="theta"><mi>θ</mi></math>
    , using it as we would any other objective. Once we learn the optimal <math alttext="theta"><mi>θ</mi></math>
    , all we need to do to perform generative modeling is:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，等效表达式不依赖于真实概率分布，因此我们可以直接优化*θ*，将其用作任何其他目标一样。一旦我们学习到最佳的*θ*，进行生成建模所需做的就是：
- en: 'Follow the methodology presented earlier for calculating the score of <math
    alttext="p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> : run the example through our learned network,
    take the log of the result, and backpropagate all the way to the input.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前提出的方法计算*p<sub>θ</sub>(x<sup>(i)</sup>)*的得分：通过我们学习的网络运行示例，取结果的对数，并反向传播直到输入。
- en: Sample <math alttext="epsilon"><mi>ϵ</mi></math> from *N(0,I).*
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*N(0,I)*中抽取样本*epsilon*。
- en: Plug in the results of steps 1 and 2 into the Langevin dynamics equation to
    obtain the next sample, <math alttext="x Superscript left-parenthesis i plus 1
    right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    .
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将步骤1和2的结果插入Langevin动力学方程中，以获得下一个样本*x<sup>(i+1)</sup>*。
- en: Repeat steps 1 through 3 with <math alttext="x Superscript left-parenthesis
    i plus 1 right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    .
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1到3，使用*x<sup>(i+1)</sup>*。
- en: This procedure allows us to draw samples from <math alttext="p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> , which, as shown
    earlier, should approximate *p(x)* well once the network has been trained.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程允许我们从*p<sub>θ</sub>(x)*中抽取样本，正如之前所示，一旦网络训练完成，它应该很好地逼近*p(x)*。
- en: Can we do better than implicit score matching? For one, implicit score matching
    requires us to calculate second-order gradients, as can be seen from the <math
    alttext="sigma-summation Underscript i equals 1 Overscript d Endscripts normal
    nabla Subscript x Sub Subscript i Baseline normal upper Psi Subscript theta comma
    i Baseline left-parenthesis x right-parenthesis"><mrow><msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <msub><mi>∇</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <msub><mi>Ψ</mi> <mrow><mi>θ</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> term in the implicit score matching
    objective. This can be quite computationally expensive depending on the size of
    *x.* In a framework such as PyTorch, this would require first calculating the
    first-order gradient through standard means such as backpropagation and then looping
    through each <math alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>
    manually to compute its second-order gradient. In the next section, we will cover
    *denoising autoencoders* and *denoising score matching*, which modify the objective
    and allow us to get around these complexity issues.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否比隐式得分匹配做得更好？首先，隐式得分匹配要求我们计算二阶梯度，正如在隐式得分匹配目标中的*∑<sub>i=1</sub><sup>d</sup>∇<sub>x<sub>i</sub></sub>Ψ<sub>θ,i</sub>(x)*一项中所示。这取决于*x*的大小，这可能会非常耗费计算资源。在PyTorch等框架中，这将首先通过标准方法（如反向传播）计算第一阶梯度，然后手动循环遍历每个*x<sub>i</sub>*来计算其二阶梯度。在接下来的部分中，我们将介绍*去噪自动编码器*和*去噪得分匹配*，这些修改了目标并使我们能够避开这些复杂性问题。
- en: Denoising Autoencoders and Score Matching
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去噪自动编码器和得分匹配
- en: Before explaining the connection between denoising autoencoders and score matching,
    we first motivate the denoising autoencoder architecture. In [Chapter 9](ch09.xhtml#ch07),
    we learned about autoencoders through the lens of representation learning. We
    used autoencoders to compress high-dimensional data, such as images, into low-dimensional
    representations that preserved the information, or useful features, necessary
    to reconstruct the original data. We additionally showed, through our experiments
    on MNIST, that we were able to reconstruct the data quite well and we generally
    saw, for instances of a given digit, clustering of its low-dimensional representations.
    This implies that if we were to train a standard classifier on these low-dimensional
    representations, with the label being their original digit categories, we’d expect
    to see great accuracy.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释去噪自动编码器和得分匹配之间的联系之前，我们首先要激发去噪自动编码器的架构。在第9章中，我们通过表示学习的视角了解了自动编码器。我们使用自动编码器将高维数据（如图像）压缩成保留信息或重构原始数据所需的有用特征的低维表示。此外，通过我们在MNIST上的实验，我们能够相当好地重构数据，并且通常看到给定数字实例的低维表示聚类。这意味着如果我们在这些低维表示上训练标准分类器，标签为它们的原始数字类别，我们预计会看到很高的准确性。
- en: However, depending on the data we try to compress, it turns out that, at times,
    our compressions aren’t able to capture useful features. In other words, when
    we use our trained autoencoder on real-world images outside of our sample that
    may be slightly corrupted, rotated, shifted, or captured under various light settings,
    our ability to classify these images using their low-dimensional representations
    takes a large dip.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据我们尝试压缩的数据，有时候我们的压缩并不能捕捉到有用的特征。换句话说，当我们在现实世界中使用我们训练过的自动编码器处理可能略有损坏、旋转、移位或在各种光照条件下拍摄的图像时，我们使用它们的低维表示来对这些图像进行分类的能力会大幅下降。
- en: Ideally, we would like our learned representations to be invariant to such noise.
    In 2008, Vincent proposed denoising autoencoders as a method for combating the
    issues we see with standard autoencoders. Denoising autoencoders first corrupt
    the original input data with noise, run the corrupted input through a standard
    autoencoder, and finally attempt to reconstruct the original input ([Figure 10-8](#fig1008)).
    The original paper used a corruption scheme that randomly zeroed out some portion
    of the input, but acknowledged that a variety of corruption schemes could be used
    instead. Intuitively, the representations learned from such a procedure should
    be much more robust to the challenges presented by real-world images. Indeed,
    the experiments on MNIST by Vincent in 2008 showed that, under various data augmentations
    such as rotation and background noise, the denoising autoencoder performed significantly
    better than the standard autoencoder in terms of classification accuracy.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望我们学到的表示对这种噪声是不变的。2008年，Vincent提出了去噪自动编码器作为对标准自动编码器存在问题的一种方法。去噪自动编码器首先用噪声损坏原始输入数据，然后将损坏的输入通过标准自动编码器运行，并最终尝试重构原始输入（[图10-8](#fig1008)）。原始论文使用了一个随机将输入的一部分置零的损坏方案，但承认可以使用各种损坏方案。直觉上，从这样一个过程中学到的表示应该对真实世界图像所面临的挑战更加稳健。事实上，Vincent在2008年对MNIST数据集进行的实验表明，在旋转和背景噪声等各种数据增强下，去噪自动编码器在分类准确度方面明显优于标准自动编码器。
- en: '![](Images/fdl2_1008.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1008.png)'
- en: Figure 10-8\. The denoising autoencoder architecture is the same as that of
    the standard autoencoder, except instead of minimizing the reconstruction error
    between y and the input x', we minimize the reconstruction error between y and
    the original x.
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-8。去噪自动编码器的架构与标准自动编码器相同，只是不再最小化y和输入x'之间的重构误差，而是最小化y和原始x之间的重构误差。
- en: 'Following Vincent 2011, which first noticed the connection between denoising
    AEs and score matching, we instead define the corruption scheme to be the addition
    of Gaussian noise to the original data. Formally, we have that <math alttext="p
    left-parenthesis x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    represents the true distribution of the data, <math alttext="p Subscript d a t
    a Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> represents the distribution
    of the data using our training set, and <math alttext="p Subscript sigma Baseline
    left-parenthesis x prime vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>''</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> represents the conditional distribution
    of the corrupted data given the original data. In particular:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Vincent 2011年的研究，首次注意到去噪自动编码器和评分匹配之间的联系，我们将定义损坏方案为向原始数据添加高斯噪声。形式上，我们有<math
    alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></math>代表数据的真实分布，<math alttext="p Subscript d a t a Baseline
    left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>代表使用我们的训练集的数据分布，<math
    alttext="p Subscript sigma Baseline left-parenthesis x prime vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>代表给定原始数据的损坏数据的条件分布。特别地：
- en: "<math alttext=\"p Subscript sigma Baseline left-parenthesis x prime vertical-bar\
    \ x right-parenthesis equals upper N left-parenthesis x prime semicolon x comma\
    \ sigma squared upper I right-parenthesis\"><mrow><msub><mi>p</mi> <mi>σ</mi></msub>\
    \ <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>\
    \ <mo>=</mo> <mi>N</mi> <mrow><mo>(</mo> <mi>x</mi> <mi>â</mi> <mi>\x80</mi> <mi>\x99\
    </mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <msup><mi>σ</mi> <mn>2</mn></msup> <mi>I</mi>\
    \ <mo>)</mo></mrow></mrow></math>"
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: "<math alttext=\"p Subscript sigma Baseline left-parenthesis x prime vertical-bar\
    \ x right-parenthesis equals upper N left-parenthesis x prime semicolon x comma\
    \ sigma squared upper I right-parenthesis\"><mrow><msub><mi>p</mi> <mi>σ</mi></msub>\
    \ <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>\
    \ <mo>=</mo> <mi>N</mi> <mrow><mo>(</mo> <mi>x</mi> <mi>â</mi> <mi>\x80</mi> <mi>\x99\
    </mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <msup><mi>σ</mi> <mn>2</mn></msup> <mi>I</mi>\
    \ <mo>)</mo></mrow></mrow></math>"
- en: 'Where the mean of the distribution is the original data and the subscript <math
    alttext="sigma"><mi>σ</mi></math> represents the standard deviation of the Gaussian
    noise applied to the original data. Note that *x’* and *x* are defined over the
    same domain (all possible images, for example). We can now calculate the distribution
    over the corrupted data:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 其中分布的均值是原始数据，下标<math alttext="sigma"><mi>σ</mi></math>代表应用于原始数据的高斯噪声的标准差。注意*x'*和*x*定义在相同的域上（例如所有可能的图像）。我们现在可以计算损坏数据的分布：
- en: <math alttext="p Subscript sigma Baseline left-parenthesis x prime right-parenthesis
    equals sigma-summation Underscript x Endscripts p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x right-parenthesis p left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>∑</mo> <mi>x</mi></msub> <msub><mi>p</mi> <mi>σ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p Subscript sigma Baseline left-parenthesis x prime right-parenthesis
    equals sigma-summation Underscript x Endscripts p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x right-parenthesis p left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>∑</mo> <mi>x</mi></msub> <msub><mi>p</mi> <mi>σ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="almost-equals sigma-summation Underscript x Endscripts p Subscript
    sigma Baseline left-parenthesis x prime vertical-bar x right-parenthesis p Subscript
    d a t a Baseline left-parenthesis x right-parenthesis"><mrow><mo>≈</mo> <msub><mo>∑</mo>
    <mi>x</mi></msub> <msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="almost-equals sigma-summation Underscript x Endscripts p Subscript
    sigma Baseline left-parenthesis x prime vertical-bar x right-parenthesis p Subscript
    d a t a Baseline left-parenthesis x right-parenthesis"><mrow><mo>≈</mo> <msub><mo>∑</mo>
    <mi>x</mi></msub> <msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals StartFraction 1 Over n EndFraction sigma-summation Underscript
    i equals 1 Overscript n Endscripts p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x equals x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup>
    <mo>|</mo> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals StartFraction 1 Over n EndFraction sigma-summation Underscript
    i equals 1 Overscript n Endscripts p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x equals x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup>
    <mo>|</mo> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
- en: which is the empirical average over the conditional probabilities using each
    data point from our dataset as the reference. This follows naturally from letting
    the true distribution be approximated by the distribution defined by the dataset
    (same as how this was defined in [“Generative Adversarial Networks”](#gans-sect)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用我们数据集中的每个数据点作为参考计算条件概率的经验平均值。这自然地遵循了让真实分布由数据集定义的分布来近似（与[“生成对抗网络”](#gans-sect)中的定义方式相同）。
- en: In 2011, Vincent explored the possibility of using <math alttext="p Subscript
    sigma Baseline left-parenthesis x prime right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
    as the reference instead of <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> as we do in explicit score matching.
    The reasoning for this is that <math alttext="p Subscript sigma Baseline left-parenthesis
    x prime right-parenthesis"><mrow><msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math> can be viewed
    as a continuous approximation to the true distribution <math alttext="p left-parenthesis
    x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    . The approximation defined by <math alttext="p Subscript d a t a Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> is unbiased, but is
    unfortunately discontinuous everywhere *x* is not present in the dataset due to
    being a uniform distribution over all images in the dataset, with a likelihood
    of zero everywhere else. Of course, as <math alttext="sigma"><mi>σ</mi></math>
    gets larger, <math alttext="p Subscript sigma Baseline left-parenthesis x prime
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math> is seen as a less and less faithful
    approximation to <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> , so we’d like to work with small
    <math alttext="sigma"><mi>σ</mi></math> ’s.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Vincent 2011 first proposed explicit score matching using <math alttext="p
    Subscript sigma Baseline left-parenthesis x prime right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>''</mo></msup> <mo>)</mo></mrow></mrow></math>
    as the reference:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*<math alttext="upper J left-parenthesis theta right-parenthesis equals double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x prime right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal nabla
    Subscript x prime Baseline log p Subscript theta Baseline left-parenthesis x prime
    right-parenthesis minus normal nabla Subscript x prime Baseline log p Subscript
    sigma Baseline left-parenthesis x prime right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mi>J</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo><msup><mi>x</mi> <mo>''</mo></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>''</mo></msup></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>''</mo></msup> <mo>)</mo></mrow> <mo>-</mo> <msub><mi>∇</mi>
    <msup><mi>x</mi> <mo>''</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>''</mo></msup> <mo>)</mo></mrow>
    <msubsup><mrow><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '*<math alttext="theta Superscript asterisk Baseline equals argmin Subscript
    theta Baseline upper J left-parenthesis theta right-parenthesis"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <mi>J</mi>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same reasoning for why this is a valid optimization procedure
    for <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    is the same as in the previous section—the only difference here is the reference
    distribution we are trying to match. Vincent 2011 actually goes an extra step
    and shows that this optimization procedure is equivalent to:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为什么这是一个有效的优化过程对于<math alttext="p Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>的推理与前一节中的相同——唯一的区别在于我们试图匹配的参考分布。Vincent
    2011 实际上走了一步额外，并展示了这个优化过程等效于：
- en: <math alttext="upper J Subscript DSM Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    one-half StartAbsoluteValue EndAbsoluteValue normal nabla Subscript x prime Baseline
    log p Subscript theta Baseline left-parenthesis x prime right-parenthesis minus
    normal nabla Subscript x prime Baseline log p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x right-parenthesis StartAbsoluteValue EndAbsoluteValue Subscript
    2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi> <mtext>DSM</mtext></msub>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mrow><mo>|</mo> <mo>|</mo></mrow> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>-</mo> <msub><mi>∇</mi>
    <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow> <msubsup><mrow><mo>|</mo><mo>|</mo></mrow> <mn>2</mn>
    <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper J Subscript DSM Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    one-half StartAbsoluteValue EndAbsoluteValue normal nabla Subscript x prime Baseline
    log p Subscript theta Baseline left-parenthesis x prime right-parenthesis minus
    normal nabla Subscript x prime Baseline log p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x right-parenthesis StartAbsoluteValue EndAbsoluteValue Subscript
    2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi> <mtext>DSM</mtext></msub>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mrow><mo>|</mo> <mo>|</mo></mrow> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>-</mo> <msub><mi>∇</mi>
    <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow> <msubsup><mrow><mo>|</mo><mo>|</mo></mrow> <mn>2</mn>
    <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: <math alttext="theta Subscript DSM Superscript asterisk Baseline equals argmin
    Subscript theta Baseline upper J Subscript DSM Baseline left-parenthesis theta
    right-parenthesis"><mrow><msubsup><mi>θ</mi> <mtext>DSM</mtext> <mo>*</mo></msubsup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <msub><mi>J</mi> <mtext>DSM</mtext></msub>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="theta Subscript DSM Superscript asterisk Baseline equals argmin
    Subscript theta Baseline upper J Subscript DSM Baseline left-parenthesis theta
    right-parenthesis"><mrow><msubsup><mi>θ</mi> <mtext>DSM</mtext> <mo>*</mo></msubsup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <msub><mi>J</mi> <mtext>DSM</mtext></msub>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
- en: Although we won’t show the proof here and refer you to Vincent 2011 for the
    full details, it does utilize the log trick we described in [“Implementing a VAE”](#vae-sect).
    We refer to optimizing this objective as *denoising score matching,* or *DSM*
    for short*,* and as we will show soon, it serves as the connection to denoising
    AEs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会在这里展示证明，并将您转至 Vincent 2011 以获取完整细节，但它确实利用了我们在 [“实现VAE”](#vae-sect) 中描述的对数技巧。我们将优化这个目标称为*去噪得分匹配*，简称为*DSM*，正如我们将很快展示的那样，它作为与去噪自编码器的连接。
- en: "We know that <math alttext=\"p Subscript sigma Baseline left-parenthesis x\
    \ prime vertical-bar x right-parenthesis equals upper N left-parenthesis x prime\
    \ semicolon x comma sigma squared upper I right-parenthesis\"><mrow><msub><mi>p</mi>\
    \ <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>\
    \ <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>N</mi> <mrow><mo>(</mo> <mi>x</mi>\
    \ <mi>â</mi> <mi>\x80</mi> <mi>\x99</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <msup><mi>σ</mi>\
    \ <mn>2</mn></msup> <mi>I</mi> <mo>)</mo></mrow></mrow></math> , and now compute\
    \ the gradient of its log:"
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: "我们知道<math alttext=\"p Subscript sigma Baseline left-parenthesis x prime vertical-bar\
    \ x right-parenthesis equals upper N left-parenthesis x prime semicolon x comma\
    \ sigma squared upper I right-parenthesis\"><mrow><msub><mi>p</mi> <mi>σ</mi></msub>\
    \ <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>\
    \ <mo>=</mo> <mi>N</mi> <mrow><mo>(</mo> <mi>x</mi> <mi>â</mi> <mi>\x80</mi> <mi>\x99\
    </mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <msup><mi>σ</mi> <mn>2</mn></msup> <mi>I</mi>\
    \ <mo>)</mo></mrow></mrow></math>，现在计算其对数的梯度："
- en: <math alttext="normal nabla Subscript x prime Baseline log p Subscript sigma
    Baseline left-parenthesis x prime vertical-bar x right-parenthesis equals normal
    nabla Subscript x prime Baseline log left-parenthesis StartFraction 1 Over StartRoot
    left-parenthesis 2 pi right-parenthesis Superscript d Baseline StartAbsoluteValue
    sigma squared upper I EndAbsoluteValue EndRoot EndFraction e Superscript StartFraction
    minus left-parenthesis x prime minus x right-parenthesis Super Superscript upper
    T Superscript left-parenthesis x prime minus x right-parenthesis Over 2 sigma
    squared EndFraction Baseline right-parenthesis"><mrow><msub><mi>∇</mi> <msup><mi>x</mi>
    <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>σ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <mrow><mo>(</mo> <mfrac><mn>1</mn> <msqrt><mrow><msup><mrow><mo>(</mo><mn>2</mn><mi>π</mi><mo>)</mo></mrow>
    <mi>d</mi></msup> <mrow><mo>|</mo><msup><mi>σ</mi> <mn>2</mn></msup> <mi>I</mi><mo>|</mo></mrow></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mfrac><mrow><mo>-</mo><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mn>2</mn><msup><mi>σ</mi>
    <mn>2</mn></msup></mrow></mfrac></msup> <mo>)</mo></mrow></mrow></math>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript x prime Baseline log p Subscript sigma
    Baseline left-parenthesis x prime vertical-bar x right-parenthesis equals normal
    nabla Subscript x prime Baseline log left-parenthesis StartFraction 1 Over StartRoot
    left-parenthesis 2 pi right-parenthesis Superscript d Baseline StartAbsoluteValue
    sigma squared upper I EndAbsoluteValue EndRoot EndFraction e Superscript StartFraction
    minus left-parenthesis x prime minus x right-parenthesis Super Superscript upper
    T Superscript left-parenthesis x prime minus x right-parenthesis Over 2 sigma
    squared EndFraction Baseline right-parenthesis"><mrow><msub><mi>∇</mi> <msup><mi>x</mi>
    <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>σ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <mrow><mo>(</mo> <mfrac><mn>1</mn> <msqrt><mrow><msup><mrow><mo>(</mo><mn>2</mn><mi>π</mi><mo>)</mo></mrow>
    <mi>d</mi></msup> <mrow><mo>|</mo><msup><mi>σ</mi> <mn>2</mn></msup> <mi>I</mi><mo>|</mo></mrow></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mfrac><mrow><mo>-</mo><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mn>2</mn><msup><mi>σ</mi>
    <mn>2</mn></msup></mrow></mfrac></msup> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript x prime Baseline log StartFraction
    1 Over StartRoot left-parenthesis 2 pi right-parenthesis Superscript d Baseline
    StartAbsoluteValue sigma squared upper I EndAbsoluteValue EndRoot EndFraction
    plus normal nabla Subscript x prime Baseline log e Superscript StartFraction minus
    left-parenthesis x prime minus x right-parenthesis Super Superscript upper T Superscript
    left-parenthesis x prime minus x right-parenthesis Over 2 sigma squared EndFraction"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <mfrac><mn>1</mn> <msqrt><mrow><msup><mrow><mo>(</mo><mn>2</mn><mi>π</mi><mo>)</mo></mrow>
    <mi>d</mi></msup> <mrow><mo>|</mo><msup><mi>σ</mi> <mn>2</mn></msup> <mi>I</mi><mo>|</mo></mrow></mrow></msqrt></mfrac>
    <mo>+</mo> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <msup><mi>e</mi> <mfrac><mrow><mo>-</mo><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mn>2</mn><msup><mi>σ</mi>
    <mn>2</mn></msup></mrow></mfrac></msup></mrow></math>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript x prime Baseline log StartFraction
    1 Over StartRoot left-parenthesis 2 pi right-parenthesis Superscript d Baseline
    StartAbsoluteValue sigma squared upper I EndAbsoluteValue EndRoot EndFraction
    plus normal nabla Subscript x prime Baseline log e Superscript StartFraction minus
    left-parenthesis x prime minus x right-parenthesis Super Superscript upper T Superscript
    left-parenthesis x prime minus x right-parenthesis Over 2 sigma squared EndFraction"><mrow><mo>=</mo>
    <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <mfrac><mn>1</mn> <msqrt><mrow><msup><mrow><mo>(</mo><mn>2</mn><mi>π</mi><mo>)</mo></mrow>
    <mi>d</mi></msup> <mrow><mo>|</mo><msup><mi>σ</mi> <mn>2</mn></msup> <mi>I</mi><mo>|</mo></mrow></mrow></msqrt></mfrac>
    <mo>+</mo> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <msup><mi>e</mi> <mfrac><mrow><mo>-</mo><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mn>2</mn><msup><mi>σ</mi>
    <mn>2</mn></msup></mrow></mfrac></msup></mrow></math>
- en: <math alttext="equals minus StartFraction 1 Over 2 sigma squared EndFraction
    normal nabla Subscript x prime Baseline left-parenthesis x prime minus x right-parenthesis
    Superscript upper T Baseline left-parenthesis x prime minus x right-parenthesis"><mrow><mo>=</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><msup><mi>σ</mi> <mn>2</mn></msup></mrow></mfrac>
    <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>-</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals minus StartFraction 1 Over 2 sigma squared EndFraction
    normal nabla Subscript x prime Baseline left-parenthesis x prime minus x right-parenthesis
    Superscript upper T Baseline left-parenthesis x prime minus x right-parenthesis"><mrow><mo>=</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><msup><mi>σ</mi> <mn>2</mn></msup></mrow></mfrac>
    <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>-</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals minus StartFraction 1 Over 2 sigma squared EndFraction
    left-parenthesis normal nabla Subscript x prime Baseline x Superscript prime upper
    T Baseline x prime minus 2 normal nabla Subscript x prime Baseline x Superscript
    prime upper T Baseline x plus normal nabla Subscript x prime Baseline x Superscript
    upper T Baseline x right-parenthesis"><mrow><mo>=</mo> <mo>-</mo> <mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>σ</mi> <mn>2</mn></msup></mrow></mfrac> <mrow><mo>(</mo>
    <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>-</mo> <mn>2</mn> <msub><mi>∇</mi> <msup><mi>x</mi>
    <mo>'</mo></msup></msub> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <mi>x</mi> <mo>+</mo> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub>
    <msup><mi>x</mi> <mi>T</mi></msup> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals minus StartFraction 1 Over 2 sigma squared EndFraction
    left-parenthesis normal nabla Subscript x prime Baseline x Superscript prime upper
    T Baseline x prime minus 2 normal nabla Subscript x prime Baseline x Superscript
    prime upper T Baseline x plus normal nabla Subscript x prime Baseline x Superscript
    upper T Baseline x right-parenthesis"><mrow><mo>=</mo> <mo>-</mo> <mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>σ</mi> <mn>2</mn></msup></mrow></mfrac> <mrow><mo>(</mo>
    <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>-</mo> <mn>2</mn> <msub><mi>∇</mi> <msup><mi>x</mi>
    <mo>'</mo></msup></msub> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <mi>x</mi> <mo>+</mo> <msub><mi>∇</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub>
    <msup><mi>x</mi> <mi>T</mi></msup> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals StartFraction 1 Over sigma squared EndFraction left-parenthesis
    x minus x prime right-parenthesis"><mrow><mo>=</mo> <mfrac><mn>1</mn> <msup><mi>σ</mi>
    <mn>2</mn></msup></mfrac> <mrow><mo>(</mo> <mi>x</mi> <mo>-</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals StartFraction 1 Over sigma squared EndFraction left-parenthesis
    x minus x prime right-parenthesis"><mrow><mo>=</mo> <mfrac><mn>1</mn> <msup><mi>σ</mi>
    <mn>2</mn></msup></mfrac> <mrow><mo>(</mo> <mi>x</mi> <mo>-</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
- en: Let’s break down the math. The first equality is simply the definition of a
    Gaussian distribution with mean *x* and variance <math alttext="sigma squared
    upper I"><mrow><msup><mi>σ</mi> <mn>2</mn></msup> <mi>I</mi></mrow></math> . The
    second equality is a result of the log breaking up the product into a sum of logs,
    and the gradient of a sum being the sum of gradients. In the third equality, we
    see the first term has been removed since it is not a function of *x’*, and thus
    its gradient is zero. Additionally, the log of *e* raised to any power is just
    the power itself, since log as used here has base *e*. Finally, we expand out
    the dot product of *x’ – x* with itself and apply the gradient to each individual
    term of the resulting sum. Note that we can simply rewrite <math alttext="minus
    x Superscript prime upper T Baseline x minus x Superscript upper T Baseline x
    prime"><mrow><mo>-</mo> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <mi>x</mi> <mo>-</mo> <msup><mi>x</mi> <mi>T</mi></msup> <msup><mi>x</mi> <mo>'</mo></msup></mrow></math>
    as <math alttext="minus 2 x Superscript prime upper T Baseline x"><mrow><mo>-</mo>
    <mn>2</mn> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup> <mi>x</mi></mrow></math>
    since the two terms are transposes of each other and result in the same scalar.
    We refer you to an amazing text called *The Matrix Cookbook* by KB Petersen and
    Michael Syskind Pedersen, which can serve as a guide to evaluating these gradients
    (plus more) and arrive at the final equality. The intuition for the gradient of
    <math alttext="x Superscript prime upper T Baseline x prime"><mrow><msup><mi>x</mi>
    <mrow><mo>'</mo><mi>T</mi></mrow></msup> <msup><mi>x</mi> <mo>'</mo></msup></mrow></math>
    is that it is the analog of the derivative of the square of a variable from single-variable
    calculus.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解这个数学问题。第一个等式只是高斯分布的定义，均值为*x*，方差为<math alttext="sigma squared upper I"><mrow><msup><mi>σ</mi>
    <mn>2</mn></msup> <mi>I</mi></mrow></math>。第二个等式是对数将乘积分解为对数和的结果，以及和的梯度为梯度之和。在第三个等式中，我们看到第一项已被移除，因为它不是*x’*的函数，因此其梯度为零。此外，*e*的对数提升到任意幂仅仅是幂本身，因为这里使用的对数具有基数*e*。最后，我们展开*x’
    – x*与自身的点积，并将梯度应用于结果和的每个单独项。请注意，我们可以简单地将<math alttext="minus x Superscript prime
    upper T Baseline x minus x Superscript upper T Baseline x prime"><mrow><mo>-</mo>
    <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup> <mi>x</mi> <mo>-</mo>
    <msup><mi>x</mi> <mi>T</mi></msup> <msup><mi>x</mi> <mo>'</mo></msup></mrow></math>重写为<math
    alttext="minus 2 x Superscript prime upper T Baseline x"><mrow><mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup> <mi>x</mi></mrow></math>，因为这两项是彼此的转置，并且结果是相同的标量。我们建议您阅读
    KB Petersen 和 Michael Syskind Pedersen 撰写的一本名为*The Matrix Cookbook*的精彩文本，它可以作为评估这些梯度（以及更多内容）并得出最终等式的指南。对于<math
    alttext="x Superscript prime upper T Baseline x prime"><mrow><msup><mi>x</mi>
    <mrow><mo>'</mo><mi>T</mi></mrow></msup> <msup><mi>x</mi> <mo>'</mo></msup></mrow></math>的梯度的直觉是，它类似于单变量微积分中变量平方的导数。
- en: 'For the final step, we will show that optimizing the objective for denoising
    score matching is equivalent to optimizing the objective for denoising AEs. To
    recap, a denoising AE has the same architecture as that of a standard AE—the only
    difference is in the input data and the training objective. The training objective
    of the denoising AE looks like:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，我们将展示，优化去噪得分匹配的目标等效于优化去噪自编码器的目标。回顾一下，去噪自编码器的架构与标准自编码器相同——唯一的区别在于输入数据和训练目标。去噪自编码器的训练目标如下：
- en: <math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    StartAbsoluteValue EndAbsoluteValue decode left-parenthesis encode left-parenthesis
    x Superscript prime Baseline right-parenthesis right-parenthesis minus x StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo>|</mo>
    <mo>|</mo> <mtext>decode</mtext></mrow> <mrow><mo>(</mo> <mtext>encode</mtext>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup>
    <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    StartAbsoluteValue EndAbsoluteValue decode left-parenthesis encode left-parenthesis
    x Superscript prime Baseline right-parenthesis right-parenthesis minus x StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo>|</mo>
    <mo>|</mo> <mtext>decode</mtext></mrow> <mrow><mo>(</mo> <mtext>encode</mtext>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup>
    <mrow><mo>]</mo></mrow></mrow></math>
- en: <math alttext="theta Subscript DAE Superscript asterisk Baseline equals argmin
    Subscript theta Baseline upper J Subscript DAE Baseline left-parenthesis theta
    right-parenthesis"><mrow><msubsup><mi>θ</mi> <mtext>DAE</mtext> <mo>*</mo></msubsup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <msub><mi>J</mi> <mtext>DAE</mtext></msub>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="theta Subscript DAE Superscript asterisk Baseline equals argmin
    Subscript theta Baseline upper J Subscript DAE Baseline left-parenthesis theta
    right-parenthesis"><mrow><msubsup><mi>θ</mi> <mtext>DAE</mtext> <mo>*</mo></msubsup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>θ</mi></msub> <msub><mi>J</mi> <mtext>DAE</mtext></msub>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
- en: 'Note that the parameters, or weights, of both decode() and encode() are encompassed
    by <math alttext="theta"><mi>θ</mi></math> . To summarize, we must show that <math
    alttext="theta Subscript DAE Superscript asterisk"><msubsup><mi>θ</mi> <mtext>DAE</mtext>
    <mo>*</mo></msubsup></math> and <math alttext="theta Subscript DSM Superscript
    asterisk"><msubsup><mi>θ</mi> <mtext>DSM</mtext> <mo>*</mo></msubsup></math> defined
    earlier are equivalent for some form of the unnormalized likelihood. Once again,
    following Vincent 2011, we define the denoising autoencoder as an encoder consisting
    of a single fully connected layer followed by a sigmoid layer and a decoder consisting
    solely of a single fully connected layer. Additionally, we add the constraint
    that the two fully connected layers are weight-tied so that they are transposes
    of each other. The training objective can now be specified as, where <math alttext="theta
    equals left-parenthesis upper W comma b comma c right-parenthesis"><mrow><mi>θ</mi>
    <mo>=</mo> <mo>(</mo> <mi>W</mi> <mo>,</mo> <mi>b</mi> <mo>,</mo> <mi>c</mi> <mo>)</mo></mrow></math>
    :'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，decode() 和 encode() 的参数或权重都由 <math alttext="theta"><mi>θ</mi></math> 包含。总结一下，我们必须证明之前定义的
    <math alttext="theta Subscript DAE Superscript asterisk"><msubsup><mi>θ</mi> <mtext>DAE</mtext>
    <mo>*</mo></msubsup></math> 和 <math alttext="theta Subscript DSM Superscript asterisk"><msubsup><mi>θ</mi>
    <mtext>DSM</mtext> <mo>*</mo></msubsup></math> 对于某种未归一化似然形式是等价的。再次，按照 Vincent
    2011 的方法，我们将去噪自动编码器定义为一个编码器，由一个全连接层和一个 Sigmoid 层组成，以及一个解码器，仅由一个全连接层组成。此外，我们添加了两个全连接层是权重绑定的约束，使它们互为转置。现在可以将训练目标指定为，其中
    <math alttext="theta equals left-parenthesis upper W comma b comma c right-parenthesis"><mrow><mi>θ</mi>
    <mo>=</mo> <mo>(</mo> <mi>W</mi> <mo>,</mo> <mi>b</mi> <mo>,</mo> <mi>c</mi> <mo>)</mo></mrow></math>：
- en: <math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    StartAbsoluteValue EndAbsoluteValue upper W Superscript upper T Baseline left-parenthesis
    upper W x prime plus b right-parenthesis plus c minus x StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi> <mtext>DAE</mtext></msub>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo>|</mo> <mo>|</mo></mrow>
    <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>c</mi>
    <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup>
    <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    StartAbsoluteValue EndAbsoluteValue upper W Superscript upper T Baseline left-parenthesis
    upper W x prime plus b right-parenthesis plus c minus x StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi> <mtext>DAE</mtext></msub>
    <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo>|</mo> <mo>|</mo></mrow>
    <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>c</mi>
    <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup>
    <mrow><mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals 2 sigma Superscript 4 Baseline asterisk double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x comma x Sub
    Superscript prime Subscript right-parenthesis Baseline left-bracket StartFraction
    1 Over 2 sigma Superscript 4 Baseline EndFraction StartAbsoluteValue EndAbsoluteValue
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x StartAbsoluteValue EndAbsoluteValue Subscript 2 Superscript 2 Baseline
    right-bracket"><mrow><mo>=</mo> <mn>2</mn> <msup><mi>σ</mi> <mn>4</mn></msup>
    <mo>*</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>σ</mi> <mn>4</mn></msup></mrow></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn>
    <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals 2 sigma Superscript 4 Baseline asterisk double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x comma x Sub
    Superscript prime Subscript right-parenthesis Baseline left-bracket StartFraction
    1 Over 2 sigma Superscript 4 Baseline EndFraction StartAbsoluteValue EndAbsoluteValue
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x StartAbsoluteValue EndAbsoluteValue Subscript 2 Superscript 2 Baseline
    right-bracket"><mrow><mo>=</mo> <mn>2</mn> <msup><mi>σ</mi> <mn>4</mn></msup>
    <mo>*</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi> <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>σ</mi> <mn>4</mn></msup></mrow></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn>
    <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals 2 sigma Superscript 4 Baseline asterisk double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x comma x Sub
    Superscript prime Subscript right-parenthesis Baseline left-bracket one-half StartAbsoluteValue
    EndAbsoluteValue StartFraction 1 Over sigma squared EndFraction left-parenthesis
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x prime right-parenthesis minus StartFraction 1 Over sigma squared
    EndFraction left-parenthesis x minus x prime right-parenthesis StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mo>=</mo>
    <mn>2</mn> <msup><mi>σ</mi> <mn>4</mn></msup> <mo>*</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mrow><mo>|</mo> <mo>|</mo></mrow> <mfrac><mn>1</mn> <msup><mi>σ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>-</mo>
    <mfrac><mn>1</mn> <msup><mi>σ</mi> <mn>2</mn></msup></mfrac> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <msubsup><mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals 2 sigma Superscript 4 Baseline asterisk double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x comma x Sub
    Superscript prime Subscript right-parenthesis Baseline left-bracket one-half StartAbsoluteValue
    EndAbsoluteValue StartFraction 1 Over sigma squared EndFraction left-parenthesis
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x prime right-parenthesis minus StartFraction 1 Over sigma squared
    EndFraction left-parenthesis x minus x prime right-parenthesis StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mo>=</mo>
    <mn>2</mn> <msup><mi>σ</mi> <mn>4</mn></msup> <mo>*</mo> <msub><mi>𝔼</mi> <mrow><msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mrow><mo>|</mo> <mo>|</mo></mrow> <mfrac><mn>1</mn> <msup><mi>σ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>-</mo>
    <mfrac><mn>1</mn> <msup><mi>σ</mi> <mn>2</mn></msup></mfrac> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <msubsup><mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: You may notice that our algebraic manipulation has led to the appearance of
    <math alttext="normal nabla Subscript x prime Baseline log p Subscript sigma Baseline
    left-parenthesis x prime vertical-bar x right-parenthesis"><mrow><msub><mi>∇</mi>
    <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> . All we need to do now is find a form
    for the unnormalized likelihood whose gradient with respect to *x’* is <math alttext="StartFraction
    1 Over sigma squared EndFraction left-parenthesis upper W Superscript upper T
    Baseline left-parenthesis upper W x prime plus b right-parenthesis plus c minus
    x prime right-parenthesis"><mrow><mfrac><mn>1</mn> <msup><mi>σ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们的代数操作导致了 <math alttext="normal nabla Subscript x prime Baseline log
    p Subscript sigma Baseline left-parenthesis x prime vertical-bar x right-parenthesis"><mrow><msub><mi>∇</mi>
    <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>σ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> 的出现。现在我们只需要找到一个未归一化似然的形式，其相对于 *x’*
    的梯度为 <math alttext="StartFraction 1 Over sigma squared EndFraction left-parenthesis
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x prime right-parenthesis"><mrow><mfrac><mn>1</mn> <msup><mi>σ</mi>
    <mn>2</mn></msup></mfrac> <mrow><mo>(</mo> <msup><mi>W</mi> <mi>T</mi></sup> <mrow><mo>(</mo>
    <mi>W</mi> <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow>
    <mo>+</mo> <mi>c</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>。
- en: As it turns out, if we define the unnormalized likelihood <math alttext="q Subscript
    theta Baseline left-parenthesis x prime right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>θ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
    to be <math alttext="minus StartFraction 1 Over sigma squared EndFraction left-parenthesis
    c Superscript upper T Baseline x minus one-half StartAbsoluteValue EndAbsoluteValue
    x StartAbsoluteValue EndAbsoluteValue Subscript 2 Superscript 2 Baseline plus
    sigma-summation Underscript j equals 1 Overscript d Endscripts softplus left-parenthesis
    upper W Subscript j Superscript upper T Baseline x plus b Subscript j Baseline
    right-parenthesis right-parenthesis"><mrow><mo>-</mo> <mfrac><mn>1</mn> <msup><mi>σ</mi>
    <mn>2</mn></msup></mfrac> <mrow><mo>(</mo></mrow> <msup><mi>c</mi> <mi>T</mi></msup>
    <mi>x</mi> <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msubsup><mrow><mo>|</mo><mo>|</mo><mi>x</mi><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <mtext>softplus</mtext> <mrow><mo>(</mo> <msubsup><mi>W</mi>
    <mi>j</mi> <mi>T</mi></msubsup> <mi>x</mi> <mo>+</mo> <msub><mi>b</mi> <mi>j</mi></msub>
    <mo>)</mo></mrow> <mrow><mo>)</mo></mrow></mrow></math> and plug in this expression
    to the denoising score matching objective, we are left with an objective that
    is just <math alttext="StartFraction 1 Over 2 sigma Superscript 4 Baseline EndFraction
    upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis"><mrow><mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>σ</mi> <mn>4</mn></msup></mrow></mfrac> <msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
    . We refer you to Vincent 2011 to see why this is the case.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，如果我们定义未归一化的似然<math alttext="q Subscript theta Baseline left-parenthesis
    x prime right-parenthesis"><mrow><msub><mi>q</mi> <mi>θ</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math> 为<math alttext="minus
    StartFraction 1 Over sigma squared EndFraction left-parenthesis c Superscript
    upper T Baseline x minus one-half StartAbsoluteValue EndAbsoluteValue x StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline plus sigma-summation Underscript
    j equals 1 Overscript d Endscripts softplus left-parenthesis upper W Subscript
    j Superscript upper T Baseline x plus b Subscript j Baseline right-parenthesis
    right-parenthesis"><mrow><mo>-</mo> <mfrac><mn>1</mn> <msup><mi>σ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo></mrow> <msup><mi>c</mi> <mi>T</mi></msup> <mi>x</mi> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msubsup><mrow><mo>|</mo><mo>|</mo><mi>x</mi><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <mtext>softplus</mtext> <mrow><mo>(</mo> <msubsup><mi>W</mi>
    <mi>j</mi> <mi>T</mi></msubsup> <mi>x</mi> <mo>+</mo> <msub><mi>b</mi> <mi>j</mi></msub>
    <mo>)</mo></mrow> <mrow><mo>)</mo></mrow></mrow></math> 并将此表达式插入去噪得分匹配目标，我们得到的目标只是<math
    alttext="StartFraction 1 Over 2 sigma Superscript 4 Baseline EndFraction upper
    J Subscript DAE Baseline left-parenthesis theta right-parenthesis"><mrow><mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>σ</mi> <mn>4</mn></msup></mrow></mfrac> <msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
    。我们建议您参考Vincent 2011年的原因。
- en: Optimizing this new objective with respect to <math alttext="theta"><mi>θ</mi></math>
    is no different from optimizing a denoising autoencoder. This is because <math
    alttext="sigma"><mi>σ</mi></math> is a positive constant and has no dependence
    on <math alttext="theta"><mi>θ</mi></math> , thus only scaling the magnitude of
    the resulting gradient rather than affecting its direction. In summary, we have
    found that training a denoising AE is the same as optimizing the denoising score
    matching objective, where the unnormalized likelihood takes the form specified
    in the previous paragraph. More simply, the weights of a trained denoising AE
    would be the same as those of an unnormalized likelihood specified by <math alttext="minus
    StartFraction 1 Over sigma squared EndFraction left-parenthesis c Superscript
    upper T Baseline x minus one-half StartAbsoluteValue EndAbsoluteValue x StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline plus sigma-summation Underscript
    j equals 1 Overscript d Endscripts softplus left-parenthesis upper W Subscript
    j Superscript upper T Baseline x plus b Subscript j Baseline right-parenthesis
    right-parenthesis"><mrow><mo>-</mo> <mfrac><mn>1</mn> <msup><mi>σ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo></mrow> <msup><mi>c</mi> <mi>T</mi></msup> <mi>x</mi> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msubsup><mrow><mo>|</mo><mo>|</mo><mi>x</mi><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <mtext>softplus</mtext> <mrow><mo>(</mo> <msubsup><mi>W</mi>
    <mi>j</mi> <mi>T</mi></msubsup> <mi>x</mi> <mo>+</mo> <msub><mi>b</mi> <mi>j</mi></msub>
    <mo>)</mo></mrow> <mrow><mo>)</mo></mrow></mrow></math> and trained via denoising
    score matching.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 优化这个新目标关于<math alttext="theta"><mi>θ</mi></math> 的情况与优化去噪自编码器没有区别。这是因为<math
    alttext="sigma"><mi>σ</mi></math> 是一个正常数，不依赖于<math alttext="theta"><mi>θ</mi></math>，因此只是缩放梯度的幅度而不影响其方向。总之，我们发现训练去噪自编码器与优化去噪得分匹配目标是相同的，其中未归一化的似然采用前一段指定的形式。更简单地说，训练好的去噪自编码器的权重将与通过去噪得分匹配指定的未归一化似然的权重相同。
- en: 'All we would need to do to perform generative modeling using a denoising AE
    is:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用去噪自编码器执行生成建模，我们需要做的是：
- en: Fully train the denoising AE by minimizing <math alttext="upper J Subscript
    DAE Baseline left-parenthesis theta right-parenthesis"><mrow><msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过最小化<math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis"><mrow><msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mrow></math>
    来完全训练去噪自编码器。
- en: For a given <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> , calculate its score
    by evaluating <math alttext="StartFraction 1 Over sigma squared EndFraction left-parenthesis
    decode left-parenthesis encode left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis right-parenthesis minus x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mfrac><mn>1</mn>
    <msup><mi>σ</mi> <mn>2</mn></msup></mfrac> <mrow><mo>(</mo> <mtext>decode</mtext>
    <mrow><mo>(</mo> <mtext>encode</mtext> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> .
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于给定的<math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>，通过评估<math alttext="StartFraction
    1 Over sigma squared EndFraction left-parenthesis decode left-parenthesis encode
    left-parenthesis x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    right-parenthesis minus x Superscript left-parenthesis i right-parenthesis Baseline
    right-parenthesis"><mrow><mfrac><mn>1</mn> <msup><mi>σ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo> <mtext>decode</mtext> <mrow><mo>(</mo> <mtext>encode</mtext>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>来计算其分数。
- en: Sample <math alttext="epsilon"><mi>ϵ</mi></math> from *N(0,I).*
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*N(0,I)*中抽取样本<math alttext="epsilon"><mi>ϵ</mi></math>。
- en: Plug in the results of 2 and 3 into the Langevin dynamics equation to obtain
    the next sample <math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    .
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将2和3的结果代入Langevin动力学方程中，得到下一个样本<math alttext="x Superscript left-parenthesis
    i plus 1 right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>。
- en: Repeat steps 2 through 4 with <math alttext="x Superscript left-parenthesis
    i plus 1 right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    .
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2到4，使用<math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>。
- en: Though we’ve gotten around the issue of needing to calculate second-order gradients
    by using this method, there is still the issue of being able to sample only from
    the noisy approximation of *p(x)*. More recent work builds off of concepts from
    both implicit score matching and denoising score matching to achieve even stronger
    and more realistic generative capabilities. We highly recommend you explore the
    literature further, as most of the prerequisite material has been covered in these
    sections.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通过使用这种方法解决了需要计算二阶梯度的问题，但仍然存在只能从*p(x)*的嘈杂近似中进行采样的问题。最近的工作借鉴了隐式分数匹配和去噪分数匹配的概念，以实现更强大和更逼真的生成能力。我们强烈建议您进一步探索文献，因为这些部分已经涵盖了大部分先决条件材料。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In summary, we have learned a great deal about generative models. We covered
    the motivation and mathematics behind GANs, VAEs, and a few forms of score matching,
    and even implemented a VAE from scratch. We also learned about the similarities
    and differences between these methods. For example, a GAN implicitly models a
    complex distribution that we can sample from via its generator, while a VAE explicitly
    learns distributions but is slightly more restrictive in the complexity of distributions
    it can model. Implicit score matching, similarly to GANs, allowed us to sample
    from complex distributions via Langevin dynamics (without the use of an additional
    noise distribution *p(z))*, but having to compute second-order gradients led us
    to the development of the denoising score matching and its connection with pre-existing
    denoising AEs. Additionally, VAEs took on the strongest probabilistic modeling
    approach of the three by defining a set of latent variables and explicitly learning
    an approximate posterior, given an input example, and a likelihood function, given
    a setting of latent variables. In contrast, for GANs, the additional variable
    *z’s* purpose is solely as an intermediate for sampling. Although all of these
    models tackle generative modeling from distinct perspectives and motivations,
    they have all produced strong results and have laid a solid groundwork for current
    and future research.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经学到了很多关于生成模型的知识。我们涵盖了GANs、VAEs以及一些形式的分数匹配背后的动机和数学，甚至从头开始实现了一个VAE。我们还了解了这些方法之间的相似之处和不同之处。例如，GAN隐式地建模了一个复杂的分布，我们可以通过其生成器进行采样，而VAE明确地学习分布，但在其可以建模的分布复杂性方面略微受限。隐式分数匹配与GAN类似，允许我们通过Langevin动力学从复杂的分布中进行采样（而无需使用额外的噪声分布*p(z)），但是必须计算二阶梯度导致我们开发了去噪分数匹配以及其与现有去噪AE的联系。此外，VAE通过定义一组潜在变量并明确学习近似后验（给定输入示例）和似然函数（给定潜在变量设置）而采取了三种方法中最强大的概率建模方法。相比之下，对于GANs，附加变量*z*的目的仅仅是作为采样的中间变量。尽管所有这些模型从不同的角度和动机来解决生成建模问题，但它们都取得了强大的结果，并为当前和未来的研究奠定了坚实的基础。
- en: ^([1](ch10.xhtml#idm45934165113648-marker)) Goodfellow et al. “Generative Adversarial
    Networks.” *arXiv Preprint arXiv*:1406.2661\. 2014.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#idm45934165113648-marker)) Goodfellow等人。“生成对抗网络。”*arXiv预印本arXiv*:1406.2661。2014年。
- en: ^([2](ch10.xhtml#idm45934168472352-marker)) Kingma et al. “Auto-Encoding Variational
    Bayes.” *arXiv Preprint arXiv*:1312.6114\. 2014.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.xhtml#idm45934168472352-marker)) Kingma等人。“自动编码变分贝叶斯。”*arXiv预印本arXiv*:1312.6114。2014年。
