- en: Chapter 10\. Generative Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬åç« . ç”Ÿæˆæ¨¡å‹
- en: Generative models attempt to understand the *latent*, or underlying, process
    that produces the data we see. For example, when breaking down images of digits
    in the MNIST dataset, we can interpret some attributes of the underlying process
    generating each image as the digit itself (a discrete variable ranging from zero
    through nine), the orientation or angle at which it will be drawn, the size of
    the resulting image, the thickness of the lines, and some noise component (all
    of which are continuous variables). So far, weâ€™ve been concerned with *discriminative*
    models, either in the regression or classification setting. In the classification
    setting, discriminative models take as input an example such as an image from
    the MNIST dataset and attempt to determine the most likely digit category, from
    zero through nine, that the input belongs to. Generative models instead attempt
    to fully model the data distribution, and in the process may implicitly try to
    learn some of the features mentioned previously to generate images that look as
    if they were originally from the MNIST dataset. Note that generative modeling
    is a harder problem than discriminative modeling, as a discriminative model may,
    for example, need to learn only a few features well to distinguish between different
    digits in the MNIST dataset to a satisfactory degree. Generative models come in
    many varieties, and in this chapter, we provide a glimpse into a vast research
    landscape that has begun to blossom only in the past decade.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿæˆæ¨¡å‹è¯•å›¾ç†è§£äº§ç”Ÿæˆ‘ä»¬æ‰€çœ‹åˆ°çš„æ•°æ®çš„*æ½œåœ¨*æˆ–åŸºç¡€è¿‡ç¨‹ã€‚ä¾‹å¦‚ï¼Œåœ¨åˆ†è§£MNISTæ•°æ®é›†ä¸­çš„æ•°å­—å›¾åƒæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç”Ÿæˆæ¯ä¸ªå›¾åƒçš„æ½œåœ¨è¿‡ç¨‹çš„ä¸€äº›å±æ€§è§£é‡Šä¸ºæ•°å­—æœ¬èº«ï¼ˆä»é›¶åˆ°ä¹çš„ç¦»æ•£å˜é‡ï¼‰ã€å°†ç»˜åˆ¶å›¾åƒçš„æ–¹å‘æˆ–è§’åº¦ã€ç”Ÿæˆå›¾åƒçš„å¤§å°ã€çº¿æ¡çš„ç²—ç»†ä»¥åŠä¸€äº›å™ªå£°æˆåˆ†ï¼ˆæ‰€æœ‰è¿™äº›éƒ½æ˜¯è¿ç»­å˜é‡ï¼‰ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å…³æ³¨çš„æ˜¯*é‰´åˆ«*æ¨¡å‹ï¼Œæ— è®ºæ˜¯åœ¨å›å½’è¿˜æ˜¯åˆ†ç±»è®¾ç½®ä¸­ã€‚åœ¨åˆ†ç±»è®¾ç½®ä¸­ï¼Œé‰´åˆ«æ¨¡å‹å°†MNISTæ•°æ®é›†ä¸­çš„å›¾åƒä½œä¸ºè¾“å…¥ï¼Œå¹¶å°è¯•ç¡®å®šè¾“å…¥æœ€æœ‰å¯èƒ½å±äºçš„æ•°å­—ç±»åˆ«ï¼Œä»é›¶åˆ°ä¹ã€‚ç”Ÿæˆæ¨¡å‹åˆ™å°è¯•å®Œå…¨å»ºæ¨¡æ•°æ®åˆ†å¸ƒï¼Œå¹¶åœ¨æ­¤è¿‡ç¨‹ä¸­å¯èƒ½éšå«åœ°å°è¯•å­¦ä¹ å…ˆå‰æåˆ°çš„ä¸€äº›ç‰¹å¾ï¼Œä»¥ç”Ÿæˆçœ‹èµ·æ¥å°±åƒæœ€åˆæ¥è‡ªMNISTæ•°æ®é›†çš„å›¾åƒã€‚è¯·æ³¨æ„ï¼Œç”Ÿæˆå»ºæ¨¡æ¯”é‰´åˆ«å»ºæ¨¡æ›´éš¾ï¼Œå› ä¸ºä¾‹å¦‚ï¼Œé‰´åˆ«æ¨¡å‹å¯èƒ½åªéœ€è¦å¾ˆå¥½åœ°å­¦ä¹ å‡ ä¸ªç‰¹å¾ï¼Œä»¥ä»¤äººæ»¡æ„åœ°åŒºåˆ†MNISTæ•°æ®é›†ä¸­ä¸åŒæ•°å­—ä¹‹é—´çš„å·®å¼‚ã€‚ç”Ÿæˆæ¨¡å‹æœ‰è®¸å¤šç§ç±»ï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç¥è§è¿‡å»åå¹´æ‰å¼€å§‹è“¬å‹ƒå‘å±•çš„å¹¿é˜”ç ”ç©¶é¢†åŸŸã€‚
- en: Generative Adversarial Networks
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç”Ÿæˆå¯¹æŠ—ç½‘ç»œ
- en: '*Generative Adversarial Networks*, or GANs for short, are a form of generative
    model designed to produce realistic samples of entities, such as images, from
    noise. They were introduced by Goodfellow et al. in 2014.^([1](ch10.xhtml#idm45934165113648))
    For the remainder of this section, we will assume we are working with an image
    dataset such as MNIST or CIFAR-10\. The original GAN architecture is broken down
    into two neural networks: the *discriminator* and the *generator.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*ç”Ÿæˆå¯¹æŠ—ç½‘ç»œ*ï¼Œç®€ç§°GANsï¼Œæ˜¯ä¸€ç§æ—¨åœ¨ä»å™ªå£°ä¸­ç”Ÿæˆé€¼çœŸå®ä½“æ ·æœ¬ï¼ˆå¦‚å›¾åƒï¼‰çš„ç”Ÿæˆæ¨¡å‹ã€‚å®ƒä»¬ç”±Goodfellowç­‰äººäº2014å¹´æå‡ºã€‚åœ¨æœ¬èŠ‚çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†å‡è®¾æˆ‘ä»¬æ­£åœ¨å¤„ç†å›¾åƒæ•°æ®é›†ï¼Œå¦‚MNISTæˆ–CIFAR-10ã€‚åŸå§‹çš„GANæ¶æ„è¢«åˆ†è§£ä¸ºä¸¤ä¸ªç¥ç»ç½‘ç»œï¼š*é‰´åˆ«å™¨*å’Œ*ç”Ÿæˆå™¨*ã€‚'
- en: The generator takes in samples from some noise distribution, such as a multivariate
    Gaussian distribution, and outputs an image. The discriminator is tasked with
    predicting whether this image was produced by the generator or was sampled from
    the original dataset. As the generator gets better and better at producing images
    that look real, the discriminator has a harder time determining whether a given
    image was produced by the generator or sampled from the dataset. We can think
    of these two networks as participating in a game, competing against each other
    to develop. Each network evolves until the generator can eventually produce images
    that look as if they were drawn directly from the original dataset, and the discriminator
    cannot distinguish between the two sets of images, i.e., predicts that any image
    is from the dataset with probability <math alttext="one-half"><mfrac><mn>1</mn>
    <mn>2</mn></mfrac></math> .
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿæˆå™¨ä»ä¸€äº›å™ªå£°åˆ†å¸ƒï¼ˆå¦‚å¤šå…ƒé«˜æ–¯åˆ†å¸ƒï¼‰ä¸­è·å–æ ·æœ¬ï¼Œå¹¶è¾“å‡ºä¸€å¹…å›¾åƒã€‚é‰´åˆ«å™¨çš„ä»»åŠ¡æ˜¯é¢„æµ‹è¿™å¹…å›¾åƒæ˜¯ç”±ç”Ÿæˆå™¨ç”Ÿæˆçš„ï¼Œè¿˜æ˜¯ä»åŸå§‹æ•°æ®é›†ä¸­æŠ½æ ·çš„ã€‚éšç€ç”Ÿæˆå™¨è¶Šæ¥è¶Šæ“…é•¿ç”Ÿæˆçœ‹èµ·æ¥çœŸå®çš„å›¾åƒï¼Œé‰´åˆ«å™¨è¶Šæ¥è¶Šéš¾ä»¥ç¡®å®šç»™å®šå›¾åƒæ˜¯ç”±ç”Ÿæˆå™¨ç”Ÿæˆçš„è¿˜æ˜¯ä»æ•°æ®é›†ä¸­æŠ½æ ·çš„ã€‚æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸¤ä¸ªç½‘ç»œçœ‹ä½œå‚ä¸ä¸€åœºæ¸¸æˆï¼Œå½¼æ­¤ç«äº‰ä»¥å‘å±•ã€‚æ¯ä¸ªç½‘ç»œéƒ½ä¼šä¸æ–­æ¼”åŒ–ï¼Œç›´åˆ°ç”Ÿæˆå™¨æœ€ç»ˆèƒ½å¤Ÿç”Ÿæˆçœ‹èµ·æ¥å°±åƒç›´æ¥ä»åŸå§‹æ•°æ®é›†ä¸­ç»˜åˆ¶å‡ºæ¥çš„å›¾åƒï¼Œè€Œé‰´åˆ«å™¨æ— æ³•åŒºåˆ†è¿™ä¸¤ç»„å›¾åƒï¼Œå³é¢„æµ‹ä»»ä½•å›¾åƒæ¥è‡ªæ•°æ®é›†çš„æ¦‚ç‡ä¸º1/2ã€‚
- en: More rigorously, we define the data distribution to be <math alttext="p Subscript
    data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> . Although we can
    never really know the true data distribution, in practice we generally think of
    it as being approximated well enough by the dataset we have on hand ( <math alttext="p
    Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    is just a uniform distribution over all of the images present in the dataset and
    zero likelihood associated with all images that are not in the dataset).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´ä¸¥æ ¼åœ°è¯´ï¼Œæˆ‘ä»¬å®šä¹‰æ•°æ®åˆ†å¸ƒä¸ºp_data(x)ã€‚è™½ç„¶æˆ‘ä»¬æ°¸è¿œæ— æ³•çœŸæ­£äº†è§£çœŸå®çš„æ•°æ®åˆ†å¸ƒï¼Œä½†åœ¨å®è·µä¸­ï¼Œæˆ‘ä»¬é€šå¸¸è®¤ä¸ºæˆ‘ä»¬æ‰‹å¤´çš„æ•°æ®é›†è¶³å¤Ÿå¥½åœ°è¿‘ä¼¼äº†å®ƒï¼ˆp_data(x)åªæ˜¯æ•°æ®é›†ä¸­æ‰€æœ‰å›¾åƒçš„å‡åŒ€åˆ†å¸ƒï¼Œå¹¶ä¸”ä¸ä¸åœ¨æ•°æ®é›†ä¸­çš„æ‰€æœ‰å›¾åƒç›¸å…³è”çš„å¯èƒ½æ€§ä¸ºé›¶ï¼‰ã€‚
- en: We additionally define the distribution parametrized by the generator to be
    <math alttext="p Subscript g Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    . The random variable *x* represents an entity such as an image, a collection
    of pixels that can each be thought of as their own random variables. The generator,
    which we also refer to as *G*, defines <math alttext="p Subscript g Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> by mapping samples from the noise distribution,
    which we will refer to as *p(z)*, to the data space, which consists of all possible
    images (not just those in the dataset). It is important to keep in mind that *G*
    itself is a deterministic function, but implicitly defines a distribution by acting
    on the noise distribution. Note that this distribution is implicit because we
    can generate samples from it only via *G(z),* rather than being an explicit distribution
    we can work with directly and query an image for its likelihood. [FigureÂ 10-1](#the_discriminator_is_tasked_with_determining_whether_any_input)
    shows the typical GAN architecture.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦å¤–å®šä¹‰ç”±ç”Ÿæˆå™¨å‚æ•°åŒ–çš„åˆ†å¸ƒä¸º<p<sub>g</sub>(x)>ã€‚éšæœºå˜é‡*x*ä»£è¡¨ä¸€ä¸ªå®ä½“ï¼Œæ¯”å¦‚ä¸€å¹…å›¾åƒï¼Œä¸€ä¸ªç”±æ¯ä¸ªåƒç´ ç»„æˆçš„é›†åˆï¼Œæ¯ä¸ªåƒç´ å¯ä»¥è¢«è§†ä¸ºè‡ªå·±çš„éšæœºå˜é‡ã€‚æˆ‘ä»¬ä¹Ÿç§°ä¹‹ä¸º*G*çš„ç”Ÿæˆå™¨é€šè¿‡å°†ä»å™ªå£°åˆ†å¸ƒä¸­é‡‡æ ·çš„æ ·æœ¬æ˜ å°„åˆ°æ•°æ®ç©ºé—´æ¥å®šä¹‰<p<sub>g</sub>(x)ï¼Œæˆ‘ä»¬å°†å…¶ç§°ä¸º*p(z)*ï¼Œæ•°æ®ç©ºé—´åŒ…æ‹¬æ‰€æœ‰å¯èƒ½çš„å›¾åƒï¼ˆä¸ä»…ä»…æ˜¯æ•°æ®é›†ä¸­çš„å›¾åƒï¼‰ã€‚é‡è¦çš„æ˜¯è¦è®°ä½*G*æœ¬èº«æ˜¯ä¸€ä¸ªç¡®å®šæ€§å‡½æ•°ï¼Œä½†é€šè¿‡ä½œç”¨äºå™ªå£°åˆ†å¸ƒéšå«åœ°å®šä¹‰äº†ä¸€ä¸ªåˆ†å¸ƒã€‚è¯·æ³¨æ„ï¼Œè¿™ä¸ªåˆ†å¸ƒæ˜¯éšå«çš„ï¼Œå› ä¸ºæˆ‘ä»¬åªèƒ½é€šè¿‡*G(z)*ç”Ÿæˆæ ·æœ¬ï¼Œè€Œä¸èƒ½ç›´æ¥ä½¿ç”¨å®ƒå¹¶æŸ¥è¯¢å›¾åƒçš„å¯èƒ½æ€§ã€‚[å›¾10-1](#the_discriminator_is_tasked_with_determining_whether_any_input)å±•ç¤ºäº†å…¸å‹çš„GANæ¶æ„ã€‚
- en: '![](Images/fdl2_1001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1001.png)'
- en: Figure 10-1\. The discriminator determines whether any input image was sampled
    from the dataset or generator. The generatorâ€™s goal is to trick the discriminator
    into believing its images were sampled from the dataset.
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾10-1ã€‚é‰´åˆ«å™¨ç¡®å®šä»»ä½•è¾“å…¥å›¾åƒæ˜¯ä»æ•°æ®é›†è¿˜æ˜¯ç”Ÿæˆå™¨ä¸­é‡‡æ ·çš„ã€‚ç”Ÿæˆå™¨çš„ç›®æ ‡æ˜¯æ¬ºéª—é‰´åˆ«å™¨ï¼Œä½¿å…¶ç›¸ä¿¡å…¶å›¾åƒæ˜¯ä»æ•°æ®é›†ä¸­é‡‡æ ·çš„ã€‚
- en: An optimal generator for a given dataset would also parametrize <math alttext="p
    Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , as this would perfectly confuse even the best discriminator. In other words,
    if the generator parametrizes the exact same distribution as that of the dataset
    and it is equally likely to sample from either the generator or the dataset, then
    no discriminator would be able to tell where the query originated from, as both
    are always equally likely. We formalize this intuition in the next paragraph.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºç»™å®šæ•°æ®é›†çš„æœ€ä½³ç”Ÿæˆå™¨è¿˜ä¼šå‚æ•°åŒ–<p<sub>data</sub>(x)ï¼Œå› ä¸ºè¿™å°†å®Œå…¨æ··æ·†ç”šè‡³æœ€å¥½çš„é‰´åˆ«å™¨ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœç”Ÿæˆå™¨å‚æ•°åŒ–ä¸æ•°æ®é›†å®Œå…¨ç›¸åŒçš„åˆ†å¸ƒï¼Œå¹¶ä¸”ä»ç”Ÿæˆå™¨æˆ–æ•°æ®é›†ä¸­é‡‡æ ·çš„å¯èƒ½æ€§ç›¸ç­‰ï¼Œé‚£ä¹ˆæ²¡æœ‰é‰´åˆ«å™¨èƒ½å¤Ÿå‘Šè¯‰æŸ¥è¯¢çš„æ¥æºï¼Œå› ä¸ºä¸¤è€…å§‹ç»ˆæ˜¯åŒç­‰å¯èƒ½çš„ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€æ®µæ­£å¼è¡¨è¾¾è¿™ç§ç›´è§‰ã€‚
- en: 'Thinking back to [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba), given a generator
    that parametrizes the same distribution as the dataset, we have <math alttext="p
    left-parenthesis x vertical-bar y equals generator right-parenthesis equals p
    left-parenthesis x vertical-bar y equals dataset right-parenthesis comma for-all
    x"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo> <mo>,</mo> <mo>âˆ€</mo> <mi>x</mi></mrow></math>
    , where *y* is a Bernoulli random variable over the two options: generator or
    dataset. Note that we use <math alttext="p Subscript g Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> and <math alttext="p left-parenthesis
    x vertical-bar y equals generator right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow></math>
    interchangeably, and <math alttext="p Subscript data Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> and <math alttext="p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></math>
    interchangeably, since they mean the same thing. The latter option of each allows
    us to keep in mind we are working with conditional probabilities. Again, assuming
    that sampling from the generator and sampling from the dataset are equally likely,
    or <math alttext="p left-parenthesis y equals generator right-parenthesis equals
    p left-parenthesis y equals dataset right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo> <mo>=</mo> <mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></math>
    , we can use Bayesâ€™ Rule to obtain the equality: <math alttext="p left-parenthesis
    y equals generator vertical-bar x right-parenthesis equals p left-parenthesis
    y equals dataset vertical-bar x right-parenthesis comma for-all x"><mrow><mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mo>âˆ€</mo> <mi>x</mi></mrow></math>
    . Since there are only two options, as *y* is a Bernoulli random variable, we
    are left with the perfectly confused discriminator alluded to earlier that predicts
    any image to be sampled from the dataset with probability <math alttext="one-half"><mfrac><mn>1</mn>
    <mn>2</mn></mfrac></math> .'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹[ç¬¬2ç« ](ch02.xhtml#fundamentals-of-proba)ï¼Œå‡è®¾æœ‰ä¸€ä¸ªç”Ÿæˆå™¨å‚æ•°åŒ–ä¸æ•°æ®é›†ç›¸åŒçš„åˆ†å¸ƒï¼Œæˆ‘ä»¬æœ‰<math alttext="p
    left-parenthesis x vertical-bar y equals generator right-parenthesis equals p
    left-parenthesis x vertical-bar y equals dataset right-parenthesis comma for-all
    x"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo> <mo>,</mo> <mo>âˆ€</mo> <mi>x</mi></mrow></math>ï¼Œå…¶ä¸­*y*æ˜¯ä¸€ä¸ªä¼¯åŠªåˆ©éšæœºå˜é‡ï¼Œæœ‰ä¸¤ä¸ªé€‰é¡¹ï¼šç”Ÿæˆå™¨æˆ–æ•°æ®é›†ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å¯ä»¥äº’æ¢ä½¿ç”¨<math
    alttext="p Subscript g Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>å’Œ<math
    alttext="p left-parenthesis x vertical-bar y equals generator right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo></mrow></math>ï¼Œä»¥åŠ<math alttext="p Subscript data Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>å’Œ<math alttext="p left-parenthesis x
    vertical-bar y equals dataset right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></math>ï¼Œå› ä¸ºå®ƒä»¬è¡¨ç¤ºç›¸åŒçš„å«ä¹‰ã€‚æ¯ä¸ªåè€…é€‰é¡¹è®©æˆ‘ä»¬è®°ä½æˆ‘ä»¬æ­£åœ¨å¤„ç†æ¡ä»¶æ¦‚ç‡ã€‚å†æ¬¡å‡è®¾ä»ç”Ÿæˆå™¨é‡‡æ ·å’Œä»æ•°æ®é›†é‡‡æ ·æ˜¯åŒç­‰å¯èƒ½çš„ï¼Œæˆ–<math
    alttext="p left-parenthesis y equals generator right-parenthesis equals p left-parenthesis
    y equals dataset right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>generator</mtext> <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi>
    <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></math>ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è´å¶æ–¯å®šç†å¾—åˆ°ç­‰å¼ï¼š<math
    alttext="p left-parenthesis y equals generator vertical-bar x right-parenthesis
    equals p left-parenthesis y equals dataset vertical-bar x right-parenthesis comma
    for-all x"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mo>âˆ€</mo>
    <mi>x</mi></mrow></math>ã€‚ç”±äºåªæœ‰ä¸¤ä¸ªé€‰é¡¹ï¼Œå› ä¸º*y*æ˜¯ä¸€ä¸ªä¼¯åŠªåˆ©éšæœºå˜é‡ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¹‹å‰æåˆ°çš„å®Œå…¨æ··æ·†çš„é‰´åˆ«å™¨ï¼Œé¢„æµ‹ä»»ä½•å›¾åƒè¢«ä»æ•°æ®é›†ä¸­é‡‡æ ·çš„æ¦‚ç‡ä¸º<math
    alttext="one-half"><mfrac><mn>1</mn> <mn>2</mn></mfrac></math>ã€‚
- en: 'Knowing our end goal, we can now go about designing an objective function for
    training our generator and discriminator in tandem. In the original GAN paper,
    the objective presented was:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: äº†è§£æˆ‘ä»¬çš„æœ€ç»ˆç›®æ ‡åï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å¼€å§‹è®¾è®¡ä¸€ä¸ªç›®æ ‡å‡½æ•°ï¼Œç”¨äºåŒæ—¶è®­ç»ƒæˆ‘ä»¬çš„ç”Ÿæˆå™¨å’Œé‰´åˆ«å™¨ã€‚åœ¨åŸå§‹çš„GANè®ºæ–‡ä¸­ï¼Œæå‡ºçš„ç›®æ ‡æ˜¯ï¼š
- en: <math alttext="upper V left-parenthesis upper G comma upper D right-parenthesis
    equals double-struck upper E Subscript x tilde p Sub Subscript data Subscript
    left-parenthesis x right-parenthesis Baseline left-bracket log upper D left-parenthesis
    x right-parenthesis right-bracket plus double-struck upper E Subscript z tilde
    p left-parenthesis z right-parenthesis Baseline left-bracket log left-parenthesis
    1 minus upper D left-parenthesis upper G left-parenthesis z right-parenthesis
    right-parenthesis right-bracket"><mrow><mi>V</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><mi>z</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper V left-parenthesis upper G comma upper D right-parenthesis
    equals double-struck upper E Subscript x tilde p Sub Subscript data Subscript
    left-parenthesis x right-parenthesis Baseline left-bracket log upper D left-parenthesis
    x right-parenthesis right-bracket plus double-struck upper E Subscript z tilde
    p left-parenthesis z right-parenthesis Baseline left-bracket log left-parenthesis
    1 minus upper D left-parenthesis upper G left-parenthesis z right-parenthesis
    right-parenthesis right-bracket"><mrow><mi>V</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><mi>z</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
- en: '*G(z)* represents the mapping from the noise distribution to the data space
    described earlier, and *D(x)* represents the score assigned to the input image.
    *D(x)* is interpreted as the probability that the input image was drawn from the
    dataset. Of course, the discriminator *D* would like to maximize this objectiveâ€”this
    corresponds with assigning high probabilities to images drawn from the dataset
    rather than images produced by the generator *G*. *G*, on the other hand, would
    like to minimize this objective, since that corresponds with producing realistic
    images, or even images that look exactly like those from the dataset, that confuse
    *D* and cause it to return a high score for these generator-produced images. This
    idea of maximizing the objective for one network and minimizing the objective
    for the other is termed *minimax,* and the optimization procedure looks like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*G(z)*ä»£è¡¨ä»å™ªå£°åˆ†å¸ƒåˆ°æ•°æ®ç©ºé—´çš„æ˜ å°„ï¼Œ*D(x)*ä»£è¡¨åˆ†é…ç»™è¾“å…¥å›¾åƒçš„åˆ†æ•°ã€‚*D(x)*è¢«è§£é‡Šä¸ºè¾“å…¥å›¾åƒæ¥è‡ªæ•°æ®é›†çš„æ¦‚ç‡ã€‚å½“ç„¶ï¼Œé‰´åˆ«å™¨*D*å¸Œæœ›æœ€å¤§åŒ–è¿™ä¸ªç›®æ ‡â€”â€”è¿™å¯¹åº”äºä¸ºä»æ•°æ®é›†ä¸­ç»˜åˆ¶çš„å›¾åƒåˆ†é…é«˜æ¦‚ç‡ï¼Œè€Œä¸æ˜¯ç”±ç”Ÿæˆå™¨*G*ç”Ÿæˆçš„å›¾åƒã€‚å¦ä¸€æ–¹é¢ï¼Œ*G*å¸Œæœ›æœ€å°åŒ–è¿™ä¸ªç›®æ ‡ï¼Œå› ä¸ºè¿™å¯¹åº”äºç”Ÿæˆé€¼çœŸçš„å›¾åƒï¼Œç”šè‡³æ˜¯ä¸æ•°æ®é›†ä¸­çš„å›¾åƒå®Œå…¨ç›¸åŒçš„å›¾åƒï¼Œè¿™ä¼šè®©*D*æ„Ÿåˆ°å›°æƒ‘ï¼Œå¹¶å¯¼è‡´å®ƒä¸ºè¿™äº›ç”Ÿæˆå™¨ç”Ÿæˆçš„å›¾åƒè¿”å›é«˜åˆ†æ•°ã€‚è¿™ç§æœ€å¤§åŒ–ä¸€ä¸ªç½‘ç»œçš„ç›®æ ‡å’Œæœ€å°åŒ–å¦ä¸€ä¸ªç½‘ç»œçš„ç›®æ ‡çš„æƒ³æ³•è¢«ç§°ä¸º*minimax*ï¼Œä¼˜åŒ–è¿‡ç¨‹å¦‚ä¸‹ï¼š'
- en: <math alttext="min Subscript upper G Baseline max Subscript upper D Baseline
    double-struck upper E Subscript x tilde p Sub Subscript data Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log upper D left-parenthesis x right-parenthesis
    right-bracket plus double-struck upper E Subscript z tilde p left-parenthesis
    z right-parenthesis Baseline left-bracket log left-parenthesis 1 minus upper D
    left-parenthesis upper G left-parenthesis z right-parenthesis right-parenthesis
    right-bracket"><mrow><msub><mtext>min</mtext> <mi>G</mi></msub> <msub><mtext>max</mtext>
    <mi>D</mi></msub> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><mi>z</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="min Subscript upper G Baseline max Subscript upper D Baseline
    double-struck upper E Subscript x tilde p Sub Subscript data Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log upper D left-parenthesis x right-parenthesis
    right-bracket plus double-struck upper E Subscript z tilde p left-parenthesis
    z right-parenthesis Baseline left-bracket log left-parenthesis 1 minus upper D
    left-parenthesis upper G left-parenthesis z right-parenthesis right-parenthesis
    right-bracket"><mrow><msub><mtext>min</mtext> <mi>G</mi></msub> <msub><mtext>max</mtext>
    <mi>D</mi></msub> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><mi>z</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
- en: 'The paper goes on to show that, for a fixed generator *G,* the optimal discriminator
    trained under this objective would output the following score:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è®ºæ–‡ç»§ç»­å±•ç¤ºï¼Œå¯¹äºå›ºå®šç”Ÿæˆå™¨*G*ï¼Œåœ¨è¿™ä¸ªç›®æ ‡ä¸‹è®­ç»ƒçš„æœ€ä¼˜é‰´åˆ«å™¨å°†è¾“å‡ºä»¥ä¸‹å¾—åˆ†ï¼š
- en: <math alttext="StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis
    Over p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis
    Over p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
- en: for a given image *x*. First, we consider why this should even describe the
    behavior of an optimal discriminator given a fixed generator. Before we get into
    the â€œwhy,â€ itâ€™s important to keep in mind that *D* can be alternatively represented
    as <math alttext="p Subscript theta Baseline left-parenthesis y equals dataset
    vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , or the discriminatorâ€™s belief that the image was drawn from the dataset. Here
    <math alttext="theta"><mi>Î¸</mi></math> represents the parameters, or weights,
    of *D.* When we perform an update operation such as gradient descent, <math alttext="theta"><mi>Î¸</mi></math>
    represents the set of weights that is being updated. It is important to keep in
    mind that this distribution is distinct from <math alttext="p left-parenthesis
    y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    mentioned earlierâ€”the latter is the true probability that a given image was sampled
    from the dataset.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºç»™å®šçš„å›¾åƒ*x*ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬è€ƒè™‘ä¸ºä»€ä¹ˆè¿™åº”è¯¥æè¿°ä¸€ä¸ªå›ºå®šç”Ÿæˆå™¨ä¸‹æœ€ä¼˜é‰´åˆ«å™¨çš„è¡Œä¸ºã€‚åœ¨æˆ‘ä»¬æ·±å…¥â€œä¸ºä»€ä¹ˆâ€ä¹‹å‰ï¼Œé‡è¦çš„æ˜¯è¦è®°ä½*D*å¯ä»¥è¢«å¦å¤–è¡¨ç¤ºä¸º<math
    alttext="p Subscript theta Baseline left-parenthesis y equals dataset vertical-bar
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼Œæˆ–è€…é‰´åˆ«å™¨è®¤ä¸ºå›¾åƒæ˜¯ä»æ•°æ®é›†ä¸­æŠ½å–çš„ä¿¡å¿µã€‚è¿™é‡Œ<math
    alttext="theta"><mi>Î¸</mi></math>ä»£è¡¨*D*çš„å‚æ•°æˆ–æƒé‡ã€‚å½“æˆ‘ä»¬æ‰§è¡Œè¯¸å¦‚æ¢¯åº¦ä¸‹é™çš„æ›´æ–°æ“ä½œæ—¶ï¼Œ<math alttext="theta"><mi>Î¸</mi></math>ä»£è¡¨æ­£åœ¨æ›´æ–°çš„æƒé‡é›†ã€‚é‡è¦çš„æ˜¯è¦è®°ä½ï¼Œè¿™ä¸ªåˆ†å¸ƒä¸ä¹‹å‰æåˆ°çš„<math
    alttext="p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></math>æ˜¯ä¸åŒçš„â€”â€”åè€…æ˜¯ç»™å®šå›¾åƒä»æ•°æ®é›†ä¸­æŠ½å–çš„çœŸå®æ¦‚ç‡ã€‚
- en: The optimal discriminator can never know the exact origin of the image unless
    it is impossible for the generator to have produced the image, i.e., <math alttext="p
    Subscript g Baseline left-parenthesis x right-parenthesis equals 0"><mrow><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>
    . We can quantify the uncertainty in the discriminatorâ€™s prediction as a function
    of the imageâ€™s likelihood under the data distribution, or <math alttext="p Subscript
    data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> , and the imageâ€™s
    likelihood under the distribution defined by *G*, or <math alttext="p Subscript
    g Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> . If the imageâ€™s likelihood
    under the distribution defined by the generator is less than that of the data
    distribution, it makes sense that the optimal discriminator should be swayed accordingly
    and should score the image closer to one than zero.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ä¼˜é‰´åˆ«å™¨æ°¸è¿œæ— æ³•å‡†ç¡®çŸ¥é“å›¾åƒçš„ç¡®åˆ‡æ¥æºï¼Œé™¤éç”Ÿæˆå™¨æ— æ³•äº§ç”Ÿå›¾åƒï¼Œå³<math alttext="p Subscript g Baseline left-parenthesis
    x right-parenthesis equals 0"><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>ã€‚æˆ‘ä»¬å¯ä»¥é‡åŒ–é‰´åˆ«å™¨é¢„æµ‹çš„ä¸ç¡®å®šæ€§ï¼Œä½œä¸ºå›¾åƒåœ¨æ•°æ®åˆ†å¸ƒä¸‹çš„å¯èƒ½æ€§å‡½æ•°ï¼Œæˆ–è€…<math
    alttext="p Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼Œä»¥åŠåœ¨*G*å®šä¹‰çš„åˆ†å¸ƒä¸‹çš„å›¾åƒå¯èƒ½æ€§å‡½æ•°ï¼Œæˆ–è€…<math
    alttext="p Subscript g Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ã€‚å¦‚æœå›¾åƒåœ¨ç”Ÿæˆå™¨å®šä¹‰çš„åˆ†å¸ƒä¸‹çš„å¯èƒ½æ€§å°äºæ•°æ®åˆ†å¸ƒä¸‹çš„å¯èƒ½æ€§ï¼Œé‚£ä¹ˆæœ€ä¼˜é‰´åˆ«å™¨åº”è¯¥ç›¸åº”åœ°å—åˆ°å½±å“ï¼Œå¹¶ä¸”åº”è¯¥å°†å›¾åƒè¯„åˆ†æ›´æ¥è¿‘äºä¸€è€Œä¸æ˜¯é›¶ã€‚
- en: Note
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: Note that a quick back-of-the-envelope check shows that this property is true
    for the score <math alttext="StartFraction p Subscript data Baseline left-parenthesis
    x right-parenthesis Over p Subscript data Baseline left-parenthesis x right-parenthesis
    plus p Subscript g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
    . But why is this the exact proportion by which the property is true? Letâ€™s take
    a more concrete look at the score <math alttext="StartFraction p Subscript data
    Baseline left-parenthesis x right-parenthesis Over p Subscript data Baseline left-parenthesis
    x right-parenthesis plus p Subscript g Baseline left-parenthesis x right-parenthesis
    EndFraction"><mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
    and determine why this is the optimal function of the two probabilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œä¸€ä¸ªå¿«é€Ÿçš„ä¼°ç®—æ˜¾ç¤ºè¿™ä¸ªæ€§è´¨å¯¹äºå¾—åˆ†<math alttext="StartFraction p Subscript data Baseline
    left-parenthesis x right-parenthesis Over p Subscript data Baseline left-parenthesis
    x right-parenthesis plus p Subscript g Baseline left-parenthesis x right-parenthesis
    EndFraction"><mfrac><msub><mi>p</mi> <mtext>data</mtext></msub> <mo>(</mo><mi>x</mi><mo>)</mo>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></math>æ˜¯çœŸå®çš„ã€‚ä½†ä¸ºä»€ä¹ˆè¿™ä¸ªæ€§è´¨çš„ç¡®åˆ‡æ¯”ä¾‹æ˜¯çœŸå®çš„å‘¢ï¼Ÿè®©æˆ‘ä»¬æ›´å…·ä½“åœ°çœ‹ä¸€ä¸‹å¾—åˆ†<math
    alttext="StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis
    Over p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mo>(</mo><mi>x</mi><mo>)</mo> <mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></math>å¹¶ç¡®å®šä¸ºä»€ä¹ˆè¿™æ˜¯ä¸¤ä¸ªæ¦‚ç‡çš„æœ€ä¼˜å‡½æ•°ã€‚
- en: 'Taking some inspiration from our discussion regarding the perfectly confused
    discriminator, we can alternatively express the proposed optimal discriminator
    score in terms of conditional probabilities:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æˆ‘ä»¬å…³äºå®Œå…¨æ··æ·†çš„é‰´åˆ«å™¨çš„è®¨è®ºä¸­è·å¾—ä¸€äº›å¯ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ¡ä»¶æ¦‚ç‡çš„æœ¯è¯­æ¥è¡¨è¾¾æ‰€æå‡ºçš„æœ€ä¼˜é‰´åˆ«å™¨å¾—åˆ†ï¼š
- en: <math alttext="StartFraction p left-parenthesis x vertical-bar y equals dataset
    right-parenthesis Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    plus p left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction"><mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></math>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction p left-parenthesis x vertical-bar y equals dataset
    right-parenthesis Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    plus p left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction"><mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></math>
- en: 'Additionally, making the same assumption regarding equal likelihood of sampling
    from the dataset versus sampling from the generator ( <math alttext="p left-parenthesis
    y equals dataset right-parenthesis equals p left-parenthesis y equals generator
    right-parenthesis equals 0.5"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi>
    <mo>=</mo> <mtext>generator</mtext> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mo>.</mo>
    <mn>5</mn></mrow></math> ), we can get to a much more interpretable representation
    of the optimal score:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œå‡è®¾ä»æ•°æ®é›†ä¸­æŠ½æ ·ä¸ä»ç”Ÿæˆå™¨ä¸­æŠ½æ ·å…·æœ‰ç›¸åŒçš„æ¦‚ç‡ï¼ˆ<math alttext="p left-parenthesis y equals dataset
    right-parenthesis equals p left-parenthesis y equals generator right-parenthesis
    equals 0.5"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>)</mo> <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn></mrow></math>ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸€ä¸ªæ›´å…·è§£é‡Šæ€§çš„æœ€ä¼˜å¾—åˆ†è¡¨ç¤ºï¼š
- en: <math alttext="upper D Superscript asterisk Baseline left-parenthesis x right-parenthesis
    equals StartFraction p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis plus
    p left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction"><mrow><msup><mi>D</mi>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper D Superscript asterisk Baseline left-parenthesis x right-parenthesis
    equals StartFraction p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis plus
    p left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction"><mrow><msup><mi>D</mi>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></mrow></math>
- en: <math alttext="equals StartFraction p left-parenthesis x vertical-bar y equals
    dataset right-parenthesis asterisk p left-parenthesis y equals dataset right-parenthesis
    Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis asterisk
    p left-parenthesis y equals dataset right-parenthesis plus p left-parenthesis
    x vertical-bar y equals generator right-parenthesis asterisk p left-parenthesis
    y equals generator right-parenthesis EndFraction"><mrow><mo>=</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals StartFraction p left-parenthesis x vertical-bar y equals
    dataset right-parenthesis asterisk p left-parenthesis y equals dataset right-parenthesis
    Over p left-parenthesis x vertical-bar y equals dataset right-parenthesis asterisk
    p left-parenthesis y equals dataset right-parenthesis plus p left-parenthesis
    x vertical-bar y equals generator right-parenthesis asterisk p left-parenthesis
    y equals generator right-parenthesis EndFraction"><mrow><mo>=</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo><mo>*</mo><mi>p</mi><mo>(</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mfrac></mrow></math>
- en: <math alttext="equals StartFraction p left-parenthesis x comma y equals dataset
    right-parenthesis Over p left-parenthesis x right-parenthesis EndFraction"><mrow><mo>=</mo>
    <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals StartFraction p left-parenthesis x comma y equals dataset
    right-parenthesis Over p left-parenthesis x right-parenthesis EndFraction"><mrow><mo>=</mo>
    <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mrow></math>
- en: <math alttext="equals p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mo>=</mo>
    <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></math>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mo>=</mo>
    <mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></math>
- en: The denominator in the third equality is a result of having marginalized out
    *y.* The final result is just the conditional probability of having sampled from
    the dataset given the input image. It makes sense that the optimal discriminator,
    <math alttext="p Subscript theta Sub Superscript asterisk Baseline left-parenthesis
    y equals dataset vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi> <msup><mi>Î¸</mi>
    <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> , should strive to match
    the true probability that the input image was drawn from the dataset, <math alttext="p
    left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></math> .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸‰ä¸ªç­‰å¼ä¸­çš„åˆ†æ¯æ˜¯é€šè¿‡è¾¹ç¼˜åŒ–*y*å¾—åˆ°çš„ç»“æœã€‚æœ€ç»ˆç»“æœåªæ˜¯åœ¨ç»™å®šè¾“å…¥å›¾åƒçš„æƒ…å†µä¸‹ä»æ•°æ®é›†ä¸­æŠ½æ ·çš„æ¡ä»¶æ¦‚ç‡ã€‚æœ€ä¼˜é‰´åˆ«å™¨ï¼Œ<math alttext="p
    Subscript theta Sub Superscript asterisk Baseline left-parenthesis y equals dataset
    vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi> <msup><mi>Î¸</mi> <mo>*</mo></msup></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math>ï¼Œåº”è¯¥åŠªåŠ›åŒ¹é…è¾“å…¥å›¾åƒæ¥è‡ªæ•°æ®é›†çš„çœŸå®æ¦‚ç‡ï¼Œ<math alttext="p left-parenthesis
    y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></math>ã€‚
- en: 'Now, we consider why the minimax objective defined earlier is maximized by
    <math alttext="p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></math> , or the true conditional probability of having drawn
    from the dataset given an image *x,* under the assumption of a fixed generator.
    Letâ€™s take a closer look at the objective and try to reformulate it in a more
    informative manner that may provide us with some insight:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬è€ƒè™‘ä¸ºä»€ä¹ˆä¹‹å‰å®šä¹‰çš„æå°æå¤§ç›®æ ‡ç”±<math alttext="p left-parenthesis y equals dataset vertical-bar
    x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></math>æˆ–åœ¨å›ºå®šç”Ÿæˆå™¨çš„å‡è®¾ä¸‹ç»™å®šå›¾åƒ*x*æ—¶ä»æ•°æ®é›†ä¸­æŠ½æ ·çš„çœŸå®æ¡ä»¶æ¦‚ç‡æœ€å¤§åŒ–ã€‚è®©æˆ‘ä»¬ä»”ç»†è§‚å¯Ÿç›®æ ‡ï¼Œå¹¶å°è¯•ä»¥æ›´å…·ä¿¡æ¯æ€§çš„æ–¹å¼é‡æ–°è¡¨è¿°å®ƒï¼Œè¿™å¯èƒ½ä¸ºæˆ‘ä»¬æä¾›ä¸€äº›è§è§£ï¼š
- en: <math alttext="upper V left-parenthesis upper G comma upper D right-parenthesis
    equals double-struck upper E Subscript x tilde p Sub Subscript data Subscript
    left-parenthesis x right-parenthesis Baseline left-bracket log upper D left-parenthesis
    x right-parenthesis right-bracket plus double-struck upper E Subscript z tilde
    p left-parenthesis z right-parenthesis Baseline left-bracket log left-parenthesis
    1 minus upper D left-parenthesis upper G left-parenthesis z right-parenthesis
    right-parenthesis right-bracket"><mrow><mi>V</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><mi>z</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper V left-parenthesis upper G comma upper D right-parenthesis
    equals double-struck upper E Subscript x tilde p Sub Subscript data Subscript
    left-parenthesis x right-parenthesis Baseline left-bracket log upper D left-parenthesis
    x right-parenthesis right-bracket plus double-struck upper E Subscript z tilde
    p left-parenthesis z right-parenthesis Baseline left-bracket log left-parenthesis
    1 minus upper D left-parenthesis upper G left-parenthesis z right-parenthesis
    right-parenthesis right-bracket"><mrow><mi>V</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mi>D</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><mi>z</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>D</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log p
    Subscript theta Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis
    right-bracket plus double-struck upper E Subscript p Sub Subscript phi Subscript
    left-parenthesis x vertical-bar y equals generator right-parenthesis Baseline
    left-bracket log left-parenthesis 1 minus p Subscript theta Baseline left-parenthesis
    y equals dataset vertical-bar x right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log p
    Subscript theta Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis
    right-bracket plus double-struck upper E Subscript p Sub Subscript phi Subscript
    left-parenthesis x vertical-bar y equals generator right-parenthesis Baseline
    left-bracket log left-parenthesis 1 minus p Subscript theta Baseline left-parenthesis
    y equals dataset vertical-bar x right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log p
    Subscript theta Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis
    right-bracket plus double-struck upper E Subscript p Sub Subscript phi Subscript
    left-parenthesis x vertical-bar y equals generator right-parenthesis Baseline
    left-bracket log left-parenthesis p Subscript theta Baseline left-parenthesis
    y equals generator vertical-bar x right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log p
    Subscript theta Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis
    right-bracket plus double-struck upper E Subscript p Sub Subscript phi Subscript
    left-parenthesis x vertical-bar y equals generator right-parenthesis Baseline
    left-bracket log left-parenthesis p Subscript theta Baseline left-parenthesis
    y equals generator vertical-bar x right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: As usual, we have formulated the objective in terms of conditional probabilities.
    To get from the first equality to the second, we note that taking the expectation
    with respect to the noise distribution *p(z)* and then applying a function such
    as *G* to each sample is equivalent to just taking the expectation with respect
    to the distribution over the data space defined by *Gâ€™s* mapping. This is similar
    in spirit to a concept we discussed in [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba),
    where random variables can be functions of other random variables. Also note the
    addition of the letter <math alttext="phi"><mi>Ï†</mi></math> starting from the
    second lineâ€”this letter represents the parameters, or weights, of *G.*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: åƒå¾€å¸¸ä¸€æ ·ï¼Œæˆ‘ä»¬å·²ç»ç”¨æ¡ä»¶æ¦‚ç‡çš„æœ¯è¯­åˆ¶å®šäº†ç›®æ ‡ã€‚ä»ç¬¬ä¸€ä¸ªç­‰å¼åˆ°ç¬¬äºŒä¸ªç­‰å¼ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°ï¼Œå¯¹äºå™ªå£°åˆ†å¸ƒ*p(z)*çš„æœŸæœ›å€¼ï¼Œç„¶åå¯¹æ¯ä¸ªæ ·æœ¬åº”ç”¨*G*ç­‰å‡½æ•°ï¼Œç­‰æ•ˆäºå¯¹ç”±*G*çš„æ˜ å°„å®šä¹‰çš„æ•°æ®ç©ºé—´ä¸Šçš„åˆ†å¸ƒå–æœŸæœ›å€¼ã€‚è¿™åœ¨ç²¾ç¥ä¸Šç±»ä¼¼äºæˆ‘ä»¬åœ¨[ç¬¬2ç« ](ch02.xhtml#fundamentals-of-proba)ä¸­è®¨è®ºè¿‡çš„ä¸€ä¸ªæ¦‚å¿µï¼Œå³éšæœºå˜é‡å¯ä»¥æ˜¯å…¶ä»–éšæœºå˜é‡çš„å‡½æ•°ã€‚è¿˜è¦æ³¨æ„ä»ç¬¬äºŒè¡Œå¼€å§‹æ·»åŠ å­—æ¯<math
    alttext="phi"><mi>Ï†</mi></math> â€”â€”è¿™ä¸ªå­—æ¯ä»£è¡¨*G*çš„å‚æ•°æˆ–æƒé‡ã€‚
- en: 'Taking a closer look at the final expression, we start to see an awful lot
    of similarities between the objective and the concepts of entropy and cross entropy
    introduced in [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba). It turns out that
    we can manipulate the objective slightly without affecting the best <math alttext="theta"><mi>Î¸</mi></math>
    here to obtain a sum of the negatives of two cross-entropy terms:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ä»”ç»†è§‚å¯Ÿæœ€ç»ˆè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¼€å§‹çœ‹åˆ°ç›®æ ‡ä¸ç†µå’Œäº¤å‰ç†µçš„æ¦‚å¿µä¹‹é—´æœ‰å¾ˆå¤šç›¸ä¼¼ä¹‹å¤„ï¼Œè¿™äº›æ¦‚å¿µåœ¨[ç¬¬2ç« ](ch02.xhtml#fundamentals-of-proba)ä¸­ä»‹ç»è¿‡ã€‚åŸæ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç¨å¾®è°ƒæ•´ç›®æ ‡ï¼Œè€Œä¸å½±å“æœ€ä½³çš„Î¸ï¼Œä»è€Œè·å¾—ä¸¤ä¸ªäº¤å‰ç†µé¡¹çš„è´Ÿå’Œçš„æ€»å’Œï¼š
- en: <math alttext="theta Superscript asterisk Baseline equals argmin Subscript theta
    Baseline upper V left-parenthesis upper G comma upper D right-parenthesis"><mrow><msup><mi>Î¸</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <mi>V</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="theta Superscript asterisk Baseline equals argmin Subscript theta
    Baseline upper V left-parenthesis upper G comma upper D right-parenthesis"><mrow><msup><mi>Î¸</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <mi>V</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mo>,</mo> <mi>D</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals argmin Subscript theta Baseline double-struck upper E
    Subscript x tilde p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    Baseline left-bracket log p Subscript theta Baseline left-parenthesis y equals
    dataset vertical-bar x right-parenthesis right-bracket plus double-struck upper
    E Subscript p Sub Subscript phi Subscript left-parenthesis x vertical-bar y equals
    generator right-parenthesis Baseline left-bracket log left-parenthesis p Subscript
    theta Baseline left-parenthesis y equals generator vertical-bar x right-parenthesis
    right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mtext>argmin</mtext>
    <mi>Î¸</mi></msub> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals argmin Subscript theta Baseline double-struck upper E
    Subscript x tilde p left-parenthesis x vertical-bar y equals dataset right-parenthesis
    Baseline left-bracket log p Subscript theta Baseline left-parenthesis y equals
    dataset vertical-bar x right-parenthesis right-bracket plus double-struck upper
    E Subscript p Sub Subscript phi Subscript left-parenthesis x vertical-bar y equals
    generator right-parenthesis Baseline left-bracket log left-parenthesis p Subscript
    theta Baseline left-parenthesis y equals generator vertical-bar x right-parenthesis
    right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mtext>argmin</mtext>
    <mi>Î¸</mi></msub> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals argmin Subscript theta Baseline minus upper H left-parenthesis
    p left-parenthesis x comma y equals dataset right-parenthesis comma p Subscript
    theta Baseline left-parenthesis x comma y equals dataset right-parenthesis right-parenthesis
    minus upper H left-parenthesis p left-parenthesis x comma y equals generator right-parenthesis
    comma p Subscript theta Baseline left-parenthesis x comma y equals generator right-parenthesis
    right-parenthesis"><mrow><mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub>
    <mo>-</mo> <mi>H</mi> <mrow><mo>(</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>,</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo>
    <mi>H</mi> <mrow><mo>(</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>generator</mtext> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals argmin Subscript theta Baseline minus upper H left-parenthesis
    p left-parenthesis x comma y equals dataset right-parenthesis comma p Subscript
    theta Baseline left-parenthesis x comma y equals dataset right-parenthesis right-parenthesis
    minus upper H left-parenthesis p left-parenthesis x comma y equals generator right-parenthesis
    comma p Subscript theta Baseline left-parenthesis x comma y equals generator right-parenthesis
    right-parenthesis"><mrow><mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub>
    <mo>-</mo> <mi>H</mi> <mrow><mo>(</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>,</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo>
    <mi>H</mi> <mrow><mo>(</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>generator</mtext> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: As discussed in [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba), the cross entropy
    between two distributions is minimized when the two distributions are exactly
    the sameâ€”here we are doing the equivalent by simply maximizing the negative cross
    entropy instead. Thus, <math alttext="theta"><mi>Î¸</mi></math> achieves the optimal
    set of weights <math alttext="theta Superscript asterisk"><msup><mi>Î¸</mi> <mo>*</mo></msup></math>
    when <math alttext="p Subscript theta Baseline left-parenthesis x comma y equals
    dataset right-parenthesis equals p left-parenthesis x comma y equals dataset right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow></mrow></math>
    and <math alttext="p Subscript theta Baseline left-parenthesis x comma y equals
    generator right-parenthesis equals p left-parenthesis x comma y equals generator
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow> <mo>=</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext>
    <mo>)</mo></mrow></mrow></math> .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚åœ¨[ç¬¬2ç« ](ch02.xhtml#fundamentals-of-proba)ä¸­è®¨è®ºçš„é‚£æ ·ï¼Œä¸¤ä¸ªåˆ†å¸ƒä¹‹é—´çš„äº¤å‰ç†µåœ¨ä¸¤ä¸ªåˆ†å¸ƒå®Œå…¨ç›¸åŒæ—¶è¢«æœ€å°åŒ–â€”â€”åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬é€šè¿‡ç®€å•åœ°æœ€å¤§åŒ–è´Ÿäº¤å‰ç†µæ¥å®ç°ç­‰æ•ˆã€‚å› æ­¤ï¼Œ<math
    alttext="theta"><mi>Î¸</mi></math> åœ¨<math alttext="theta Superscript asterisk"><msup><mi>Î¸</mi>
    <mo>*</mo></msup></math>æ—¶å®ç°äº†æœ€ä¼˜æƒé‡é›†<math alttext="theta Superscript asterisk"><msup><mi>Î¸</mi>
    <mo>*</mo></msup></math>ï¼Œå½“<math alttext="p Subscript theta Baseline left-parenthesis
    x comma y equals dataset right-parenthesis equals p left-parenthesis x comma y
    equals dataset right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>)</mo></mrow></mrow></math>å’Œ<math alttext="p Subscript
    theta Baseline left-parenthesis x comma y equals generator right-parenthesis equals
    p left-parenthesis x comma y equals generator right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo>
    <mtext>generator</mtext> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>generator</mtext> <mo>)</mo></mrow></mrow></math>ã€‚
- en: As our final step, weâ€™d like to show that at <math alttext="theta Superscript
    asterisk"><msup><mi>Î¸</mi> <mo>*</mo></msup></math> , <math alttext="p Subscript
    theta Sub Superscript asterisk Baseline left-parenthesis y equals dataset vertical-bar
    x right-parenthesis equals p left-parenthesis y equals dataset vertical-bar x
    right-parenthesis"><mrow><msub><mi>p</mi> <msup><mi>Î¸</mi> <mo>*</mo></msup></msub>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> as
    promised. We already know that <math alttext="p Subscript theta Sub Superscript
    asterisk Baseline left-parenthesis x comma y equals dataset right-parenthesis
    equals p left-parenthesis x comma y equals dataset right-parenthesis"><mrow><msub><mi>p</mi>
    <msup><mi>Î¸</mi> <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>)</mo></mrow></mrow></math> from our prior work. Dividing by *p(x)* on both
    sides leaves us with the desired result.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæˆ‘ä»¬çš„æœ€åä¸€æ­¥ï¼Œæˆ‘ä»¬å¸Œæœ›å±•ç¤ºåœ¨<math alttext="theta Superscript asterisk"><msup><mi>Î¸</mi>
    <mo>*</mo></msup></math>æ—¶ï¼Œ<math alttext="p Subscript theta Sub Superscript asterisk
    Baseline left-parenthesis y equals dataset vertical-bar x right-parenthesis equals
    p left-parenthesis y equals dataset vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi>
    <msup><mi>Î¸</mi> <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo>
    <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>|</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math>ï¼Œæ­£å¦‚æ‰¿è¯ºçš„é‚£æ ·ã€‚æˆ‘ä»¬å·²ç»çŸ¥é“<math alttext="p Subscript theta
    Sub Superscript asterisk Baseline left-parenthesis x comma y equals dataset right-parenthesis
    equals p left-parenthesis x comma y equals dataset right-parenthesis"><mrow><msub><mi>p</mi>
    <msup><mi>Î¸</mi> <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>=</mo> <mtext>dataset</mtext>
    <mo>)</mo></mrow></mrow></math>æ¥è‡ªæˆ‘ä»¬ä¹‹å‰çš„å·¥ä½œã€‚åœ¨ä¸¤è¾¹éƒ½é™¤ä»¥*p(x)*åï¼Œæˆ‘ä»¬å¾—åˆ°äº†æœŸæœ›çš„ç»“æœã€‚
- en: 'So far, we have assumed a fixed *G*, and shown various properties regarding
    the optimal *D.* Unfortunately, we canâ€™t assume a fixed *G* in practice, as we
    must train the generator as well as the discriminator. But now that we have shown
    some properties regarding the optimal *D,* we can begin to talk about the properties
    *G* must satisfy to achieve the global optimumâ€”a generator that can perfectly
    confuse even the optimal discriminator. If we assume an optimal discriminator
    and plug in its score <math alttext="StartFraction p Subscript data Baseline left-parenthesis
    x right-parenthesis Over p Subscript data Baseline left-parenthesis x right-parenthesis
    plus p Subscript g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>
    to the objective *V(G,D),* we obtain an objective that is solely dependent on
    the parameters, or weights, of *G*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å‡è®¾äº†ä¸€ä¸ªå›ºå®šçš„*G*ï¼Œå¹¶å±•ç¤ºäº†å…³äºæœ€ä¼˜*D*çš„å„ç§å±æ€§ã€‚ä¸å¹¸çš„æ˜¯ï¼Œåœ¨å®è·µä¸­æˆ‘ä»¬ä¸èƒ½å‡è®¾ä¸€ä¸ªå›ºå®šçš„*G*ï¼Œå› ä¸ºæˆ‘ä»¬å¿…é¡»è®­ç»ƒç”Ÿæˆå™¨å’Œé‰´åˆ«å™¨ã€‚ä½†æ˜¯ç°åœ¨æˆ‘ä»¬å·²ç»å±•ç¤ºäº†ä¸€äº›å…³äºæœ€ä¼˜*D*çš„å±æ€§ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹è®¨è®º*G*å¿…é¡»æ»¡è¶³çš„å±æ€§ï¼Œä»¥å®ç°å…¨å±€æœ€ä¼˜â€”â€”ä¸€ä¸ªç”šè‡³å¯ä»¥å®Œå…¨æ··æ·†æœ€ä¼˜é‰´åˆ«å™¨çš„ç”Ÿæˆå™¨ã€‚å¦‚æœæˆ‘ä»¬å‡è®¾ä¸€ä¸ªæœ€ä¼˜é‰´åˆ«å™¨ï¼Œå¹¶å°†å…¶å¾—åˆ†<math
    alttext="StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis
    Over p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction"><mfrac><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac></math>ä»£å…¥ç›®æ ‡*V(G,D)*ï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªä»…ä¾èµ–äº*G*çš„å‚æ•°æˆ–æƒé‡çš„ç›®æ ‡ï¼š
- en: <math alttext="upper C left-parenthesis upper G right-parenthesis equals double-struck
    upper E Subscript x tilde p Sub Subscript data Subscript left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p Subscript data Baseline left-parenthesis
    x right-parenthesis Over p Subscript data Baseline left-parenthesis x right-parenthesis
    plus p Subscript g Baseline left-parenthesis x right-parenthesis EndFraction right-bracket
    plus double-struck upper E Subscript x tilde p Sub Subscript g Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log left-parenthesis 1 minus StartFraction
    p Subscript data Baseline left-parenthesis x right-parenthesis Over p Subscript
    data Baseline left-parenthesis x right-parenthesis plus p Subscript g Baseline
    left-parenthesis x right-parenthesis EndFraction right-parenthesis right-bracket"><mrow><mi>C</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow> <mo>+</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mtext>log</mtext>
    <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C left-parenthesis upper G right-parenthesis equals double-struck
    upper E Subscript x tilde p Sub Subscript data Subscript left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p Subscript data Baseline left-parenthesis
    x right-parenthesis Over p Subscript data Baseline left-parenthesis x right-parenthesis
    plus p Subscript g Baseline left-parenthesis x right-parenthesis EndFraction right-bracket
    plus double-struck upper E Subscript x tilde p Sub Subscript g Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log left-parenthesis 1 minus StartFraction
    p Subscript data Baseline left-parenthesis x right-parenthesis Over p Subscript
    data Baseline left-parenthesis x right-parenthesis plus p Subscript g Baseline
    left-parenthesis x right-parenthesis EndFraction right-parenthesis right-bracket"><mrow><mi>C</mi>
    <mrow><mo>(</mo> <mi>G</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow> <mo>+</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mtext>log</mtext>
    <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript x tilde p Sub Subscript
    data Subscript left-parenthesis x right-parenthesis Baseline left-bracket log
    StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis Over
    p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction right-bracket plus
    double-struck upper E Subscript x tilde p Sub Subscript g Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log StartFraction p Subscript g Baseline
    left-parenthesis x right-parenthesis Over p Subscript data Baseline left-parenthesis
    x right-parenthesis plus p Subscript g Baseline left-parenthesis x right-parenthesis
    EndFraction right-bracket"><mrow><mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow> <mo>+</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mtext>log</mtext>
    <mfrac><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript x tilde p Sub Subscript
    data Subscript left-parenthesis x right-parenthesis Baseline left-bracket log
    StartFraction p Subscript data Baseline left-parenthesis x right-parenthesis Over
    p Subscript data Baseline left-parenthesis x right-parenthesis plus p Subscript
    g Baseline left-parenthesis x right-parenthesis EndFraction right-bracket plus
    double-struck upper E Subscript x tilde p Sub Subscript g Subscript left-parenthesis
    x right-parenthesis Baseline left-bracket log StartFraction p Subscript g Baseline
    left-parenthesis x right-parenthesis Over p Subscript data Baseline left-parenthesis
    x right-parenthesis plus p Subscript g Baseline left-parenthesis x right-parenthesis
    EndFraction right-bracket"><mrow><mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow> <mo>+</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi> <mi>g</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mtext>log</mtext>
    <mfrac><mrow><msub><mi>p</mi> <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow>
    <mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>g</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log StartFraction
    p left-parenthesis x vertical-bar y equals dataset right-parenthesis Over p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis plus p Subscript phi Baseline
    left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction
    right-bracket plus double-struck upper E Subscript x tilde p Sub Subscript phi
    Subscript left-parenthesis x vertical-bar y equals generator right-parenthesis
    Baseline left-bracket log StartFraction p Subscript phi Baseline left-parenthesis
    x vertical-bar y equals generator right-parenthesis Over p left-parenthesis x
    vertical-bar y equals dataset right-parenthesis plus p Subscript phi Baseline
    left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction
    right-bracket"><mrow><mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow>
    <mrow><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript x tilde p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis Baseline left-bracket log StartFraction
    p left-parenthesis x vertical-bar y equals dataset right-parenthesis Over p left-parenthesis
    x vertical-bar y equals dataset right-parenthesis plus p Subscript phi Baseline
    left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction
    right-bracket plus double-struck upper E Subscript x tilde p Sub Subscript phi
    Subscript left-parenthesis x vertical-bar y equals generator right-parenthesis
    Baseline left-bracket log StartFraction p Subscript phi Baseline left-parenthesis
    x vertical-bar y equals generator right-parenthesis Over p left-parenthesis x
    vertical-bar y equals dataset right-parenthesis plus p Subscript phi Baseline
    left-parenthesis x vertical-bar y equals generator right-parenthesis EndFraction
    right-bracket"><mrow><mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow>
    <mrow><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><mi>x</mi><mo>âˆ¼</mo><msub><mi>p</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mtext>log</mtext> <mfrac><mrow><msub><mi>p</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow>
    <mrow><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>dataset</mtext><mo>)</mo></mrow><mo>+</mo><msub><mi>p</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>=</mo><mtext>generator</mtext><mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow></mrow></math>
- en: We can now minimize this objective by optimizing over the generator weights
    <math alttext="phi"><mi>Ï†</mi></math> . We refer you to the original GAN paper
    for the rigorous derivation. However, as one might expect by now, it turns out
    that the optimal distribution *G* represents, or <math alttext="p Subscript g
    Sub Superscript asterisk Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <msup><mi>g</mi> <mo>*</mo></msup></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , is equal to <math alttext="p Subscript data Baseline left-parenthesis x right-parenthesis
    comma for-all x"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>,</mo> <mo>âˆ€</mo> <mi>x</mi></mrow></math> .
    This matches our original intuition regarding the perfectly confused discriminator
    and shows that the objective function proposed in the original GAN paper does
    indeed theoretically converge to this global optimum.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¼˜åŒ–ç”Ÿæˆå™¨æƒé‡<math alttext="phi"><mi>Ï†</mi></math> æ¥æœ€å°åŒ–è¿™ä¸ªç›®æ ‡ã€‚æˆ‘ä»¬å»ºè®®æ‚¨å‚è€ƒåŸå§‹GANè®ºæ–‡è¿›è¡Œä¸¥æ ¼æ¨å¯¼ã€‚ç„¶è€Œï¼Œæ­£å¦‚ç°åœ¨å¯èƒ½å·²ç»é¢„æ–™åˆ°çš„é‚£æ ·ï¼Œæœ€ä¼˜åˆ†å¸ƒ*G*ä»£è¡¨ï¼Œæˆ–è€…
    <math alttext="p Subscript g Sub Superscript asterisk Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <msup><mi>g</mi> <mo>*</mo></msup></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼Œç­‰äº <math alttext="p
    Subscript data Baseline left-parenthesis x right-parenthesis comma for-all x"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mo>âˆ€</mo> <mi>x</mi></mrow></math>ã€‚è¿™ç¬¦åˆæˆ‘ä»¬æœ€åˆå¯¹å®Œå…¨è¿·æƒ‘é‰´åˆ«å™¨çš„ç›´è§‰ï¼Œå¹¶æ˜¾ç¤ºåŸå§‹GANè®ºæ–‡ä¸­æå‡ºçš„ç›®æ ‡å‡½æ•°ç¡®å®åœ¨ç†è®ºä¸Šæ”¶æ•›åˆ°è¿™ä¸ªå…¨å±€æœ€ä¼˜è§£ã€‚
- en: Now that we have an optimal generator and discriminator, how do we perform image
    generation? All we need to do is sample from our noise distribution *p(z)* and
    run each sample through the generator. The generator, being optimal, should produce
    images that look as if they were drawn from the dataset itself. It may come as
    a surprise to you that the discriminator is no longer needed in this phaseâ€”but
    it has served its purpose. The discriminator played a key role in competing with
    the generator, each evolving until the latter could produce images that perfectly
    confused the discriminator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªæœ€ä¼˜çš„ç”Ÿæˆå™¨å’Œé‰´åˆ«å™¨ï¼Œæˆ‘ä»¬å¦‚ä½•è¿›è¡Œå›¾åƒç”Ÿæˆå‘¢ï¼Ÿæˆ‘ä»¬åªéœ€è¦ä»æˆ‘ä»¬çš„å™ªå£°åˆ†å¸ƒ*p(z)*ä¸­æŠ½æ ·ï¼Œå¹¶å°†æ¯ä¸ªæ ·æœ¬é€šè¿‡ç”Ÿæˆå™¨è¿è¡Œã€‚ç”Ÿæˆå™¨ï¼Œä½œä¸ºæœ€ä¼˜è§£ï¼Œåº”è¯¥ç”Ÿæˆçœ‹èµ·æ¥å°±åƒæ˜¯ä»æ•°æ®é›†æœ¬èº«ä¸­ç»˜åˆ¶çš„å›¾åƒã€‚ä¹Ÿè®¸è®©ä½ æƒŠè®¶çš„æ˜¯ï¼Œåœ¨è¿™ä¸ªé˜¶æ®µé‰´åˆ«å™¨ä¸å†éœ€è¦äº†ï¼Œä½†å®ƒå·²ç»å‘æŒ¥äº†ä½œç”¨ã€‚é‰´åˆ«å™¨åœ¨ä¸ç”Ÿæˆå™¨ç«äº‰ä¸­å‘æŒ¥äº†å…³é”®ä½œç”¨ï¼Œæ¯ä¸ªéƒ½åœ¨æ¼”å˜ï¼Œç›´åˆ°åè€…èƒ½å¤Ÿç”Ÿæˆå®Œå…¨è¿·æƒ‘é‰´åˆ«å™¨çš„å›¾åƒã€‚
- en: Note that unlike the standard interpretation of generative modeling, *z* does
    not represent a set of latent variables from which the data is generated. *z*
    simply plays the role of being a random variable distributed as one of our standard
    distributions, such as a uniform distribution or a standard multivariate Gaussian
    distribution, which are easy to sample from. *G,* when fully trained and optimal,
    is a complex, differentiable function that transforms samples from *p(z)* into
    samples from <math alttext="p Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , which approximates *p(x)*. In the next section, we will see the parallels between
    *G(z)* and the reparametrization trick, which also allows us to sample from a
    distribution by transforming samples (via a differentiable function) from a distribution
    that is easier to sample from.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œä¸ç”Ÿæˆå»ºæ¨¡çš„æ ‡å‡†è§£é‡Šä¸åŒï¼Œ*z*å¹¶ä¸ä»£è¡¨ä¸€ç»„ç”Ÿæˆæ•°æ®çš„æ½œåœ¨å˜é‡ã€‚*z*åªæ˜¯æ‰®æ¼”ä¸€ä¸ªéšæœºå˜é‡çš„è§’è‰²ï¼Œåˆ†å¸ƒä¸ºæˆ‘ä»¬çš„æ ‡å‡†åˆ†å¸ƒä¹‹ä¸€ï¼Œæ¯”å¦‚å‡åŒ€åˆ†å¸ƒæˆ–æ ‡å‡†å¤šå…ƒé«˜æ–¯åˆ†å¸ƒï¼Œè¿™äº›åˆ†å¸ƒæ˜“äºæŠ½æ ·ã€‚å½“å®Œå…¨è®­ç»ƒå’Œä¼˜åŒ–æ—¶ï¼Œ*G*æ˜¯ä¸€ä¸ªå¤æ‚çš„ã€å¯å¾®åˆ†çš„å‡½æ•°ï¼Œå°†ä»*p(z)*ä¸­æŠ½æ ·çš„æ ·æœ¬è½¬æ¢ä¸ºä»
    <math alttext="p Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    ä¸­æŠ½æ ·çš„æ ·æœ¬ï¼Œè¿™ä¸ªåˆ†å¸ƒè¿‘ä¼¼äº*p(x)*ã€‚åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°*G(z)*å’Œé‡å‚æ•°åŒ–æŠ€å·§ä¹‹é—´çš„ç›¸ä¼¼ä¹‹å¤„ï¼Œè¿™ä¹Ÿå…è®¸æˆ‘ä»¬é€šè¿‡ä»æ˜“äºæŠ½æ ·çš„åˆ†å¸ƒä¸­è½¬æ¢æ ·æœ¬ï¼ˆé€šè¿‡ä¸€ä¸ªå¯å¾®åˆ†å‡½æ•°ï¼‰æ¥æŠ½æ ·ã€‚
- en: Variational Autoencoders
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å˜åˆ†è‡ªåŠ¨ç¼–ç å™¨
- en: In parallel to the introduction of GANs, Kingma and Welling introduced the *Variational
    Autoencoder*, or VAE for short, in their seminal paper, â€œAuto-Encoding Variational
    Bayes,â€ from 2014.^([2](ch10.xhtml#idm45934168472352)) The idea behind the VAE
    is more strongly rooted in probabilistic modeling than the aforementioned GAN.
    The VAE assumes there exists a set of unobserved latent variables, which we denote
    as *z*, that generate the data we see, which we denote as *x*. More formally,
    we say there exists a joint probability distribution *p(x,z)* over the latent
    variables *z* and the observed data *x* that factors as <math alttext="p left-parenthesis
    x vertical-bar z right-parenthesis p left-parenthesis z right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo> <mi>p</mi> <mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow></math> (see [FigureÂ 10-2](#img1002)). Thinking back to [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba),
    this factorization is quite intuitive. Given the predefined roles of *z* and *x,*
    the universe in which *z* takes on some value and *x* is generated from this setting
    of *z* makes much more sense than the other way around.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸GANçš„å¼•å…¥åŒæ—¶ï¼ŒKingmaå’ŒWellingåœ¨ä»–ä»¬2014å¹´çš„å¼€åˆ›æ€§è®ºæ–‡â€œè‡ªåŠ¨ç¼–ç å˜åˆ†è´å¶æ–¯â€ä¸­å¼•å…¥äº†*å˜åˆ†è‡ªåŠ¨ç¼–ç å™¨*ï¼Œç®€ç§°VAEã€‚VAEçš„ç†å¿µæ›´å¤šåœ°æ ¹æ¤äºæ¦‚ç‡å»ºæ¨¡ï¼Œè€Œä¸æ˜¯å‰é¢æåˆ°çš„GANã€‚VAEå‡è®¾å­˜åœ¨ä¸€ç»„æœªè§‚å¯Ÿåˆ°çš„æ½œåœ¨å˜é‡ï¼Œæˆ‘ä»¬å°†å…¶è¡¨ç¤ºä¸º*z*ï¼Œç”Ÿæˆæˆ‘ä»¬çœ‹åˆ°çš„æ•°æ®ï¼Œæˆ‘ä»¬å°†å…¶è¡¨ç¤ºä¸º*x*ã€‚æ›´æ­£å¼åœ°è¯´ï¼Œæˆ‘ä»¬è¯´å­˜åœ¨ä¸€ä¸ªè”åˆæ¦‚ç‡åˆ†å¸ƒ*p(x,z)*ï¼Œè¦†ç›–æ½œåœ¨å˜é‡*z*å’Œè§‚å¯Ÿåˆ°çš„æ•°æ®*x*ï¼Œè¿™ä¸ªåˆ†å¸ƒå¯ä»¥åˆ†è§£ä¸º
    <math alttext="p left-parenthesis x vertical-bar z right-parenthesis p left-parenthesis
    z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi>
    <mo>)</mo> <mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo></mrow></math>ï¼ˆè§[å›¾10-2](#img1002)ï¼‰ã€‚å›æƒ³[ç¬¬2ç« ](ch02.xhtml#fundamentals-of-proba)ï¼Œè¿™ç§åˆ†è§£æ˜¯éå¸¸ç›´è§‚çš„ã€‚è€ƒè™‘åˆ°*z*å’Œ*x*çš„é¢„å®šä¹‰è§’è‰²ï¼Œ*z*å–æŸä¸ªå€¼å¹¶ä¸”*x*ä»è¿™ä¸ª*z*çš„è®¾ç½®ä¸­ç”Ÿæˆçš„å®‡å®™æ¯”å¦ä¸€ç§æ–¹å¼æ›´æœ‰æ„ä¹‰ã€‚
- en: '![](Images/fdl2_1002.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1002.png)'
- en: Figure 10-2\. z represents the latent variables from which every instance of
    *x* is generated. The arrow pointing from z to x signifies this relationship.
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾10-2ã€‚zä»£è¡¨ç”Ÿæˆæ¯ä¸ª*x*å®ä¾‹çš„æ½œåœ¨å˜é‡ã€‚ä»zæŒ‡å‘xçš„ç®­å¤´è¡¨ç¤ºè¿™ç§å…³ç³»ã€‚
- en: '*x* could represent any sort of continuous or discrete data, including images.
    We additionally know the domain of *x* due to our knowledge of the dataset. *z,*
    on the other hand, is much more elusive. We have no idea what *z* looks like,
    so we make some initial assumptions about it. For example, we may assume that
    it initially takes the form of a Gaussian distribution, i.e., *p(z)* is Gaussian.
    Again, thinking back to [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba), we say
    that *p(z),* or our prior on *z,* is Gaussian.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we think about such a data-generation process, some natural probabilistic
    questions (should) come to mind. For example, what is the distribution <math alttext="p
    left-parenthesis z vertical-bar x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>z</mi> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></math> , or the posterior of
    *z* having known *x*? As we observe data, our beliefs regarding the underlying
    parameters often change. Take the coin flip experiment from [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba)
    as an example. We initially assumed a 50-50 chance of flipping heads, where the
    50-50 can be thought of as our latent parameter <math alttext="alpha"><mi>Î±</mi></math>
    â€”the parameter dictating the data generation procedure of sequences of heads and
    tails. This is a little simplifiedâ€”in reality, we initially have a distribution
    over <math alttext="alpha"><mi>Î±</mi></math> , the probability of flipping heads,
    which is our prior distribution. Of course, the domain of the prior is the range
    [0,1], where it is logical to design the prior <math alttext="p left-parenthesis
    alpha right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>Î±</mi> <mo>)</mo></mrow></math>
    such that <math alttext="p left-parenthesis alpha equals 0.5 right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>Î±</mi> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mo>)</mo></mrow></math>
    is larger than all other settings of <math alttext="alpha"><mi>Î±</mi></math> .
    As we observed sequences of flips, we updated our prior via Bayesâ€™ Theorem. In
    a similar manner, we initially assume *p(z)* to be a Gaussian distribution with
    some mean and variance; but as we observe data, we recalculate our belief in the
    form of a posterior, *p(z|x)* (see [FigureÂ 10-3](#img1003)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Another question naturally comes to mind: what is the distribution *p(x|z),*
    or the likelihood of the data *x* given a certain setting of the latent variables
    *z*? In the coin flip setting, *p(x|z)* is easy to think about. Due to our complete
    knowledge of the experiment, we know the probability of any sequence is just the
    product of the probability of each flip, which is directly defined by *z*. In
    more intricate settings such as images, however, we can assume the relationship
    between the data *x* and the latent variables *z* is much more complicated than
    that. For example, when looking at images, it is clear that the value of a given
    pixel is quite affected by the values of its neighboring pixels and sometimes
    even by pixels much farther than one might think. The simple independence assumption
    we have for coin flips will not suffice for our purposes. This is just one reason
    why we canâ€™t simply use a method like Bayesâ€™ Theorem to learn a posterior over
    *z*â€”it requires much more knowledge regarding the system than what is immediately
    available to us.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fdl2_1003.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Here we have the coin flip experiment, where the prior is designed
    such that 0.5 has the highest likelihood. Once we see a series of heads and tails,
    the posterior shifts to the right due to there being more heads than tails.
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In variational autoencoders, we encode these distributions as neural networks,
    which can be seen as complex, nonlinear functions that can accurately model the
    relationships between latent variables *z* and the observed data *x*. We denote
    the neural network that outputs a distribution over the data given a setting of
    the latent variables, also termed the *decoder,* as <math alttext="p Subscript
    theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    , where <math alttext="theta"><mi>Î¸</mi></math> represents the weights of the
    neural network. In other words, the setting of <math alttext="theta"><mi>Î¸</mi></math>
    , in addition to the predetermined architecture of the neural network, completely
    define the modelâ€™s belief of the true distribution <math alttext="p left-parenthesis
    x vertical-bar z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo>
    <mi>z</mi> <mo>)</mo></mrow></math> . We optimize <math alttext="theta"><mi>Î¸</mi></math>
    to achieve a setting that is closest to that of the true distribution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å˜åˆ†è‡ªåŠ¨ç¼–ç å™¨ä¸­ï¼Œæˆ‘ä»¬å°†è¿™äº›åˆ†å¸ƒç¼–ç ä¸ºç¥ç»ç½‘ç»œï¼Œå¯ä»¥çœ‹ä½œæ˜¯å¤æ‚çš„éçº¿æ€§å‡½æ•°ï¼Œå¯ä»¥å‡†ç¡®åœ°å»ºæ¨¡æ½œåœ¨å˜é‡zå’Œè§‚å¯Ÿæ•°æ®xä¹‹é—´çš„å…³ç³»ã€‚æˆ‘ä»¬å°†è¾“å‡ºç»™å®šæ½œåœ¨å˜é‡è®¾ç½®ä¸‹æ•°æ®åˆ†å¸ƒçš„ç¥ç»ç½‘ç»œï¼Œä¹Ÿç§°ä¸ºè§£ç å™¨ï¼Œè¡¨ç¤ºä¸º<pÎ¸(x|z)ï¼Œå…¶ä¸­Î¸ä»£è¡¨ç¥ç»ç½‘ç»œçš„æƒé‡ã€‚æ¢å¥è¯è¯´ï¼ŒÎ¸çš„è®¾ç½®ï¼Œé™¤äº†ç¥ç»ç½‘ç»œçš„é¢„å®šæ¶æ„å¤–ï¼Œå®Œå…¨å®šä¹‰äº†æ¨¡å‹å¯¹çœŸå®åˆ†å¸ƒp(x|z)çš„ä¿¡å¿µã€‚æˆ‘ä»¬ä¼˜åŒ–Î¸ä»¥å®ç°ä¸çœŸå®åˆ†å¸ƒæœ€æ¥è¿‘çš„è®¾ç½®ã€‚
- en: We additionally encode the posterior over *z*, or *p(z|x),* as a neural network.
    We denote this neural network, termed the *encoder,* as <math alttext="q Subscript
    phi Baseline left-parenthesis z vertical-bar x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    . Similarly to the decoder, we optimize <math alttext="phi"><mi>Ï†</mi></math>
    to achieve a setting that is closest to that of the true posterior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å°†åéªŒz|xæˆ–p(z|x)ç¼–ç ä¸ºç¥ç»ç½‘ç»œã€‚æˆ‘ä»¬å°†è¿™ä¸ªç¥ç»ç½‘ç»œç§°ä¸ºç¼–ç å™¨ï¼Œè¡¨ç¤ºä¸ºqÏ†(z|x)ã€‚ä¸è§£ç å™¨ç±»ä¼¼ï¼Œæˆ‘ä»¬ä¼˜åŒ–Ï†ä»¥å®ç°ä¸çœŸå®åéªŒæœ€æ¥è¿‘çš„è®¾ç½®ã€‚
- en: Kingma and Welling made some key observations that made the variational autoencoder
    a practical means for generative modeling ([FigureÂ 10-4](#fig1004)). The first
    was that the *evidence lower bound* (ELBO for short), which is a lower bound on
    the true log likelihood of the data <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> , could be reformulated in a way
    that allowed for tractable optimization over the encoder and decoder parameters.
    The second was a reparametrization trick that enabled the computation of a low
    variance estimate of the gradient with respect to the parameters of the encoder,
    <math alttext="phi"><mi>Ï†</mi></math> . Although this may sound like a lot of
    jargon right now, we will go into each of these key observations in much more
    detail and concretely motivate the encoder-decoder architecture.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kingmaå’ŒWellingåšå‡ºäº†ä¸€äº›å…³é”®è§‚å¯Ÿï¼Œä½¿å˜åˆ†è‡ªåŠ¨ç¼–ç å™¨æˆä¸ºç”Ÿæˆå»ºæ¨¡çš„å®ç”¨æ‰‹æ®µï¼ˆå›¾10-4ï¼‰ã€‚ç¬¬ä¸€ç‚¹æ˜¯*è¯æ®ä¸‹ç•Œ*ï¼ˆELBOç®€ç§°ï¼‰ï¼Œå®ƒæ˜¯æ•°æ®çœŸå®å¯¹æ•°ä¼¼ç„¶çš„ä¸€ä¸ªä¸‹ç•Œï¼Œå¯ä»¥é‡æ–°è¡¨è¿°ä¸ºä¸€ç§å…è®¸åœ¨ç¼–ç å™¨å’Œè§£ç å™¨å‚æ•°ä¸Šè¿›è¡Œå¯å¤„ç†ä¼˜åŒ–çš„æ–¹å¼ã€‚ç¬¬äºŒç‚¹æ˜¯ä¸€ç§é‡æ–°å‚æ•°åŒ–æŠ€å·§ï¼Œä½¿å¾—èƒ½å¤Ÿè®¡ç®—å…³äºç¼–ç å™¨å‚æ•°Ï†çš„æ¢¯åº¦çš„ä½æ–¹å·®ä¼°è®¡ã€‚å°½ç®¡ç°åœ¨è¿™å¬èµ·æ¥åƒæ˜¯å¾ˆå¤šè¡Œè¯ï¼Œæˆ‘ä»¬å°†æ›´è¯¦ç»†åœ°è®¨è®ºè¿™äº›å…³é”®è§‚å¯Ÿï¼Œå¹¶å…·ä½“è¯´æ˜ç¼–ç å™¨-è§£ç å™¨æ¶æ„ã€‚
- en: '![](Images/fdl2_1004.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1004.png)'
- en: Figure 10-4\. The overall VAE architecture presented in Kingma and Welling.
    Note that both z and the image after the decoder are both samples from the encoder
    distribution and decoder distribution, respectively.
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾10-4ã€‚Kingmaå’ŒWellingæå‡ºçš„æ•´ä½“VAEæ¶æ„ã€‚è¯·æ³¨æ„ï¼Œzå’Œè§£ç å™¨åçš„å›¾åƒéƒ½æ˜¯æ¥è‡ªç¼–ç å™¨åˆ†å¸ƒå’Œè§£ç å™¨åˆ†å¸ƒçš„æ ·æœ¬ã€‚
- en: 'Letâ€™s assume we have observed some data *x*, where each individual example
    can be denoted as <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> . Note that we are still
    under the assumption that there exist some set of latent variables *z* generating
    the data weâ€™ve seen. We split our analysis over the observed data into one over
    each individual example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> . We know there exists
    a true posterior over the latent variables <math alttext="p left-parenthesis z
    vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> , but we have no idea what that true posterior is. We
    assume it can be approximated by some distribution over the latent variables <math
    alttext="q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> , where *q* is a family of distributions in which
    optimization is much easier but complex enough to accurately model the true posterior.
    An example would be a multilayer neural network, which, as weâ€™ve already seen,
    can be efficiently optimized via gradient descent and can represent complex, nonlinear
    functions. Note that each example <math alttext="x Superscript left-parenthesis
    i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    weâ€™ve seen has some true probability of occurrence, which we can write as <math
    alttext="p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> . We instead work with <math alttext="log p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> , since this allows us to do some convenient decomposition
    into terms weâ€™ve encountered before and doesnâ€™t affect the verity of the optimization
    process:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬è§‚å¯Ÿåˆ°ä¸€äº›æ•°æ® *x*ï¼Œå…¶ä¸­æ¯ä¸ªä¸ªä½“ç¤ºä¾‹å¯ä»¥è¡¨ç¤ºä¸º <math alttext="x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å·"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä»ç„¶å‡è®¾å­˜åœ¨ä¸€ç»„æ½œåœ¨å˜é‡ *z*
    ç”Ÿæˆæˆ‘ä»¬æ‰€è§çš„æ•°æ®ã€‚æˆ‘ä»¬å°†æˆ‘ä»¬å¯¹è§‚å¯Ÿåˆ°çš„æ•°æ®çš„åˆ†æåˆ†ä¸ºå¯¹æ¯ä¸ªä¸ªä½“ç¤ºä¾‹ <math alttext="x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å·"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> çš„åˆ†æã€‚æˆ‘ä»¬çŸ¥é“å­˜åœ¨ä¸€ä¸ªçœŸå®çš„æ½œåœ¨å˜é‡åéªŒ
    <math alttext="p å·¦æ‹¬å· z ç«–çº¿ x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å· Baseline å³æ‹¬å·"><mrow><mi>p</mi> <mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math>ï¼Œä½†æˆ‘ä»¬ä¸çŸ¥é“çœŸå®çš„åéªŒæ˜¯ä»€ä¹ˆã€‚æˆ‘ä»¬å‡è®¾å®ƒå¯ä»¥é€šè¿‡ä¸€äº›æ½œåœ¨å˜é‡çš„åˆ†å¸ƒæ¥è¿‘ä¼¼ <math alttext="q
    ä¸‹æ ‡ phi Baseline å·¦æ‹¬å· z ç«–çº¿ x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å· Baseline å³æ‹¬å·"><mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>ï¼Œå…¶ä¸­ *q* æ˜¯ä¸€ä¸ªåˆ†å¸ƒæ—ï¼Œä¼˜åŒ–æ›´å®¹æ˜“ï¼Œä½†è¶³å¤Ÿå¤æ‚ä»¥å‡†ç¡®å»ºæ¨¡çœŸå®çš„åéªŒã€‚ä¸€ä¸ªä¾‹å­æ˜¯å¤šå±‚ç¥ç»ç½‘ç»œï¼Œæ­£å¦‚æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ï¼Œå¯ä»¥é€šè¿‡æ¢¯åº¦ä¸‹é™æœ‰æ•ˆä¼˜åŒ–ï¼Œå¹¶ä¸”å¯ä»¥è¡¨ç¤ºå¤æ‚çš„éçº¿æ€§å‡½æ•°ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬æ‰€è§çš„æ¯ä¸ªç¤ºä¾‹
    <math alttext="x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å·"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    éƒ½æœ‰ä¸€å®šçš„å‘ç”Ÿæ¦‚ç‡ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸º <math alttext="p å·¦æ‹¬å· x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å· Baseline å³æ‹¬å·"><mrow><mi>p</mi>
    <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math>ã€‚æˆ‘ä»¬æ”¹ä¸ºä½¿ç”¨ <math alttext="log p å·¦æ‹¬å· x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å· Baseline
    å³æ‹¬å·"><mrow><mo form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math>ï¼Œå› ä¸ºè¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿå¯¹æˆ‘ä»¬ä¹‹å‰é‡åˆ°çš„é¡¹è¿›è¡Œæ–¹ä¾¿çš„åˆ†è§£ï¼Œå¹¶ä¸”ä¸ä¼šå½±å“ä¼˜åŒ–è¿‡ç¨‹çš„çœŸå®æ€§ï¼š
- en: <math alttext="log p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis equals log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="log p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis equals log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    plus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis minus log q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis"><mrow><mo>=</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>+</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    plus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis minus log q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis"><mrow><mo>=</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>+</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline comma z right-parenthesis minus
    log p left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis plus log q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    minus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow>
    <mo>+</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline comma z right-parenthesis minus
    log p left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis plus log q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    minus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow>
    <mo>+</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline comma z right-parenthesis
    Over q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis EndFraction right-bracket plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log StartFraction q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis Over p left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis EndFraction right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo><mi>z</mi><mo>)</mo></mrow>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><mi>p</mi><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline comma z right-parenthesis
    Over q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis EndFraction right-bracket plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log StartFraction q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis Over p left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis EndFraction right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo><mi>z</mi><mo>)</mo></mrow>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><mi>p</mi><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
- en: = <math alttext="ELBO plus KL left-parenthesis q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    StartAbsoluteValue EndAbsoluteValue p left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-parenthesis"><mrow><mtext>ELBO</mtext>
    <mo>+</mo> <mtext>KL</mtext> <mo>(</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>|</mo> <mo>|</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>)</mo></mrow></math>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: = <math alttext="ELBO åŠ  KL å·¦æ‹¬å· q ä¸‹æ ‡ phi Baseline å·¦æ‹¬å· z ç«–çº¿ x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å· Baseline
    å³æ‹¬å· StartAbsoluteValue EndAbsoluteValue p å·¦æ‹¬å· z ç«–çº¿ x ä¸Šæ ‡å·¦æ‹¬å· i å³æ‹¬å· Baseline å³æ‹¬å·
    å³æ‹¬å·"><mrow><mtext>ELBO</mtext> <mo>+</mo> <mtext>KL</mtext> <mo>(</mo> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>|</mo> <mo>|</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>)</mo></mrow></math>
- en: 'The first step is to express the marginal likelihood of the individual example
    <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> as a function of the
    example itself and the latent factors *z.* As we learned earlier, the marginal
    likelihood can be broken down into a quotient of the joint distribution <math
    alttext="p left-parenthesis z comma x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>,</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>
    and the conditional distribution <math alttext="p left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> . The log function allows us to separate this quotient
    into a difference between the logs of the two terms. In the second step, we use
    a little trick that allows us to conveniently insert the approximate posterior
    into the equalityâ€”adding and subtracting the same term shouldnâ€™t affect the equality.
    In the third step, we insert an expectation with respect to the approximate posterior.
    Why is this allowed? Well, a priori we know that <math alttext="log p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> is a constant. It is just the log of the probability
    of the example occurring under the true distribution, which is fixed. Thus, taking
    the expectation on both sides doesnâ€™t change anything about the left side of the
    equation, since the expectation of a constant is just the constant itself. On
    the right side, we have now gotten closer to expressing the log of the marginal
    likelihood in terms that weâ€™ve seen before. In the second to last step, we combine
    logs back into quotients and use the linearity of expectation to arrive at a sum
    of two terms: (1) the KL divergence between the approximate posterior and the
    true posterior, and (2) the ELBO, or the evidence lower bound.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€æ­¥æ˜¯å°†å•ä¸ªç¤ºä¾‹<math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>çš„è¾¹é™…ä¼¼ç„¶è¡¨è¾¾ä¸ºç¤ºä¾‹æœ¬èº«å’Œæ½œåœ¨å› å­*z*çš„å‡½æ•°ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰å­¦åˆ°çš„ï¼Œè¾¹é™…ä¼¼ç„¶å¯ä»¥åˆ†è§£ä¸ºè”åˆåˆ†å¸ƒ<math
    alttext="p left-parenthesis z comma x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>,</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>å’Œæ¡ä»¶åˆ†å¸ƒ<math
    alttext="p left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>|</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>çš„å•†ã€‚å¯¹æ•°å‡½æ•°ä½¿æˆ‘ä»¬èƒ½å¤Ÿå°†è¿™ä¸ªå•†åˆ†è§£ä¸ºä¸¤ä¸ªé¡¹çš„å¯¹æ•°ä¹‹é—´çš„å·®å¼‚ã€‚åœ¨ç¬¬äºŒæ­¥ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå°æŠ€å·§ï¼Œä½¿æˆ‘ä»¬å¯ä»¥æ–¹ä¾¿åœ°å°†è¿‘ä¼¼åéªŒæ’å…¥ç­‰å¼ä¸­â€”â€”æ·»åŠ å’Œå‡å»ç›¸åŒçš„é¡¹ä¸åº”å½±å“ç­‰å¼ã€‚åœ¨ç¬¬ä¸‰æ­¥ä¸­ï¼Œæˆ‘ä»¬æ’å…¥äº†å¯¹è¿‘ä¼¼åéªŒçš„æœŸæœ›ã€‚ä¸ºä»€ä¹ˆå…è®¸è¿™æ ·åšï¼Ÿå—¯ï¼Œæˆ‘ä»¬äº‹å…ˆçŸ¥é“<math
    alttext="log p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mo form="prefix">log</mo> <mi>p</mi> <mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>æ˜¯ä¸€ä¸ªå¸¸æ•°ã€‚å®ƒåªæ˜¯åœ¨çœŸå®åˆ†å¸ƒä¸‹å‘ç”Ÿç¤ºä¾‹çš„æ¦‚ç‡çš„å¯¹æ•°ï¼Œæ˜¯å›ºå®šçš„ã€‚å› æ­¤ï¼Œåœ¨ç­‰å¼çš„å·¦ä¾§è¿›è¡ŒæœŸæœ›ä¸ä¼šæ”¹å˜ä»»ä½•ä¸œè¥¿ï¼Œå› ä¸ºå¸¸æ•°çš„æœŸæœ›å°±æ˜¯å¸¸æ•°æœ¬èº«ã€‚åœ¨å³ä¾§ï¼Œæˆ‘ä»¬ç°åœ¨å·²ç»æ›´æ¥è¿‘ä»¥å‰çœ‹åˆ°çš„ç”¨æœ¯è¯­è¡¨è¾¾è¾¹é™…ä¼¼ç„¶çš„å¯¹æ•°ã€‚åœ¨å€’æ•°ç¬¬äºŒæ­¥ä¸­ï¼Œæˆ‘ä»¬å°†å¯¹æ•°ç»„åˆæˆå•†ï¼Œå¹¶åˆ©ç”¨æœŸæœ›çš„çº¿æ€§æ€§å¾—åˆ°ä¸¤ä¸ªé¡¹çš„å’Œï¼š(1)
    è¿‘ä¼¼åéªŒä¸çœŸå®åéªŒä¹‹é—´çš„KLæ•£åº¦ï¼Œä»¥åŠ(2) ELBOï¼Œæˆ–è¯æ®ä¸‹ç•Œã€‚
- en: 'By now, you may have noticed that the form of the KL divergence is slightly
    different than what we encountered in [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba).
    Recall the standard KL divergence presented earlier, where the true distribution
    was *p(x)* and its approximation was *q(x)*. The KL divergence we defined was
    the difference between the cross entropy of the two distributions and the entropy
    of the true distribution, which was expressed as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°KLæ•£åº¦çš„å½¢å¼ä¸æˆ‘ä»¬åœ¨[ç¬¬2ç« ](ch02.xhtml#fundamentals-of-proba)ä¸­é‡åˆ°çš„ç•¥æœ‰ä¸åŒã€‚å›æƒ³ä¸€ä¸‹ä¹‹å‰ä»‹ç»çš„æ ‡å‡†KLæ•£åº¦ï¼Œå…¶ä¸­çœŸå®åˆ†å¸ƒæ˜¯*p(x)*ï¼Œå…¶è¿‘ä¼¼å€¼æ˜¯*q(x)*ã€‚æˆ‘ä»¬å®šä¹‰çš„KLæ•£åº¦æ˜¯ä¸¤ä¸ªåˆ†å¸ƒçš„äº¤å‰ç†µä¸çœŸå®åˆ†å¸ƒçš„ç†µä¹‹é—´çš„å·®å¼‚ï¼Œè¡¨è¾¾å¦‚ä¸‹ï¼š
- en: <math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p left-parenthesis x right-parenthesis
    Over q left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>ğ”¼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p left-parenthesis x right-parenthesis
    Over q left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>ğ”¼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
- en: We can see that the KL divergence in this derivation is the exact opposite.
    The expectation is with respect to the approximate posterior rather than the true
    posterior, and the numerator and denominator are flipped. Essentially what we
    see is <math alttext="double-struck upper E Subscript q left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction q left-parenthesis x right-parenthesis
    Over p left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>ğ”¼</mi>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
    instead of <math alttext="double-struck upper E Subscript p left-parenthesis x
    right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis x
    right-parenthesis Over q left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>ğ”¼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
    . We call this the *reverse KL divergence,* since the roles of the model and the
    truth have been switched, and is the quantity we attempt to minimize in VAEs.
    Although this does not have as clean a physical interpretation as the standard
    KL, note that the reverse KL divergence is *just a type of KL divergence* and
    retains all the properties we discussed in [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba).Thus,
    optimizing the reverse KL divergence still achieves a unique global minimum of
    zero when <math alttext="q left-parenthesis x right-parenthesis equals p left-parenthesis
    x right-parenthesis comma for-all x"><mrow><mi>q</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo>
    <mo>=</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mo>âˆ€</mo> <mi>x</mi></mrow></math>
    , so it is a valid objective to be optimizing over as it reaches its unique minimum
    when the approximate posterior is exactly the same as the true posterior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¿™ä¸ªæ¨å¯¼ä¸­KLæ•£åº¦æ˜¯å®Œå…¨ç›¸åçš„ã€‚æœŸæœ›æ˜¯é’ˆå¯¹è¿‘ä¼¼åéªŒè€Œä¸æ˜¯çœŸå®åéªŒï¼Œåˆ†å­å’Œåˆ†æ¯è¢«é¢ å€’äº†ã€‚åŸºæœ¬ä¸Šæˆ‘ä»¬çœ‹åˆ°çš„æ˜¯<math alttext="double-struck
    upper E Subscript q left-parenthesis x right-parenthesis Baseline left-bracket
    log StartFraction q left-parenthesis x right-parenthesis Over p left-parenthesis
    x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>ğ”¼</mi> <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
    è€Œä¸æ˜¯<math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket log StartFraction p left-parenthesis x right-parenthesis
    Over q left-parenthesis x right-parenthesis EndFraction right-bracket"><mrow><msub><mi>ğ”¼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo>
    <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac> <mo>]</mo></mrow></mrow></math>
    ã€‚æˆ‘ä»¬ç§°ä¹‹ä¸º*åå‘KLæ•£åº¦*ï¼Œå› ä¸ºæ¨¡å‹å’ŒçœŸç›¸çš„è§’è‰²å·²ç»äº¤æ¢ï¼Œè¿™æ˜¯æˆ‘ä»¬åœ¨VAEä¸­è¯•å›¾æœ€å°åŒ–çš„é‡ã€‚å°½ç®¡è¿™æ²¡æœ‰åƒæ ‡å‡†KLé‚£æ ·æ¸…æ™°çš„ç‰©ç†è§£é‡Šï¼Œä½†è¯·æ³¨æ„ï¼Œåå‘KLæ•£åº¦*åªæ˜¯ä¸€ç§KLæ•£åº¦*ï¼Œå¹¶ä¿ç•™äº†æˆ‘ä»¬åœ¨[ç¬¬2ç« ](ch02.xhtml#fundamentals-of-proba)ä¸­è®¨è®ºçš„æ‰€æœ‰å±æ€§ã€‚å› æ­¤ï¼Œä¼˜åŒ–åå‘KLæ•£åº¦ä»ç„¶åœ¨<math
    alttext="q left-parenthesis x right-parenthesis equals p left-parenthesis x right-parenthesis
    comma for-all x"><mrow><mi>q</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo>
    <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mo>âˆ€</mo> <mi>x</mi></mrow></math>æ—¶å®ç°é›¶çš„å”¯ä¸€å…¨å±€æœ€å°å€¼ï¼Œå› æ­¤å®ƒæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ä¼˜åŒ–ç›®æ ‡ï¼Œå› ä¸ºå½“è¿‘ä¼¼åéªŒä¸çœŸå®åéªŒå®Œå…¨ç›¸åŒæ—¶ï¼Œå®ƒè¾¾åˆ°å…¶å”¯ä¸€æœ€å°å€¼ã€‚
- en: 'The reality, however, is that the true posterior <math alttext="p left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> is still unknown to us. As a result, we canâ€™t directly
    minimize any KL divergence with the true posterior. This is where the ELBO plays
    a key role. As we discussed earlier, <math alttext="log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo form="prefix">log</mo>
    <mi>p</mi> <mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> is a constant. Thus, minimizing the reverse KL divergence
    is the same as maximizing the ELBO. The name evidence lower bound should make
    more sense nowâ€”as we maximize this term, it provides a better and better lower
    bound on the true log probability of the example. If we can develop a methodology
    for maximizing the ELBO efficiently, we should be well on our way to developing
    a generative model. Letâ€™s reformulate the ELBO into terms that might be easier
    to work with:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç°å®æ˜¯çœŸå®åéªŒ<math alttext="p left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> å¯¹æˆ‘ä»¬ä»ç„¶æ˜¯æœªçŸ¥çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æ— æ³•ç›´æ¥æœ€å°åŒ–ä»»ä½•KLæ•£åº¦ä¸çœŸå®åéªŒã€‚è¿™å°±æ˜¯ELBOå‘æŒ¥å…³é”®ä½œç”¨çš„åœ°æ–¹ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„ï¼Œ<math
    alttext="log p left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mo form="prefix">log</mo> <mi>p</mi> <mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></math>æ˜¯ä¸€ä¸ªå¸¸æ•°ã€‚å› æ­¤ï¼Œæœ€å°åŒ–åå‘KLæ•£åº¦ç­‰åŒäºæœ€å¤§åŒ–ELBOã€‚ç°åœ¨è¯æ®ä¸‹ç•Œè¿™ä¸ªåå­—åº”è¯¥æ›´æœ‰æ„ä¹‰äº†â€”â€”éšç€æˆ‘ä»¬æœ€å¤§åŒ–è¿™ä¸ªé¡¹ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªè¶Šæ¥è¶Šå¥½çš„çœŸå®ç¤ºä¾‹å¯¹æ•°æ¦‚ç‡çš„ä¸‹ç•Œã€‚å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿå¼€å‘ä¸€ç§æœ‰æ•ˆåœ°æœ€å¤§åŒ–ELBOçš„æ–¹æ³•ï¼Œæˆ‘ä»¬å°±åº”è¯¥åœ¨å¼€å‘ç”Ÿæˆæ¨¡å‹çš„é“è·¯ä¸Šèµ°å¾—æ›´é¡ºåˆ©ã€‚è®©æˆ‘ä»¬é‡æ–°è¡¨è¿°ELBOï¼Œä½¿å…¶æ›´å®¹æ˜“å¤„ç†ï¼š
- en: <math alttext="double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline comma z right-parenthesis
    Over q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis EndFraction right-bracket equals
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis right-bracket"><mrow><msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo><mi>z</mi><mo>)</mo></mrow>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline comma z right-parenthesis
    Over q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis EndFraction right-bracket equals
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline comma z right-parenthesis minus log q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis right-bracket"><mrow><msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><mi>p</mi><mo>(</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>,</mo><mi>z</mi><mo>)</mo></mrow>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac>
    <mo>]</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    plus log p left-parenthesis z right-parenthesis minus log q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>+</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    plus log p left-parenthesis z right-parenthesis minus log q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>+</mo> <mo form="prefix">log</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket plus double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis z right-parenthesis
    minus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket plus double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis z right-parenthesis
    minus log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>+</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>-</mo> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket minus double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis Over p left-parenthesis z right-parenthesis
    EndFraction right-bracket"><mrow><mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow> <mo>-</mo> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></mfrac>
    <mo>]</mo></mrow></mrow></math>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log p left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket minus double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket log StartFraction q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis Over p left-parenthesis z right-parenthesis
    EndFraction right-bracket"><mrow><mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow> <mo>-</mo> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mfrac><mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><mi>p</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow></mfrac>
    <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals minus upper K upper L left-parenthesis q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue p left-parenthesis
    z right-parenthesis right-parenthesis plus double-struck upper E Subscript q Sub
    Subscript phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket"><mrow><mrow><mo>=</mo> <mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals minus upper K upper L left-parenthesis q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue p left-parenthesis
    z right-parenthesis right-parenthesis plus double-struck upper E Subscript q Sub
    Subscript phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket"><mrow><mrow><mo>=</mo> <mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow></mrow></math>
- en: At this point, we can start to see the beginnings of an architecture and an
    optimization procedure for maximizing the ELBO. For example, the first term is
    just the reverse KL divergence between the approximate posterior and the prior,
    which we already assumed to be a Gaussian distribution. We can use a neural network,
    or encoder, to represent the approximate posterior. The reverse KL divergence
    acts as a regularization term on the approximate posterior, since maximizing the
    negative of the reverse KL is the same as minimizing the reverse KL. Regularization
    prevents the approximate posterior from straying too far from the prior distribution.
    This is desirable since we have witnessed only a single example, and thus we donâ€™t
    want our belief over the latent variables to shift too much from our prior. The
    second term is the expected true log likelihood of the example given a setting
    of latent variables *z,* where *z* is sampled from the approximate posterior.
    Wanting to maximize this quantity with respect to <math alttext="phi"><mi>Ï†</mi></math>
    is intuitively reasonable. This influences the approximate posterior to assign
    higher likelihoods to settings of *z* that, in turn, explain the input example
    <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> as well as possible.
    The balancing act between regularization, which prevents overfitting, and maximum
    likelihood estimation, which on its own would reach an optimum where <math alttext="q
    Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> is just a point mass over the setting of *z* that
    best describes <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> , is a classic optimization
    procedure youâ€™ve likely encountered in many data science and machine learning
    problems.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹çœ‹åˆ°ä¸€ä¸ªæ¶æ„å’Œä¸€ä¸ªæœ€å¤§åŒ–ELBOçš„ä¼˜åŒ–è¿‡ç¨‹çš„å¼€ç«¯ã€‚ä¾‹å¦‚ï¼Œç¬¬ä¸€é¡¹åªæ˜¯è¿‘ä¼¼åéªŒå’Œå…ˆéªŒä¹‹é—´çš„åå‘KLæ•£åº¦ï¼Œæˆ‘ä»¬å·²ç»å‡è®¾ä¸ºé«˜æ–¯åˆ†å¸ƒã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªç¥ç»ç½‘ç»œï¼Œæˆ–ç¼–ç å™¨ï¼Œæ¥è¡¨ç¤ºè¿‘ä¼¼åéªŒã€‚åå‘KLæ•£åº¦ä½œä¸ºä¸€ä¸ªæ­£åˆ™åŒ–é¡¹ä½œç”¨åœ¨è¿‘ä¼¼åéªŒä¸Šï¼Œå› ä¸ºæœ€å¤§åŒ–åå‘KLçš„è´Ÿå€¼ç­‰åŒäºæœ€å°åŒ–åå‘KLã€‚æ­£åˆ™åŒ–é˜²æ­¢è¿‘ä¼¼åéªŒåç¦»å…ˆéªŒåˆ†å¸ƒå¤ªè¿œã€‚è¿™æ˜¯å¯å–çš„ï¼Œå› ä¸ºæˆ‘ä»¬åªè§è¿‡ä¸€ä¸ªä¾‹å­ï¼Œå› æ­¤æˆ‘ä»¬ä¸å¸Œæœ›æˆ‘ä»¬å¯¹æ½œåœ¨å˜é‡çš„ä¿¡å¿µä»æˆ‘ä»¬çš„å…ˆéªŒä¸­åç¦»å¤ªå¤šã€‚ç¬¬äºŒé¡¹æ˜¯ç»™å®šæ½œåœ¨å˜é‡*z*çš„è®¾ç½®çš„ä¾‹å­çš„æœŸæœ›çœŸå®å¯¹æ•°ä¼¼ç„¶ï¼Œå…¶ä¸­*z*æ˜¯ä»è¿‘ä¼¼åéªŒä¸­æŠ½æ ·çš„ã€‚å¸Œæœ›ç›¸å¯¹äº
    <math alttext="phi"><mi>Ï†</mi></math> æœ€å¤§åŒ–è¿™ä¸ªæ•°é‡æ˜¯ç›´è§‚åˆç†çš„ã€‚è¿™å½±å“è¿‘ä¼¼åéªŒåˆ†é…æ›´é«˜çš„å¯èƒ½æ€§ç»™*z*çš„è®¾ç½®ï¼Œåè¿‡æ¥ï¼Œè§£é‡Šè¾“å…¥ä¾‹å­
    <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>ã€‚åœ¨æ­£åˆ™åŒ–å’Œæœ€å¤§ä¼¼ç„¶ä¼°è®¡ä¹‹é—´çš„å¹³è¡¡ï¼Œé˜²æ­¢è¿‡æ‹Ÿåˆï¼Œä»¥åŠæœ€å¤§ä¼¼ç„¶ä¼°è®¡æœ¬èº«ä¼šè¾¾åˆ°ä¸€ä¸ªæœ€ä¼˜ç‚¹ï¼Œå…¶ä¸­
    <math alttext="q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> åªæ˜¯ä¸€ä¸ªæœ€å¥½æè¿° <math alttext="x Superscript left-parenthesis
    i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    çš„*z*è®¾ç½®çš„ç‚¹è´¨é‡ï¼Œæ˜¯ä¸€ä¸ªç»å…¸çš„ä¼˜åŒ–è¿‡ç¨‹ï¼Œä½ å¯èƒ½åœ¨è®¸å¤šæ•°æ®ç§‘å­¦å’Œæœºå™¨å­¦ä¹ é—®é¢˜ä¸­é‡åˆ°è¿‡ã€‚
- en: 'However, as noted earlier, we unfortunately donâ€™t have access to the true conditional
    distribution <math alttext="p left-parenthesis x vertical-bar z right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></math> . Instead,
    we attempt to learn it using a second neural networkâ€”the decoder. We denote the
    parameters of the decoder as <math alttext="theta"><mi>Î¸</mi></math> and let the
    decoder represent the distribution <math alttext="p Subscript theta Baseline left-parenthesis
    x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> . In summary,
    we perform the following optimization procedure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæ­£å¦‚å‰é¢æ‰€æŒ‡å‡ºçš„ï¼Œæˆ‘ä»¬ä¸å¹¸åœ°æ— æ³•è®¿é—®çœŸå®çš„æ¡ä»¶åˆ†å¸ƒ <math alttext="p left-parenthesis x vertical-bar
    z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi>
    <mo>)</mo></mrow></math>ã€‚ç›¸åï¼Œæˆ‘ä»¬å°è¯•ä½¿ç”¨ç¬¬äºŒä¸ªç¥ç»ç½‘ç»œâ€”â€”è§£ç å™¨æ¥å­¦ä¹ å®ƒã€‚æˆ‘ä»¬å°†è§£ç å™¨çš„å‚æ•°è¡¨ç¤ºä¸º <math alttext="theta"><mi>Î¸</mi></math>ï¼Œå¹¶è®©è§£ç å™¨è¡¨ç¤ºåˆ†å¸ƒ
    <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>ã€‚æ€»ä¹‹ï¼Œæˆ‘ä»¬æ‰§è¡Œä»¥ä¸‹ä¼˜åŒ–è¿‡ç¨‹ï¼š
- en: <math alttext="phi Superscript asterisk Baseline comma theta Superscript asterisk
    Baseline equals argmax Subscript phi comma theta Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log p Subscript theta Baseline left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket"><mrow><msup><mi>Ï†</mi> <mo>*</mo></msup> <mo>,</mo> <msup><mi>Î¸</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmax</mtext> <mrow><mi>Ï†</mi><mo>,</mo><mi>Î¸</mi></mrow></msub>
    <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="phi Superscript asterisk Baseline comma theta Superscript asterisk
    Baseline equals argmax Subscript phi comma theta Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket log p Subscript theta Baseline left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis
    right-bracket"><mrow><msup><mi>Ï†</mi> <mo>*</mo></msup> <mo>,</mo> <msup><mi>Î¸</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmax</mtext> <mrow><mi>Ï†</mi><mo>,</mo><mi>Î¸</mi></mrow></msub>
    <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: 'Weâ€™ve already discussed why this is a valid optimization procedure for the
    encoder parameters <math alttext="phi"><mi>Ï†</mi></math> , assuming that <math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis
    equals p left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    . Of course, this assumption is not satisfied at the beginning of training. However,
    as training progresses and <math alttext="theta"><mi>Î¸</mi></math> becomes more
    and more optimal, we eventually arrive at the desired theoretical optimization.
    But the question still remains: why is this a valid optimization procedure for
    <math alttext="theta"><mi>Î¸</mi></math> ? If we assume the encoder represents
    the true posterior distribution, weâ€™d want to maximize the likelihood of recovering
    the original example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> from our encoder samples
    *z*. Of course, just like the optimization of <math alttext="phi"><mi>Ï†</mi></math>
    , our assumption about the approximate posterior is not satisfied at the beginning
    of trainingâ€”but as training progresses and two networks improve jointly, we hope
    to eventually reach our goal.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»è®¨è®ºè¿‡ä¸ºä»€ä¹ˆè¿™æ˜¯å¯¹ç¼–ç å™¨å‚æ•°Ï†çš„æœ‰æ•ˆä¼˜åŒ–è¿‡ç¨‹ï¼Œå‡è®¾pÎ¸|x,z=p|x,zã€‚å½“ç„¶ï¼Œåœ¨è®­ç»ƒå¼€å§‹æ—¶ï¼Œè¿™ä¸ªå‡è®¾å¹¶ä¸æˆç«‹ã€‚ç„¶è€Œï¼Œéšç€è®­ç»ƒçš„è¿›è¡Œå’ŒÎ¸å˜å¾—è¶Šæ¥è¶Šä¼˜åŒ–ï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šè¾¾åˆ°æœŸæœ›çš„ç†è®ºä¼˜åŒ–ã€‚ä½†é—®é¢˜ä»ç„¶å­˜åœ¨ï¼šä¸ºä»€ä¹ˆè¿™æ˜¯å¯¹Î¸çš„æœ‰æ•ˆä¼˜åŒ–è¿‡ç¨‹ï¼Ÿå¦‚æœæˆ‘ä»¬å‡è®¾ç¼–ç å™¨ä»£è¡¨çœŸå®çš„åéªŒåˆ†å¸ƒï¼Œæˆ‘ä»¬å¸Œæœ›æœ€å¤§åŒ–ä»æˆ‘ä»¬çš„ç¼–ç å™¨æ ·æœ¬*z*ä¸­æ¢å¤åŸå§‹ç¤ºä¾‹xiçš„å¯èƒ½æ€§ã€‚å½“ç„¶ï¼Œå°±åƒå¯¹Ï†çš„ä¼˜åŒ–ä¸€æ ·ï¼Œæˆ‘ä»¬å¯¹è¿‘ä¼¼åéªŒçš„å‡è®¾åœ¨è®­ç»ƒå¼€å§‹æ—¶å¹¶ä¸æˆç«‹ï¼Œä½†éšç€è®­ç»ƒçš„è¿›è¡Œå’Œä¸¤ä¸ªç½‘ç»œå…±åŒæ”¹è¿›ï¼Œæˆ‘ä»¬å¸Œæœ›æœ€ç»ˆè¾¾åˆ°æˆ‘ä»¬çš„ç›®æ ‡ã€‚
- en: 'This leads us into how to actually carry out the optimization. For <math alttext="theta"><mi>Î¸</mi></math>
    , it turns out we can use standard minibatch gradient descent techniques directly:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¼•å¯¼æˆ‘ä»¬å¦‚ä½•å®é™…è¿›è¡Œä¼˜åŒ–ã€‚å¯¹äºÎ¸ï¼Œäº‹å®è¯æ˜æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨æ ‡å‡†çš„å°æ‰¹é‡æ¢¯åº¦ä¸‹é™æŠ€æœ¯ï¼š
- en: <math alttext="normal nabla Subscript theta Baseline minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis plus double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>âˆ‡</mi>
    <mi>Î¸</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript theta Baseline minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis plus double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>âˆ‡</mi>
    <mi>Î¸</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript theta Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript theta Baseline double-struck upper E Subscript q Sub Subscript
    phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>Î¸</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>âˆ‡</mi>
    <mi>Î¸</mi></msub> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript theta Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript theta Baseline double-struck upper E Subscript q Sub Subscript
    phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>Î¸</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>âˆ‡</mi>
    <mi>Î¸</mi></msub> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript theta Baseline double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <mi>Î¸</mi></msub> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript theta Baseline double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <mi>Î¸</mi></msub> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket normal nabla Subscript theta
    Baseline log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>âˆ‡</mi> <mi>Î¸</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript q Sub Subscript phi Subscript
    left-parenthesis z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis
    Subscript right-parenthesis Baseline left-bracket normal nabla Subscript theta
    Baseline log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>âˆ‡</mi> <mi>Î¸</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="almost-equals StartFraction 1 Over n EndFraction sigma-summation
    Underscript j equals 1 Overscript n Endscripts normal nabla Subscript theta Baseline
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><mo>â‰ˆ</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>âˆ‡</mi> <mi>Î¸</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="almost-equals StartFraction 1 Over n EndFraction sigma-summation
    Underscript j equals 1 Overscript n Endscripts normal nabla Subscript theta Baseline
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><mo>â‰ˆ</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>âˆ‡</mi> <mi>Î¸</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: The first equality arises from the fact that the gradient of a sum of terms
    is equal to the sum of the gradients of each of the terms. Since the first term
    is not a function of <math alttext="theta"><mi>Î¸</mi></math> , its gradient with
    respect to <math alttext="theta"><mi>Î¸</mi></math> is 0, leading us to the second
    equality. From there we have the standard minibatch gradient estimate derivation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªç­‰å¼æºäºä¸€ä¸ªäº‹å®ï¼Œå³ä¸€ç»„é¡¹çš„æ¢¯åº¦ç­‰äºæ¯ä¸ªé¡¹çš„æ¢¯åº¦ä¹‹å’Œã€‚ç”±äºç¬¬ä¸€é¡¹ä¸æ˜¯Î¸çš„å‡½æ•°ï¼Œå®ƒå¯¹Î¸çš„æ¢¯åº¦ä¸º0ï¼Œå¯¼è‡´æˆ‘ä»¬å¾—åˆ°ç¬¬äºŒä¸ªç­‰å¼ã€‚ä»é‚£é‡Œæˆ‘ä»¬æœ‰äº†æ ‡å‡†çš„å°æ‰¹é‡æ¢¯åº¦ä¼°è®¡æ¨å¯¼ã€‚
- en: 'The optimization with respect to <math alttext="phi"><mi>Ï†</mi></math> is not
    as simple. If we try to do the same for <math alttext="phi"><mi>Ï†</mi></math>
    as we did for <math alttext="theta"><mi>Î¸</mi></math> , we run into an unforeseen
    issue:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºÏ†çš„ä¼˜åŒ–å¹¶ä¸é‚£ä¹ˆç®€å•ã€‚å¦‚æœæˆ‘ä»¬å°è¯•å¯¹Ï†åšä¸Î¸ç›¸åŒçš„æ“ä½œï¼Œæˆ‘ä»¬ä¼šé‡åˆ°ä¸€ä¸ªæ„æƒ³ä¸åˆ°çš„é—®é¢˜ï¼š
- en: <math alttext="normal nabla Subscript phi Baseline minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis plus double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript phi Baseline minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis plus double-struck upper
    E Subscript q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub
    Superscript left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline
    left-bracket log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript phi Baseline double-struck upper E Subscript q Sub Subscript
    phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript phi Baseline double-struck upper E Subscript q Sub Subscript
    phi Subscript left-parenthesis z vertical-bar x Sub Superscript left-parenthesis
    i right-parenthesis Subscript right-parenthesis Baseline left-bracket log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript phi Baseline integral q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo>âˆ«</mo> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    normal nabla Subscript phi Baseline integral q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo>âˆ«</mo> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    integral normal nabla Subscript phi Baseline q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo> <mo>âˆ«</mo></mrow> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    integral normal nabla Subscript phi Baseline q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo> <mo>âˆ«</mo></mrow> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
- en: 'In the last step, we canâ€™t express the second term as an expectation. This
    is because the gradient is with respect to the parameters of the distribution
    from which we are sampling. We canâ€™t simply switch the order of the expectation
    and gradient as we did for <math alttext="theta"><mi>Î¸</mi></math> . To get around
    this, we make the following observation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ€åä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬æ— æ³•å°†ç¬¬äºŒé¡¹è¡¨ç¤ºä¸ºæœŸæœ›ã€‚è¿™æ˜¯å› ä¸ºæ¢¯åº¦æ˜¯é’ˆå¯¹æˆ‘ä»¬æŠ½æ ·çš„åˆ†å¸ƒçš„å‚æ•°ã€‚æˆ‘ä»¬ä¸èƒ½åƒå¯¹Î¸é‚£æ ·ç®€å•åœ°äº¤æ¢æœŸæœ›å’Œæ¢¯åº¦çš„é¡ºåºã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬åšå‡ºä»¥ä¸‹è§‚å¯Ÿï¼š
- en: <math alttext="normal nabla Subscript phi Baseline q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis equals normal nabla Subscript phi Baseline q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis asterisk StartFraction q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis Over q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    EndFraction"><mrow><msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>*</mo> <mfrac><mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow> <mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></mfrac></mrow></math>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript phi Baseline q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis equals normal nabla Subscript phi Baseline q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis asterisk StartFraction q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis Over q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    EndFraction"><mrow><msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>*</mo> <mfrac><mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow> <mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></mfrac></mrow></math>
- en: <math alttext="equals q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    asterisk StartFraction normal nabla Subscript phi Baseline q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis Over q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    EndFraction"><mrow><mo>=</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>*</mo> <mfrac><mrow><msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac></mrow></math>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    asterisk StartFraction normal nabla Subscript phi Baseline q Subscript phi Baseline
    left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis Over q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    EndFraction"><mrow><mo>=</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>*</mo> <mfrac><mrow><msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></mfrac></mrow></math>
- en: <math alttext="equals q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    normal nabla Subscript phi Baseline log q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo>=</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    normal nabla Subscript phi Baseline log q Subscript phi Baseline left-parenthesis
    z vertical-bar x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mo>=</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
- en: 'With a bit of calculus and algebra, we have derived an equivalent form for
    the gradient. If we substitute this reformulation into the step we were stuck
    on:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ä¸€ç‚¹å¾®ç§¯åˆ†å’Œä»£æ•°ï¼Œæˆ‘ä»¬å¾—åˆ°äº†æ¢¯åº¦çš„ç­‰ä»·å½¢å¼ã€‚å¦‚æœæˆ‘ä»¬å°†è¿™ç§é‡è¿°æ›¿æ¢åˆ°æˆ‘ä»¬å¡ä½çš„æ­¥éª¤ä¸­ï¼š
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    integral q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis normal nabla Subscript
    phi Baseline log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo> <mo>âˆ«</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    integral q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis normal nabla Subscript
    phi Baseline log q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis d z"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo> <mo>âˆ«</mo></mrow> <msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>z</mi></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket normal nabla Subscript phi Baseline log
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis log p Subscript theta Baseline
    left-parenthesis x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar
    z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub>
    <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline minus upper K upper
    L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar x
    Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis StartAbsoluteValue
    EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis plus
    double-struck upper E Subscript q Sub Subscript phi Subscript left-parenthesis
    z vertical-bar x Sub Superscript left-parenthesis i right-parenthesis Subscript
    right-parenthesis Baseline left-bracket normal nabla Subscript phi Baseline log
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis log p Subscript theta Baseline
    left-parenthesis x Superscript left-parenthesis i right-parenthesis Baseline vertical-bar
    z right-parenthesis right-bracket"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub>
    <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow> <msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>|</mo> <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo> <mo>+</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="almost-equals normal nabla Subscript phi Baseline minus upper
    K upper L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    StartAbsoluteValue EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis
    plus StartFraction 1 Over n EndFraction sigma-summation Underscript j equals 1
    Overscript n Endscripts normal nabla Subscript phi Baseline log q Subscript phi
    Baseline left-parenthesis z equals z Subscript j Baseline vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><mo>â‰ˆ</mo>
    <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>j</mi></msub> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="almost-equals normal nabla Subscript phi Baseline minus upper
    K upper L left-parenthesis q Subscript phi Baseline left-parenthesis z vertical-bar
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    StartAbsoluteValue EndAbsoluteValue p left-parenthesis z right-parenthesis right-parenthesis
    plus StartFraction 1 Over n EndFraction sigma-summation Underscript j equals 1
    Overscript n Endscripts normal nabla Subscript phi Baseline log q Subscript phi
    Baseline left-parenthesis z equals z Subscript j Baseline vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis log p Subscript
    theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><mo>â‰ˆ</mo>
    <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mrow><mo>-</mo> <mi>K</mi> <mi>L</mi> <mo>(</mo></mrow>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mrow><mo>|</mo>
    <mo>|</mo> <mi>p</mi></mrow> <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mrow><mo>)</mo>
    <mo>+</mo></mrow> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>j</mi></msub> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: We can now use standard minibatch gradient estimation techniques to optimize
    our objective with respect to <math alttext="phi"><mi>Ï†</mi></math> . The observation
    we made is a well-known technique in the machine learning community termed the
    *log trick.* We will see this technique used again later in the chapter on reinforcement
    learning when we introduce the policy gradient method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ‡å‡†çš„å°æ‰¹é‡æ¢¯åº¦ä¼°è®¡æŠ€æœ¯æ¥ä¼˜åŒ–æˆ‘ä»¬å…³äºÏ†çš„ç›®æ ‡ã€‚æˆ‘ä»¬æ‰€åšçš„è§‚å¯Ÿæ˜¯æœºå™¨å­¦ä¹ ç¤¾åŒºä¸­ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„æŠ€æœ¯ï¼Œç§°ä¸º*logæŠ€å·§*ã€‚åœ¨å¼ºåŒ–å­¦ä¹ ç« èŠ‚ä¸­ä»‹ç»ç­–ç•¥æ¢¯åº¦æ–¹æ³•æ—¶ï¼Œæˆ‘ä»¬å°†å†æ¬¡çœ‹åˆ°è¿™ç§æŠ€æœ¯çš„åº”ç”¨ã€‚
- en: 'Now that we have fully dissected the first observation that Kingma and Welling
    made, we now move to the second: the computation of a low variance estimate of
    the gradient with respect to <math alttext="phi"><mi>Ï†</mi></math> . As we mentioned
    earlier, the log trick allows us to estimate this gradient. However, this estimate
    has been shown to be of high variance. This means that if we were to run trials
    where, in each trial, we draw a few samples <math alttext="z Subscript j"><msub><mi>z</mi>
    <mi>j</mi></msub></math> from the approximate posterior and estimate the gradient
    with respect to <math alttext="phi"><mi>Ï†</mi></math> , we would expect to see
    vastly different estimates of the gradient across trials. Of course, this is undesirable,
    as weâ€™d like trials for the same input example to be consistent with each other
    to have any confidence in our training procedure. We could try to ameliorate this
    by drawing many samples from the approximate posterior for each example, but this
    becomes computationally prohibitive for relatively little gain.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»å®Œå…¨å‰–æäº†Kingmaå’ŒWellingæå‡ºçš„ç¬¬ä¸€ä¸ªè§‚å¯Ÿï¼Œæˆ‘ä»¬ç°åœ¨è½¬å‘ç¬¬äºŒä¸ªè§‚å¯Ÿï¼šè®¡ç®—ç›¸å¯¹äº <math alttext="phi"><mi>Ï†</mi></math>
    çš„æ¢¯åº¦çš„ä½æ–¹å·®ä¼°è®¡ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼Œå¯¹æ•°æŠ€å·§ä½¿æˆ‘ä»¬èƒ½å¤Ÿä¼°è®¡è¿™ä¸ªæ¢¯åº¦ã€‚ç„¶è€Œï¼Œå·²ç»è¯æ˜è¿™ç§ä¼°è®¡å…·æœ‰å¾ˆé«˜çš„æ–¹å·®ã€‚è¿™æ„å‘³ç€å¦‚æœæˆ‘ä»¬è¿›è¡Œè¯•éªŒï¼Œåœ¨æ¯æ¬¡è¯•éªŒä¸­ï¼Œæˆ‘ä»¬ä»è¿‘ä¼¼åéªŒä¸­æŠ½å–ä¸€äº›æ ·æœ¬
    <math alttext="z Subscript j"><msub><mi>z</mi> <mi>j</mi></msub></math> å¹¶ä¼°è®¡ç›¸å¯¹äº
    <math alttext="phi"><mi>Ï†</mi></math> çš„æ¢¯åº¦ï¼Œæˆ‘ä»¬é¢„è®¡åœ¨ä¸åŒè¯•éªŒä¸­ä¼šçœ‹åˆ°æ¢¯åº¦çš„ä¼°è®¡å¤§ä¸ç›¸åŒã€‚å½“ç„¶ï¼Œè¿™æ˜¯ä¸å¯å–çš„ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›å¯¹äºç›¸åŒçš„è¾“å…¥ç¤ºä¾‹ï¼Œè¯•éªŒä¹‹é—´ä¿æŒä¸€è‡´ï¼Œä»¥å¯¹æˆ‘ä»¬çš„è®­ç»ƒè¿‡ç¨‹æœ‰ä¿¡å¿ƒã€‚æˆ‘ä»¬å¯ä»¥å°è¯•é€šè¿‡ä¸ºæ¯ä¸ªç¤ºä¾‹ä»è¿‘ä¼¼åéªŒä¸­æŠ½å–è®¸å¤šæ ·æœ¬æ¥æ”¹å–„è¿™ä¸€ç‚¹ï¼Œä½†è¿™å¯¹äºç›¸å¯¹è¾ƒå°çš„æ”¶ç›Šè€Œè¨€åœ¨è®¡ç®—ä¸Šæ˜¯ä¸å¯è¡Œçš„ã€‚
- en: Kingma and Welling proposed an alternative method to the log trick for getting
    around the issue of taking the gradient with respect to the weights of the network
    parametrizing distribution from which we are sampling. This method is called the
    *reparametrization trick*, and it allows us to compute a low variance estimate
    of the gradient, as opposed to the log trick. Why this is the case is beyond the
    scope of this text, but we refer you to the vast amount of academic literature
    that exists on this and similar topics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kingmaå’ŒWellingæå‡ºäº†ä¸€ç§ç»•è¿‡ä½¿ç”¨ç½‘ç»œæƒé‡å‚æ•°åŒ–åˆ†å¸ƒçš„æ¢¯åº¦çš„é—®é¢˜çš„å¯¹æ•°æŠ€å·§çš„æ›¿ä»£æ–¹æ³•ã€‚è¿™ç§æ–¹æ³•è¢«ç§°ä¸º*é‡æ–°å‚æ•°åŒ–æŠ€å·§*ï¼Œå®ƒå…è®¸æˆ‘ä»¬è®¡ç®—æ¢¯åº¦çš„ä½æ–¹å·®ä¼°è®¡ï¼Œä¸å¯¹æ•°æŠ€å·§ç›¸åã€‚ä¸ºä»€ä¹ˆä¼šè¿™æ ·è¶…å‡ºäº†æœ¬æ–‡çš„èŒƒå›´ï¼Œä½†æˆ‘ä»¬å»ºè®®æ‚¨å‚è€ƒå­˜åœ¨äºè¿™ä¸ªå’Œç±»ä¼¼ä¸»é¢˜ä¸Šçš„å¤§é‡å­¦æœ¯æ–‡çŒ®ã€‚
- en: 'The reparametrization trick involves assuming the approximate posterior takes
    on some form, such as a multivariate Gaussian distribution, and then expressing
    this distribution as a function of another distribution that has no dependence
    on the weights of the encoder. Letâ€™s assume that <math alttext="q Subscript phi
    Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo>
    <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> takes on the form <math alttext="upper N left-parenthesis
    z semicolon ModifyingAbove mu With caret Subscript phi Baseline comma ModifyingAbove
    sigma With caret Subscript phi Superscript 2 Baseline upper I right-parenthesis"><mrow><mi>N</mi>
    <mo>(</mo> <mi>z</mi> <mo>;</mo> <msub><mover accent="true"><mi>Î¼</mi> <mo>^</mo></mover>
    <mi>Ï†</mi></msub> <mo>,</mo> <msubsup><mover accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover>
    <mi>Ï†</mi> <mn>2</mn></msubsup> <mi>I</mi> <mo>)</mo></mrow></math> . This represents
    a multivariate Gaussian distribution where each component <math alttext="z Subscript
    i"><msub><mi>z</mi> <mi>i</mi></msub></math> is independent of all other components
    and <math alttext="z Subscript i Baseline tilde upper N left-parenthesis mu Subscript
    phi comma i Baseline comma sigma Subscript phi comma i Superscript 2 Baseline
    right-parenthesis"><mrow><msub><mi>z</mi> <mi>i</mi></msub> <mo>âˆ¼</mo> <mi>N</mi>
    <mrow><mo>(</mo> <msub><mi>Î¼</mi> <mrow><mi>Ï†</mi><mo>,</mo><mi>i</mi></mrow></msub>
    <mo>,</mo> <msubsup><mi>Ïƒ</mi> <mrow><mi>Ï†</mi><mo>,</mo><mi>i</mi></mrow> <mn>2</mn></msubsup>
    <mo>)</mo></mrow></mrow></math> , <math alttext="for-all i"><mrow><mo>âˆ€</mo> <mi>i</mi></mrow></math>
    . We use <math alttext="phi"><mi>Ï†</mi></math> in the subscript to explicitly
    show the approximate posteriorâ€™s dependence on the parameters of the encoder through
    its mean and variance vectors, which are defined by the encoder. In its current
    form, we run into the issue of not being able to switch the order of the expectation
    and the gradient that we encountered earlier. Using the reparametrization trick,
    we can rewrite the sampling procedure as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: é‡æ–°å‚æ•°åŒ–æŠ€å·§æ¶‰åŠå‡è®¾è¿‘ä¼¼åéªŒæœä»æŸç§å½¢å¼ï¼Œæ¯”å¦‚å¤šå…ƒé«˜æ–¯åˆ†å¸ƒï¼Œç„¶åå°†è¿™ä¸ªåˆ†å¸ƒè¡¨ç¤ºä¸ºå¦ä¸€ä¸ªåˆ†å¸ƒçš„å‡½æ•°ï¼Œè¯¥åˆ†å¸ƒä¸ä¾èµ–äºç¼–ç å™¨çš„æƒé‡ã€‚å‡è®¾ <math alttext="q
    Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi> <mi>Ï†</mi></msub>
    <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> é‡‡ç”¨å½¢å¼ <math alttext="upper N left-parenthesis z
    semicolon ModifyingAbove mu With caret Subscript phi Baseline comma ModifyingAbove
    sigma With caret Subscript phi Superscript 2 Baseline upper I right-parenthesis"><mrow><mi>N</mi>
    <mo>(</mo> <mi>z</mi> <mo>;</mo> <msub><mover accent="true"><mi>Î¼</mi> <mo>^</mo></mover>
    <mi>Ï†</mi></msub> <mo>,</mo> <msubsup><mover accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover>
    <mi>Ï†</mi> <mn>2</mn></msubsup> <mi>I</mi> <mo>)</mo></mrow></math> ã€‚è¿™ä»£è¡¨ä¸€ä¸ªå¤šå…ƒé«˜æ–¯åˆ†å¸ƒï¼Œå…¶ä¸­æ¯ä¸ªåˆ†é‡
    <math alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math> ç‹¬ç«‹äºæ‰€æœ‰å…¶ä»–åˆ†é‡ï¼Œå¹¶ä¸”
    <math alttext="z Subscript i Baseline tilde upper N left-parenthesis mu Subscript
    phi comma i Baseline comma sigma Subscript phi comma i Superscript 2 Baseline
    right-parenthesis"><mrow><msub><mi>z</mi> <mi>i</mi></msub> <mo>âˆ¼</mo> <mi>N</mi>
    <mrow><mo>(</mo> <msub><mi>Î¼</mi> <mrow><mi>Ï†</mi><mo>,</mo><mi>i</mi></mrow></msub>
    <mo>,</mo> <msubsup><mi>Ïƒ</mi> <mrow><mi>Ï†</mi><mo>,</mo><mi>i</mi></mrow> <mn>2</mn></msubsup>
    <mo>)</mo></mrow></mrow></math>ï¼Œå¯¹äºæ‰€æœ‰ iã€‚æˆ‘ä»¬åœ¨ä¸‹æ ‡ä¸­ä½¿ç”¨ <math alttext="phi"><mi>Ï†</mi></math>
    æ˜ç¡®æ˜¾ç¤ºè¿‘ä¼¼åéªŒä¾èµ–äºç¼–ç å™¨å‚æ•°çš„å‡å€¼å’Œæ–¹å·®å‘é‡ï¼Œè¿™äº›å‘é‡ç”±ç¼–ç å™¨å®šä¹‰ã€‚åœ¨å½“å‰å½¢å¼ä¸­ï¼Œæˆ‘ä»¬é‡åˆ°äº†æ— æ³•äº¤æ¢æœŸæœ›å’Œæ¢¯åº¦é¡ºåºçš„é—®é¢˜ã€‚ä½¿ç”¨é‡æ–°å‚æ•°åŒ–æŠ€å·§ï¼Œæˆ‘ä»¬å¯ä»¥å°†æŠ½æ ·è¿‡ç¨‹é‡å†™ä¸ºï¼š
- en: <math alttext="z tilde upper N left-parenthesis ModifyingAbove mu With caret
    Subscript phi Baseline comma ModifyingAbove sigma With caret Subscript phi Superscript
    2 Baseline upper I right-parenthesis left right double arrow z equals ModifyingAbove
    mu With caret Subscript phi Baseline plus ModifyingAbove sigma With caret Subscript
    phi Baseline asterisk epsilon comma epsilon tilde upper N left-parenthesis 0 comma
    upper I right-parenthesis"><mrow><mi>z</mi> <mo>âˆ¼</mo> <mi>N</mi> <mrow><mo>(</mo>
    <msub><mover accent="true"><mi>Î¼</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>,</mo>
    <msubsup><mover accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover> <mi>Ï†</mi> <mn>2</mn></msubsup>
    <mi>I</mi> <mo>)</mo></mrow> <mo>â‡”</mo> <mi>z</mi> <mo>=</mo> <msub><mover accent="true"><mi>Î¼</mi>
    <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>+</mo> <msub><mover accent="true"><mi>Ïƒ</mi>
    <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>*</mo> <mi>Ïµ</mi> <mo>,</mo> <mi>Ïµ</mi>
    <mo>âˆ¼</mo> <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>I</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="z tilde upper N left-parenthesis ModifyingAbove mu With caret
    Subscript phi Baseline comma ModifyingAbove sigma With caret Subscript phi Superscript
    2 Baseline upper I right-parenthesis left right double arrow z equals ModifyingAbove
    mu With caret Subscript phi Baseline plus ModifyingAbove sigma With caret Subscript
    phi Baseline asterisk epsilon comma epsilon tilde upper N left-parenthesis 0 comma
    upper I right-parenthesis"><mrow><mi>z</mi> <mo>âˆ¼</mo> <mi>N</mi> <mrow><mo>(</mo>
    <msub><mover accent="true"><mi>Î¼</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>,</mo>
    <msubsup><mover accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover> <mi>Ï†</mi> <mn>2</mn></msubsup>
    <mi>I</mi> <mo>)</mo></mrow> <mo>â‡”</mo> <mi>z</mi> <mo>=</mo> <msub><mover accent="true"><mi>Î¼</mi>
    <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>+</mo> <msub><mover accent="true"><mi>Ïƒ</mi>
    <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>*</mo> <mi>Ïµ</mi> <mo>,</mo> <mi>Ïµ</mi>
    <mo>âˆ¼</mo> <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>I</mi> <mo>)</mo></mrow></mrow></math>
- en: We highly encourage you to work out why the sampling procedure can be rewritten
    in this manner using the definition of the Gaussian distribution. It will be easier
    to consider the univariate case first, where *X* is a standard Gaussian random
    variable, and then show *Y = c*X* is a Gaussian random variable with mean zero
    and variance <math alttext="c squared"><msup><mi>c</mi> <mn>2</mn></msup></math>
    . Then, consider the general univariate case where *X* is any Gaussian random
    variable, and show *Y = X + c* is a Gaussian random variable with mean *E[X]*
    + *c* and variance *Var(X)*. Putting these steps together will get you to the
    reformulated sampling procedure described previously.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¼ºçƒˆé¼“åŠ±æ‚¨é€šè¿‡é«˜æ–¯åˆ†å¸ƒçš„å®šä¹‰æ¥è§£é‡Šä¸ºä»€ä¹ˆé‡‡æ ·è¿‡ç¨‹å¯ä»¥ä»¥è¿™ç§æ–¹å¼é‡å†™ã€‚é¦–å…ˆè€ƒè™‘å•å˜é‡æƒ…å†µä¼šæ›´å®¹æ˜“ï¼Œå…¶ä¸­*X*æ˜¯ä¸€ä¸ªæ ‡å‡†é«˜æ–¯éšæœºå˜é‡ï¼Œç„¶åå±•ç¤º*Y =
    c*X*æ˜¯ä¸€ä¸ªå‡å€¼ä¸ºé›¶ï¼Œæ–¹å·®ä¸º<math alttext="c squared"><msup><mi>c</mi> <mn>2</mn></msup></math>çš„é«˜æ–¯éšæœºå˜é‡ã€‚ç„¶åï¼Œè€ƒè™‘*X*æ˜¯ä»»æ„é«˜æ–¯éšæœºå˜é‡çš„ä¸€èˆ¬å•å˜é‡æƒ…å†µï¼Œå¹¶å±•ç¤º*Y
    = X + c*æ˜¯ä¸€ä¸ªå‡å€¼ä¸º*E[X]* + *c*ï¼Œæ–¹å·®ä¸º*Var(X)*çš„é«˜æ–¯éšæœºå˜é‡ã€‚å°†è¿™äº›æ­¥éª¤ç»“åˆèµ·æ¥ï¼Œæ‚¨å°†å¾—åˆ°å…ˆå‰æè¿°çš„é‡æ„é‡‡æ ·è¿‡ç¨‹ã€‚
- en: 'In summary, we have expressed the approximate posterior as a function of a
    distribution that is independent of <math alttext="phi"><mi>Ï†</mi></math> , along
    with a mean vector and a standard deviation vector that are dependent on <math
    alttext="phi"><mi>Ï†</mi></math> . We term the random variable <math alttext="epsilon"><mi>Ïµ</mi></math>
    an *auxiliary random variable.* Plugging this reformulation into our troublesome
    gradient expression from earlier:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ä¹‹ï¼Œæˆ‘ä»¬å°†è¿‘ä¼¼åéªŒè¡¨ç¤ºä¸ºä¸<math alttext="phi"><mi>Ï†</mi></math>æ— å…³çš„åˆ†å¸ƒå‡½æ•°ï¼Œä»¥åŠä¾èµ–äº<math alttext="phi"><mi>Ï†</mi></math>çš„å‡å€¼å‘é‡å’Œæ ‡å‡†å·®å‘é‡ã€‚æˆ‘ä»¬å°†éšæœºå˜é‡<math
    alttext="epsilon"><mi>Ïµ</mi></math>ç§°ä¸º*è¾…åŠ©éšæœºå˜é‡*ã€‚å°†è¿™ç§é‡æ„æ’å…¥æˆ‘ä»¬å…ˆå‰çš„æ£˜æ‰‹æ¢¯åº¦è¡¨è¾¾å¼ä¸­ï¼š
- en: <math alttext="normal nabla Subscript phi Baseline double-struck upper E Subscript
    q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub Superscript
    left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline left-bracket
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript phi Baseline double-struck upper E Subscript
    q Sub Subscript phi Subscript left-parenthesis z vertical-bar x Sub Superscript
    left-parenthesis i right-parenthesis Subscript right-parenthesis Baseline left-bracket
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar z right-parenthesis right-bracket"><mrow><msub><mi>âˆ‡</mi>
    <mi>Ï†</mi></msub> <msub><mi>ğ”¼</mi> <mrow><msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo><mi>z</mi><mo>|</mo><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript phi Baseline double-struck upper
    E Subscript epsilon tilde upper N left-parenthesis 0 comma upper I right-parenthesis
    Baseline left-bracket log p Subscript theta Baseline left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar g Subscript phi Baseline
    left-parenthesis epsilon right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>ğ”¼</mi> <mrow><mi>Ïµ</mi><mo>âˆ¼</mo><mi>N</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript phi Baseline double-struck upper
    E Subscript epsilon tilde upper N left-parenthesis 0 comma upper I right-parenthesis
    Baseline left-bracket log p Subscript theta Baseline left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar g Subscript phi Baseline
    left-parenthesis epsilon right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <msub><mi>ğ”¼</mi> <mrow><mi>Ïµ</mi><mo>âˆ¼</mo><mi>N</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals double-struck upper E Subscript epsilon tilde upper N
    left-parenthesis 0 comma upper I right-parenthesis Baseline left-bracket normal
    nabla Subscript phi Baseline log p Subscript theta Baseline left-parenthesis x
    Superscript left-parenthesis i right-parenthesis Baseline vertical-bar g Subscript
    phi Baseline left-parenthesis epsilon right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>Ïµ</mi><mo>âˆ¼</mo><mi>N</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals double-struck upper E Subscript epsilon tilde upper N
    left-parenthesis 0 comma upper I right-parenthesis Baseline left-bracket normal
    nabla Subscript phi Baseline log p Subscript theta Baseline left-parenthesis x
    Superscript left-parenthesis i right-parenthesis Baseline vertical-bar g Subscript
    phi Baseline left-parenthesis epsilon right-parenthesis right-parenthesis right-bracket"><mrow><mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><mi>Ïµ</mi><mo>âˆ¼</mo><mi>N</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>]</mo></mrow></mrow></math>
- en: <math alttext="almost-equals StartFraction 1 Over n EndFraction sigma-summation
    Underscript j equals 1 Overscript n Endscripts normal nabla Subscript phi Baseline
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar g Subscript phi Baseline left-parenthesis
    epsilon Subscript j Baseline right-parenthesis right-parenthesis"><mrow><mo>â‰ˆ</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <msub><mi>Ïµ</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="almost-equals StartFraction 1 Over n EndFraction sigma-summation
    Underscript j equals 1 Overscript n Endscripts normal nabla Subscript phi Baseline
    log p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline vertical-bar g Subscript phi Baseline left-parenthesis
    epsilon Subscript j Baseline right-parenthesis right-parenthesis"><mrow><mo>â‰ˆ</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>âˆ‡</mi> <mi>Ï†</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>|</mo> <msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <msub><mi>Ïµ</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: Where <math alttext="g Subscript phi Baseline left-parenthesis epsilon right-parenthesis
    equals ModifyingAbove mu With caret Subscript phi Baseline plus ModifyingAbove
    sigma With caret Subscript phi Baseline asterisk epsilon"><mrow><msub><mi>g</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mover
    accent="true"><mi>Î¼</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>+</mo> <msub><mover
    accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>*</mo> <mi>Ïµ</mi></mrow></math>
    . We rewrote *z* as <math alttext="g Subscript phi Baseline left-parenthesis epsilon
    right-parenthesis"><mrow><msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi>
    <mo>)</mo></mrow></mrow></math> to explicitly show that the dependence on the
    encoder parameters is now only through the deterministic function applied to the
    sampling distribution, rather than the sampling distribution itself. This allows
    us to switch the order of the expectation and the gradient seamlessly, thereby
    lending it to standard minibatch gradient estimation techniques.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­<math alttext="g Subscript phi Baseline left-parenthesis epsilon right-parenthesis
    equals ModifyingAbove mu With caret Subscript phi Baseline plus ModifyingAbove
    sigma With caret Subscript phi Baseline asterisk epsilon"><mrow><msub><mi>g</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mover
    accent="true"><mi>Î¼</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>+</mo> <msub><mover
    accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub> <mo>*</mo> <mi>Ïµ</mi></mrow></math>ã€‚æˆ‘ä»¬å°†*z*é‡å†™ä¸º<math
    alttext="g Subscript phi Baseline left-parenthesis epsilon right-parenthesis"><mrow><msub><mi>g</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow></mrow></math>ï¼Œæ˜ç¡®æ˜¾ç¤ºäº†å¯¹ç¼–ç å™¨å‚æ•°çš„ä¾èµ–ç°åœ¨ä»…é€šè¿‡åº”ç”¨äºé‡‡æ ·åˆ†å¸ƒçš„ç¡®å®šæ€§å‡½æ•°ï¼Œè€Œä¸æ˜¯é‡‡æ ·åˆ†å¸ƒæœ¬èº«ã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ— ç¼åˆ‡æ¢æœŸæœ›å’Œæ¢¯åº¦çš„é¡ºåºï¼Œä»è€Œä½¿å…¶é€‚ç”¨äºæ ‡å‡†çš„å°æ‰¹é‡æ¢¯åº¦ä¼°è®¡æŠ€æœ¯ã€‚
- en: How does this change manifest itself in the encoder architecture? Earlier, when
    using the log trick, we could directly parametrize the approximate posterior via
    the encoder. Now, we instead have the encoder, for each example <math alttext="x
    Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    , output a vector of means <math alttext="ModifyingAbove mu With caret Subscript
    phi"><msub><mover accent="true"><mi>Î¼</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub></math>
    , a vector of standard deviations <math alttext="ModifyingAbove sigma With caret
    Subscript phi"><msub><mover accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub></math>
    , and sample <math alttext="epsilon"><mi>Ïµ</mi></math> from a standard Gaussian
    distribution that is completely separate from the encoder-decoder VAE architecture.
    Note that the reparametrization technique comes with its own restrictionsâ€”we must
    assume a form for the approximate posterior, in this case a Gaussian, that allows
    us to define a differentiable function such as <math alttext="g Subscript phi"><msub><mi>g</mi>
    <mi>Ï†</mi></msub></math> . However, thereâ€™s no guarantee the true posterior is
    Gaussianâ€”it is most likely a complex distribution that cannot be represented as
    functions of our standard distributions. This is a trade-off we must make to achieve
    a low variance gradient estimate for tractable optimization ([FigureÂ 10-5](#fig1005)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å˜åŒ–å¦‚ä½•ä½“ç°åœ¨ç¼–ç å™¨æ¶æ„ä¸­ï¼Ÿæ—©æœŸï¼Œå½“ä½¿ç”¨å¯¹æ•°æŠ€å·§æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç¼–ç å™¨ç›´æ¥å‚æ•°åŒ–è¿‘ä¼¼åéªŒã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ”¹ä¸ºç¼–ç å™¨ï¼Œå¯¹äºæ¯ä¸ªç¤ºä¾‹<math alttext="x
    Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>ï¼Œè¾“å‡ºå‡å€¼å‘é‡<math
    alttext="ModifyingAbove mu With caret Subscript phi"><msub><mover accent="true"><mi>Î¼</mi>
    <mo>^</mo></mover> <mi>Ï†</mi></msub></math>ï¼Œæ ‡å‡†å·®å‘é‡<math alttext="ModifyingAbove
    sigma With caret Subscript phi"><msub><mover accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover>
    <mi>Ï†</mi></msub></math>ï¼Œå¹¶ä»ä¸ç¼–ç å™¨-è§£ç å™¨VAEæ¶æ„å®Œå…¨åˆ†ç¦»çš„æ ‡å‡†é«˜æ–¯åˆ†å¸ƒä¸­é‡‡æ ·<math alttext="epsilon"><mi>Ïµ</mi></math>ã€‚è¯·æ³¨æ„ï¼Œé‡æ–°å‚æ•°åŒ–æŠ€æœ¯æœ‰å…¶è‡ªèº«çš„é™åˆ¶â€”â€”æˆ‘ä»¬å¿…é¡»å‡è®¾è¿‘ä¼¼åéªŒçš„å½¢å¼ï¼Œæœ¬ä¾‹ä¸­ä¸ºé«˜æ–¯åˆ†å¸ƒï¼Œè¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿå®šä¹‰ä¸€ä¸ªå¯å¾®å‡½æ•°ï¼Œå¦‚<math
    alttext="g Subscript phi"><msub><mi>g</mi> <mi>Ï†</mi></msub></math>ã€‚ç„¶è€Œï¼Œå¹¶æ²¡æœ‰ä¿è¯çœŸå®åéªŒæ˜¯é«˜æ–¯åˆ†å¸ƒâ€”â€”å®ƒå¾ˆå¯èƒ½æ˜¯ä¸€ä¸ªå¤æ‚çš„åˆ†å¸ƒï¼Œæ— æ³•è¡¨ç¤ºä¸ºæˆ‘ä»¬æ ‡å‡†åˆ†å¸ƒçš„å‡½æ•°ã€‚è¿™æ˜¯æˆ‘ä»¬å¿…é¡»åšå‡ºçš„æƒè¡¡ï¼Œä»¥è·å¾—å¯å¤„ç†çš„ä¼˜åŒ–çš„ä½æ–¹å·®æ¢¯åº¦ä¼°è®¡ï¼ˆ[å›¾10-5](#fig1005)ï¼‰ã€‚
- en: '![](Images/fdl2_1005.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1005.png)'
- en: Figure 10-5\. What the encoder looks like after the inclusion of reparametrization.
    It returns a mean and standard deviation vector, which we can combine with Ïµ to
    generate the setting of z. The purpose of the circle versus rectangles is to show
    that the only sampling is happening for Ïµ, completely independent of the encoder
    architecture. The mean and standard deviation vectors are produced deterministically
    from the input image. In addition, z is deterministic once we know the value of
    Ïµ.
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾10-5ã€‚åœ¨é‡æ–°å‚æ•°åŒ–åç¼–ç å™¨çš„å¤–è§‚ã€‚å®ƒè¿”å›ä¸€ä¸ªå‡å€¼å’Œæ ‡å‡†å·®å‘é‡ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ä¸ Ïµ ç»“åˆèµ·æ¥ç”Ÿæˆ z çš„è®¾ç½®ã€‚åœ†å½¢ä¸çŸ©å½¢ä¹‹é—´çš„åŒºåˆ«åœ¨äº Ïµ çš„æŠ½æ ·æ˜¯å”¯ä¸€å‘ç”Ÿçš„ï¼Œå®Œå…¨ç‹¬ç«‹äºç¼–ç å™¨æ¶æ„ã€‚å‡å€¼å’Œæ ‡å‡†å·®å‘é‡æ˜¯ç¡®å®šæ€§åœ°ä»è¾“å…¥å›¾åƒä¸­äº§ç”Ÿçš„ã€‚æ­¤å¤–ï¼Œä¸€æ—¦æˆ‘ä»¬çŸ¥é“
    Ïµ çš„å€¼ï¼Œz å°±æ˜¯ç¡®å®šæ€§çš„ã€‚
- en: 'Note that the training procedure for a VAE is quite simpleâ€”the beast was in
    the motivation and mathematics behind the architecture and optimization. All we
    need to do is:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼ŒVAE çš„è®­ç»ƒè¿‡ç¨‹éå¸¸ç®€å•â€”â€”å…¶å¤æ‚æ€§åœ¨äºæ¶æ„å’Œä¼˜åŒ–èƒŒåçš„åŠ¨æœºå’Œæ•°å­¦ã€‚æˆ‘ä»¬éœ€è¦åšçš„åªæ˜¯ï¼š
- en: Sample an example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> from the dataset.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»æ•°æ®é›†ä¸­æŠ½æ ·ä¸€ä¸ªç¤ºä¾‹ <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>ã€‚
- en: Run <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> through the encoder
    network to generate a vector of means <math alttext="ModifyingAbove mu With caret
    Subscript phi"><msub><mover accent="true"><mi>Î¼</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub></math>
    and a vector of standard deviations <math alttext="ModifyingAbove sigma With caret
    Subscript phi"><msub><mover accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub></math>
    .
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é€šè¿‡ç¼–ç å™¨ç½‘ç»œè¿è¡Œ <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> ç”Ÿæˆä¸€ä¸ªå‡å€¼å‘é‡ <math alttext="ModifyingAbove
    mu With caret Subscript phi"><msub><mover accent="true"><mi>Î¼</mi> <mo>^</mo></mover>
    <mi>Ï†</mi></msub></math> å’Œä¸€ä¸ªæ ‡å‡†å·®å‘é‡ <math alttext="ModifyingAbove sigma With caret
    Subscript phi"><msub><mover accent="true"><mi>Ïƒ</mi> <mo>^</mo></mover> <mi>Ï†</mi></msub></math>ã€‚
- en: Sample <math alttext="epsilon"><mi>Ïµ</mi></math> and calculate the result of
    <math alttext="g Subscript phi Baseline left-parenthesis epsilon right-parenthesis"><mrow><msub><mi>g</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æŠ½æ · <math alttext="epsilon"><mi>Ïµ</mi></math> å¹¶è®¡ç®— <math alttext="g Subscript
    phi Baseline left-parenthesis epsilon right-parenthesis"><mrow><msub><mi>g</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow></mrow></math>
    çš„ç»“æœã€‚
- en: Run the result through the decoder network, which now represents the distribution
    <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z equals
    g Subscript phi Baseline left-parenthesis epsilon right-parenthesis right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo>
    <msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>Ïµ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></math> .
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é€šè¿‡è§£ç å™¨ç½‘ç»œè¿è¡Œç»“æœï¼Œç°åœ¨è¡¨ç¤ºåˆ†å¸ƒ <math alttext="p Subscript theta Baseline left-parenthesis
    x vertical-bar z equals g Subscript phi Baseline left-parenthesis epsilon right-parenthesis
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>g</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo>
    <mi>Ïµ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>ã€‚
- en: Query this distribution with our initial example <math alttext="x Superscript
    left-parenthesis i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    and take the log of the resulting likelihood. This will be our *decoder loss.*
    If you took multiple samples of <math alttext="epsilon"><mi>Ïµ</mi></math> in step
    3, run the above procedure for each sample, and average to get the decoder loss.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç”¨æˆ‘ä»¬çš„åˆå§‹ç¤ºä¾‹ <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> æŸ¥è¯¢è¿™ä¸ªåˆ†å¸ƒï¼Œå¹¶å–ç»“æœä¼¼ç„¶çš„å¯¹æ•°ã€‚è¿™å°†æ˜¯æˆ‘ä»¬çš„
    *è§£ç å™¨æŸå¤±*ã€‚å¦‚æœåœ¨æ­¥éª¤3ä¸­å¯¹ <math alttext="epsilon"><mi>Ïµ</mi></math> è¿›è¡Œäº†å¤šæ¬¡æŠ½æ ·ï¼Œè¯·å¯¹æ¯ä¸ªæ ·æœ¬è¿è¡Œä¸Šè¿°è¿‡ç¨‹ï¼Œå¹¶å–å¹³å‡å€¼ä»¥è·å¾—è§£ç å™¨æŸå¤±ã€‚
- en: Sum the decoder loss with <math alttext="minus upper K upper L left-parenthesis
    q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis"><mrow><mo>-</mo> <mi>K</mi>
    <mi>L</mi> <mo>(</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>|</mo> <mo>|</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></math> , the *encoder loss,* to get a final
    loss. Use the negative of the final loss in the next step since we want to maximize
    it instead of minimize it.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†è§£ç å™¨æŸå¤±ä¸ *ç¼–ç å™¨æŸå¤±* <math alttext="minus upper K upper L left-parenthesis q Subscript
    phi Baseline left-parenthesis z vertical-bar x Superscript left-parenthesis i
    right-parenthesis Baseline right-parenthesis StartAbsoluteValue EndAbsoluteValue
    p left-parenthesis z right-parenthesis right-parenthesis"><mrow><mo>-</mo> <mi>K</mi>
    <mi>L</mi> <mo>(</mo> <msub><mi>q</mi> <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi>
    <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>|</mo> <mo>|</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></math> ç›¸åŠ ï¼Œå¾—åˆ°æœ€ç»ˆæŸå¤±ã€‚åœ¨ä¸‹ä¸€æ­¥ä¸­ä½¿ç”¨æœ€ç»ˆæŸå¤±çš„è´Ÿå€¼ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›æœ€å¤§åŒ–å®ƒè€Œä¸æ˜¯æœ€å°åŒ–å®ƒã€‚
- en: Perform classical SGD/minibatch gradient descent to update <math alttext="phi"><mi>Ï†</mi></math>
    and <math alttext="theta"><mi>Î¸</mi></math> .
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‰§è¡Œç»å…¸çš„ SGD/å°æ‰¹é‡æ¢¯åº¦ä¸‹é™æ¥æ›´æ–° <math alttext="phi"><mi>Ï†</mi></math> å’Œ <math alttext="theta"><mi>Î¸</mi></math>ã€‚
- en: Now that we have covered how to train a VAE, how do we utilize it as a generative
    model once it is trained? Note that we initially defined the generative process
    as <math alttext="p left-parenthesis x vertical-bar z right-parenthesis p left-parenthesis
    z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi>
    <mo>)</mo> <mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo></mrow></math> , where we
    start with some setting of the latent variables *z* sampled from the prior distribution
    and map *z* to an instance *x* in the data space via the conditional likelihood.
    Weâ€™ve already learned this generative process in the form of <math alttext="p
    Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    , or the decoder, and assumed the prior distribution <math alttext="p left-parenthesis
    z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo></mrow></math>
    to be a multivariate standard Gaussian at the beginning. To generate samples from
    a VAE, we sample <math alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>
    from the prior distribution *p(z),* pass this sample through the decoder so it
    now represents the distribution <math alttext="p Subscript theta Baseline left-parenthesis
    x vertical-bar z equals z Subscript i Baseline right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo>
    <msub><mi>z</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math> , and finally
    sample <math alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>
    from <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar
    z equals z Subscript i Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math> . Note that we no longer need
    the approximate posterior at this stepâ€”however, it played a key role in the training
    of the decoder and is still useful in understanding how our latent variable distribution
    shifts after witnessing an example from the dataset.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»è®¨è®ºäº†å¦‚ä½•è®­ç»ƒVAEï¼Œé‚£ä¹ˆä¸€æ—¦è®­ç»ƒå®Œæˆï¼Œæˆ‘ä»¬å¦‚ä½•å°†å…¶ç”¨ä½œç”Ÿæˆæ¨¡å‹å‘¢ï¼Ÿè¯·æ³¨æ„ï¼Œæˆ‘ä»¬æœ€åˆå°†ç”Ÿæˆè¿‡ç¨‹å®šä¹‰ä¸º<math alttext="p left-parenthesis
    x vertical-bar z right-parenthesis p left-parenthesis z right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo> <mi>p</mi> <mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow></math>ï¼Œå…¶ä¸­æˆ‘ä»¬ä»å…ˆéªŒåˆ†å¸ƒä¸­å¯¹æ½œåœ¨å˜é‡*z*è¿›è¡Œé‡‡æ ·ï¼Œå¹¶é€šè¿‡æ¡ä»¶ä¼¼ç„¶å°†*z*æ˜ å°„åˆ°æ•°æ®ç©ºé—´ä¸­çš„å®ä¾‹*x*ã€‚æˆ‘ä»¬å·²ç»å­¦ä¹ äº†è¿™ä¸ªç”Ÿæˆè¿‡ç¨‹çš„å½¢å¼<math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>ï¼Œæˆ–è€…è§£ç å™¨ï¼Œå¹¶å‡è®¾å…ˆéªŒåˆ†å¸ƒ<math
    alttext="p left-parenthesis z right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow></math>æœ€åˆæ˜¯ä¸€ä¸ªå¤šå…ƒæ ‡å‡†é«˜æ–¯åˆ†å¸ƒã€‚è¦ä»VAEç”Ÿæˆæ ·æœ¬ï¼Œæˆ‘ä»¬ä»å…ˆéªŒåˆ†å¸ƒ*p(z)*ä¸­é‡‡æ ·<math alttext="z
    Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>ï¼Œå°†æ­¤æ ·æœ¬é€šè¿‡è§£ç å™¨ï¼Œä½¿å…¶ç°åœ¨è¡¨ç¤ºåˆ†å¸ƒ<math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z equals z
    Subscript i Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>ï¼Œæœ€åä»<math alttext="p Subscript
    theta Baseline left-parenthesis x vertical-bar z equals z Subscript i Baseline
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>ä¸­é‡‡æ ·<math
    alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>ã€‚è¯·æ³¨æ„ï¼Œåœ¨è¿™ä¸€æ­¥æˆ‘ä»¬ä¸å†éœ€è¦è¿‘ä¼¼åéªŒ
    - ä½†æ˜¯ï¼Œåœ¨è§£ç å™¨çš„è®­ç»ƒä¸­èµ·ç€å…³é”®ä½œç”¨ï¼Œå¹¶ä¸”åœ¨ç†è§£æˆ‘ä»¬çš„æ½œåœ¨å˜é‡åˆ†å¸ƒåœ¨çœ‹åˆ°æ•°æ®é›†ä¸­çš„ç¤ºä¾‹åå¦‚ä½•å˜åŒ–æ–¹é¢ä»ç„¶å¾ˆæœ‰ç”¨ã€‚
- en: Implementing a VAE
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å®ç°VAE
- en: In this section, we will build a VAE from scratch in PyTorch. We will additionally
    provide some example training and testing code on the famous MNIST digits dataset.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†åœ¨PyTorchä¸­ä»å¤´å¼€å§‹æ„å»ºä¸€ä¸ªVAEã€‚æˆ‘ä»¬è¿˜å°†æä¾›ä¸€äº›åœ¨è‘—åçš„MNISTæ•°å­—æ•°æ®é›†ä¸Šè¿›è¡Œè®­ç»ƒå’Œæµ‹è¯•çš„ç¤ºä¾‹ä»£ç ã€‚
- en: 'Before we begin, here is a list of the packages you will need to reproduce
    this section on your own:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¼€å§‹ä¹‹å‰ï¼Œè¿™é‡Œæ˜¯æ‚¨éœ€è¦çš„è½¯ä»¶åŒ…åˆ—è¡¨ï¼Œä»¥ä¾¿è‡ªå·±é‡ç°æœ¬èŠ‚å†…å®¹ï¼š
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Letâ€™s start with the encoder. As we discussed in the previous section, the encoder
    is a neural network that outputs a vector of means and a vector of standard deviations.
    Each index represents a univariate Gaussian, and the entire vector represents
    a multivariate Gaussian where each component is independent from the others. Though
    we are working with image data, for the sake of simplicity we convert each image
    into a vector by flattening it at the start. This allows us to apply standard,
    fully connected layers on the input. Since each image in the MNIST dataset is
    of size 28 Ã— 28, each resulting representation is a 784-dimensional vector. We
    also need to decide on the number of components, or latent variables, we will
    use to represent the latent space. We can treat the number of components as a
    hyperparameterâ€”if we notice that the decoder log likelihoods of input examples
    are consistently low even after a significant amount of training, this may indicate
    an approximate posterior that is not expressive enough. Increasing the number
    of components and retraining in this case is advisable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»ç¼–ç å™¨å¼€å§‹ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨ä¸Šä¸€èŠ‚ä¸­è®¨è®ºçš„ï¼Œç¼–ç å™¨æ˜¯ä¸€ä¸ªç¥ç»ç½‘ç»œï¼Œå®ƒè¾“å‡ºä¸€ç»„å‡å€¼å‘é‡å’Œä¸€ç»„æ ‡å‡†å·®å‘é‡ã€‚æ¯ä¸ªç´¢å¼•ä»£è¡¨ä¸€ä¸ªå•å˜é‡é«˜æ–¯åˆ†å¸ƒï¼Œæ•´ä¸ªå‘é‡ä»£è¡¨ä¸€ä¸ªå¤šå…ƒé«˜æ–¯åˆ†å¸ƒï¼Œå…¶ä¸­æ¯ä¸ªåˆ†é‡ä¸å…¶ä»–åˆ†é‡ç‹¬ç«‹ã€‚è™½ç„¶æˆ‘ä»¬å¤„ç†çš„æ˜¯å›¾åƒæ•°æ®ï¼Œä½†ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬åœ¨å¼€å§‹æ—¶å°†æ¯ä¸ªå›¾åƒå±•å¹³ä¸ºä¸€ä¸ªå‘é‡ã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨è¾“å…¥ä¸Šåº”ç”¨æ ‡å‡†çš„å…¨è¿æ¥å±‚ã€‚ç”±äºMNISTæ•°æ®é›†ä¸­çš„æ¯ä¸ªå›¾åƒå¤§å°ä¸º28Ã—28ï¼Œå› æ­¤æ¯ä¸ªç»“æœè¡¨ç¤ºæ˜¯ä¸€ä¸ª784ç»´å‘é‡ã€‚æˆ‘ä»¬è¿˜éœ€è¦å†³å®šç”¨äºè¡¨ç¤ºæ½œåœ¨ç©ºé—´çš„æˆåˆ†æˆ–æ½œåœ¨å˜é‡çš„æ•°é‡ã€‚æˆ‘ä»¬å¯ä»¥å°†æˆåˆ†çš„æ•°é‡è§†ä¸ºè¶…å‚æ•°
    - å¦‚æœæˆ‘ä»¬æ³¨æ„åˆ°å³ä½¿ç»è¿‡å¤§é‡è®­ç»ƒï¼Œè¾“å…¥ç¤ºä¾‹çš„è§£ç å™¨å¯¹æ•°ä¼¼ç„¶ä»ç„¶ä¸€ç›´å¾ˆä½ï¼Œè¿™å¯èƒ½è¡¨æ˜è¿‘ä¼¼åéªŒä¸å¤Ÿè¡¨è¾¾ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹å¢åŠ æˆåˆ†çš„æ•°é‡å¹¶é‡æ–°è®­ç»ƒæ˜¯æ˜æ™ºçš„ã€‚
- en: 'Here is example code for an encoder:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¼–ç å™¨çš„ç¤ºä¾‹ä»£ç ï¼š
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the sake of simplicity, we leave out nonlinearities between the layers
    for now. Our encoder consists of two levels of layers. The first level operates
    on the input, embedding the vector into a lower dimensional representation. The
    second level operates on the 200-d representation and consists of two independent
    layers: one for determining the means of each of the univariate Gaussian components,
    and one for determining the standard deviations of each of the univariate Gaussian
    components. Here, we use 20 components. As we stated earlier, we assume <math
    alttext="q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> takes the form of a multivariate Gaussian, where
    each component is independent of the others. Note that attempting to learn a full
    covariance matrix is computationally prohibitive (amongst other concerns), as
    its size grows quadratically with the number of components.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬æš‚æ—¶å¿½ç•¥å±‚ä¹‹é—´çš„éçº¿æ€§ã€‚æˆ‘ä»¬çš„ç¼–ç å™¨ç”±ä¸¤ä¸ªçº§åˆ«çš„å±‚ç»„æˆã€‚ç¬¬ä¸€çº§åˆ«å¯¹è¾“å…¥è¿›è¡Œæ“ä½œï¼Œå°†å‘é‡åµŒå…¥åˆ°è¾ƒä½ç»´åº¦çš„è¡¨ç¤ºä¸­ã€‚ç¬¬äºŒçº§åˆ«å¯¹200ç»´è¡¨ç¤ºè¿›è¡Œæ“ä½œï¼Œç”±ä¸¤ä¸ªç‹¬ç«‹çš„å±‚ç»„æˆï¼šä¸€ä¸ªç”¨äºç¡®å®šæ¯ä¸ªå•å˜é‡é«˜æ–¯åˆ†é‡çš„å‡å€¼ï¼Œä¸€ä¸ªç”¨äºç¡®å®šæ¯ä¸ªå•å˜é‡é«˜æ–¯åˆ†é‡çš„æ ‡å‡†å·®ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨20ä¸ªåˆ†é‡ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€è¿°ï¼Œæˆ‘ä»¬å‡è®¾<math
    alttext="q Subscript phi Baseline left-parenthesis z vertical-bar x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Ï†</mi></msub> <mrow><mo>(</mo> <mi>z</mi> <mo>|</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>é‡‡ç”¨å¤šå…ƒé«˜æ–¯çš„å½¢å¼ï¼Œå…¶ä¸­æ¯ä¸ªåˆ†é‡ç‹¬ç«‹äºå…¶ä»–åˆ†é‡ã€‚è¯·æ³¨æ„ï¼Œå°è¯•å­¦ä¹ å®Œæ•´çš„åæ–¹å·®çŸ©é˜µåœ¨è®¡ç®—ä¸Šæ˜¯ä¸å¯è¡Œçš„ï¼ˆé™¤å…¶ä»–é—®é¢˜å¤–ï¼‰ï¼Œå› ä¸ºå…¶å¤§å°éšåˆ†é‡æ•°é‡çš„å¢åŠ å‘ˆäºŒæ¬¡å¢é•¿ã€‚
- en: 'Here is example code for a decoder:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯è§£ç å™¨çš„ç¤ºä¾‹ä»£ç ï¼š
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, we leave out the nonlinearities for the sake of simplicity. The decoder
    operates on the sampled *z*, which we know is a 20-d vector. The rest of the decoder
    architecture is symmetrical to the encoder, and outputs a distribution over the
    input data. Although not in the code just yet, there is a final sigmoid layer
    that will be applied to the output of the `recon_output` layer which, recall,
    squashes each input dimension into the range (0,1). Since we are working with
    the discrete MNIST dataset where each pixel is represented as either a zero or
    a one, the output of the final sigmoid layer is used to represent a Bernoulli
    distribution for each pixel. Recall the Bernoulli distribution from [ChapterÂ 2](ch02.xhtml#fundamentals-of-proba),
    represented as *Ber(p),* where *p* is the probability of returning a one and 1
    *â€“ p* is the the probability of returning a zero.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å†æ¬¡å¿½ç•¥éçº¿æ€§ã€‚è§£ç å™¨æ“ä½œé‡‡æ ·çš„*z*ï¼Œæˆ‘ä»¬çŸ¥é“å®ƒæ˜¯ä¸€ä¸ª20ç»´å‘é‡ã€‚è§£ç å™¨çš„å…¶ä½™æ¶æ„ä¸ç¼–ç å™¨å¯¹ç§°ï¼Œå¹¶è¾“å‡ºè¾“å…¥æ•°æ®çš„åˆ†å¸ƒã€‚å°½ç®¡ä»£ç ä¸­è¿˜æ²¡æœ‰ï¼Œä½†æœ€ç»ˆä¼šåº”ç”¨ä¸€ä¸ªsigmoidå±‚åˆ°`recon_output`å±‚çš„è¾“å‡ºä¸Šï¼Œå›æƒ³ä¸€ä¸‹ï¼Œå®ƒå°†æ¯ä¸ªè¾“å…¥ç»´åº¦å‹ç¼©åˆ°èŒƒå›´(0,1)ã€‚ç”±äºæˆ‘ä»¬ä½¿ç”¨ç¦»æ•£çš„MNISTæ•°æ®é›†ï¼Œå…¶ä¸­æ¯ä¸ªåƒç´ è¡¨ç¤ºä¸ºé›¶æˆ–ä¸€ï¼Œæœ€ç»ˆsigmoidå±‚çš„è¾“å‡ºç”¨äºè¡¨ç¤ºæ¯ä¸ªåƒç´ çš„ä¼¯åŠªåˆ©åˆ†å¸ƒã€‚å›æƒ³ä¸€ä¸‹[ç¬¬2ç« ](ch02.xhtml#fundamentals-of-proba)ä¸­çš„ä¼¯åŠªåˆ©åˆ†å¸ƒï¼Œè¡¨ç¤ºä¸º*Ber(p)*ï¼Œå…¶ä¸­*p*æ˜¯è¿”å›ä¸€çš„æ¦‚ç‡ï¼Œ1-*p*æ˜¯è¿”å›é›¶çš„æ¦‚ç‡ã€‚
- en: 'More formally, we have that the decoder likelihood distribution <math alttext="p
    Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    can be rewritten as a product over each pixel:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´æ­£å¼åœ°ï¼Œæˆ‘ä»¬æœ‰è§£ç å™¨çš„ä¼¼ç„¶åˆ†å¸ƒ<math alttext="p Subscript theta Baseline left-parenthesis x
    vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>å¯ä»¥é‡å†™ä¸ºæ¯ä¸ªåƒç´ çš„ä¹˜ç§¯ï¼š
- en: <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z
    right-parenthesis equals product Underscript j equals 1 Overscript 784 Endscripts
    p Subscript theta Baseline left-parenthesis x Subscript j Baseline vertical-bar
    z right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>âˆ</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup> <msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>|</mo>
    <mi>z</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z
    right-parenthesis equals product Underscript j equals 1 Overscript 784 Endscripts
    p Subscript theta Baseline left-parenthesis x Subscript j Baseline vertical-bar
    z right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>âˆ</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup> <msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>|</mo>
    <mi>z</mi> <mo>)</mo></mrow></mrow></math>
- en: where <math alttext="p left-parenthesis x Subscript j Baseline vertical-bar
    z right-parenthesis equals upper B e r left-parenthesis decoder left-parenthesis
    z right-parenthesis Subscript j Baseline right-parenthesis"><mrow><mi>p</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mi>j</mi></msub> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>B</mi> <mi>e</mi> <mi>r</mi> <mrow><mo>(</mo> <mtext>decoder</mtext> <msub><mrow><mo>(</mo><mi>z</mi><mo>)</mo></mrow>
    <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­<math alttext="p left-parenthesis x Subscript j Baseline vertical-bar z right-parenthesis
    equals upper B e r left-parenthesis decoder left-parenthesis z right-parenthesis
    Subscript j Baseline right-parenthesis"><mrow><mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>j</mi></msub> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>B</mi>
    <mi>e</mi> <mi>r</mi> <mrow><mo>(</mo> <mtext>decoder</mtext> <msub><mrow><mo>(</mo><mi>z</mi><mo>)</mo></mrow>
    <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: Note that decoder(*z*) represents the 784-d vector after applying the sigmoid
    layer. For a given pixel <math alttext="x Subscript j Superscript left-parenthesis
    i right-parenthesis"><msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></math>
    in the input example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> , weâ€™d like its corresponding
    probability *p* to be close to one if <math alttext="x Subscript j Superscript
    left-parenthesis i right-parenthesis Baseline equals 1"><mrow><msubsup><mi>x</mi>
    <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>=</mo> <mn>1</mn></mrow></math>
    , and its corresponding probability *p* to be close to zero if <math alttext="x
    Subscript j Superscript left-parenthesis i right-parenthesis Baseline equals 0"><mrow><msubsup><mi>x</mi>
    <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>=</mo> <mn>0</mn></mrow></math>
    . As you may recall from the previous section, we work with <math alttext="log
    p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><mo
    form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> , which reduces to <math
    alttext="sigma-summation Underscript j equals 1 Overscript 784 Endscripts log
    p Subscript theta Baseline left-parenthesis x Subscript j Baseline vertical-bar
    z right-parenthesis"><mrow><msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mn>784</mn></msubsup> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œdecoder(*z*)è¡¨ç¤ºåº”ç”¨Sigmoidå±‚åçš„784ç»´å‘é‡ã€‚å¯¹äºè¾“å…¥ç¤ºä¾‹<math alttext="x Subscript j Superscript
    left-parenthesis i right-parenthesis"><msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></math>
    ä¸­çš„ç»™å®šåƒç´ <math alttext="x Subscript j Superscript left-parenthesis i right-parenthesis"><msubsup><mi>x</mi>
    <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></math> ï¼Œæˆ‘ä»¬å¸Œæœ›å…¶å¯¹åº”çš„æ¦‚ç‡*p*åœ¨<math
    alttext="x Subscript j Superscript left-parenthesis i right-parenthesis Baseline
    equals 1"><mrow><msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup>
    <mo>=</mo> <mn>1</mn></mrow></math>æ—¶æ¥è¿‘äº1ï¼Œè€Œåœ¨<math alttext="x Subscript j Superscript
    left-parenthesis i right-parenthesis Baseline equals 0"><mrow><msubsup><mi>x</mi>
    <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>=</mo> <mn>0</mn></mrow></math>æ—¶æ¥è¿‘äº0ã€‚æ­£å¦‚æ‚¨å¯èƒ½ä»ä¸Šä¸€èŠ‚ä¸­è®°å¾—çš„é‚£æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨<math
    alttext="log p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><mo
    form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> ï¼Œè¿™å¯ä»¥ç®€åŒ–ä¸º<math alttext="sigma-summation
    Underscript j equals 1 Overscript 784 Endscripts log p Subscript theta Baseline
    left-parenthesis x Subscript j Baseline vertical-bar z right-parenthesis"><mrow><msubsup><mo>âˆ‘</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> ã€‚
- en: 'Now, we can put the encoder and decoder together into a single VAE architecture:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç¼–ç å™¨å’Œè§£ç å™¨æ”¾åœ¨ä¸€èµ·ï¼Œæ„å»ºä¸€ä¸ªå•ä¸€çš„VAEæ¶æ„ï¼š
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The call to encode is followed by the call to decode in the forward function.
    Note that decode uses only a single sample from the approximate posterior, as
    we found that a single sample is sufficient for the MNIST dataset, but this can
    be easily modified to work for multiple samples. To calculate the reverse KL,
    the forward function returns the results of the encode call in addition to the
    decoder likelihood distribution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰å‘å‡½æ•°ä¸­ï¼Œå¯¹encodeçš„è°ƒç”¨åé¢æ˜¯å¯¹decodeçš„è°ƒç”¨ã€‚è¯·æ³¨æ„ï¼Œdecodeä»…ä½¿ç”¨æ¥è‡ªè¿‘ä¼¼åéªŒçš„å•ä¸ªæ ·æœ¬ï¼Œå› ä¸ºæˆ‘ä»¬å‘ç°å¯¹äºMNISTæ•°æ®é›†ï¼Œå•ä¸ªæ ·æœ¬å°±è¶³å¤Ÿäº†ï¼Œä½†è¿™å¯ä»¥å¾ˆå®¹æ˜“åœ°ä¿®æ”¹ä¸ºé€‚ç”¨äºå¤šä¸ªæ ·æœ¬ã€‚ä¸ºäº†è®¡ç®—åå‘KLæ•£åº¦ï¼Œå‰å‘å‡½æ•°è¿”å›äº†encodeè°ƒç”¨çš„ç»“æœä»¥åŠè§£ç å™¨çš„ä¼¼ç„¶åˆ†å¸ƒçš„ç»“æœã€‚
- en: 'Here is example code for computing the loss:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯è®¡ç®—æŸå¤±çš„ç¤ºä¾‹ä»£ç ï¼š
- en: '[PRE4]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We recommend you take a look at the PyTorch documentation for `nn.BCELoss`
    and verify that it is indeed computing the negative log likelihood of the input
    example <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> : <math alttext="minus
    sigma-summation Underscript j equals 1 Overscript 784 Endscripts log p Subscript
    theta Baseline left-parenthesis x Subscript j Superscript left-parenthesis i right-parenthesis
    Baseline vertical-bar z right-parenthesis"><mrow><mo>-</mo> <msubsup><mo>âˆ‘</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup> <mo form="prefix">log</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msubsup><mi>x</mi> <mi>j</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    . We also recommend you verify that the `kl_loss` term is the reverse KL divergence
    between two Gaussian distributions as derived in Kingma and Welling. Returning
    the sum of the negative log likelihood and the reverse KL divergence as a final
    loss term gets us to the end of step 6 from the previous section. Finally, for
    some training code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å»ºè®®æ‚¨æŸ¥çœ‹PyTorchæ–‡æ¡£ä¸­å…³äº`nn.BCELoss`çš„å†…å®¹ï¼Œå¹¶éªŒè¯å®ƒæ˜¯å¦ç¡®å®è®¡ç®—äº†è¾“å…¥ç¤ºä¾‹<math alttext="x Superscript
    left-parenthesis i right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>
    çš„è´Ÿå¯¹æ•°ä¼¼ç„¶ï¼š <math alttext="minus sigma-summation Underscript j equals 1 Overscript
    784 Endscripts log p Subscript theta Baseline left-parenthesis x Subscript j Superscript
    left-parenthesis i right-parenthesis Baseline vertical-bar z right-parenthesis"><mrow><mo>-</mo>
    <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>784</mn></msubsup>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup>
    <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math> ã€‚æˆ‘ä»¬è¿˜å»ºè®®æ‚¨éªŒè¯`kl_loss`é¡¹æ˜¯å¦æ˜¯Kingmaå’ŒWellingä¸­æ¨å¯¼çš„ä¸¤ä¸ªé«˜æ–¯åˆ†å¸ƒä¹‹é—´çš„åå‘KLæ•£åº¦ã€‚å°†è´Ÿå¯¹æ•°ä¼¼ç„¶å’Œåå‘KLæ•£åº¦çš„æ€»å’Œä½œä¸ºæœ€ç»ˆæŸå¤±é¡¹è¿”å›ï¼Œä½¿æˆ‘ä»¬è¾¾åˆ°äº†ä¸Šä¸€èŠ‚ä¸­ç¬¬6æ­¥çš„ç»“å°¾ã€‚æœ€åï¼Œä¸€äº›è®­ç»ƒä»£ç ï¼š
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we train the VAE for 10 epochs, saving the state of the VAE at the end
    of each epoch. Note that we set some hyperparameters fixed here, such as the learning
    rate of the optimizer and the number of latent variables. We recommend writing
    some validation code, in addition to the training code presented here, to select
    the best hyperparameter settings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è®­ç»ƒVAE 10ä¸ªepochsï¼Œä¿å­˜æ¯ä¸ªepochç»“æŸæ—¶çš„VAEçŠ¶æ€ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå›ºå®šäº†ä¸€äº›è¶…å‚æ•°ï¼Œæ¯”å¦‚ä¼˜åŒ–å™¨çš„å­¦ä¹ ç‡å’Œæ½œå˜é‡çš„æ•°é‡ã€‚æˆ‘ä»¬å»ºè®®ç¼–å†™ä¸€äº›éªŒè¯ä»£ç ï¼Œé™¤äº†è¿™é‡Œå‘ˆç°çš„è®­ç»ƒä»£ç ï¼Œä»¥é€‰æ‹©æœ€ä½³çš„è¶…å‚æ•°è®¾ç½®ã€‚
- en: 'Finally, how can we test the generative capabilities of our fully trained VAE?
    We know that the generative process can be written as *p(z)p(x|z),* where we first
    draw a sample <math alttext="z Subscript j"><msub><mi>z</mi> <mi>j</mi></msub></math>
    from our prior, run the sample through the decoder so the decoderâ€™s likelihood
    distribution now represents <math alttext="p Subscript theta Baseline left-parenthesis
    x vertical-bar z equals z Subscript j Baseline right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo>
    <msub><mi>z</mi> <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math> , and sample
    <math alttext="x Subscript j"><msub><mi>x</mi> <mi>j</mi></msub></math> from this
    distribution. Here is the code that puts this logic into action:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬å¦‚ä½•æµ‹è¯•æˆ‘ä»¬å®Œå…¨è®­ç»ƒçš„VAEçš„ç”Ÿæˆèƒ½åŠ›ï¼Ÿæˆ‘ä»¬çŸ¥é“ç”Ÿæˆè¿‡ç¨‹å¯ä»¥å†™æˆ*p(z)p(x|z)*ï¼Œå…¶ä¸­æˆ‘ä»¬é¦–å…ˆä»å…ˆéªŒä¸­æŠ½å–ä¸€ä¸ªæ ·æœ¬<math alttext="z
    Subscript j"><msub><mi>z</mi> <mi>j</mi></msub></math>ï¼Œå°†æ ·æœ¬é€šè¿‡è§£ç å™¨è¿è¡Œï¼Œä½¿è§£ç å™¨çš„ä¼¼ç„¶åˆ†å¸ƒç°åœ¨è¡¨ç¤ºä¸º<math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z equals z
    Subscript j Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow></mrow></math>ï¼Œç„¶åä»è¯¥åˆ†å¸ƒä¸­æŠ½å–<math alttext="x Subscript
    j"><msub><mi>x</mi> <mi>j</mi></msub></math>ã€‚ä»¥ä¸‹æ˜¯å°†æ­¤é€»è¾‘ä»˜è¯¸å®è·µçš„ä»£ç ï¼š
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `for` loop generates 100 samples from the approximate posterior, and for
    each of those samples, a sample from the corresponding decoder likelihood distribution
    over the input data. The last couple of lines of code allow us to save the samples
    in a 10 Ã— 10 grid, depicted in [FigureÂ 10-6](#hundred_samples_from_a_vae_trained_on_the_mnist_dataset).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`å¾ªç¯ä»è¿‘ä¼¼åéªŒä¸­ç”Ÿæˆ100ä¸ªæ ·æœ¬ï¼Œå¯¹äºæ¯ä¸ªæ ·æœ¬ï¼Œä»ç›¸åº”çš„è§£ç å™¨ä¼¼ç„¶åˆ†å¸ƒä¸­æŠ½å–è¾“å…¥æ•°æ®çš„æ ·æœ¬ã€‚ä»£ç çš„æœ€åå‡ è¡Œå…è®¸æˆ‘ä»¬å°†æ ·æœ¬ä¿å­˜åœ¨ä¸€ä¸ª10Ã—10çš„ç½‘æ ¼ä¸­ï¼Œå¦‚[å›¾10-6](#hundred_samples_from_a_vae_trained_on_the_mnist_dataset)æ‰€ç¤ºã€‚'
- en: '![](Images/fdl2_1006.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1006.png)'
- en: Figure 10-6\. 100 samples from a VAE trained on the MNIST dataset for 10 epochs.
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾10-6. åœ¨MNISTæ•°æ®é›†ä¸Šè®­ç»ƒçš„VAEç”Ÿæˆçš„100ä¸ªæ ·æœ¬ï¼Œè®­ç»ƒäº†10ä¸ªepochsã€‚
- en: Though the images are a bit blurry, we can make out digits in most of the samples.
    With more complex architectures such as RNNs, hyperparameter tuning, and longer
    training times, we will surely see even better results. In the next section, we
    introduce a slightly different take on generative models that has recently been
    achieving popularity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å›¾åƒæœ‰ç‚¹æ¨¡ç³Šï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥çœ‹å‡ºå¤§å¤šæ•°æ ·æœ¬ä¸­çš„æ•°å­—ã€‚é€šè¿‡ä½¿ç”¨æ›´å¤æ‚çš„æ¶æ„ï¼Œå¦‚RNNã€è¶…å‚æ•°è°ƒæ•´å’Œæ›´é•¿çš„è®­ç»ƒæ—¶é—´ï¼Œæˆ‘ä»¬è‚¯å®šä¼šçœ‹åˆ°æ›´å¥½çš„ç»“æœã€‚åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»ä¸€ç§ç•¥æœ‰ä¸åŒçš„ç”Ÿæˆæ¨¡å‹æ–¹æ³•ï¼Œæœ€è¿‘è¶Šæ¥è¶Šå—æ¬¢è¿ã€‚
- en: Score-Based Generative Models
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åŸºäºåˆ†æ•°çš„ç”Ÿæˆæ¨¡å‹
- en: In this section, we approach generative modeling through a slightly different
    lens than what we have encountered so far. In an optimally trained GAN, we first
    sample from some noise distribution *p(z)* and run this sample <math alttext="z
    Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math> through a generator *G,*
    which deterministically transforms <math alttext="z Subscript i"><msub><mi>z</mi>
    <mi>i</mi></msub></math> into a sample <math alttext="x Subscript i"><msub><mi>x</mi>
    <mi>i</mi></msub></math> from the true data distribution (where we approximate
    the true data distribution *p(x)* using our dataset, <math alttext="p Subscript
    data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mtext>data</mtext></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> ). Though *G* itself
    is a deterministic function, *G(z)* is a random variable distributed as the true
    data distribution. In summary, we have implicitly defined a distribution over
    our domain via the generatorâ€™s action on samples from *p(z)*, and a way of sampling
    from the true data distribution via a simpler distribution *p(z)*, such as a multivariate
    Gaussian distribution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç•¥æœ‰ä¸åŒçš„è§†è§’æ¥æ¥è¿‘ç”Ÿæˆå»ºæ¨¡ï¼Œè¿™ä¸æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢é‡åˆ°çš„æƒ…å†µæœ‰æ‰€ä¸åŒã€‚åœ¨ç»è¿‡æœ€ä½³è®­ç»ƒçš„GANä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆä»ä¸€äº›å™ªå£°åˆ†å¸ƒ*p(z)*ä¸­æŠ½æ ·ï¼Œç„¶åå°†è¿™ä¸ªæ ·æœ¬<math
    alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>é€šè¿‡ä¸€ä¸ªç”Ÿæˆå™¨*G*ï¼Œå°†<math
    alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>ç¡®å®šæ€§åœ°è½¬æ¢ä¸ºä¸€ä¸ªæ ·æœ¬<math
    alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>ï¼Œè¿™ä¸ªæ ·æœ¬æ¥è‡ªçœŸå®æ•°æ®åˆ†å¸ƒï¼ˆæˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬çš„æ•°æ®é›†è¿‘ä¼¼çœŸå®æ•°æ®åˆ†å¸ƒ*p(x)*ï¼Œ<math
    alttext="p Subscript data Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mtext>data</mtext></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼‰ã€‚è™½ç„¶*G*æœ¬èº«æ˜¯ä¸€ä¸ªç¡®å®šæ€§å‡½æ•°ï¼Œ*G(z)*æ˜¯ä¸€ä¸ªéšæœºå˜é‡ï¼Œå…¶åˆ†å¸ƒä¸çœŸå®æ•°æ®åˆ†å¸ƒç›¸åŒã€‚æ€»ä¹‹ï¼Œæˆ‘ä»¬é€šè¿‡ç”Ÿæˆå™¨å¯¹*p(z)*ä¸­çš„æ ·æœ¬çš„æ“ä½œéšå¼åœ°å®šä¹‰äº†æˆ‘ä»¬åŸŸä¸Šçš„åˆ†å¸ƒï¼Œä»¥åŠé€šè¿‡ä¸€ä¸ªç®€å•çš„åˆ†å¸ƒ*p(z)*ï¼ˆå¦‚å¤šå…ƒé«˜æ–¯åˆ†å¸ƒï¼‰ä»çœŸå®æ•°æ®åˆ†å¸ƒä¸­æŠ½æ ·çš„æ–¹æ³•ã€‚
- en: VAEs are more explicit in their probabilistic modeling. We define *z* to be
    a set of latent variables that generate the data we see, *x.* We explicitly learn
    a conditional distribution over the data <math alttext="p Subscript theta Baseline
    left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    via the decoder, which we can sample from. In an optimally trained VAE, <math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis
    equals p left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>
    , is the true conditional likelihood of the data. To generate data using an optimally
    trained VAE, we first sample a setting of the latent variables from *p(z)* and
    run this sample <math alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>
    through the decoder, which now parametrizes the distribution <math alttext="p
    left-parenthesis x vertical-bar z equals z Subscript i Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>i</mi></msub>
    <mo>)</mo></mrow></math> . This is an explicit probability distribution we can
    now sample from.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: VAEsåœ¨å…¶æ¦‚ç‡å»ºæ¨¡æ–¹é¢æ›´ä¸ºæ˜ç¡®ã€‚æˆ‘ä»¬å®šä¹‰*z*ä¸ºç”Ÿæˆæˆ‘ä»¬çœ‹åˆ°çš„æ•°æ®*x*çš„ä¸€ç»„æ½œåœ¨å˜é‡ã€‚æˆ‘ä»¬æ˜ç¡®åœ°å­¦ä¹ æ•°æ®çš„æ¡ä»¶åˆ†å¸ƒ<math alttext="p
    Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>é€šè¿‡è§£ç å™¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸­æŠ½æ ·ã€‚åœ¨ç»è¿‡æœ€ä½³è®­ç»ƒçš„VAEä¸­ï¼Œ<math
    alttext="p Subscript theta Baseline left-parenthesis x vertical-bar z right-parenthesis
    equals p left-parenthesis x vertical-bar z right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>)</mo></mrow></mrow></math>ï¼Œæ˜¯æ•°æ®çš„çœŸå®æ¡ä»¶æ¦‚ç‡ã€‚è¦ä½¿ç”¨ç»è¿‡æœ€ä½³è®­ç»ƒçš„VAEç”Ÿæˆæ•°æ®ï¼Œæˆ‘ä»¬é¦–å…ˆä»*p(z)*ä¸­æŠ½æ ·ä¸€ç»„æ½œåœ¨å˜é‡çš„è®¾ç½®ï¼Œç„¶åå°†è¿™ä¸ªæ ·æœ¬<math
    alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>é€šè¿‡è§£ç å™¨è¿è¡Œï¼Œè§£ç å™¨ç°åœ¨å‚æ•°åŒ–äº†åˆ†å¸ƒ<math
    alttext="p left-parenthesis x vertical-bar z equals z Subscript i Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>z</mi> <mo>=</mo> <msub><mi>z</mi> <mi>i</mi></msub>
    <mo>)</mo></mrow></math>ã€‚è¿™æ˜¯ä¸€ä¸ªæ˜ç¡®çš„æ¦‚ç‡åˆ†å¸ƒï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥ä»ä¸­æŠ½æ ·ã€‚
- en: Note that although GANs and VAEs themselves are quite distinct, both of their
    architectures and actions involve an additional distribution *p(z) (*whether that
    is a noise distribution in GANs or a prior over latent variables in VAEs). Is
    there a way of sampling from the true data distribution without the additional
    distribution? Score-based generative models attempt to do just that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œå°½ç®¡GANå’ŒVAEæœ¬èº«æ˜¯éå¸¸ä¸åŒçš„ï¼Œä½†å®ƒä»¬çš„æ¶æ„å’Œæ“ä½œéƒ½æ¶‰åŠåˆ°ä¸€ä¸ªé¢å¤–çš„åˆ†å¸ƒ*p(z)*ï¼ˆæ— è®ºæ˜¯GANä¸­çš„å™ªå£°åˆ†å¸ƒè¿˜æ˜¯VAEä¸­æ½œåœ¨å˜é‡çš„å…ˆéªŒï¼‰ã€‚æœ‰æ²¡æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥ä»çœŸå®æ•°æ®åˆ†å¸ƒä¸­æŠ½æ ·è€Œä¸éœ€è¦é¢å¤–çš„åˆ†å¸ƒï¼ŸåŸºäºåˆ†æ•°çš„ç”Ÿæˆæ¨¡å‹è¯•å›¾åšåˆ°è¿™ä¸€ç‚¹ã€‚
- en: One method of sampling from a probability distribution is an iterative process
    called *Langevin dynamics.* This process is actually an instance of a class of
    algorithms referred to as *Markov Chain Monte Carlo (MCMC)* algorithms. Motivating
    MCMC algorithms and proving why they sample from probability distributions in
    an unbiased manner are beyond the scope of this section, but we refer you to the
    vast amount of academic literature that exists on this topic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ¦‚ç‡åˆ†å¸ƒä¸­æŠ½æ ·çš„ä¸€ç§æ–¹æ³•æ˜¯ä¸€ç§ç§°ä¸º*LangevinåŠ¨åŠ›å­¦*çš„è¿­ä»£è¿‡ç¨‹ã€‚è¿™ä¸ªè¿‡ç¨‹å®é™…ä¸Šæ˜¯ä¸€ç±»ç®—æ³•çš„ä¸€ä¸ªå®ä¾‹ï¼Œè¢«ç§°ä¸º*é©¬å°”å¯å¤«é“¾è’™ç‰¹å¡ç½—ï¼ˆMCMCï¼‰*ç®—æ³•ã€‚æ¿€åŠ±MCMCç®—æ³•å¹¶è¯æ˜å®ƒä»¬ä»¥æ— åçš„æ–¹å¼ä»æ¦‚ç‡åˆ†å¸ƒä¸­æŠ½æ ·è¶…å‡ºäº†æœ¬èŠ‚çš„èŒƒå›´ï¼Œä½†æˆ‘ä»¬å»ºè®®æ‚¨å‚è€ƒå…³äºè¿™ä¸ªä¸»é¢˜çš„å¤§é‡å­¦æœ¯æ–‡çŒ®ã€‚
- en: 'Langevin dynamics follows the process defined as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: LangevinåŠ¨åŠ›å­¦éµå¾ªä»¥ä¸‹å®šä¹‰çš„è¿‡ç¨‹ï¼š
- en: <math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis Baseline
    equals x Superscript left-parenthesis i right-parenthesis Baseline plus eta normal
    nabla Subscript x Baseline log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis plus StartRoot 2 eta EndRoot epsilon
    comma epsilon tilde upper N left-parenthesis 0 comma upper I right-parenthesis"><mrow><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup> <mo>=</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>+</mo>
    <mi>Î·</mi> <msub><mi>âˆ‡</mi> <mi>x</mi></msub> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>+</mo> <msqrt><mrow><mn>2</mn> <mi>Î·</mi></mrow></msqrt>
    <mi>Ïµ</mi> <mo>,</mo> <mi>Ïµ</mi> <mo>âˆ¼</mo> <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mi>I</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis Baseline
    equals x Superscript left-parenthesis i right-parenthesis Baseline plus eta normal
    nabla Subscript x Baseline log p left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis plus StartRoot 2 eta EndRoot epsilon
    comma epsilon tilde upper N left-parenthesis 0 comma upper I right-parenthesis"><mrow><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup> <mo>=</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>+</mo>
    <mi>Î·</mi> <msub><mi>âˆ‡</mi> <mi>x</mi></msub> <mo form="prefix">log</mo> <mi>p</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>+</mo> <msqrt><mrow><mn>2</mn> <mi>Î·</mi></mrow></msqrt>
    <mi>Ïµ</mi> <mo>,</mo> <mi>Ïµ</mi> <mo>âˆ¼</mo> <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mi>I</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> here represents a sample
    from *p(x),* and this dynamics equation shows us how to generate the next sample
    <math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    given our current sample.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œè¡¨ç¤ºä»*p(x)*ä¸­æŠ½å–çš„æ ·æœ¬ï¼Œè¿™ä¸ªåŠ¨æ€æ–¹ç¨‹å‘æˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•ç”Ÿæˆä¸‹ä¸€ä¸ªæ ·æœ¬<math alttext="x Superscript left-parenthesis
    i plus 1 right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>ï¼Œç»™å®šæˆ‘ä»¬å½“å‰çš„æ ·æœ¬ã€‚
- en: Note that if we were to remove the Gaussian noise component at the end of the
    dynamics equation, we would just be following the gradient to a maximum of *p(x),*
    i.e., performing gradient ascent with some step-size <math alttext="eta"><mi>Î·</mi></math>
    . The intuition behind this dynamics equation is that the addition of the noise
    component prevents us from simply reaching the maximum *x* and instead allows
    us to explore regions with high probability, thereby exploring regions of low
    probability less ([FigureÂ 10-7](#fig1007)). Again, why this produces samples from
    *p(x)* in an unbiased manner is beyond the scope of this text, but we highly encourage
    you to learn more from the academic literature.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬åœ¨åŠ¨æ€æ–¹ç¨‹çš„æœ«å°¾å»é™¤é«˜æ–¯å™ªå£°æˆåˆ†ï¼Œæˆ‘ä»¬å°†åªæ˜¯æ²¿ç€*p(x)*çš„æ¢¯åº¦å‘æœ€å¤§å€¼ç§»åŠ¨ï¼Œå³ï¼Œä½¿ç”¨ä¸€äº›æ­¥é•¿<math alttext="eta"><mi>Î·</mi></math>æ‰§è¡Œæ¢¯åº¦ä¸Šå‡ã€‚è¿™ä¸ªåŠ¨æ€æ–¹ç¨‹èƒŒåçš„ç›´è§‰æ˜¯ï¼Œå™ªå£°æˆåˆ†çš„æ·»åŠ é˜»æ­¢æˆ‘ä»¬ç®€å•åœ°åˆ°è¾¾æœ€å¤§å€¼*x*ï¼Œè€Œæ˜¯å…è®¸æˆ‘ä»¬æ¢ç´¢é«˜æ¦‚ç‡åŒºåŸŸï¼Œä»è€Œæ¢ç´¢ä½æ¦‚ç‡åŒºåŸŸè¾ƒå°‘ï¼ˆ[å›¾10-7](#fig1007)ï¼‰ã€‚å†æ¬¡å¼ºè°ƒï¼Œä¸ºä»€ä¹ˆè¿™ç§æ–¹å¼ä»¥æ— åçš„æ–¹å¼äº§ç”Ÿ*p(x)*çš„æ ·æœ¬è¶…å‡ºäº†æœ¬æ–‡çš„èŒƒå›´ï¼Œä½†æˆ‘ä»¬å¼ºçƒˆé¼“åŠ±æ‚¨ä»å­¦æœ¯æ–‡çŒ®ä¸­äº†è§£æ›´å¤šã€‚
- en: '![](Images/fdl2_1007.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1007.png)'
- en: Figure 10-7\. We use f here to represent a Gaussian distribution with mean (and
    also maximum) at the origin. Each of the contours represents locations with equal
    likelihood. As we can see from the diagram, the gradient points directly toward
    the maximum, but adding a bit of noise allows us to explore and sample from high-density
    regions without converging to the maximum.
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾10-7ã€‚è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨*f*æ¥è¡¨ç¤ºä¸€ä¸ªå‡å€¼ï¼ˆä¹Ÿæ˜¯æœ€å¤§å€¼ï¼‰åœ¨åŸç‚¹çš„é«˜æ–¯åˆ†å¸ƒã€‚æ¯ä¸ªç­‰é«˜çº¿ä»£è¡¨å…·æœ‰ç›¸ç­‰æ¦‚ç‡çš„ä½ç½®ã€‚ä»å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œæ¢¯åº¦ç›´æ¥æŒ‡å‘æœ€å¤§å€¼ï¼Œä½†æ·»åŠ ä¸€ç‚¹å™ªå£°ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ¢ç´¢å’Œä»é«˜å¯†åº¦åŒºåŸŸä¸­æŠ½æ ·ï¼Œè€Œä¸ä¼šæ”¶æ•›åˆ°æœ€å¤§å€¼ã€‚
- en: Although we use the gradient of the log probability instead of the gradient
    of the probability, the value(s) of *x* that maximizes <math alttext="log p left-parenthesis
    x right-parenthesis"><mrow><mo form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></math> is the same as the value(s) of *x* that maximizes *p(x)*
    due to the logâ€™s concaveness. More generally, the logâ€™s concaveness also preserves
    the ordering relationships between all possible values of *x,* i.e., if <math
    alttext="p left-parenthesis x 1 right-parenthesis greater-than-or-equal-to p left-parenthesis
    x 2 right-parenthesis"><mrow><mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>â‰¥</mo> <mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></mrow></math> , then <math alttext="log p left-parenthesis x
    1 right-parenthesis greater-than-or-equal-to log p left-parenthesis x 2 right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>â‰¥</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></mrow></math> , and vice
    versa. For that reason, as we saw in [â€œImplementing a VAEâ€](#vae-sect), these
    sorts of optimization processes tend to not be affected meaningfully by the inclusion
    of the log.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡æˆ‘ä»¬ä½¿ç”¨å¯¹æ•°æ¦‚ç‡çš„æ¢¯åº¦è€Œä¸æ˜¯æ¦‚ç‡çš„æ¢¯åº¦ï¼Œä½†æœ€å¤§åŒ– <math alttext="log p left-parenthesis x right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    çš„å€¼ä¸æœ€å¤§åŒ– *p(x)* çš„å€¼ç›¸åŒï¼Œå› ä¸ºå¯¹æ•°çš„å‡¹æ€§ã€‚æ›´ä¸€èˆ¬åœ°ï¼Œå¯¹æ•°çš„å‡¹æ€§ä¹Ÿä¿ç•™äº†æ‰€æœ‰å¯èƒ½çš„ *x* å€¼ä¹‹é—´çš„é¡ºåºå…³ç³»ï¼Œå³ï¼Œå¦‚æœ <math alttext="p
    left-parenthesis x 1 right-parenthesis greater-than-or-equal-to p left-parenthesis
    x 2 right-parenthesis"><mrow><mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>â‰¥</mo> <mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></mrow></math>ï¼Œé‚£ä¹ˆ <math alttext="log p left-parenthesis x 1 right-parenthesis
    greater-than-or-equal-to log p left-parenthesis x 2 right-parenthesis"><mrow><mo
    form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>â‰¥</mo> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></mrow></math>ï¼Œåä¹‹äº¦ç„¶ã€‚å› æ­¤ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨[â€œå®ç°VAEâ€](#vae-sect)ä¸­çœ‹åˆ°çš„é‚£æ ·ï¼Œè¿™äº›ä¼˜åŒ–è¿‡ç¨‹å¾€å¾€ä¸ä¼šå—åˆ°å¯¹æ•°çš„å½±å“ã€‚
- en: However, the main issue with Langevin dynamics, as weâ€™ve encountered before
    with other generative models, is that we donâ€™t know *p(x),* let alone the gradient
    of its log! But there may be a way to model <math alttext="normal nabla Subscript
    x Baseline log p left-parenthesis x right-parenthesis"><mrow><msub><mi>âˆ‡</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math> , which we call <math alttext="p left-parenthesis
    x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    â€™s *score function*, directly. This would allow us to simply plug the score directly
    into the Langevin dynamics equation and draw samples from *p(x)* as if we knew
    *p(x)* all along. This is the idea of score-based generative modeling.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä¸LangevinåŠ¨åŠ›å­¦çš„ä¸»è¦é—®é¢˜ï¼Œæ­£å¦‚æˆ‘ä»¬ä¹‹å‰åœ¨å…¶ä»–ç”Ÿæˆæ¨¡å‹ä¸­é‡åˆ°çš„é‚£æ ·ï¼Œæˆ‘ä»¬ä¸çŸ¥é“ *p(x)*ï¼Œæ›´ä¸ç”¨è¯´å…¶å¯¹æ•°çš„æ¢¯åº¦äº†ï¼ä½†ä¹Ÿè®¸æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥å¯¹
    <math alttext="normal nabla Subscript x Baseline log p left-parenthesis x right-parenthesis"><mrow><msub><mi>âˆ‡</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math>ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> çš„*åˆ†æ•°å‡½æ•°*ï¼Œè¿›è¡Œå»ºæ¨¡ã€‚è¿™å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿå°†åˆ†æ•°ç›´æ¥æ’å…¥LangevinåŠ¨åŠ›å­¦æ–¹ç¨‹ï¼Œå¹¶ä»
    *p(x)* ä¸­æŠ½æ ·ï¼Œå°±å¥½åƒæˆ‘ä»¬ä¸€ç›´çŸ¥é“ *p(x)* ä¸€æ ·ã€‚è¿™å°±æ˜¯åŸºäºåˆ†æ•°çš„ç”Ÿæˆå»ºæ¨¡çš„æƒ³æ³•ã€‚
- en: For a moment, letâ€™s forget the problem of sampling from an unknown distribution
    *p(x)* and instead consider the problem of learning *p(x)*. From now until the
    end of this section, we will consider only the problems of learning and sampling
    from continuous probability distributions. In the same vein of explicitly learning
    approximate probability distributions like in VAEs, we can try to approximate
    *p(x)* with a learned version <math alttext="p Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> , where <math alttext="theta"><mi>Î¸</mi></math>
    represents the parameters of the learned model. What we envision is a learned
    function, such as a neural network, that takes as input an example *x* and outputs
    a likelihood <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    . However, there is no way to ensure that <math alttext="integral p Subscript
    theta Baseline left-parenthesis x right-parenthesis d x equals 1"><mrow><mo>âˆ«</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>1</mn></mrow></math> , which is a necessary
    condition of any probability distribution.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: æš‚æ—¶å¿˜è®°ä»æœªçŸ¥åˆ†å¸ƒ *p(x)* ä¸­æŠ½æ ·çš„é—®é¢˜ï¼Œè€Œæ˜¯è€ƒè™‘å­¦ä¹  *p(x)* çš„é—®é¢˜ã€‚ä»ç°åœ¨åˆ°æœ¬èŠ‚ç»“æŸï¼Œæˆ‘ä»¬å°†åªè€ƒè™‘å­¦ä¹ å’Œä»è¿ç»­æ¦‚ç‡åˆ†å¸ƒä¸­æŠ½æ ·çš„é—®é¢˜ã€‚ä¸æ˜¾å¼å­¦ä¹ è¿‘ä¼¼æ¦‚ç‡åˆ†å¸ƒçš„VAEç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•ç”¨å­¦ä¹ ç‰ˆæœ¬
    <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    æ¥è¿‘ä¼¼ *p(x)*ï¼Œå…¶ä¸­ <math alttext="theta"><mi>Î¸</mi></math> è¡¨ç¤ºå­¦ä¹ æ¨¡å‹çš„å‚æ•°ã€‚æˆ‘ä»¬è®¾æƒ³çš„æ˜¯ä¸€ä¸ªå­¦ä¹ å‡½æ•°ï¼Œæ¯”å¦‚ä¸€ä¸ªç¥ç»ç½‘ç»œï¼Œå®ƒä»¥ç¤ºä¾‹
    *x* ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¾“å‡ºä¸€ä¸ªä¼¼ç„¶åº¦ <math alttext="p Subscript theta Baseline left-parenthesis x
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math>ã€‚ç„¶è€Œï¼Œæ²¡æœ‰åŠæ³•ç¡®ä¿ <math alttext="integral p Subscript
    theta Baseline left-parenthesis x right-parenthesis d x equals 1"><mrow><mo>âˆ«</mo>
    <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>1</mn></mrow></math>ï¼Œè¿™æ˜¯ä»»ä½•æ¦‚ç‡åˆ†å¸ƒçš„å¿…è¦æ¡ä»¶ã€‚
- en: Instead, we settle for learning what we call an unnormalized probability distribution
    <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    . This is a function that takes an example *x* and outputs an unnormalized likelihood.
    We can, in theory, represent the normalized probability distribution <math alttext="p
    Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    via <math alttext="StartFraction q Subscript theta Baseline left-parenthesis x
    right-parenthesis Over upper Z left-parenthesis theta right-parenthesis EndFraction"><mfrac><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mi>Z</mi><mo>(</mo><mi>Î¸</mi><mo>)</mo></mrow></mfrac></math>
    , where <math alttext="upper Z left-parenthesis theta right-parenthesis equals
    integral q Subscript theta Baseline left-parenthesis x right-parenthesis d x"><mrow><mi>Z</mi>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <mo>âˆ«</mo> <msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>
    . Unfortunately, this integral is generally intractable and has no closed form
    solution. Of course, there are exceptions to the rule. For example, <math alttext="upper
    Z left-parenthesis theta right-parenthesis equals sigma asterisk StartRoot 2 pi
    EndRoot"><mrow><mi>Z</mi> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>Ïƒ</mi> <mo>*</mo> <msqrt><mrow><mn>2</mn> <mi>Ï€</mi></mrow></msqrt></mrow></math>
    for a univariate Gaussian distribution, where <math alttext="theta equals left-parenthesis
    mu comma sigma right-parenthesis"><mrow><mi>Î¸</mi> <mo>=</mo> <mo>(</mo> <mi>Î¼</mi>
    <mo>,</mo> <mi>Ïƒ</mi> <mo>)</mo></mrow></math> are the mean and standard deviation
    of the Gaussian. But if weâ€™d like to model more expressive distributions via a
    neural network, for example, it is almost always impossible to tractably calculate
    <math alttext="upper Z left-parenthesis theta right-parenthesis"><mrow><mi>Z</mi>
    <mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></math> , which we will also refer to as
    the *partition function.*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œæˆ‘ä»¬åªèƒ½å­¦ä¹ æˆ‘ä»¬ç§°ä¹‹ä¸ºéå½’ä¸€åŒ–æ¦‚ç‡åˆ†å¸ƒçš„å‡½æ•° <math alttext="q Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>ã€‚è¿™æ˜¯ä¸€ä¸ªæ¥å—ä¸€ä¸ªç¤ºä¾‹ *x* å¹¶è¾“å‡ºéå½’ä¸€åŒ–å¯èƒ½æ€§çš„å‡½æ•°ã€‚ç†è®ºä¸Šï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡
    <math alttext="StartFraction q Subscript theta Baseline left-parenthesis x right-parenthesis
    Over upper Z left-parenthesis theta right-parenthesis EndFraction"><mfrac><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mi>Z</mi><mo>(</mo><mi>Î¸</mi><mo>)</mo></mrow></mfrac></math>
    æ¥è¡¨ç¤ºå½’ä¸€åŒ–æ¦‚ç‡åˆ†å¸ƒ <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼Œå…¶ä¸­
    <math alttext="upper Z left-parenthesis theta right-parenthesis equals integral
    q Subscript theta Baseline left-parenthesis x right-parenthesis d x"><mrow><mi>Z</mi>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <mo>âˆ«</mo> <msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ªç§¯åˆ†é€šå¸¸æ˜¯éš¾ä»¥å¤„ç†çš„ï¼Œæ²¡æœ‰é—­åˆå½¢å¼çš„è§£ã€‚å½“ç„¶ï¼Œä¹Ÿæœ‰ä¾‹å¤–ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸€å…ƒé«˜æ–¯åˆ†å¸ƒï¼Œ<math
    alttext="upper Z left-parenthesis theta right-parenthesis equals sigma asterisk
    StartRoot 2 pi EndRoot"><mrow><mi>Z</mi> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>Ïƒ</mi> <mo>*</mo> <msqrt><mrow><mn>2</mn> <mi>Ï€</mi></mrow></msqrt></mrow></math>ï¼Œå…¶ä¸­
    <math alttext="theta equals left-parenthesis mu comma sigma right-parenthesis"><mrow><mi>Î¸</mi>
    <mo>=</mo> <mo>(</mo> <mi>Î¼</mi> <mo>,</mo> <mi>Ïƒ</mi> <mo>)</mo></mrow></math>
    æ˜¯é«˜æ–¯åˆ†å¸ƒçš„å‡å€¼å’Œæ ‡å‡†å·®ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æƒ³é€šè¿‡ç¥ç»ç½‘ç»œæ¥å»ºæ¨¡æ›´å…·è¡¨ç°åŠ›çš„åˆ†å¸ƒï¼Œå‡ ä¹æ€»æ˜¯ä¸å¯èƒ½å¯é åœ°è®¡ç®— <math alttext="upper Z left-parenthesis
    theta right-parenthesis"><mrow><mi>Z</mi> <mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></math>ï¼Œæˆ‘ä»¬ä¹Ÿå°†å…¶ç§°ä¸º*åˆ†åŒºå‡½æ•°*ã€‚
- en: How can we go about learning such an unnormalized probability distribution?
    Researchers have presented many approaches for learning <math alttext="q Subscript
    theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> throughout the history
    of machine learning and inference, but one particular method starts to bridge
    the gap between learning an unnormalized probability distribution and sampling
    from its normalized version via a process like Langevin dynamics. *Score matching*,
    or the idea of learning <math alttext="q Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> via minimizing the difference between
    the score function of <math alttext="q Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> and the score function of the true
    distribution <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> , was first proposed by Hyvarinen
    in 2005.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•å­¦ä¹ è¿™æ ·ä¸€ä¸ªéå½’ä¸€åŒ–æ¦‚ç‡åˆ†å¸ƒï¼Ÿç ”ç©¶äººå‘˜åœ¨æœºå™¨å­¦ä¹ å’Œæ¨ç†çš„å†å²ä¸Šæå‡ºäº†è®¸å¤šå­¦ä¹  <math alttext="q Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> çš„æ–¹æ³•ï¼Œä½†ä¸€ç§ç‰¹å®šçš„æ–¹æ³•å¼€å§‹å¼¥åˆå­¦ä¹ éå½’ä¸€åŒ–æ¦‚ç‡åˆ†å¸ƒå’Œä»å…¶å½’ä¸€åŒ–ç‰ˆæœ¬ä¸­æŠ½æ ·ä¹‹é—´çš„å·®è·ï¼Œæ¯”å¦‚é€šè¿‡ç±»ä¼¼LangevinåŠ¨åŠ›å­¦çš„è¿‡ç¨‹ã€‚*åˆ†æ•°åŒ¹é…*ï¼Œæˆ–è€…å­¦ä¹ 
    <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    çš„æƒ³æ³•é€šè¿‡æœ€å°åŒ– <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    çš„å¾—åˆ†å‡½æ•°ä¸çœŸå®åˆ†å¸ƒ <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> çš„å¾—åˆ†å‡½æ•°ä¹‹é—´çš„å·®å¼‚ï¼Œæœ€åˆç”±Hyvarinenåœ¨2005å¹´æå‡ºã€‚
- en: Here, we show that minimizing the difference as stated is equivalent to minimizing
    the difference between the score function of <math alttext="p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> and the score function
    of <math alttext="p left-parenthesis x right-parenthesis colon"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>:</mo></mrow></math>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å±•ç¤ºäº†å°†å·®å¼‚æœ€å°åŒ–ç­‰åŒäºæœ€å°åŒ–<math alttext="p Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>çš„å¾—åˆ†å‡½æ•°å’Œ<math alttext="p left-parenthesis
    x right-parenthesis colon"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>:</mo></mrow></math>çš„å¾—åˆ†å‡½æ•°ä¹‹é—´çš„å·®å¼‚ã€‚
- en: <math alttext="normal nabla Subscript x Baseline log q Subscript theta Baseline
    left-parenthesis x right-parenthesis equals normal nabla Subscript x Baseline
    log left-parenthesis p Subscript theta Baseline left-parenthesis x right-parenthesis
    asterisk upper Z left-parenthesis theta right-parenthesis right-parenthesis"><mrow><msub><mi>âˆ‡</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>âˆ‡</mi> <mi>x</mi></msub>
    <mo form="prefix">log</mo> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>*</mo> <mi>Z</mi> <mrow><mo>(</mo>
    <mi>Î¸</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript x Baseline log q Subscript theta Baseline
    left-parenthesis x right-parenthesis equals normal nabla Subscript x Baseline
    log left-parenthesis p Subscript theta Baseline left-parenthesis x right-parenthesis
    asterisk upper Z left-parenthesis theta right-parenthesis right-parenthesis"><mrow><msub><mi>âˆ‡</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>q</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>âˆ‡</mi> <mi>x</mi></msub>
    <mo form="prefix">log</mo> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>*</mo> <mi>Z</mi> <mrow><mo>(</mo>
    <mi>Î¸</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript x Baseline log p Subscript theta
    Baseline left-parenthesis x right-parenthesis plus normal nabla Subscript x Baseline
    log upper Z left-parenthesis theta right-parenthesis"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>âˆ‡</mi> <mi>x</mi></msub>
    <mo form="prefix">log</mo> <mi>Z</mi> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript x Baseline log p Subscript theta
    Baseline left-parenthesis x right-parenthesis plus normal nabla Subscript x Baseline
    log upper Z left-parenthesis theta right-parenthesis"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>âˆ‡</mi> <mi>x</mi></msub>
    <mo form="prefix">log</mo> <mi>Z</mi> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript x Baseline log p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript x Baseline log p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><mo>=</mo> <msub><mi>âˆ‡</mi>
    <mi>x</mi></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: It turns out that the score function of <math alttext="q Subscript theta Baseline
    left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> is the same as the
    score function of <math alttext="p Subscript theta Baseline left-parenthesis x
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math> , <math alttext="for-all x"><mrow><mo>âˆ€</mo> <mi>x</mi></mrow></math>
    . This is because the log first separates the product of <math alttext="q Subscript
    theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> and the partition
    function into a sum of logs, and finally the gradient with respect to *x* eliminates
    the log of the partition function, since this term is solely dependent on the
    weights <math alttext="theta"><mi>Î¸</mi></math> and is not a function of *x* itself.
    Thus, the optimal <math alttext="theta"><mi>Î¸</mi></math> that minimizes the proposed
    difference is equivalent to the optimal <math alttext="theta"><mi>Î¸</mi></math>
    that minimizes the difference in scores between <math alttext="p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> and *p(x)*. The following
    is the optimization procedure, which we call *explicit score matching:*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®è¯æ˜ï¼Œ<math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>çš„å¾—åˆ†å‡½æ•°ä¸<math
    alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>çš„å¾—åˆ†å‡½æ•°ç›¸åŒï¼Œ<math
    alttext="for-all x"><mrow><mo>âˆ€</mo> <mi>x</mi></mrow></math>ã€‚è¿™æ˜¯å› ä¸ºå¯¹æ•°é¦–å…ˆå°†<math alttext="q
    Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>å’Œåˆ†åŒºå‡½æ•°çš„ä¹˜ç§¯åˆ†ç¦»ä¸ºå¯¹æ•°çš„å’Œï¼Œæœ€åå…³äº*x*çš„æ¢¯åº¦æ¶ˆé™¤äº†åˆ†åŒºå‡½æ•°çš„å¯¹æ•°ï¼Œå› ä¸ºè¿™ä¸ªé¡¹ä»…å–å†³äºæƒé‡<math
    alttext="theta"><mi>Î¸</mi></math>ï¼Œè€Œä¸æ˜¯*x*æœ¬èº«çš„å‡½æ•°ã€‚å› æ­¤ï¼Œæœ€å°åŒ–æ‰€æå‡ºçš„å·®å¼‚çš„æœ€ä¼˜<math alttext="theta"><mi>Î¸</mi></math>ç­‰åŒäºæœ€å°åŒ–<math
    alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>å’Œ*p(x)*ä¹‹é—´å¾—åˆ†çš„å·®å¼‚ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬ç§°ä¹‹ä¸º*æ˜¾å¼å¾—åˆ†åŒ¹é…*çš„ä¼˜åŒ–è¿‡ç¨‹ã€‚
- en: <math alttext="upper J left-parenthesis theta right-parenthesis equals double-struck
    upper E Subscript p left-parenthesis x right-parenthesis Baseline left-bracket
    one-half StartAbsoluteValue EndAbsoluteValue normal nabla Subscript x Baseline
    log q Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    nabla Subscript x Baseline log p left-parenthesis x right-parenthesis StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mi>J</mi>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>âˆ‡</mi> <mi>x</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>-</mo> <msub><mi>âˆ‡</mi> <mi>x</mi></msub> <msubsup><mrow><mo form="prefix">log</mo><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper J left-parenthesis theta right-parenthesis equals double-struck
    upper E Subscript p left-parenthesis x right-parenthesis Baseline left-bracket
    one-half StartAbsoluteValue EndAbsoluteValue normal nabla Subscript x Baseline
    log q Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    nabla Subscript x Baseline log p left-parenthesis x right-parenthesis StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mi>J</mi>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>âˆ‡</mi> <mi>x</mi></msub> <mo form="prefix">log</mo>
    <msub><mi>q</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>-</mo> <msub><mi>âˆ‡</mi> <mi>x</mi></msub> <msubsup><mrow><mo form="prefix">log</mo><mi>p</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: '*<math alttext="theta Superscript asterisk Baseline equals argmin Subscript
    theta Baseline upper J left-parenthesis theta right-parenthesis"><mrow><msup><mi>Î¸</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <mi>J</mi>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*<math alttext="theta Superscript asterisk Baseline equals argmin Subscript
    theta Baseline upper J left-parenthesis theta right-parenthesis"><mrow><msup><mi>Î¸</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <mi>J</mi>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>*'
- en: The reason for the leading <math alttext="one-half"><mfrac><mn>1</mn> <mn>2</mn></mfrac></math>
    is to simplify the resulting gradient (cancels out with the 2 that will be pulled
    down from the square of the norm). Note that we have completely removed the dependence
    on the partition function in our analysis, and we now have a way to (1) learn
    an unnormalized distribution <math alttext="q Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> , and (2) calculate the score of <math
    alttext="p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> via our neural network. For item 1, in the case
    where we find a setting <math alttext="theta"><mi>Î¸</mi></math> that results in
    <math alttext="upper J left-parenthesis theta right-parenthesis equals 0"><mrow><mi>J</mi>
    <mo>(</mo> <mi>Î¸</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math> , <math alttext="p
    Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    and *p(x)* are the same for all *x* since their gradients are the same for all
    *x.* Of course, in general, two functions that have the same gradients everywhere
    can still be different functions by being off from each other by a nonzero constant.
    However, in our case, these two functions cannot be off by a nonzero constant
    since they are both probability distributions that must sum to one. Thus, we have
    a valid optimization procedure for learning an unnormalized distribution that,
    when normalized, should approximate the true distribution well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: é¢†å…ˆçš„ <math alttext="one-half"><mfrac><mn>1</mn> <mn>2</mn></mfrac></math> çš„åŸå› æ˜¯ä¸ºäº†ç®€åŒ–ç»“æœçš„æ¢¯åº¦ï¼ˆä¸å°†ä»èŒƒæ•°çš„å¹³æ–¹ä¸­ä¸‹æ‹‰çš„2ç›¸äº’æŠµæ¶ˆï¼‰ã€‚è¯·æ³¨æ„ï¼Œåœ¨æˆ‘ä»¬çš„åˆ†æä¸­å®Œå…¨æ¶ˆé™¤äº†å¯¹åˆ†åŒºå‡½æ•°çš„ä¾èµ–ï¼Œç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸€ç§æ–¹æ³•æ¥ï¼ˆ1ï¼‰å­¦ä¹ ä¸€ä¸ªæœªå½’ä¸€åŒ–çš„åˆ†å¸ƒ
    <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼Œä»¥åŠï¼ˆ2ï¼‰é€šè¿‡æˆ‘ä»¬çš„ç¥ç»ç½‘ç»œè®¡ç®—
    <math alttext="p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> çš„å¾—åˆ†ã€‚å¯¹äºç¬¬ä¸€é¡¹ï¼Œåœ¨æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªå¯¼è‡´ <math alttext="upper J left-parenthesis
    theta right-parenthesis equals 0"><mrow><mi>J</mi> <mo>(</mo> <mi>Î¸</mi> <mo>)</mo>
    <mo>=</mo> <mn>0</mn></mrow></math> çš„è®¾ç½® <math alttext="theta"><mi>Î¸</mi></math>
    çš„æƒ…å†µä¸‹ï¼Œ<math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    å’Œ *p(x)* å¯¹äºæ‰€æœ‰ *x* éƒ½æ˜¯ç›¸åŒçš„ï¼Œå› ä¸ºå®ƒä»¬å¯¹äºæ‰€æœ‰ *x* çš„æ¢¯åº¦éƒ½æ˜¯ç›¸åŒçš„ã€‚å½“ç„¶ï¼Œåœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªåœ¨ä»»ä½•åœ°æ–¹å…·æœ‰ç›¸åŒæ¢¯åº¦çš„å‡½æ•°ä»ç„¶å¯ä»¥é€šè¿‡ç›¸äº’åç¦»ä¸€ä¸ªéé›¶å¸¸æ•°è€Œæˆä¸ºä¸åŒçš„å‡½æ•°ã€‚ç„¶è€Œï¼Œåœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°ä¸èƒ½é€šè¿‡éé›¶å¸¸æ•°åç¦»ï¼Œå› ä¸ºå®ƒä»¬éƒ½æ˜¯å¿…é¡»æ€»å’Œä¸ºä¸€çš„æ¦‚ç‡åˆ†å¸ƒã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„ä¼˜åŒ–è¿‡ç¨‹æ¥å­¦ä¹ ä¸€ä¸ªæœªå½’ä¸€åŒ–çš„åˆ†å¸ƒï¼Œå½“å½’ä¸€åŒ–æ—¶ï¼Œåº”è¯¥å¾ˆå¥½åœ°é€¼è¿‘çœŸå®åˆ†å¸ƒã€‚
- en: 'To perform item 2, in theory all we would need to do is first run our example
    <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> through our neural network
    to get <math alttext="q Subscript theta Baseline left-parenthesis x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> , take the log of <math alttext="q Subscript theta
    Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis Baseline
    right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></math>
    , and backpropagate this result through our network all the way back to the input.
    Weâ€™ve already shown that the resultant score is equivalent to the score of <math
    alttext="p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> . Going forward, we will refer to the score function
    of <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    (and <math alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    ) as <math alttext="normal upper Psi Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>Î¨</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> , and the score function of <math alttext="p
    left-parenthesis x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    as <math alttext="normal upper Psi left-parenthesis x right-parenthesis"><mrow><mi>Î¨</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> . Using our new notation, we rewrite
    the explicit score matching objective as:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰§è¡Œé¡¹ç›®2ï¼Œç†è®ºä¸Šæˆ‘ä»¬åªéœ€è¦é¦–å…ˆé€šè¿‡æˆ‘ä»¬çš„ç¥ç»ç½‘ç»œè¿è¡Œç¤ºä¾‹<math alttext="x Superscript left-parenthesis i
    right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>ï¼Œå¾—åˆ°<math
    alttext="q Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>ï¼Œå–<math alttext="q Subscript theta Baseline left-parenthesis
    x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>çš„å¯¹æ•°ï¼Œå¹¶å°†è¿™ä¸ªç»“æœåå‘ä¼ æ’­åˆ°è¾“å…¥ç«¯ã€‚æˆ‘ä»¬å·²ç»è¯æ˜äº†ç»“æœåˆ†æ•°ç­‰åŒäº<math alttext="p
    Subscript theta Baseline left-parenthesis x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow></mrow></math>çš„åˆ†æ•°ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†æŠŠ<math
    alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼ˆå’Œ<math
    alttext="q Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼‰çš„åˆ†æ•°å‡½æ•°ç§°ä¸º<math
    alttext="normal upper Psi Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>Î¨</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ï¼Œä»¥åŠ<math
    alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></math>çš„åˆ†æ•°å‡½æ•°ç§°ä¸º<math alttext="normal upper Psi left-parenthesis
    x right-parenthesis"><mrow><mi>Î¨</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>ã€‚ä½¿ç”¨æˆ‘ä»¬çš„æ–°ç¬¦å·ï¼Œæˆ‘ä»¬å°†æ˜¾å¼åˆ†æ•°åŒ¹é…ç›®æ ‡é‡å†™ä¸ºï¼š
- en: <math alttext="theta Superscript asterisk Baseline equals argmin Subscript theta
    Baseline double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal upper
    Psi Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    upper Psi left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msup><mi>Î¸</mi> <mo>*</mo></msup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <msub><mi>ğ”¼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>Î¨</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>-</mo> <msubsup><mrow><mi>Î¨</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="theta Superscript asterisk Baseline equals argmin Subscript theta
    Baseline double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal upper
    Psi Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    upper Psi left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msup><mi>Î¸</mi> <mo>*</mo></msup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <msub><mi>ğ”¼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>Î¨</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>-</mo> <msubsup><mrow><mi>Î¨</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: 'Although we have gotten around the issue of the partition function, we still
    have no idea what <math alttext="normal upper Psi left-parenthesis x right-parenthesis"><mrow><mi>Î¨</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> is. Hyvarinen, in 2005, in addition
    to proposing the notion of explicit score matching, proved an amazing property
    regarding explicit score matching (satisfied under certain weak regularity conditions):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡æˆ‘ä»¬å·²ç»è§£å†³äº†åˆ†åŒºå‡½æ•°çš„é—®é¢˜ï¼Œä½†æˆ‘ä»¬ä»ç„¶ä¸çŸ¥é“<math alttext="normal upper Psi left-parenthesis x
    right-parenthesis"><mrow><mi>Î¨</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>æ˜¯ä»€ä¹ˆã€‚Hyvarinenåœ¨2005å¹´æå‡ºäº†æ˜¾å¼åˆ†æ•°åŒ¹é…çš„æ¦‚å¿µï¼Œå¹¶è¯æ˜äº†å…³äºæ˜¾å¼åˆ†æ•°åŒ¹é…çš„ä¸€ä¸ªæƒŠäººæ€§è´¨ï¼ˆåœ¨æŸäº›å¼±æ­£åˆ™æ¡ä»¶ä¸‹æ»¡è¶³ï¼‰ï¼š
- en: <math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal upper
    Psi Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    upper Psi left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket equals double-struck upper E
    Subscript p left-parenthesis x right-parenthesis Baseline left-bracket one-half
    StartAbsoluteValue EndAbsoluteValue normal upper Psi Subscript theta Baseline
    left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue Subscript
    2 Superscript 2 Baseline plus sigma-summation Underscript i equals 1 Overscript
    d Endscripts normal nabla Subscript x Sub Subscript i Subscript Baseline normal
    upper Psi Subscript theta comma i Baseline left-parenthesis x right-parenthesis
    plus c right-bracket"><mrow><msub><mi>ğ”¼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>Î¨</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>-</mo> <msubsup><mrow><mi>Î¨</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo> <mo>=</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo></mrow>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo> <mo>|</mo></mrow> <msub><mi>Î¨</mi>
    <mi>Î¸</mi></msub> <msubsup><mrow><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>âˆ‘</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <msub><mi>âˆ‡</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <msub><mi>Î¨</mi> <mrow><mi>Î¸</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>c</mi> <mo>]</mo></mrow></mrow></math>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="double-struck upper E Subscript p left-parenthesis x right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal upper
    Psi Subscript theta Baseline left-parenthesis x right-parenthesis minus normal
    upper Psi left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket equals double-struck upper E
    Subscript p left-parenthesis x right-parenthesis Baseline left-bracket one-half
    StartAbsoluteValue EndAbsoluteValue normal upper Psi Subscript theta Baseline
    left-parenthesis x right-parenthesis StartAbsoluteValue EndAbsoluteValue Subscript
    2 Superscript 2 Baseline plus sigma-summation Underscript i equals 1 Overscript
    d Endscripts normal nabla Subscript x Sub Subscript i Subscript Baseline normal
    upper Psi Subscript theta comma i Baseline left-parenthesis x right-parenthesis
    plus c right-bracket"><mrow><msub><mi>ğ”¼</mi> <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>Î¨</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>-</mo> <msubsup><mrow><mi>Î¨</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo> <mo>=</mo></mrow> <msub><mi>ğ”¼</mi>
    <mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msub> <mrow><mo>[</mo></mrow>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo> <mo>|</mo></mrow> <msub><mi>Î¨</mi>
    <mi>Î¸</mi></msub> <msubsup><mrow><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>âˆ‘</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <msub><mi>âˆ‡</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <msub><mi>Î¨</mi> <mrow><mi>Î¸</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>c</mi> <mo>]</mo></mrow></mrow></math>
- en: Where <math alttext="normal upper Psi Subscript theta comma i Baseline left-parenthesis
    x right-parenthesis equals normal nabla Subscript x Sub Subscript i Baseline log
    p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>Î¨</mi>
    <mrow><mi>Î¸</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>âˆ‡</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> â€”the score function is just a length
    *d* vector (assuming *x* is of *d* dimensions), where each index <math alttext="i"><mi>i</mi></math>
    corresponds with the partial derivative of the log probability with respect to
    <math alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math> . <math
    alttext="c"><mi>c</mi></math> is a constant that has no dependence on <math alttext="theta"><mi>Î¸</mi></math>
    , so it can simply be ignored during optimization. This is a method the community
    has come to know as *implicit score matching.*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­<math alttext="normal upper Psi Subscript theta comma i Baseline left-parenthesis
    x right-parenthesis equals normal nabla Subscript x Sub Subscript i Baseline log
    p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>Î¨</mi>
    <mrow><mi>Î¸</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>âˆ‡</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>â€”â€”åˆ†æ•°å‡½æ•°åªæ˜¯ä¸€ä¸ªé•¿åº¦ä¸º*d*çš„å‘é‡ï¼ˆå‡è®¾*x*æ˜¯*d*ç»´ï¼‰ï¼Œå…¶ä¸­æ¯ä¸ªç´¢å¼•<math
    alttext="i"><mi>i</mi></math>å¯¹åº”äºå¯¹*log*æ¦‚ç‡å…³äº<math alttext="x Subscript i"><msub><mi>x</mi>
    <mi>i</mi></msub></math>çš„åå¯¼æ•°ã€‚*c*æ˜¯ä¸€ä¸ªä¸<math alttext="theta"><mi>Î¸</mi></math>æ— å…³çš„å¸¸æ•°ï¼Œå› æ­¤åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­å¯ä»¥ç®€å•å¿½ç•¥ã€‚è¿™æ˜¯ç¤¾åŒºå·²çŸ¥çš„ä¸€ç§æ–¹æ³•ï¼Œç§°ä¸º*éšå¼åˆ†æ•°åŒ¹é…*ã€‚
- en: 'Note that the equivalent expression has no dependence on the true probability
    distribution, and thus we can directly optimize <math alttext="theta"><mi>Î¸</mi></math>
    , using it as we would any other objective. Once we learn the optimal <math alttext="theta"><mi>Î¸</mi></math>
    , all we need to do to perform generative modeling is:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œç­‰æ•ˆè¡¨è¾¾å¼ä¸ä¾èµ–äºçœŸå®æ¦‚ç‡åˆ†å¸ƒï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥ä¼˜åŒ–*Î¸*ï¼Œå°†å…¶ç”¨ä½œä»»ä½•å…¶ä»–ç›®æ ‡ä¸€æ ·ã€‚ä¸€æ—¦æˆ‘ä»¬å­¦ä¹ åˆ°æœ€ä½³çš„*Î¸*ï¼Œè¿›è¡Œç”Ÿæˆå»ºæ¨¡æ‰€éœ€åšçš„å°±æ˜¯ï¼š
- en: 'Follow the methodology presented earlier for calculating the score of <math
    alttext="p Subscript theta Baseline left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> : run the example through our learned network,
    take the log of the result, and backpropagate all the way to the input.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æŒ‰ç…§ä¹‹å‰æå‡ºçš„æ–¹æ³•è®¡ç®—*p<sub>Î¸</sub>(x<sup>(i)</sup>)*çš„å¾—åˆ†ï¼šé€šè¿‡æˆ‘ä»¬å­¦ä¹ çš„ç½‘ç»œè¿è¡Œç¤ºä¾‹ï¼Œå–ç»“æœçš„å¯¹æ•°ï¼Œå¹¶åå‘ä¼ æ’­ç›´åˆ°è¾“å…¥ã€‚
- en: Sample <math alttext="epsilon"><mi>Ïµ</mi></math> from *N(0,I).*
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»*N(0,I)*ä¸­æŠ½å–æ ·æœ¬*epsilon*ã€‚
- en: Plug in the results of steps 1 and 2 into the Langevin dynamics equation to
    obtain the next sample, <math alttext="x Superscript left-parenthesis i plus 1
    right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    .
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†æ­¥éª¤1å’Œ2çš„ç»“æœæ’å…¥LangevinåŠ¨åŠ›å­¦æ–¹ç¨‹ä¸­ï¼Œä»¥è·å¾—ä¸‹ä¸€ä¸ªæ ·æœ¬*x<sup>(i+1)</sup>*ã€‚
- en: Repeat steps 1 through 3 with <math alttext="x Superscript left-parenthesis
    i plus 1 right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    .
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é‡å¤æ­¥éª¤1åˆ°3ï¼Œä½¿ç”¨*x<sup>(i+1)</sup>*ã€‚
- en: This procedure allows us to draw samples from <math alttext="p Subscript theta
    Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> , which, as shown
    earlier, should approximate *p(x)* well once the network has been trained.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¿‡ç¨‹å…è®¸æˆ‘ä»¬ä»*p<sub>Î¸</sub>(x)*ä¸­æŠ½å–æ ·æœ¬ï¼Œæ­£å¦‚ä¹‹å‰æ‰€ç¤ºï¼Œä¸€æ—¦ç½‘ç»œè®­ç»ƒå®Œæˆï¼Œå®ƒåº”è¯¥å¾ˆå¥½åœ°é€¼è¿‘*p(x)*ã€‚
- en: Can we do better than implicit score matching? For one, implicit score matching
    requires us to calculate second-order gradients, as can be seen from the <math
    alttext="sigma-summation Underscript i equals 1 Overscript d Endscripts normal
    nabla Subscript x Sub Subscript i Baseline normal upper Psi Subscript theta comma
    i Baseline left-parenthesis x right-parenthesis"><mrow><msubsup><mo>âˆ‘</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <msub><mi>âˆ‡</mi> <msub><mi>x</mi> <mi>i</mi></msub></msub>
    <msub><mi>Î¨</mi> <mrow><mi>Î¸</mi><mo>,</mo><mi>i</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> term in the implicit score matching
    objective. This can be quite computationally expensive depending on the size of
    *x.* In a framework such as PyTorch, this would require first calculating the
    first-order gradient through standard means such as backpropagation and then looping
    through each <math alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>
    manually to compute its second-order gradient. In the next section, we will cover
    *denoising autoencoders* and *denoising score matching*, which modify the objective
    and allow us to get around these complexity issues.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½å¦æ¯”éšå¼å¾—åˆ†åŒ¹é…åšå¾—æ›´å¥½ï¼Ÿé¦–å…ˆï¼Œéšå¼å¾—åˆ†åŒ¹é…è¦æ±‚æˆ‘ä»¬è®¡ç®—äºŒé˜¶æ¢¯åº¦ï¼Œæ­£å¦‚åœ¨éšå¼å¾—åˆ†åŒ¹é…ç›®æ ‡ä¸­çš„*âˆ‘<sub>i=1</sub><sup>d</sup>âˆ‡<sub>x<sub>i</sub></sub>Î¨<sub>Î¸,i</sub>(x)*ä¸€é¡¹ä¸­æ‰€ç¤ºã€‚è¿™å–å†³äº*x*çš„å¤§å°ï¼Œè¿™å¯èƒ½ä¼šéå¸¸è€—è´¹è®¡ç®—èµ„æºã€‚åœ¨PyTorchç­‰æ¡†æ¶ä¸­ï¼Œè¿™å°†é¦–å…ˆé€šè¿‡æ ‡å‡†æ–¹æ³•ï¼ˆå¦‚åå‘ä¼ æ’­ï¼‰è®¡ç®—ç¬¬ä¸€é˜¶æ¢¯åº¦ï¼Œç„¶åæ‰‹åŠ¨å¾ªç¯éå†æ¯ä¸ª*x<sub>i</sub>*æ¥è®¡ç®—å…¶äºŒé˜¶æ¢¯åº¦ã€‚åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»*å»å™ªè‡ªåŠ¨ç¼–ç å™¨*å’Œ*å»å™ªå¾—åˆ†åŒ¹é…*ï¼Œè¿™äº›ä¿®æ”¹äº†ç›®æ ‡å¹¶ä½¿æˆ‘ä»¬èƒ½å¤Ÿé¿å¼€è¿™äº›å¤æ‚æ€§é—®é¢˜ã€‚
- en: Denoising Autoencoders and Score Matching
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å»å™ªè‡ªåŠ¨ç¼–ç å™¨å’Œå¾—åˆ†åŒ¹é…
- en: Before explaining the connection between denoising autoencoders and score matching,
    we first motivate the denoising autoencoder architecture. In [ChapterÂ 9](ch09.xhtml#ch07),
    we learned about autoencoders through the lens of representation learning. We
    used autoencoders to compress high-dimensional data, such as images, into low-dimensional
    representations that preserved the information, or useful features, necessary
    to reconstruct the original data. We additionally showed, through our experiments
    on MNIST, that we were able to reconstruct the data quite well and we generally
    saw, for instances of a given digit, clustering of its low-dimensional representations.
    This implies that if we were to train a standard classifier on these low-dimensional
    representations, with the label being their original digit categories, weâ€™d expect
    to see great accuracy.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è§£é‡Šå»å™ªè‡ªåŠ¨ç¼–ç å™¨å’Œå¾—åˆ†åŒ¹é…ä¹‹é—´çš„è”ç³»ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆè¦æ¿€å‘å»å™ªè‡ªåŠ¨ç¼–ç å™¨çš„æ¶æ„ã€‚åœ¨ç¬¬9ç« ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡è¡¨ç¤ºå­¦ä¹ çš„è§†è§’äº†è§£äº†è‡ªåŠ¨ç¼–ç å™¨ã€‚æˆ‘ä»¬ä½¿ç”¨è‡ªåŠ¨ç¼–ç å™¨å°†é«˜ç»´æ•°æ®ï¼ˆå¦‚å›¾åƒï¼‰å‹ç¼©æˆä¿ç•™ä¿¡æ¯æˆ–é‡æ„åŸå§‹æ•°æ®æ‰€éœ€çš„æœ‰ç”¨ç‰¹å¾çš„ä½ç»´è¡¨ç¤ºã€‚æ­¤å¤–ï¼Œé€šè¿‡æˆ‘ä»¬åœ¨MNISTä¸Šçš„å®éªŒï¼Œæˆ‘ä»¬èƒ½å¤Ÿç›¸å½“å¥½åœ°é‡æ„æ•°æ®ï¼Œå¹¶ä¸”é€šå¸¸çœ‹åˆ°ç»™å®šæ•°å­—å®ä¾‹çš„ä½ç»´è¡¨ç¤ºèšç±»ã€‚è¿™æ„å‘³ç€å¦‚æœæˆ‘ä»¬åœ¨è¿™äº›ä½ç»´è¡¨ç¤ºä¸Šè®­ç»ƒæ ‡å‡†åˆ†ç±»å™¨ï¼Œæ ‡ç­¾ä¸ºå®ƒä»¬çš„åŸå§‹æ•°å­—ç±»åˆ«ï¼Œæˆ‘ä»¬é¢„è®¡ä¼šçœ‹åˆ°å¾ˆé«˜çš„å‡†ç¡®æ€§ã€‚
- en: However, depending on the data we try to compress, it turns out that, at times,
    our compressions arenâ€™t able to capture useful features. In other words, when
    we use our trained autoencoder on real-world images outside of our sample that
    may be slightly corrupted, rotated, shifted, or captured under various light settings,
    our ability to classify these images using their low-dimensional representations
    takes a large dip.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæ ¹æ®æˆ‘ä»¬å°è¯•å‹ç¼©çš„æ•°æ®ï¼Œæœ‰æ—¶å€™æˆ‘ä»¬çš„å‹ç¼©å¹¶ä¸èƒ½æ•æ‰åˆ°æœ‰ç”¨çš„ç‰¹å¾ã€‚æ¢å¥è¯è¯´ï¼Œå½“æˆ‘ä»¬åœ¨ç°å®ä¸–ç•Œä¸­ä½¿ç”¨æˆ‘ä»¬è®­ç»ƒè¿‡çš„è‡ªåŠ¨ç¼–ç å™¨å¤„ç†å¯èƒ½ç•¥æœ‰æŸåã€æ—‹è½¬ã€ç§»ä½æˆ–åœ¨å„ç§å…‰ç…§æ¡ä»¶ä¸‹æ‹æ‘„çš„å›¾åƒæ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨å®ƒä»¬çš„ä½ç»´è¡¨ç¤ºæ¥å¯¹è¿™äº›å›¾åƒè¿›è¡Œåˆ†ç±»çš„èƒ½åŠ›ä¼šå¤§å¹…ä¸‹é™ã€‚
- en: Ideally, we would like our learned representations to be invariant to such noise.
    In 2008, Vincent proposed denoising autoencoders as a method for combating the
    issues we see with standard autoencoders. Denoising autoencoders first corrupt
    the original input data with noise, run the corrupted input through a standard
    autoencoder, and finally attempt to reconstruct the original input ([FigureÂ 10-8](#fig1008)).
    The original paper used a corruption scheme that randomly zeroed out some portion
    of the input, but acknowledged that a variety of corruption schemes could be used
    instead. Intuitively, the representations learned from such a procedure should
    be much more robust to the challenges presented by real-world images. Indeed,
    the experiments on MNIST by Vincent in 2008 showed that, under various data augmentations
    such as rotation and background noise, the denoising autoencoder performed significantly
    better than the standard autoencoder in terms of classification accuracy.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›æˆ‘ä»¬å­¦åˆ°çš„è¡¨ç¤ºå¯¹è¿™ç§å™ªå£°æ˜¯ä¸å˜çš„ã€‚2008å¹´ï¼ŒVincentæå‡ºäº†å»å™ªè‡ªåŠ¨ç¼–ç å™¨ä½œä¸ºå¯¹æ ‡å‡†è‡ªåŠ¨ç¼–ç å™¨å­˜åœ¨é—®é¢˜çš„ä¸€ç§æ–¹æ³•ã€‚å»å™ªè‡ªåŠ¨ç¼–ç å™¨é¦–å…ˆç”¨å™ªå£°æŸååŸå§‹è¾“å…¥æ•°æ®ï¼Œç„¶åå°†æŸåçš„è¾“å…¥é€šè¿‡æ ‡å‡†è‡ªåŠ¨ç¼–ç å™¨è¿è¡Œï¼Œå¹¶æœ€ç»ˆå°è¯•é‡æ„åŸå§‹è¾“å…¥ï¼ˆ[å›¾10-8](#fig1008)ï¼‰ã€‚åŸå§‹è®ºæ–‡ä½¿ç”¨äº†ä¸€ä¸ªéšæœºå°†è¾“å…¥çš„ä¸€éƒ¨åˆ†ç½®é›¶çš„æŸåæ–¹æ¡ˆï¼Œä½†æ‰¿è®¤å¯ä»¥ä½¿ç”¨å„ç§æŸåæ–¹æ¡ˆã€‚ç›´è§‰ä¸Šï¼Œä»è¿™æ ·ä¸€ä¸ªè¿‡ç¨‹ä¸­å­¦åˆ°çš„è¡¨ç¤ºåº”è¯¥å¯¹çœŸå®ä¸–ç•Œå›¾åƒæ‰€é¢ä¸´çš„æŒ‘æˆ˜æ›´åŠ ç¨³å¥ã€‚äº‹å®ä¸Šï¼ŒVincentåœ¨2008å¹´å¯¹MNISTæ•°æ®é›†è¿›è¡Œçš„å®éªŒè¡¨æ˜ï¼Œåœ¨æ—‹è½¬å’ŒèƒŒæ™¯å™ªå£°ç­‰å„ç§æ•°æ®å¢å¼ºä¸‹ï¼Œå»å™ªè‡ªåŠ¨ç¼–ç å™¨åœ¨åˆ†ç±»å‡†ç¡®åº¦æ–¹é¢æ˜æ˜¾ä¼˜äºæ ‡å‡†è‡ªåŠ¨ç¼–ç å™¨ã€‚
- en: '![](Images/fdl2_1008.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fdl2_1008.png)'
- en: Figure 10-8\. The denoising autoencoder architecture is the same as that of
    the standard autoencoder, except instead of minimizing the reconstruction error
    between y and the input x', we minimize the reconstruction error between y and
    the original x.
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾10-8ã€‚å»å™ªè‡ªåŠ¨ç¼–ç å™¨çš„æ¶æ„ä¸æ ‡å‡†è‡ªåŠ¨ç¼–ç å™¨ç›¸åŒï¼Œåªæ˜¯ä¸å†æœ€å°åŒ–yå’Œè¾“å…¥x'ä¹‹é—´çš„é‡æ„è¯¯å·®ï¼Œè€Œæ˜¯æœ€å°åŒ–yå’ŒåŸå§‹xä¹‹é—´çš„é‡æ„è¯¯å·®ã€‚
- en: 'Following Vincent 2011, which first noticed the connection between denoising
    AEs and score matching, we instead define the corruption scheme to be the addition
    of Gaussian noise to the original data. Formally, we have that <math alttext="p
    left-parenthesis x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    represents the true distribution of the data, <math alttext="p Subscript d a t
    a Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> represents the distribution
    of the data using our training set, and <math alttext="p Subscript sigma Baseline
    left-parenthesis x prime vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>''</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> represents the conditional distribution
    of the corrupted data given the original data. In particular:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®Vincent 2011å¹´çš„ç ”ç©¶ï¼Œé¦–æ¬¡æ³¨æ„åˆ°å»å™ªè‡ªåŠ¨ç¼–ç å™¨å’Œè¯„åˆ†åŒ¹é…ä¹‹é—´çš„è”ç³»ï¼Œæˆ‘ä»¬å°†å®šä¹‰æŸåæ–¹æ¡ˆä¸ºå‘åŸå§‹æ•°æ®æ·»åŠ é«˜æ–¯å™ªå£°ã€‚å½¢å¼ä¸Šï¼Œæˆ‘ä»¬æœ‰<math
    alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow></math>ä»£è¡¨æ•°æ®çš„çœŸå®åˆ†å¸ƒï¼Œ<math alttext="p Subscript d a t a Baseline
    left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>ä»£è¡¨ä½¿ç”¨æˆ‘ä»¬çš„è®­ç»ƒé›†çš„æ•°æ®åˆ†å¸ƒï¼Œ<math
    alttext="p Subscript sigma Baseline left-parenthesis x prime vertical-bar x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>ä»£è¡¨ç»™å®šåŸå§‹æ•°æ®çš„æŸåæ•°æ®çš„æ¡ä»¶åˆ†å¸ƒã€‚ç‰¹åˆ«åœ°ï¼š
- en: "<math alttext=\"p Subscript sigma Baseline left-parenthesis x prime vertical-bar\
    \ x right-parenthesis equals upper N left-parenthesis x prime semicolon x comma\
    \ sigma squared upper I right-parenthesis\"><mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub>\
    \ <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>\
    \ <mo>=</mo> <mi>N</mi> <mrow><mo>(</mo> <mi>x</mi> <mi>Ã¢</mi> <mi>\x80</mi> <mi>\x99\
    </mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <msup><mi>Ïƒ</mi> <mn>2</mn></msup> <mi>I</mi>\
    \ <mo>)</mo></mrow></mrow></math>"
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: "<math alttext=\"p Subscript sigma Baseline left-parenthesis x prime vertical-bar\
    \ x right-parenthesis equals upper N left-parenthesis x prime semicolon x comma\
    \ sigma squared upper I right-parenthesis\"><mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub>\
    \ <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>\
    \ <mo>=</mo> <mi>N</mi> <mrow><mo>(</mo> <mi>x</mi> <mi>Ã¢</mi> <mi>\x80</mi> <mi>\x99\
    </mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <msup><mi>Ïƒ</mi> <mn>2</mn></msup> <mi>I</mi>\
    \ <mo>)</mo></mrow></mrow></math>"
- en: 'Where the mean of the distribution is the original data and the subscript <math
    alttext="sigma"><mi>Ïƒ</mi></math> represents the standard deviation of the Gaussian
    noise applied to the original data. Note that *xâ€™* and *x* are defined over the
    same domain (all possible images, for example). We can now calculate the distribution
    over the corrupted data:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­åˆ†å¸ƒçš„å‡å€¼æ˜¯åŸå§‹æ•°æ®ï¼Œä¸‹æ ‡<math alttext="sigma"><mi>Ïƒ</mi></math>ä»£è¡¨åº”ç”¨äºåŸå§‹æ•°æ®çš„é«˜æ–¯å™ªå£°çš„æ ‡å‡†å·®ã€‚æ³¨æ„*x'*å’Œ*x*å®šä¹‰åœ¨ç›¸åŒçš„åŸŸä¸Šï¼ˆä¾‹å¦‚æ‰€æœ‰å¯èƒ½çš„å›¾åƒï¼‰ã€‚æˆ‘ä»¬ç°åœ¨å¯ä»¥è®¡ç®—æŸåæ•°æ®çš„åˆ†å¸ƒï¼š
- en: <math alttext="p Subscript sigma Baseline left-parenthesis x prime right-parenthesis
    equals sigma-summation Underscript x Endscripts p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x right-parenthesis p left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>âˆ‘</mo> <mi>x</mi></msub> <msub><mi>p</mi> <mi>Ïƒ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p Subscript sigma Baseline left-parenthesis x prime right-parenthesis
    equals sigma-summation Underscript x Endscripts p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x right-parenthesis p left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>âˆ‘</mo> <mi>x</mi></msub> <msub><mi>p</mi> <mi>Ïƒ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>p</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="almost-equals sigma-summation Underscript x Endscripts p Subscript
    sigma Baseline left-parenthesis x prime vertical-bar x right-parenthesis p Subscript
    d a t a Baseline left-parenthesis x right-parenthesis"><mrow><mo>â‰ˆ</mo> <msub><mo>âˆ‘</mo>
    <mi>x</mi></msub> <msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="almost-equals sigma-summation Underscript x Endscripts p Subscript
    sigma Baseline left-parenthesis x prime vertical-bar x right-parenthesis p Subscript
    d a t a Baseline left-parenthesis x right-parenthesis"><mrow><mo>â‰ˆ</mo> <msub><mo>âˆ‘</mo>
    <mi>x</mi></msub> <msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow> <msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals StartFraction 1 Over n EndFraction sigma-summation Underscript
    i equals 1 Overscript n Endscripts p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x equals x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <msubsup><mo>âˆ‘</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup>
    <mo>|</mo> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals StartFraction 1 Over n EndFraction sigma-summation Underscript
    i equals 1 Overscript n Endscripts p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x equals x Superscript left-parenthesis i right-parenthesis
    Baseline right-parenthesis"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <msubsup><mo>âˆ‘</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup>
    <mo>|</mo> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>
- en: which is the empirical average over the conditional probabilities using each
    data point from our dataset as the reference. This follows naturally from letting
    the true distribution be approximated by the distribution defined by the dataset
    (same as how this was defined in [â€œGenerative Adversarial Networksâ€](#gans-sect)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä½¿ç”¨æˆ‘ä»¬æ•°æ®é›†ä¸­çš„æ¯ä¸ªæ•°æ®ç‚¹ä½œä¸ºå‚è€ƒè®¡ç®—æ¡ä»¶æ¦‚ç‡çš„ç»éªŒå¹³å‡å€¼ã€‚è¿™è‡ªç„¶åœ°éµå¾ªäº†è®©çœŸå®åˆ†å¸ƒç”±æ•°æ®é›†å®šä¹‰çš„åˆ†å¸ƒæ¥è¿‘ä¼¼ï¼ˆä¸[â€œç”Ÿæˆå¯¹æŠ—ç½‘ç»œâ€](#gans-sect)ä¸­çš„å®šä¹‰æ–¹å¼ç›¸åŒï¼‰ã€‚
- en: In 2011, Vincent explored the possibility of using <math alttext="p Subscript
    sigma Baseline left-parenthesis x prime right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
    as the reference instead of <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> as we do in explicit score matching.
    The reasoning for this is that <math alttext="p Subscript sigma Baseline left-parenthesis
    x prime right-parenthesis"><mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math> can be viewed
    as a continuous approximation to the true distribution <math alttext="p left-parenthesis
    x right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    . The approximation defined by <math alttext="p Subscript d a t a Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> is unbiased, but is
    unfortunately discontinuous everywhere *x* is not present in the dataset due to
    being a uniform distribution over all images in the dataset, with a likelihood
    of zero everywhere else. Of course, as <math alttext="sigma"><mi>Ïƒ</mi></math>
    gets larger, <math alttext="p Subscript sigma Baseline left-parenthesis x prime
    right-parenthesis"><mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math> is seen as a less and less faithful
    approximation to <math alttext="p left-parenthesis x right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> , so weâ€™d like to work with small
    <math alttext="sigma"><mi>Ïƒ</mi></math> â€™s.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Vincent 2011 first proposed explicit score matching using <math alttext="p
    Subscript sigma Baseline left-parenthesis x prime right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>''</mo></msup> <mo>)</mo></mrow></mrow></math>
    as the reference:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*<math alttext="upper J left-parenthesis theta right-parenthesis equals double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x prime right-parenthesis
    Baseline left-bracket one-half StartAbsoluteValue EndAbsoluteValue normal nabla
    Subscript x prime Baseline log p Subscript theta Baseline left-parenthesis x prime
    right-parenthesis minus normal nabla Subscript x prime Baseline log p Subscript
    sigma Baseline left-parenthesis x prime right-parenthesis StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mi>J</mi> <mrow><mo>(</mo>
    <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><msup><mi>x</mi> <mo>''</mo></msup> <mo>)</mo></mrow></mrow></msub>
    <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>''</mo></msup></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>''</mo></msup> <mo>)</mo></mrow> <mo>-</mo> <msub><mi>âˆ‡</mi>
    <msup><mi>x</mi> <mo>''</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>''</mo></msup> <mo>)</mo></mrow>
    <msubsup><mrow><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '*<math alttext="theta Superscript asterisk Baseline equals argmin Subscript
    theta Baseline upper J left-parenthesis theta right-parenthesis"><mrow><msup><mi>Î¸</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <mi>J</mi>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same reasoning for why this is a valid optimization procedure
    for <math alttext="p Subscript theta Baseline left-parenthesis x right-parenthesis"><mrow><msub><mi>p</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    is the same as in the previous sectionâ€”the only difference here is the reference
    distribution we are trying to match. Vincent 2011 actually goes an extra step
    and shows that this optimization procedure is equivalent to:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œä¸ºä»€ä¹ˆè¿™æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ä¼˜åŒ–è¿‡ç¨‹å¯¹äº<math alttext="p Subscript theta Baseline left-parenthesis
    x right-parenthesis"><mrow><msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math>çš„æ¨ç†ä¸å‰ä¸€èŠ‚ä¸­çš„ç›¸åŒâ€”â€”å”¯ä¸€çš„åŒºåˆ«åœ¨äºæˆ‘ä»¬è¯•å›¾åŒ¹é…çš„å‚è€ƒåˆ†å¸ƒã€‚Vincent
    2011 å®é™…ä¸Šèµ°äº†ä¸€æ­¥é¢å¤–ï¼Œå¹¶å±•ç¤ºäº†è¿™ä¸ªä¼˜åŒ–è¿‡ç¨‹ç­‰æ•ˆäºï¼š
- en: <math alttext="upper J Subscript DSM Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    one-half StartAbsoluteValue EndAbsoluteValue normal nabla Subscript x prime Baseline
    log p Subscript theta Baseline left-parenthesis x prime right-parenthesis minus
    normal nabla Subscript x prime Baseline log p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x right-parenthesis StartAbsoluteValue EndAbsoluteValue Subscript
    2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi> <mtext>DSM</mtext></msub>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mrow><mo>|</mo> <mo>|</mo></mrow> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>-</mo> <msub><mi>âˆ‡</mi>
    <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow> <msubsup><mrow><mo>|</mo><mo>|</mo></mrow> <mn>2</mn>
    <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper J Subscript DSM Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    one-half StartAbsoluteValue EndAbsoluteValue normal nabla Subscript x prime Baseline
    log p Subscript theta Baseline left-parenthesis x prime right-parenthesis minus
    normal nabla Subscript x prime Baseline log p Subscript sigma Baseline left-parenthesis
    x prime vertical-bar x right-parenthesis StartAbsoluteValue EndAbsoluteValue Subscript
    2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi> <mtext>DSM</mtext></msub>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mrow><mo>|</mo> <mo>|</mo></mrow> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub>
    <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>-</mo> <msub><mi>âˆ‡</mi>
    <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow> <msubsup><mrow><mo>|</mo><mo>|</mo></mrow> <mn>2</mn>
    <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: <math alttext="theta Subscript DSM Superscript asterisk Baseline equals argmin
    Subscript theta Baseline upper J Subscript DSM Baseline left-parenthesis theta
    right-parenthesis"><mrow><msubsup><mi>Î¸</mi> <mtext>DSM</mtext> <mo>*</mo></msubsup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <msub><mi>J</mi> <mtext>DSM</mtext></msub>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="theta Subscript DSM Superscript asterisk Baseline equals argmin
    Subscript theta Baseline upper J Subscript DSM Baseline left-parenthesis theta
    right-parenthesis"><mrow><msubsup><mi>Î¸</mi> <mtext>DSM</mtext> <mo>*</mo></msubsup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <msub><mi>J</mi> <mtext>DSM</mtext></msub>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
- en: Although we wonâ€™t show the proof here and refer you to Vincent 2011 for the
    full details, it does utilize the log trick we described in [â€œImplementing a VAEâ€](#vae-sect).
    We refer to optimizing this objective as *denoising score matching,* or *DSM*
    for short*,* and as we will show soon, it serves as the connection to denoising
    AEs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶æˆ‘ä»¬ä¸ä¼šåœ¨è¿™é‡Œå±•ç¤ºè¯æ˜ï¼Œå¹¶å°†æ‚¨è½¬è‡³ Vincent 2011 ä»¥è·å–å®Œæ•´ç»†èŠ‚ï¼Œä½†å®ƒç¡®å®åˆ©ç”¨äº†æˆ‘ä»¬åœ¨ [â€œå®ç°VAEâ€](#vae-sect) ä¸­æè¿°çš„å¯¹æ•°æŠ€å·§ã€‚æˆ‘ä»¬å°†ä¼˜åŒ–è¿™ä¸ªç›®æ ‡ç§°ä¸º*å»å™ªå¾—åˆ†åŒ¹é…*ï¼Œç®€ç§°ä¸º*DSM*ï¼Œæ­£å¦‚æˆ‘ä»¬å°†å¾ˆå¿«å±•ç¤ºçš„é‚£æ ·ï¼Œå®ƒä½œä¸ºä¸å»å™ªè‡ªç¼–ç å™¨çš„è¿æ¥ã€‚
- en: "We know that <math alttext=\"p Subscript sigma Baseline left-parenthesis x\
    \ prime vertical-bar x right-parenthesis equals upper N left-parenthesis x prime\
    \ semicolon x comma sigma squared upper I right-parenthesis\"><mrow><msub><mi>p</mi>\
    \ <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>\
    \ <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>N</mi> <mrow><mo>(</mo> <mi>x</mi>\
    \ <mi>Ã¢</mi> <mi>\x80</mi> <mi>\x99</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <msup><mi>Ïƒ</mi>\
    \ <mn>2</mn></msup> <mi>I</mi> <mo>)</mo></mrow></mrow></math> , and now compute\
    \ the gradient of its log:"
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: "æˆ‘ä»¬çŸ¥é“<math alttext=\"p Subscript sigma Baseline left-parenthesis x prime vertical-bar\
    \ x right-parenthesis equals upper N left-parenthesis x prime semicolon x comma\
    \ sigma squared upper I right-parenthesis\"><mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub>\
    \ <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>\
    \ <mo>=</mo> <mi>N</mi> <mrow><mo>(</mo> <mi>x</mi> <mi>Ã¢</mi> <mi>\x80</mi> <mi>\x99\
    </mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <msup><mi>Ïƒ</mi> <mn>2</mn></msup> <mi>I</mi>\
    \ <mo>)</mo></mrow></mrow></math>ï¼Œç°åœ¨è®¡ç®—å…¶å¯¹æ•°çš„æ¢¯åº¦ï¼š"
- en: <math alttext="normal nabla Subscript x prime Baseline log p Subscript sigma
    Baseline left-parenthesis x prime vertical-bar x right-parenthesis equals normal
    nabla Subscript x prime Baseline log left-parenthesis StartFraction 1 Over StartRoot
    left-parenthesis 2 pi right-parenthesis Superscript d Baseline StartAbsoluteValue
    sigma squared upper I EndAbsoluteValue EndRoot EndFraction e Superscript StartFraction
    minus left-parenthesis x prime minus x right-parenthesis Super Superscript upper
    T Superscript left-parenthesis x prime minus x right-parenthesis Over 2 sigma
    squared EndFraction Baseline right-parenthesis"><mrow><msub><mi>âˆ‡</mi> <msup><mi>x</mi>
    <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Ïƒ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <mrow><mo>(</mo> <mfrac><mn>1</mn> <msqrt><mrow><msup><mrow><mo>(</mo><mn>2</mn><mi>Ï€</mi><mo>)</mo></mrow>
    <mi>d</mi></msup> <mrow><mo>|</mo><msup><mi>Ïƒ</mi> <mn>2</mn></msup> <mi>I</mi><mo>|</mo></mrow></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mfrac><mrow><mo>-</mo><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mn>2</mn><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow></mfrac></msup> <mo>)</mo></mrow></mrow></math>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal nabla Subscript x prime Baseline log p Subscript sigma
    Baseline left-parenthesis x prime vertical-bar x right-parenthesis equals normal
    nabla Subscript x prime Baseline log left-parenthesis StartFraction 1 Over StartRoot
    left-parenthesis 2 pi right-parenthesis Superscript d Baseline StartAbsoluteValue
    sigma squared upper I EndAbsoluteValue EndRoot EndFraction e Superscript StartFraction
    minus left-parenthesis x prime minus x right-parenthesis Super Superscript upper
    T Superscript left-parenthesis x prime minus x right-parenthesis Over 2 sigma
    squared EndFraction Baseline right-parenthesis"><mrow><msub><mi>âˆ‡</mi> <msup><mi>x</mi>
    <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi> <mi>Ïƒ</mi></msub>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <mrow><mo>(</mo> <mfrac><mn>1</mn> <msqrt><mrow><msup><mrow><mo>(</mo><mn>2</mn><mi>Ï€</mi><mo>)</mo></mrow>
    <mi>d</mi></msup> <mrow><mo>|</mo><msup><mi>Ïƒ</mi> <mn>2</mn></msup> <mi>I</mi><mo>|</mo></mrow></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mfrac><mrow><mo>-</mo><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mn>2</mn><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow></mfrac></msup> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals normal nabla Subscript x prime Baseline log StartFraction
    1 Over StartRoot left-parenthesis 2 pi right-parenthesis Superscript d Baseline
    StartAbsoluteValue sigma squared upper I EndAbsoluteValue EndRoot EndFraction
    plus normal nabla Subscript x prime Baseline log e Superscript StartFraction minus
    left-parenthesis x prime minus x right-parenthesis Super Superscript upper T Superscript
    left-parenthesis x prime minus x right-parenthesis Over 2 sigma squared EndFraction"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <mfrac><mn>1</mn> <msqrt><mrow><msup><mrow><mo>(</mo><mn>2</mn><mi>Ï€</mi><mo>)</mo></mrow>
    <mi>d</mi></msup> <mrow><mo>|</mo><msup><mi>Ïƒ</mi> <mn>2</mn></msup> <mi>I</mi><mo>|</mo></mrow></mrow></msqrt></mfrac>
    <mo>+</mo> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <msup><mi>e</mi> <mfrac><mrow><mo>-</mo><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mn>2</mn><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow></mfrac></msup></mrow></math>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals normal nabla Subscript x prime Baseline log StartFraction
    1 Over StartRoot left-parenthesis 2 pi right-parenthesis Superscript d Baseline
    StartAbsoluteValue sigma squared upper I EndAbsoluteValue EndRoot EndFraction
    plus normal nabla Subscript x prime Baseline log e Superscript StartFraction minus
    left-parenthesis x prime minus x right-parenthesis Super Superscript upper T Superscript
    left-parenthesis x prime minus x right-parenthesis Over 2 sigma squared EndFraction"><mrow><mo>=</mo>
    <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <mfrac><mn>1</mn> <msqrt><mrow><msup><mrow><mo>(</mo><mn>2</mn><mi>Ï€</mi><mo>)</mo></mrow>
    <mi>d</mi></msup> <mrow><mo>|</mo><msup><mi>Ïƒ</mi> <mn>2</mn></msup> <mi>I</mi><mo>|</mo></mrow></mrow></msqrt></mfrac>
    <mo>+</mo> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo>
    <msup><mi>e</mi> <mfrac><mrow><mo>-</mo><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow></mrow> <mrow><mn>2</mn><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow></mfrac></msup></mrow></math>
- en: <math alttext="equals minus StartFraction 1 Over 2 sigma squared EndFraction
    normal nabla Subscript x prime Baseline left-parenthesis x prime minus x right-parenthesis
    Superscript upper T Baseline left-parenthesis x prime minus x right-parenthesis"><mrow><mo>=</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><msup><mi>Ïƒ</mi> <mn>2</mn></msup></mrow></mfrac>
    <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>-</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals minus StartFraction 1 Over 2 sigma squared EndFraction
    normal nabla Subscript x prime Baseline left-parenthesis x prime minus x right-parenthesis
    Superscript upper T Baseline left-parenthesis x prime minus x right-parenthesis"><mrow><mo>=</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><msup><mi>Ïƒ</mi> <mn>2</mn></msup></mrow></mfrac>
    <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>-</mo><mi>x</mi><mo>)</mo></mrow> <mi>T</mi></msup> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>-</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals minus StartFraction 1 Over 2 sigma squared EndFraction
    left-parenthesis normal nabla Subscript x prime Baseline x Superscript prime upper
    T Baseline x prime minus 2 normal nabla Subscript x prime Baseline x Superscript
    prime upper T Baseline x plus normal nabla Subscript x prime Baseline x Superscript
    upper T Baseline x right-parenthesis"><mrow><mo>=</mo> <mo>-</mo> <mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>Ïƒ</mi> <mn>2</mn></msup></mrow></mfrac> <mrow><mo>(</mo>
    <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>-</mo> <mn>2</mn> <msub><mi>âˆ‡</mi> <msup><mi>x</mi>
    <mo>'</mo></msup></msub> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <mi>x</mi> <mo>+</mo> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub>
    <msup><mi>x</mi> <mi>T</mi></msup> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals minus StartFraction 1 Over 2 sigma squared EndFraction
    left-parenthesis normal nabla Subscript x prime Baseline x Superscript prime upper
    T Baseline x prime minus 2 normal nabla Subscript x prime Baseline x Superscript
    prime upper T Baseline x plus normal nabla Subscript x prime Baseline x Superscript
    upper T Baseline x right-parenthesis"><mrow><mo>=</mo> <mo>-</mo> <mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>Ïƒ</mi> <mn>2</mn></msup></mrow></mfrac> <mrow><mo>(</mo>
    <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>-</mo> <mn>2</mn> <msub><mi>âˆ‡</mi> <msup><mi>x</mi>
    <mo>'</mo></msup></msub> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <mi>x</mi> <mo>+</mo> <msub><mi>âˆ‡</mi> <msup><mi>x</mi> <mo>'</mo></msup></msub>
    <msup><mi>x</mi> <mi>T</mi></msup> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="equals StartFraction 1 Over sigma squared EndFraction left-parenthesis
    x minus x prime right-parenthesis"><mrow><mo>=</mo> <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mfrac> <mrow><mo>(</mo> <mi>x</mi> <mo>-</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals StartFraction 1 Over sigma squared EndFraction left-parenthesis
    x minus x prime right-parenthesis"><mrow><mo>=</mo> <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mfrac> <mrow><mo>(</mo> <mi>x</mi> <mo>-</mo> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
- en: Letâ€™s break down the math. The first equality is simply the definition of a
    Gaussian distribution with mean *x* and variance <math alttext="sigma squared
    upper I"><mrow><msup><mi>Ïƒ</mi> <mn>2</mn></msup> <mi>I</mi></mrow></math> . The
    second equality is a result of the log breaking up the product into a sum of logs,
    and the gradient of a sum being the sum of gradients. In the third equality, we
    see the first term has been removed since it is not a function of *xâ€™*, and thus
    its gradient is zero. Additionally, the log of *e* raised to any power is just
    the power itself, since log as used here has base *e*. Finally, we expand out
    the dot product of *xâ€™ â€“ x* with itself and apply the gradient to each individual
    term of the resulting sum. Note that we can simply rewrite <math alttext="minus
    x Superscript prime upper T Baseline x minus x Superscript upper T Baseline x
    prime"><mrow><mo>-</mo> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup>
    <mi>x</mi> <mo>-</mo> <msup><mi>x</mi> <mi>T</mi></msup> <msup><mi>x</mi> <mo>'</mo></msup></mrow></math>
    as <math alttext="minus 2 x Superscript prime upper T Baseline x"><mrow><mo>-</mo>
    <mn>2</mn> <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup> <mi>x</mi></mrow></math>
    since the two terms are transposes of each other and result in the same scalar.
    We refer you to an amazing text called *The Matrix Cookbook* by KB Petersen and
    Michael Syskind Pedersen, which can serve as a guide to evaluating these gradients
    (plus more) and arrive at the final equality. The intuition for the gradient of
    <math alttext="x Superscript prime upper T Baseline x prime"><mrow><msup><mi>x</mi>
    <mrow><mo>'</mo><mi>T</mi></mrow></msup> <msup><mi>x</mi> <mo>'</mo></msup></mrow></math>
    is that it is the analog of the derivative of the square of a variable from single-variable
    calculus.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥åˆ†è§£è¿™ä¸ªæ•°å­¦é—®é¢˜ã€‚ç¬¬ä¸€ä¸ªç­‰å¼åªæ˜¯é«˜æ–¯åˆ†å¸ƒçš„å®šä¹‰ï¼Œå‡å€¼ä¸º*x*ï¼Œæ–¹å·®ä¸º<math alttext="sigma squared upper I"><mrow><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup> <mi>I</mi></mrow></math>ã€‚ç¬¬äºŒä¸ªç­‰å¼æ˜¯å¯¹æ•°å°†ä¹˜ç§¯åˆ†è§£ä¸ºå¯¹æ•°å’Œçš„ç»“æœï¼Œä»¥åŠå’Œçš„æ¢¯åº¦ä¸ºæ¢¯åº¦ä¹‹å’Œã€‚åœ¨ç¬¬ä¸‰ä¸ªç­‰å¼ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ç¬¬ä¸€é¡¹å·²è¢«ç§»é™¤ï¼Œå› ä¸ºå®ƒä¸æ˜¯*xâ€™*çš„å‡½æ•°ï¼Œå› æ­¤å…¶æ¢¯åº¦ä¸ºé›¶ã€‚æ­¤å¤–ï¼Œ*e*çš„å¯¹æ•°æå‡åˆ°ä»»æ„å¹‚ä»…ä»…æ˜¯å¹‚æœ¬èº«ï¼Œå› ä¸ºè¿™é‡Œä½¿ç”¨çš„å¯¹æ•°å…·æœ‰åŸºæ•°*e*ã€‚æœ€åï¼Œæˆ‘ä»¬å±•å¼€*xâ€™
    â€“ x*ä¸è‡ªèº«çš„ç‚¹ç§¯ï¼Œå¹¶å°†æ¢¯åº¦åº”ç”¨äºç»“æœå’Œçš„æ¯ä¸ªå•ç‹¬é¡¹ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å°†<math alttext="minus x Superscript prime
    upper T Baseline x minus x Superscript upper T Baseline x prime"><mrow><mo>-</mo>
    <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup> <mi>x</mi> <mo>-</mo>
    <msup><mi>x</mi> <mi>T</mi></msup> <msup><mi>x</mi> <mo>'</mo></msup></mrow></math>é‡å†™ä¸º<math
    alttext="minus 2 x Superscript prime upper T Baseline x"><mrow><mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mrow><mo>'</mo><mi>T</mi></mrow></msup> <mi>x</mi></mrow></math>ï¼Œå› ä¸ºè¿™ä¸¤é¡¹æ˜¯å½¼æ­¤çš„è½¬ç½®ï¼Œå¹¶ä¸”ç»“æœæ˜¯ç›¸åŒçš„æ ‡é‡ã€‚æˆ‘ä»¬å»ºè®®æ‚¨é˜…è¯»
    KB Petersen å’Œ Michael Syskind Pedersen æ’°å†™çš„ä¸€æœ¬åä¸º*The Matrix Cookbook*çš„ç²¾å½©æ–‡æœ¬ï¼Œå®ƒå¯ä»¥ä½œä¸ºè¯„ä¼°è¿™äº›æ¢¯åº¦ï¼ˆä»¥åŠæ›´å¤šå†…å®¹ï¼‰å¹¶å¾—å‡ºæœ€ç»ˆç­‰å¼çš„æŒ‡å—ã€‚å¯¹äº<math
    alttext="x Superscript prime upper T Baseline x prime"><mrow><msup><mi>x</mi>
    <mrow><mo>'</mo><mi>T</mi></mrow></msup> <msup><mi>x</mi> <mo>'</mo></msup></mrow></math>çš„æ¢¯åº¦çš„ç›´è§‰æ˜¯ï¼Œå®ƒç±»ä¼¼äºå•å˜é‡å¾®ç§¯åˆ†ä¸­å˜é‡å¹³æ–¹çš„å¯¼æ•°ã€‚
- en: 'For the final step, we will show that optimizing the objective for denoising
    score matching is equivalent to optimizing the objective for denoising AEs. To
    recap, a denoising AE has the same architecture as that of a standard AEâ€”the only
    difference is in the input data and the training objective. The training objective
    of the denoising AE looks like:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åä¸€æ­¥ï¼Œæˆ‘ä»¬å°†å±•ç¤ºï¼Œä¼˜åŒ–å»å™ªå¾—åˆ†åŒ¹é…çš„ç›®æ ‡ç­‰æ•ˆäºä¼˜åŒ–å»å™ªè‡ªç¼–ç å™¨çš„ç›®æ ‡ã€‚å›é¡¾ä¸€ä¸‹ï¼Œå»å™ªè‡ªç¼–ç å™¨çš„æ¶æ„ä¸æ ‡å‡†è‡ªç¼–ç å™¨ç›¸åŒâ€”â€”å”¯ä¸€çš„åŒºåˆ«åœ¨äºè¾“å…¥æ•°æ®å’Œè®­ç»ƒç›®æ ‡ã€‚å»å™ªè‡ªç¼–ç å™¨çš„è®­ç»ƒç›®æ ‡å¦‚ä¸‹ï¼š
- en: <math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    StartAbsoluteValue EndAbsoluteValue decode left-parenthesis encode left-parenthesis
    x Superscript prime Baseline right-parenthesis right-parenthesis minus x StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo>|</mo>
    <mo>|</mo> <mtext>decode</mtext></mrow> <mrow><mo>(</mo> <mtext>encode</mtext>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup>
    <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    StartAbsoluteValue EndAbsoluteValue decode left-parenthesis encode left-parenthesis
    x Superscript prime Baseline right-parenthesis right-parenthesis minus x StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo>|</mo>
    <mo>|</mo> <mtext>decode</mtext></mrow> <mrow><mo>(</mo> <mtext>encode</mtext>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup>
    <mrow><mo>]</mo></mrow></mrow></math>
- en: <math alttext="theta Subscript DAE Superscript asterisk Baseline equals argmin
    Subscript theta Baseline upper J Subscript DAE Baseline left-parenthesis theta
    right-parenthesis"><mrow><msubsup><mi>Î¸</mi> <mtext>DAE</mtext> <mo>*</mo></msubsup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <msub><mi>J</mi> <mtext>DAE</mtext></msub>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="theta Subscript DAE Superscript asterisk Baseline equals argmin
    Subscript theta Baseline upper J Subscript DAE Baseline left-parenthesis theta
    right-parenthesis"><mrow><msubsup><mi>Î¸</mi> <mtext>DAE</mtext> <mo>*</mo></msubsup>
    <mo>=</mo> <msub><mtext>argmin</mtext> <mi>Î¸</mi></msub> <msub><mi>J</mi> <mtext>DAE</mtext></msub>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
- en: 'Note that the parameters, or weights, of both decode() and encode() are encompassed
    by <math alttext="theta"><mi>Î¸</mi></math> . To summarize, we must show that <math
    alttext="theta Subscript DAE Superscript asterisk"><msubsup><mi>Î¸</mi> <mtext>DAE</mtext>
    <mo>*</mo></msubsup></math> and <math alttext="theta Subscript DSM Superscript
    asterisk"><msubsup><mi>Î¸</mi> <mtext>DSM</mtext> <mo>*</mo></msubsup></math> defined
    earlier are equivalent for some form of the unnormalized likelihood. Once again,
    following Vincent 2011, we define the denoising autoencoder as an encoder consisting
    of a single fully connected layer followed by a sigmoid layer and a decoder consisting
    solely of a single fully connected layer. Additionally, we add the constraint
    that the two fully connected layers are weight-tied so that they are transposes
    of each other. The training objective can now be specified as, where <math alttext="theta
    equals left-parenthesis upper W comma b comma c right-parenthesis"><mrow><mi>Î¸</mi>
    <mo>=</mo> <mo>(</mo> <mi>W</mi> <mo>,</mo> <mi>b</mi> <mo>,</mo> <mi>c</mi> <mo>)</mo></mrow></math>
    :'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œdecode() å’Œ encode() çš„å‚æ•°æˆ–æƒé‡éƒ½ç”± <math alttext="theta"><mi>Î¸</mi></math> åŒ…å«ã€‚æ€»ç»“ä¸€ä¸‹ï¼Œæˆ‘ä»¬å¿…é¡»è¯æ˜ä¹‹å‰å®šä¹‰çš„
    <math alttext="theta Subscript DAE Superscript asterisk"><msubsup><mi>Î¸</mi> <mtext>DAE</mtext>
    <mo>*</mo></msubsup></math> å’Œ <math alttext="theta Subscript DSM Superscript asterisk"><msubsup><mi>Î¸</mi>
    <mtext>DSM</mtext> <mo>*</mo></msubsup></math> å¯¹äºæŸç§æœªå½’ä¸€åŒ–ä¼¼ç„¶å½¢å¼æ˜¯ç­‰ä»·çš„ã€‚å†æ¬¡ï¼ŒæŒ‰ç…§ Vincent
    2011 çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å°†å»å™ªè‡ªåŠ¨ç¼–ç å™¨å®šä¹‰ä¸ºä¸€ä¸ªç¼–ç å™¨ï¼Œç”±ä¸€ä¸ªå…¨è¿æ¥å±‚å’Œä¸€ä¸ª Sigmoid å±‚ç»„æˆï¼Œä»¥åŠä¸€ä¸ªè§£ç å™¨ï¼Œä»…ç”±ä¸€ä¸ªå…¨è¿æ¥å±‚ç»„æˆã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬æ·»åŠ äº†ä¸¤ä¸ªå…¨è¿æ¥å±‚æ˜¯æƒé‡ç»‘å®šçš„çº¦æŸï¼Œä½¿å®ƒä»¬äº’ä¸ºè½¬ç½®ã€‚ç°åœ¨å¯ä»¥å°†è®­ç»ƒç›®æ ‡æŒ‡å®šä¸ºï¼Œå…¶ä¸­
    <math alttext="theta equals left-parenthesis upper W comma b comma c right-parenthesis"><mrow><mi>Î¸</mi>
    <mo>=</mo> <mo>(</mo> <mi>W</mi> <mo>,</mo> <mi>b</mi> <mo>,</mo> <mi>c</mi> <mo>)</mo></mrow></math>ï¼š
- en: <math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    StartAbsoluteValue EndAbsoluteValue upper W Superscript upper T Baseline left-parenthesis
    upper W x prime plus b right-parenthesis plus c minus x StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi> <mtext>DAE</mtext></msub>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo>|</mo> <mo>|</mo></mrow>
    <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>c</mi>
    <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup>
    <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis
    equals double-struck upper E Subscript p Sub Subscript sigma Subscript left-parenthesis
    x comma x Sub Superscript prime Subscript right-parenthesis Baseline left-bracket
    StartAbsoluteValue EndAbsoluteValue upper W Superscript upper T Baseline left-parenthesis
    upper W x prime plus b right-parenthesis plus c minus x StartAbsoluteValue EndAbsoluteValue
    Subscript 2 Superscript 2 Baseline right-bracket"><mrow><msub><mi>J</mi> <mtext>DAE</mtext></msub>
    <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo> <mo>|</mo> <mo>|</mo></mrow>
    <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi> <msup><mi>x</mi>
    <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>c</mi>
    <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn> <mn>2</mn></msubsup>
    <mrow><mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals 2 sigma Superscript 4 Baseline asterisk double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x comma x Sub
    Superscript prime Subscript right-parenthesis Baseline left-bracket StartFraction
    1 Over 2 sigma Superscript 4 Baseline EndFraction StartAbsoluteValue EndAbsoluteValue
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x StartAbsoluteValue EndAbsoluteValue Subscript 2 Superscript 2 Baseline
    right-bracket"><mrow><mo>=</mo> <mn>2</mn> <msup><mi>Ïƒ</mi> <mn>4</mn></msup>
    <mo>*</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>Ïƒ</mi> <mn>4</mn></msup></mrow></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn>
    <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals 2 sigma Superscript 4 Baseline asterisk double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x comma x Sub
    Superscript prime Subscript right-parenthesis Baseline left-bracket StartFraction
    1 Over 2 sigma Superscript 4 Baseline EndFraction StartAbsoluteValue EndAbsoluteValue
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x StartAbsoluteValue EndAbsoluteValue Subscript 2 Superscript 2 Baseline
    right-bracket"><mrow><mo>=</mo> <mn>2</mn> <msup><mi>Ïƒ</mi> <mn>4</mn></msup>
    <mo>*</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi> <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>Ïƒ</mi> <mn>4</mn></msup></mrow></mfrac> <mrow><mo>|</mo>
    <mo>|</mo></mrow> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msubsup><mrow><mi>x</mi><mo>|</mo><mo>|</mo></mrow> <mn>2</mn>
    <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: <math alttext="equals 2 sigma Superscript 4 Baseline asterisk double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x comma x Sub
    Superscript prime Subscript right-parenthesis Baseline left-bracket one-half StartAbsoluteValue
    EndAbsoluteValue StartFraction 1 Over sigma squared EndFraction left-parenthesis
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x prime right-parenthesis minus StartFraction 1 Over sigma squared
    EndFraction left-parenthesis x minus x prime right-parenthesis StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mo>=</mo>
    <mn>2</mn> <msup><mi>Ïƒ</mi> <mn>4</mn></msup> <mo>*</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mrow><mo>|</mo> <mo>|</mo></mrow> <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>-</mo>
    <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <msubsup><mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="equals 2 sigma Superscript 4 Baseline asterisk double-struck
    upper E Subscript p Sub Subscript sigma Subscript left-parenthesis x comma x Sub
    Superscript prime Subscript right-parenthesis Baseline left-bracket one-half StartAbsoluteValue
    EndAbsoluteValue StartFraction 1 Over sigma squared EndFraction left-parenthesis
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x prime right-parenthesis minus StartFraction 1 Over sigma squared
    EndFraction left-parenthesis x minus x prime right-parenthesis StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline right-bracket"><mrow><mo>=</mo>
    <mn>2</mn> <msup><mi>Ïƒ</mi> <mn>4</mn></msup> <mo>*</mo> <msub><mi>ğ”¼</mi> <mrow><msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow></mrow></msub> <mrow><mo>[</mo></mrow> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mrow><mo>|</mo> <mo>|</mo></mrow> <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>-</mo>
    <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <msubsup><mrow><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mrow><mo>]</mo></mrow></mrow></math>
- en: You may notice that our algebraic manipulation has led to the appearance of
    <math alttext="normal nabla Subscript x prime Baseline log p Subscript sigma Baseline
    left-parenthesis x prime vertical-bar x right-parenthesis"><mrow><msub><mi>âˆ‡</mi>
    <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> . All we need to do now is find a form
    for the unnormalized likelihood whose gradient with respect to *xâ€™* is <math alttext="StartFraction
    1 Over sigma squared EndFraction left-parenthesis upper W Superscript upper T
    Baseline left-parenthesis upper W x prime plus b right-parenthesis plus c minus
    x prime right-parenthesis"><mrow><mfrac><mn>1</mn> <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo> <msup><mi>W</mi> <mi>T</mi></msup> <mrow><mo>(</mo> <mi>W</mi>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mi>c</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯èƒ½ä¼šæ³¨æ„åˆ°ï¼Œæˆ‘ä»¬çš„ä»£æ•°æ“ä½œå¯¼è‡´äº† <math alttext="normal nabla Subscript x prime Baseline log
    p Subscript sigma Baseline left-parenthesis x prime vertical-bar x right-parenthesis"><mrow><msub><mi>âˆ‡</mi>
    <msup><mi>x</mi> <mo>'</mo></msup></msub> <mo form="prefix">log</mo> <msub><mi>p</mi>
    <mi>Ïƒ</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>|</mo>
    <mi>x</mi> <mo>)</mo></mrow></mrow></math> çš„å‡ºç°ã€‚ç°åœ¨æˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°ä¸€ä¸ªæœªå½’ä¸€åŒ–ä¼¼ç„¶çš„å½¢å¼ï¼Œå…¶ç›¸å¯¹äº *xâ€™*
    çš„æ¢¯åº¦ä¸º <math alttext="StartFraction 1 Over sigma squared EndFraction left-parenthesis
    upper W Superscript upper T Baseline left-parenthesis upper W x prime plus b right-parenthesis
    plus c minus x prime right-parenthesis"><mrow><mfrac><mn>1</mn> <msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mfrac> <mrow><mo>(</mo> <msup><mi>W</mi> <mi>T</mi></sup> <mrow><mo>(</mo>
    <mi>W</mi> <msup><mi>x</mi> <mo>'</mo></msup> <mo>+</mo> <mi>b</mi> <mo>)</mo></mrow>
    <mo>+</mo> <mi>c</mi> <mo>-</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>ã€‚
- en: As it turns out, if we define the unnormalized likelihood <math alttext="q Subscript
    theta Baseline left-parenthesis x prime right-parenthesis"><mrow><msub><mi>q</mi>
    <mi>Î¸</mi></msub> <mrow><mo>(</mo> <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math>
    to be <math alttext="minus StartFraction 1 Over sigma squared EndFraction left-parenthesis
    c Superscript upper T Baseline x minus one-half StartAbsoluteValue EndAbsoluteValue
    x StartAbsoluteValue EndAbsoluteValue Subscript 2 Superscript 2 Baseline plus
    sigma-summation Underscript j equals 1 Overscript d Endscripts softplus left-parenthesis
    upper W Subscript j Superscript upper T Baseline x plus b Subscript j Baseline
    right-parenthesis right-parenthesis"><mrow><mo>-</mo> <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mfrac> <mrow><mo>(</mo></mrow> <msup><mi>c</mi> <mi>T</mi></msup>
    <mi>x</mi> <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msubsup><mrow><mo>|</mo><mo>|</mo><mi>x</mi><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <mtext>softplus</mtext> <mrow><mo>(</mo> <msubsup><mi>W</mi>
    <mi>j</mi> <mi>T</mi></msubsup> <mi>x</mi> <mo>+</mo> <msub><mi>b</mi> <mi>j</mi></msub>
    <mo>)</mo></mrow> <mrow><mo>)</mo></mrow></mrow></math> and plug in this expression
    to the denoising score matching objective, we are left with an objective that
    is just <math alttext="StartFraction 1 Over 2 sigma Superscript 4 Baseline EndFraction
    upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis"><mrow><mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>Ïƒ</mi> <mn>4</mn></msup></mrow></mfrac> <msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
    . We refer you to Vincent 2011 to see why this is the case.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®è¯æ˜ï¼Œå¦‚æœæˆ‘ä»¬å®šä¹‰æœªå½’ä¸€åŒ–çš„ä¼¼ç„¶<math alttext="q Subscript theta Baseline left-parenthesis
    x prime right-parenthesis"><mrow><msub><mi>q</mi> <mi>Î¸</mi></msub> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>'</mo></msup> <mo>)</mo></mrow></mrow></math> ä¸º<math alttext="minus
    StartFraction 1 Over sigma squared EndFraction left-parenthesis c Superscript
    upper T Baseline x minus one-half StartAbsoluteValue EndAbsoluteValue x StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline plus sigma-summation Underscript
    j equals 1 Overscript d Endscripts softplus left-parenthesis upper W Subscript
    j Superscript upper T Baseline x plus b Subscript j Baseline right-parenthesis
    right-parenthesis"><mrow><mo>-</mo> <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo></mrow> <msup><mi>c</mi> <mi>T</mi></msup> <mi>x</mi> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msubsup><mrow><mo>|</mo><mo>|</mo><mi>x</mi><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <mtext>softplus</mtext> <mrow><mo>(</mo> <msubsup><mi>W</mi>
    <mi>j</mi> <mi>T</mi></msubsup> <mi>x</mi> <mo>+</mo> <msub><mi>b</mi> <mi>j</mi></msub>
    <mo>)</mo></mrow> <mrow><mo>)</mo></mrow></mrow></math> å¹¶å°†æ­¤è¡¨è¾¾å¼æ’å…¥å»å™ªå¾—åˆ†åŒ¹é…ç›®æ ‡ï¼Œæˆ‘ä»¬å¾—åˆ°çš„ç›®æ ‡åªæ˜¯<math
    alttext="StartFraction 1 Over 2 sigma Superscript 4 Baseline EndFraction upper
    J Subscript DAE Baseline left-parenthesis theta right-parenthesis"><mrow><mfrac><mn>1</mn>
    <mrow><mn>2</mn><msup><mi>Ïƒ</mi> <mn>4</mn></msup></mrow></mfrac> <msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
    ã€‚æˆ‘ä»¬å»ºè®®æ‚¨å‚è€ƒVincent 2011å¹´çš„åŸå› ã€‚
- en: Optimizing this new objective with respect to <math alttext="theta"><mi>Î¸</mi></math>
    is no different from optimizing a denoising autoencoder. This is because <math
    alttext="sigma"><mi>Ïƒ</mi></math> is a positive constant and has no dependence
    on <math alttext="theta"><mi>Î¸</mi></math> , thus only scaling the magnitude of
    the resulting gradient rather than affecting its direction. In summary, we have
    found that training a denoising AE is the same as optimizing the denoising score
    matching objective, where the unnormalized likelihood takes the form specified
    in the previous paragraph. More simply, the weights of a trained denoising AE
    would be the same as those of an unnormalized likelihood specified by <math alttext="minus
    StartFraction 1 Over sigma squared EndFraction left-parenthesis c Superscript
    upper T Baseline x minus one-half StartAbsoluteValue EndAbsoluteValue x StartAbsoluteValue
    EndAbsoluteValue Subscript 2 Superscript 2 Baseline plus sigma-summation Underscript
    j equals 1 Overscript d Endscripts softplus left-parenthesis upper W Subscript
    j Superscript upper T Baseline x plus b Subscript j Baseline right-parenthesis
    right-parenthesis"><mrow><mo>-</mo> <mfrac><mn>1</mn> <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo></mrow> <msup><mi>c</mi> <mi>T</mi></msup> <mi>x</mi> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msubsup><mrow><mo>|</mo><mo>|</mo><mi>x</mi><mo>|</mo><mo>|</mo></mrow>
    <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mo>âˆ‘</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>d</mi></msubsup> <mtext>softplus</mtext> <mrow><mo>(</mo> <msubsup><mi>W</mi>
    <mi>j</mi> <mi>T</mi></msubsup> <mi>x</mi> <mo>+</mo> <msub><mi>b</mi> <mi>j</mi></msub>
    <mo>)</mo></mrow> <mrow><mo>)</mo></mrow></mrow></math> and trained via denoising
    score matching.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–è¿™ä¸ªæ–°ç›®æ ‡å…³äº<math alttext="theta"><mi>Î¸</mi></math> çš„æƒ…å†µä¸ä¼˜åŒ–å»å™ªè‡ªç¼–ç å™¨æ²¡æœ‰åŒºåˆ«ã€‚è¿™æ˜¯å› ä¸º<math
    alttext="sigma"><mi>Ïƒ</mi></math> æ˜¯ä¸€ä¸ªæ­£å¸¸æ•°ï¼Œä¸ä¾èµ–äº<math alttext="theta"><mi>Î¸</mi></math>ï¼Œå› æ­¤åªæ˜¯ç¼©æ”¾æ¢¯åº¦çš„å¹…åº¦è€Œä¸å½±å“å…¶æ–¹å‘ã€‚æ€»ä¹‹ï¼Œæˆ‘ä»¬å‘ç°è®­ç»ƒå»å™ªè‡ªç¼–ç å™¨ä¸ä¼˜åŒ–å»å™ªå¾—åˆ†åŒ¹é…ç›®æ ‡æ˜¯ç›¸åŒçš„ï¼Œå…¶ä¸­æœªå½’ä¸€åŒ–çš„ä¼¼ç„¶é‡‡ç”¨å‰ä¸€æ®µæŒ‡å®šçš„å½¢å¼ã€‚æ›´ç®€å•åœ°è¯´ï¼Œè®­ç»ƒå¥½çš„å»å™ªè‡ªç¼–ç å™¨çš„æƒé‡å°†ä¸é€šè¿‡å»å™ªå¾—åˆ†åŒ¹é…æŒ‡å®šçš„æœªå½’ä¸€åŒ–ä¼¼ç„¶çš„æƒé‡ç›¸åŒã€‚
- en: 'All we would need to do to perform generative modeling using a denoising AE
    is:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ä½¿ç”¨å»å™ªè‡ªç¼–ç å™¨æ‰§è¡Œç”Ÿæˆå»ºæ¨¡ï¼Œæˆ‘ä»¬éœ€è¦åšçš„æ˜¯ï¼š
- en: Fully train the denoising AE by minimizing <math alttext="upper J Subscript
    DAE Baseline left-parenthesis theta right-parenthesis"><mrow><msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é€šè¿‡æœ€å°åŒ–<math alttext="upper J Subscript DAE Baseline left-parenthesis theta right-parenthesis"><mrow><msub><mi>J</mi>
    <mtext>DAE</mtext></msub> <mrow><mo>(</mo> <mi>Î¸</mi> <mo>)</mo></mrow></mrow></math>
    æ¥å®Œå…¨è®­ç»ƒå»å™ªè‡ªç¼–ç å™¨ã€‚
- en: For a given <math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math> , calculate its score
    by evaluating <math alttext="StartFraction 1 Over sigma squared EndFraction left-parenthesis
    decode left-parenthesis encode left-parenthesis x Superscript left-parenthesis
    i right-parenthesis Baseline right-parenthesis right-parenthesis minus x Superscript
    left-parenthesis i right-parenthesis Baseline right-parenthesis"><mrow><mfrac><mn>1</mn>
    <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac> <mrow><mo>(</mo> <mtext>decode</mtext>
    <mrow><mo>(</mo> <mtext>encode</mtext> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math> .
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¯¹äºç»™å®šçš„<math alttext="x Superscript left-parenthesis i right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></math>ï¼Œé€šè¿‡è¯„ä¼°<math alttext="StartFraction
    1 Over sigma squared EndFraction left-parenthesis decode left-parenthesis encode
    left-parenthesis x Superscript left-parenthesis i right-parenthesis Baseline right-parenthesis
    right-parenthesis minus x Superscript left-parenthesis i right-parenthesis Baseline
    right-parenthesis"><mrow><mfrac><mn>1</mn> <msup><mi>Ïƒ</mi> <mn>2</mn></msup></mfrac>
    <mrow><mo>(</mo> <mtext>decode</mtext> <mrow><mo>(</mo> <mtext>encode</mtext>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></mrow></math>æ¥è®¡ç®—å…¶åˆ†æ•°ã€‚
- en: Sample <math alttext="epsilon"><mi>Ïµ</mi></math> from *N(0,I).*
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»*N(0,I)*ä¸­æŠ½å–æ ·æœ¬<math alttext="epsilon"><mi>Ïµ</mi></math>ã€‚
- en: Plug in the results of 2 and 3 into the Langevin dynamics equation to obtain
    the next sample <math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    .
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†2å’Œ3çš„ç»“æœä»£å…¥LangevinåŠ¨åŠ›å­¦æ–¹ç¨‹ä¸­ï¼Œå¾—åˆ°ä¸‹ä¸€ä¸ªæ ·æœ¬<math alttext="x Superscript left-parenthesis
    i plus 1 right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>ã€‚
- en: Repeat steps 2 through 4 with <math alttext="x Superscript left-parenthesis
    i plus 1 right-parenthesis"><msup><mi>x</mi> <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>
    .
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é‡å¤æ­¥éª¤2åˆ°4ï¼Œä½¿ç”¨<math alttext="x Superscript left-parenthesis i plus 1 right-parenthesis"><msup><mi>x</mi>
    <mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup></math>ã€‚
- en: Though weâ€™ve gotten around the issue of needing to calculate second-order gradients
    by using this method, there is still the issue of being able to sample only from
    the noisy approximation of *p(x)*. More recent work builds off of concepts from
    both implicit score matching and denoising score matching to achieve even stronger
    and more realistic generative capabilities. We highly recommend you explore the
    literature further, as most of the prerequisite material has been covered in these
    sections.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡æˆ‘ä»¬é€šè¿‡ä½¿ç”¨è¿™ç§æ–¹æ³•è§£å†³äº†éœ€è¦è®¡ç®—äºŒé˜¶æ¢¯åº¦çš„é—®é¢˜ï¼Œä½†ä»ç„¶å­˜åœ¨åªèƒ½ä»*p(x)*çš„å˜ˆæ‚è¿‘ä¼¼ä¸­è¿›è¡Œé‡‡æ ·çš„é—®é¢˜ã€‚æœ€è¿‘çš„å·¥ä½œå€Ÿé‰´äº†éšå¼åˆ†æ•°åŒ¹é…å’Œå»å™ªåˆ†æ•°åŒ¹é…çš„æ¦‚å¿µï¼Œä»¥å®ç°æ›´å¼ºå¤§å’Œæ›´é€¼çœŸçš„ç”Ÿæˆèƒ½åŠ›ã€‚æˆ‘ä»¬å¼ºçƒˆå»ºè®®æ‚¨è¿›ä¸€æ­¥æ¢ç´¢æ–‡çŒ®ï¼Œå› ä¸ºè¿™äº›éƒ¨åˆ†å·²ç»æ¶µç›–äº†å¤§éƒ¨åˆ†å…ˆå†³æ¡ä»¶ææ–™ã€‚
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: In summary, we have learned a great deal about generative models. We covered
    the motivation and mathematics behind GANs, VAEs, and a few forms of score matching,
    and even implemented a VAE from scratch. We also learned about the similarities
    and differences between these methods. For example, a GAN implicitly models a
    complex distribution that we can sample from via its generator, while a VAE explicitly
    learns distributions but is slightly more restrictive in the complexity of distributions
    it can model. Implicit score matching, similarly to GANs, allowed us to sample
    from complex distributions via Langevin dynamics (without the use of an additional
    noise distribution *p(z))*, but having to compute second-order gradients led us
    to the development of the denoising score matching and its connection with pre-existing
    denoising AEs. Additionally, VAEs took on the strongest probabilistic modeling
    approach of the three by defining a set of latent variables and explicitly learning
    an approximate posterior, given an input example, and a likelihood function, given
    a setting of latent variables. In contrast, for GANs, the additional variable
    *zâ€™s* purpose is solely as an intermediate for sampling. Although all of these
    models tackle generative modeling from distinct perspectives and motivations,
    they have all produced strong results and have laid a solid groundwork for current
    and future research.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ä¹‹ï¼Œæˆ‘ä»¬å·²ç»å­¦åˆ°äº†å¾ˆå¤šå…³äºç”Ÿæˆæ¨¡å‹çš„çŸ¥è¯†ã€‚æˆ‘ä»¬æ¶µç›–äº†GANsã€VAEsä»¥åŠä¸€äº›å½¢å¼çš„åˆ†æ•°åŒ¹é…èƒŒåçš„åŠ¨æœºå’Œæ•°å­¦ï¼Œç”šè‡³ä»å¤´å¼€å§‹å®ç°äº†ä¸€ä¸ªVAEã€‚æˆ‘ä»¬è¿˜äº†è§£äº†è¿™äº›æ–¹æ³•ä¹‹é—´çš„ç›¸ä¼¼ä¹‹å¤„å’Œä¸åŒä¹‹å¤„ã€‚ä¾‹å¦‚ï¼ŒGANéšå¼åœ°å»ºæ¨¡äº†ä¸€ä¸ªå¤æ‚çš„åˆ†å¸ƒï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å…¶ç”Ÿæˆå™¨è¿›è¡Œé‡‡æ ·ï¼Œè€ŒVAEæ˜ç¡®åœ°å­¦ä¹ åˆ†å¸ƒï¼Œä½†åœ¨å…¶å¯ä»¥å»ºæ¨¡çš„åˆ†å¸ƒå¤æ‚æ€§æ–¹é¢ç•¥å¾®å—é™ã€‚éšå¼åˆ†æ•°åŒ¹é…ä¸GANç±»ä¼¼ï¼Œå…è®¸æˆ‘ä»¬é€šè¿‡LangevinåŠ¨åŠ›å­¦ä»å¤æ‚çš„åˆ†å¸ƒä¸­è¿›è¡Œé‡‡æ ·ï¼ˆè€Œæ— éœ€ä½¿ç”¨é¢å¤–çš„å™ªå£°åˆ†å¸ƒ*p(z)ï¼‰ï¼Œä½†æ˜¯å¿…é¡»è®¡ç®—äºŒé˜¶æ¢¯åº¦å¯¼è‡´æˆ‘ä»¬å¼€å‘äº†å»å™ªåˆ†æ•°åŒ¹é…ä»¥åŠå…¶ä¸ç°æœ‰å»å™ªAEçš„è”ç³»ã€‚æ­¤å¤–ï¼ŒVAEé€šè¿‡å®šä¹‰ä¸€ç»„æ½œåœ¨å˜é‡å¹¶æ˜ç¡®å­¦ä¹ è¿‘ä¼¼åéªŒï¼ˆç»™å®šè¾“å…¥ç¤ºä¾‹ï¼‰å’Œä¼¼ç„¶å‡½æ•°ï¼ˆç»™å®šæ½œåœ¨å˜é‡è®¾ç½®ï¼‰è€Œé‡‡å–äº†ä¸‰ç§æ–¹æ³•ä¸­æœ€å¼ºå¤§çš„æ¦‚ç‡å»ºæ¨¡æ–¹æ³•ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¯¹äºGANsï¼Œé™„åŠ å˜é‡*z*çš„ç›®çš„ä»…ä»…æ˜¯ä½œä¸ºé‡‡æ ·çš„ä¸­é—´å˜é‡ã€‚å°½ç®¡æ‰€æœ‰è¿™äº›æ¨¡å‹ä»ä¸åŒçš„è§’åº¦å’ŒåŠ¨æœºæ¥è§£å†³ç”Ÿæˆå»ºæ¨¡é—®é¢˜ï¼Œä½†å®ƒä»¬éƒ½å–å¾—äº†å¼ºå¤§çš„ç»“æœï¼Œå¹¶ä¸ºå½“å‰å’Œæœªæ¥çš„ç ”ç©¶å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚
- en: ^([1](ch10.xhtml#idm45934165113648-marker)) Goodfellow et al. â€œGenerative Adversarial
    Networks.â€ *arXiv Preprint arXiv*:1406.2661\. 2014.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#idm45934165113648-marker)) Goodfellowç­‰äººã€‚â€œç”Ÿæˆå¯¹æŠ—ç½‘ç»œã€‚â€*arXivé¢„å°æœ¬arXiv*:1406.2661ã€‚2014å¹´ã€‚
- en: ^([2](ch10.xhtml#idm45934168472352-marker)) Kingma et al. â€œAuto-Encoding Variational
    Bayes.â€ *arXiv Preprint arXiv*:1312.6114\. 2014.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.xhtml#idm45934168472352-marker)) Kingmaç­‰äººã€‚â€œè‡ªåŠ¨ç¼–ç å˜åˆ†è´å¶æ–¯ã€‚â€*arXivé¢„å°æœ¬arXiv*:1312.6114ã€‚2014å¹´ã€‚
