- en: Chapter 7\. Integrating Databases into AI Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll integrate a database to your current API service to
    store and retrieve user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes basic experience working with databases and Structured
    Query Language (SQL), so it won’t cover every aspect of SQL programming and database
    workflows. Instead, you will learn the higher-level database concepts, development
    workflows, and best practices when integrating databases to your FastAPI applications
    that interact with GenAI models such as LLMs.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this, you will learn the role of relational (SQL) versus nonrelational
    (noSQL) databases in application development and will be able to confidently select
    the right database for your use case. Next, you will understand more about the
    features of relational databases and associated tooling such as object relational
    mappers (ORMs) and database migration tools. Finally, as a hands-on exercise,
    you will integrate a database to your existing application using SQLAlchemy and
    Alembic, to store and retrieve user conversations with an LLM.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will feel more confident in selecting, configuring,
    and resolving database-related issues within your GenAI applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Role of a Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building backend services, you often require a database to persist application
    state and store user data. In other cases, your application won’t need a database,
    and you shouldn’t try to add one since any database integration can significantly
    increase the complexity of your services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are several cases for which you could forgo using a database:'
  prefs: []
  type: TYPE_NORMAL
- en: Your application can start from a fresh state on startup for each new user session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recalculating the application data is straightforward and resource-efficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application data is small enough to be stored in memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your application is tolerant to data losses due to various reasons such as server
    errors, restarts, or other unexpected events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Different user sessions or application instances won’t need to share data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data you need can directly be fetched from external systems, GenAI models,
    and other application APIs, and not your own database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is happy to wait for data to be recomputed for each new session or
    action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your service requirements allow for the data to be persisted in files on disk,
    the browser storage, or an external cloud storage instead of a database. With
    these alternatives, your services can tolerate that data storage and retrieval
    won’t be as reliable and efficient as a database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’re building a proof-of-concept and need to avoid project delays or complexity
    at all costs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An example application that matches the previous criteria is a *GenAI image
    generator* only used for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you won’t need to store any generated images, and you can always
    restart or use the application at any time from a fresh state. Additionally, the
    application doesn’t need to know who the user is. Plus, there is no need to share
    data between sessions. Furthermore, if there is a server error, the impact of
    data loss is minimal since you can regenerate a new image on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are at least a handful of cases where you won’t need a
    database to build your own GenAI services. However, you may be wondering when
    you do really need a database.
  prefs: []
  type: TYPE_NORMAL
- en: To determine when a database is necessary, you will want to understand the role
    of databases. In short, you can use them to store, organize, and manage data in
    an efficient format allowing for easy retrieval, manipulation, and analysis. Additionally,
    databases ship with critical features such as restore/backup, concurrent access
    management, indexing, caching, and role-based access control, alongside many others,
    that make them an irreplaceable component of any services that displays, produces
    and consumes data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine in significant detail the inner workings
    of databases, with an emphasis on relational databases that practical examples
    of this chapter will focus on. With a detailed understanding of database internals,
    you can then design fully optimized and production-ready GenAI APIs. This will
    then allow you to delegate heavy workloads to the database engine, which is specifically
    designed for data-heavy tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Database Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand when to leverage a database, let’s learn more about
    different databases you can use and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can construct a mental model of databases by placing them into two main
    categories: *relational* (SQL) and *nonrelational* (NoSQL) databases.'
  prefs: []
  type: TYPE_NORMAL
- en: The *SQL* versus *NoSQL* categorization is based on the fact that relational
    databases use various dialects of SQL as their main query language, whereas nonrelational
    databases often come packaged with their own specialized query languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'With both categories of database systems, you can adopt a mental model of how
    such systems are structured. Both SQL and NoSQL database systems often consist
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A *server* at the highest level, which hosts the entire database infrastructure
    and consumes system resources (CPU, RAM, and storage).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more *databases* within the server, which act as *logical container(s)*
    that hold related data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more *schemas* within a database (depending on the database software),
    which serve as a *blueprint* that defines the complete structure of the data and
    various structural objects such as indexes, logical constraints, triggers, etc.
    However, NoSQL database servers may not use strict schemas, unlike relational
    databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more *tables* (SQL) or *collections* (NoSQL) created inside the database
    (as part of a schema), which group related data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more *items* within each collection (as documents) or table (as rows),
    which represent specific records or entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 7-1](#database_server_breakdown) visualizes the aforementioned breakdown.'
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0701](assets/bgai_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Database system breakdown
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Adopting a mental model as shown in [Figure 7-1](#database_server_breakdown)
    will help you navigate the ever-increasing variety of database systems as you
    can expect similar underlying mechanisms to be present. This familiarity will
    hopefully reduce your learning curve in adopting different database systems.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s briefly review both SQL and NoSQL database systems so that you have
    a better understanding of their use cases, features, and limitations when building
    APIs and services.
  prefs: []
  type: TYPE_NORMAL
- en: To help you with creating a mental model of both relational and nonrelational
    databases, take a look at [Figure 7-2](#db_types).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0702](assets/bgai_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Database types
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also use the summary in [Table 7-1](#db_comparison) as a reference of
    the database types that will be covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Comparison of databases
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Data model | Examples | Use cases |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Key-value stores | Key-value pairs | Redis, DynamoDB, Memcached | Caching,
    session management |'
  prefs: []
  type: TYPE_TB
- en: '| Graph stores | Nodes and edges | Neo4j, Amazon Neptune, ArangoDB | Social
    networks, recommendation engines, fraud detection |'
  prefs: []
  type: TYPE_TB
- en: '| Document stores | Documents | MongoDB, CouchDB, Amazon DocumentDB | Content
    management, e-commerce, real-time analytics |'
  prefs: []
  type: TYPE_TB
- en: '| Vector stores | High-dimensional vectors | Pinecone, Weaviate | Recommendation
    systems, image/text search, ML model storage |'
  prefs: []
  type: TYPE_TB
- en: '| Wide-column family stores | Tables with rows and columns | Apache Cassandra,
    HBase, ScyllaDB | Time-series data, real-time analytics, logging |'
  prefs: []
  type: TYPE_TB
- en: Now that you have a broad overview of every common relational and nonrelational
    database, you can visualize a real-world GenAI service that makes use of these
    databases together.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re building a RAG-enabled LLM service that can talk to a knowledge
    base. The documents in this knowledge base are related to each other, so you decide
    to implement a RAG graph to capture a richer context. To implement a RAG graph,
    you integrate your service with a graph-based database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to retrieve relevant chunks of documents, you also need to embed them in
    a vector database. As part of this, you also need a relational database to monitor
    usage, and store user data and conversation histories.
  prefs: []
  type: TYPE_NORMAL
- en: Since the users may ask common questions, you also decide to cache the LLM responses
    by generating several outputs in advance. Therefore, you also integrate a key-value
    store to your service.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you want to give administrators control over system prompts with the
    ability to version-control prompts. So, you add a content management system as
    a prompt manager to your solution. However, since the prompt templates can often
    change, you also decide to integrate a document database.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, each database type ends up solving a particular problem in your
    complex RAG-enabled application. One stores your backend and user data, another
    captures the document relationships, one stores your document embeddings, another
    helps store flexible schemas of your prompts, and the last one helps you to return
    cached outputs.
  prefs: []
  type: TYPE_NORMAL
- en: You can see a visualization of the application architecture in [Figure 7-3](#rag_graph_architecture)
    to understand how these databases can work together to realize a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0703](assets/bgai_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Using various database types together
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you understand how your GenAI services can integrate with a variety
    of databases, in the next section, we will focus on adding a relational database
    to your service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project: Storing User Conversations with an LLM in a Relational Database'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we covered the core database concepts relevant to adding
    data persistence to your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will integrate a relational database to your GenAI service
    so that you can store user conversation histories with an LLM in the database.
    As part of this work, you will also learn the best practices, tooling, and development
    workflow to manage schema changes and data migrations in your database.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we will install a Postgres relational database that is open
    source, free, and battle-tested and is in use by many enterprises. To get started,
    let’s download and run the Postgres container using `docker run`, as shown in
    [Example 7-1](#postgres).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. Download and run the Postgres database container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Download and run the latest `postgres` relational database image from in the
    Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `postgres` image and then expose and map container port `5432` to the
    same ports on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the container with several environmental variables that specify the default
    database administrator username and password, database name, and DBMS data location
    within the container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Mount the Postgres database storage to the host machine filesystem at a `dbstorage`
    folder in the present working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s install the `sqlalchemy`, `alembic`, and `psycopg3` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These battle-tested packages allow you to directly communicate with the Postgres
    relational database via Python. `psycopg3` is a popular PostgreSQL database adapter
    for Python, and SQLAlchemy is SQL toolkit and ORM that allows you to run SQL queries
    against your database in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `alembic` package is a *database migration tool* created by the
    SQLAlchemy developers for usage with the SQLAlchemy. The data migration workflow
    is like the Git version control system but for your database schemas. It allows
    you to manage the changes and updates to your schemas so that you avoid any data
    corruptions, track changes over time, and revert any changes as required.
  prefs: []
  type: TYPE_NORMAL
- en: Defining ORM Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to query your database in Python is to define your ORM models
    with SQLAlchemy classes, as shown in [Example 7-2](#sqlalchemy_models). You can
    use the data schemas from the ERD diagram mentioned in [Figure 8-4](ch08.html#erd).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will add the `user` table in the next chapter when implementing authentication
    and authorization mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. Defining database ORM models
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a declarative base class for creating SQLAlchemy models for its ORM
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `Conversation` model specifying the table columns, primary key, and
    secondary indexes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `mapped_column()` to derive the column type from the type hint given
    to `Mapped`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Index the `model_type` in case you want faster filtering of conversations by
    model type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_integrating_databases_into_ai_services_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Specify defaults and update operations for datetime columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_integrating_databases_into_ai_services_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Indicate that all orphan messages must be deleted if a conversation is deleted
    through a `CASCADE DELETE` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_integrating_databases_into_ai_services_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `Message` model specifying the table columns, primary key, secondary
    indexes, table relationships, and foreign keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_integrating_databases_into_ai_services_CO2-9)'
  prefs: []
  type: TYPE_NORMAL
- en: The `messages` table will contain both the LLM prompts and responses, usage
    tokens, and costs alongside the status codes and success states.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_integrating_databases_into_ai_services_CO2-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Specify `Mapped[int | None]` to declare an optional typing so the column will
    allow `NULL` values (i.e., `nullable=True`).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your data models defined, you can create a connection to the database
    to create each table with the specified configurations. To achieve this, you will
    need to create a *database engine* and implement *session management*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Database Engine and Session Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 7-3](#sqlalchemy_engine) shows how to create a SQLAlchemy engine using
    your Postgres database connection string. Once created, you can use the engine
    and the `Base` class to create tables for each of your data models.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The SQLAlchemy’s `create_all()` method in [Example 7-3](#sqlalchemy_engine)
    can only create tables in the database but not modify existing tables. This workflow
    is useful only if you’re prototyping and happy to reset the database schemas with
    new tables on each run.
  prefs: []
  type: TYPE_NORMAL
- en: For production environments, you should use a database migration tool such as
    `alembic` to update your database schemas and to avoid unintended data loss. You
    will learn about the database migration workflow shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. Create the SQLAlchemy database engine
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Postgres databases, the connection string is defined using the following
    template: `*<driver>*://*<username>*:*<password>*@*<origin>*/*<database>*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an async database engine using the database connection string. Turn on
    debug logging with `echo=True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Drop any existing tables and then create all database tables using the defined
    SQLAlchemy models in [Example 7-3](#sqlalchemy_engine).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Dispose of the database engine during the server shutdown process. Any code
    after the `yield` keyword inside the FastAPI’s `lifespan` context manager is executed
    when server shutdown is requested.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For clarity, environment variables and secrets such as database connection strings
    are hard-coded in every code example.
  prefs: []
  type: TYPE_NORMAL
- en: In production scenarios, never hard-code secrets and environment variables.
    Leverage environment files, secret managers, and tools like Pydantic Settings
    to handle application secrets and variables.
  prefs: []
  type: TYPE_NORMAL
- en: With the engine created, you can now implement a factory function for creating
    sessions to the database. Session factory is a design pattern that allows you
    to open, interact with, and close database connections across your services.
  prefs: []
  type: TYPE_NORMAL
- en: Since you may reuse a session, you can use FastAPI’s dependency injection system
    to cache and reuse sessions across each request runtime, as shown in [Example 7-4](#sqlalchemy_session).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. Creating a database session FastAPI dependency
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an async database session factory bound to the database engine you created
    previously to asynchronously connect to your Postgres instance. Disable automatic
    committing of transactions with `autocommit=false` and automatic flushing of changes
    to the database with `autoflush=False`. Disabling both behaviors gives you more
    control, helps prevent unintended data updates, and allows you to implement more
    robust transaction management.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a dependency function to reuse and inject across your FastAPI app into
    route controller functions. Since the function uses the `yield` keyword within
    the `async with`, it is considered an async context manager. FastAPI will internally
    decorate the `get_db_session` as context manager when it is used as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the database session factory to create an async session. The context manager
    helps to manage the database session lifecycle such as opening, interacting with,
    and closing the database connections in each session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Yield the database session to the caller of the `get_db_session` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_integrating_databases_into_ai_services_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If there are any exceptions, roll back the transaction and reraise the exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_integrating_databases_into_ai_services_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, close the database session at the end to release any resources
    that it holds.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_integrating_databases_into_ai_services_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare an annotated database session dependency that can be reused across different
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can create a database session from any FastAPI route via dependency
    injection, let’s implement the create, read, update, and delete (CRUD) endpoints
    for the conversations resource.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD Endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As FastAPI relies on Pydantic to serialize and validate incoming and outgoing
    data, before implementing CRUD endpoints, you’ll need to map database entities
    to Pydantic models. This avoids tightly coupling your API schema with your database
    models to give you the freedom and flexibility in developing your API and databases
    independent of each other.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow [Example 7-5](#sqlalchemy_pydantic) to define your CRUD schemas.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5\. Declaring Pydantic API schemas for conversation endpoints
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the Pydantic model to read and validate attributes of other models like
    SQLAlchemy, which is often used in Pydantic when working with database models.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create separate Pydantic models based on the base model for different use cases
    such as conversation record creation and update, or data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Having to declare Pydantic and SQLAlchemy models may feel like code duplication
    but will allow you to implement your data access layer however you like.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you want to avoid any code duplication, you can leverage the
    `sqlmodel` package, which integrates Pydantic with SQLAlchemy, removing much of
    the code duplication. However, bear in mind that `sqlmodel` may not be ideal for
    production due to limited flexibility and support for advanced use cases with
    SQLAlchemy. Therefore, you may want to use separate Pydantic and SQLAlchemy models
    for complex applications.^([1](ch07.html#id951))
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the SQLAlchemy and Pydantic models, you can start developing
    your CRUD API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing CRUD endpoints, you should try to leverage FastAPI dependencies
    as much as you can to reduce database round-trips. For instance, when retrieving,
    updating, and deleting records, you need to check in with the database that a
    record exists using its ID.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement a record retrieval function to use a dependency across your
    get, update, and delete endpoints, as shown in [Example 7-6](#sqlalchemy_endpoints).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bear in mind that FastAPI can only cache the output of the `get_conversation`
    dependency within a single request and not across multiple requests.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-6\. Implementing resource-based CRUD endpoints for the `conversations`
    table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a dependency to check if the conversation record exists. Raise a 404
    `HTTPException` if a record is not found; otherwise, return the retrieved record.
    This dependency can be reused across several CRUD endpoints through dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Begin the async session within an async context manager during each request.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: When listing records, it’s more efficient to retrieve only a subset of records.
    By default, SQLAlchemy ORM returns a subset of most recent records in the database,
    but you can use the `.offset(skip)` and `.limit(take)` chained methods to retrieve
    any subset of records.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Pydantic model from a SQLAlchemy model using `model_validate()`. Raises
    a `ValidationError` if the SQLAlchemy object passed can’t be created or doesn’t
    pass Pydantic’s data validation checks.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_integrating_databases_into_ai_services_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: For operations that mutate a record (i.e., create, update, and delete), commit
    the transaction then send the refreshed record to the client, except for the successful
    delete operation that should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the controller logic is simplified through this dependency injection
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, pay attention to success status codes you should to send to the
    client. Successful retrieval operations should return 200, while record creation
    operations return 201, updates return 202, and deletions return 204.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have a resource-based RESTful API that you can use
    to perform CRUD operations on your `conversations` table.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can implement CRUD endpoints, let’s refactor the existing code
    examples to use the *repository and services* design pattern you learned about
    in [Chapter 2](ch02.html#ch02). With this design pattern, you can abstract the
    database operations to achieve a more modular, maintainable, and testable codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Repository and Services Design Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *repository* is a design pattern that mediates the business logic of your
    application and the database access layer—for instance, via an ORM. It contains
    several methods for performing CRUD operations in the database layer.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html#ch02), you first saw [Figure 7-4](#onion), which showed
    where the repositories sit within the onion/layered application architecture when
    working with a database.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0704](assets/bgai_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. The repository pattern within the onion/layered application architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To implement a repository pattern, you can use an *abstract interface*, which
    enforces certain constraints on how you define your specific repository classes
    as you can see in [Example 7-7](#sqlalchemy_repository).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’ve never used *abstract* classes, they’re classes that can’t be instantiated
    on their own. Abstract classes can contain methods without implementation that
    its subclasses must implement.
  prefs: []
  type: TYPE_NORMAL
- en: A concrete class is one that inherits an abstract class and implements each
    of its abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-7\. Implementing a repository abstract interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the abstract `Repository` interface with several CRUD-related abstract
    method signatures that subclasses must implement. If an abstract method is not
    implemented in a concrete subclass, a `NotImplementedError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a `Repository` class, you declare subclasses for each of your
    tables to define how database operations must be performed following the CRUD-based
    methods. For instance, to perform CRUD operations on the conversation records
    in the database, you can implement a concrete `ConversationRepository` class,
    as shown in [Example 7-8](#sqlalchemy_conversation_repository).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-8\. Implementing the conversation repository using the abstract repository
    interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Inherit the abstract `Repository` interface and implement each of its methods
    while adhering to the method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: You have now moved the database logic for conversations into the `ConversationRepository`.
    This means you can now import this class into your route controller functions
    and start using it right away.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to your `main.py` file and refactor your route controllers to use the
    `ConversationRepository`, as shown in [Example 7-9](#sqlalchemy_conversation_repository_endpoints).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-9\. Refactoring the conversation CRUD endpoints to use the repository
    pattern
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Place conversation CRUD routes on a separate API router and include on the FastAPI
    application for modular API design.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Refactor conversation CRUD routes to use the repository pattern for more readable
    controller implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Do you notice how cleaner your route controllers appear now that the database
    logic has been abstracted within the `ConversationRepository` class?
  prefs: []
  type: TYPE_NORMAL
- en: You can take this approach one step further and implement a service pattern
    as well. A *service* pattern is an extension of the repository pattern that encapsulates
    the business logic and operations in a higher layer. These higher-level operations
    often require more complex queries and a sequence of CRUD operations to be performed
    to implement the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you can implement a `ConversationService` to fetch messages related
    to a conversation or a specific user (see [Example 7-10](#sqlalchemy_conversation_service)).
    Since it extends a `ConversationRepository`, you can still access the lower-level
    data access CRUD methods such as `list`, `get`, `create`, `update`, and `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: Once again you can go back to your controllers and replace references to the
    `ConversationRepository` with the `ConversationService` instead. Additionally,
    you can use the same service to add a new endpoint for fetching messages within
    a single conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-10\. Implementing the conversation services pattern
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new endpoint to list messages of a conversation using the conversation
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a fully working RESTful API for interacting with your conversation
    data following the repository and service patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’re more familiar with the repository and services pattern, you
    can try implementing CRUD endpoints for the `messages` table.
  prefs: []
  type: TYPE_NORMAL
- en: When using the repository and service patterns, be mindful that you avoid tightly
    coupling your services to specific repository implementation and not overload
    your services with many responsibilities. Keep repositories focused on data access
    and manipulation and avoid placing business logic in them.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to handle database transactions and exceptions properly, especially
    when performing multiple related operations. Also, consider performance implications
    of your queries such as including many JOINs, and optimize queries where you can.
  prefs: []
  type: TYPE_NORMAL
- en: Good practice is to use consistent naming conventions for your methods and classes
    and to avoid hard-coding configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more aspect of the database development workflow that we need to
    address next. That is managing ever-changing database schemas, in particular in
    collaborative teams where multiple people are working on the same database both
    in development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Database Schemas Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must have noticed that in [Example 7-3](#sqlalchemy_engine) you are deleting
    and re-creating your database tables every time you start your FastAPI server.
    This is acceptable for development workflows during the prototyping stage, but
    not at all when you need to deploy your services in production with active users.
    You can’t reset your database from scratch every time you update your database
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: You also will probably need a way to revert changes if something breaks or if
    you decide to roll back certain features. To achieve this, you can use a database
    migration tool such as Alembic that is designed to work seamlessly with the SQLAlchemy
    ORM.
  prefs: []
  type: TYPE_NORMAL
- en: Alembic allows you to version control your database schemas the same way that
    tools like Git can help you version control your code. They’re extremely useful
    when you’re working in a team with multiple application environments and need
    to keep track of changes or revert updates as needed.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you must first install `alembic` via `pip` and then initialize
    it by running [Example 7-11](#alembic_init) at the root of your FastAPI project.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-11\. Initializing an Alembic environment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Alembic will create its environment within the `alembic` folder with several
    files and a `versions` directory, as shown in [Example 7-12](#alembic_dir).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-12\. Alembic environment within your project root directory
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: An environment file for specifying target schema and database connections
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A directory for holding *migrations* files, which specify the instructions on
    how to update or revert the database schema
  prefs: []
  type: TYPE_NORMAL
- en: Once the Alembic environment is generated, open and modify the *env.py* file
    located in the `alembic` directory, as shown in [Example 7-13](#alembic_env),
    so that it gets access to your SQLAlchemy metadata object that contains the target
    schema information.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-13\. Connect the Alembic environment with your SQLAlchemy models
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With Alembic connected to your SQLAlchemy models, Alembic can now auto-generate
    your migration files by comparing the current schema of your database with your
    SQLAlchemy models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This command will compare the defined SQLAlchemy models against the existing
    database schema and automatically generate a SQL migration file under the `alembic/versions`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the generated migration file, you should see a file content similar
    to [Example 7-14](#alembic_initial_migration).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-14\. The initial Alembic migration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you’ve updated your first migration file, you’re ready to run it against
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If your ever need to revert the operation, you can run `alembic downgrade` instead.
  prefs: []
  type: TYPE_NORMAL
- en: What Alembic does under the hood is to generate the raw SQL needed to run or
    revert a migration and create an `alembic_versions` table in the database. It
    uses this table to keep track of migrations that have already been applied on
    your database so that rerunning the `alembic upgrade head` command won’t perform
    any duplicate migrations.
  prefs: []
  type: TYPE_NORMAL
- en: If in any case, your database schemas and your migration history drift away,
    you can always remove files from the `versions` directory and truncate the `alembic_revision`
    table. Then reinitialize Alembic to start with a fresh environment against an
    existing database.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After migrating a database with a migration file, make sure to commit to a Git
    repository. Avoid re-editing migration files after migrating a database as Alembic
    will skip existing migrations by cross-checking them with its versioning table.
  prefs: []
  type: TYPE_NORMAL
- en: If a migration file has already been run, it won’t detect changes in its content.
  prefs: []
  type: TYPE_NORMAL
- en: To update your database schema, create a new migration file instead.
  prefs: []
  type: TYPE_NORMAL
- en: Following the aforementioned workflow will now allow you to not only version
    control your database schemas but also manage changes to your production environments
    as your application requirements change.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Data When Working with Real-Time Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now be in a position to implement your own CRUD endpoints to retrieve
    and mutate both user conversation and message records in your database.
  prefs: []
  type: TYPE_NORMAL
- en: One question that remains unanswered is how to handle transactions within data
    streaming endpoints, such as an LLM streaming outputs to a client.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t stream data into a traditional relational database as ensuring ACID
    compliance with streaming transactions will prove challenging. Instead, you will
    want to perform your standard database operation as soon as your FastAPI server
    returns a response to the client. This challenge is exactly what a FastAPI’s background
    task can solve, as you can see in [Example 7-15](#db_stream).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-15\. Storing content of an LLM output stream
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function to store a message against a conversation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the conversation record exists and fetch it within a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create two separate copies of the LLM stream, one for the `StreamingResponse`
    and another to process in a background task.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a background task to store the message after the `StreamingResponse`
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 7-15](#db_stream), you allow FastAPI to fully stream the LLM response
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: It won’t matter whether you’re using an SSE or WebSocket endpoint. Once a request
    a response is fully streamed, invoke a background task passing in the full stream
    response content. Within the background task, you can then run a function to store
    the message after the request is sent, with the full LLM response content.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same approach, you can even generate a title for a conversation based
    on the content of the first message. To do this, you can invoke the LLM again
    with the content of the first message in the conversation, requesting for an appropriate
    title for the conversation. Once a conversation title is generated, you can create
    the conversation record in the database, as shown in [Example 7-16](#conversation_title).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-16\. Using the LLM to generate conversation titles based on the initial
    user prompt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using SQLAlchemy with Alembic is a tried and tested approach to working with
    relational databases in FastAPI, so you’re more likely to find a lot of resources
    on integrating these technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Both the SQLAlchemy ORM and Alembic allow you to interact with your database
    and control the changes to its schemas.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you dove into the critical aspects of integrating a database
    into your FastAPI application to store and retrieve user conversations.
  prefs: []
  type: TYPE_NORMAL
- en: You learned to identify when a database is necessary and how to identify the
    appropriate type for your project, whether it be relational or nonrelational.
    By understanding the underlying mechanisms of relational databases and the use
    cases for nonrelational databases, you’re now equipped to make informed decisions
    about database selection.
  prefs: []
  type: TYPE_NORMAL
- en: You also explored the development workflow, tooling, and best practices for
    working with relational databases. This includes learning techniques to improve
    query performance and efficiency, as well as strategies for managing evolving
    database schema changes. Additionally, you gained insights into managing codebase,
    database schema, and data drifts when working in teams.
  prefs: []
  type: TYPE_NORMAL
- en: As you move forward, the next chapter will guide you through implementing user
    management, authentication, and authorization mechanisms. This will further enhance
    your application’s security and user experience, building on the solid database
    foundation you’ve established in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch07.html#id951-marker)) Refer to this [reddit discussion thread](https://oreil.ly/OMaOT).
  prefs: []
  type: TYPE_NORMAL
