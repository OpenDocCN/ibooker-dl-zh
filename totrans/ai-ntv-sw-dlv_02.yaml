- en: Chapter 2\. Source Control Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a scenario where you and your team are collaborating on a complex software
    project. Multiple minds are contributing, making revisions and enhancements. Without
    a clear system for managing changes, you risk overwriting each other’s work and
    losing track of who updated what and why they made those changes. Without a clear
    system to tag sets of changes, you are unable to navigate back to a previous stable
    version of your team’s code should an issue arise. Without defined workflows and
    structured access control, anyone can change anything at any time, with no oversight.
    Without controls, your team is unable to determine which code files were used
    to build a particular release should you need to recreate it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, imagine that several teams have worked for months on a new application
    and it is now nearing time to deploy to your production environment. Ad hoc fixes
    and tweaks have been made to various development and QA environments, but those
    have not been reliably reflected in the production environment. Important production
    settings have not been repeated in QA environments, and development environments
    vary widely. Given the increasing complexity of the required environments, spinning
    up new environments has become a time-consuming and error-prone bottleneck that
    creates frustration and delay.
  prefs: []
  type: TYPE_NORMAL
- en: These situations are recipes for dysfunction and wasted effort. Source control
    management (SCM) practices were created to address these very problems. At its
    core, SCM is about tracking and managing changes made to code and other critical
    resources like configurations over time.
  prefs: []
  type: TYPE_NORMAL
- en: Today, artificial intelligence is transforming how we approach SCM. AI can automatically
    detect risky changes, suggest improvements to code or configurations, and even
    help resolve merge conflicts by understanding the intent behind modifications.
    It can identify inconsistencies across environments, recommend corrections, and
    optimize deployment workflows. AI-powered tools are not just helping teams manage
    complexity—they’re enabling faster, safer, and more resilient development cycles.
    As software delivery becomes more distributed and dynamic, AI is becoming an essential
    partner in making SCM more intelligent, proactive, and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Source Control Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem of coordinating changes across a team dates back to the early days
    of programming, and the history of SCM practices is intricately linked to the
    evolution of computer programming. In this section we’ll explore how SCM has evolved
    and the critical role AI tools play in modern SCM.
  prefs: []
  type: TYPE_NORMAL
- en: A Short History of Source Control Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early days of programming, programs were relatively simple; they were
    constrained by limited hardware, and code management was rudimentary. As CPUs
    became powerful and sophisticated, computation and code became more complex. Code
    repositories, central stores that provide basic SCM functions, first emerged in
    the 1970s alongside the rise of high-level languages and structured programming
    methodologies. Tools like Source Code Control System (SCCS) offered basic version
    tracking, allowing developers to revert to previous versions and see the history
    of changes. These early systems mirrored the shift toward more organized program
    development.
  prefs: []
  type: TYPE_NORMAL
- en: SCM further evolved in the 1970s with the emergence of more structured software
    engineering teams. Tools like Revision Control System (RCS), introduced in 1982,
    and Concurrent Versions System (CVS), introduced in 1986, added features crucial
    for collaboration, including branching. This enabled more complex project management
    and a collaborative culture.
  prefs: []
  type: TYPE_NORMAL
- en: In the early 1990s, IBM Rational ClearCase emerged as a commercial solution
    for SCM. It emphasized robust configuration management and process customization,
    making it suitable for complex software development environments. Subversion (SVN),
    developed by CollabNet, is another centralized code repository that gained popularity.
    SVN 1.0 was released in 2004 to address shortcomings in CVS and provide missing
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed version control and Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rise of Agile methodologies and open source in the early 2000s put new demands
    on software development. Rapid releases meant that teams required more flexibility
    and control over increasingly complex codebases. Teams themselves changed, becoming
    larger and often geographically dispersed. Git was created in 2005 by Linus Torvalds,
    the creator of the Linux kernel. He needed a powerful and efficient system to
    manage the massive codebase of the Linux project, and existing options fell short.
  prefs: []
  type: TYPE_NORMAL
- en: A version control system (VCS) is the core technology that tracks changes to
    files over time, forming the foundation of any SCM approach. Unlike most earlier
    code repositories, Git is a distributed VCS. With a centralized VCS, everyone
    works from a single copy of the codebase stored in a central server (repository).
    Each developer has their own local copy (working copy) that they can modify. When
    a developer makes changes and commits them, those changes are immediately uploaded
    to the central repository, making them visible to everyone else. To see the latest
    changes from others, developers simply need to update their local copy from the
    central repository. [Figure 2-1](#chapter_2_figure_1_1749354010071222) shows a
    centralized VCS.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ansd_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. [Centralized version control](https://oreil.ly/YLeDg)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Distributed systems take a different approach. Here, each developer has a complete
    copy of the codebase (including both the repository and their working copy) on
    their local machine. Changes made by a developer are private to their local copy
    until they explicitly share them with the team. This is done by “pushing” their
    changes to the central repository. Similarly, to see updates made by other developers,
    users need to download (“fetch”) those changes from the central repository into
    their local copy. [Figure 2-2](#chapter_2_figure_2_1749354010071251) shows a Git
    distributed VCS.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ansd_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Distributed version control with Git
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Git’s focus on speed, its distributed nature, and robust branching made it
    a game-changer in a number of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed facilitates offline work
  prefs: []
  type: TYPE_NORMAL
- en: Git’s decentralized approach facilitates efficient and independent work, as
    developers can make changes locally without a central server. This also enabled
    developers to work offline.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible branching and merging
  prefs: []
  type: TYPE_NORMAL
- en: Git’s branching system is incredibly flexible. Developers can create isolated
    branches to work on new features or bug fixes without affecting the main codebase.
    Merging these branches back into the main codebase is a smooth and efficient process.
    This empowers developers to experiment and iterate more freely.
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight and efficient for large codebases
  prefs: []
  type: TYPE_NORMAL
- en: Git excels at handling large codebases efficiently. It only stores the differences
    between code versions, making it faster and requiring less storage space than
    traditional SCM systems.
  prefs: []
  type: TYPE_NORMAL
- en: Nonlinear history aids organizations
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some SCM systems that enforce a linear history, Git allows developers
    to rewrite history through functionalities like rebasing. This flexibility helps
    maintain a clean and organized codebase.
  prefs: []
  type: TYPE_NORMAL
- en: The first widely used hosted Git repositories arrived a few years later. GitHub,
    the most popular today, was launched in 2008\. These platforms are built upon
    the power of Git, offering a user-friendly web interface, cloud storage for codebases,
    and collaboration features. This combination transformed Git from a powerful but
    technical tool to an accessible and social platform for software development,
    making it a cornerstone of modern software development workflows.
  prefs: []
  type: TYPE_NORMAL
- en: While traditional centralized repositories still have a legacy footprint and
    are in use in environments with very specific needs, Git is now the predominant
    choice. A [2022 Stack Overflow survey](https://oreil.ly/rLVE0) found that 94%
    of overall respondents used Git and 98% of those using any source control use
    Git. For this reason, we will focus our attention on Git repository variations.
  prefs: []
  type: TYPE_NORMAL
- en: Branching out with Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2010, Gitflowbranching conventions emerged to use branching to provide a
    clear separation between development, feature creation, and release preparation.
    [Figure 2-3](#chapter_2_figure_3_1749354010071267) shows a Gitflow workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Gitflow workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: The main codebase resides on a branch called “main.” This branch is typically
    considered stable and should only contain production-ready code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new “develop” branch, which serves as the continuous integration branch for
    all development work, is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feature development happens on isolated branches (feature/release branches)
    that branch from the develop branch. Developers work on new features and bug fixes
    on these feature branches. Once a feature is complete and thoroughly tested, it’s
    merged back into the develop branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The develop branch acts as an integration point for all completed features.
    It represents the upcoming release version and is continuously updated with merged
    feature branches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it’s time for a release, a release branch is created from “develop.” Bug
    fixes and minor adjustments can be made on this branch. Once finalized, the release
    branch is merged back into “main” to create the official release. A corresponding
    tag is created in “main” to mark the release version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ansd_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. [Gitflow workflow](https://oreil.ly/L2ZLg)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Pull requests, sometimes abbreviated as PRs, are a core collaboration feature
    in Git version control used for code review and integration, and are widely used
    with Gitflow and other branching models. Pull requests provide a structured way
    for developers to propose changes to a codebase and get them reviewed by others
    before merging them into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Gitflow’s emphasis on planned releases and separate release branches has been
    challenged by newer Git branching models. Fueled by the growing adoption of continuous
    integration and continuous delivery, these models prioritize faster deployments
    with more frequent updates. Trunk-based development discards the idea of a dedicated
    development branch altogether. Instead, features are continuously integrated directly
    into the main branch (often called “trunk” or “main”) after rigorous testing.
    [Figure 2-4](#chapter_2_figure_4_1749354010071282) shows this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ansd_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Trunk-based development
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This streamlined approach allows for quicker feedback loops and faster deployments,
    aligning well with modern DevOps practices. Pull requests remain essential in
    these workflows, ensuring code quality through code review before merging changes
    into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps and Source Control Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how code repositories evolved alongside programming and software
    development practices to solve the problems we imagined, enabling teams to collaborate
    effectively in source code. But what about deployment problems? How can we efficiently
    and systematically produce the environments we need and how can we streamline
    the deployment of our code into the production environment?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where GitOps comes in. In bringing Dev and Ops together, DevOps emphasizes
    the importance of automation in eliminating manual errors and helps ensure consistency
    across environments. This translates to faster deployments, improved reliability,
    and reduced risk. GitOps refers to automating the process of provisioning infrastructure,
    especially in modern container-first, cloud infrastructures. GitOps emphasizes
    the use of a code repository (usually Git) as the single source of truth for the
    desired state of the system and leverages automation to continuously reconcile
    the actual state with the desired state. Resources stored to our repositories
    can include:'
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure configuration
  prefs: []
  type: TYPE_NORMAL
- en: Files that define components needed for the environment, the type and number
    of virtual machines (VMs), storage configurations, network settings, and security
    policies. This can include declarative and imperative configurations and deployment
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs: []
  type: TYPE_NORMAL
- en: These are essential for storing sensitive information like passwords or API
    keys that should not be directly embedded in code. Infrastructure as Code (IaC)
    tools often have mechanisms for managing and referencing environment variables
    securely.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity of the environment, the repository might also store
    other resources such as container images (through git-lfs) used for application
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Using our repository as that single source of truth, we can take advantage of
    its powerful features. We get detailed version tracking and change histories,
    and we can manage our infrastructure updates with Git workflows that promote collaboration
    and oversight like code reviews through pull requests. Well-managed infrastructure
    automation translates to faster deployments, fewer errors, and reliable environments
    every time a new one needs to be created. We’ll learn more about using GitOps
    to deploy in [Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896).
  prefs: []
  type: TYPE_NORMAL
- en: Monorepos and Remote Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned the importance of microservices in [Chapter 1](ch01.html#chapter_1_the_road_to_ai_native_devops_1749354009875299).
    Two key practices that enhance productivity in microservices-based systems are
    the use of monorepos and remote caching.
  prefs: []
  type: TYPE_NORMAL
- en: A monorepo (monolithic repository) is a single version-controlled code repository
    that stores the code for multiple projects or services. In a microservices context,
    this approach simplifies collaboration, streamlines dependency management, enables
    atomic updates across services, and reduces versioning conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Remote cachingrefers to storing build artifacts—such as compiled code or test
    results—on remote servers. Tools like Nx use this technique to significantly speed
    up development workflows by allowing teams to reuse previously generated outputs
    instead of rebuilding from scratch, reducing redundant computations.
  prefs: []
  type: TYPE_NORMAL
- en: Together, monorepos and remote caching support faster and more efficient CI/CD
    pipelines and contribute to improved overall system performance. However, monorepos
    can introduce complexity as projects scale, and remote caching can raise concerns
    about vendor lock-in if not thoughtfully implemented.
  prefs: []
  type: TYPE_NORMAL
- en: AI in Source Control Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AI tools have revolutionized how developers approach coding. GitHub Copilot,
    Cursor, Harness AI Code Agent, and similar coding assistants/agents act as intelligent
    pair programmers, offering real-time code suggestions based on project context.
    These tools can predict and suggest entire lines or blocks of code, significantly
    speeding up the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond code completion, AI assistants can:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate boilerplate code structures automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suggest different implementation approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide code explanation and documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assist with debugging and optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AI-native software delivery starts with an AI-native SCM. The integration of
    AI with SCM extends beyond just code completion. Within SCMs, AI can analyze repository
    patterns, identify potential bugs before they reach production, and suggest architectural
    improvements based on best practices observed across similar projects. This proactive
    approach significantly reduces technical debt and improves code quality from the
    earliest stages of development. We will explore some of these themes later in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections we’ll walk through how SCM systems fit into the delivery
    pipeline. With that understanding, we’ll discuss factors to consider when choosing
    an SCM that is right for your team. Lastly, we’ll look at characteristics of modern
    code repositories, including the role of AI, that can simplify your entire software
    development pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Source Control Management in the Delivery Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core repository is a critical component of the delivery pipeline, anchoring
    the entire pipeline process. It serves as the single source of truth for the code,
    ensuring consistency and reliability, and it is the entity that developers interact
    with continually, initiating integration and delivery activities.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-5](#chapter_2_figure_5_1749354010071299) depicts the relationship
    of the code repository to continuous integration and delivery.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ansd_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Developer actions against the code repository instigate the CI/CD
    pipeline
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s walk through the three main parts of a typical pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Code repository
  prefs: []
  type: TYPE_NORMAL
- en: Developers work against the code repository, committing changes and opening
    and closing pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration is initiated by specific actions within a code repository.
    These triggers can be customized, including events such as code commits, the opening
    or closing of pull requests, or other relevant actions determined by your team’s
    specific needs and practices. CI gives developers rapid feedback on code changes.
    By automating builds and tests, CI acts as an early warning system, alerting developers
    to potential bugs, integration issues, or even style violations. This immediate
    feedback empowers developers to quickly address problems, preventing them from
    snowballing into larger, more costly issues down the line. With CI, your codebase
    stays in a consistently deployable state, ready for the next step in your delivery
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery and deployment
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery and deployment steps automate the provisioning of infrastructure
    and the deployment of new code versions to one or more pre-production environments.
    Various types of tests are typically executed against the app running in pre-production
    environments. We’ll look at these steps in [Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896).
    Finally, automatic or manual decisions gate the final deployment of the software
    into the production environment. We’ll discuss these steps at length in [Chapter 8](ch08.html#chapter_8_feature_management_and_experimentation_1749354011197288).
    By deploying smaller changes frequently, CD streamlines the delivery process,
    reduces release risk, and enhances the ability to respond to user feedback quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many code repositories build in secret detection features. Secrets can include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: API keys
  prefs: []
  type: TYPE_NORMAL
- en: Unique identifiers used to authenticate and authorize access to various web
    services and APIs
  prefs: []
  type: TYPE_NORMAL
- en: Access tokens
  prefs: []
  type: TYPE_NORMAL
- en: Temporary credentials that grant specific access rights to an application or
    resource
  prefs: []
  type: TYPE_NORMAL
- en: OAuth tokens
  prefs: []
  type: TYPE_NORMAL
- en: Tokens used for delegated authorization, allowing one application to access
    resources on behalf of a user
  prefs: []
  type: TYPE_NORMAL
- en: Private keys
  prefs: []
  type: TYPE_NORMAL
- en: Secret keys used in asymmetric encryption to decrypt messages or verify digital
    signatures
  prefs: []
  type: TYPE_NORMAL
- en: Usernames and passwords
  prefs: []
  type: TYPE_NORMAL
- en: Credentials used for basic authentication to systems and services
  prefs: []
  type: TYPE_NORMAL
- en: Database connection strings
  prefs: []
  type: TYPE_NORMAL
- en: Details needed to establish a connection to a database, often including sensitive
    information like hostnames, usernames, and passwords
  prefs: []
  type: TYPE_NORMAL
- en: Cloud service connection strings
  prefs: []
  type: TYPE_NORMAL
- en: Strings used to connect to cloud services like Azure Storage or AWS S3, potentially
    containing access keys and other secrets
  prefs: []
  type: TYPE_NORMAL
- en: Some code repositories will prevent or warn a developer when attempting to commit
    or merge code with a detected secret. CI processes can play a role in secret detection,
    preventing them from reaching a production environment. An ideal approach is to
    leverage both for comprehensive security.
  prefs: []
  type: TYPE_NORMAL
- en: Code Repository Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the importance of SCM to software development, selecting a code repository
    is one of the first decisions a team will make. *Where will we put the source
    code?* is a question a team will need to answer to even kick off a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, a repository must support the basic operations and the
    developer workflows that are critical to your team:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating, importing, and cloning repositories with support for distributed offline
    work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching, merging, and defining branching rules to meet your specific team’s
    needs (e.g., limiting branch creation/deletion to specific users)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, reviewing, and merging pull requests, along with defining pull request
    policies in line with the governance your team requires (e.g., requiring all changes
    to be associated with a pull request, prohibiting direct commits, or setting a
    minimum number of required reviewer approvals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and modifying tags, and defining tag policies (e.g., enforcing tag
    names to adhere to a specific pattern like semantic versioning)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While there may be differences in the implementation details, these are expected
    repository features.
  prefs: []
  type: TYPE_NORMAL
- en: In creating a delivery pipeline, teams typically start with repository choice
    first; because this is a choice that can have far-reaching effects on the implementation,
    it is critical to ensure your code repository will support seamless integration
    within a broader ecosystem. Your code repository should function in an ecosystem
    that enhances your team’s productivity instead of adding to their workload. In
    addition, a solution should be cost-effective and provide the transparency your
    organization requires.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive Integrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A well-designed DevOps ecosystem is characterized by easy-to-use tooling and
    comprehensive integrations with the functions and services that your delivery
    pipeline requires. This stands in contrast to a piecemeal approach, where developers
    are burdened with manual integration of many disparate tools, which can lead to
    issues that are difficult to troubleshoot and security risks. It is also contrasted
    with overly complex single-platform solutions, often suffering from feature bloat,
    that are difficult to configure.
  prefs: []
  type: TYPE_NORMAL
- en: An example of streamlined integration is configuration-as-code. This practice
    allows updates to your delivery pipeline to be versioned and tracked directly
    within your repository, just like your project code. You can further enhance collaboration
    and governance by enforcing workflows that require changes to be made through
    pull requests and approvals, mirroring standard development practices.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature example relates to security/vulnerability scanning. Displaying
    detected vulnerabilities and suggested remediations in the context of a pull request
    helps the developer quickly understand and resolve any detected issue.
  prefs: []
  type: TYPE_NORMAL
- en: AI-Powered Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The past few years have seen explosive growth in coding assistants or agents
    that use large language models to improve developer efficiency. These coding assistants
    help with auto-completing code, generating code suggestions, understanding what
    a piece of code does, and many other use cases. When AI assistants are integrated
    with code repositories to have access to the full codebase as context—not just
    isolated code snippets—they can generate more accurate and relevant suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: MCP plays a key role here by providing a universal, standardized way to connect
    AI models and code assistants with various data sources, including repositories
    like Harness Code Repository, GitHub, and Git. This eliminates the need for custom
    integrations, reducing development effort and increasing efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful application of generative AI (GenAI) in code repositories is
    semantic search—the ability to search an entire codebase using natural language.
    Tools like Sourcegraph’s Cody and Harness Code Repository enable developers to
    ask questions like, “How is authentication implemented and where is this code?”
    rather than relying on keyword-based searches like “log in” or “authenticate.”
    This capability is especially valuable for onboarding new team members and helping
    them quickly understand complex codebases without deep familiarity with project-specific
    terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding code reviews, tools like DeepCode and Codacy use ML algorithms to
    review code changes, automatically detecting potential bugs, code smells, and
    adherence to coding standards more efficiently than manual reviews. Other use
    cases for AI in SCMs are enhancing security by automatically scanning for vulnerabilities
    and compliance issues before code is committed and recommending fixes for those
    issues, summarizing pull requests, and generating software delivery pipelines
    using SCM as one of the data sources.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that with AI systems, results depend heavily on the
    data used to train the AI models. So, for example, “good” code will result in
    good code suggestions and reviews, and “bad” code will result in bad code suggestions
    and reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the impact of AI is equally important in verifying whether using AI
    has actually had a positive impact on the developers. Tools such as Harness Software
    Engineering Insights and others can help with measuring the productivity of developers
    using different coding assistants and also compare them with the developers that
    don’t use any coding assistants.
  prefs: []
  type: TYPE_NORMAL
- en: AI-powered SCMs accelerate time-to-market by generating fast and reliable code
    (especially when well-trained), improving code quality by identifying issues—including
    security vulnerabilities—at the source, and enhancing team collaboration by elevating
    the quality and efficiency of code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency and Transparency Through Open Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether or not your DevOps tools are open source is an important consideration.
    Open source solutions can be cost-effective for organizations with budget constraints,
    and the transparency they offer has advantages as well.
  prefs: []
  type: TYPE_NORMAL
- en: Proprietary solutions can often claim to offer reliable uptime and dedicated
    customer support teams to address any technical issues you encounter. However,
    there are often subscription fees for enterprise users, which can be a significant
    cost factor for small teams. Open source codebases are free to use, making them
    ideal for teams with limited budgets. The open source nature allows for transparency
    and community-driven development. Developers have access to the source code, enabling
    customization of the platform to fit specific needs. However, they often have
    to rely on the community for troubleshooting and support. While valuable, open
    source may not offer the same level of guaranteed assistance as a commercial provider.
    In addition, while open source promotes transparency, it also means potential
    vulnerabilities are publicly visible.
  prefs: []
  type: TYPE_NORMAL
- en: Open core solutions, like Harness.io and GitLab, provide a middle ground. They
    offer a free, feature-limited version, akin to open source.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, OSS can be put into escrow if needed for regulatory requirements or
    to ensure continuity of business generally. This provides assurance that in the
    event the tool provider goes out of business you will still have access to the
    tools needed to build, test, and monitor your application and to recreate your
    development, testing, and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: A Platform Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditional, piecemeal DevOps toolchains often create data silos and hinder
    visibility into the entire SDLC. However, a single DevOps platform offers a compelling
    solution by providing end-to-end visibility. For example, it enables tracking
    of every change, from the initial commit in the code repository to the final deployment
    on production servers. This holistic view helps you to identify bottlenecks, pinpoint
    potential issues early in the development cycle, and measure the overall effectiveness
    of your DevOps practices. Furthermore, comprehensive audit trails provide a clear
    record of all activity, simplifying troubleshooting and ensuring compliance with
    security regulations.
  prefs: []
  type: TYPE_NORMAL
- en: A unified platform also streamlines governance and unlocks the potential for
    intelligent automation. Managing governance policies across disparate tools can
    be cumbersome and error-prone. A single platform allows you to define and enforce
    policies consistently throughout your entire development pipeline. This ensures
    code adheres to coding standards, security best practices, and internal guidelines.
    For example, you can streamline governance by implementing a policy such as *scan
    code before committing, during the CI process, and during the CD process using
    (your organization’s) approved security scanner.* With a unified platform this
    can be easily implemented as a template that gets reused.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, with a complete understanding of the deployment context, including
    infrastructure and configuration details, the platform can offer intelligent code
    suggestions that optimize performance and efficiency. Imagine an AI-powered assistant
    that recommends code tweaks based on how the service will be deployed, potentially
    saving development time and improving code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Access Control, an Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As teams assemble a delivery toolchain, it’s common to start with individual
    point solutions. However, this piecemeal approach can lead to significant operational
    overhead. In this section, we’ll look at the example of RBAC to see how a cohesive
    delivery pipeline can simplify operations and empower development teams.
  prefs: []
  type: TYPE_NORMAL
- en: Most collaboration tools use role-based access to functionality in some form
    or another. Code repositories will support built-in roles, or will include built-in
    roles and will allow users to define custom roles. GitHub, for example, defines
    the roles *Read, Triage, Write, Maintain,* and *Admin*. These roles correspond
    to levels of access; the Read role is recommended for noncode contributors, whereas
    the Admin role is designed for users who require full access to the project, including
    sensitive and destructive actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These systems use RBAC, a method of managing access to resources within a system
    that centers on three core elements, namely users, roles, and permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: Users represent individuals or accounts requiring access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles are defined sets of permissions that grant access to specific resources
    or actions within the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions are the fundamental units of control, defining what actions a user
    can take (like reading, editing, or deleting data).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users are not directly assigned permissions. Instead, they are assigned one
    or more roles. Once a user is assigned a role, they inherit all the permissions
    associated with that role. This approach simplifies access management by eliminating
    the need to individually assign permissions to every user. Instead, permissions
    are defined at the role level, and users are granted access based on the roles
    they are assigned. [Figure 2-6](#chapter_2_figure_6_1749354010071315) illustrates
    users assigned to roles and the sets of permissions associated with roles.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ansd_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Users are assigned to roles; permissions are associated with roles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using role-based access is a common pattern that reduces administrative and
    enhances security by enforcing the principle of least privilege—users are granted
    only the permissions necessary for their job functions. Role-based access also
    helps with compliance, as it provides clear documentation of who has access to
    what within the system.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Roles, a Platform Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a DevOps ecosystem consisting of a Git repo, Jenkins, Terraform to manage
    an AWS infrastructure, Ansible for configuration management, and Datadog to capture
    performance metrics. In a system like this, constructed of several disparate tools,
    you might find that you need to define similar roles in each system, and repeatedly
    add the same. Provisioning a new developer might take several time-consuming steps.
    Let’s look at how an all-in-one platform handles RBAC using a platform approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the Harness Platform has a three-level hierarchical structure.
    The three levels, or scopes, are Account, Organization (Org), and Project:'
  prefs: []
  type: TYPE_NORMAL
- en: Account is the topmost entity. It can exercise control and has visibility over
    the entire platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organization is a unit of control where people and projects from the same business
    unit can be organized in an independent hierarchy. An organization can have multiple
    projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects represent the basic unit of collaboration in which users are grouped
    together to work on the same task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource Groups are an RBAC component that define the objects that a user can
    access. Objects are any Harness resource, including projects, pipelines, connectors,
    secrets, delegates, environments, users, and more. When you assign a Resource
    Group to a user, the access defined in the Resource Group is granted to the target
    user. Resource Groups can be defined at any scope.
  prefs: []
  type: TYPE_NORMAL
- en: Roles likewise can be defined at each scope. Roles are applied together to Resource
    Groups to create a complete set of permissions and access. For example, you can
    assign the Pipeline Executor role to a Resource Group that only allows access
    to specific pipelines, rather than all pipelines in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced SCM, a cornerstone of modern software development.
    SCM addresses the challenges of team collaboration and managing changes to codebases
    over time. It enables teams to collaborate effectively and manage code changes
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: SCM is essential to DevOps and CI/CD workflows, and its role is expanding with
    the emergence of AI-native SCM systems. These intelligent systems can generate,
    review, analyze, and optimize code, transforming how teams write and manage software.
    By automating routine tasks, enhancing accuracy, and surfacing insights, AI-powered
    SCM systems accelerate development and improve delivery efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the importance of selecting the right code repository and
    the benefits of a unified DevOps platform for cohesive workflows and stronger
    governance. With a solid SCM foundation in place, [Chapter 3](ch03.html#chapter_3_the_build_and_pre_deployment_testing_steps_of_cont_1749354010266208)
    dives into how continuous integration automates builds and unit tests to ensure
    code quality and development speed.
  prefs: []
  type: TYPE_NORMAL
