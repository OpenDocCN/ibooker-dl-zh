- en: Chapter 2\. Source Control Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. 源代码管理
- en: Imagine a scenario where you and your team are collaborating on a complex software
    project. Multiple minds are contributing, making revisions and enhancements. Without
    a clear system for managing changes, you risk overwriting each other’s work and
    losing track of who updated what and why they made those changes. Without a clear
    system to tag sets of changes, you are unable to navigate back to a previous stable
    version of your team’s code should an issue arise. Without defined workflows and
    structured access control, anyone can change anything at any time, with no oversight.
    Without controls, your team is unable to determine which code files were used
    to build a particular release should you need to recreate it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样一个场景：你和你的团队正在协作进行一个复杂的软件项目。多个大脑在贡献，进行修订和改进。如果没有一个明确的系统来管理更改，你可能会覆盖彼此的工作，失去对谁更新了什么以及为什么做出这些更改的跟踪。如果没有一个明确的系统来标记更改集，当出现问题时，你将无法导航回团队代码的先前稳定版本。如果没有定义的工作流程和结构化的访问控制，任何人都可以在任何时候更改任何内容，没有任何监督。没有控制，如果你的团队需要重新创建它，他们将无法确定用于构建特定发布的代码文件。
- en: Next, imagine that several teams have worked for months on a new application
    and it is now nearing time to deploy to your production environment. Ad hoc fixes
    and tweaks have been made to various development and QA environments, but those
    have not been reliably reflected in the production environment. Important production
    settings have not been repeated in QA environments, and development environments
    vary widely. Given the increasing complexity of the required environments, spinning
    up new environments has become a time-consuming and error-prone bottleneck that
    creates frustration and delay.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，想象一下，几个团队已经为一个新的应用程序工作了数月，现在即将接近部署到您的生产环境。对各种开发和 QA 环境进行了临时的修复和调整，但这些更改并没有可靠地反映在生产环境中。重要的生产设置在
    QA 环境中没有重复，开发环境差异很大。鉴于所需环境的日益复杂，启动新环境已成为耗时且易出错的瓶颈，这导致了挫败感和延迟。
- en: These situations are recipes for dysfunction and wasted effort. Source control
    management (SCM) practices were created to address these very problems. At its
    core, SCM is about tracking and managing changes made to code and other critical
    resources like configurations over time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况是功能失调和浪费努力的配方。源代码管理（SCM）实践正是为了解决这些问题而创建的。在核心上，SCM 是关于跟踪和管理随时间对代码和其他关键资源（如配置）所做的更改。
- en: Today, artificial intelligence is transforming how we approach SCM. AI can automatically
    detect risky changes, suggest improvements to code or configurations, and even
    help resolve merge conflicts by understanding the intent behind modifications.
    It can identify inconsistencies across environments, recommend corrections, and
    optimize deployment workflows. AI-powered tools are not just helping teams manage
    complexity—they’re enabling faster, safer, and more resilient development cycles.
    As software delivery becomes more distributed and dynamic, AI is becoming an essential
    partner in making SCM more intelligent, proactive, and efficient.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，人工智能正在改变我们对待源代码管理的方式。AI 可以自动检测风险更改，建议对代码或配置的改进，甚至通过理解修改背后的意图来帮助解决合并冲突。它可以识别跨环境的不一致性，推荐修正，并优化部署工作流程。AI
    驱动的工具不仅帮助团队管理复杂性，而且使开发周期更快、更安全、更具弹性。随着软件交付变得更加分散和动态，AI 正在成为使源代码管理更加智能、主动和高效的关键合作伙伴。
- en: Introducing Source Control Management
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍源代码管理
- en: The problem of coordinating changes across a team dates back to the early days
    of programming, and the history of SCM practices is intricately linked to the
    evolution of computer programming. In this section we’ll explore how SCM has evolved
    and the critical role AI tools play in modern SCM.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队间协调更改的问题可以追溯到编程的早期阶段，源代码管理实践的历史与计算机编程的演变紧密相连。在本节中，我们将探讨源代码管理是如何演变的，以及 AI
    工具在现代源代码管理中的关键作用。
- en: A Short History of Source Control Management
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码管理简史
- en: In the early days of programming, programs were relatively simple; they were
    constrained by limited hardware, and code management was rudimentary. As CPUs
    became powerful and sophisticated, computation and code became more complex. Code
    repositories, central stores that provide basic SCM functions, first emerged in
    the 1970s alongside the rise of high-level languages and structured programming
    methodologies. Tools like Source Code Control System (SCCS) offered basic version
    tracking, allowing developers to revert to previous versions and see the history
    of changes. These early systems mirrored the shift toward more organized program
    development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程的早期，程序相对简单；它们受限于有限的硬件，代码管理也相当原始。随着CPU变得强大和复杂，计算和代码也变得更加复杂。代码库，即提供基本源代码管理（SCM）功能的中心存储库，首次在20世纪70年代随着高级语言和结构化编程方法的兴起而出现。像源代码控制系统（SCCS）这样的工具提供了基本的版本跟踪功能，允许开发者回滚到之前的版本并查看变更历史。这些早期系统反映了向更有组织的程序开发方向的转变。
- en: SCM further evolved in the 1970s with the emergence of more structured software
    engineering teams. Tools like Revision Control System (RCS), introduced in 1982,
    and Concurrent Versions System (CVS), introduced in 1986, added features crucial
    for collaboration, including branching. This enabled more complex project management
    and a collaborative culture.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪70年代，随着更结构化的软件工程团队的兴起，SCM进一步发展。1982年引入的修订控制系统（RCS）和1986年引入的并发版本系统（CVS）增加了对协作至关重要的功能，包括分支。这使得更复杂的项目管理和协作文化成为可能。
- en: In the early 1990s, IBM Rational ClearCase emerged as a commercial solution
    for SCM. It emphasized robust configuration management and process customization,
    making it suitable for complex software development environments. Subversion (SVN),
    developed by CollabNet, is another centralized code repository that gained popularity.
    SVN 1.0 was released in 2004 to address shortcomings in CVS and provide missing
    features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代初，IBM Rational ClearCase作为SCM的商业解决方案出现。它强调强大的配置管理和流程定制，使其适合复杂的软件开发环境。由CollabNet开发的Subversion（SVN）是另一个流行的集中式代码库。SVN
    1.0于2004年发布，旨在解决CVS的不足并提供缺失的功能。
- en: Distributed version control and Git
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式版本控制和Git
- en: The rise of Agile methodologies and open source in the early 2000s put new demands
    on software development. Rapid releases meant that teams required more flexibility
    and control over increasingly complex codebases. Teams themselves changed, becoming
    larger and often geographically dispersed. Git was created in 2005 by Linus Torvalds,
    the creator of the Linux kernel. He needed a powerful and efficient system to
    manage the massive codebase of the Linux project, and existing options fell short.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在21世纪初，敏捷方法和开源的兴起对软件开发提出了新的要求。快速发布意味着团队需要更多的灵活性和对日益复杂的代码库的控制。团队本身也发生了变化，变得更大，并且通常地理上分散。Git是由Linux内核的创造者林纳斯·托瓦兹（Linus
    Torvalds）于2005年创建的。他需要一个强大而高效的系统来管理Linux项目的庞大代码库，而现有的选项都未能满足需求。
- en: A version control system (VCS) is the core technology that tracks changes to
    files over time, forming the foundation of any SCM approach. Unlike most earlier
    code repositories, Git is a distributed VCS. With a centralized VCS, everyone
    works from a single copy of the codebase stored in a central server (repository).
    Each developer has their own local copy (working copy) that they can modify. When
    a developer makes changes and commits them, those changes are immediately uploaded
    to the central repository, making them visible to everyone else. To see the latest
    changes from others, developers simply need to update their local copy from the
    central repository. [Figure 2-1](#chapter_2_figure_1_1749354010071222) shows a
    centralized VCS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统（VCS）是跟踪文件随时间变化的核心理技术，是任何SCM方法的基础。与大多数早期的代码库不同，Git是一个分布式VCS。在集中式VCS中，每个人都从存储在中央服务器（仓库）中的单个代码库副本工作。每个开发者都有自己的本地副本（工作副本）可以修改。当开发者进行更改并提交时，这些更改会立即上传到中央仓库，使其他人都能看到。要查看他人的最新更改，开发者只需从中央仓库更新他们的本地副本。[图2-1](#chapter_2_figure_1_1749354010071222)展示了集中式VCS。
- en: '![](assets/ansd_0201.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/ansd_0201.png)'
- en: Figure 2-1\. [Centralized version control](https://oreil.ly/YLeDg)
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. [集中式版本控制](https://oreil.ly/YLeDg)
- en: Distributed systems take a different approach. Here, each developer has a complete
    copy of the codebase (including both the repository and their working copy) on
    their local machine. Changes made by a developer are private to their local copy
    until they explicitly share them with the team. This is done by “pushing” their
    changes to the central repository. Similarly, to see updates made by other developers,
    users need to download (“fetch”) those changes from the central repository into
    their local copy. [Figure 2-2](#chapter_2_figure_2_1749354010071251) shows a Git
    distributed VCS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统采取了不同的方法。在这里，每个开发者都在他们的本地机器上拥有代码库的完整副本（包括仓库和他们的工作副本）。开发者所做的更改仅限于他们的本地副本，直到他们明确地与团队共享。这是通过“推送”他们的更改到中央仓库来完成的。同样，要查看其他开发者所做的更新，用户需要从中央仓库下载（“获取”）这些更改到他们的本地副本。[图
    2-2](#chapter_2_figure_2_1749354010071251) 展示了 Git 分布式版本控制系统。
- en: '![](assets/ansd_0202.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/ansd_0202.png)'
- en: Figure 2-2\. Distributed version control with Git
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 使用 Git 的分布式版本控制
- en: 'Git’s focus on speed, its distributed nature, and robust branching made it
    a game-changer in a number of ways:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Git 对速度的关注、其分布式特性以及强大的分支功能，在多个方面都带来了变革：
- en: Distributed facilitates offline work
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式架构便于离线工作
- en: Git’s decentralized approach facilitates efficient and independent work, as
    developers can make changes locally without a central server. This also enabled
    developers to work offline.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Git的分布式方法促进了高效和独立的工作，因为开发者可以在本地进行更改，而无需中央服务器。这也使得开发者能够离线工作。
- en: Flexible branching and merging
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活的分支和合并
- en: Git’s branching system is incredibly flexible. Developers can create isolated
    branches to work on new features or bug fixes without affecting the main codebase.
    Merging these branches back into the main codebase is a smooth and efficient process.
    This empowers developers to experiment and iterate more freely.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的分支系统非常灵活。开发者可以创建隔离的分支来处理新功能或错误修复，而不会影响主代码库。将这些分支合并回主代码库是一个顺畅且高效的过程。这使开发者能够更自由地进行实验和迭代。
- en: Lightweight and efficient for large codebases
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级且高效，适用于大型代码库
- en: Git excels at handling large codebases efficiently. It only stores the differences
    between code versions, making it faster and requiring less storage space than
    traditional SCM systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Git 在高效处理大型代码库方面表现出色。它只存储代码版本之间的差异，这使得它比传统的版本控制系统更快，并且需要的存储空间更少。
- en: Nonlinear history aids organizations
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性历史记录有助于组织
- en: Unlike some SCM systems that enforce a linear history, Git allows developers
    to rewrite history through functionalities like rebasing. This flexibility helps
    maintain a clean and organized codebase.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些强制执行线性历史的源代码管理系统不同，Git 允许开发者通过重置等功能重写历史。这种灵活性有助于保持代码库的整洁和组织。
- en: The first widely used hosted Git repositories arrived a few years later. GitHub,
    the most popular today, was launched in 2008\. These platforms are built upon
    the power of Git, offering a user-friendly web interface, cloud storage for codebases,
    and collaboration features. This combination transformed Git from a powerful but
    technical tool to an accessible and social platform for software development,
    making it a cornerstone of modern software development workflows.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个广泛使用的托管 Git 仓库几年后出现。GitHub，如今最受欢迎的平台，于 2008 年推出。这些平台建立在 Git 的强大功能之上，提供用户友好的网页界面、代码库的云存储和协作功能。这种组合将
    Git 从一个强大但技术性的工具转变为一个易于访问且社交的软件开发平台，使其成为现代软件开发工作流程的基石。
- en: While traditional centralized repositories still have a legacy footprint and
    are in use in environments with very specific needs, Git is now the predominant
    choice. A [2022 Stack Overflow survey](https://oreil.ly/rLVE0) found that 94%
    of overall respondents used Git and 98% of those using any source control use
    Git. For this reason, we will focus our attention on Git repository variations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然传统的集中式仓库仍然有遗留的足迹，并且在具有非常特定需求的环境中仍在使用，但现在 Git 是首选。2022 年 Stack Overflow 调查（[https://oreil.ly/rLVE0](https://oreil.ly/rLVE0)）发现，94%
    的受访者使用 Git，而使用任何源代码控制系统的 98% 的受访者使用 Git。因此，我们将重点关注 Git 仓库的变体。
- en: Branching out with Git
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Git 进行分支
- en: In 2010, Gitflowbranching conventions emerged to use branching to provide a
    clear separation between development, feature creation, and release preparation.
    [Figure 2-3](#chapter_2_figure_3_1749354010071267) shows a Gitflow workflow.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，Gitflow 分支约定出现，利用分支来提供开发、功能创建和发布准备之间的清晰分离。[图 2-3](#chapter_2_figure_3_1749354010071267)
    展示了 Gitflow 工作流程。
- en: 'In the Gitflow workflow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gitflow 工作流程中：
- en: The main codebase resides on a branch called “main.” This branch is typically
    considered stable and should only contain production-ready code.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要代码库位于名为“main”的分支上。这个分支通常被认为是稳定的，应该只包含生产就绪的代码。
- en: A new “develop” branch, which serves as the continuous integration branch for
    all development work, is created.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的“develop”分支，该分支作为所有开发工作的持续集成分支。
- en: Feature development happens on isolated branches (feature/release branches)
    that branch from the develop branch. Developers work on new features and bug fixes
    on these feature branches. Once a feature is complete and thoroughly tested, it’s
    merged back into the develop branch.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能开发发生在从“develop”分支分叉的独立分支（功能/发布分支）上。开发者在这些功能分支上工作，开发新功能和修复错误。一旦功能完成并经过彻底测试，它就会被合并回“develop”分支。
- en: The develop branch acts as an integration point for all completed features.
    It represents the upcoming release version and is continuously updated with merged
    feature branches.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “develop”分支作为所有完成功能的集成点。它代表了即将发布的版本，并且随着合并的功能分支而持续更新。
- en: When it’s time for a release, a release branch is created from “develop.” Bug
    fixes and minor adjustments can be made on this branch. Once finalized, the release
    branch is merged back into “main” to create the official release. A corresponding
    tag is created in “main” to mark the release version.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当是时候发布时，从“develop”分支创建一个发布分支。可以在该分支上进行错误修复和微小调整。一旦最终确定，发布分支就会被合并回“main”以创建官方发布。在“main”中创建一个相应的标签来标记发布版本。
- en: '![](assets/ansd_0203.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ansd_0203.png)'
- en: Figure 2-3\. [Gitflow workflow](https://oreil.ly/L2ZLg)
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. [Gitflow工作流程](https://oreil.ly/L2ZLg)
- en: Pull requests, sometimes abbreviated as PRs, are a core collaboration feature
    in Git version control used for code review and integration, and are widely used
    with Gitflow and other branching models. Pull requests provide a structured way
    for developers to propose changes to a codebase and get them reviewed by others
    before merging them into the main branch.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求，有时简称为PRs，是Git版本控制中的一个核心协作功能，用于代码审查和集成，并且与Gitflow和其他分支模型广泛使用。拉取请求为开发者提供了一个结构化的方式来提出对代码库的更改，并在合并到主分支之前由他人进行审查。
- en: Gitflow’s emphasis on planned releases and separate release branches has been
    challenged by newer Git branching models. Fueled by the growing adoption of continuous
    integration and continuous delivery, these models prioritize faster deployments
    with more frequent updates. Trunk-based development discards the idea of a dedicated
    development branch altogether. Instead, features are continuously integrated directly
    into the main branch (often called “trunk” or “main”) after rigorous testing.
    [Figure 2-4](#chapter_2_figure_4_1749354010071282) shows this pattern.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow对计划发布和单独发布分支的强调受到了较新Git分支模型的挑战。随着持续集成和持续交付的日益普及，这些模型优先考虑更快的部署和更频繁的更新。基于主干的开发完全摒弃了专用开发分支的概念。相反，在经过严格测试后，功能会直接集成到主分支（通常称为“主干”或“main”）。[图2-4](#chapter_2_figure_4_1749354010071282)展示了这种模式。
- en: '![](assets/ansd_0204.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ansd_0204.png)'
- en: Figure 2-4\. Trunk-based development
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. 基于主干的开发
- en: This streamlined approach allows for quicker feedback loops and faster deployments,
    aligning well with modern DevOps practices. Pull requests remain essential in
    these workflows, ensuring code quality through code review before merging changes
    into the main branch.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化的方法允许更快的反馈循环和更快的部署，与现代DevOps实践相得益彰。在上述工作流程中，拉取请求（Pull requests）仍然至关重要，确保在将更改合并到主分支之前通过代码审查来保证代码质量。
- en: GitOps and Source Control Management
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitOps和源代码管理
- en: We have seen how code repositories evolved alongside programming and software
    development practices to solve the problems we imagined, enabling teams to collaborate
    effectively in source code. But what about deployment problems? How can we efficiently
    and systematically produce the environments we need and how can we streamline
    the deployment of our code into the production environment?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到代码库如何随着编程和软件开发实践的发展而发展，以解决我们想象中的问题，使团队能够在源代码中有效协作。但关于部署问题呢？我们如何高效和系统地产生我们需要的环境，以及我们如何简化代码到生产环境的部署？
- en: 'Here is where GitOps comes in. In bringing Dev and Ops together, DevOps emphasizes
    the importance of automation in eliminating manual errors and helps ensure consistency
    across environments. This translates to faster deployments, improved reliability,
    and reduced risk. GitOps refers to automating the process of provisioning infrastructure,
    especially in modern container-first, cloud infrastructures. GitOps emphasizes
    the use of a code repository (usually Git) as the single source of truth for the
    desired state of the system and leverages automation to continuously reconcile
    the actual state with the desired state. Resources stored to our repositories
    can include:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是GitOps发挥作用的地方。在将开发和运维结合在一起的过程中，DevOps强调了自动化在消除手动错误和确保环境一致性方面的重要性。这转化为更快的部署、更高的可靠性和降低风险。GitOps指的是自动化基础设施配置的过程，特别是在现代以容器优先、云基础设施中。GitOps强调使用代码仓库（通常是Git）作为系统期望状态的唯一真相来源，并利用自动化来持续地将实际状态与期望状态进行协调。存储到我们仓库的资源可以包括：
- en: Infrastructure configuration
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施配置
- en: Files that define components needed for the environment, the type and number
    of virtual machines (VMs), storage configurations, network settings, and security
    policies. This can include declarative and imperative configurations and deployment
    scripts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 定义环境所需组件的文件，虚拟机（VM）的类型和数量，存储配置，网络设置和安全策略。这可能包括声明性和命令性配置以及部署脚本。
- en: Environment variables
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量
- en: These are essential for storing sensitive information like passwords or API
    keys that should not be directly embedded in code. Infrastructure as Code (IaC)
    tools often have mechanisms for managing and referencing environment variables
    securely.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是存储敏感信息（如密码或API密钥）所必需的，这些信息不应直接嵌入到代码中。基础设施即代码（IaC）工具通常具有管理和引用环境变量的安全机制。
- en: Additional resources
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其他资源
- en: Depending on the complexity of the environment, the repository might also store
    other resources such as container images (through git-lfs) used for application
    deployment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据环境的复杂性，仓库可能还会存储其他资源，例如用于应用程序部署的容器镜像（通过git-lfs）。
- en: Using our repository as that single source of truth, we can take advantage of
    its powerful features. We get detailed version tracking and change histories,
    and we can manage our infrastructure updates with Git workflows that promote collaboration
    and oversight like code reviews through pull requests. Well-managed infrastructure
    automation translates to faster deployments, fewer errors, and reliable environments
    every time a new one needs to be created. We’ll learn more about using GitOps
    to deploy in [Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的仓库作为唯一的真相来源，我们可以利用其强大的功能。我们获得详细的版本跟踪和变更历史，并且可以使用Git工作流程来管理我们的基础设施更新，这些工作流程通过拉取请求促进协作和监督，就像代码审查一样。良好的基础设施自动化可以转化为更快的部署、更少的错误以及每次创建新环境时都可靠的运行环境。我们将在[第四章](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896)中了解更多关于使用GitOps进行部署的信息。
- en: Monorepos and Remote Caching
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单仓库和远程缓存
- en: We mentioned the importance of microservices in [Chapter 1](ch01.html#chapter_1_the_road_to_ai_native_devops_1749354009875299).
    Two key practices that enhance productivity in microservices-based systems are
    the use of monorepos and remote caching.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第一章](ch01.html#chapter_1_the_road_to_ai_native_devops_1749354009875299)中提到了微服务的重要性。在基于微服务的系统中提高生产力的两个关键实践是使用单仓库和远程缓存。
- en: A monorepo (monolithic repository) is a single version-controlled code repository
    that stores the code for multiple projects or services. In a microservices context,
    this approach simplifies collaboration, streamlines dependency management, enables
    atomic updates across services, and reduces versioning conflicts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单仓库（单体仓库）是一个单一的版本控制代码仓库，用于存储多个项目或服务的代码。在微服务环境中，这种方法简化了协作，简化了依赖关系管理，使服务之间的原子更新成为可能，并减少了版本冲突。
- en: Remote cachingrefers to storing build artifacts—such as compiled code or test
    results—on remote servers. Tools like Nx use this technique to significantly speed
    up development workflows by allowing teams to reuse previously generated outputs
    instead of rebuilding from scratch, reducing redundant computations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 远程缓存指的是在远程服务器上存储构建工件，例如编译代码或测试结果。像Nx这样的工具通过允许团队重用先前生成的输出而不是从头开始重建，从而显著加快开发工作流程，减少冗余计算。
- en: Together, monorepos and remote caching support faster and more efficient CI/CD
    pipelines and contribute to improved overall system performance. However, monorepos
    can introduce complexity as projects scale, and remote caching can raise concerns
    about vendor lock-in if not thoughtfully implemented.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单一仓库和远程缓存共同支持更快、更高效的CI/CD管道，并有助于提高整体系统性能。然而，随着项目的扩展，单一仓库可能会引入复杂性，而远程缓存如果不经过深思熟虑地实施，可能会引起供应商锁定的问题。
- en: AI in Source Control Management
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码管理中的人工智能
- en: AI tools have revolutionized how developers approach coding. GitHub Copilot,
    Cursor, Harness AI Code Agent, and similar coding assistants/agents act as intelligent
    pair programmers, offering real-time code suggestions based on project context.
    These tools can predict and suggest entire lines or blocks of code, significantly
    speeding up the development process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能工具彻底改变了开发者对待编码的方式。GitHub Copilot、Cursor、Harness AI Code Agent以及类似的编码助手/代理充当智能配对程序员，根据项目上下文提供实时代码建议。这些工具可以预测并建议整个行或代码块，显著加快开发过程。
- en: 'Beyond code completion, AI assistants can:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码补全之外，人工智能助手还可以：
- en: Generate boilerplate code structures automatically
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成样板代码结构
- en: Suggest different implementation approaches
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出不同的实现方法
- en: Provide code explanation and documentation
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供代码解释和文档
- en: Assist with debugging and optimization
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助调试和优化
- en: AI-native software delivery starts with an AI-native SCM. The integration of
    AI with SCM extends beyond just code completion. Within SCMs, AI can analyze repository
    patterns, identify potential bugs before they reach production, and suggest architectural
    improvements based on best practices observed across similar projects. This proactive
    approach significantly reduces technical debt and improves code quality from the
    earliest stages of development. We will explore some of these themes later in
    the chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能原生软件交付从人工智能原生的源代码管理开始。人工智能与源代码管理的集成不仅限于代码补全。在源代码管理中，人工智能可以分析仓库模式，在代码达到生产之前识别潜在的错误，并根据观察到的类似项目的最佳实践提出架构改进建议。这种主动方法显著减少了技术债务并提高了代码质量，从开发最早阶段开始。
- en: In the following sections we’ll walk through how SCM systems fit into the delivery
    pipeline. With that understanding, we’ll discuss factors to consider when choosing
    an SCM that is right for your team. Lastly, we’ll look at characteristics of modern
    code repositories, including the role of AI, that can simplify your entire software
    development pipeline.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍源代码管理系统如何融入交付管道。有了这个理解，我们将讨论在选择适合您团队的源代码管理系统时需要考虑的因素。最后，我们将探讨现代代码仓库的特征，包括人工智能的作用，这些特征可以简化您的整个软件开发管道。
- en: Source Control Management in the Delivery Pipeline
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交付管道中的源代码管理
- en: The core repository is a critical component of the delivery pipeline, anchoring
    the entire pipeline process. It serves as the single source of truth for the code,
    ensuring consistency and reliability, and it is the entity that developers interact
    with continually, initiating integration and delivery activities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 核心仓库是交付管道的一个关键组件，是整个管道过程的锚点。它作为代码的唯一真实来源，确保一致性和可靠性，并且是开发者不断与之交互的实体，启动集成和交付活动。
- en: '[Figure 2-5](#chapter_2_figure_5_1749354010071299) depicts the relationship
    of the code repository to continuous integration and delivery.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-5](#chapter_2_figure_5_1749354010071299)展示了代码仓库与持续集成和交付之间的关系。'
- en: '![](assets/ansd_0205.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ansd_0205.png)'
- en: Figure 2-5\. Developer actions against the code repository instigate the CI/CD
    pipeline
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-5\. 开发者对代码仓库的操作触发了CI/CD管道
- en: 'Let’s walk through the three main parts of a typical pipeline:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解典型管道的三个主要部分：
- en: Code repository
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仓库
- en: Developers work against the code repository, committing changes and opening
    and closing pull requests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者针对代码仓库进行操作，提交更改并打开和关闭拉取请求。
- en: Continuous integration
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous integration is initiated by specific actions within a code repository.
    These triggers can be customized, including events such as code commits, the opening
    or closing of pull requests, or other relevant actions determined by your team’s
    specific needs and practices. CI gives developers rapid feedback on code changes.
    By automating builds and tests, CI acts as an early warning system, alerting developers
    to potential bugs, integration issues, or even style violations. This immediate
    feedback empowers developers to quickly address problems, preventing them from
    snowballing into larger, more costly issues down the line. With CI, your codebase
    stays in a consistently deployable state, ready for the next step in your delivery
    pipeline.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是由代码仓库内的特定操作触发的。这些触发器可以自定义，包括代码提交、拉取请求的打开或关闭或其他由您团队的具体需求和习惯确定的有关操作。CI为开发者提供了关于代码更改的快速反馈。通过自动化构建和测试，CI充当早期预警系统，提醒开发者潜在的bug、集成问题或甚至样式违规。这种即时反馈使开发者能够迅速解决问题，防止它们演变成更大、更昂贵的后续问题。有了CI，您的代码库将保持一致的可部署状态，为您的交付管道的下一步做好准备。
- en: Continuous delivery and deployment
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付和部署
- en: Continuous delivery and deployment steps automate the provisioning of infrastructure
    and the deployment of new code versions to one or more pre-production environments.
    Various types of tests are typically executed against the app running in pre-production
    environments. We’ll look at these steps in [Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896).
    Finally, automatic or manual decisions gate the final deployment of the software
    into the production environment. We’ll discuss these steps at length in [Chapter 8](ch08.html#chapter_8_feature_management_and_experimentation_1749354011197288).
    By deploying smaller changes frequently, CD streamlines the delivery process,
    reduces release risk, and enhances the ability to respond to user feedback quickly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付和部署步骤自动化了基础设施的配置和将新代码版本部署到一个或多个预生产环境。通常会对运行在预生产环境中的应用程序执行各种类型的测试。我们将在[第4章](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896)中探讨这些步骤。最后，自动或手动决策将软件最终部署到生产环境。我们将在[第8章](ch08.html#chapter_8_feature_management_and_experimentation_1749354011197288)中详细讨论这些步骤。通过频繁部署较小的更改，CD简化了交付过程，降低了发布风险，并增强了快速响应用户反馈的能力。
- en: 'Many code repositories build in secret detection features. Secrets can include
    the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 许多代码仓库内置了秘密检测功能。秘密可能包括以下内容：
- en: API keys
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥
- en: Unique identifiers used to authenticate and authorize access to various web
    services and APIs
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 用于验证和授权访问各种Web服务和API的唯一标识符
- en: Access tokens
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌
- en: Temporary credentials that grant specific access rights to an application or
    resource
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 授予应用程序或资源特定访问权限的临时凭证
- en: OAuth tokens
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth令牌
- en: Tokens used for delegated authorization, allowing one application to access
    resources on behalf of a user
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用于委托授权的令牌，允许一个应用程序代表用户访问资源
- en: Private keys
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥
- en: Secret keys used in asymmetric encryption to decrypt messages or verify digital
    signatures
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解密消息或验证数字签名的非对称加密中的密钥
- en: Usernames and passwords
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名和密码
- en: Credentials used for basic authentication to systems and services
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用于对系统和服务的基本身份验证的凭证
- en: Database connection strings
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接字符串
- en: Details needed to establish a connection to a database, often including sensitive
    information like hostnames, usernames, and passwords
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 建立数据库连接所需的信息细节，通常包括主机名、用户名和密码等敏感信息
- en: Cloud service connection strings
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务连接字符串
- en: Strings used to connect to cloud services like Azure Storage or AWS S3, potentially
    containing access keys and other secrets
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用于连接到云服务如Azure存储或AWS S3的字符串，可能包含访问密钥和其他机密信息
- en: Some code repositories will prevent or warn a developer when attempting to commit
    or merge code with a detected secret. CI processes can play a role in secret detection,
    preventing them from reaching a production environment. An ideal approach is to
    leverage both for comprehensive security.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码仓库将在尝试提交或合并检测到秘密的代码时阻止或警告开发者。CI流程可以在秘密检测中发挥作用，防止它们进入生产环境。理想的方法是利用两者以实现全面的安全。
- en: Code Repository Considerations
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码仓库考虑因素
- en: Given the importance of SCM to software development, selecting a code repository
    is one of the first decisions a team will make. *Where will we put the source
    code?* is a question a team will need to answer to even kick off a project.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到SCM对软件开发的重要性，选择代码仓库是团队将做出的第一个决定之一。*我们将把源代码放在哪里？* 是团队需要回答的问题，甚至是启动项目。
- en: 'First and foremost, a repository must support the basic operations and the
    developer workflows that are critical to your team:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个仓库必须支持对团队至关重要的基本操作和开发者工作流程：
- en: Creating, importing, and cloning repositories with support for distributed offline
    work
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持分布式离线工作的创建、导入和克隆仓库
- en: Branching, merging, and defining branching rules to meet your specific team’s
    needs (e.g., limiting branch creation/deletion to specific users)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支、合并以及定义分支规则以满足您特定团队的需求（例如，限制分支创建/删除到特定用户）
- en: Creating, reviewing, and merging pull requests, along with defining pull request
    policies in line with the governance your team requires (e.g., requiring all changes
    to be associated with a pull request, prohibiting direct commits, or setting a
    minimum number of required reviewer approvals)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、审查和合并拉取请求，以及定义符合团队治理要求的拉取请求策略（例如，要求所有更改都与拉取请求相关联，禁止直接提交，或设置所需的最小审查者批准数量）
- en: Creating and modifying tags, and defining tag policies (e.g., enforcing tag
    names to adhere to a specific pattern like semantic versioning)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和修改标签，以及定义标签策略（例如，强制标签名称遵循特定模式，如语义版本控制）
- en: While there may be differences in the implementation details, these are expected
    repository features.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在实现细节上可能存在差异，但这些是预期的仓库功能。
- en: In creating a delivery pipeline, teams typically start with repository choice
    first; because this is a choice that can have far-reaching effects on the implementation,
    it is critical to ensure your code repository will support seamless integration
    within a broader ecosystem. Your code repository should function in an ecosystem
    that enhances your team’s productivity instead of adding to their workload. In
    addition, a solution should be cost-effective and provide the transparency your
    organization requires.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建交付管道时，团队通常首先选择仓库；因为这是一个可能对实施产生深远影响的决策，所以确保您的代码仓库能够支持在更广泛的生态系统中的无缝集成至关重要。您的代码仓库应在增强团队生产力的生态系统内运行，而不是增加他们的工作量。此外，解决方案应具有成本效益，并提供您组织所需的可视化。
- en: Comprehensive Integrations
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全面集成
- en: A well-designed DevOps ecosystem is characterized by easy-to-use tooling and
    comprehensive integrations with the functions and services that your delivery
    pipeline requires. This stands in contrast to a piecemeal approach, where developers
    are burdened with manual integration of many disparate tools, which can lead to
    issues that are difficult to troubleshoot and security risks. It is also contrasted
    with overly complex single-platform solutions, often suffering from feature bloat,
    that are difficult to configure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的DevOps生态系统以易于使用的工具和与交付管道所需的功能和服务的全面集成为特征。这与零散的方法形成对比，在这种方法中，开发者被迫手动集成许多不同的工具，这可能导致难以调试的问题和安全隐患。它也与过于复杂的单一平台解决方案形成对比，这些解决方案通常功能冗余，难以配置。
- en: An example of streamlined integration is configuration-as-code. This practice
    allows updates to your delivery pipeline to be versioned and tracked directly
    within your repository, just like your project code. You can further enhance collaboration
    and governance by enforcing workflows that require changes to be made through
    pull requests and approvals, mirroring standard development practices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 流线式集成的一个例子是配置即代码。这种做法允许您的交付管道更新在您的仓库中进行版本控制和跟踪，就像您的项目代码一样。您可以通过强制执行需要通过拉取请求和批准进行更改的工作流程来进一步增强协作和治理，这些工作流程反映了标准开发实践。
- en: Another feature example relates to security/vulnerability scanning. Displaying
    detected vulnerabilities and suggested remediations in the context of a pull request
    helps the developer quickly understand and resolve any detected issue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个功能示例与安全/漏洞扫描相关。在拉取请求的上下文中显示检测到的漏洞和建议的修复措施，有助于开发者快速理解和解决任何检测到的问题。
- en: AI-Powered Features
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI功能
- en: The past few years have seen explosive growth in coding assistants or agents
    that use large language models to improve developer efficiency. These coding assistants
    help with auto-completing code, generating code suggestions, understanding what
    a piece of code does, and many other use cases. When AI assistants are integrated
    with code repositories to have access to the full codebase as context—not just
    isolated code snippets—they can generate more accurate and relevant suggestions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，使用大型语言模型来提高开发者效率的编码助手或代理经历了爆炸式增长。这些编码助手帮助自动完成代码、生成代码建议、理解代码片段的功能，以及许多其他用例。当人工智能助手与代码仓库集成，能够访问完整的代码库作为上下文——而不仅仅是孤立的代码片段——它们可以生成更准确和相关的建议。
- en: MCP plays a key role here by providing a universal, standardized way to connect
    AI models and code assistants with various data sources, including repositories
    like Harness Code Repository, GitHub, and Git. This eliminates the need for custom
    integrations, reducing development effort and increasing efficiency.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MCP 在这里发挥着关键作用，通过提供一种通用的、标准化的方式将人工智能模型和代码助手与各种数据源连接起来，包括 Harness 代码仓库、GitHub
    和 Git 等存储库。这消除了定制集成的需求，减少了开发工作量，提高了效率。
- en: Another powerful application of generative AI (GenAI) in code repositories is
    semantic search—the ability to search an entire codebase using natural language.
    Tools like Sourcegraph’s Cody and Harness Code Repository enable developers to
    ask questions like, “How is authentication implemented and where is this code?”
    rather than relying on keyword-based searches like “log in” or “authenticate.”
    This capability is especially valuable for onboarding new team members and helping
    them quickly understand complex codebases without deep familiarity with project-specific
    terminology.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 生成人工智能（GenAI）在代码仓库中的另一个强大应用是语义搜索——使用自然语言搜索整个代码库的能力。像 Sourcegraph 的 Cody 和 Harness
    代码仓库这样的工具使开发者能够提出诸如“认证是如何实现的，这段代码在哪里？”等问题，而不是依赖于基于关键字的搜索，如“登录”或“认证”。这种能力对于新团队成员的入职和帮助他们快速理解复杂的代码库，而不需要深入了解特定项目的术语，特别有价值。
- en: Regarding code reviews, tools like DeepCode and Codacy use ML algorithms to
    review code changes, automatically detecting potential bugs, code smells, and
    adherence to coding standards more efficiently than manual reviews. Other use
    cases for AI in SCMs are enhancing security by automatically scanning for vulnerabilities
    and compliance issues before code is committed and recommending fixes for those
    issues, summarizing pull requests, and generating software delivery pipelines
    using SCM as one of the data sources.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码审查，DeepCode 和 Codacy 等工具使用机器学习算法来审查代码变更，比人工审查更有效地自动检测潜在的错误、代码异味和遵守编码标准。在源代码管理系统中，人工智能的其他用例包括在提交代码之前自动扫描漏洞和合规性问题以增强安全性，总结拉取请求，以及使用源代码管理作为数据源之一来生成软件交付管道。
- en: It is important to note that with AI systems, results depend heavily on the
    data used to train the AI models. So, for example, “good” code will result in
    good code suggestions and reviews, and “bad” code will result in bad code suggestions
    and reviews.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，要注意，在使用人工智能系统时，结果在很大程度上取决于用于训练人工智能模型的数据。因此，例如，“良好”的代码将产生良好的代码建议和审查，而“不良”的代码将产生不良的代码建议和审查。
- en: Measuring the impact of AI is equally important in verifying whether using AI
    has actually had a positive impact on the developers. Tools such as Harness Software
    Engineering Insights and others can help with measuring the productivity of developers
    using different coding assistants and also compare them with the developers that
    don’t use any coding assistants.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测量人工智能的影响在验证使用人工智能是否真正对开发者产生了积极影响方面同样重要。像 Harness 软件工程洞察力和其他工具可以帮助测量使用不同编码助手的开发者的生产力，并将它们与不使用任何编码助手的开发者进行比较。
- en: AI-powered SCMs accelerate time-to-market by generating fast and reliable code
    (especially when well-trained), improving code quality by identifying issues—including
    security vulnerabilities—at the source, and enhancing team collaboration by elevating
    the quality and efficiency of code reviews.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能驱动的源代码管理系统通过生成快速且可靠的代码（尤其是在良好训练的情况下），通过在源头识别问题——包括安全漏洞——来提高代码质量，并通过提高代码审查的质量和效率来增强团队合作，从而加速上市时间。
- en: Efficiency and Transparency Through Open Source
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过开源实现效率和透明度
- en: Whether or not your DevOps tools are open source is an important consideration.
    Open source solutions can be cost-effective for organizations with budget constraints,
    and the transparency they offer has advantages as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你的DevOps工具是否开源是一个重要的考虑因素。对于预算有限的组织来说，开源解决方案可以具有成本效益，并且它们提供的透明度也有优势。
- en: Proprietary solutions can often claim to offer reliable uptime and dedicated
    customer support teams to address any technical issues you encounter. However,
    there are often subscription fees for enterprise users, which can be a significant
    cost factor for small teams. Open source codebases are free to use, making them
    ideal for teams with limited budgets. The open source nature allows for transparency
    and community-driven development. Developers have access to the source code, enabling
    customization of the platform to fit specific needs. However, they often have
    to rely on the community for troubleshooting and support. While valuable, open
    source may not offer the same level of guaranteed assistance as a commercial provider.
    In addition, while open source promotes transparency, it also means potential
    vulnerabilities are publicly visible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 专有解决方案通常可以声称提供可靠的正常运行时间和专门的客户支持团队来解决你遇到的任何技术问题。然而，企业用户通常需要支付订阅费用，这可能是小型团队的一个重大成本因素。开源代码库是免费使用的，这使得它们非常适合预算有限的团队。开源的本质允许透明度和社区驱动的开发。开发者可以访问源代码，使平台可以根据特定需求进行定制。然而，他们通常必须依赖社区进行故障排除和支持。虽然开源很有价值，但它可能不会提供与商业提供商相同的保证援助水平。此外，虽然开源促进透明度，但也意味着潜在漏洞公开可见。
- en: Open core solutions, like Harness.io and GitLab, provide a middle ground. They
    offer a free, feature-limited version, akin to open source.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Harness.io和GitLab的开源核心解决方案提供了一个中间地带。它们提供了一个免费、功能有限的版本，类似于开源。
- en: Lastly, OSS can be put into escrow if needed for regulatory requirements or
    to ensure continuity of business generally. This provides assurance that in the
    event the tool provider goes out of business you will still have access to the
    tools needed to build, test, and monitor your application and to recreate your
    development, testing, and production environments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果需要满足监管要求或确保业务连续性，开源软件（OSS）可以存入保证金。这提供了这样的保证：如果工具提供商停业，你仍然可以访问构建、测试和监控应用程序以及重新创建开发、测试和生产环境所需的工具。
- en: A Platform Approach
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台方法
- en: Traditional, piecemeal DevOps toolchains often create data silos and hinder
    visibility into the entire SDLC. However, a single DevOps platform offers a compelling
    solution by providing end-to-end visibility. For example, it enables tracking
    of every change, from the initial commit in the code repository to the final deployment
    on production servers. This holistic view helps you to identify bottlenecks, pinpoint
    potential issues early in the development cycle, and measure the overall effectiveness
    of your DevOps practices. Furthermore, comprehensive audit trails provide a clear
    record of all activity, simplifying troubleshooting and ensuring compliance with
    security regulations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的、零散的DevOps工具链往往会产生数据孤岛，阻碍对整个SDLC的可见性。然而，一个单一的DevOps平台通过提供端到端的可见性提供了一个有吸引力的解决方案。例如，它允许跟踪每个更改，从代码库中的初始提交到生产服务器上的最终部署。这种全面的视角有助于你识别瓶颈、在开发周期的早期阶段确定潜在问题，并衡量你的DevOps实践的整体有效性。此外，全面的审计跟踪提供了所有活动的清晰记录，简化了故障排除并确保符合安全法规。
- en: A unified platform also streamlines governance and unlocks the potential for
    intelligent automation. Managing governance policies across disparate tools can
    be cumbersome and error-prone. A single platform allows you to define and enforce
    policies consistently throughout your entire development pipeline. This ensures
    code adheres to coding standards, security best practices, and internal guidelines.
    For example, you can streamline governance by implementing a policy such as *scan
    code before committing, during the CI process, and during the CD process using
    (your organization’s) approved security scanner.* With a unified platform this
    can be easily implemented as a template that gets reused.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个统一的平台还可以简化治理并释放智能自动化的潜力。跨不同工具管理治理政策可能是繁琐且易出错的。一个单一的平台允许你在整个开发管道中一致地定义和执行政策。这确保了代码遵循编码标准、安全最佳实践和内部指南。例如，你可以通过实施一个政策来简化治理，比如*在提交代码之前、在CI过程中以及在使用（你组织的）批准的安全扫描器进行CD过程中扫描代码*。在一个统一的平台上，这可以很容易地作为一个模板实现，该模板可以重复使用。
- en: Additionally, with a complete understanding of the deployment context, including
    infrastructure and configuration details, the platform can offer intelligent code
    suggestions that optimize performance and efficiency. Imagine an AI-powered assistant
    that recommends code tweaks based on how the service will be deployed, potentially
    saving development time and improving code quality.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过对部署环境（包括基础设施和配置细节）的全面理解，平台可以提供智能代码建议，以优化性能和效率。想象一个由AI驱动的助手，根据服务的部署方式推荐代码调整，可能节省开发时间并提高代码质量。
- en: Access Control, an Example
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制，一个示例
- en: As teams assemble a delivery toolchain, it’s common to start with individual
    point solutions. However, this piecemeal approach can lead to significant operational
    overhead. In this section, we’ll look at the example of RBAC to see how a cohesive
    delivery pipeline can simplify operations and empower development teams.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队组建交付工具链时，通常从单个点解决方案开始。然而，这种零散的方法可能导致重大的运营开销。在本节中，我们将通过RBAC的示例来了解如何一个统一的交付管道可以简化操作并赋予开发团队权力。
- en: Most collaboration tools use role-based access to functionality in some form
    or another. Code repositories will support built-in roles, or will include built-in
    roles and will allow users to define custom roles. GitHub, for example, defines
    the roles *Read, Triage, Write, Maintain,* and *Admin*. These roles correspond
    to levels of access; the Read role is recommended for noncode contributors, whereas
    the Admin role is designed for users who require full access to the project, including
    sensitive and destructive actions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数协作工具以某种形式使用基于角色的访问来控制功能。代码仓库将支持内置角色，或者包括内置角色并允许用户定义自定义角色。例如，GitHub定义了以下角色：*读取、分类、编写、维护*和*管理员*。这些角色对应于访问级别；读取角色建议用于非代码贡献者，而管理员角色是为需要完全访问项目（包括敏感和破坏性操作）的用户设计的。
- en: 'These systems use RBAC, a method of managing access to resources within a system
    that centers on three core elements, namely users, roles, and permissions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统使用基于角色的访问控制（RBAC），这是一种在系统中管理资源访问的方法，其核心是三个基本元素，即用户、角色和权限：
- en: Users represent individuals or accounts requiring access.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户代表需要访问的个人或账户。
- en: Roles are defined sets of permissions that grant access to specific resources
    or actions within the system.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色是一组定义明确的权限，它授予对系统内特定资源或操作的访问权限。
- en: Permissions are the fundamental units of control, defining what actions a user
    can take (like reading, editing, or deleting data).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限是控制的基本单元，定义了用户可以执行的操作（如读取、编辑或删除数据）。
- en: Users are not directly assigned permissions. Instead, they are assigned one
    or more roles. Once a user is assigned a role, they inherit all the permissions
    associated with that role. This approach simplifies access management by eliminating
    the need to individually assign permissions to every user. Instead, permissions
    are defined at the role level, and users are granted access based on the roles
    they are assigned. [Figure 2-6](#chapter_2_figure_6_1749354010071315) illustrates
    users assigned to roles and the sets of permissions associated with roles.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不是直接分配权限。相反，他们被分配一个或多个角色。一旦用户被分配了角色，他们就会继承该角色关联的所有权限。这种方法通过消除为每个用户单独分配权限的需要来简化访问管理。相反，权限在角色级别定义，用户根据分配的角色获得访问权限。[图2-6](#chapter_2_figure_6_1749354010071315)说明了分配给角色的用户和与角色关联的权限集。
- en: '![](assets/ansd_0206.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ansd_0206.png)'
- en: Figure 2-6\. Users are assigned to roles; permissions are associated with roles
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-6\. 用户被分配到角色中；权限与角色相关联
- en: Using role-based access is a common pattern that reduces administrative and
    enhances security by enforcing the principle of least privilege—users are granted
    only the permissions necessary for their job functions. Role-based access also
    helps with compliance, as it provides clear documentation of who has access to
    what within the system.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于角色的访问是一种常见的模式，通过强制执行最小权限原则来减少管理负担并增强安全性——用户仅被授予完成其工作职能所需的权限。基于角色的访问还有助于合规性，因为它提供了关于系统内谁有权访问什么的明确文档。
- en: Defining Roles, a Platform Approach
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义角色，平台方法
- en: Imagine a DevOps ecosystem consisting of a Git repo, Jenkins, Terraform to manage
    an AWS infrastructure, Ansible for configuration management, and Datadog to capture
    performance metrics. In a system like this, constructed of several disparate tools,
    you might find that you need to define similar roles in each system, and repeatedly
    add the same. Provisioning a new developer might take several time-consuming steps.
    Let’s look at how an all-in-one platform handles RBAC using a platform approach.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个由 Git 仓库、Jenkins、Terraform 管理的 AWS 基础设施、Ansible 进行配置管理和 Datadog 捕获性能指标组成的
    DevOps 生态系统。在这样的系统中，由多个不同的工具构建，你可能发现需要在每个系统中定义类似的角色，并反复添加相同的角色。为新开发者提供配置可能需要几个耗时的步骤。让我们看看一个一站式平台如何通过平台方法处理
    RBAC。
- en: 'As an example, the Harness Platform has a three-level hierarchical structure.
    The three levels, or scopes, are Account, Organization (Org), and Project:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Harness 平台为例，它具有三级层次结构。这三个级别或范围是账户、组织（Org）和项目：
- en: Account is the topmost entity. It can exercise control and has visibility over
    the entire platform.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户是最顶层的实体。它可以对整个平台进行控制和可见。
- en: Organization is a unit of control where people and projects from the same business
    unit can be organized in an independent hierarchy. An organization can have multiple
    projects.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织是一个控制单位，来自同一业务单元的人员和项目可以组织在一个独立的层次结构中。一个组织可以拥有多个项目。
- en: Projects represent the basic unit of collaboration in which users are grouped
    together to work on the same task.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目代表了协作的基本单位，用户被分组在一起共同完成同一任务。
- en: Resource Groups are an RBAC component that define the objects that a user can
    access. Objects are any Harness resource, including projects, pipelines, connectors,
    secrets, delegates, environments, users, and more. When you assign a Resource
    Group to a user, the access defined in the Resource Group is granted to the target
    user. Resource Groups can be defined at any scope.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 资源组是 RBAC（基于角色的访问控制）组件，用于定义用户可以访问的对象。对象可以是任何 Harness 资源，包括项目、管道、连接器、机密、代表、环境、用户等等。当你将一个资源组分配给用户时，资源组中定义的访问权限将授予目标用户。资源组可以在任何范围内定义。
- en: Roles likewise can be defined at each scope. Roles are applied together to Resource
    Groups to create a complete set of permissions and access. For example, you can
    assign the Pipeline Executor role to a Resource Group that only allows access
    to specific pipelines, rather than all pipelines in the project.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 角色同样可以在每个范围内定义。角色应用于资源组，以创建一组完整的权限和访问权限。例如，你可以将管道执行者角色分配给仅允许访问特定管道的资源组，而不是项目中的所有管道。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced SCM, a cornerstone of modern software development.
    SCM addresses the challenges of team collaboration and managing changes to codebases
    over time. It enables teams to collaborate effectively and manage code changes
    over time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 SCM，它是现代软件开发的基础。SCM 解决了团队协作和随时间管理代码库变化的挑战。它使团队能够有效地协作，并随着时间的推移管理代码变更。
- en: SCM is essential to DevOps and CI/CD workflows, and its role is expanding with
    the emergence of AI-native SCM systems. These intelligent systems can generate,
    review, analyze, and optimize code, transforming how teams write and manage software.
    By automating routine tasks, enhancing accuracy, and surfacing insights, AI-powered
    SCM systems accelerate development and improve delivery efficiency.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: SCM 对 DevOps 和 CI/CD（持续集成/持续部署）工作流程至关重要，并且随着 AI 原生 SCM 系统的出现，其作用正在扩展。这些智能系统可以生成、审查、分析和优化代码，改变团队编写和管理软件的方式。通过自动化常规任务、提高准确性和揭示见解，AI
    驱动的 SCM 系统加速了开发并提高了交付效率。
- en: We also discussed the importance of selecting the right code repository and
    the benefits of a unified DevOps platform for cohesive workflows and stronger
    governance. With a solid SCM foundation in place, [Chapter 3](ch03.html#chapter_3_the_build_and_pre_deployment_testing_steps_of_cont_1749354010266208)
    dives into how continuous integration automates builds and unit tests to ensure
    code quality and development speed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了选择正确代码仓库的重要性以及统一 DevOps 平台对协同工作流程和更强治理的好处。在建立了坚实的 SCM（源代码管理）基础之后，[第 3
    章](ch03.html#chapter_3_the_build_and_pre_deployment_testing_steps_of_cont_1749354010266208)
    深入探讨了如何通过持续集成自动化构建和单元测试来确保代码质量和开发速度。
