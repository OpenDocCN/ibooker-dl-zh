- en: 1 Exploring FinTech and generative AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A brief introduction to FinTech
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the ACH is and why it is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use full stack development to build an ACH dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits and pitfalls of generative AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term “FinTech” became common in the last few decades as shorthand for financial
    technology. In fact, *financial technology* is a term that could be applied to
    inventions from long ago, such as the 19th-century cash register and telegraph,
    and even the earliest coin purses from circa 3,300 BCE. Today, FinTech helps empower
    crowdfunding opportunities through websites such as GoFundMe and Kickstarter.
    Gig service apps such as Uber and DoorDash rely on FinTech to facilitate fast
    payments. Payment services such as Venmo and Zelle can offer fast person-to-person
    (P2P) and business-to-business (B2B) payments thanks to FinTech. Cryptocurrencies
    like Bitcoin and Ethereum are certainly classified as FinTech, but even the more
    traditional banking, investing, and credit companies have FinTech at their core.
  prefs: []
  type: TYPE_NORMAL
- en: What is FinTech, then? Simply put, it is using technology to improve the handling
    of money. Today, FinTech refers to software that offers quicker, more convenient,
    and/or new ways to handle money.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a FinTech developer has the opportunity to work on many kinds
    of software. It should not be hard to imagine that the career paths open up for
    full stack FinTech developers, or those who can work on all aspects from frontend
    to backend. We are fond of saying that a full stack developer gets to be curious
    about many different areas. As a full stack developer, you will have opportunities
    to work on the different pieces that compose an application—from the user interface
    (UI) that customers will see down to the backend processing that fulfills requests
    from the UI and everything in between.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine receiving a reported problem about a customer interaction that is taking
    too long and ruining the user experience (UX). Where other developers will have
    to throw in the towel at one of their assigned boundaries, you will have the opportunity
    to trace that problem from the button click, through the application programming
    interface (API), to the server, and down to the specific Structured Query Language
    (SQL) statement to see how it can be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: This book will teach you about full stack development using a real-world FinTech
    project. The book aims to provide a high-level understanding of several aspects
    of software development encountered at FinTech companies, both large and small.
    After working through the project presented in the following chapters, you should
    have a better understanding of the areas of software development that interest
    you most and which topics you may want to dive deeper into. In much the same way
    that FinTech and full stack provide us with many different opportunities, we hope
    to present the reader with similar opportunities for learning both FinTech and
    software development. The varied topics should fire your imagination and encourage
    you to dive deeper into one or more topics.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 The Futuristic FinTech project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book will take you on a journey as a new software developer with a fictional
    FinTech company known as Futuristic FinTech. This means that it will be beneficial
    for you to have a little software development experience in a modern programming
    language, as we do not aim to teach you programming from the ground up. Instead,
    you should have a basic understanding of loops, if-statements, and similar. As
    this book does not focus on a single language or technology, newer developers
    should find much to learn about, while more seasoned developers should find some
    new tools or techniques.
  prefs: []
  type: TYPE_NORMAL
- en: To help you put your learning into practice, this book will take on a typical
    project for a large company such as Futuristic FinTech. This project addresses
    the need to modernize one of Futuristic FinTech’s numerous products. Products
    that need modernization are usually existing products that have been with the
    company for a long time. They are usually well established in their marketplace
    and used by many customers. The company may undertake modernizing these products
    for any number of reasons, such as
  prefs: []
  type: TYPE_NORMAL
- en: The company owns a product due to an acquisition or merger that does not meet
    the company’s existing design guidelines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product has come under renewed scrutiny because of new compliance or regulatory
    changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product is being repositioned in its marketplace or marketed to a new audience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product requires expensive hardware or additional software to maintain it,
    and modernizing it will provide a more cost-effective solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project we are undertaking is the updating of a dashboard related to a payment
    system common for facilitating payment (such as paying a mortgage or car loan)
    and movement of funds (transferring money from a checking account to a higher-interest
    savings account at another institution) in the United States—the Automated Clearing
    House (ACH).
  prefs: []
  type: TYPE_NORMAL
- en: Our ACH dashboard project will require us to gain an understanding of ACH processing
    and full stack development as we tackle the aspects of database design, APIs,
    backend processing, and presenting everything within a UI. Along the way, we introduce
    different approaches and technology that we have worked with as FinTech developers
    ourselves. We will also explore how generative AI tools can make us more productive
    in our daily work, helping us to write, troubleshoot, and conduct many other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 ACH dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, we will be building out an example payment system commonly used
    in US-based payments known as the ACH. However, the ACH system will often interact
    with equivalent systems in other countries such as
  prefs: []
  type: TYPE_NORMAL
- en: Electronic Funds Transfer (EFT) in Canada
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Euro Payments Area (SEPA) in Europe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bankers Automated Clearing System (BACS) in the United Kingdom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk Electronic Clearing System (BECS) in Australia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: National Automated Clearing House (NACH) in India
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACH payments are a great way to get introduced to FinTech because they are a
    real-world example of how transactions flow between financial institutions. Once
    we have transactions flowing into a database, the world of FinTech will really
    open up to us. We will touch on many areas of software development and FinTech
    as we build out and then enhance our ACH dashboard, as shown in figure 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the pieces that feed into the dashboard helps see the big picture. We
    can also take a look at how these pieces may come into play when loading an ACH
    file into the dashboard. Figure 1.2 gives us a high-level overview of the sequence
    of events that our dashboard will eventually execute once it is built out. Being
    able to load ACH files is the first step in interacting with the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a company  Description automatically generated](../Images/CH01_F01_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1  Building the ACH dashboard
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once we complete the ACH dashboard, we will take a look at all of the potential
    paths that are open to our project and hopefully find a fascinating direction
    to take the project in. While ACH likely affects us on a regular basis (is your
    payroll automatically deposited, or do you schedule credit card payments, mortgage
    payments, or other loans?), it is equally likely that you never heard of it before.
    Let us look at just how important the ACH is.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 How important is the ACH?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Figure 1.3 shows the trends in noncash payments in trillions of dollars between
    2000 and 2021 as gathered by the latest Federal Reserve Payments Study ([https://mng.bz/5g2z](https://mng.bz/5g2z)).
    Notice how ACH transfers have been dramatically increasing, taking a larger part
    of business, especially since the decline of checks.
  prefs: []
  type: TYPE_NORMAL
- en: ACH is a dominant US standard, but there is a rise in the need for real-time
    payments. Earlier, we had mentioned P2P and B2B. There are other payment types
    as well, but the underlying idea is a quick real-time payment between two accounts.
    In response, ACH has developed the idea of same-day ACH, which can considerably
    speed up the time it takes to process an ACH payment, moving it from days to hours.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software system  Description automatically generated](../Images/CH01_F02_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2  Loading a file through the ACH dashboard
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Real-time payments and their providers are positioning this standard as the
    next revolution in payments, and they are likely to gain some traction in the
    future. Real-time processing is set to be responsible for $10 billion per year
    by 2026, still a long way to go to affect the trillions of dollars processed by
    ACH every year. In either case, the lessons learned from this book will give us
    a handle on payment processing regardless of the technology being used. Now that
    we have an understanding of ACH, let us take a look at how we are going to accomplish
    building out this project, which will be done using an Agile methodology known
    as SAFe.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 SAFe Agile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the 17th Annual State of Agile Report, 71% of respondents use Agile
    in their software development lifecycle (SDLC) (see [https://mng.bz/6e2y](https://mng.bz/6e2y)).
    This book draws on principles from SAFe Agile because we have direct experience
    with it at large Fortune 500 FinTech companies. Moreover, Scaled Agile (the creators
    of SAFe) states that over 20,000 organizations worldwide use the Scaled Agile
    Framework (SAFe).
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph of different colored lines  Description automatically generated](../Images/CH01_F03_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3  Year-over-year comparison of various payment methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As mentioned, even large FinTech companies that can traditionally lag in the
    adoption of technology have made the switch to Agile. The large fictitious FinTech
    company we joined known as Futuristic FinTech is no exception and has adopted
    SAFe as their approach to development. In the following chapters, as we build
    out our ACH project, we’ll try to adhere to some of the principles of the framework
    and Agile methodology in general. One of the key events in SAFe Agile is the Program
    Increment (PI) Planning Session, which helps plan out the work for the coming
    sprints.
  prefs: []
  type: TYPE_NORMAL
- en: Definition A program increment (PI) is a timebox (a set amount of time) that
    is anywhere from 8 to 12 weeks long. The PI usually consists of four iterations
    called “sprints”; that term is from Scrum and has been used by many different
    software tools (e.g., JIRA). A sprint is typically a two-week period but can be
    more or less, depending on what the teams decide.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the PI planning, the division displays a product roadmap for the
    coming year that shows various commitments the business has made, expected regulatory
    changes, and company initiatives. During this PI planning session, work will be
    broken up into epics. These epics are larger projects or initiatives. For instance,
    some companies may call their release an epic (such as the Spring 2024 release),
    and projects for the release are broken down into user stories. Still others may
    create their individual projects as epics and break down tasks for that project
    as user stories. Throughout the book, we try to work in short development cycles,
    and that is one of the main concepts of Agile as well. If we are breaking up the
    work into smaller manageable pieces, we should be okay, regardless of what we
    call those smaller chunks (of course, having some consistency helps with communication).
  prefs: []
  type: TYPE_NORMAL
- en: The Agile methodology
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It should not come as a big surprise that every company is different. Many FinTech
    companies have their roots in Waterfall methodology but have moved to Agile recently.
    It is likely that we will encounter groups (divisions, business units, or teams)
    that follow Agile in different capacities—from the purists to those that have
    been dragged along kicking and screaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our aim is not to teach Agile per se, but rather to roughly work within the
    bounds of an Agile framework as we work through our project. If you want to dive
    into Agile more deeply, we encourage you to take a look at *Becoming Agile* (2009,
    Manning) by Greg Smith and Ahmed Sidky, and the Agile Manifesto ([https://agilemanifesto.org/](https://agilemanifesto.org/))
    is a required reading as well. But don’t worry: the manifesto is a quick read!'
  prefs: []
  type: TYPE_NORMAL
- en: The PI planning is about coming together as a group, and you will interact with
    business analysts, QA, developers, tech writers, and so forth to come up with
    a plan for the coming work. Figure 1.4 shows a PI planning board using a template
    found in Miro, a popular collaboration tool for just this type of activity.
  prefs: []
  type: TYPE_NORMAL
- en: On the PI planning board, we should be able to find our team and assigned work.
    In our case, we have been assigned a project to create a new ACH dashboard as
    part of a companywide initiative to modernize legacy software. Typically, the
    PI planning session lasts for a day with the focus on prioritizing work, determining
    dependencies, and hammering out requirements that must be met. In addition, we
    identify risks using a ROAM (resolved, owned, accepted, mitigated) board and finally
    take a confidence vote where everyone uses a “fist-of-five” vote where they hold
    up their hand and vote (or via supported tools). If the average vote is a three
    or higher, the plan is committed, and we can get to work. If not, we review and
    rework the plan. Often, there are concerns about the amount of work, time to complete
    it, and any existing knowledge gaps. Working through these concerns is part of
    the process, and it can take some time. We are going to fast-forward through that
    and jump into the project that our team has been assigned since we can always
    find out more about SAFe and all its moving parts on their website ([https://scaledagileframework.com/](https://scaledagileframework.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 The ACH dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coming out of PI planning, we should have a promising idea of our project and
    the goals we are aiming for within the coming sprints. Our team has picked up
    the stories for modernizing the ACH dashboard. Modernizing legacy software can
    be tricky as not only must we deal with the technical challenges of design and
    development but also consider the effects of our changes on the customers as well.
    Some industries (and
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH01_F04_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4  PI planning template in Miro
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: individuals) can be notoriously slow to change. In the case of individuals,
    they know the current system, processes, and its idiosyncrasies. They have learned
    how to navigate the system to get their work done, so why change something that
    works? These are reasonable questions that we should consider for any project.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the company has treated our ACH dashboard project, as a utility
    type task—a necessity for business but nothing more. However, since ACH is such
    a large part of how transactions are being processed by financial institutions,
    customers have begun asking for enhanced functionality for some time now. To maintain
    a competitive advantage, the business wants to modernize the dashboard. There
    is potential for better analytics of the transactions, fraud monitoring, as well
    as expanding the use of the dashboard to customers originating transactions. With
    these capabilities on the agenda, we need to look at providing a product that
    not only provides those capabilities but has a look and feel consistent with the
    rest of the products offered. Figure 1.5 shows an example of how the legacy interface
    currently looks.
  prefs: []
  type: TYPE_NORMAL
- en: While the interface is functional, there is room for improvement. The business
    has reported the limitations that the team should work to address.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH01_F05_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5  Legacy ACH Interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The current limitations of the legacy interface are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unable to upload file**s*—Operations must currently ensure the files are uploaded,
    and then the back office can select them from the drop-down. This creates an unnecessary
    delay in processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rudimentary reportin**g*—Only file totals are reported. This method does not
    produce meaningful analytics. The system stores files in a legacy database that
    lends itself to reporting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Access limitatio**n*—The interface requires a connection to the backend server
    running on an IBM Power, while this system can run a webserver. Our SecOps team
    prefers to offload this task to a different server due to the extensive routing
    and firewall protection in place for this server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Stylin**g*—The new dashboard will eventually be marketed as a separate component
    in a wider system or to end-users that manage ACH files. The business wants existing
    style guidelines to be applied to the new project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The business has envisioned a modern website (figure 1.6) that will address
    these concerns and has assigned our team to work on this project.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH01_F06_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6  Modern ACH dashboard
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The technical architects have also provided requirements from the technical
    side to support the company’s modernization initiative. Figure 1.7 provides an
    overview of the ACH dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software application  Description automatically generated](../Images/CH01_F07_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 ACH dashboard initiative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The modernization initiative includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PostgreSQ**L*—Ensure a relational database is used and that ACH files are
    parsed into the database so that the Business Intelligence group can perform analytics
    on the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Next.j**s*—Use a production-ready React framework such as Next.js. Ensure
    that the interface can support visualizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docke**r*—We want to ensure our application is split into components that
    are running in containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pytho**n*—Currently, our legacy applications, such as the ACH processing system,
    are written in COBOL. New projects should use Python as the primary language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be noted that we can substitute any of these components as we deem
    necessary (for the purposes of working on this project; on the job, chances are
    we will not have that luxury). That is something that we will bring up repeatedly
    in the following chapters. For instance, if you are more comfortable with MySQL
    or your company uses Java instead of Python and you would be better served by
    using those technologies, then, by all means, use them. You may have a tougher
    time reworking the examples from Python into Java (if you do not have experience
    in one or the other), but you will also learn a lot that way as well. Is there
    a technology you wish we had used instead? Feel free to reach out and let us know—perhaps
    we will tackle that next!
  prefs: []
  type: TYPE_NORMAL
- en: We would also like to note that the process of modernization is something that
    you will come across repeatedly in your career. It may be that all the Python/Java/Golang
    code in your company will need to be replaced by the next generation of languages
    at some point in your career. It may be that the company will hire a new chief
    technology officer who is more experienced in another technology stack and wants
    to move in that direction. Regardless of whether the decision is good or bad,
    we may be forced to endure the transition. Now that we have a bit more understanding
    of the project, let us take a look at some of the tools we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.1 Tools of the trade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of the ACH dashboard project, the team will be using the following tools.
    As in the previous section where suggested that readers may choose to replace
    Python with Java, or choose to use MySQL in place of Postgres— depending on their
    current technology stack—the same applies to these tools. If there are tools that
    are more suited to your current environment, please feel free to use those. Many
    of these tools will be discussed later, but we wanted to give you an idea of the
    toolset being used.
  prefs: []
  type: TYPE_NORMAL
- en: The tools selected by our team are
  prefs: []
  type: TYPE_NORMAL
- en: '*JetBrains PyChar**m*—Either the community or professional edition. We use
    the Professional edition and run our APIs, UI, and Docker from within it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JetBrains Webstor**m*—An additional tool for our UI development in Next.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Visual Studio Cod**e*—We use it for working with Docker and Plant UML, but
    it can also be in place of JetBrains PyCharm/Webstorm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JetBrains Qodan**a*—Used for code review.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ChatGPT*—We chose it for coding assistance because there is a free version
    available for use to experiment with. Also, if our company cannot not provide
    an integrated experience, we can still use generative AI by accessing [https://chat.openai.com/](https://chat.openai.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GitHub Copilo**t*—It provides AI coding assistance for various IDEs. Having
    a subscription to GitHub Copilot will let us get assistance in PyCharm, Webstorm,
    and Visual Studio Code, to name just a few.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also introduce various plugins that we use as well; however, we wanted
    to ensure that we set the playing field before we started to dive into the rest
    of the book. It is also possible to run the project using a single IDE. Personally,
    we tended to use JetBrains PyCharm Professional for all the development (Python,
    Next.js, and Docker) and that worked out great.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the project, let us take a closer look at generative AI.
    This book is not a comprehensive book on generative AI. For that, you may want
    to look at *Introduction to Generative AI* (2024, Manning) by Numa Dhamani and
    Maggie Engler or *Generative AI in Action* (2024, Manning) by Amit Bahree. Instead,
    we will briefly introduce generative AI and some important concepts when working
    with it. Then, as we work through the project, we will show some specific cases
    where we found generative AI helpful (and some where it was a hindrance).
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 A first look at generative AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In their last companywide meeting, Futuristic FinTech’s executive team expressed
    an interest in adopting generative AI tools to help drive efficiencies within
    the company. Several initiatives have been started in different company divisions
    to evaluate different tools and ways to incorporate generative AI. The ACH dashboard
    project can also use generative AI with the modernization project. The company
    has asked that we gain a better understanding of the capabilities, limitations,
    and liabilities of generative AI. So, what is one way we can think of generative
    AI?
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.1 A better rubber duck
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can think of generative AI as the next iteration of the rubber duck. Rubber
    duck debugging was popularized by the book *The Pragmatic Programmer* by Andy
    Hunt and Dave Thomas (Addison-Wesley, 1999), and it provides a way of encouraging
    us to voice our thought process to a less intimidating audience than our boss
    or team lead! By speaking out loud to a rubber duck (or any inanimate object),
    we are often able to identify the problem before involving anyone else. We have
    often called over a co-worker only to point at the screen showing our captive
    audience how this piece of code could not possibly fail, only to see the immediate
    problem with our solid piece of code. Having a rubber duck to “bounce” ideas off
    is an invaluable resource (and quite cost-effective). If we are shy of speaking
    out loud (even when no one is around), some tools offer the ability to type out
    our thoughts. Slack has a channel that functions as a sounding board for our thoughts.
    Entering the channel will display “You can also talk to yourself here, but please
    bear in mind you’ll have to supply both sides of the conversation.” There is also
    a rubber duck chatbot service at [https://rubberduckdebugging.com/cyberduck/](https://rubberduckdebugging.com/cyberduck/)
    and multiple generative AI rubber duck sites such as [https://rubberducktherapy.app/](https://rubberducktherapy.app/).
  prefs: []
  type: TYPE_NORMAL
- en: We can look at generative AI as the evolution of that rubber duck. Generative
    AI allows our rubber duck to provide ideas and feedback instead of just a sounding
    board. We will still encourage the use of a rubber duck as well because it provides
    insight into our thought process and a cheap therapist when our day is long, and
    our code is uncooperative.
  prefs: []
  type: TYPE_NORMAL
- en: Generative AI is a subset of machine learning that powers tools such as ChatGPT
    and GitHub Copilot. Generative AI can generate new content and is based on the
    use of large language models (LLMs). We see generative AI being quickly adopted
    into workflows in a variety of industries and roles, not just in technical areas
    but also in areas such as HR and marketing. Generative AI provides us with greater
    efficiency, which in turn saves time, and we all know time is money.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we put a FinTech spin on the old classic “Hello, World!”
    program with generative AI.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.2 Hello, Check 21!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '“Well, where to begin?” we may think when we first see the ChatGPT prompt.
    We may want to get started with diving right in and seeing the kind of coding
    chops ChatGPT has, but let us first take a look at some other possibilities with
    ChatGPT. FinTech is filled with regulations that we need to be aware of, so we
    first ask it to “Please summarize the Check 21 regulation.” After reading the
    response, we find it to be a little dry as we are software developers, not business
    analysts. So, while we may need the details later on, we just want to get a general
    impression. We can try refining our prompt: “Summarize the benefits of Check 21
    for the average bank customer.” This gives us something that may be a little more
    aligned with what we wanted to understand from the beginning. We could refine
    our prompt further: “Tell me about Check 21 in a couple of sentences,” and we
    again get a suitable response. One interesting thing to ask is “If we had to describe
    Check 21 in a single word, what would it be?” The response was “Digitalization,”
    which is actually a pretty good way to describe it.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as software developers, we came here to code! Let us assume that
    we do not have any Python coding experience, but maybe we have knowledge of other
    languages and software development in general. We would like to see if ChatGPT
    can get us going with Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take the traditional “Hello, World!” program, but put a FinTech twist
    on it by instead printing “Current Balance: $1000.00.” With ChatGPT, we say, “In
    Python, show me the code to print a line that says ‘Current Balance: $1000.00’”
    and we get the associated code of print (“Current Balance: $1000.00”). It is important
    to note that the updates to ChatGPT and the fact that ChatGPT is not deterministic
    may cause the responses that we receive to vary. We may find that we enter the
    same prompt multiple times and receive different responses each time. So, if you
    are following along, it is okay if some of the responses vary slightly.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with Python, all we have to do is print a single line; we do
    not have the overhead of importing libraries or setting up main functions that
    we may find in Java or C. So, we decided to expand on that program a little bit
    by telling ChatGPT, “Expand the program to allow the user to enter the current
    balance amount that is then printed.” That also works as expected, giving us a
    simple program shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.1  ChatGPT-generated code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Accepts input from the keyboard and stores it in current_balance'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Prints a line saying Current Balance and formats the current_balance accordingly'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the code, we decide that it may be more useful if we were to break
    this out into a function. We then ask the system to “Update the sample code to
    call a function that prints the `current_balance`.”
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.2  ChatGPT updated code with a function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a function that takes a parameter of the current balance'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Documentation of the function and its parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The print statement has been moved to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Calling the function with the user input'
  prefs: []
  type: TYPE_NORMAL
- en: The code is looking better, and it is nice that we received a commented code
    for the function using Google Style docstrings. However, we believe the code would
    be more maintainable if it were to include type hints, as mentioned at [https://peps.python.org/pep-0484/](https://peps.python.org/pep-0484/).
    So, we then request that the system includes the type hints as well by entering
    “Please add type hints to the above code.”
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.3  Code expanded with type hints
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We now show that current_balance is a string and the function does not return
    anything.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we really like the simple program we have written so far. However, when
    looking at the return value for `print_balance`, we see it is returning `None`.
    This makes sense since we are only calling a print statement within the code.
    However, to make the code even more maintainable, we can just return the formatted
    string and let the caller decide how they want to handle it. After all, this function
    should not decide how to handle the output as the caller may want to write it
    to a file or return it in an API call. We believe it is a good habit not to assume
    that the return value will always be handled the same way (in this case, printed).
    Often, we have had to rework large swaths of code because of an assumption that
    it would always be printed (in one of our cases, printed to an open network connection).
    The resulting business logic was so intertwined and the deadline so tight that
    we ended up copying the existing code and ripping out the print statements, so
    we could return what we needed. This resulted in technical debt (work that needed
    to be done in the future to address the duplicated code). Therefore, we want to
    return just the formatted string to get us into the habit of not assuming our
    function should be doing something specific with the output. So, we then tell
    ChatGPT to return a string instead of printing it, “Update the code so that `print_balance`
    will return the string and then print it.”
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.4  Returning a string
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The function has been updated to show it returns a string.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Documentation has likewise been updated.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns the string instead of printing it'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Stores the balance in a variable called user_input, which is of type string'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Stores the formatted string in a variable called formatted_balance, which
    is of type string'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Prints the formatted string'
  prefs: []
  type: TYPE_NORMAL
- en: It is very interesting that we are able to create a working program with just
    our software development knowledge and not necessarily any knowledge of Python
    (maybe we would need to look up typing for Python). While this shows that ChatGPT
    can be very helpful, it will only be as helpful as the information that we put
    into the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt engineering and problem formulation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Generative AI has led to a lot of buzz in the areas of prompt engineering and
    problem formulation. Somewhat ironically, these are not only subjects for generative
    AI but probably areas we should have been working on in our daily lives anyway!
    Prompt engineering is referred to as being able to craft meaningful input (prompts)
    for the LLM to decipher. After all, the model will need to be able to parse the
    prompt and form a response, so the input does matter because garbage in results
    in garbage out more often than not. Thus, prompt engineering focuses on
  prefs: []
  type: TYPE_NORMAL
- en: Clear and specific prompts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping prompts concise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correct grammar and spelling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using examples when appropriate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a notion that prompt engineering is not that important as models are
    continuously improving and becoming increasingly better at handling prompts. However,
    being able to clearly articulate our perspective and keeping it concise is a skill
    that most of us could benefit from. Have you ever just stopped reading a lengthy
    email? Yup, us too. While prompt engineering may be something that falls out of
    favor, there are many different approaches, some of which may currently be necessary
    depending on the problem you are working with. We recommend checking out various
    techniques defined at [https://www.promptingguide.ai/techniques](https://www.promptingguide.ai/techniques)
    or Generative AI in Action by Amit Bahree (Manning, 2024).
  prefs: []
  type: TYPE_NORMAL
- en: Problem formulation refers to the ability to clearly define our problem. This
    is another skill that is obviously applicable to daily life, not just to our new
    generative AI overlords. Would we rather work with someone who asks for our help
    by saying, “This program is broken, and I sure didn’t do anything wrong!” or the
    co-worker who says, “I tried to speed up execution of this program for the DevOps
    group as part of ticket 123, and now the formatting is off”?
  prefs: []
  type: TYPE_NORMAL
- en: While having generative AI write our code can be helpful, as new software developers,
    we will be fielding a lot of support-type work where we need to troubleshoot problems.
    Let us look at how generative AI may help us with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.3 Help! This code is not working!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another benefit of generative AI is the ability to help us identify problems
    with code. This can be valuable for keeping our sanity or making us look like
    a hero to our co-workers. For example, let us say we have code that should keep
    a list of the last transactions a customer made so that we can easily retrieve
    them in our code. Probably not an unreasonable feature for most financial software.
    In the following listing, we defined a simple function that keeps a list of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.5  Simple function to store transactions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a function that takes a list of transactions, a new transaction,
    and the maximum number of transactions to keep; this defaults to three if nothing
    is passed.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 If the length of stored transactions exceeds our maximum, then get rid of
    the first one.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Stores the new transaction'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Returns the updated list of transactions'
  prefs: []
  type: TYPE_NORMAL
- en: It’s reasonably straightforward—we pass in a list of transactions and the transaction
    we want to add to the list along with a maximum size to keep the list at. If we
    exceed the length, we get rid of the first item using the method with a parameter
    of zero to remove the first item from the list. When we write a program that uses
    this function, we see that it does not behave quite as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.6  Using our function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports our function'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines an empty list containing strings'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Adds some transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Prints the results'
  prefs: []
  type: TYPE_NORMAL
- en: The output from listing 1.6 is `['deposit` `$300',` `'deposit` `$400']`, so
    we only have two items, not three as we would have expected the default to be.
    So, either the logic to default the parameter to `3` is not working, or the logic
    to pop transactions is not working. Another possibility is that something is happening
    that we are not anticipating. Keep that in mind because, on occasion, we will
    be staring at a part of the code we think is the problem, but we can’t figure
    it out. We may spend hours struggling only to find that both the problem and answer
    lie in another part of the code. We have some unit tests that go along with this
    problem as well, which are shown in the next listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.7  Defining a unit test for our function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines our expected number of transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 An assert test to ensure we have the expected number of transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 We expect the first value passed should have been dropped, and so we have
    “deposit $200”.'
  prefs: []
  type: TYPE_NORMAL
- en: So, if we wanted to take a break and look at fixing this for ourselves before
    moving on, we certainly could do that now. Then we can come back and see what
    ChatGPT
  prefs: []
  type: TYPE_NORMAL
- en: gives us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Welcome back! Hopefully, we were able to give this a try to play around with
    the code a little bit, but let us jump right back in and enter this into ChatGPT.
    As we saw, the code from listing 1.5 has a logic flaw: we expect to see three
    transactions listed but only see two. We simply ask ChatGPT, “Why doesn’t this
    code work?” which we did on purpose just to disregard some of the prompt engineering
    and problem formulation that we discussed earlier. We wanted to see what type
    of response we would recieve, and it was a great response as ChatGPT identified
    two problems that it did not like with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![image](../Images/Response-Chatgpt.png)** The code you’ve provided is aimed
    at adding a new transaction to the user’s transaction list while ensuring that
    the length of the list doesn’t exceed the given “max.” If adding a new transaction
    would exceed the “max,” the oldest transaction is removed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a couple of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The name “max” is a built-in Python function that returns the largest of the
    input values. It would be better to avoid using it as a variable name. Let’s change
    it to something like “max_length.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The condition for popping a transaction is “if len(user_transactions) + 1 >=
    max:”. This means if you have “max_length = 3” and the current length of “user_transactions”
    is 2, it will remove the first transaction before adding the new one, thus always
    keeping the length as 2\. This is incorrect. The correct condition should be “if
    len(user_transactions) + 1 > max_length:”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we can see, a couple of problems were pointed out: first, we used the name
    “max” in our code. Our IDE flagged this as well since `max` is a built-in Python
    function. As we saw earlier with this name shadowing, the code will still work
    but can become a bit more convoluted when trying to follow it. Second, the other
    suggestion was to update the if statement in the code to be `if` `len(user_transactions)`
    `+` `1` `>` `max_length:`. With either of these solutions in place, we can rerun
    the code or rerun the tests to confirm that the code is working better.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing we always find interesting is the number of solutions to any problem;
    sometimes we solve something only to go back later and say, “What were we thinking!?”
    We thought that ChatGPT would have just dropped the `+` `1` and kept the existing
    logic. If we found that puzzling, then we might ask ChatGPT about it. We followed
    up with “What if we were to change the line to `if len(user_transactions)` `>=
    max_length:`?” and ChatGPT gave us some additional information but also confirmed
    that “this change will indeed make the code work correctly for the intended purpose!”
    We have the code and `pytests` confirming both ways.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot really provide insight into why ChatGPT chose one way over another,
    but we take this as confirmation that, again, generative AI is a tool that can
    be used but should not necessarily be taken as the end all be all. We tried to
    follow up with “Is there a performance benefit to one way versus the other?” and
    ChatGPT gave a reasonable answer. One thing we found interesting was that it started
    putting `if` `len(user_transactions)` `>=` `max_length:` as its suggested change
    and favored it because it was intuitive and provided better readability. Either
    way, we hope that you will also see the usefulness in being able to get some feedback
    from generative AI tools to help us determine code flaws and potential enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it is not necessarily a code problem that we have but more of a “I
    am sure that you need to use an equal sign to assign a variable, but it is not
    working.” Generative AI can be of huge help when you know what you want to do
    but cannot quite remember how to do it in a particular language or environment.
    We look at how generative AI can help in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.4 Help! I forgot the syntax!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another benefit of generative AI is just getting started with the syntax. Sometimes,
    as a full stack developer, constantly switching from one language to another can
    make us dizzy. We may find ourselves knowing what we want to accomplish but not
    being quite sure how to get there. As we saw with the first example, we can have
    our generative AI tools get started for us as long as we know how we want to go
    about the process. For instance, in our first example, we were able to define
    a function, pass parameters, and use type hints. If we are not aware of these
    constructs or are unwilling to learn about them, then it is unlikely that generative
    AI will be of much use to us.
  prefs: []
  type: TYPE_NORMAL
- en: Let us try another example from full stack development. Previously, we were
    working with Python, but let’s switch gears and jump to the UI with HTML5 and
    D3.js. We like to use VS Code with the Live Server plugin when working with HTML
    and scripting. Everyone has varying levels of experience with HTML5 and D3.js,
    from never having heard of them to an expert. However, even if our experience
    is having seen a bar graph or used one on a website, we can work our way through
    this without too many problems. We can ask ChatGPT to “create a simple d3.js bar
    chart in an html5 page” and end up with something respectable but, by no means,
    award winning (figure 1.8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH01_F08_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 Simple bar chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The code shows the data being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That graph looks okay, but we want to add some labels to the axis. That should
    be something we have come across when seeing visualizations before and should
    not be that far of a jump for us to consider adding to the visualization. We can
    simply enter, “Can you update the code to add axis labels?” at the prompt, and
    we will see that labels were successfully added. Even though we may not be sure
    how to write the code, we know what we want the code to do, and that is enough
    to get us going in the right direction for this example. See the output with axis
    labels in figure 1.9.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH01_F09_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9  Bar chart with axis and labels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is looking pretty good now. We may not win any contests, but it certainly
    helps get the point across with our visualization. Now, we can see about adding
    a little interactivity when we hover the mouse over a bar. We enter “Can the code
    be updated to change the bar color and display the value for the bar when I hover
    with the mouse?” on the prompt, and we get an interactive graph. The bar changes
    color from blue to orange when we hover along with the value being displayed near
    the mouse. Playing around with this, we can see it works reasonably well, but
    one thing we are not happy with is that the tooltip with the value appears where
    the mouse enters the bar but doesn’t move with the mouse as it moves within the
    bar itself. We could fix this by updating the code to update the position when
    the mouse moves, or maybe we should just display the value above the bar when
    we hover, or perhaps just display the value above the bar all the time. Feel free
    to play around with some of these or implement other approaches!
  prefs: []
  type: TYPE_NORMAL
- en: We asked for the tooltip to be displayed above the bar. Figure 10.1 shows the
    final shot of what we ended up with.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH01_F10_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10  Highlighting and hovering in our bar chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The label does not appear quite centered, and when it is displayed over the
    largest bar, it goes off-screen. We could probably coerce ChatGPT into getting
    it just the way we want, or we could dive into the code and try to work through
    it. Either way, we should have been able to come up with a decent bar graph even
    if we have not used D3.js or are not familiar with HTML. These code snippets can
    also act as training tools for us to play around with the code to use and learn
    from. Maybe we aren’t sure how to use the `append` or `on` methods from d3.js,
    reviewing these samples or the generated code is a great way to see them in action.
  prefs: []
  type: TYPE_NORMAL
- en: Verification
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since we just worked through some examples that we may not have been very familiar
    with, it is probably a good time to go over verification. We should never have
    tools such as ChatGPT write us a bunch of code that we could never understand.
    It can be beneficial to see how things are done, and we can even use it to generate
    code for ourselves (see the following sections for some additional insights on
    security/privacy/ownership concerns). But remember that sticking that code in
    and checking it means that we will own it. There have been many times where we
    have been asked about a code change that we made a decade ago because we were
    the last person to change that module.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a Perl one-liner generated from ChatGPT that validates an email address
    is formatted correctly. Feel free to insert it into your existing software solution—just
    be ready to own it in the middle of the night when the support staff calls you
    to say that the customer email import process is broken!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you were unfamiliar with regular expressions and Perl, how likely would you
    be to put that in your code?
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of tools such as ChatGPT is the ability to ask for references.
    Perhaps, after seeing the regular expression to validate an email, you decide
    that you may want to validate the results by doing a bit more research. By asking
    ChatGPT to provide sources for the code, it will refer you to the Perl documentation
    (`perldoc`). It will also refer to general regular expression knowledge, as well
    as the official standard for email addresses (RFC-5322). This can give us a good
    starting point when we want to learn a bit more about code we do not understand.
  prefs: []
  type: TYPE_NORMAL
- en: We see how powerful and helpful generative AI is, but in the next section we’ll
    take a look at a potential pitfall when using it.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.5 Did I just give away my data?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next example of the benefits of generative AI is the ability to have it
    take input and process it for us. For example, let us say that a banker provides
    us with a report file, and they want some reporting done with it. They provide
    us with a comma-separated value (CSV) file and want us to total it up. Why they
    cannot do that in Excel is beyond us, but we figure it may be a good chance for
    us to get some additional Python practice and maybe try generative AI. We are
    provided some data formatted as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we paste that data into the prompt, ChatGPT responds with “It looks like
    you’ve provided a list of Social Security Numbers (SSNs) paired with account numbers
    and corresponding balances. How can I assist you with this data?” which is a very
    nice response. Compare that response to one we may receive from your co-worker
    if you just threw a similar printout in front of them.
  prefs: []
  type: TYPE_NORMAL
- en: So, at the prompt, we enter “Given this sample file, write a python program
    to print a report with totals” and paste in our data below the prompt. It prints
    the program from the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1.8  Sample report program
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code looks reasonable, so we go ahead and run it. However, the code runs
    into a value error: `ValueError:` `could` `not` `convert` `string` `to` `float:`
    `''"1.00"''`. So, the code produced from ChatGPT contains an error. We can try
    to fix this on our own, or we can let ChatGPT know that it has a problem. Feel
    free to review and troubleshoot the error to see whether it can be fixed before
    moving on!'
  prefs: []
  type: TYPE_NORMAL
- en: The problem turned out to be the quotes in the `balance_str`. To correct it,
    we can add an additional `replace` to handle the double quotes, so the line becomes
    `balance_str` `=` `line.split(",")[2].strip().replace('$',` `'').replace('"',`
    `'')`.
  prefs: []
  type: TYPE_NORMAL
- en: While this is potentially a very helpful way to use generative AI, there are
    some potential drawbacks. One is that we have just entered nonpublic information
    (NPI) into ChatGPT. If the tool we are using ingests the data for training, then
    potentially, we have exposed customer information to an insecure source, as it
    may show up in responses to other users. We must be very careful about the data
    that we enter into any tool, not just when using generative AI, as we want to
    be sure that the information is stored securely. In our case, any SSN starting
    with `000` is invalid, so we are not using real data.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We covered the potential concerns about entering secured data into generative
    AI, and we should also be aware of entering proprietary information into it as
    well. If our proprietary code is being used to train the system, it may not be
    proprietary for very long. Always look at the Terms of Service (ToS) and End-User
    License Agreement (EULA).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another concern may be that of ownership of responses: if we ask the model
    to generate some code that goes into a product which we are selling, then who
    owns that code? Do we have to pay royalties to them? These types of questions/concerns
    are what we should keep in mind as we make the transition of student or developing
    for personal use versus developing in a corporate environment. Corporations can
    be very prickly about releasing sensitive data and rightfully so. Their business
    may depend on trade secrets, and there could be substantial fines for mishandling
    sensitive data.'
  prefs: []
  type: TYPE_NORMAL
- en: Concerns about ownership lead us to similar concerns about privacy and security,
    which we discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.6 Privacy and security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other areas of generative AI that we need to be aware of—which will be a pervasive
    topic throughout our careers—are the areas of privacy and security. It may be
    possible that feeding our code into a generative AI tool is helping to train it,
    and our proprietary code could end up getting output as an answer to someone else’s
    prompt. Tools such as GitHub Copilot specifically state that they do not store
    or share our code. In that same aspect, we will need to be careful about sensitive
    information such as nonpublic information (NPI) or personally identifiable information
    (PII) that we input into the model as well.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe we want the generative AI tool to summarize the quarterly earnings report
    for each business unit, so we can create a compelling infographic and think that
    generative AI could make that helpful. Well now, we have just potentially shared
    corporate/trade secrets with the model! So, some care and thought should be given
    to what we enter the system. If using generative AI to troubleshoot problems as
    we did in the previous section, it may be beneficial to create a smaller code
    snippet that is more generalized but still suffers the same problem we are troubleshooting.
    Who knows, we may just figure out the problem in the process!
  prefs: []
  type: TYPE_NORMAL
- en: The Open Worldwide Application Security Project (OWASP) has specific guidance
    on the adoption of generative AI at [https://genai.owasp.org/](https://genai.owasp.org/).
    It is interesting to review the OWASP Top 10 for LLMs and generative AI and see
    what type of exploits we may encounter. Knowing about the potential dangers will
    hopefully help us avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.7 Staying up to date
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One last concern might be how recent the data in the model is. If the model
    is based on older data, we may not get the results we intend. In the majority
    of cases, we have seen when asking tools such as ChatGPT for the latest version
    of Java or NPM, it is aware enough to qualify its response. In other cases, our
    question may indicate that it is a potential version problem. For instance, when
    asking ChatGPT “How do I connect to PostgreSQL in Python?” it provides a reasonable
    example of using `psycopg2`. However, there is a newer rewrite of `psycopg2` called
    `psycopg3`. If we try to refine our example and ask ChatGPT to use `psycopg3`
    instead of `psycopg2`, it again says that its data may be out of date:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![image](../Images/Response-Chatgpt.png)** It seems like there might be a
    typo in your request. As of my last knowledge update in September 2021, there
    is no library called  `psycopg3`.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if we were not aware of `psycopg2` or given instructions to use `psycopg3`,
    we may be thrown off course a little bit but not to worry. We might think that
    if there was confusion about whether our assignment was `psycopg2` or `psycopg3`,
    we could easily ask our co-workers. However, if we are new to the job and thrown
    into the deep end of the pool, we may be reluctant to ask our new mentor (who
    is undoubtedly very busy) to clarify such a simple oversight.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to see that we can ask ChatGPT to treat `psycopg3` as a drop-in
    replacement for `psycopg2` by entering the following at the prompt`:` “`psycopg3`
    is a rewrite of `psycopg2`. Can you simply replace `psycopg2` with `psycopg3`
    in the given example?”
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, ChatGPT will again generate a reasonable response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![image](../Images/Response-Chatgpt.png)** I apologize for the confusion
    earlier. Since I don’t have information about `psycopg3` as of my last update
    in September 2021, I’ll assume its usage is similar to `psycopg2`. If `psycopg3`
    is indeed a rewrite of `psycopg2`, the usage should be quite similar.'
  prefs: []
  type: TYPE_NORMAL
- en: This is yet another aspect of verification that we must be aware of—if the tools
    are not up to date and giving us suggestions, there could be vulnerabilities to
    the particular version or various improvements that we might be missing out on.
    Again, generative AI is giving us a good starting point, but it is still up to
    us to do some due diligence to ensure everything is on the up and up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FinTech encompasses a wide range of financial technologies, historically from
    cash registers to modern-day applications, including crowdfunding, gig service
    apps, P2P payments, and cryptocurrencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The book targets full stack developers in FinTech, covering end-to-end application
    development, including UI, backend processing, and troubleshooting through real-world
    examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SAFe Agile framework is widely used in FinTech companies and is significant
    in program increment planning in managing software development projects. Legacy
    systems are being modernized using new tools and frameworks, such as PostgreSQL,
    Next.js, Docker, and Python. These changes have a significant effect on both users
    and businesses. Generative AI is seen as an evolution of the rubber duck debugging
    method, providing active feedback and ideas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generative AI uses LLMs and is integrated into various industries for increased
    efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generative AI assists in coding, debugging, syntax recall, and generating code
    snippets across programming languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers should be cautious about relying on AI for up-to-date information due
    to potentially outdated training data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
