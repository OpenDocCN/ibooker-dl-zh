- en: 4 Building software with GitHub Copilot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs: []
  type: TYPE_NORMAL
- en: Developing the core of our system using Copilot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring to apply patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating hexagonal architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating event-driven principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the last chapter, we used ChatGPT to help us design our information technology
    asset management (ITAM) system. Now, with the design firmly in hand, we begin
    to build out this application, starting with the domain model. The domain model
    is the core of our system. It represents the classes that will be applying and
    enforcing our business rules. We will use GitHub Copilot extensively in this chapter.
    The most important takeaway from this chapter is that using a large language model
    (LLM) helps to illuminate the unknown unknowns: that is, the non-obvious, the
    arcane, or the hidden complexity in the systems that we build. It makes the hard
    things easier and the seemingly impossible, possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One additional note: this chapter is code-heavy. Your code almost certainly
    will not exactly match the code presented in this chapter. Instead of dwelling
    on this fact, accept it. Try to understand why these differences exist. Observe
    if altering your prompt modifies the result, and if it does, in what ways.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Laying the foundation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first section of this chapter, we lay the foundation for the rest of
    our application. We begin with the core of our application: the domain model.
    The domain model should contain the unvarnished business rules and responsibilities
    of our application, free from the outside world, focusing solely on business logic
    and workflows. As you can see from figure 4.1, the domain sits at the heart of
    our application. This is no coincidence, given that it is the heart of the application.
    We will return to this figure throughout this chapter as we deepen our understanding
    of and appreciation for hexagonal architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F01_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 A traditional visualization of hexagonal architecture in which the
    domain, or business logic, sits in the middle
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture, as you will recall from the last chapter, is an architectural
    pattern that aims to create a clear separation between an application’s core logic
    and its interaction with external systems. This principle is clearly on display
    in the figure 4.1.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1 Expressing our domain model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we begin, let’s review the documentation we created in the last chapter
    with the assistance of ChatGPT. The class diagram (figure 4.2) will provide us
    with a template for implementation. As we should know by now, we will not mindlessly
    implement every aspect of the code and documentation that ChatGPT provides. Doing
    so may inadvertently lead to a design that is brittle and hard to change, insecure,
    or incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F02_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 The domain object model that ChatGPT produced for us, highlighting
    the relationships between the classes
  prefs: []
  type: TYPE_NORMAL
- en: If we drill into the methods and fields for the `Asset` class we created in
    the last chapter (see figure 4.3), note two things. First, it differs from the
    `Asset` class we created in chapter 2\. Second, ChatGPT suggested that we have
    a constructor that takes all the attributes for this class; however, it also added
    mutator methods—the *setters*—for all the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F03_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 The `Asset` class we created with the assistance of ChatGPT. It includes
    a constructor and mutator methods for each attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 Favoring immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Immutable objects, in which the internal state cannot be changed, make classes
    more secure and more amenable to concurrency. Should two or more threads access
    the same object, we do not need to synchronize access; the state will almost certainly
    be the same for both threads. Therefore, we will favor constructor-based value
    injection over mutator methods. When we code this class, we will not add mutators.
  prefs: []
  type: TYPE_NORMAL
- en: First we will pull the `purchase_date` field up from `Hardware`. This field
    is shared among all `Asset`s (this book will not discuss cases in which `Asset`s
    are leased); therefore, the `purchase_date` field should belong in the parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to add a few additional fields that are not present in our design
    from the last chapter: `cost`, `useful_life`, and `salvage_value`. These fields
    will be necessary to correctly calculate *depreciation*. You may remember that
    depreciation is an accounting method used to allocate the cost of an asset over
    its useful life. You should notice that the terms `cost` and `useful_life` appear
    in that definition. Thus these fields are required. In addition, the salvage value
    is the amount of money a business, department, or company can expect to get from
    selling the asset at the end of its useful life. This field is essential in some
    depreciation calculations; therefore, we will add it to our class. Create a package
    called `domain`/`model`, add a file called asset.py, and then add the following
    prompt to the beginning of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you tab through the file to have GitHub Copilot autogenerate the code for
    you, you may notice that it will create the mutator despite us explicitly instructing
    it not to do that. For this and many other reasons (as we will see throughout
    this chapter), you must remain vigilant and mindful as you code. Of course, you
    can signal your intent, but these tools may override your desires in the way the
    tools construct code. Additionally, you may notice that Copilot added the `@dataclasses`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator Design Pattern is a structural design pattern that allows you
    to add new or modify existing behavior to an object dynamically without changing
    the existing class. This is done by wrapping the existing object in the decorating
    object.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting exercise for an intrepid explorer would be to ask Copilot to
    assume the persona—using the Persona Pattern—of a software engineer. Does this
    change the output in any meaningful way?
  prefs: []
  type: TYPE_NORMAL
- en: Definition *Design patterns* are common solutions to recurring design problems
    in software development. We will explore them more throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.3 Decorating our favorite classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This decorator autogenerates common methods for Python (equals and string representation,
    among others). A data class is a class that is primarily used to store data and
    does not have much behavior. In Python, data classes were introduced in Python
    3.7 as a utility to make classes that are mainly used to store data cleaner and
    more efficient. This is opposed to a user-defined class, whose purpose can be
    mixed (that is, data and behavior). Using a data class in this context is useful
    in that you can avoid boilerplate code for constructing, representing, and comparing
    objects. Also, for those keeping score at home, our autogenerated code is autogenerating
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.1 Code that GitHub Copilot creates in response to our prompt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `__post_init__()` method will run after the constructor and enforce that
    none of the parameters are null (`None` in Python parlance). Coding defensively
    this way will ensure that your values cannot change after initialization. Of course,
    you are free to add additional validations as well, such as acceptable values
    for the status of the category. But if you wish to enforce values in that case,
    it is better to do so by making them proper classes or using the `Enum` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s review the `Hardware` class in the Mermaid diagram we created in
    the last chapter (see figure 4.4). There are several items to note from this diagram:
    it contains neither accessor nor mutator methods. We will need to add accessor
    methods to our prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F04_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 The `Hardware` class that we drafted with the aid of ChatGPT. Note
    that it does not have any accessor methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have reviewed and assessed what methods and attributes we need
    in our `Hardware` class, we can build it. Create a file called hardware.py in
    the domain directory. At the beginning of this file, add the following prompt
    to have GitHub Copilot create our `Hardware` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The post-constructor code and accessor methods are not included in the code
    listing, for brevity’s sake. However, they should be automatically added to your
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.2 Definition of the `Hardware` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, given that it was referenced in the `Asset` class, let’s add the `FundingDetails`
    class. First, however, let’s review the class diagram (see figure 4.5). Notice
    that the `lines_of_business` dictionary, which we will rename to `department_allocations,`
    uses a string as the key. We should change this to be an actual `Department`.
    This is another reminder that we must actively monitor the generated code and
    make decisions about how to best implement the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F05_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 The `FundingDetails` class that we drafted with the aid of ChatGPT.
    We need to change the `lines_of_business` dict (renamed to `department_allocations`)
    to use a `Department` as the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make two additional edits to this class. First, we need to include
    the `Asset` in the constructor. This will allow us access to the fields needed
    for calculating depreciations, as previously mentioned. Additionally, we need
    to include a depreciation rate in the constructor. This is used for declining
    depreciation but not straight-line depreciation. We could set the value of this
    field in the specific deprecation constructor or use a mutator method, but for
    now we will add it to the `FundingDetails` class. The updated prompt to create
    the `FundingDetails` class, including the updated field name, is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing surprising in the generated class: the code establishes the
    internal attributes and sets them via the constructor. After the constructor has
    finished, it will check that all attributes are `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.3 `FundingDetails` class (post constructor and accessor omitted)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final class we will generate in this chapter is `DepreciationStrategy`.
    In the last chapter, we were briefly introduced to this class. What we did not
    mention at the time was that this class will employ a new design pattern: the
    *Strategy* Pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Strategy Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy Pattern is a behavioral design pattern that lets you define a family
    of algorithms, encapsulate each one as an object, and make them interchangeable.
    The idea behind the Strategy Pattern is to define a common interface for a group
    of algorithms so they’re interchangeable despite having potentially very different
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4 Adapting a strategy for depreciation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we attempt to create the `DepreciationStrategy` class, let’s review
    the class diagram that we created in the last chapter (see figure 4.6). The implementations
    of this class contain substantial hidden complexity. If we don’t give Copilot
    very specific instructions about how the calculations are to be performed, it
    will not come up with the correct algorithms. For example, here’s an incomplete,
    inexact prompt to create `DepreciationStrategy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/CH04_F06_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 The interface class `DepreciationStrategy` defines the functionality
    to calculate the depreciation of our assets in our domain model. There are four
    concrete classes representing how we can depreciate an asset.
  prefs: []
  type: TYPE_NORMAL
- en: This prompt will return methods that, at first sight, appear correct. But they
    are not. For example, if we examine the straight-line depreciation method, we
    see that it neither includes the salvage value in the calculation nor uses the
    useful life.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.4 Incorrect implementation of straight-line depreciation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To correct this, we should update the prompt with the actual formulas for the
    depreciation methods. Fortunately, we do not have to provide the exact syntax,
    just the calculations. Copilot will translate our algorithms to validate Python
    code. Here is the updated prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can use pseudocode. Copilot handles the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.5 Output from our prompt to calculate depreciation methods
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Many other classes are left undefined. Feel free to practice perfecting your
    prompt engineering by implementing the missing classes. For example, you may want
    to add `Organizations`, `MaintenanceSchedule`, `Address`, `UsageStatistics`, `User`,
    `Role`, and `Warranty`. In the next section, we will work with Copilot to apply
    patterns to our code, starting with a familiar one.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Weaving patterns, patterns, patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we enrich our domain model with commonly used design patterns.
    They represent best practices and can be used to speed up the development process
    by providing a set of proven solutions to certain problems. Design patterns are
    not ready-to-use code snippets but rather general guides on how to solve a particular
    problem in a way that is flexible and can be reused across different projects.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Paying a visit to our department
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first pattern we will revisit is *Visitor*. As you may recall from chapter
    3, you use the Visitor Pattern to add new behavior to or change the existing behavior
    of a given class. Figure 4.7 shows how it was modeled in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F07_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 The `DepartmentVisitor` interface (updated to use the new name; previously
    called `LineOfBusinessVisitor`). This class “visits” both hardware and software,
    holding the total cost and depreciation internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s design a prompt to have Copilot generate an implementation of our `Visitor`
    Pattern, `DepartmentVisitor`, which visits our `Asset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Copilot generates the straightforward implementation of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.6 `Vistor` implementation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 4.2.2 Creating objects in a factory (pattern)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Factory* Pattern is another creation pattern that allows you to abstract
    away some of the details of the object you are attempting to create. In our ITAM
    system, we have two types of `Asset` (currently): `Hardware` and `Software`. Each
    of these objects has attributes idiosyncratic to itself. One effect of this is
    that our application does not need to know the specifics of the concrete class
    (`Hardware`, for example). From the application’s perspective, it just gets an
    instance of `Asset` with additional fields. Let’s look at how to get Copilot to
    create an `AssetFactory` class for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This prompt is one of the most detailed we have encountered. As our needs get
    more and more niche, our prompts will naturally become more meticulous. Let’s
    examine this code in detail, starting with the `new` method.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.7 Code for `AssetFactory`, containing two embedded factories
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `new` method determines which of the specific factories it needs to call
    based on the `asset_type` parameter. Additionally, it keeps track of the number
    of assets it has created, ensuring that the identifier (`id` field) is always
    unique. Otherwise, if the identifier creation were pushed down to the specific
    `Factory` object, we would get duplicate keys.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.8 Embedded `HardwareAssetFactory` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `new` method of the `HardwareAssetFactory` class is relatively straightforward.
    This method accepts the parameters from the `AssetFactory`, attempts to resolve
    the `DepreciationStrategy`, and sets some sensible defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.9 Embedded `SoftwareAssetFactory` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `SoftwareAssetFactory` class is nearly identical to the `HardwareAssetFactory`
    class—so much so that it likely has a code smell. The term *code smell* in software
    development describes an intuition a developer has, indicating that there may
    be a deeper problem with the code. It is not a bug per se, but a feeling. You
    may find yourself with the urge to refactor, because this does appear to violate
    the DRY principle (Don’t Repeat Yourself).
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is an easier way to handle this deduplication. To do this, we will
    look at our next design pattern: the *Builder* Pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Builder Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Builder Pattern is a creational design pattern that provides a fluent API
    for the creation of objects by providing step-by-step instructions for how to
    create an object.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.3 Instructing the system on how to build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we will write a prompt to have Copilot create our builders: one for `Asset`
    and one for `FundingDetails`. We will let the builder know that if `asset_type`
    is hardware, it should return an instance of `Hardware`, and the same for `Software`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note is that all the values need to be stored in local variables;
    otherwise, we would encounter post-initialization exceptions. The generated code
    for the `AssetBuilder` is is shown next. The `import` statements and accessor
    methods are omitted for the sake of brevity. One thing worth mentioning is that
    the methods return `self` so they can be chained together.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.10 Corresponding `AssetBuilder` classes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next we will examine the `build()` method of the `AssetBuilder` class. This
    method uses the `category` field to return the correct subclass of `Asset`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.11 `build()` method for the `AssetBuilder` classes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can now look at `FundingDetailsBuilder`. This class closely resembles `AssetBuilder`,
    but without the polymorphic `build()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.12 `FundingDetailsBuilder` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The class’s `build()` method implementation is fairly straightforward; it only
    returns an instance of the `FundingDetails` object after applying the parameters
    to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.13 `build()` method of the `FundingDetailsBuilder` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s extract the `_get_depreciation_strategy` method from the `AssetFactory`
    class, consolidating the logic of mapping the name of the depreciation strategy
    to an instance of the `DepreciationStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.14 Updated `build()` method of `FundingDetailsBuilder`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have written the builders, we can modify the `AssetFactory` to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pattern hiding in plain sight: The Adapter'
  prefs: []
  type: TYPE_NORMAL
- en: The *Adapter* Pattern is a structural design pattern that allows us to bridge
    the gap between the target interface and a class with an incompatible interface.
    For example, in our case, we could have formalized the interface for `str` ->
    `DepreciationStrategy` in an adapter called `StringDepreciationStrategyAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will update the prompt in the `AssetFactory` class to use the new builders
    to construct the instances of `Asset` and `FundingDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using the new builders will drastically reduce this class’s code volume. For
    example, the `new` method is now only eight lines long (as formatted in Microsoft
    VS Code).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.15 The updated factory method for an `Asset`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 4.2.4 Observing changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we are going to apply the *Observer* Pattern to our ITAM system. This pattern’s
    real value will become more obvious in the next chapter, but we will sow the seeds
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Observer Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Observer Pattern is a behavioral pattern in which the `Subject` class reports
    certain state changes to observer classes via notifications. The pattern is useful
    in user interfaces and event-driven systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new class called `AssetManager` in the directory service.
    The `AssetManager` class will be responsible for interacting with the outside
    world (more on this in the next section). This prompt instructs Copilot about
    to how to define this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our current implementation of `AssetManager` uses a list to track the lifecycle
    of the `Asset`s it manages. `AssetManager` supports all the CRUD (create, read,
    update, and delete) operations of `Asset`s.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.16 Implementation of `AssetManager`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s update our prompt to add notifications to our `AssetManager` class. Right
    now, we will not assign any observers; we will save that for chapter 5, when we
    start to deal with data flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In response to our prompt, if we re-create the entire class, Copilot adds the
    notification framework on which we will eventually expand.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.17 Updated `AssetManager` definition with notifications enabled
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see two more patterns in the next section of this chapter: Singleton
    and Repository. But first we need to set up a controller to interact with our
    system. That takes us to the usage of ports and adapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Plugging in ports and adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our ITAM system is beginning to come together; the core business model has
    been built out. We have applied patterns to make the code more concise, readable,
    and maintainable. There is, however, one glaring deficiency: how do we interact
    with our application? In this section, we continue to deepen our investigation
    into hexagonal architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Hexagonal architecture in review
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may recall, hexagonal architecture is an approach to designing software
    that emphasizes the separation of the core business logic from external services.
    The business logic can be thought of as the “brain” of the application. It contains
    all the important rules and constructs that the application will need to guarantee
    the correctness of the program. In this analogy, the external services are your
    “hands” or “eyes;” they allow interactions with the outside world (user interfaces,
    database, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture separates the main program logic from the outside parts
    like buttons, screens, and databases. It makes it easy to change those outside
    parts without changing the main program. It does this by using *ports* that define
    how the outside parts can interact with the main program and *adapters* that make
    those interactions happen in a concrete way.
  prefs: []
  type: TYPE_NORMAL
- en: This approach makes it easier to change and evolve the application over time.
    If a change needs to be made to one of the external systems, the application’s
    core should be unaffected; you only need to update the adapter (see figure 4.8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F08_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 A more conceptual visualization of the hexagonal architecture in
    action. Notice that the core is segregated from the rest of the system and is
    only interacted with via ports.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 Driving our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will begin by building out a driver for the system. A *driver* is a system
    external to the context boundary of the application that sends requests to the
    system and, optionally, receives responses from the application. A conventional
    example is a Representational State Transfer (commonly referred to as REST) call
    from a web browser to a REST controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will add a REST controller to our ITAM system. It will expose the
    functionality provided by the `AssetManager` class. Create a directory called
    infrastructure/API in which to create a file called asset_controller.py. At the
    beginning of this file, add the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Given that we do not specify the path to use, Copilot may produce inconsistent
    or invalid paths with the routes. The following code was output in VS Code in
    response to the previous prompt. The route is `asset` rather than `assets`; it’s
    more of a preference than a standard, but in REST the nouns are generally made
    plural.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.18 Generated code with route `asset`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You may elect to manually update the code to reflect your path preference. Above
    all, though, ensure that it is consistent across the various methods. The following
    listing shows how to initialize all the services needed to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.19 Updated `main` class to reflect consistent routes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how the routes are defined and how their methods are used. The
    first two routes define how we access our `Asset` objects. The first GET request
    gets all `Asset`s that we currently have in the system. In the real world, we
    would include convenience features such as pagination and sorting. However, given
    the limited number of entries in the system currently, we will forgo this. The
    next GET method gets a specific `Asset` by its identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.20 `AssetController` methods to access `Asset`s
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The final set of routes defines how we create `Asset`s, update them, and remove
    them from our system. Note that we are not doing “soft” deletes, which would just
    set a flag and not return this `Asset` in response to subsequent queries.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.21 `AssetController` methods to modify and delete `Asset`s
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the simplified representations of the `Asset` class called, not coincidently,
    `AssetIn` and `AssetOut`. You can define those classes in the `AssetController`,
    or you can add a separate class and define them there. In the reference implementation
    for this book, they are defined in a file called asset_model.py. This prompt defines
    the `AssetIn` and `AssetOut` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With the prompt defined at the beginning of the file, Copilot generates code
    similar to the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.22 `AssetIn` and `AssetOut` classes in asset_model.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, we can add another layer of abstraction between `AssetController`
    and `AssetManager`. Doing so may be considered hexagonal architecture in extremis,
    but there are few challenges in computer science that cannot be resolved by adding
    one more layer of abstraction. We will add a port that will be used to interface
    with `AssetController`. Let’s create a prompt for the class `AssetRestPort` and
    have Copilot generate the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This prompt instructs Copilot to create an interface that we will implement
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.23 Complete source code for `AssetRestPort`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will implement this port with an adapter that will be used to interact
    with the controller to further abstract the components. We can swap out this adapter
    for another if we want to, for example, turn this into a command-line application.
    The prompt for `AssetRestAdapter` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There are two important elements to this prompt. The first is that it implements
    the port interface that we defined previously. The second is that it wraps `AssetManager`’s
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.24 Source code for `AssetRestAdapter`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do is to update `AssetController` to remove its direct
    invocation of the `AssetManager` methods and instead have `AssetController` invoke
    the methods of the adapter, which in turn invokes the methods of `AssetManager`.
    The key takeaway from the Ports and Adapters Pattern is that it abstracts the
    interaction between the driving parts of the system—in this case, the REST API—and
    the driven application: the business model and core of our system, `AssetManager`.
    To make this more explicit and as a preview, we will shortly modify this class
    again to add the port to the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.25 Updated code for `AssetController` using `AssetRestAdapter`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As previously mentioned, we will modify `AssetController` to remove all direct
    references to the `AssetManager`. Our current `AssetController`, although it does
    not directly invoke any `AssetManager` methods, does hold an indirect reference
    to `AssetManager`, because `AssetManager` is constructed in `AssetController`.
    Doing so further insulates `AssetManager` from changes in the drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 Accessing our data and persisting our changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Abstractions in software are not merely an academic matter. These abstractions
    give us flexibility when it comes to satisfying requirements and making changes.
    They can hide complexity, encapsulating behavior behind seemingly simple interfaces.
    This brings us to our next pattern: the *Repository* Pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Repository Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Repository Pattern is a design pattern that helps manage data by creating
    a separate place to handle tasks like getting, saving, updating, and deleting
    data. It connects the data source (such as a database or file) to the rest of
    the application, keeping data access code separate from other code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our ITAM project, the Repository Pattern will allow us to present a greatly
    simplified interface, masking the complexity of, in this case, our data access.
    From the perspective of the repository or `AssetManager`, our data access layer
    is just a series of methods. Behind the scenes, it may be a REST API, a Redis
    cache, MongoDB, a file, or a database of any flavor. Let’s create a prompt that
    will set up our generic data access layer using the Repository Pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With this prompt, Copilot should have everything it needs to establish the contract
    that all implementations will honor. Let’s examine the code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.26 Code for `BaseRepository`, our generic data access layer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Copilot introduced a `Generic` type, allowing for some typing hints when it
    comes time to implement. If we express that the type should be an `Asset`, the
    method signature will demonstrate this. Our first attempt at an implementation
    will be an in-memory data store. This will allow us to perform an end-to-end test
    of our entire system. It also nicely demonstrates why abstractions are useful.
    Before long, we will add another implementation that uses Postgres. But first,
    the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Our in-memory implementation will use a simple list to store `Asset`s. We will
    be able to perform all CRUD operations. Additionally, Copilot will add typing
    hints for us, letting others know that it should accept and return `Asset`s. That
    is what is meant by `BaseRepository`[`Asset`]: it’s an implementation of a `BaseRepository`
    whose `Generic` type is `Asset`.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.27 Code for `InMemoryAssetRepository`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will update `AssetManager` to delegate the CRUD operations of the
    `Asset`s to a `BaseRepository` instance (`_repository`). The full source code
    follows, including the prompt at the beginning of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.28 `AssetManager` using `InMemoryAssetRepository`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have a core business domain that is untouched directly by
    our system. We have ports by which requests can come in. We also have ports by
    which we can store the data (at least while the system is running). We should
    be able to test the system end to end by running it, POSTing requests to the creation
    end point, and reading from the GET end points. Once we have confirmed that the
    system works end to end, we can tackle the problem that our data is only persisted
    in memory; we can now hook up an actual database. To do this, we introduce the
    final pattern of this chapter: the *Singleton* Pattern. A singleton, conceptually,
    is very simple to grok; there should only ever be one instance of it running.
    It is good for many use cases: logging, caching, configuration settings, or a
    database connection manager.'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton Pattern is a design pattern that ensures a class has only one
    instance and provides a global access point to that instance. It is used when
    you want to have a single object shared across different parts of your program
    instead of creating multiple instances of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.4 Centralizing (and externalizing) our data access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will ask Copilot to create a singleton class for us to manage our database’s
    connections. We should never hardcode usernames or passwords (or any connection
    details, for that matter) in our source code, not only because it is inherently
    less secure but also because the details will likely differ depending on the environment
    (DEV versus QA versus PROD). We will therefore ask Copilot to accept these values
    as environmental variables and configure the connections using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We are asking Copilot to employ SQLAlchemy, an object-relational mapping (ORM)
    tool, to perform the actions against the database. Copilot will adroitly assemble
    our source code. The `@staticmethod` keyword creates a method that belongs to
    a class rather than the instance of the class. This keyword is used to get the
    instance of the `DatabaseConnection` class. Because a static method cannot modify
    the instance data, it can be used to ensure that only one instance of this class
    is ever running and is thus a singleton. The constructor initializes the connection
    to the database using string interpolation with environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.29 Implementation of a `DatabaseConnection`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can get a connection to our database, we need to create a repository
    that will use this connection to store and retrieve our `Asset` objects. We will
    create a class that does just that called `SQLAlchemyAssetRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.30 Prompt and code for the `SQLAlchemyAssetRepository` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Next we will refactor `AssetController` to allow us to pass in `AssetRestPort`.
    By doing this, we can swap out the driven aspect of our application. This refactor
    further abstracts the driver from the business core.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.31 Updated `AssetController` that exposes routes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can now consolidate the initialization logic of our application into the
    main.py file. This is the big payoff. Our system will have layering, facilitating
    the swapping out of components as needed or when requirements change.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.32 Final version of main.py, wiring our application together
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! We now have a running system that persists data to our database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator Pattern is a structural design pattern that allows you to add
    new object behavior or modify existing behavior dynamically without changing the
    existing class. This is done by wrapping the current object in the decorating
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Visitor Pattern adds new behavior to changes the existing behavior of a
    given class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory Pattern is another creation pattern that allows you to abstract
    away some of the details of the object you are attempting to create.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Builder Pattern is a creational design pattern that provides a fluent API
    for the creation of objects by providing step-by-step instructions for creating
    those objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adapter Pattern is a structural design pattern that allows you to bridge
    the gap between the target interface and a class with an incompatible interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer Pattern is a behavioral pattern in which the subject class reports
    certain state changes to observer classes via notifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexagonal architecture separates the main program logic from outer parts like
    buttons, screens, and databases. It makes changing outer parts easy without changing
    the main program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Repository Pattern is a design pattern that helps manage data by creating
    a separate place to handle tasks like getting, saving, updating, and deleting
    data. It connects the data source (such as a database or file) to the rest of
    the application, keeping data access code separate from other code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton Pattern is a design pattern that ensures a class has only one
    instance and provides a global access point to that instance. It is used when
    you want a single object to be shared across different parts of your program instead
    of creating multiple instances of the same class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
