- en: 4 Building software with GitHub Copilot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 使用GitHub Copilot构建软件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Developing the core of our system using Copilot
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Copilot开发我们系统的核心
- en: Refactoring to apply patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构以应用模式
- en: Integrating hexagonal architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成六边形架构
- en: Incorporating event-driven principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合事件驱动原则
- en: 'In the last chapter, we used ChatGPT to help us design our information technology
    asset management (ITAM) system. Now, with the design firmly in hand, we begin
    to build out this application, starting with the domain model. The domain model
    is the core of our system. It represents the classes that will be applying and
    enforcing our business rules. We will use GitHub Copilot extensively in this chapter.
    The most important takeaway from this chapter is that using a large language model
    (LLM) helps to illuminate the unknown unknowns: that is, the non-obvious, the
    arcane, or the hidden complexity in the systems that we build. It makes the hard
    things easier and the seemingly impossible, possible.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用ChatGPT帮助我们设计我们的信息技术资产管理（ITAM）系统。现在，随着设计的确定，我们开始构建这个应用程序，从领域模型开始。领域模型是我们系统的核心。它代表了将应用和执行我们业务规则的课程。在本章中，我们将广泛使用GitHub
    Copilot。本章最重要的收获是使用大型语言模型（LLM）有助于阐明未知未知：即在我们构建的系统中非显而易见、神秘或隐藏的复杂性。它使困难的事情变得容易，使看似不可能的事情成为可能。
- en: 'One additional note: this chapter is code-heavy. Your code almost certainly
    will not exactly match the code presented in this chapter. Instead of dwelling
    on this fact, accept it. Try to understand why these differences exist. Observe
    if altering your prompt modifies the result, and if it does, in what ways.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个额外的注意事项：本章代码较多。你的代码几乎肯定不会与本章中展示的代码完全匹配。不要纠结于这个事实，接受它。尝试理解这些差异存在的原因。观察是否改变你的提示会修改结果，如果会，那么是如何修改的。
- en: 4.1 Laying the foundation
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 奠定基础
- en: 'In the first section of this chapter, we lay the foundation for the rest of
    our application. We begin with the core of our application: the domain model.
    The domain model should contain the unvarnished business rules and responsibilities
    of our application, free from the outside world, focusing solely on business logic
    and workflows. As you can see from figure 4.1, the domain sits at the heart of
    our application. This is no coincidence, given that it is the heart of the application.
    We will return to this figure throughout this chapter as we deepen our understanding
    of and appreciation for hexagonal architecture.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们为后续的应用程序奠定了基础。我们从应用程序的核心开始：领域模型。领域模型应包含我们应用程序的未经修饰的业务规则和责任，不受外部世界的影响，专注于业务逻辑和工作流程。如图4.1所示，领域位于我们应用程序的核心。这不是巧合，因为它是应用程序的核心。随着我们对六边形架构的理解和欣赏的加深，我们将在本章中多次回到这个图。
- en: '![](../Images/CH04_F01_Crocker2.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F01_Crocker2.png)'
- en: Figure 4.1 A traditional visualization of hexagonal architecture in which the
    domain, or business logic, sits in the middle
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 传统六边形架构的视觉表示，其中领域或业务逻辑位于中间
- en: Hexagonal architecture, as you will recall from the last chapter, is an architectural
    pattern that aims to create a clear separation between an application’s core logic
    and its interaction with external systems. This principle is clearly on display
    in the figure 4.1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从上一章回忆的那样，六边形架构是一种旨在在应用程序的核心逻辑与其与外部系统交互之间创建清晰分离的架构模式。这一原则在图4.1中得到了清晰的展示。
- en: 4.1.1 Expressing our domain model
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 表达我们的领域模型
- en: Before we begin, let’s review the documentation we created in the last chapter
    with the assistance of ChatGPT. The class diagram (figure 4.2) will provide us
    with a template for implementation. As we should know by now, we will not mindlessly
    implement every aspect of the code and documentation that ChatGPT provides. Doing
    so may inadvertently lead to a design that is brittle and hard to change, insecure,
    or incomplete.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们回顾一下ChatGPT的帮助下我们在上一章中创建的文档。类图（图4.2）将为我们提供实现模板。正如我们现在所知道的，我们不会盲目地实现ChatGPT提供的代码和文档的每一个方面。这样做可能会无意中导致一个脆弱且难以更改、不安全或不完整的架构。
- en: '![](../Images/CH04_F02_Crocker2.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F02_Crocker2.png)'
- en: Figure 4.2 The domain object model that ChatGPT produced for us, highlighting
    the relationships between the classes
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 ChatGPT为我们生成的领域对象模型，突出显示类之间的关系](../Images/CH04_F02_Crocker2.png)'
- en: If we drill into the methods and fields for the `Asset` class we created in
    the last chapter (see figure 4.3), note two things. First, it differs from the
    `Asset` class we created in chapter 2\. Second, ChatGPT suggested that we have
    a constructor that takes all the attributes for this class; however, it also added
    mutator methods—the *setters*—for all the attributes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们深入查看我们在上一章中创建的`Asset`类的方法和字段（见图4.3），请注意两点。首先，它与我们在第2章中创建的`Asset`类不同。其次，ChatGPT建议我们为这个类提供一个接受所有属性的构造函数；然而，它还添加了所有属性的修改器方法——即*设置器*。
- en: '![](../Images/CH04_F03_Crocker2.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3](../Images/CH04_F03_Crocker2.png)'
- en: Figure 4.3 The `Asset` class we created with the assistance of ChatGPT. It includes
    a constructor and mutator methods for each attribute.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：我们借助ChatGPT创建的`Asset`类。它包括每个属性的构造函数和修改器方法。
- en: 4.1.2 Favoring immutability
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 优先考虑不可变性
- en: Immutable objects, in which the internal state cannot be changed, make classes
    more secure and more amenable to concurrency. Should two or more threads access
    the same object, we do not need to synchronize access; the state will almost certainly
    be the same for both threads. Therefore, we will favor constructor-based value
    injection over mutator methods. When we code this class, we will not add mutators.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象，其中内部状态不能改变，使类更加安全，并且更易于并发。如果有两个或更多线程访问同一个对象，我们不需要同步访问；两个线程的状态几乎肯定是一样的。因此，我们将优先考虑基于构造函数的值注入而不是修改器方法。当我们编写这个类时，我们不会添加修改器。
- en: First we will pull the `purchase_date` field up from `Hardware`. This field
    is shared among all `Asset`s (this book will not discuss cases in which `Asset`s
    are leased); therefore, the `purchase_date` field should belong in the parent
    class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`purchase_date`字段从`Hardware`类中提取出来。这个字段在所有`Asset`类中是共享的（本书不会讨论`Asset`类租赁的情况）；因此，`purchase_date`字段应该属于父类。
- en: 'Next we need to add a few additional fields that are not present in our design
    from the last chapter: `cost`, `useful_life`, and `salvage_value`. These fields
    will be necessary to correctly calculate *depreciation*. You may remember that
    depreciation is an accounting method used to allocate the cost of an asset over
    its useful life. You should notice that the terms `cost` and `useful_life` appear
    in that definition. Thus these fields are required. In addition, the salvage value
    is the amount of money a business, department, or company can expect to get from
    selling the asset at the end of its useful life. This field is essential in some
    depreciation calculations; therefore, we will add it to our class. Create a package
    called `domain`/`model`, add a file called asset.py, and then add the following
    prompt to the beginning of this file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一些在上章设计中没有的额外字段：`cost`（成本）、`useful_life`（使用寿命）和`salvage_value`（残值）。这些字段对于正确计算*折旧*是必要的。你可能记得，折旧是一种会计方法，用于在资产的使用寿命内分配资产的成本。你应该注意到，定义中出现了`cost`和`useful_life`这两个术语。因此，这些字段是必需的。此外，残值是指业务、部门或公司在其使用寿命结束时通过出售资产可以期望获得的金额。这个字段在一些折旧计算中是必不可少的；因此，我们将把它添加到我们的类中。创建一个名为`domain`/`model`的包，添加一个名为`asset.py`的文件，然后在这个文件的开始处添加以下提示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you tab through the file to have GitHub Copilot autogenerate the code for
    you, you may notice that it will create the mutator despite us explicitly instructing
    it not to do that. For this and many other reasons (as we will see throughout
    this chapter), you must remain vigilant and mindful as you code. Of course, you
    can signal your intent, but these tools may override your desires in the way the
    tools construct code. Additionally, you may notice that Copilot added the `@dataclasses`
    decorator.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过文件进行缩进以让GitHub Copilot为你自动生成代码时，你可能注意到它会创建修改器，尽管我们明确指示它不要这样做。出于这个原因以及许多其他原因（正如我们将在本章中看到的），你必须保持警惕和专注地编写代码。当然，你可以表达你的意图，但这些工具可能会以工具构建代码的方式覆盖你的愿望。此外，你可能注意到Copilot添加了`@dataclasses`装饰器。
- en: Decorator Design Pattern
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: The Decorator Design Pattern is a structural design pattern that allows you
    to add new or modify existing behavior to an object dynamically without changing
    the existing class. This is done by wrapping the existing object in the decorating
    object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式是一种结构型设计模式，它允许你动态地向对象添加新行为或修改现有行为，而无需更改现有类。这是通过将现有对象包装在装饰对象中实现的。
- en: An interesting exercise for an intrepid explorer would be to ask Copilot to
    assume the persona—using the Persona Pattern—of a software engineer. Does this
    change the output in any meaningful way?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个勇敢的探险者来说，一个有趣的练习是让Copilot扮演一个软件工程师的角色——使用角色模式。这会在任何有意义的方面改变输出吗？
- en: Definition *Design patterns* are common solutions to recurring design problems
    in software development. We will explore them more throughout this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*设计模式*是软件开发中常见的设计问题的解决方案。我们将在本章中进一步探讨它们。
- en: 4.1.3 Decorating our favorite classes
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 装饰我们最喜欢的类
- en: This decorator autogenerates common methods for Python (equals and string representation,
    among others). A data class is a class that is primarily used to store data and
    does not have much behavior. In Python, data classes were introduced in Python
    3.7 as a utility to make classes that are mainly used to store data cleaner and
    more efficient. This is opposed to a user-defined class, whose purpose can be
    mixed (that is, data and behavior). Using a data class in this context is useful
    in that you can avoid boilerplate code for constructing, representing, and comparing
    objects. Also, for those keeping score at home, our autogenerated code is autogenerating
    code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此装饰器自动生成Python的常见方法（例如等于和字符串表示，等等）。数据类是一个主要用于存储数据且没有太多行为的类。在Python中，数据类是在Python
    3.7中引入的，作为一种使主要用于存储数据的类更干净、更高效的工具。这与用户定义的类相对立，其目的可以是混合的（即数据和行为）。在这种情况下使用数据类是有用的，因为它可以避免构造、表示和比较对象的样板代码。此外，对于那些在家计分的人，我们的自动生成代码正在自动生成代码。
- en: Listing 4.1 Code that GitHub Copilot creates in response to our prompt
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 GitHub Copilot根据我们的提示创建的代码
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `__post_init__()` method will run after the constructor and enforce that
    none of the parameters are null (`None` in Python parlance). Coding defensively
    this way will ensure that your values cannot change after initialization. Of course,
    you are free to add additional validations as well, such as acceptable values
    for the status of the category. But if you wish to enforce values in that case,
    it is better to do so by making them proper classes or using the `Enum` class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`__post_init__()`方法将在构造函数之后运行，并强制所有参数都不是空（在Python中称为`None`）。以这种方式进行防御性编码将确保初始化后您的值不会改变。当然，您可以自由添加额外的验证，例如对类别状态的接受值。但如果您希望在该情况下强制执行值，最好通过将其作为适当的类或使用`Enum`类来实现。'
- en: 'Next, let’s review the `Hardware` class in the Mermaid diagram we created in
    the last chapter (see figure 4.4). There are several items to note from this diagram:
    it contains neither accessor nor mutator methods. We will need to add accessor
    methods to our prompt.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下我们在上一章中创建的Mermaid图中的`Hardware`类（见图4.4）。从这个图中我们可以注意几个事项：它既不包含访问器方法，也不包含修改器方法。我们需要在我们的提示中添加访问器方法。
- en: '![](../Images/CH04_F04_Crocker2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F04_Crocker2.png)'
- en: Figure 4.4 The `Hardware` class that we drafted with the aid of ChatGPT. Note
    that it does not have any accessor methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 使用ChatGPT辅助绘制的`Hardware`类。请注意，它没有任何访问器方法。
- en: 'Now that we have reviewed and assessed what methods and attributes we need
    in our `Hardware` class, we can build it. Create a file called hardware.py in
    the domain directory. At the beginning of this file, add the following prompt
    to have GitHub Copilot create our `Hardware` class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查和评估了在我们的`Hardware`类中需要哪些方法和属性，我们可以构建它。在域目录中创建一个名为`hardware.py`的文件。在此文件的开始处，添加以下提示以让GitHub
    Copilot创建我们的`Hardware`类：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The post-constructor code and accessor methods are not included in the code
    listing, for brevity’s sake. However, they should be automatically added to your
    file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，代码列表中不包括构造函数后的代码和访问器方法。然而，它们应该会自动添加到您的文件中。
- en: Listing 4.2 Definition of the `Hardware` class
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 `Hardware`类的定义
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, given that it was referenced in the `Asset` class, let’s add the `FundingDetails`
    class. First, however, let’s review the class diagram (see figure 4.5). Notice
    that the `lines_of_business` dictionary, which we will rename to `department_allocations,`
    uses a string as the key. We should change this to be an actual `Department`.
    This is another reminder that we must actively monitor the generated code and
    make decisions about how to best implement the project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，鉴于它已在`Asset`类中引用，让我们添加`FundingDetails`类。然而，首先让我们回顾一下类图（见图4.5）。请注意，我们将重命名的`lines_of_business`字典，它使用一个字符串作为键。我们应该将其更改为实际的`Department`。这是另一个提醒，我们必须积极监控生成的代码，并就如何最佳实施项目做出决策。
- en: '![](../Images/CH04_F05_Crocker2.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F05_Crocker2.png)'
- en: Figure 4.5 The `FundingDetails` class that we drafted with the aid of ChatGPT.
    We need to change the `lines_of_business` dict (renamed to `department_allocations`)
    to use a `Department` as the key.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 我们在ChatGPT的帮助下草拟的`FundingDetails`类。我们需要将`lines_of_business`字典（重命名为`department_allocations`）改为使用`Department`作为键。
- en: 'We need to make two additional edits to this class. First, we need to include
    the `Asset` in the constructor. This will allow us access to the fields needed
    for calculating depreciations, as previously mentioned. Additionally, we need
    to include a depreciation rate in the constructor. This is used for declining
    depreciation but not straight-line depreciation. We could set the value of this
    field in the specific deprecation constructor or use a mutator method, but for
    now we will add it to the `FundingDetails` class. The updated prompt to create
    the `FundingDetails` class, including the updated field name, is shown next:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对这个类进行两项额外的编辑。首先，我们需要在构造函数中包含`Asset`。这将使我们能够访问计算折旧所需的字段，如前所述。此外，我们还需要在构造函数中包含一个折旧率。这用于递减折旧，但不用于直线折旧。我们可以在特定的折旧构造函数中设置这个字段的值或使用一个修改器方法，但到目前为止，我们将将其添加到`FundingDetails`类中。创建`FundingDetails`类的更新提示，包括更新的字段名，如下所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is nothing surprising in the generated class: the code establishes the
    internal attributes and sets them via the constructor. After the constructor has
    finished, it will check that all attributes are `None`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的类中没有什么令人惊讶的：代码建立了内部属性并通过构造函数设置它们。构造函数完成后，它将检查所有属性是否为`None`。
- en: Listing 4.3 `FundingDetails` class (post constructor and accessor omitted)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 `FundingDetails`类（省略构造函数和访问器）
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final class we will generate in this chapter is `DepreciationStrategy`.
    In the last chapter, we were briefly introduced to this class. What we did not
    mention at the time was that this class will employ a new design pattern: the
    *Strategy* Pattern.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将生成的最终类是`DepreciationStrategy`。在上章中，我们简要介绍了这个类。当时我们没有提到的是，这个类将采用一种新的设计模式：*策略模式*。
- en: Strategy Pattern
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式
- en: The Strategy Pattern is a behavioral design pattern that lets you define a family
    of algorithms, encapsulate each one as an object, and make them interchangeable.
    The idea behind the Strategy Pattern is to define a common interface for a group
    of algorithms so they’re interchangeable despite having potentially very different
    implementations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是一种行为设计模式，它允许你定义一组算法，将每个算法封装为一个对象，并使它们可互换。策略模式背后的思想是为一组算法定义一个公共接口，以便它们尽管可能有非常不同的实现，但仍可互换。
- en: 4.1.4 Adapting a strategy for depreciation
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 调整折旧策略
- en: 'Before we attempt to create the `DepreciationStrategy` class, let’s review
    the class diagram that we created in the last chapter (see figure 4.6). The implementations
    of this class contain substantial hidden complexity. If we don’t give Copilot
    very specific instructions about how the calculations are to be performed, it
    will not come up with the correct algorithms. For example, here’s an incomplete,
    inexact prompt to create `DepreciationStrategy`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试创建`DepreciationStrategy`类之前，让我们回顾一下我们在上章中创建的类图（见图4.6）。这个类的实现包含大量的隐藏复杂性。如果我们不对Copilot关于如何执行计算给出非常具体的指示，它将不会提出正确的算法。例如，这是一个创建`DepreciationStrategy`的不完整、不精确的提示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/CH04_F06_Crocker2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F06_Crocker2.png)'
- en: Figure 4.6 The interface class `DepreciationStrategy` defines the functionality
    to calculate the depreciation of our assets in our domain model. There are four
    concrete classes representing how we can depreciate an asset.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 接口类`DepreciationStrategy`定义了在我们的领域模型中计算资产折旧的功能。有四个具体的类代表了我们可以如何折旧资产。
- en: This prompt will return methods that, at first sight, appear correct. But they
    are not. For example, if we examine the straight-line depreciation method, we
    see that it neither includes the salvage value in the calculation nor uses the
    useful life.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示将返回看起来似乎是正确的方法。但它们并不正确。例如，如果我们检查直线折旧法，我们会看到它既没有在计算中包含残值，也没有使用使用寿命。
- en: Listing 4.4 Incorrect implementation of straight-line depreciation
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 直线折旧的不正确实现
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To correct this, we should update the prompt with the actual formulas for the
    depreciation methods. Fortunately, we do not have to provide the exact syntax,
    just the calculations. Copilot will translate our algorithms to validate Python
    code. Here is the updated prompt:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这一点，我们应该更新提示，包含折旧方法的实际公式。幸运的是，我们不需要提供确切的语法，只需提供计算。Copilot 将将我们的算法转换为验证 Python
    代码。以下是更新的提示：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we can use pseudocode. Copilot handles the rest.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用伪代码。Copilot 处理其余部分。
- en: Listing 4.5 Output from our prompt to calculate depreciation methods
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 计算折旧方法的提示输出
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Many other classes are left undefined. Feel free to practice perfecting your
    prompt engineering by implementing the missing classes. For example, you may want
    to add `Organizations`, `MaintenanceSchedule`, `Address`, `UsageStatistics`, `User`,
    `Role`, and `Warranty`. In the next section, we will work with Copilot to apply
    patterns to our code, starting with a familiar one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他类都未定义。请随意练习通过实现缺失的类来完善你的提示工程。例如，你可能想添加 `Organizations`、`MaintenanceSchedule`、`Address`、`UsageStatistics`、`User`、`Role`
    和 `Warranty`。在下一节中，我们将与 Copilot 一起将模式应用于我们的代码，从熟悉的一个开始。
- en: 4.2 Weaving patterns, patterns, patterns
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 编织模式，模式，模式
- en: In this section, we enrich our domain model with commonly used design patterns.
    They represent best practices and can be used to speed up the development process
    by providing a set of proven solutions to certain problems. Design patterns are
    not ready-to-use code snippets but rather general guides on how to solve a particular
    problem in a way that is flexible and can be reused across different projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们通过常用设计模式丰富我们的领域模型。它们代表最佳实践，可以通过提供一组经过验证的解决方案来加速开发过程，解决某些问题。设计模式不是现成的代码片段，而是关于如何以灵活的方式解决特定问题的通用指南，并且可以在不同的项目中重用。  '
- en: 4.2.1 Paying a visit to our department
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 访问我们的部门
- en: The first pattern we will revisit is *Visitor*. As you may recall from chapter
    3, you use the Visitor Pattern to add new behavior to or change the existing behavior
    of a given class. Figure 4.7 shows how it was modeled in the last chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新审视的第一个模式是 *访问者*。如您在第 3 章中回忆的那样，您使用访问者模式向给定的类添加新行为或更改现有行为。图 4.7 显示了它在上一章中的建模方式。
- en: '![](../Images/CH04_F07_Crocker2.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F07_Crocker2.png)'
- en: Figure 4.7 The `DepartmentVisitor` interface (updated to use the new name; previously
    called `LineOfBusinessVisitor`). This class “visits” both hardware and software,
    holding the total cost and depreciation internally.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 `DepartmentVisitor` 接口（更新为新名称；之前称为 `LineOfBusinessVisitor`）。这个类“访问”硬件和软件，内部持有总成本和折旧。
- en: 'Let’s design a prompt to have Copilot generate an implementation of our `Visitor`
    Pattern, `DepartmentVisitor`, which visits our `Asset`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个提示，让 Copilot 生成我们的 `Visitor` 模式实现，`DepartmentVisitor`，它访问我们的 `Asset`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Copilot generates the straightforward implementation of this class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 生成这个类的直接实现。
- en: Listing 4.6 `Vistor` implementation
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 `Vistor` 实现
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 4.2.2 Creating objects in a factory (pattern)
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 在工厂（模式）中创建对象
- en: 'The *Factory* Pattern is another creation pattern that allows you to abstract
    away some of the details of the object you are attempting to create. In our ITAM
    system, we have two types of `Asset` (currently): `Hardware` and `Software`. Each
    of these objects has attributes idiosyncratic to itself. One effect of this is
    that our application does not need to know the specifics of the concrete class
    (`Hardware`, for example). From the application’s perspective, it just gets an
    instance of `Asset` with additional fields. Let’s look at how to get Copilot to
    create an `AssetFactory` class for us:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*工厂模式* 是另一种创建模式，它允许你抽象出你试图创建的对象的一些细节。在我们的 ITAM 系统中，我们有两种类型的 `Asset`（目前）：`Hardware`
    和 `Software`。这些对象各自都有独特的属性。这种做法的一个效果是，我们的应用程序不需要知道具体类（例如 `Hardware`）的详细信息。从应用程序的角度来看，它只是得到一个带有额外字段的
    `Asset` 实例。让我们看看如何让 Copilot 为我们创建一个 `AssetFactory` 类：'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This prompt is one of the most detailed we have encountered. As our needs get
    more and more niche, our prompts will naturally become more meticulous. Let’s
    examine this code in detail, starting with the `new` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示是我们遇到的最详细的之一。随着我们的需求越来越专业化，我们的提示将自然变得更加细致。让我们详细检查这段代码，从 `new` 方法开始。
- en: Listing 4.7 Code for `AssetFactory`, containing two embedded factories
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 `AssetFactory` 代码，包含两个内嵌的工厂
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `new` method determines which of the specific factories it needs to call
    based on the `asset_type` parameter. Additionally, it keeps track of the number
    of assets it has created, ensuring that the identifier (`id` field) is always
    unique. Otherwise, if the identifier creation were pushed down to the specific
    `Factory` object, we would get duplicate keys.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 方法根据 `asset_type` 参数确定需要调用哪个特定工厂。此外，它还跟踪已创建的资产数量，确保标识符（`id` 字段）始终唯一。否则，如果标识符的创建被推到特定的
    `Factory` 对象，我们将会得到重复的键。'
- en: Listing 4.8 Embedded `HardwareAssetFactory` class
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 内嵌的 `HardwareAssetFactory` 类
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `new` method of the `HardwareAssetFactory` class is relatively straightforward.
    This method accepts the parameters from the `AssetFactory`, attempts to resolve
    the `DepreciationStrategy`, and sets some sensible defaults.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`HardwareAssetFactory` 类的 `new` 方法相对简单。这个方法接受来自 `AssetFactory` 的参数，尝试解析 `DepreciationStrategy`，并设置一些合理的默认值。'
- en: Listing 4.9 Embedded `SoftwareAssetFactory` class
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 内嵌的 `SoftwareAssetFactory` 类
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SoftwareAssetFactory` class is nearly identical to the `HardwareAssetFactory`
    class—so much so that it likely has a code smell. The term *code smell* in software
    development describes an intuition a developer has, indicating that there may
    be a deeper problem with the code. It is not a bug per se, but a feeling. You
    may find yourself with the urge to refactor, because this does appear to violate
    the DRY principle (Don’t Repeat Yourself).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoftwareAssetFactory` 类几乎与 `HardwareAssetFactory` 类完全相同——如此相似，以至于可能存在代码异味。在软件开发中，*代码异味*这个术语描述的是开发者的一种直觉，表明代码可能存在更深层次的问题。这本身不是一个错误，而是一种感觉。你可能会有重构的冲动，因为这似乎违反了DRY原则（不要重复自己）。'
- en: 'But there is an easier way to handle this deduplication. To do this, we will
    look at our next design pattern: the *Builder* Pattern.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一种更简单的方式来处理这种去重。为此，我们将查看下一个设计模式：*建造者模式*。
- en: Builder Pattern
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式
- en: The Builder Pattern is a creational design pattern that provides a fluent API
    for the creation of objects by providing step-by-step instructions for how to
    create an object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式是一种创建型设计模式，它通过提供如何创建对象的逐步说明，提供了一个流畅的API来创建对象。
- en: 4.2.3 Instructing the system on how to build
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 指示系统如何构建
- en: 'First we will write a prompt to have Copilot create our builders: one for `Asset`
    and one for `FundingDetails`. We will let the builder know that if `asset_type`
    is hardware, it should return an instance of `Hardware`, and the same for `Software`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个提示，让Copilot创建我们的构建器：一个用于 `Asset`，另一个用于 `FundingDetails`。我们将让构建器知道，如果
    `asset_type` 是硬件，它应该返回一个 `Hardware` 的实例，对于 `Software` 也是如此：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One thing to note is that all the values need to be stored in local variables;
    otherwise, we would encounter post-initialization exceptions. The generated code
    for the `AssetBuilder` is is shown next. The `import` statements and accessor
    methods are omitted for the sake of brevity. One thing worth mentioning is that
    the methods return `self` so they can be chained together.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，所有值都需要存储在局部变量中；否则，我们可能会遇到初始化后的异常。下面展示了 `AssetBuilder` 生成的代码。为了简洁起见，省略了
    `import` 语句和访问器方法。值得一提的是，这些方法返回 `self`，因此可以串联起来使用。
- en: Listing 4.10 Corresponding `AssetBuilder` classes
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 对应的 `AssetBuilder` 类
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next we will examine the `build()` method of the `AssetBuilder` class. This
    method uses the `category` field to return the correct subclass of `Asset`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查 `AssetBuilder` 类的 `build()` 方法。这个方法使用 `category` 字段来返回正确的 `Asset`
    子类。
- en: Listing 4.11 `build()` method for the `AssetBuilder` classes
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 `AssetBuilder` 类的 `build()` 方法
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now look at `FundingDetailsBuilder`. This class closely resembles `AssetBuilder`,
    but without the polymorphic `build()` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看 `FundingDetailsBuilder` 类。这个类与 `AssetBuilder` 类非常相似，但没有多态的 `build()`
    方法。
- en: Listing 4.12 `FundingDetailsBuilder` class
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 `FundingDetailsBuilder` 类
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The class’s `build()` method implementation is fairly straightforward; it only
    returns an instance of the `FundingDetails` object after applying the parameters
    to the constructor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类的 `build()` 方法实现相当简单；它只是在将参数应用到构造函数后返回 `FundingDetails` 对象的实例。
- en: Listing 4.13 `build()` method of the `FundingDetailsBuilder` class
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 `FundingDetailsBuilder` 类的 `build()` 方法
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, let’s extract the `_get_depreciation_strategy` method from the `AssetFactory`
    class, consolidating the logic of mapping the name of the depreciation strategy
    to an instance of the `DepreciationStrategy`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从`AssetFactory`类中提取`_get_depreciation_strategy`方法，将映射折旧策略名称到`DepreciationStrategy`实例的逻辑进行整合。
- en: Listing 4.14 Updated `build()` method of `FundingDetailsBuilder`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14 `FundingDetailsBuilder`的更新版`build()`方法
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have written the builders, we can modify the `AssetFactory` to use
    them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了构建器，我们可以修改`AssetFactory`来使用它们。
- en: 'A pattern hiding in plain sight: The Adapter'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏在明处的模式：适配器
- en: The *Adapter* Pattern is a structural design pattern that allows us to bridge
    the gap between the target interface and a class with an incompatible interface.
    For example, in our case, we could have formalized the interface for `str` ->
    `DepreciationStrategy` in an adapter called `StringDepreciationStrategyAdapter`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器模式**是一种结构型设计模式，它允许我们弥合目标接口与具有不兼容接口的类之间的差距。例如，在我们的案例中，我们可以在名为`StringDepreciationStrategyAdapter`的适配器中正式化`str`
    -> `DepreciationStrategy`的接口。'
- en: 'We will update the prompt in the `AssetFactory` class to use the new builders
    to construct the instances of `Asset` and `FundingDetails`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`AssetFactory`类中的提示，使用新的构建器来构建`Asset`和`FundingDetails`的实例：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using the new builders will drastically reduce this class’s code volume. For
    example, the `new` method is now only eight lines long (as formatted in Microsoft
    VS Code).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的构建器将大大减少这个类的代码量。例如，`new`方法现在只有八行长（如Microsoft VS Code格式化所示）。
- en: Listing 4.15 The updated factory method for an `Asset`
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15 `Asset`的更新版工厂方法
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 4.2.4 Observing changes
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 观察变化
- en: Next we are going to apply the *Observer* Pattern to our ITAM system. This pattern’s
    real value will become more obvious in the next chapter, but we will sow the seeds
    here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把**观察者模式**应用到我们的ITAM系统中。这个模式的真实价值将在下一章中变得更加明显，但我们将在这里播下种子。
- en: Observer Pattern
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The Observer Pattern is a behavioral pattern in which the `Subject` class reports
    certain state changes to observer classes via notifications. The pattern is useful
    in user interfaces and event-driven systems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是一种行为型模式，其中`Subject`类通过通知向观察者类报告某些状态变化。这个模式在用户界面和事件驱动系统中非常有用。
- en: 'We will create a new class called `AssetManager` in the directory service.
    The `AssetManager` class will be responsible for interacting with the outside
    world (more on this in the next section). This prompt instructs Copilot about
    to how to define this class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在目录服务中创建一个新的类`AssetManager`。`AssetManager`类将负责与外部世界交互（更多内容将在下一节中介绍）。这个提示指导Copilot如何定义这个类：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our current implementation of `AssetManager` uses a list to track the lifecycle
    of the `Asset`s it manages. `AssetManager` supports all the CRUD (create, read,
    update, and delete) operations of `Asset`s.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前对`AssetManager`的实现使用列表来跟踪它所管理的`Asset`的生命周期。`AssetManager`支持`Asset`的所有CRUD（创建、读取、更新和删除）操作。
- en: Listing 4.16 Implementation of `AssetManager`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.16 `AssetManager`的实现
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s update our prompt to add notifications to our `AssetManager` class. Right
    now, we will not assign any observers; we will save that for chapter 5, when we
    start to deal with data flow:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的提示，为我们的`AssetManager`类添加通知。目前，我们不会分配任何观察者；我们将把这一点留到第五章，当我们开始处理数据流时：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In response to our prompt, if we re-create the entire class, Copilot adds the
    notification framework on which we will eventually expand.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对我们的提示的回应，如果我们重新创建整个类，Copilot会添加我们将最终扩展的通知框架。
- en: Listing 4.17 Updated `AssetManager` definition with notifications enabled
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.17 启用通知的更新版`AssetManager`定义
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will see two more patterns in the next section of this chapter: Singleton
    and Repository. But first we need to set up a controller to interact with our
    system. That takes us to the usage of ports and adapters.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的下一节中看到两个更多的模式：单例和仓库。但首先我们需要设置一个控制器来与我们的系统交互。这带我们到了端口和适配器的使用。
- en: 4.3 Plugging in ports and adapters
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 插入端口和适配器
- en: 'Our ITAM system is beginning to come together; the core business model has
    been built out. We have applied patterns to make the code more concise, readable,
    and maintainable. There is, however, one glaring deficiency: how do we interact
    with our application? In this section, we continue to deepen our investigation
    into hexagonal architecture.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ITAM系统开始整合；核心业务模型已经构建完成。我们应用了模式使代码更加简洁、可读和可维护。然而，有一个明显的缺陷：我们如何与我们的应用程序交互？在本节中，我们继续深入调查六边形架构。
- en: 4.3.1 Hexagonal architecture in review
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 回顾六边形架构
- en: As you may recall, hexagonal architecture is an approach to designing software
    that emphasizes the separation of the core business logic from external services.
    The business logic can be thought of as the “brain” of the application. It contains
    all the important rules and constructs that the application will need to guarantee
    the correctness of the program. In this analogy, the external services are your
    “hands” or “eyes;” they allow interactions with the outside world (user interfaces,
    database, etc.).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所回忆的那样，六边形架构是一种设计软件的方法，它强调将核心业务逻辑与外部服务分离。业务逻辑可以被视为应用程序的“大脑”。它包含所有重要的规则和结构，这些规则和结构是应用程序需要保证程序正确性的。在这个类比中，外部服务是你的“手”或“眼睛”；它们允许与外部世界的交互（用户界面、数据库等）。
- en: Hexagonal architecture separates the main program logic from the outside parts
    like buttons, screens, and databases. It makes it easy to change those outside
    parts without changing the main program. It does this by using *ports* that define
    how the outside parts can interact with the main program and *adapters* that make
    those interactions happen in a concrete way.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构将主要程序逻辑与外部部分（如按钮、屏幕和数据库）分开。这使得在不更改主要程序的情况下轻松更改这些外部部分。它是通过使用定义外部部分如何与主要程序交互的**端口**和使这些交互以具体方式发生的**适配器**来实现的。
- en: This approach makes it easier to change and evolve the application over time.
    If a change needs to be made to one of the external systems, the application’s
    core should be unaffected; you only need to update the adapter (see figure 4.8).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得随着时间的推移更改和演进应用程序变得更加容易。如果需要对其中一个外部系统进行更改，应用程序的核心不应受到影响；你只需要更新适配器（见图4.8）。
- en: '![](../Images/CH04_F08_Crocker2.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8](../Images/CH04_F08_Crocker2.png)'
- en: Figure 4.8 A more conceptual visualization of the hexagonal architecture in
    action. Notice that the core is segregated from the rest of the system and is
    only interacted with via ports.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 动态中六边形架构的更概念化可视化。注意，核心与系统的其余部分分离，并且仅通过端口进行交互。
- en: 4.3.2 Driving our application
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 驱动我们的应用程序
- en: We will begin by building out a driver for the system. A *driver* is a system
    external to the context boundary of the application that sends requests to the
    system and, optionally, receives responses from the application. A conventional
    example is a Representational State Transfer (commonly referred to as REST) call
    from a web browser to a REST controller.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建系统的驱动程序。**驱动程序**是指位于应用程序上下文边界之外的系统，它向系统发送请求，并且可选地从应用程序接收响应。一个传统的例子是从网络浏览器到REST控制器的表示状态转移（通常称为REST）调用。
- en: 'First we will add a REST controller to our ITAM system. It will expose the
    functionality provided by the `AssetManager` class. Create a directory called
    infrastructure/API in which to create a file called asset_controller.py. At the
    beginning of this file, add the following prompt:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向我们的ITAM系统添加一个REST控制器。它将公开`AssetManager`类提供的功能。创建一个名为infrastructure/API的目录，在其中创建一个名为asset_controller.py的文件。在这个文件的开始处，添加以下提示：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given that we do not specify the path to use, Copilot may produce inconsistent
    or invalid paths with the routes. The following code was output in VS Code in
    response to the previous prompt. The route is `asset` rather than `assets`; it’s
    more of a preference than a standard, but in REST the nouns are generally made
    plural.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有指定要使用的路径，Copilot可能会生成不一致或无效的路径。以下代码是在VS Code中响应上一个提示时输出的。路由是`asset`而不是`assets`；这更多的是一种偏好而不是标准，但在REST中名词通常被复数化。
- en: Listing 4.18 Generated code with route `asset`
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.18 使用`asset`路由生成的代码
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You may elect to manually update the code to reflect your path preference. Above
    all, though, ensure that it is consistent across the various methods. The following
    listing shows how to initialize all the services needed to run the application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择手动更新代码以反映你的路径偏好。然而，最重要的是，确保它在各种方法中保持一致。以下列表显示了如何初始化运行应用程序所需的所有服务。
- en: Listing 4.19 Updated `main` class to reflect consistent routes
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 更新 `main` 类以反映一致的路径
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, let’s see how the routes are defined and how their methods are used. The
    first two routes define how we access our `Asset` objects. The first GET request
    gets all `Asset`s that we currently have in the system. In the real world, we
    would include convenience features such as pagination and sorting. However, given
    the limited number of entries in the system currently, we will forgo this. The
    next GET method gets a specific `Asset` by its identifier.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看路由是如何定义的，以及它们的方法是如何使用的。前两个路由定义了如何访问我们的 `Asset` 对象。第一个 GET 请求获取系统中当前所有的
    `Asset`。在现实世界中，我们会包括便利功能，如分页和排序。然而，鉴于系统中当前条目数量有限，我们将放弃这些功能。下一个 GET 方法通过标识符获取特定的
    `Asset`。
- en: Listing 4.20 `AssetController` methods to access `Asset`s
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 访问 `Asset` 的 `AssetController` 方法
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The final set of routes defines how we create `Asset`s, update them, and remove
    them from our system. Note that we are not doing “soft” deletes, which would just
    set a flag and not return this `Asset` in response to subsequent queries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的路由集定义了如何在我们的系统中创建 `Asset`、更新它们以及从系统中删除它们。注意，我们不是进行“软删除”，这只会设置一个标志，而不会在后续查询中返回这个
    `Asset`。
- en: Listing 4.21 `AssetController` methods to modify and delete `Asset`s
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.21 修改和删除 `Asset` 的 `AssetController` 方法
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note the simplified representations of the `Asset` class called, not coincidently,
    `AssetIn` and `AssetOut`. You can define those classes in the `AssetController`,
    or you can add a separate class and define them there. In the reference implementation
    for this book, they are defined in a file called asset_model.py. This prompt defines
    the `AssetIn` and `AssetOut` classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Asset` 类的简化表示，称为 `AssetIn` 和 `AssetOut`，这并非巧合。你可以在 `AssetController` 中定义这些类，或者你可以添加一个单独的类并在那里定义它们。在本书的参考实现中，它们定义在一个名为
    asset_model.py 的文件中。这个提示定义了 `AssetIn` 和 `AssetOut` 类：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the prompt defined at the beginning of the file, Copilot generates code
    similar to the following listing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件开头定义的提示下，Copilot生成了类似于以下列表的代码。
- en: Listing 4.22 `AssetIn` and `AssetOut` classes in asset_model.py
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.22 asset_model.py 中的 `AssetIn` 和 `AssetOut` 类
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Optionally, we can add another layer of abstraction between `AssetController`
    and `AssetManager`. Doing so may be considered hexagonal architecture in extremis,
    but there are few challenges in computer science that cannot be resolved by adding
    one more layer of abstraction. We will add a port that will be used to interface
    with `AssetController`. Let’s create a prompt for the class `AssetRestPort` and
    have Copilot generate the code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以在 `AssetController` 和 `AssetManager` 之间添加另一层抽象。这样做可能被认为是极端的六边形架构，但计算机科学中很少有挑战不能通过添加另一层抽象来解决。我们将添加一个用于与
    `AssetController` 接口的端口。让我们为类 `AssetRestPort` 创建一个提示，并让 Copilot 生成代码：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This prompt instructs Copilot to create an interface that we will implement
    shortly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示指示 Copilot 创建一个我们将很快实现的接口。
- en: Listing 4.23 Complete source code for `AssetRestPort`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.23 `AssetRestPort` 的完整源代码
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next we will implement this port with an adapter that will be used to interact
    with the controller to further abstract the components. We can swap out this adapter
    for another if we want to, for example, turn this into a command-line application.
    The prompt for `AssetRestAdapter` is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用一个适配器来实现这个端口，该适配器将用于与控制器交互，以进一步抽象组件。如果我们想的话，可以替换这个适配器为另一个，例如，将其转换为命令行应用程序。`AssetRestAdapter`
    的提示如下：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are two important elements to this prompt. The first is that it implements
    the port interface that we defined previously. The second is that it wraps `AssetManager`’s
    functionality.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示有两个重要的元素。第一个是它实现了我们之前定义的端口接口。第二个是它封装了 `AssetManager` 的功能。
- en: Listing 4.24 Source code for `AssetRestAdapter`
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.24 `AssetRestAdapter` 的源代码
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All that is left to do is to update `AssetController` to remove its direct
    invocation of the `AssetManager` methods and instead have `AssetController` invoke
    the methods of the adapter, which in turn invokes the methods of `AssetManager`.
    The key takeaway from the Ports and Adapters Pattern is that it abstracts the
    interaction between the driving parts of the system—in this case, the REST API—and
    the driven application: the business model and core of our system, `AssetManager`.
    To make this more explicit and as a preview, we will shortly modify this class
    again to add the port to the constructor.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作只是更新`AssetController`以移除其直接调用`AssetManager`方法的操作，并让`AssetController`调用适配器的操作，适配器再调用`AssetManager`的操作。从端口和适配器模式的关键要点来看，它抽象了系统驱动部分（在这种情况下，REST
    API）与驱动应用（我们的业务模型和系统核心`AssetManager`）之间的交互。为了使这一点更加明确，我们将很快再次修改这个类，将其端口添加到构造函数中。
- en: Listing 4.25 Updated code for `AssetController` using `AssetRestAdapter`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.25 使用`AssetRestAdapter`更新`AssetController`的代码
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As previously mentioned, we will modify `AssetController` to remove all direct
    references to the `AssetManager`. Our current `AssetController`, although it does
    not directly invoke any `AssetManager` methods, does hold an indirect reference
    to `AssetManager`, because `AssetManager` is constructed in `AssetController`.
    Doing so further insulates `AssetManager` from changes in the drivers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将修改`AssetController`以移除所有对`AssetManager`的直接引用。我们的当前`AssetController`，尽管它没有直接调用任何`AssetManager`方法，但确实持有对`AssetManager`的间接引用，因为`AssetManager`是在`AssetController`中构建的。这样做进一步隔离了`AssetManager`与驱动程序的变化。
- en: 4.3.3 Accessing our data and persisting our changes
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 访问我们的数据和持久化我们的更改
- en: 'Abstractions in software are not merely an academic matter. These abstractions
    give us flexibility when it comes to satisfying requirements and making changes.
    They can hide complexity, encapsulating behavior behind seemingly simple interfaces.
    This brings us to our next pattern: the *Repository* Pattern.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中的抽象不仅仅是学术问题。这些抽象在满足需求和进行更改时给我们提供了灵活性。它们可以隐藏复杂性，将行为封装在看似简单的接口之后。这使我们来到了下一个模式：**仓库**模式。
- en: Repository Pattern
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式
- en: The Repository Pattern is a design pattern that helps manage data by creating
    a separate place to handle tasks like getting, saving, updating, and deleting
    data. It connects the data source (such as a database or file) to the rest of
    the application, keeping data access code separate from other code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式是一种设计模式，通过创建一个单独的地方来处理获取、保存、更新和删除数据等任务来帮助管理数据。它将数据源（如数据库或文件）连接到应用程序的其余部分，使数据访问代码与其他代码分离。
- en: 'In our ITAM project, the Repository Pattern will allow us to present a greatly
    simplified interface, masking the complexity of, in this case, our data access.
    From the perspective of the repository or `AssetManager`, our data access layer
    is just a series of methods. Behind the scenes, it may be a REST API, a Redis
    cache, MongoDB, a file, or a database of any flavor. Let’s create a prompt that
    will set up our generic data access layer using the Repository Pattern:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ITAM项目中，仓库模式将使我们能够提供一个大大简化的接口，掩盖了数据访问的复杂性。从仓库或`AssetManager`的角度来看，我们的数据访问层只是一系列方法。幕后，它可能是一个REST
    API、Redis缓存、MongoDB、文件或任何类型的数据库。让我们创建一个提示，使用仓库模式设置我们的通用数据访问层：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this prompt, Copilot should have everything it needs to establish the contract
    that all implementations will honor. Let’s examine the code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个提示，Copilot应该拥有建立所有实现都将遵守的合同所需的一切。让我们检查一下代码。
- en: Listing 4.26 Code for `BaseRepository`, our generic data access layer
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.26 `BaseRepository`的代码，我们的通用数据访问层
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Copilot introduced a `Generic` type, allowing for some typing hints when it
    comes time to implement. If we express that the type should be an `Asset`, the
    method signature will demonstrate this. Our first attempt at an implementation
    will be an in-memory data store. This will allow us to perform an end-to-end test
    of our entire system. It also nicely demonstrates why abstractions are useful.
    Before long, we will add another implementation that uses Postgres. But first,
    the prompt:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot引入了一个`Generic`类型，允许在实现时提供一些类型提示。如果我们表达类型应该是`Asset`，方法签名将展示这一点。我们的第一次实现尝试将是一个内存数据存储。这将使我们能够对整个系统进行端到端测试。这也很好地展示了抽象的有用性。不久，我们将添加另一个使用Postgres的实现。但首先，这是提示：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our in-memory implementation will use a simple list to store `Asset`s. We will
    be able to perform all CRUD operations. Additionally, Copilot will add typing
    hints for us, letting others know that it should accept and return `Asset`s. That
    is what is meant by `BaseRepository`[`Asset`]: it’s an implementation of a `BaseRepository`
    whose `Generic` type is `Asset`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.27 Code for `InMemoryAssetRepository`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, we will update `AssetManager` to delegate the CRUD operations of the
    `Asset`s to a `BaseRepository` instance (`_repository`). The full source code
    follows, including the prompt at the beginning of the file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.28 `AssetManager` using `InMemoryAssetRepository`
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'At this point, we have a core business domain that is untouched directly by
    our system. We have ports by which requests can come in. We also have ports by
    which we can store the data (at least while the system is running). We should
    be able to test the system end to end by running it, POSTing requests to the creation
    end point, and reading from the GET end points. Once we have confirmed that the
    system works end to end, we can tackle the problem that our data is only persisted
    in memory; we can now hook up an actual database. To do this, we introduce the
    final pattern of this chapter: the *Singleton* Pattern. A singleton, conceptually,
    is very simple to grok; there should only ever be one instance of it running.
    It is good for many use cases: logging, caching, configuration settings, or a
    database connection manager.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Pattern
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton Pattern is a design pattern that ensures a class has only one
    instance and provides a global access point to that instance. It is used when
    you want to have a single object shared across different parts of your program
    instead of creating multiple instances of the same class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.4 Centralizing (and externalizing) our data access
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will ask Copilot to create a singleton class for us to manage our database’s
    connections. We should never hardcode usernames or passwords (or any connection
    details, for that matter) in our source code, not only because it is inherently
    less secure but also because the details will likely differ depending on the environment
    (DEV versus QA versus PROD). We will therefore ask Copilot to accept these values
    as environmental variables and configure the connections using them:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are asking Copilot to employ SQLAlchemy, an object-relational mapping (ORM)
    tool, to perform the actions against the database. Copilot will adroitly assemble
    our source code. The `@staticmethod` keyword creates a method that belongs to
    a class rather than the instance of the class. This keyword is used to get the
    instance of the `DatabaseConnection` class. Because a static method cannot modify
    the instance data, it can be used to ensure that only one instance of this class
    is ever running and is thus a singleton. The constructor initializes the connection
    to the database using string interpolation with environment variables.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.29 Implementation of a `DatabaseConnection`
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.29 `DatabaseConnection` 的实现
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that we can get a connection to our database, we need to create a repository
    that will use this connection to store and retrieve our `Asset` objects. We will
    create a class that does just that called `SQLAlchemyAssetRepository`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够连接到我们的数据库，我们需要创建一个仓库，该仓库将使用此连接来存储和检索我们的 `Asset` 对象。我们将创建一个名为 `SQLAlchemyAssetRepository`
    的类来完成这项工作。
- en: Listing 4.30 Prompt and code for the `SQLAlchemyAssetRepository` class
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.30 `SQLAlchemyAssetRepository` 类的提示和代码
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next we will refactor `AssetController` to allow us to pass in `AssetRestPort`.
    By doing this, we can swap out the driven aspect of our application. This refactor
    further abstracts the driver from the business core.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重构 `AssetController` 以允许我们传入 `AssetRestPort`。通过这样做，我们可以替换应用程序的驱动方面。这次重构进一步将驱动从业务核心中抽象出来。
- en: Listing 4.31 Updated `AssetController` that exposes routes
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.31 更新后的 `AssetController`，公开路由
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can now consolidate the initialization logic of our application into the
    main.py file. This is the big payoff. Our system will have layering, facilitating
    the swapping out of components as needed or when requirements change.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将应用程序的初始化逻辑整合到 main.py 文件中。这是最大的回报。我们的系统将具有分层结构，便于根据需要或当需求发生变化时替换组件。
- en: Listing 4.32 Final version of main.py, wiring our application together
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.32 main.py 的最终版本，将我们的应用程序连接在一起
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Congratulations! We now have a running system that persists data to our database.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们现在有一个正在运行的系统，可以将数据持久化到我们的数据库中。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The Decorator Pattern is a structural design pattern that allows you to add
    new object behavior or modify existing behavior dynamically without changing the
    existing class. This is done by wrapping the current object in the decorating
    object.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式是一种结构型设计模式，它允许你动态地添加新对象行为或修改现有行为，而不改变现有类。这是通过将当前对象包装在装饰对象中实现的。
- en: The Visitor Pattern adds new behavior to changes the existing behavior of a
    given class.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式向现有类的行为添加新行为。
- en: The Factory Pattern is another creation pattern that allows you to abstract
    away some of the details of the object you are attempting to create.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式是另一种创建模式，它允许你抽象出你试图创建的对象的一些细节。
- en: The Builder Pattern is a creational design pattern that provides a fluent API
    for the creation of objects by providing step-by-step instructions for creating
    those objects.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者模式是一种创建型设计模式，它通过提供创建对象的逐步指令来提供一个流畅的 API，用于创建对象。
- en: The Adapter Pattern is a structural design pattern that allows you to bridge
    the gap between the target interface and a class with an incompatible interface.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式是一种结构型设计模式，它允许你桥接目标接口与具有不兼容接口的类之间的差距。
- en: The Observer Pattern is a behavioral pattern in which the subject class reports
    certain state changes to observer classes via notifications.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式是一种行为模式，其中主题类通过通知将某些状态变化报告给观察者类。
- en: Hexagonal architecture separates the main program logic from outer parts like
    buttons, screens, and databases. It makes changing outer parts easy without changing
    the main program.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六角架构将主程序逻辑与按钮、屏幕和数据库等外部部分分开。它使得在不改变主程序的情况下改变外部部分变得容易。
- en: The Repository Pattern is a design pattern that helps manage data by creating
    a separate place to handle tasks like getting, saving, updating, and deleting
    data. It connects the data source (such as a database or file) to the rest of
    the application, keeping data access code separate from other code.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓储模式是一种设计模式，它通过创建一个单独的地方来处理获取、保存、更新和删除数据等任务来帮助管理数据。它将数据源（如数据库或文件）连接到应用程序的其余部分，使数据访问代码与其他代码分离。
- en: The Singleton Pattern is a design pattern that ensures a class has only one
    instance and provides a global access point to that instance. It is used when
    you want a single object to be shared across different parts of your program instead
    of creating multiple instances of the same class.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式是一种设计模式，它确保一个类只有一个实例，并提供对该实例的全局访问点。当你想要在程序的不同部分共享单个对象而不是创建同一类的多个实例时，会使用它。
