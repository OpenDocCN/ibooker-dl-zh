- en: '4 Reading Python code: Part 1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 阅读Python代码：第1部分
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why knowing how to read code is important
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何阅读代码的重要性
- en: How to ask Copilot to explain code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让Copilot解释代码
- en: Using functions to break down large problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数分解大问题
- en: Using variables to hang on to values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量来保留值
- en: Using if-statements to make decisions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用if语句进行决策
- en: Using strings to store and manipulate text
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串存储和操作文本
- en: Using lists to collect and manipulate many values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表收集和操作多个值
- en: In chapter 3, we used Copilot to write several functions for us. What are they
    good for? Maybe our `money_made` function could be part of a stock trading system,
    our `is_strong_password` function could be used as part of a social networking
    website, or our `best_word` function could be used as part of some Scrabble AI.
    Overall, we’ve written some useful functions that could be part of larger programs.
    And, we did this without writing much code ourselves or, indeed, understanding
    what the code even does.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们使用Copilot为我们编写了几个函数。它们有什么用？也许我们的`money_made`函数可以是股票交易系统的一部分，我们的`is_strong_password`函数可以用作社交网站的一部分，或者我们的`best_word`函数可以用作某些Scrabble
    AI的一部分。总的来说，我们编写了一些有用的函数，它们可以是更大程序的一部分。而且，我们没有写很多代码，实际上甚至不理解代码的作用。
- en: 'However, we believe that you need to understand at a high level what code does.
    Because this will require some time to learn, we’ve split this discussion over
    two chapters. In this chapter, we’ll explain why reading code is important and
    introduce you to a Copilot feature that can help you understand the code. After
    that, we’ll dive into the top 10 programming features you’ll need to recognize
    to read most basic code produced by Copilot. We’ll do the first five in this chapter
    and the remaining five in the next chapter. Don’t worry: you’ve actually been
    informally introduced to all 10 already—we’re just going to deepen your understanding
    of each one.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们认为你需要从高层次上理解代码的作用。因为这需要一些时间来学习，所以我们把这个讨论分成了两章。在本章中，我们将解释阅读代码的重要性，并介绍一个可以帮助你理解代码的Copilot功能。之后，我们将深入探讨你需要识别的前10个编程特性，以阅读Copilot生成的最基本代码。我们将在这章中介绍前五个，在下一章中介绍剩下的五个。不用担心：你实际上已经非正式地介绍了这10个——我们只是要加深你对每个特性的理解。
- en: 4.1 Why we need to read code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 为什么我们需要阅读代码
- en: When we talk about reading code, what we mean is understanding what code does
    by looking at it. There are two such levels of understanding, and they’re both
    important.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论阅读代码时，我们的意思是通过查看代码来理解代码的作用。有两种这样的理解层次，它们都很重要。
- en: The first level is being able to understand, line by line, what a program will
    do. This often involves tracing the values of variables as the code runs to determine
    exactly what the code is doing at each step. This is useful, but isn’t the whole
    story. It’s like following a cooking recipe step-by-step without knowing what
    the recipe is making or how its ingredients fit together. At the end, you might
    have a cake, but you might not be able to grasp why the cake turned out so well
    or how you could come up with such a recipe yourself. You need to understand why
    the recipe, as a whole, is effective.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一层是能够逐行理解程序将做什么。这通常涉及到在代码运行时追踪变量的值，以确定代码在每一步的具体行为。这很有用，但并不是全部。就像不知道食谱要做什么或其成分如何搭配的情况下，一步一步地跟随烹饪食谱。最后，你可能会有一个蛋糕，但你可能无法理解蛋糕为什么做得这么好，或者你如何能自己想出这样的食谱。你需要理解整个食谱为什么有效。
- en: 'So, that’s the second level: determining the overall purpose of a program.
    That is, you need to be able to zoom out, away from each line, and understand
    what the program is doing at a high level.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是第二层：确定程序的整体目的。也就是说，你需要能够从每一行中抽离出来，从高层次上理解程序在做什么。
- en: At the end of these two chapters, we want you to be able to begin to understand
    code from Copilot at both of these levels. We’ll start focusing on that line-by-line
    understanding, but toward the end of this chapter and through the rest of the
    book, you’ll start being able to look at a small chunk of code and determine its
    overall purpose.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两章的结尾，我们希望你能开始理解Copilot在这两个层面的代码。我们将开始逐行关注这种理解，但在本章的末尾以及本书的其余部分，你将开始能够查看一小段代码并确定其整体目的。
- en: We can illustrate the difference between the two levels of reading code by referring
    back to our `best_word` function from chapter 3, reprinted in the following listing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过参考第3章中重新打印的`best_word`函数来阐述阅读代码两个层次之间的区别。
- en: Listing 4.1 `best_word` function for Scrabble
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1为Scrabble的`best_word`函数
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A *tracing description* of what this program does is a description of each line.
    For example, we would say that we’re defining a function called `best_word` that
    takes one parameter called `word_list`. We have a variable called `best_word`
    that we start off as a string with no characters, otherwise known as the empty
    string. (It’s unfortunate that the function and this variable are both called
    `best_word` because it makes it trickier to refer to one or the other, but that’s
    what Copilot gave us.) We also have another variable, `best_points`, that we start
    at `0`. Then, we have a `for` loop over each word in the `word_list`. Inside the
    `for` loop, we call our `num_points` helper function and store its return value
    in the points variable, and so on. (We’ll explain how we know what each line of
    code does over this chapter and the next.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*追踪描述*这个程序的功能是描述每一行。例如，我们会说我们定义了一个名为`best_word`的函数，它接受一个名为`word_list`的参数。我们有一个名为`best_word`的变量，我们一开始将其初始化为一个空字符串，即没有字符的字符串。（不幸的是，函数和这个变量都叫`best_word`，这使得指代其中一个或另一个变得复杂，但这是Copilot给我们的。）我们还有一个名为`best_points`的变量，我们将其初始化为`0`。然后，我们有一个遍历`word_list`中每个单词的`for`循环。在`for`循环内部，我们调用我们的`num_points`辅助函数，并将它的返回值存储在`points`变量中，等等。（我们将在本章和下一章中解释我们如何知道每一行代码的作用。）'
- en: 'In contrast, a *description of the overall purpose* would be something like
    our docstring description: “Return the word with the highest Scrabble point value
    from a list of words.” Rather than refer to each line, this description refers
    to the code’s purpose as a whole, explaining what it does at a high level.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个*整体目的描述*可能类似于我们的文档字符串描述：“从单词列表中返回具有最高Scrabble得分值的单词。”这个描述不是针对每一行，而是指代代码的整体目的，从高层次解释它做什么。
- en: 'You’ll come to an overall-purpose level of understanding through a combination
    of practice with tracing and testing, and we hope you arrive there in full glory
    by the end of the book. Working at a tracing level generally precedes the ability
    to work at an overall-purpose level [1], so in this chapter and the next, we’re
    going to focus on the tracing level by understanding what each line of code does.
    There are three reasons why we want you to be able to read code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过结合追踪和测试的实践达到整体目的的理解水平，我们希望你在书的结尾能够完全实现这一目标。在追踪层次上工作通常先于在整体目的层次上工作[1]，因此在本章和下一章中，我们将通过理解每一行代码的作用来专注于追踪层次。我们希望你能够阅读代码有三个原因：
- en: '*To help determine whether code is correct —*In chapter 3, we practiced how
    to test the code that Copilot gives us. Testing is a powerful skill for determining
    whether code does the right thing, and we’ll continue to use it throughout the
    book. But many programmers, the two of us included, will only test something if
    it seems plausibly correct. If we can determine by inspection that the code is
    wrong, then we won’t bother to test it: we’ll try to fix the code first. Similarly,
    we want you to identify when code is simply wrong without having to spend time
    testing it. The more code that you can identify as wrong (through quick tracing
    or honing your overall-purpose skills), the more time you save testing broken
    code.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*为了帮助确定代码是否正确—*在第3章中，我们练习了如何测试Copilot给出的代码。测试是确定代码是否正确执行的一项强大技能，我们将在整本书中继续使用它。但许多程序员，包括我们两个，只有在代码看起来合理正确的情况下才会进行测试。如果我们通过检查就能确定代码是错误的，那么我们就不费心去测试它：我们会先尝试修复代码。同样，我们希望你能识别出代码的错误，而无需花费时间去测试。你能识别出更多错误的代码（通过快速追踪或提高你的整体技能），你就能节省更多测试错误代码的时间。'
- en: '*To inform testing —*Understanding what the code is doing line by line is useful
    on its own, but it also helps turbocharge your ability to test effectively. For
    example, in the next chapter, you’ll learn about loops—that they can cause your
    code to repeat zero times, one time, two times, or as many times as needed. You’ll
    be able to combine that knowledge with what you already know about testing to
    help you identify important categories of cases to test.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*为了指导测试—*理解代码逐行执行的内容本身很有用，但它也有助于提升你测试有效性的能力。例如，在下一章中，你将学习到循环——它们可以使代码重复零次、一次、两次或所需次数。你将能够将这一知识与你已经了解的测试知识相结合，帮助你确定重要的测试案例类别。'
- en: '*To help you write code —*We know, you want Copilot to write all of your code!
    We want that too. But inevitably, there will be code that Copilot just doesn’t
    get right, no matter how much prompt engineering you do. Or maybe enough prompt
    engineering could finally cajole Copilot to write the correct code, but it would
    be simpler and faster to just do it ourselves. In writing this book, the two of
    us strive to have Copilot write as much code as possible. But, because of our
    knowledge of Python programming, we’re often able to see a mistake and just fix
    it without going through any hoops to have Copilot fix it for us. Longer term,
    we want you to be empowered to learn more programming on your own, and having
    an understanding of Python is our way to provide a bridge for you from this book
    to other resources later. There is research evidence that being able to trace
    and explain code is prerequisite to being able to write code [1].'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*为了帮助你编写代码—*我们知道，你希望Copilot为你编写所有代码！我们也有同样的愿望。但不可避免的是，Copilot可能无法正确处理某些代码，无论你如何进行提示工程。或者，也许足够的提示工程最终能够说服Copilot编写正确的代码，但自己动手做会更简单、更快。在编写这本书的过程中，我们两个人努力让Copilot尽可能多地编写代码。但是，由于我们对Python编程的了解，我们经常能够发现错误并直接修复，而无需通过任何繁琐的步骤让Copilot为我们修复。从长远来看，我们希望你能获得自主学习的编程能力，而理解Python编程则是我们为你提供从这本书到其他资源桥梁的方式。有研究表明，能够追踪和解释代码是能够编写代码的前提条件
    [1]。'
- en: Before we get to it, we need to be clear about the level of depth that we’re
    striving for. We’re not going to teach you every nuance of every line of code.
    Doing so would revert us back to the traditional way programming was taught prior
    to tools like Copilot. Rather, through a combination of Copilot tools and our
    own explanations, we’re going to help you understand the gist or overall goal
    of each line of code. You’ll need more than this if you endeavor to write large
    portions of programs in the future. We’re trying to target the sweet spot between
    “this code is magic” and “I know exactly how every line of the code works.”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，我们需要明确我们追求的深度水平。我们不会教给你每一行代码的每一个细微之处。这样做会让我们回到在Copilot等工具出现之前传统的编程教学方式。相反，通过Copilot工具和我们的解释相结合，我们将帮助你理解每一行代码的精髓或总体目标。如果你未来打算编写大量程序，你需要的东西将不止于此。我们试图在“这段代码是魔法”和“我确切知道代码的每一行是如何工作的”之间找到最佳平衡点。
- en: 4.2 Asking Copilot to explain code
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 请求Copilot解释代码
- en: 'To this point, we’ve used Copilot to generate code for us. That’s its most
    well-known feature, but it’s not the only one. We’re going to show you another
    of its best features right now: explaining what Python code does!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用Copilot为我们生成代码。这是它最知名的功能，但并非唯一。现在，我们将向你展示它的另一个最佳功能：解释Python代码的功能！
- en: The Copilot extension is always changing. The specific steps we give here may
    vary somewhat, and, in that case, we encourage you to consult more general GitHub
    Copilot documentation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot扩展总是在变化中。我们这里给出的具体步骤可能会有所不同，在这种情况下，我们鼓励你查阅更通用的GitHub Copilot文档。
- en: To try the Explain feature, you need to highlight some code that you want Copilot
    to describe to you. Let’s try this with our `best_word` function (listing 4.1).
    If you don’t have this code typed in from chapter 3, please enter it now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试解释功能，你需要突出显示一些你希望Copilot为你描述的代码。让我们用我们的`best_word`函数（列表4.1）来试一试。如果你没有从第三章输入这段代码，请现在输入。
- en: '![figure](../Images/4-1.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/4-1.png)'
- en: Figure 4.1 The code from the `best_word` function highlighted in the editor
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1 在编辑器中突出显示的`best_word`函数的代码
- en: Highlight the code as in figure 4.1\. After this, we have a few options. The
    first is to click the Chat icon in the Activity Bar (on the left-hand side of
    VS Code), or press Ctrl-Alt-I. This will open the Copilot Chat interface, as in
    figure 4.2\. (There are other interfaces for Chat, including a Quick Chat that
    you can open with Ctrl-Shift-I—it doesn’t matter which chat interface you use.)
    Copilot Chat is able to respond to your questions not only with natural language
    but also with blocks of code, buttons/links that you can click to invoke commands,
    and more. It also suggests questions that you may wish to ask and, of course,
    allows you to type whatever code-related questions you like.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如图4.1所示，高亮显示代码。之后，我们有几个选项。第一个是点击活动栏中的聊天图标（位于VS Code的左侧），或者按Ctrl-Alt-I。这将打开如图4.2所示的Copilot聊天界面。（还有其他聊天界面，包括你可以通过Ctrl-Shift-I打开的快速聊天——使用哪个聊天界面无关紧要。）Copilot聊天能够不仅用自然语言，还能用代码块、你可以点击以调用命令的按钮/链接等方式来回答你的问题。它还建议你可能想问的问题，当然，也允许你输入任何你喜欢的与代码相关的问题。
- en: '![figure](../Images/4-2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/4-2.png)'
- en: Figure 4.2 Copilot Chat interface in VS Code
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2 VS Code中的Copilot聊天界面
- en: 'For now, we’ll use Copilot Chat to explain the code. In the text box, type
    the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Copilot聊天来解释代码。在文本框中，输入以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If Copilot asks, you want the @workspace option. If this doesn’t work for you,
    you can also try this command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Copilot询问，你想要选择@workspace选项。如果这个选项对你不起作用，你也可以尝试以下命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Typing a forward slash (/) is how you tell Copilot Chat that you’re specifying
    a command (Copilot documentation refers to these as slash commands), rather than
    natural language. In this case, we’re asking for the `/explain` command to be
    run by Copilot for the selected text.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个正斜杠(/)是告诉Copilot聊天你正在指定一个命令（Copilot文档将这些称为斜杠命令），而不是自然语言。在这种情况下，我们正在请求Copilot运行`/explain`命令来解释选中的文本。
- en: Alternatively, you could ask Copilot to explain the code by highlighting the
    code in the function just like in figure 4.1\. Then, right-click the code in the
    function, and you’ll see the menu that appears in figure 4.3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过如图4.1所示的方式在函数中高亮显示代码来请求Copilot解释代码。然后，右键点击函数中的代码，你将看到如图4.3所示的菜单。
- en: '![figure](../Images/4-3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/4-3.png)'
- en: Figure 4.3 The menu that appears when you right-click the selected `best_word`
    function
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3 当你右键点击选中的`best_word`函数时出现的菜单
- en: In this menu, highlight Copilot, and you’ll see the list of options shown in
    figure 4.4\. These options are the more commonly used features with Copilot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜单中，高亮显示Copilot，你将看到图4.4中显示的选项列表。这些选项是使用Copilot时常用的功能。
- en: '![figure](../Images/4-4.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/4-4.png)'
- en: Figure 4.4 A list of options that you can use with Copilot
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4 你可以使用Copilot的选项列表
- en: The last step is to select the Explain This option. The Copilot Chat window
    will open (as shown earlier in figure 4.2), and you’ll get an explanation of the
    code. As usual, Copilot is nondeterministic, so your results will likely differ
    from ours. In fact, if an explanation is confusing you, you might try the `/explain`
    command again or writing your own prompt to get a different explanation. As educators,
    this is the start of a dream come true, where learners will be able to ask for
    as many explanations as they need to fully understand how code works.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是选择“解释此代码”选项。Copilot聊天窗口将打开（如图4.2中之前所示），你将得到代码的解释。像往常一样，Copilot是非确定性的，所以你的结果可能与我们的大不相同。事实上，如果解释让你感到困惑，你可能再次尝试使用`/explain`命令，或者编写自己的提示以获得不同的解释。作为教育工作者，这是梦想成真的开始，学习者将能够请求他们需要的任何解释，以完全理解代码是如何工作的。
- en: Copilot explanations can be wrong
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Copilot的解释可能会出错
- en: As with the code produced by Copilot, the explanations from Copilot can be wrong
    too. You might be thinking, “Wait, what’s the value of a tool to understand code
    if it can be wrong?!” First, we agree that this can be really frustrating. However,
    Copilot’s explanations are right often enough in our experience that they can
    be really helpful, particularly for understanding code basics such as the things
    we’re teaching in these two chapters. Moreover, what learners historically did
    when they were confused about their code was to ask friends or websites about
    the code, which can lead to mistakes too. A way to help mitigate the potential
    for error is to ask Copilot for its explanation a couple of times because you’re
    less likely to get grossly incorrect answers across multiple tries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与Copilot生成的代码一样，Copilot的解释也可能出错。你可能想，“等等，如果这个工具可以出错，那么理解代码的价值在哪里？！”首先，我们同意这确实可能非常令人沮丧。然而，根据我们的经验，Copilot的解释通常足够准确，可以非常有帮助，尤其是在理解代码基础知识方面，比如我们在这两章中教授的内容。此外，当学习者对他们的代码感到困惑时，他们通常会向朋友或网站寻求关于代码的帮助，这也可能导致错误。为了帮助减轻错误的可能性，你可以多次请求Copilot的解释，因为你在多次尝试中不太可能得到完全错误的答案。
- en: 'Here’s what Copilot gave us the first time we asked:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次请求Copilot时它给出的：
- en: The provided Python code defines a function named `best_word` that takes a list
    of words as an argument (`word_list`). The purpose of this function is to determine
    and return the word from the list that is worth the most points.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的Python代码定义了一个名为`best_word`的函数，它接受一个单词列表作为参数（`word_list`）。这个函数的目的是确定并返回列表中价值最高的单词。
- en: 'The function starts by initializing two variables: `best_word` and `best_points`.
    `best_word` is an empty string that will eventually hold the word with the highest
    point value, while `best_points` is set to 0 and will hold the highest point value
    found.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先初始化两个变量：`best_word`和`best_points`。`best_word`是一个空字符串，最终将包含具有最高点值的单词，而`best_points`被设置为0，将包含找到的最高点值。
- en: The function then enters a loop where it iterates over each word in the `word_list`.
    For each word, it calculates the point value of the word by calling the `num_points`
    function (not shown in the provided code). The `num_points` function presumably
    takes a word as an argument and returns its point value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后进入一个循环，遍历`word_list`中的每个单词。对于每个单词，它通过调用`num_points`函数（在提供的代码中未显示）来计算单词的点值。`num_points`函数可能接受一个单词作为参数，并返回其点值。
- en: If the point value of the current word is greater than the current `best_points`,
    the function updates `best_word` to be the current word and `best_points` to be
    the points of the current word. This way, the function always keeps track of the
    word with the highest point value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前单词的点值大于当前的`best_points`，函数将更新`best_word`为当前单词，并将`best_points`更新为当前单词的点值。这样，函数始终跟踪具有最高点值的单词。
- en: After the loop has iterated over all the words in the list, the function returns
    `best_word`, which at this point should be the word with the highest point value
    from the list. If the list is empty or all words have a point value of 0, the
    function will return an empty string.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环遍历完列表中的所有单词后，函数返回`best_word`，此时它应该是列表中具有最高点值的单词。如果列表为空或所有单词的点值都为0，函数将返回一个空字符串。
- en: To us, this is an excellent description of what the code does. It starts with
    an overall explanation of the code, and then proceeds to give more of a line-by-line
    explanation. Notice, however, to make full sense of it, you need to know important
    Python terminology and features. The explanation from Copilot refers to functions,
    arguments, variables, strings, loops, making decisions (“If the point value”),
    and returning. This explanation is quite useful if you understand the terminology,
    but much less useful if you don’t. By the end of this and the next chapter, you’ll
    know the main terminology and features of Python that you need to interpret a
    typical explanation from Copilot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这是对代码功能的一个非常好的描述。它首先对代码进行了整体解释，然后逐行进行更详细的说明。然而，请注意，要完全理解它，你需要了解重要的Python术语和特性。Copilot的解释提到了函数、参数、变量、字符串、循环、做出决定（“如果点值为”），以及返回。如果你理解了这些术语，这个解释非常有用，但如果你不理解，那么它的用处就小得多。到这一章和下一章的结尾，你将了解解释Copilot典型解释所需的Python的主要术语和特性。
- en: Asking for explanations
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 请求解释
- en: 'The type of explanation that you get from the `/explain` command may not meet
    your requirements. For example, suppose that you want Copilot to explicitly give
    you each line of code and explain what it does, so that you can more easily connect
    the code to its specific explanation. You can make that happen! Try this prompt:
    “Explain that code again, but do it line by line. Give each line of code and the
    explanation of what it does.” Doing so gave us a very detailed breakdown of each
    line of code, followed by its explanation. We encourage you to craft your own
    prompts if built-in commands aren’t giving you the level of detail that you want.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你从 `/explain` 命令中获得的那种解释可能不符合你的要求。例如，假设你希望 Copilot 明确地给你每一行代码并解释其功能，这样你就可以更容易地将代码与其具体解释联系起来。你可以做到这一点！尝试这个提示：“再次解释那行代码，但逐行解释。给出每一行代码及其功能的解释。”这样做给了我们每一行代码及其解释的非常详细的分解。我们鼓励你如果内置命令没有提供你想要的详细程度，就自己制作提示。
- en: '4.3 Top 10 programming features you need to know: Part 1'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 你需要了解的前 10 个编程特性：第 1 部分
- en: 'We’re going to give you a whirlwind tour of the 10 Python features that you’ll
    need for the rest of your programming journey, starting with the first five of
    those in this chapter. Python is an interactive language, which makes it easier
    than other languages for us to play around with and see what stuff does. We’ll
    take advantage of that here as we explore programming features. This is how the
    two of us learned Python and how many thousands of programmers have done so. Don’t
    hesitate to experiment! To get started, press Ctrl–Shift–P and type `REPL`, and
    then select Python: Start REPL. This should result in the situation shown in figure
    4.5\. (REPL stands for read-execute-print-loop. It’s called that because Python
    reads what you type, executes/runs it, prints the results back to you, and does
    all of this over and over in a loop.)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将带您快速浏览您在接下来的编程旅程中需要的 10 个 Python 特性，从本章中提到的这五个开始。Python 是一种交互式语言，这使得我们比其他语言更容易进行实验和查看各种功能。我们将利用这一点来探索编程特性。这是我们学习
    Python 的方式，也是成千上万的程序员学习 Python 的方式。不要犹豫去尝试！要开始，请按 Ctrl–Shift–P 并输入 `REPL`，然后选择
    Python：启动 REPL。这应该会导致图 4.5 中所示的情况。（REPL 代表读取-执行-打印-循环。之所以这样称呼，是因为 Python 会读取你输入的内容，执行/运行它，将结果打印回你，并在循环中反复这样做。）
- en: '![figure](../Images/4-5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/4-5.png)'
- en: Figure 4.5 Starting REPL from VS Code
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5 从 VS Code 启动 REPL
- en: This will put you back at the same Python prompt as in chapter 3 (as shown in
    figure 4.6), except with none of your functions loaded.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把你带回到第三章中相同的 Python 提示符（如图 4.6 所示），但没有任何你的函数被加载。
- en: '![figure](../Images/4-6.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/4-6.png)'
- en: Figure 4.6 REPL running in VS Code
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6 VS Code 中运行的 REPL
- en: Then, we can start typing Python code. For example, type
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始输入 Python 代码。例如，输入
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'and press Enter. You’ll see the response of `20`. We won’t spend time on simple
    math here, but the way you interact with Python to learn how it works is exactly
    the same: you type some code, and Python responds. Now, let’s jump into the first
    five of those 10 Python features we mentioned.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按 Enter 键。你会看到 `20` 的响应。我们在这里不会花费时间在简单的数学上，但你是如何与 Python 交互以了解其工作方式的，这与我们之前提到的那
    10 个 Python 特性中的第一个完全相同：你输入一些代码，Python 就会响应。现在，让我们深入探讨我们之前提到的 10 个 Python 特性中的前五个。
- en: '4.3.1 #1\. Functions'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.1 #1. 函数'
- en: 'You learned all about functions in chapter 3, so let’s just summarize what
    we learned. You use functions to break a large problem into smaller pieces. In
    retrospect, that `best_word` function we wrote in chapter 3 is a pretty big task:
    it has to figure out which word in a list of words is worth the most points. How
    many points is a word worth? Aha—that’s a subtask that we can carve out from this
    function, which we did in our earlier `num_points` function.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第三章已经学到了所有关于函数的知识，所以让我们只总结一下我们学到了什么。你使用函数将一个大问题分解成更小的部分。回顾一下，我们在第三章写的 `best_word`
    函数是一个相当大的任务：它必须确定在一系列单词中哪个单词值得最多的分数。一个单词值多少分？啊——这是一个可以从该函数中分离出来的子任务，我们在之前的 `num_points`
    函数中就是这样做的。
- en: We design a function to take parameters, one parameter for each piece or collection
    of data that the function needs to do its job. After doing their work, most functions
    use `return` to send the answer back to the line of code that called them. When
    we call a function, we pass values, known as arguments, with one value for each
    parameter, and we often store that return value using a variable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计一个函数来接受参数，每个参数对应于函数需要执行其工作所需的数据块或数据集合。在完成它们的工作后，大多数函数使用 `return` 将答案发送回调用它们的代码行。当我们调用一个函数时，我们传递值，称为参数，每个参数一个值，我们通常使用变量来存储那个返回值。
- en: 'For each program we write, we’ll likely need to design a few functions, but
    there are also some functions that are built-in to Python that we get for free.
    We can call those like we call our own functions. For example, there’s a built-in
    `max` function that takes one or more arguments and tells us the largest:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们编写的每个程序，我们可能需要设计几个函数，但 Python 也内置了一些函数，我们可以免费使用。我们可以像调用自己的函数一样调用它们。例如，有一个内置的
    `max` 函数，它接受一个或多个参数，并告诉我们最大的值：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There’s also the `input` function, which we used in our `get_strong_password`
    function from chapter 3\. It takes an argument that becomes the prompt to the
    user, and it returns whatever the user types at the keyboard:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 `input` 函数，我们在第 3 章的 `get_strong_password` 函数中使用过。它接受一个参数，该参数成为用户的提示，并返回用户在键盘上输入的内容：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If `input` is the function to receive input from the keyboard, is there an
    `output` function to output a message to the screen? Well, yes, but it’s called
    `print`, not `output`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `input` 是从键盘接收输入的函数，那么有没有一个 `output` 函数可以将消息输出到屏幕？嗯，是的，但它被称为 `print`，而不是
    `output`：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '4.3.2 #2\. Variables'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.2 #2\. 变量'
- en: A variable is a name that refers to a value. We used variables in chapter 3
    to keep track of `return` values from functions. We also just used a variable
    here to hold the user’s name. Whenever we need to remember a value for later,
    we use a variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个指向值的名称。我们在第 3 章中使用变量来跟踪函数的 `return` 值。我们在这里也使用了一个变量来保存用户的姓名。每次我们需要记住一个值以供以后使用时，我们都会使用变量。
- en: 'To assign a value to a variable, we use the = (equals sign) symbol, which is
    called the *assignment* symbol. It figures out the value of whatever is on the
    right and then assigns that to the variable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值赋给变量，我们使用等号（=）符号，这被称为 *赋值* 符号。它计算出右侧的值，并将其赋给变量：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 The right-hand side of the = symbol is evaluated, which means 20 + 4 is
    evaluated to be 24\. Then, the variable age is assigned the value of 24.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 等号右侧的表达式将被评估，这意味着 20 + 4 被评估为 24。然后，变量 age 被赋予值 24。'
- en: The = symbol is different in Python than in math
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Python 中的 = 符号与数学中的不同
- en: The = sign is used in Python and other programming languages to denote *assignment*.
    The variable on the left side of the = symbol is given the value of the calculation
    performed on the right side of the = symbol. This is *not* a permanent relationship
    as the variable can have its value changed. People new to programming who are
    strong in math can find this confusing, but just remember that the = sign in Python
    means assignment, not equality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 和其他编程语言中，等号（=）用于表示 *赋值*。等号左侧的变量被赋予等号右侧计算得到的值。这不是一个永久的关系，因为变量的值可以改变。对于数学能力强但编程新手的人来说，这可能会令人困惑，但只需记住
    Python 中的等号表示赋值，而不是相等。
- en: 'We can use the variable in a larger context, called an *expression*. The value
    that the variable refers to gets substituted for its name:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在更大的上下文中使用变量，这被称为 *表达式*。变量所指向的值会替换其名称：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Age is still available in the Python prompt and has the value 24\. 24 +
    3 is evaluated to be 27.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 年龄在 Python 提示符中仍然可用，其值为 24。24 + 3 被评估为 27。'
- en: '#2 The expression of age + 3 doesn’t change age because we didn’t reassign
    age.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 表达式 age + 3 并没有改变 age 的值，因为我们没有重新赋值 age。'
- en: Variables persist in the Python prompt
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 变量在 Python 提示符中持续存在
- en: We assigned `age` in the earlier batch of code. Why can we keep referring to
    it? Any variable declared during a session of programming with your Python prompt
    will stick around until you quit. That’s just how variables work in programs too.
    They’re available as soon as you assign a value to them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的代码块中分配了 `age`。为什么我们可以继续引用它？在 Python 提示符的编程会话期间声明的任何变量都会持续存在，直到你退出。这就是程序中变量的工作方式。一旦你为它们赋值，它们就可用。
- en: 'But notice that the variable `age` didn’t change when we said `age` `+` `3`!
    To change it, we need another = assignment statement:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，当我们说 `age` `+` `3` 时，变量 `age` 并没有改变！要改变它，我们需要另一个 `=` 赋值语句：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 We’ve changed age by doing an assignment (the = symbol).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们通过赋值（等号 `=` 符号）改变了 age。'
- en: 'Let’s see a few more ways to change what a variable refers to. We’ll include
    some explanations as annotations with the code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多改变变量引用的方法。我们将在代码旁边添加一些注释来解释：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 A shortcut way to add. age += 5 is equivalent to age = age + 5.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一个加的快捷方式。`age += 5` 等同于 `age = age + 5`。'
- en: '#2 A shortcut way to multiply by 2\. age *= 2 is equivalent to age = age *
    2\.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 一个乘以 2 的快捷方式。`age *= 2` 等同于 `age = age * 2`。'
- en: '4.3.3 #3\. Conditionals'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.3 #3. 条件语句'
- en: Whenever our program has to make a decision, we need a conditional statement.
    For example, in chapter 2, we needed to make a decision about which players to
    include in our data (we wanted only quarterbacks). To do so, we used `if` statements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的程序需要做出决定时，我们都需要一个条件语句。例如，在第 2 章中，我们需要决定包含在数据中的球员（我们只想包含四分卫）。为此，我们使用了 `if`
    语句。
- en: Remember our larger function from chapter 3? We’ve reproduced it here in the
    following listing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在第 3 章中提到的较大值函数吗？我们在这里的列表中重新实现了它。
- en: Listing 4.2 Function to determine the larger of two values
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2 确定两个值中较大值的函数
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 The num1 &gt; num2 expression will be True if num1 is greater than num2
    and will be False if num1 is less than or equal to num2.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果 num1 大于 num2，则 num1 &gt; num2 表达式将为 True；如果 num1 小于或等于 num2，则为 False。'
- en: '#2 This line is executed when num1 is greater than num2.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当 num1 大于 num2 时执行此行。'
- en: '#3 The else keyword must be paired with an if keyword. When the if doesn’t
    execute (num1 &gt; num2 is False), the else executes instead.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 `else` 关键字必须与 `if` 关键字配对。当 `if` 不执行（num1 &gt; num2 为 False）时，`else` 将会执行。'
- en: '#4 This line is executed when num1 isn’t greater than num2.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 当 num1 不大于 num2 时执行此行。'
- en: The `if-else` structure in listing 4.2 is known as a *conditional* statement,
    and it allows our program to make decisions. Here, if `num1` is greater than `num2`,
    then `num1` is returned; otherwise, `num2` is returned. That’s how it returns
    the larger one!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 中的 `if-else` 结构被称为 *条件语句*，它允许我们的程序做出决定。在这里，如果 `num1` 大于 `num2`，则返回 `num1`；否则，返回
    `num2`。这就是它返回较大值的方式！
- en: After `if`, we put a Boolean condition (`num1` `>` `num2`). A Boolean condition
    is an expression that tests a condition where the result would either be `True`
    or `False`. If it’s `True`, then the code under the `if` runs; if it’s `False`,
    then the code under the `else` runs. We create Boolean expressions using comparison
    symbols such as `>=` for greater than or equal to, `<` for less than, > for greater
    than, == for equal to, and `!=` for not equal to. Notice that we’re using indentation
    not only for the code of the function but also for the code of the `if` and `else`
    parts of the `if-else` statement. Indentation is necessary for the code to function
    properly, so it’s worth paying attention to (we talk more about indentation in
    the next chapter). This is how Python knows which lines of code belong to the
    function and which additionally belong to the `if` or `else`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 后面，我们放置一个布尔条件（`num1` `>` `num2`）。布尔条件是一个测试条件的表达式，其结果要么是 `True`，要么是 `False`。如果是
    `True`，则 `if` 下的代码执行；如果是 `False`，则 `else` 下的代码执行。我们使用比较符号（如 `>=` 表示大于等于，`<` 表示小于，`>`
    表示大于，`==` 表示等于，`!=` 表示不等于）来创建布尔表达式。请注意，我们不仅使用缩进来表示函数的代码，还使用缩进来表示 `if` 和 `else`
    语句的代码部分。缩进对于代码正确执行是必要的，所以值得注意（我们将在下一章中更多地讨论缩进）。这就是 Python 如何知道哪些代码行属于函数，哪些代码行还属于
    `if` 或 `else`。
- en: 'We can play around with conditional statements at the Python prompt too—we
    don’t need to be writing code inside of a function. Here’s an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 Python 提示符中玩转条件语句——我们不需要在函数内部编写代码。以下是一个例子：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 We assign 40 to age.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们将 40 赋值给 age。'
- en: '#2 Because age is 40, this code is asking whether 40 < 40\. It’s not, so the
    if part of the code is skipped.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 因为 age 是 40，这段代码是在询问 40 < 40 是否成立。它不成立，所以代码的 `if` 部分被跳过。'
- en: '#3 The else portion runs because the if condition is False.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 因为 `if` 条件为 False，所以执行 `else` 部分。'
- en: You’ll notice that the prompt changes from `>>>` to `...` when you’re typing
    inside the `if` statement. The change of prompt lets you know that you’re in the
    middle of typing code that you need to complete. You need an extra press of Enter
    when you’re done with the `else` code to get out of the `...` prompt and back
    to the `>>>` prompt.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`if`语句中输入时，你会注意到提示符从`>>>`变为`...`。提示符的变化让你知道你正在输入需要完成的代码。当你完成`else`代码后，你需要额外按一次Enter键，以退出`...`提示符并回到`>>>`提示符。
- en: 'We set the age variable to 40\. As `40` `<` `40` is `False`, the `else` runs.
    Let’s try again, this time making the `if` run:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将年龄变量设置为40。因为`40` `<` `40`是`False`，所以else部分会执行。让我们再试一次，这次让if部分执行：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 We assign 25 to age.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们将25赋值给年龄。'
- en: '#2 Because age is 25, this is asking whether 25 < 40\. It is, so the if part
    of the code runs.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 因为年龄是25，这是在询问25是否小于40。它是，所以if部分的代码会执行。'
- en: '#3 The else portion doesn’t run (we already ran the if part of the code).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当上面的条件都不成立时，else部分不会执行（我们已执行了代码的if部分）。'
- en: 'You might see some `if` statements with no `else` part, and that’s okay: the
    `else` part is optional. In that case, if the condition is `False`, then the `if`
    statement won’t do anything:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些没有`else`部分的`if`语句，这是可以的：`else`部分是可选的。在这种情况下，如果条件为`False`，则`if`语句不会执行任何操作：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 We assign 25 to age.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们将25赋值给年龄。'
- en: '#2 == tests to see if the two values are equal.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 == 检查两个值是否相等。'
- en: Notice that the way to test whether two values are equal is to use two equals
    signs, (`==)`, not one equals sign. (We already know that one equals sign is for
    the assignment statement to assign a value to a variable.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试两个值是否相等的方法是使用两个等号（`==`），而不是一个等号。（我们已知一个等号是用来执行赋值语句，将值赋给变量的。）
- en: What do you do if you have more than two possible outcomes? For example, let’s
    say that a person’s age determines the show they’ll likely binge, as shown in
    table 4.1.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多于两种可能的结果怎么办？例如，假设一个人的年龄决定了他们可能会狂热的电视剧，如表4.1所示。
- en: Table 4.1 Possible favorite TV shows by age
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.1 按年龄可能的喜欢的电视剧
- en: '| Age | Show |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Age | Show |'
- en: '| --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 30–39  | *Friends*  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 30–39  | *Friends*  |'
- en: '| 20–29  | *The Office*  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 20–29  | *The Office*  |'
- en: '| 10–19  | *Pretty Little Liars*  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 10–19  | *Pretty Little Liars*  |'
- en: '| 0–9  | *Chi’s Sweet Home*  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 0–9  | *Chi’s Sweet Home*  |'
- en: 'We can’t capture all of these outcomes with just an `if-else`, so the `elif`
    (short for `else-if`) allows us to capture the logic for more than two possible
    outcomes, as shown in the following code. We’re presenting this code without the
    Python prompts (`>>>` and `...`) because this would be a lot to type:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅用`if-else`来捕捉所有这些结果，所以`elif`（即`else-if`）允许我们捕捉多于两个可能结果的条件逻辑，如下面的代码所示。我们在这里不包含Python提示符（`>>>`和`...`），因为这会非常繁琐：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 This is True if both age >= 30 and age <= 39 are true; for example, if age
    were 35\.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当年龄大于等于30且小于等于39时，此条件为真；例如，如果年龄是35。'
- en: '#2 This condition is checked if the above condition is False.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果上面的条件为False，则会检查此条件。'
- en: '#3 This code runs if all conditions above are False.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果上面的所有条件都不成立，则此代码会执行。'
- en: We’re using `and` to capture a complex condition. For example, in the first
    line, we want age to be greater than or equal to 30 and less than or equal to
    39\. Python works from top to bottom, and when it finds a condition that’s true,
    it runs the corresponding indented code. Then, it stops checking the remaining
    `elif`s or `else`—so if two conditions happened to be true, only the code for
    the first one would run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`and`来捕捉一个复杂条件。例如，在第一行，我们希望年龄大于等于30且小于等于39。Python从上到下工作，当它找到一个成立的条件时，它会运行相应的缩进代码。然后，它停止检查剩余的`elif`或`else`——所以如果两个条件都成立，只有第一个条件的代码会运行。
- en: Try experimenting with various values for the age variable to observe that the
    correct code runs in each case. In fact, if we were serious about testing this
    code, we could use the `if` statement structure for a good sense of the values
    we’d want to test. It’s all about testing the boundaries of values. For example,
    we definitely want to test the ages 30 and 39 to make sure, for example, that
    we’re correctly capturing the full 30–39 range with the first condition. Similarly,
    we’d want to test 20, 29, 10, 19, 0, 9, and then something larger than 39 to test
    the `else` way at the bottom.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的年龄变量值进行实验，以观察在每种情况下正确的代码是否都能运行。实际上，如果我们认真测试这段代码，我们可以使用`if`语句结构来获得我们想要测试的值的良好感觉。这全部都是为了测试值的边界。例如，我们肯定想要测试30岁和39岁，以确保我们正确地用第一个条件捕捉到了完整的30-39岁范围。同样，我们还想测试20岁、29岁、10岁、19岁、0岁、9岁，以及大于39岁的某个值，以测试底部的`else`方式。
- en: If you use additional `if`s rather than `elif`s, then they become separate `if`
    statements, rather than a single `if` statement. This matters because Python always
    checks each independent `if` statement on its own, regardless of what may have
    happened in previous `if` statements.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用额外的`if`而不是`elif`，那么它们就变成了独立的`if`语句，而不是单个`if`语句。这很重要，因为Python总是独立地检查每个独立的`if`语句，而不管之前的`if`语句中发生了什么。
- en: 'For example, let’s change the `elif`s to `if`s in our age code. That gives
    us the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将我们的年龄代码中的`elif`改为`if`。这将给我们以下结果：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 This condition is always checked.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个条件始终会被检查。'
- en: '#2 This else goes with the most recent if statement.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个`else`与最近的`if`语句相关联。'
- en: Suppose that you put `age` `=` `25` above this code and run it. What do you
    think will happen? Well, the second `if` condition `age` `>=` `20` `and` `age`
    `<=` `29` is `True`, so we’ll certainly output `Binging` `The` `Office`. But that’s
    not all that happens! Remember, because we’re using `if`s here, each of the remaining
    ones is going to be checked. (If they were `elif`s, we’d be done.) `age` `>=`
    `10` `and` `age` `<=` `19` is `False`, so we’re not going to output `Binging`
    `Pretty` `Little` `Liars`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在上述代码中将`age`设置为`25`并运行它。你认为会发生什么？嗯，第二个`if`条件`age``>=``20``and``age``<=``29`是`True`，所以我们肯定会输出`Binging
    The Office`。但这并不是全部发生的事情！记住，因为我们在这里使用的是`if`，所以每个剩余的都会被检查。（如果它们是`elif`，我们就完成了。）`age``>=``10``and``age``<=``19`是`False`，所以我们不会输出`Binging
    Pretty Little Liars`。
- en: The final `if` condition `age` `>=` `0` `and` `age` `<=` `9` is also `False`,
    so we’re not going to output `Binging` `Chi's` `Sweet` `Home`. But this `if` has
    an `else`! So, we *are* going to output `What's` `binging?` We didn’t intend this!
    We only wanted `What's` `binging?` for people whose age is at least 40\. This
    is all to say that `if` and `elif` behave differently and that we need to be using
    the one that matches the behavior that we want (`if` if we want multiple chunks
    of code to potentially run, and `elif` if we want only one).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`if`条件`age``>=``0``and``age``<=``9`也是`False`，所以我们不会输出`Binging Chi's Sweet
    Home`。但是这个`if`有一个`else`！所以，我们确实会输出`What's binging?`。我们并没有打算这样做！我们只想为年龄至少为40岁的人输出`What's
    binging?`。这一切都是为了说明`if`和`elif`的行为不同，并且我们需要使用符合我们想要的行为的其中一个（如果我们想要多个代码块可能运行，则使用`if`；如果我们只想运行一个，则使用`elif`）。
- en: '4.3.4 #4\. Strings'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.4 #4. 字符串'
- en: As we learned in chapter 3, a string is the type we use whenever we want to
    store text. Text is everywhere—stats like in chapter 2, passwords, books—so strings
    show up in almost every Python program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第3章中学到的，字符串是我们想要存储文本时使用的类型。文本无处不在——第2章中的统计数据、密码、书籍——所以字符串几乎出现在每个Python程序中。
- en: We use quotation marks to indicate the beginning and end of the string. You’ll
    see Copilot use double quotes or single quotes. It doesn’t matter which you use;
    just be sure to start and end the string with the same type of quote.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用引号来表示字符串的开始和结束。你会看到Copilot使用双引号或单引号。使用哪种引号都无关紧要；只需确保字符串以相同类型的引号开始和结束。
- en: Strings come with a powerful set of methods. A *method* is a function that’s
    associated with a particular type—in this case, strings. The way you call a method
    is a little different from how you call a function. When you call a function,
    you put the argument values in parentheses. With methods, we still put values
    in parentheses, but we need to put the value on which we’re calling the method
    first, outside of the parentheses, followed by a dot. We’ll see an example of
    that next!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串附带了一组强大的方法。*方法*是与特定类型相关联的函数——在本例中是字符串。调用方法的方式与调用函数的方式略有不同。当你调用函数时，你将参数值放在括号内。对于方法，我们仍然将值放在括号内，但我们需要首先将我们要调用方法的价值放在括号外，然后是一个点。我们将在下一个例子中看到这一点！
- en: 'In chapter 3, Copilot used some string methods to implement `is_strong_password`.
    Let’s try using those methods here to gain a better understanding of how they
    work:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，Copilot使用了一些字符串方法来实现`is_strong_password`。让我们在这里尝试使用这些方法，以便更好地理解它们是如何工作的：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 isupper needs all characters to be uppercase for it to return True.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `isupper`需要所有字符都是大写才能返回True。'
- en: '#2 isdigit needs all characters to be numbers for it to return True.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 `isdigit`需要所有字符都是数字才能返回True。'
- en: '#3 isalnum needs all characters to be alphanumeric to return True (a space
    isn’t considered alphanumeric).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 `isalnum`需要所有字符都是字母数字才能返回True（空格不被视为字母数字）。'
- en: There are many other string methods as well. Some help you convert strings between
    lowercase and uppercase, others help you search a string, and still others help
    you format a string (e.g., centering or right-justifying it).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的字符串方法。一些帮助你将字符串在大小写之间转换，其他帮助你搜索字符串，还有一些帮助你格式化字符串（例如，居中或右对齐）。
- en: 'Copilot’s Explain feature can often be helpful if you’re not sure what a given
    string method does. For example, what does this function do:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对某个特定的字符串方法不确定，Copilot的Explain功能通常很有帮助。例如，这个函数做什么：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 Removes all ( characters from phone number'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从电话号码中移除所有（字符'
- en: '#2 Removes all ) characters from phone number'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 从电话号码中移除所有）字符'
- en: '#3 Removes all – characters from phone number'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 从电话号码中移除所有–字符'
- en: 'Remember that we can ask Copilot to explain code, as we demonstrated in section
    4.2\. Here’s what we got when we asked Copilot to explain this code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以像在第4.2节中演示的那样要求Copilot解释代码。这是当我们要求Copilot解释这段代码时得到的结果：
- en: The provided Python code defines a function named `clean_number`. This function
    is designed to take a single argument, `phone_number`, which is expected to be
    a string representing a phone number. The purpose of this function is to remove
    certain characters from the phone number string, specifically parentheses “(”
    and “)” and hyphens “-”.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的Python代码定义了一个名为`clean_number`的函数。这个函数旨在接受一个参数，`phone_number`，它预期是一个表示电话号码的字符串。这个函数的目的是从电话号码字符串中移除某些字符，特别是括号“（”和“）”以及连字符“-”。
- en: 'The function uses the `replace()` method, which is a built-in method in Python
    for strings. The `replace()` method replaces a specified phrase with another specified
    phrase. It takes two arguments: the first is the substring that needs to be replaced,
    and the second is the substring that will replace the first substring.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用了`replace()`方法，这是Python中字符串的一个内置方法。`replace()`方法用另一个指定的子串替换指定的子串。它接受两个参数：第一个是需要替换的子串，第二个是替换第一个子串的子串。
- en: 'In this function, the `replace()` method is called three times on `phone_number`.
    Each call to `replace()` is used to remove one type of character: first the open
    parenthesis “(”, then the close parenthesis “)”, and finally the hyphen “-”. It
    does this by replacing these characters with an empty string "", effectively removing
    them.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`replace()`方法在`phone_number`上被调用了三次。每次调用`replace()`都用于移除一种类型的字符：首先移除开括号“（”，然后移除闭括号“）”，最后移除连字符“-”。它是通过将这些字符替换为空字符串""来实现的，从而有效地移除了它们。
- en: After all replacements are done, the cleaned `phone_number` is returned by the
    function. This will be a string containing the digits of the phone number without
    any parentheses or hyphens.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有替换完成后，函数返回清理后的`phone_number`。这将是一个不包含任何括号或连字符的数字字符串。
- en: This function could be useful in situations where you need to process or store
    phone numbers in a consistent, character-free format. For example, you might want
    to remove these characters when storing phone numbers in a database, or when comparing
    phone numbers for equality.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在需要以一致、无字符的格式处理或存储电话号码的情况下可能很有用。例如，你可能想在数据库中存储电话号码或比较电话号码的相等性时移除这些字符。
- en: 'That confirms what this function does: removes parentheses and hyphens from
    a phone number string. And it uses the `replace` method to do so.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了此函数的功能：从电话号码字符串中移除括号和连字符。并且它使用`replace`方法来完成此操作。
- en: 'Wait—“replace” sounds like we’re changing some characters to some other characters
    (replacing them), not removing them. How is `replace` able to remove characters
    for us, then? The explanation said, “It does this by replacing these characters
    with an empty string "", effectively removing them.” That’s a clue to how `replace`
    is doing this, but we might want to know more. We therefore next used the prompt
    “How does the replace method use the empty string to remove characters?” and received
    the following explanation from Copilot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 等等——“replace”听起来像我们正在将一些字符更改为其他字符（替换它们），而不是移除它们。那么`replace`是如何为我们移除字符的呢？解释说：“它是通过将这些字符替换为空字符串""来实现的，从而有效地移除了它们。”这是了解`replace`如何工作的一个线索，但我们可能还想了解更多。因此，我们接下来使用了提示“replace方法是如何使用空字符串来移除字符的？”并从Copilot那里收到了以下解释：
- en: The `replace()` method in Python replaces all occurrences of a specified substring
    in the string it’s called on with another specified substring.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`replace()`方法在其被调用的字符串中替换所有指定的子字符串。
- en: In this case, the specified substrings are the characters “(”, “)”, and “-”.
    The method is called on the `phone_number` string, and the second argument to
    `replace()` is an empty string "".
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，指定的子字符串是字符“（”，”）”和“-”。方法被调用在`phone_number`字符串上，`replace()`的第二个参数是一个空字符串""。
- en: So, what happens is that every occurrence of the specified character in `phone_number`
    is replaced with an empty string. This effectively removes that character from
    the string, because replacing something with nothing is equivalent to removing
    it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，发生的情况是`phone_number`中指定字符的每个出现都被替换为空字符串。这实际上从字符串中移除了该字符，因为用无替换某物等同于移除它。
- en: This is done three times in the `clean_number` function, once for each character
    that needs to be removed. After all three characters have been removed, the cleaned
    `phone_number` is returned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`clean_number`函数中进行了三次，每次移除一个字符。在所有三个字符都被移除后，清理后的`phone_number`被返回。
- en: And if you wanted to learn even more, you could continue asking Copilot questions
    or do your own testing at the Python prompt. For example, you could verify that
    `replace` removes all (, ), and - characters, even if there are multiples of each.
    And you could explore using `replace` to actually replace characters (its typical
    use case), rather than removing them. This kind of exploration is also helpful
    if we need to separate truth from bits of incorrect information that Copilot may
    provide. This is why we need a baseline of our own Python knowledge!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要学习更多，你可以继续向Copilot提问或在Python提示符下进行自己的测试。例如，你可以验证`replace`会移除所有(, ), 和 -
    字符，即使每种字符有多个。你还可以探索使用`replace`来实际替换字符（其典型用例），而不是移除它们。这种探索如果需要区分真相和Copilot可能提供的不正确信息片段也是很有帮助的。这就是为什么我们需要自己的Python知识基础！
- en: 'You’ll also often see what look like mathematical operators being used on strings.
    They are the same as math symbols, but they do different things on strings. The
    + operator is used to put two strings together, and the * operator is used to
    repeat a string a specific number of times. Examples are shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会经常看到在字符串上使用看起来像数学运算符的情况。它们与数学符号相同，但在字符串上执行不同的操作。+运算符用于将两个字符串拼接在一起，而*运算符用于将字符串重复特定次数。示例如下：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Combines first and second strings and assigns result to sentence'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将第一和第二字符串合并并将结果赋值给sentence'
- en: '#2 Repeats the -= string five times'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将“-”字符串重复五次'
- en: '4.3.5 #5\. Lists'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.5 #5\. 列表'
- en: A *string is great when we have a sequence of characters, such as a password
    or a single Scrabble word. But sometimes, we need to store many words or many
    numbers. For that, we need a list. We used a list in chapter 3 for the `best_word`
    function because that function needed to work with a list of individual words.*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个字符序列时，例如密码或单个Scrabble单词，字符串就非常棒。但有时，我们需要存储许多单词或许多数字。为此，我们需要一个列表。我们在第3章使用列表来处理`best_word`函数，因为这个函数需要与单词列表一起工作。
- en: '*Whereas we use quotation marks to start and end a string, we use opening and
    closing square brackets to start and end a list. And, as for strings, there are
    many methods available on lists. To give you an idea of the kinds of list methods
    available and what they do, let’s explore some of these:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*与我们在字符串的开始和结束处使用引号一样，我们使用开闭方括号来开始和结束列表。至于字符串，列表上有许多可用方法。为了给你一个关于可用列表方法和它们做什么的印象，让我们探索一些这些方法：'
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 A list with three string values in it'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 包含三个字符串值的列表'
- en: '#2 Adds a new string value to the end of the list'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在列表末尾添加一个新的字符串值'
- en: '#3 Reverses the list (now the values are in the opposite order)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 反转列表（现在值是相反的顺序）'
- en: 'Many Python types, including strings and lists, allow you to work with particular
    values using an *index*. You need to use indices whenever you want to work with
    part of a string or list rather than the whole thing. An index is just a number
    that identifies an element. Indices start at 0 for the first element and go up
    to, but not including, the number of values. The first value has index 0 (not
    index 1!), the second has index 1, the third has index 2, and so on. The last
    value in the list is at the index, which is the length of the list minus 1\. The
    length of the list can be determined by using the `len` function. For example,
    if we do `len(books)`, we’ll get a value of `4` (so the valid indices are from
    0 up to and including 3). People also often use negative indices, which provides
    another way to index each value: the rightmost value has index –1, the value to
    its left has index –2, and so on. Figure 4.7 depicts this example with both positive
    and negative indexing.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python类型，包括字符串和列表，允许你使用索引来处理特定的值。当你想要处理字符串或列表的一部分而不是整个字符串或列表时，你需要使用索引。索引只是一个标识元素的数字。索引从0开始，对于第一个元素，然后一直增加到但不包括值的数量。第一个值有索引0（不是索引1！），第二个有索引1，第三个有索引2，依此类推。列表中的最后一个值在索引处，该索引是列表长度减1。列表的长度可以通过使用`len`函数来确定。例如，如果我们做`len(books)`，我们会得到一个值为`4`（因此有效的索引是从0到包括3）。人们也经常使用负索引，这为每个值提供了另一种索引方式：最右侧的值有索引-1，其左侧的值有索引-2，依此类推。图4.7展示了正索引和负索引的示例。
- en: '![figure](../Images/4-7.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/4-7.png)'
- en: Figure 4.7 List elements can be accessed through either positive or negative
    indices.
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7 列表元素可以通过正索引或负索引访问。
- en: 'Let’s practice indexing on the current books list:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在当前的书籍列表上练习索引：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 books[0] corresponds to the first element.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 books[0]对应于第一个元素。'
- en: '#2 Error because index 3 is the last book!'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 错误是因为索引3是最后一本书！'
- en: '#3 books[-1] refers to the last element in the list.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 books[-1]指向列表中的最后一个元素。'
- en: 'There’s also a way to pull multiple values out of a string or list, rather
    than just one. It’s called *slicing*. We specify the index of the first value,
    a colon, and the index to the right of the value, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种方法可以从字符串或列表中提取多个值，而不仅仅是单个值。这被称为*切片*。我们指定第一个值的索引，一个冒号，以及值右侧的索引，如下所示：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Starts at index 1, ends at index 2 (not 3!)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从索引1开始，到索引2结束（不是3！）'
- en: We specified 1:3, so you might expect to get the values including index 3\.
    But the value at the second index (the one after the colon) isn’t included. It’s
    counterintuitive but true!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了1:3，所以你可能期望得到包括索引3在内的值。但冒号后面的第二个索引（即值之后的索引）不包括在内。这听起来很反直觉，但却是真的！
- en: 'If we leave out the starting or ending index, Python uses the start or end
    as appropriate:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略起始或结束索引，Python会根据需要使用起始或结束索引：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 Same as using books[0:3]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 与使用书籍[0:3]相同'
- en: '#2 Same as using books[1:4]'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 与使用books[1:4]相同'
- en: 'We can also use indexing to change a specific value in a list, for example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用索引来更改列表中的特定值，例如：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Changes books[0] to refer to the string value “The Android”'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将书籍[0]更改为指向字符串值“Android”'
- en: '#2 Changes books[1] to be in all uppercase'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将书籍[1]更改为全部大写'
- en: 'If we try that on a string, though, we get an error:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在字符串上尝试这样做，我们会得到一个错误：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#1 Looking up a char works fine.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 查找字符没有问题。'
- en: '#2 But assigning doesn’t!'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 但赋值不会！'
- en: A string is known as an *immutable* value, which means that you can’t change
    its characters. You can only create an entirely new string. By contrast, a list
    is known as a *mutable* value, which means that you can change it. If you get
    errors about a type not supporting item assignment, you’re likely trying to change
    a value that can’t be changed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串被称为*不可变*值，这意味着您不能更改其字符。您只能创建一个全新的字符串。相比之下，列表被称为*可变*值，这意味着您可以更改它。如果您收到有关类型不支持项赋值错误的错误，您很可能是尝试更改无法更改的值。
- en: In this chapter, we introduced you to five of the most common code features
    in Python. We’ll continue with five more in the next chapter. We also showed you
    how you can use the Copilot explanation tool to help you understand what the code
    is doing and offered guidance for verifying the veracity of these explanations.
    Table 4.2 provides a summary of the features we covered in this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了Python中最常见的五个代码特性。我们将在下一章继续介绍另外五个。我们还向您展示了如何使用Copilot解释工具来帮助您理解代码，并提供了验证这些解释真实性的指导。表4.2提供了本章所涵盖特性的总结。
- en: Table 4.2 Summary of Python code features from this chapter
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.2本章Python代码特性总结
- en: '| **Code Element** | Example | Brief Description |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **代码元素** | 示例 | 简要描述 |'
- en: '| --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Functions  | `def larger(num1, num2)`  | Code feature that allows us to manage
    code complexity. Functions take in inputs, process those inputs, and possibly
    return an output.  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | `def larger(num1, num2)` | 允许我们管理代码复杂性的代码特性。函数接受输入，处理这些输入，并可能返回一个输出。|'
- en: '| Variables  | `age = 25`  | A human-readable name that refers to a stored
    value. It can be assigned using the `=` assignment statement.  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | `age = 25` | 一个可读性高的人名，它指向一个存储的值。可以使用`=`赋值语句进行赋值。|'
- en: '| Conditionals  | `if age < 18: print("Can''t vote") else: print("Can vote")`  |
    Conditionals allow the code to make decisions. In Python, we have three keywords
    associated with conditionals: `if`, `elif`, and `else`.  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 条件语句 | `if age < 18: print("Can''t vote") else: print("Can vote")` | 条件语句允许代码做出决策。在Python中，我们有与条件相关的三个关键字：`if`、`elif`和`else`。|'
- en: '| Strings  | `name = ''Dan''`  | Strings store a sequence of characters (text).
    There are many powerful methods available for modifying strings.  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `name = ''Dan''` | 字符串存储一系列字符（文本）。有许多强大的方法可用于修改字符串。|'
- en: '| Lists  | `list = [''Leo'', ''Dan'']`  | A sequence of values of any type.
    There are many powerful methods available for modifying lists.  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | `list = [''Leo'', ''Dan'']` | 一个包含任何类型值的序列。有许多强大的方法可用于修改列表。|'
- en: 4.4 Exercises
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 练习
- en: Recall the conditionals code we looked at in listing 4.2 (section 4.3.3). How
    does the behavior of this program differ from the original?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下我们在列表4.2（第4.3.3节）中查看的条件代码。这个程序的行为与原始程序有何不同？
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 2\. In the following code, what gets printed if age is 32? What would be printed
    if you change every `if`, except for the first, to an `elif` instead?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 在以下代码中，如果年龄是32，会打印什么？如果您将除了第一个之外的所有`if`改为`elif`，会打印什么？
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 3\. What Python data type would you use to hold a series of temperature readings
    from a sensor that records data every minute? What would this data type store?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 你会使用什么Python数据类型来存储传感器每分钟记录的一系列温度读数？这种数据类型会存储什么？
- en: 4\. Arrange the following blocks of Python code to create a program that calculates
    the sum of all even numbers in a provided list.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 将以下Python代码块排列成程序，以计算提供的列表中所有偶数的总和。
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '5\. (Recall section 4.3.1.) Consider the Python function call `min(input("Enter`
    `a` `number:` `"),` `input("Enter` `another` `number:` `"))`. Before running this
    code, think about what this line is supposed to do, and then answer the following
    questions:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5. （回忆第4.3.1节。）考虑以下Python函数调用`min(input("Enter a number: "), input("Enter another
    number: "))`。在运行此代码之前，思考这一行代码的预期功能，然后回答以下问题：'
- en: What do you expect to happen when this code is run? Describe each step of the
    execution process.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你期望运行此代码时会发生什么？描述执行过程的每个步骤。
- en: How does Python handle the inputs and the `min` function together in this scenario?
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个场景中，Python是如何处理输入和`min`函数的？
- en: If the inputs aren’t numbers but strings that are numeric (e.g., `5` or `2`),
    how might Python’s behavior change, if at all?
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入的不是数字，而是可以表示数字的字符串（例如，`5`或`2`），Python的行为会怎样改变，如果有的话？
- en: What would be the outcome if one or both inputs aren’t numeric? Test your hypothesis
    by trying different inputs.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个或两个输入不是数字，结果会怎样？通过尝试不同的输入来测试您的假设。
- en: 6\. In section 4.3.2, we talked about how variables persist in Python. How does
    this property of variables influence the way you might structure your code? Think
    of an example scenario where maintaining variable states across different parts
    of a program would be beneficial.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '7\. We ask Copilot to explain how the following code works:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Copilot provides the following explanation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: This Python code is a simple program that asks the user for their age and then
    prints out a message based on the age range they fall into.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of the code uses the `input()` function to prompt the user to
    enter their age. The `input()` function reads a line from input (usually from
    the user’s keyboard), converts it into a string, and returns that string. In this
    case, the prompt is “Enter your age: ”. The returned string is then converted
    into an integer using the `int()` function and stored in the variable age.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is a series of conditional statements that check the value
    of age and print out a corresponding message. The `if` statement checks if the
    age is less than 13, and if so, it prints “You are a child.” If the age is not
    less than 13, the program moves to the next condition, the `elif` (short for `else`
    `if`) statement, which checks if the age is less than 20\. If so, it prints “You
    are a teenager.” If the age is not less than 20, it moves to the next `elif` statement,
    which checks if the age is less than 60\. If so, it prints “You are an adult.”
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the explanation from Copilot is incomplete as it doesn’t describe
    the code for *all inputs*. Determine what the explanation is missing, and add
    your answer to the explanation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Review the Python code provided and the initial prompt to Copilot. The explanation
    returned was too vague and didn’t help you understand the string methods used
    in the code.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Prompt given to Copilot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Can you explain what this code does?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Copilot explanation given back:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The code involves manipulating a string stored in text by finding a specific
    word and replacing it with another word. It uses methods to locate where the word
    starts and then constructs a new string where the word has been replaced. Finally,
    it prints out the modified string.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task is to do the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Identify why the initial prompt might lead to a vague or unhelpful explanation.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improve the prompt to ensure a more detailed and specific explanation from Copilot.
    Consider what you specifically don’t understand about the string methods and how
    the code uses them.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the revised prompt to Copilot, and discuss how your changes will lead
    to a better explanation.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to be able to read code to determine whether it’s correct, test it effectively,
    and write our own code when needed.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot can provide line-by-line explanations of code to explain what the code
    is doing, and you can use your own prompt to influence the type of explanation
    you get.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has built-in functions such as `max`, `input`, and `print` that we call
    just like we call our own functions.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python有内置函数，如`max`、`input`和`print`，我们可以像调用自己的函数一样调用它们。
- en: A variable is a name that refers to a value.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是一个指向值的名称。
- en: An assignment statement makes a variable refer to a specific value.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个赋值语句使一个变量指向一个特定的值。
- en: An `if` statement is used to have our programs make decisions and proceed down
    one of multiple paths.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`if`语句用于让我们的程序做出决策，并沿着多条路径中的其中一条继续执行。
- en: A string is used to store and manipulate text.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串用于存储和操作文本。
- en: A method is a function associated with a particular type.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法是与特定类型相关联的函数。
- en: A list is used to store and manipulate a general sequence of values (e.g., a
    sequence of numbers or a sequence of strings).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表用于存储和操作一系列通用的值（例如，一系列数字或一系列字符串）。
- en: Each value in a string or list has an index; indexing starts at 0, not 1\.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串或列表中的每个值都有一个索引；索引从0开始，而不是1。
- en: Strings are immutable (not changeable); lists are mutable (changeable).*
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是不可变的（不可更改的）；列表是可变的（可更改的）*。
