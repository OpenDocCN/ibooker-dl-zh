["```py\nimport numpy as np\n\nrng = np.random.default_rng(seed=42)\nm = 200  # number of instances\nX = 2 * rng.random((m, 1))  # column vector\ny = 4 + 3 * X + rng.standard_normal((m, 1))  # column vector\n```", "```py\nfrom sklearn.preprocessing import add_dummy_feature\n\nX_b = add_dummy_feature(X)  # add x0 = 1 to each instance\ntheta_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n```", "```py\n>>> theta_best `array([[3.69084138],`\n `[3.32960458]])`\n```", "```py```", "````py`` We would have hoped for *θ*[0] = 4 and *θ*[1] = 3 instead of *θ*[0] = 3.6908 and *θ*[1] = 3.3296\\. Close enough, but the noise made it impossible to recover the exact parameters of the original function. The smaller and noisier the dataset, the harder it gets.    Now we can make predictions using <mover accent=\"true\"><mi mathvariant=\"bold\">θ</mi><mo>^</mo></mover>:    ``` >>> X_new = np.array([[0], [2]]) `>>>` `X_new_b` `=` `add_dummy_feature``(``X_new``)`  `# add x0 = 1 to each instance` ```py` `>>>` `y_predict` `=` `X_new_b` `@` `theta_best` ``` `>>>` `y_predict` `` `array([[ 3.69084138],`  `[10.35005055]])` `` ```py ````", "```py   ```", "```py```", "```py```", "````py ````", "``` Let’s plot this model’s predictions ([Figure 4-2](#linear_model_predictions_plot)):    ```", "```py  ![Scatter plot showing data points with a fitted linear regression line representing predictions.](assets/hmls_0402.png)  ###### Figure 4-2\\. Linear regression model predictions    Performing linear regression using Scikit-Learn is relatively straightforward:    ```", "```py`` `>>>` `lin_reg``.``fit``(``X``,` `y``)` ```", "```py `(array([3.69084138]), array([[3.32960458]]))` `>>>` `lin_reg``.``predict``(``X_new``)` `` `array([[ 3.69084138],`  `[10.35005055]])` `` ```", "```py` ```", "```py   ```", "```py`` ```", "```py` ```", "```py Notice that Scikit-Learn separates the bias term (`intercept_`) from the feature weights (`coef_`). The `LinearRegression` class is based on the `scipy.linalg.lstsq()` function (the name stands for “least squares”), which you could call directly:    ```", "```py   ```", "```py` This function computes <mover accent=\"true\"><mi mathvariant=\"bold\">θ</mi><mo>^</mo></mover><mo>=</mo><msup><mi mathvariant=\"bold\">X</mi><mo>+</mo></msup><mi mathvariant=\"bold\">y</mi>, where <msup><mi mathvariant=\"bold\">X</mi><mo>+</mo></msup> is the *pseudoinverse* of **X** (specifically, the Moore–Penrose inverse). You can use `np.linalg.pinv()` to compute the pseudoinverse directly:    ```", "```py   ``The pseudoinverse itself is computed using a standard matrix factorization technique called *singular value decomposition* (SVD) that can decompose the training set matrix **X** into the matrix multiplication of three matrices **U** **Σ** **V**^⊺ (see `numpy.linalg.svd()`). The pseudoinverse is computed as <msup><mi mathvariant=\"bold\">X</mi><mo>+</mo></msup><mo>=</mo><mi mathvariant=\"bold\">V</mi><msup><mi mathvariant=\"bold\">Σ</mi><mo>+</mo></msup><msup><mi mathvariant=\"bold\">U</mi><mo>⊺</mo></msup>. To compute the matrix <msup><mi mathvariant=\"bold\">Σ</mi><mo>+</mo></msup>, the algorithm takes **Σ** and sets to zero all values smaller than a tiny threshold value, then it replaces all the nonzero values with their inverse, and finally it transposes the resulting matrix. This approach is more efficient than computing the normal equation, plus it handles edge cases nicely: indeed, the normal equation may not work if the matrix **X**^⊺**X** is not invertible (i.e., singular), such as if *m* < *n* or if some features are redundant, but the pseudoinverse is always defined.`` ```", "```py`` ```", "```py ```", "```py` ```", "```py`` ```", "```py```", "``````py```` ```py``````", "``````py``````", "```py` ```", "```py ```", "```py```", "````py````", "```py```", "```py```", "````py````", "```py```", "``````py``````", "`````` # Gradient Descent    *Gradient descent* is a generic optimization algorithm capable of finding optimal solutions to a wide range of problems. The general idea of gradient descent is to tweak parameters iteratively in order to minimize a cost function.    Suppose you are lost in the mountains in a dense fog, and you can only feel the slope of the ground below your feet. A good strategy to get to the bottom of the valley quickly is to go downhill in the direction of the steepest slope. This is exactly what gradient descent does: it measures the local gradient of the error function with regard to the parameter vector **θ**, and it goes in the direction of descending gradient. Once the gradient is zero, you have reached a minimum!    In practice, you start by filling **θ** with random values (this is called *random initialization*). Then you improve it gradually, taking one baby step at a time, each step attempting to decrease the cost function (e.g., the MSE), until the algorithm *converges* to a minimum (see [Figure 4-3](#gradient_descent_diagram)).  ![Diagram illustrating gradient descent where model parameters adjust in decreasing steps towards the minimum of a cost function, demonstrating the effect of a small learning rate.](assets/hmls_0403.png)  ###### Figure 4-3\\. In this depiction of gradient descent, the model parameters are initialized randomly and get tweaked repeatedly to minimize the cost function; the learning step size is proportional to the slope of the cost function, so the steps gradually get smaller as the cost approaches the minimum    An important parameter in gradient descent is the size of the steps, determined by the *learning rate* hyperparameter. If the learning rate is too small, then the algorithm will have to go through many iterations to converge, which will take a long time (see [Figure 4-4](#small_learning_rate_diagram)).  ![Diagram illustrating a gradient descent path with a small learning rate, showing slow progression towards the minimum cost.](assets/hmls_0404.png)  ###### Figure 4-4\\. Learning rate too small    On the other hand, if the learning rate is too high, you might jump across the valley and end up on the other side, possibly even higher up than you were before. This might make the algorithm diverge, with larger and larger values, failing to find a good solution (see [Figure 4-5](#large_learning_rate_diagram)).  ![Diagram illustrating how a high learning rate can cause gradient descent to overshoot the optimal point, resulting in divergence.](assets/hmls_0405.png)  ###### Figure 4-5\\. Learning rate too high    Additionally, not all cost functions look like nice, regular bowls. There may be holes, ridges, plateaus, and all sorts of irregular terrain, making convergence to the minimum difficult. [Figure 4-6](#gradient_descent_pitfalls_diagram) shows the two main challenges with gradient descent. If the random initialization starts the algorithm on the left, then it will converge to a *local minimum*, which is not as good as the *global minimum*. If it starts on the right, then it will take a very long time to cross the plateau. And if you stop too early, you will never reach the global minimum.  ![Diagram illustrating gradient descent pitfalls, showing a local minimum trap and a plateau that slows progress toward the global minimum.](assets/hmls_0406.png)  ###### Figure 4-6\\. Gradient descent pitfalls    Fortunately, the MSE cost function for a linear regression model happens to be a *convex function*, which means that if you pick any two points on the curve, the line segment joining them is never below the curve. This implies that there are no local minima, just one global minimum. It is also a continuous function with a slope that never changes abruptly.⁠^([2](ch04.html#id1475)) These two facts have a great consequence: gradient descent is guaranteed to approach arbitrarily closely the global minimum (if you wait long enough and if the learning rate is not too high).    While the cost function has the shape of a bowl, it can be an elongated bowl if the features have very different scales. [Figure 4-7](#elongated_bowl_diagram) shows gradient descent on a training set where features 1 and 2 have the same scale (on the left), and on a training set where feature 1 has much smaller values than feature 2 (on the right).⁠^([3](ch04.html#id1476))    As you can see, on the left the gradient descent algorithm goes straight toward the minimum, thereby reaching it quickly, whereas on the right it first goes in a direction almost orthogonal to the direction of the global minimum, and it ends with a long march down an almost flat valley. It will eventually reach the minimum, but it will take a long time.    This diagram also illustrates the fact that training a model means searching for a combination of model parameters that minimizes a cost function (over the training set). It is a search in the model’s *parameter space*. The more parameters a model has, the more dimensions this space has, and the harder the search is: searching for a needle in a 300-dimensional haystack is much trickier than in 3 dimensions. Fortunately, since the cost function is convex in the case of linear regression, the needle is simply at the bottom of the bowl.  ![Diagram showing gradient descent paths on cost function contours; left is circular indicating equal feature scaling, right is elongated showing uneven scaling.](assets/hmls_0407.png)  ###### Figure 4-7\\. Gradient descent with (left) and without (right) feature scaling    ###### Warning    When using gradient descent, you should ensure that all features have a similar scale (e.g., using Scikit-Learn’s `StandardScaler` class), or else it will take much longer to converge.    ## Batch Gradient Descent    Most models have more than one model parameter. Therefore, to implement gradient descent, you need to compute the gradient of the cost function with regard to each model parameter *θ*[*j*]. In other words, you need to calculate how much the cost function will change if you change *θ*[*j*] just a little bit. This is called a *partial derivative*. It is like asking, “What is the slope of the mountain toward the east?” and then asking the same question facing north (and so on for all other dimensions, if you can imagine a universe with more than three dimensions). [Equation 4-6](#mse_partial_derivatives) computes the partial derivative of the MSE with regard to parameter *θ*[*j*], denoted ∂ MSE(**θ**) / ∂θ[*j*].    ##### Equation 4-6\\. Partial derivatives of the cost function  <mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mfrac><mi>∂</mi> <mrow><mi>∂</mi><msub><mi>θ</mi> <mi>j</mi></msub></mrow></mfrac></mstyle> <mtext>MSE</mtext> <mrow><mo>(</mo> <mi mathvariant=\"bold\">θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel=\"0\" displaystyle=\"true\"><mfrac><mn>2</mn> <mi>m</mi></mfrac></mstyle> <munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>m</mi></munderover> <mrow><mo>(</mo> <msup><mi mathvariant=\"bold\">θ</mi> <mo>⊺</mo></msup> <msup><mi mathvariant=\"bold\">x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>-</mo> <msup><mi>y</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></mrow>  Instead of computing these partial derivatives individually, you can use [Equation 4-7](#mse_gradient_vector) to compute them all in one go. The gradient vector, denoted ∇[**θ**]MSE(**θ**), contains all the partial derivatives of the cost function (one for each model parameter).    ##### Equation 4-7\\. Gradient vector of the cost function  <mrow><msub><mi>∇</mi> <mi mathvariant=\"bold\">θ</mi></msub> <mtext>MSE</mtext> <mrow><mo>(</mo> <mi mathvariant=\"bold\">θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo stretchy=\"true\">(</mo> <mtable><mtr><mtd><mrow><mfrac><mi>∂</mi> <mrow><mi>∂</mi><msub><mi>θ</mi> <mn>0</mn></msub></mrow></mfrac> <mtext>MSE</mtext> <mrow><mo>(</mo> <mi mathvariant=\"bold\">θ</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mrow><mfrac><mi>∂</mi> <mrow><mi>∂</mi><msub><mi>θ</mi> <mn>1</mn></msub></mrow></mfrac> <mtext>MSE</mtext> <mrow><mo>(</mo> <mi mathvariant=\"bold\">θ</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd></mtr> <mtr><mtd><mrow><mfrac><mi>∂</mi> <mrow><mi>∂</mi><msub><mi>θ</mi> <mi>n</mi></msub></mrow></mfrac> <mtext>MSE</mtext> <mrow><mo>(</mo> <mi mathvariant=\"bold\">θ</mi> <mo>)</mo></mrow></mrow></mtd></mtr></mtable> <mo stretchy=\"true\">)</mo></mrow> <mo>=</mo> <mstyle scriptlevel=\"0\" displaystyle=\"true\"><mfrac><mn>2</mn> <mi>m</mi></mfrac></mstyle> <msup><mi mathvariant=\"bold\">X</mi> <mo>⊺</mo></msup> <mrow><mo>(</mo> <mi mathvariant=\"bold\">X</mi> <mi mathvariant=\"bold\">θ</mi> <mo>-</mo> <mi mathvariant=\"bold\">y</mi> <mo>)</mo></mrow></mrow>  ###### Warning    Notice that this formula involves calculations over the full training set **X**, at each gradient descent step! This is why the algorithm is called *batch gradient descent*: it uses the whole batch of training data at every step (actually, *full gradient descent* would probably be a better name). As a result, it is terribly slow on very large training sets (we will look at some much faster gradient descent algorithms shortly). However, gradient descent scales well with the number of features; training a linear regression model when there are hundreds of thousands of features is much faster using gradient descent than using the normal equation or SVD decomposition.    Once you have the gradient vector, which points uphill, just go in the opposite direction to go downhill. This means subtracting ∇[**θ**]MSE(**θ**) from **θ**. This is where the learning rate *η* comes into play:⁠^([4](ch04.html#id1483)) multiply the gradient vector by *η* to determine the size of the downhill step ([Equation 4-8](#gradient_descent_step)).    ##### Equation 4-8\\. Gradient descent step  <msup><mi mathvariant=\"bold\">θ</mi><mrow><mo>(</mo><mtext>next step</mtext><mo>)</mo></mrow></msup><mo>=</mo><mi mathvariant=\"bold\">θ</mi><mo>-</mo><mi>η</mi><msub><mo>∇</mo><mi mathvariant=\"bold\">θ</mi></msub><mtext>MSE</mtext><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo>  Let’s look at a quick implementation of this algorithm:    ```py eta = 0.1  # learning rate n_epochs = 1000 m = len(X_b)  # number of instances  rng = np.random.default_rng(seed=42) theta = rng.standard_normal((2, 1))  # randomly initialized model parameters  for epoch in range(n_epochs):     gradients = 2 / m * X_b.T @ (X_b @ theta - y)     theta = theta - eta * gradients ```    That wasn’t too hard! Each iteration over the training set is called an *epoch*. Let’s look at the resulting `theta`:    ```py >>> theta `array([[3.69084138],`  `[3.32960458]])` ```   ``Hey, that’s exactly what the normal equation found! Gradient descent worked perfectly. But what if you had used a different learning rate (`eta`)? [Figure 4-8](#gradient_descent_plot) shows the first 20 steps of gradient descent using three different learning rates. The line at the bottom of each plot represents the random starting point, then each epoch is represented by a darker and darker line.  ![Diagram showing the first 20 steps of gradient descent with learning rates of 0.02, 0.1, and 0.5, illustrating slow convergence, optimal convergence, and divergence, respectively.](assets/hmls_0408.png)  ###### Figure 4-8\\. Gradient descent with various learning rates    On the left, the learning rate is too low: the algorithm will eventually reach the solution, but it will take a long time. In the middle, the learning rate looks pretty good: in just a few epochs, it has already converged to the solution. On the right, the learning rate is too high: the algorithm diverges, jumping all over the place and actually getting further and further away from the solution at every step.    To find a good learning rate, you can use grid search (see [Chapter 2](ch02.html#project_chapter)). However, you may want to limit the number of epochs so that grid search can eliminate models that take too long to converge.    You may wonder how to set the number of epochs. If it is too low, you will still be far away from the optimal solution when the algorithm stops; but if it is too high, you will waste time while the model parameters do not change anymore. A simple solution is to set a very large number of epochs but to interrupt the algorithm when the gradient vector becomes tiny—that is, when its norm becomes smaller than a tiny number *ε* (called the *tolerance*)—because this happens when gradient descent has (almost) reached the minimum.``  ```py`` ## Stochastic Gradient Descent    The main problem with batch gradient descent is the fact that it uses the whole training set to compute the gradients at every step, which makes it very slow when the training set is large. At the opposite extreme, *stochastic gradient descent* picks a random instance in the training set at every step and computes the gradients based only on that single instance. Obviously, working on a single instance at a time makes the algorithm much faster because it has very little data to manipulate at every iteration. It also makes it possible to train on huge training sets, since only one instance needs to be in memory at each iteration (stochastic GD can be implemented as an out-of-core algorithm; see [Chapter 1](ch01.html#landscape_chapter)).    On the other hand, due to its stochastic (i.e., random) nature, this algorithm is much less regular than batch gradient descent: instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, never settling down (see [Figure 4-9](#sgd_random_walk_diagram)). Once the algorithm stops, the final parameter values will be good, but not optimal.    When the cost function is very irregular (as in [Figure 4-6](#gradient_descent_pitfalls_diagram)), this can actually help the algorithm jump out of local minima, so stochastic gradient descent has a better chance of finding the global minimum than batch gradient descent does.    Therefore, randomness is good to escape from local optima, but bad because it means that the algorithm can never settle at the minimum. One solution to this dilemma is to gradually reduce the learning rate. The steps start out large (which helps make quick progress and escape local minima), then get smaller and smaller, allowing the algorithm to settle at the global minimum. This process is akin to *simulated annealing*, an algorithm inspired by the process in metallurgy of annealing, where molten metal is slowly cooled down. The function that determines the learning rate at each iteration is called the *learning schedule*. If the learning rate is reduced too quickly, you may get stuck in a local minimum, or even end up frozen halfway to the minimum. If the learning rate is reduced too slowly, you may jump around the minimum for a long time and end up with a suboptimal solution if you halt training too early.  ![Diagram illustrating the path of stochastic gradient descent, showing a random walk toward the minimum cost area on a contour plot.](assets/hmls_0409.png)  ###### Figure 4-9\\. With stochastic gradient descent, each training step is much faster but also much more stochastic than when using batch gradient descent    This code implements stochastic gradient descent using a simple learning schedule:    ``` n_epochs = 50 t0, t1 = 5, 50  # learning schedule hyperparameters  def learning_schedule(t):     return t0 / (t + t1)  rng = np.random.default_rng(seed=42) theta = rng.standard_normal((2, 1))  # randomly initialized model parameters  for epoch in range(n_epochs):     for iteration in range(m):         random_index = rng.integers(m)         xi = X_b[random_index : random_index + 1]         yi = y[random_index : random_index + 1]         gradients = 2 * xi.T @ (xi @ theta - yi)  # for SGD, do not divide by m         eta = learning_schedule(epoch * m + iteration)         theta = theta - eta * gradients ```py    By convention we iterate by rounds of *m* iterations; each round is called an *epoch*, as earlier. While the batch gradient descent code iterated 1,000 times through the whole training set, this code goes through the training set only 50 times and reaches a pretty good solution:    ``` >>> theta `array([[3.69826475],`  `[3.30748311]])` ```py   ```` [Figure 4-10](#sgd_plot) shows the first 20 steps of training (notice how irregular the steps are).  ![Scatter plot showing multiple linear regression lines demonstrating the first 20 steps of stochastic gradient descent, illustrating how the algorithm converges towards optimal parameters.](assets/hmls_0410.png)  ###### Figure 4-10\\. The first 20 steps of stochastic gradient descent    Note that since instances are picked randomly, some instances may be picked several times per epoch, while others may not be picked at all. If you want to be sure that the algorithm goes through every instance at each epoch, another approach is to shuffle the training set (making sure to shuffle the input features and the labels jointly), then go through it instance by instance, then shuffle it again, and so on. However, this approach is more complex, and it generally does not improve the result.    ###### Warning    When using stochastic gradient descent, the training instances must be independent and identically distributed (IID) to ensure that the parameters get pulled toward the global optimum, on average. A simple way to ensure this is to shuffle the instances during training (e.g., pick each instance randomly, or shuffle the training set at the beginning of each epoch). If you do not shuffle the instances—for example, if the instances are sorted by label—then SGD will start by optimizing for one label, then the next, and so on, and it will not settle close to the global minimum.    To perform linear regression using stochastic GD with Scikit-Learn, you can use the `SGDRegressor` class, which defaults to optimizing the MSE cost function. The following code runs for a maximum of 1,000 epochs (`max_iter`) or until the loss drops by less than 10^(–5) (`tol`) during 100 epochs (`n_iter_no_change`). It starts with a learning rate of 0.01 (`eta0`), using the default learning schedule (different from the one we used). Lastly, it does not use any regularization (`penalty=None`; more details on this shortly):    ```py from sklearn.linear_model import SGDRegressor  sgd_reg = SGDRegressor(max_iter=1000, tol=1e-5, penalty=None, eta0=0.01,                        n_iter_no_change=100, random_state=42) sgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets ```    Once again, you find a solution quite close to the one returned by the normal equation:    ```py >>> sgd_reg.intercept_, sgd_reg.coef_ `(array([3.68899733]), array([3.33054574]))` ```   ``###### Tip    All Scikit-Learn estimators can be trained using the `fit()` method, but some estimators also have a `partial_fit()` method that you can call to run a single round of training on one or more instances (it ignores hyperparameters like `max_iter` or `tol`). Repeatedly calling `partial_fit()` will gradually train the model. This is useful when you need more control over the training process. Other models have a `warm_start` hyperparameter instead (and some have both): if you set `warm_start=True`, calling the `fit()` method on a trained model will not reset the model; it will just continue training where it left off, respecting hyperparameters like `max_iter` and `tol`. Note that `fit()` resets the iteration counter used by the learning schedule, while `partial_fit()` does not.`` ```py`  ``` ``## Mini-Batch Gradient Descent    The last gradient descent algorithm we will look at is called *mini-batch gradient descent*. It is straightforward once you know batch and stochastic gradient descent: at each step, instead of computing the gradients based on the full training set (as in batch GD) or based on just one instance (as in stochastic GD), mini-batch GD computes the gradients on small random sets of instances called *mini-batches*. The main advantage of mini-batch GD over stochastic GD is that you can get a performance boost from hardware acceleration of matrix operations, especially when using *graphical processing units* (GPUs).    The algorithm’s progress in parameter space is less erratic than with stochastic GD, especially with fairly large mini-batches. As a result, mini-batch GD will end up walking around a bit closer to the minimum than stochastic GD—but it may be harder for it to escape from local minima (in the case of problems that suffer from local minima, unlike linear regression with the MSE cost function). [Figure 4-11](#gradient_descent_paths_plot) shows the paths taken by the three gradient descent algorithms in parameter space during training. They all end up near the minimum, but batch GD’s path actually stops at the minimum, while both stochastic GD and mini-batch GD continue to walk around. However, don’t forget that batch GD takes a lot of time to take each step, and stochastic GD and mini-batch GD would also reach the minimum if you used a good learning schedule.  ![Diagram showing the paths of stochastic, mini-batch, and batch gradient descent algorithms in parameter space, illustrating their different approaches to convergence near the minimum.](assets/hmls_0411.png)  ###### Figure 4-11\\. Gradient descent paths in parameter space    [Table 4-1](#linear_regression_algorithm_comparison) compares the algorithms we’ve discussed so far for linear regression⁠^([5](ch04.html#id1509)) (recall that *m* is the number of training instances and *n* is the number of features).      Table 4-1\\. Comparison of algorithms for linear regression   | Algorithm | Large *m* | Out-of-core support | Large *n* | Hyperparams | Scaling required | Scikit-Learn | | --- | --- | --- | --- | --- | --- | --- | | Normal equation | Fast | No | Slow | 0 | No | N/A | | SVD | Fast | No | Slow | 0 | No | `LinearRegression` | | Batch GD | Slow | No | Fast | 2 | Yes | N/A | | Stochastic GD | Fast | Yes | Fast | ≥2 | Yes | `SGDRegressor` | | Mini-batch GD | Fast | Yes | Fast | ≥2 | Yes | N/A |    There is almost no difference after training: all these algorithms end up with very similar models and make predictions in exactly the same way.`` ```py `````  ```py``````", "```````py` ``````py```````", "```` ```py````", "```py```", "``` # Polynomial Regression    What if your data is more complex than a straight line? Surprisingly, you can use a linear model to fit nonlinear data. A simple way to do this is to add powers of each feature as new features, then train a linear model on this extended set of features. This technique is called *polynomial regression*.    Let’s look at an example. First, we’ll generate some nonlinear data (see [Figure 4-12](#quadratic_data_plot)), based on a simple *quadratic equation*—that’s an equation of the form *y* = *ax*² + *bx* + *c*—plus some noise:    ```", "```  ![Scatter plot of a nonlinear and noisy dataset showing a quadratic pattern, illustrating why a straight line wouldn't fit well.](assets/hmls_0412.png)  ###### Figure 4-12\\. Generated nonlinear and noisy dataset    Clearly, a straight line will never fit this data properly. So let’s use Scikit-Learn’s `PolynomialFeatures` class to transform our training data, adding the square (second-degree polynomial) of each feature in the training set as a new feature (in this case there is just one feature):    ```", "````` `>>>` `X_poly` `=` `poly_features``.``fit_transform``(``X``)` ```py` `>>>` `X``[``0``]` ``` `array([1.64373629])` `>>>` `X_poly``[``0``]` `` `array([1.64373629, 2.701869  ])` `` ```py ```` ```py`` ```   ```py```` ```py``` `````", "```py >>> lin_reg = LinearRegression() `>>>` `lin_reg``.``fit``(``X_poly``,` `y``)` ```", "```py ```", "```py` ```", "```py ```", "```py`` ```", "```py ```", "```py`  ```", "```py```", "````py`` ````", "```````py` ``````py```````", "``` from sklearn.model_selection import learning_curve  train_sizes, train_scores, valid_scores = learning_curve(     LinearRegression(), X, y, train_sizes=np.linspace(0.01, 1.0, 40), cv=5,     scoring=\"neg_root_mean_squared_error\") train_errors = -train_scores.mean(axis=1) valid_errors = -valid_scores.mean(axis=1)  plt.plot(train_sizes, train_errors, \"r-+\", linewidth=2, label=\"train\") plt.plot(train_sizes, valid_errors, \"b-\", linewidth=3, label=\"valid\") [...]  # beautify the figure: add labels, axis, grid, and legend plt.show() ```", "``` from sklearn.pipeline import make_pipeline  polynomial_regression = make_pipeline(     PolynomialFeatures(degree=10, include_bias=False),     LinearRegression())  train_sizes, train_scores, valid_scores = learning_curve(     polynomial_regression, X, y, train_sizes=np.linspace(0.01, 1.0, 40), cv=5,     scoring=\"neg_root_mean_squared_error\") [...]  # same as earlier ```", "``` >>> from sklearn.linear_model import Ridge `>>>` `ridge_reg` `=` `Ridge``(``alpha``=``0.1``,` `solver``=``\"cholesky\"``)` ```", "``` `>>>` `ridge_reg``.``predict``([[``1.5``]])` `` `array([1.84414523])` `` ```", "```` ```py   ````", "``````py` ``````", "``` >>> sgd_reg = SGDRegressor(penalty=\"l2\", alpha=0.1 / m, tol=None, `... `                       `max_iter``=``1000``,` `eta0``=``0.01``,` `random_state``=``42``)` ```", "```` `>>>` `sgd_reg``.``fit``(``X``,` `y``.``ravel``())`  `# y.ravel() because fit() expects 1D targets` ```py `>>>` `sgd_reg``.``predict``([[``1.5``]])` `` `array([1.83659707])` `` ``` ```py` ````", "```py   ```", "```py ``The `penalty` hyperparameter sets the type of regularization term to use. Specifying `\"l2\"` indicates that you want SGD to add a regularization term to the MSE cost function equal to `alpha` times the square of the ℓ[2] norm of the weight vector. This is just like ridge regression, except there’s no division by *m* in this case; that’s why we passed `alpha=0.1 / m`, to get the same result as `Ridge(alpha=0.1)`.    ###### Tip    The `RidgeCV` class also performs ridge regression, but it automatically tunes hyperparameters using cross-validation. It’s roughly equivalent to using `GridSearchCV`, but it’s optimized for ridge regression and runs *much* faster. Several other estimators (mostly linear) also have efficient CV variants, such as `LassoCV` and `ElasticNetCV`.`` ```", "```py` ```", "```py ```", "```py` ```", "```py``  ```", "```py```", "``` ```", "```````py` ``````py```` ## Lasso Regression    *Least absolute shrinkage and selection operator regression* (usually simply called *lasso regression*) is another regularized version of linear regression: just like ridge regression, it adds a regularization term to the cost function, but it uses the ℓ[1] norm of the weight vector instead of the square of the ℓ[2] norm (see [Equation 4-11](#lasso_cost_function)). Notice that the ℓ[1] norm is multiplied by 2*α*, whereas the ℓ[2] norm was multiplied by *α* / *m* in ridge regression. These factors were chosen to ensure that the optimal *α* value is independent from the training set size: different norms lead to different factors (see [Scikit-Learn issue #15657](https://github.com/scikit-learn/scikit-learn/issues/15657) for more details).    ##### Equation 4-11\\. Lasso regression cost function  <mrow><mi>J</mi><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo></mrow><mo>=</mo><mrow><mtext>MSE</mtext><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo></mrow><mo>+</mo><mrow><mn>2</mn><mi>α</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfenced open=\"|\" close=\"|\"><msub><mi>θ</mi><mi>i</mi></msub></mfenced></mrow>  [Figure 4-19](#lasso_regression_plot) shows the same thing as [Figure 4-18](#ridge_regression_plot) but replaces the ridge models with lasso models and uses different *α* values.    An important characteristic of lasso regression is that it tends to eliminate the weights of the least important features (i.e., set them to zero). For example, the dashed line in the righthand plot in [Figure 4-19](#lasso_regression_plot) (with *α* = 0.01) looks roughly cubic: all the weights for the high-degree polynomial features are equal to zero. In other words, lasso regression automatically performs feature selection and outputs a *sparse model* with few nonzero feature weights. Of course, there’s a trade-off: if you increase *α* too much, the model will be very sparse, but its performance will plummet.  ![Plots showing linear (left) and polynomial (right) models using lasso regression with different α values, illustrating varying levels of regularization.](assets/hmls_0419.png)  ###### Figure 4-19\\. Linear (left) and polynomial (right) models, both using various levels of lasso regularization    You can get a sense of why the ℓ[1] norm induces sparsity by looking at [Figure 4-20](#lasso_vs_ridge_plot): the axes represent two model parameters, and the background contours represent different loss functions. In the top-left plot, the contours represent the ℓ[1] loss (|*θ*[1]| + |*θ*[2]|), which drops linearly as you get closer to any axis. For example, if you initialize the model parameters to *θ*[1] = 2 and *θ*[2] = 0.5, running gradient descent will decrement both parameters equally (as represented by the dashed yellow line); therefore *θ*[2] will reach 0 first (since it was closer to 0 to begin with). After that, gradient descent will roll down the gutter until it reaches *θ*[1] = 0 (with a bit of bouncing around, since the gradients of ℓ[1] never get close to 0: they are either –1 or 1 for each parameter). In the top-right plot, the contours represent lasso regression’s cost function (i.e., an MSE cost function plus an ℓ[1] loss). The small white circles show the path that gradient descent takes to optimize some model parameters that were initialized around *θ*[1] = 0.25 and *θ*[2] = –1: notice again how the path quickly reaches *θ*[2] = 0, then rolls down the gutter and ends up bouncing around the global optimum (represented by the red square). If we increased *α*, the global optimum would move left along the dashed yellow line, while if we decreased *α*, the global optimum would move right (in this example, the optimal parameters for the unregularized MSE are *θ*[1] = 2 and *θ*[2] = 0.5).    The two bottom plots show the same thing but with an ℓ[2] penalty instead. In the bottom-left plot, you can see that the ℓ[2] loss decreases as we get closer to the origin, so gradient descent just takes a straight path toward that point. In the bottom-right plot, the contours represent ridge regression’s cost function (i.e., an MSE cost function plus an ℓ[2] loss). As you can see, the gradients get smaller as the parameters approach the global optimum, so gradient descent naturally slows down. This limits the bouncing around, which helps ridge converge faster than lasso regression. Also note that the optimal parameters (represented by the red square) get closer and closer to the origin when you increase *α*, but they never get eliminated entirely.  ![Diagram comparing lasso and ridge regularization techniques, showing the paths of gradient descent in ℓ~1~ and ℓ~2~ penalty spaces, and illustrating how lasso encourages sparsity by reaching parameter zero faster.](assets/hmls_0420.png)  ###### Figure 4-20\\. Lasso versus ridge regularization    ###### Tip    To keep gradient descent from bouncing around the optimum at the end when using lasso regression, you need to gradually reduce the learning rate during training. It will still bounce around the optimum, but the steps will get smaller and smaller, so it will converge.    The lasso cost function is not differentiable at *θ*[*i*] = 0 (for *i* = 1, 2, ⋯, *n*), but gradient descent still works if you use a *subgradient vector* **g**⁠^([12](ch04.html#id1564)) instead when any *θ*[*i*] = 0\\. [Equation 4-12](#lasso_subgradient_vector) shows a subgradient vector equation you can use for gradient descent with the lasso cost function.    ##### Equation 4-12\\. Lasso regression subgradient vector  <mrow><mi>g</mi><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo></mrow><mo>=</mo><mrow><msub><mo>∇</mo><mi mathvariant=\"bold\">θ</mi></msub><mtext>MSE</mtext><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo></mrow><mo>+</mo><mrow><mn>2</mn><mi>α</mi><mfenced><mtable><mtr><mtd><mtext>sign</mtext><mo>(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo>)</mo></mtd></mtr><mtr><mtd><mtext>sign</mtext><mo>(</mo><msub><mi>θ</mi><mn>2</mn></msub><mo>)</mo></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mtext>sign</mtext><mo>(</mo><msub><mi>θ</mi><mi>n</mi></msub><mo>)</mo></mtd></mtr></mtable></mfenced></mrow><mtext>where </mtext><mrow><mtext>sign</mtext><mo>(</mo><msub><mi>θ</mi><mi>i</mi></msub><mo>)</mo></mrow><mo>=</mo><mrow><mfenced open=\"{\" close=\"\"><mtable><mtr><mtd><mo>-</mo><mn>1</mn></mtd><mtd><mtext>if </mtext><msub><mi>θ</mi><mi>i</mi></msub><mo><</mo><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mtext>if </mtext><msub><mi>θ</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd><mo>+</mo><mn>1</mn></mtd><mtd><mtext>if </mtext><msub><mi>θ</mi><mi>i</mi></msub><mo>></mo><mn>0</mn></mtd></mtr></mtable></mfenced></mrow>  Here is a small Scikit-Learn example using the `Lasso` class:    ```py >>> from sklearn.linear_model import Lasso `>>>` `lasso_reg` `=` `Lasso``(``alpha``=``0.1``)` ```` `>>>` `lasso_reg``.``fit``(``X``,` `y``)` ```py `>>>` `lasso_reg``.``predict``([[``1.5``]])` `` `array([1.87550211])` `` ``` ```py` ```   ```py` ``` ``Note that you could instead use `SGDRegressor(penalty=\"l1\", alpha=0.1)`.`` ```py ````  ```py`````` ```py````` ```py```` ## Elastic Net Regression    *Elastic net regression* is a middle ground between ridge regression and lasso regression. The regularization term is a weighted sum of both ridge and lasso’s regularization terms, and you can control the mix ratio *r*. When *r* = 0, elastic net is equivalent to ridge regression, and when *r* = 1, it is equivalent to lasso regression ([Equation 4-13](#elastic_net_cost_function)).    ##### Equation 4-13\\. Elastic net cost function  <mrow><mi>J</mi><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo></mrow><mo>=</mo><mrow><mtext>MSE</mtext><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo></mrow><mo>+</mo><mi>r</mi><mfenced><mrow><mn>2</mn><mi>α</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfenced open=\"|\" close=\"|\"><msub><mi>θ</mi><mi>i</mi></msub></mfenced></mrow></mfenced><mo>+</mo><mo>(</mo><mn>1</mn><mo>-</mo><mi>r</mi><mo>)</mo><mfenced><mrow><mfrac><mi>α</mi><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>θ</mi><mi>i</mi><mn>2</mn></msubsup></mrow></mfenced>  So when should you use elastic net regression, or ridge, lasso, or plain linear regression (i.e., without any regularization)? It is almost always preferable to have at least a little bit of regularization, so generally you should avoid plain linear regression. Ridge is a good default, but if you suspect that only a few features are useful, you should prefer lasso or elastic net because they tend to reduce the useless features’ weights down to zero, as discussed earlier. In general, elastic net is preferred over lasso because lasso may behave erratically when the number of features is greater than the number of training instances or when several features are strongly correlated.    Here is a short example that uses Scikit-Learn’s `ElasticNet` (`l1_ratio` corresponds to the mix ratio *r*):    ```py >>> from sklearn.linear_model import ElasticNet `>>>` `elastic_net` `=` `ElasticNet``(``alpha``=``0.1``,` `l1_ratio``=``0.5``)` ```` `>>>` `elastic_net``.``fit``(``X``,` `y``)` ```py `>>>` `elastic_net``.``predict``([[``1.5``]])` `` `array([1.8645014])` `` ``` ```py` ```   ```py``` ````` ```py`## Early Stopping    A different way to regularize iterative learning algorithms such as gradient descent is to stop training as soon as the validation error reaches a minimum. This popular technique is called *early stopping*. [Figure 4-21](#early_stopping_plot) shows a complex model (in this case, a high-degree polynomial regression model) being trained with batch gradient descent on the quadratic dataset we used earlier. As the epochs go by, the algorithm learns, and its prediction error (RMSE) on the training set goes down, along with its prediction error on the validation set. After a while, though, the validation error stops decreasing and starts to go back up. This indicates that the model has started to overfit the training data. With early stopping you just stop training as soon as the validation error reaches the minimum. It is such a simple and efficient regularization technique that Geoffrey Hinton called it a “beautiful free lunch”.⁠^([13](ch04.html#id1576)) That said, the validation error sometimes comes back down after a while: this is called *double descent*. It’s fairly common with large neural networks, and is an area of active research.  ![Graph illustrating early stopping regularization with RMSE on the y-axis and epochs on the x-axis; the validation error is shown to increase after reaching the minimum, marked as the \"Best model.\"](assets/hmls_0421.png)  ###### Figure 4-21\\. Early stopping regularization    ###### Tip    With stochastic and mini-batch gradient descent, the curves are not so smooth, and it may be hard to know whether you have reached the minimum or not. One solution is to stop only after the validation error has been above the minimum for some time (when you are confident that the model will not do any better), then roll back the model parameters to the point where the validation error was at a minimum.    Here is a basic implementation of early stopping:    ``` from copy import deepcopy from sklearn.metrics import root_mean_squared_error from sklearn.preprocessing import StandardScaler  X_train, y_train, X_valid, y_valid = [...]  # split the quadratic dataset  preprocessing = make_pipeline(PolynomialFeatures(degree=90, include_bias=False),                               StandardScaler()) X_train_prep = preprocessing.fit_transform(X_train) X_valid_prep = preprocessing.transform(X_valid) sgd_reg = SGDRegressor(penalty=None, eta0=0.002, random_state=42) n_epochs = 500 best_valid_rmse = float('inf')  for epoch in range(n_epochs):     sgd_reg.partial_fit(X_train_prep, y_train)     y_valid_predict = sgd_reg.predict(X_valid_prep)     val_error = root_mean_squared_error(y_valid, y_valid_predict)     if val_error < best_valid_rmse:         best_valid_rmse = val_error         best_model = deepcopy(sgd_reg) ```py    This code first adds the polynomial features and scales all the input features, both for the training set and for the validation set (the code assumes that you have split the original training set into a smaller training set and a validation set). Then it creates an `SGDRegressor` model with no regularization and a small learning rate. In the training loop, it calls `partial_fit()` instead of `fit()`, to perform incremental learning. At each epoch, it measures the RMSE on the validation set. If it is lower than the lowest RMSE seen so far, it saves a copy of the model in the `best_model` variable. This implementation does not actually stop training, but it lets you revert to the best model after training. Note that the model is copied using `copy.deepcopy()`, because it copies both the model’s hyperparameters *and* the learned parameters. In contrast, `sklearn.base.clone()` only copies the model’s hyperparameters.```` ```py`` ``````py ``````py` ``````py`` ``````py``` ``````py```` ```py```````", "``````py``````", "```py```", "``` ```", "````` ```py```` # Logistic Regression    As discussed in [Chapter 1](ch01.html#landscape_chapter), some regression algorithms can be used for classification (and vice versa). *Logistic regression* (also called *logit regression*) is commonly used to estimate the probability that an instance belongs to a particular class (e.g., what is the probability that this email is spam?). If the estimated probability is greater than a given threshold (typically 50%), then the model predicts that the instance belongs to that class (called the *positive class*, labeled “1”), and otherwise it predicts that it does not (i.e., it belongs to the *negative class*, labeled “0”). This makes it a binary classifier.    ## Estimating Probabilities    So how does logistic regression work? Just like a linear regression model, a logistic regression model computes a weighted sum of the input features (plus a bias term), but instead of outputting the result directly like the linear regression model does, it outputs the *logistic* of this result (see [Equation 4-14](#logisticregression_model_estimated_probability_vectorized_form)).    ##### Equation 4-14\\. Logistic regression model estimated probability (vectorized form)  <mrow><mover accent=\"true\"><mi>p</mi> <mo>^</mo></mover> <mo>=</mo> <msub><mi>h</mi> <mi mathvariant=\"bold\">θ</mi></msub> <mrow><mo>(</mo> <mi mathvariant=\"bold\">x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo> <msup><mi mathvariant=\"bold\">θ</mi> <mo>⊺</mo></msup> <mi mathvariant=\"bold\">x</mi> <mo>)</mo></mrow></mrow>  The logistic—denoted *σ*(·)—is a *sigmoid function* (i.e., *S*-shaped) that outputs a number between 0 and 1\\. It is defined as shown in [Equation 4-15](#equation_four_fourteen) and [Figure 4-22](#logistic_function_plot).    ##### Equation 4-15\\. Logistic function  <mrow><mi>σ</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel=\"0\" displaystyle=\"true\"><mfrac><mn>1</mn> <mrow><mn>1</mn><mo>+</mo><mo form=\"prefix\">exp</mo><mo>(</mo><mo lspace=\"0%\" rspace=\"0%\">-</mo><mi>t</mi><mo>)</mo></mrow></mfrac></mstyle></mrow>![Graph illustrating the logistic function, showing an S-shaped curve that rises from 0 to 1 as the input value increases.](assets/hmls_0422.png)  ###### Figure 4-22\\. Logistic function    Once the logistic regression model has estimated the probability <mover><mi>p</mi><mo>^</mo></mover> = *h*[**θ**](**x**) that an instance **x** belongs to the positive class, it can make its prediction *ŷ* easily (see [Equation 4-16](#equation_four_fifteen)).    ##### Equation 4-16\\. Logistic regression model prediction using a 50% threshold probability  <mrow><mover accent=\"true\"><mi>y</mi> <mo>^</mo></mover> <mo>=</mo> <mfenced separators=\"\" open=\"{\" close=\"\"><mtable><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd> <mtd columnalign=\"left\"><mrow><mtext>if</mtext> <mover accent=\"true\"><mi>p</mi> <mo>^</mo></mover> <mo><</mo> <mn>0.5</mn></mrow></mtd></mtr> <mtr><mtd columnalign=\"left\"><mn>1</mn></mtd> <mtd columnalign=\"left\"><mrow><mtext>if</mtext> <mover accent=\"true\"><mi>p</mi> <mo>^</mo></mover> <mo>≥</mo> <mn>0.5</mn></mrow></mtd></mtr></mtable></mfenced></mrow>  Notice that *σ*(*t*) < 0.5 when *t* < 0, and *σ*(*t*) ≥ 0.5 when *t* ≥ 0, so a logistic regression model using the default threshold of 50% probability predicts 1 if **θ**^⊺ **x** is positive and 0 if it is negative.    ###### Note    The score *t* is often called the *logit*. The name comes from the fact that the logit function, defined as logit(*p*) = log(*p* / (1 – *p*)), is the inverse of the logistic function. Indeed, if you compute the logit of the estimated probability *p*, you will find that the result is *t*. The logit is also called the *log-odds*, since it is the log of the ratio between the estimated probability for the positive class and the estimated probability for the negative class.    ## Training and Cost Function    Now you know how a logistic regression model estimates probabilities and makes predictions. But how is it trained? The objective of training is to set the parameter vector **θ** so that the model estimates high probabilities for positive instances (*y* = 1) and low probabilities for negative instances (*y* = 0). This idea is captured by the cost function shown in [Equation 4-17](#cost_function_of_a_single_training_instance) for a single training instance **x**.    ##### Equation 4-17\\. Cost function of a single training instance  <mrow><mi>c</mi><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo></mrow><mo>=</mo><mrow><mfenced open=\"{\" close=\"\"><mtable><mtr><mtd><mo>-</mo><mi>log</mi><mo>(</mo><mover accent=\"true\"><mi>p</mi><mo>^</mo></mover><mo>)</mo></mtd><mtd><mtext>if </mtext><mi>y</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd><mo>-</mo><mi>log</mi><mo>(</mo><mn>1</mn><mo>-</mo><mover accent=\"true\"><mi>p</mi><mo>^</mo></mover><mo>)</mo></mtd><mtd><mtext>if </mtext><mi>y</mi><mo>=</mo><mn>0</mn></mtd></mtr></mtable></mfenced></mrow>  This cost function makes sense because –log(*t*) grows very large when *t* approaches 0, so the cost will be large if the model estimates a probability close to 0 for a positive instance, and it will also be large if the model estimates a probability close to 1 for a negative instance. On the other hand, –log(*t*) is close to 0 when *t* is close to 1, so the cost will be close to 0 if the estimated probability is close to 0 for a negative instance or close to 1 for a positive instance, which is precisely what we want.    The cost function over the whole training set is the average cost over all training instances. It can be written in a single expression called the *log loss*, shown in [Equation 4-18](#logistic_regression_cost_function).    ##### Equation 4-18\\. Logistic regression cost function (log loss)  <mrow><mi>J</mi><mo>(</mo><mi mathvariant=\"bold\">θ</mi><mo>)</mo></mrow><mo>=</mo><mrow><mo>-</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mfenced open=\"[\" close=\"]\"><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup><mi>l</mi><mi>o</mi><mi>g</mi><mfenced><msup><mover accent=\"true\"><mi>p</mi><mo>^</mo></mover><mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></mfenced><mo>+</mo><mo>(</mo><mn>1</mn><mo>-</mo><msup><mi>y</mi><mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup><mo>)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfenced><mrow><mn>1</mn><mo>-</mo><msup><mover accent=\"true\"><mi>p</mi><mo>^</mo></mover><mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></mrow></mfenced></mrow></mfenced></mrow>  ###### Warning    The log loss was not just pulled out of a hat. It can be shown mathematically (using Bayesian inference) that minimizing this loss will result in the model with the *maximum likelihood* of being optimal, assuming that the instances follow a Gaussian distribution around the mean of their class. When you use the log loss, this is the implicit assumption you are making. The more wrong this assumption is, the more biased the model will be. Similarly, when we used the MSE to train linear regression models, we were implicitly assuming that the data was purely linear, plus some Gaussian noise. So, if the data is not linear (e.g., if it’s quadratic) or if the noise is not Gaussian (e.g., if outliers are not exponentially rare), then the model will be biased.    The bad news is that there is no known closed-form equation to compute the value of **θ** that minimizes this cost function (there is no equivalent of the normal equation). But the good news is that this cost function is convex, so gradient descent (or any other optimization algorithm) is guaranteed to find the global minimum (if the learning rate is not too large and you wait long enough). The partial derivatives of the cost function with regard to the *j*^(th) model parameter *θ*[*j*] are given by [Equation 4-19](#logistic_cost_function_partial_derivatives).    ##### Equation 4-19\\. Logistic cost function partial derivatives  <mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mfrac><mi>∂</mi> <mrow><mi>∂</mi><msub><mi>θ</mi> <mi>j</mi></msub></mrow></mfrac></mstyle> <mtext>J</mtext> <mrow><mo>(</mo> <mi mathvariant=\"bold\">θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel=\"0\" displaystyle=\"true\"><mfrac><mn>1</mn> <mi>m</mi></mfrac></mstyle> <munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>m</mi></munderover> <mfenced separators=\"\" open=\"(\" close=\")\"><mi>σ</mi> <mrow><mo>(</mo> <msup><mi mathvariant=\"bold\">θ</mi> <mo>⊺</mo></msup> <msup><mi mathvariant=\"bold\">x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>-</mo> <msup><mi>y</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></mfenced> <msubsup><mi>x</mi> <mi>j</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></mrow>  This equation looks very much like [Equation 4-6](#mse_partial_derivatives): for each instance it computes the prediction error and multiplies it by the *j*^(th) feature value, and then it computes the average over all training instances. Once you have the gradient vector containing all the partial derivatives, you can use it in the batch gradient descent algorithm. That’s it: you now know how to train a logistic regression model. For stochastic GD you would take one instance at a time, and for mini-batch GD you would use a mini-batch at a time.    ## Decision Boundaries    We can use the iris dataset to illustrate logistic regression. This is a famous dataset that contains the sepal and petal length and width of 150 iris flowers of three different species: *Iris setosa*, *Iris versicolor*, and *Iris virginica* (see [Figure 4-23](#iris_dataset_diagram)).  ![Photographs of three iris species: _Iris virginica_, _Iris versicolor_, and _Iris setosa_, demonstrating petal and sepal features.](assets/hmls_0423.png)  ###### Figure 4-23\\. Flowers of three iris plant species⁠^([14](ch04.html#id1611))    Let’s try to build a classifier to detect the *Iris virginica* type based only on the petal width feature. The first step is to load the data and take a quick peek:    ```py >>> from sklearn.datasets import load_iris `>>>` `iris` `=` `load_iris``(``as_frame``=``True``)` `````", "````` `['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names',`  `'filename', 'data_module']` `>>>` `iris``.``data``.``head``(``3``)` ```py` `sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)` `0                5.1               3.5                1.4               0.2` `1                4.9               3.0                1.4               0.2` `2                4.7               3.2                1.3               0.2` `>>>` `iris``.``target``.``head``(``3``)`  `# note that the instances are not shuffled` ``` `0    0` `1    0` `2    0` `Name: target, dtype: int64` `>>>` `iris``.``target_names` `` `array(['setosa', 'versicolor', 'virginica'], dtype='<U10')` `` ```py ```` ```py`` `````", "```   ```", "``` ```", "```py` Next we’ll split the data and train a logistic regression model on the training set:    ```", "```py    Let’s look at the model’s estimated probabilities for flowers with petal widths varying from 0 cm to 3 cm ([Figure 4-24](#logistic_regression_plot)):⁠^([15](ch04.html#id1612))    ```", "```py  ![Graph showing estimated probabilities of a classifier predicting _Iris virginica_ versus not _Iris virginica_ based on petal width, with a decision boundary at 1.6 cm where probabilities are equal.](assets/hmls_0424.png)  ###### Figure 4-24\\. Estimated probabilities and decision boundary    The petal width of *Iris virginica* flowers (represented as triangles) ranges from 1.4 cm to 2.5 cm, while the other iris flowers (represented by squares) generally have a smaller petal width, ranging from 0.1 cm to 1.8 cm. Notice that there is a bit of overlap. Above about 2 cm the classifier is highly confident that the flower is an *Iris virginica* (it outputs a high probability for that class), while below 1 cm it is highly confident that it is not an *Iris virginica* (high probability for the “Not Iris virginica” class). In between these extremes, the classifier is unsure. However, if you ask it to predict the class (using the `predict()` method rather than the `predict_proba()` method), it will return whichever class is the most likely. Therefore, there is a *decision boundary* at around 1.6 cm where both probabilities are equal to 50%: if the petal width is greater than 1.6 cm the classifier will predict that the flower is an *Iris virginica*, and otherwise it will predict that it is not (even if it is not very confident):    ```", "```py   ```", "```py ```", "```py`` ```", "```py  ```", "```py ```", "```py` ## Softmax Regression    The logistic regression model can be generalized to support multiple classes directly, without having to train and combine multiple binary classifiers (as discussed in [Chapter 3](ch03.html#classification_chapter)). This is called *softmax regression*, or *multinomial logistic regression*.    The idea is simple: when given an instance **x**, the softmax regression model first computes a score *s*[*k*](**x**) for each class *k*, then estimates the probability of each class by applying the *softmax function* (also called the *normalized exponential*) to the scores. The equation to compute *s*[*k*](**x**) should look familiar, as it is just like the equation for linear regression prediction (see [Equation 4-20](#softmax_score_for_class_k)).    ##### Equation 4-20\\. Softmax score for class k  <mrow><msub><mi>s</mi> <mi>k</mi></msub> <mrow><mo>(</mo> <mi mathvariant=\"bold\">x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mi mathvariant=\"bold\">θ</mi> <mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>⊺</mo></msup> <mi mathvariant=\"bold\">x</mi></mrow>  Note that each class has its own dedicated parameter vector **θ**^((*k*)). All these vectors are typically stored as rows in a *parameter matrix* **Θ**.    Once you have computed the score of every class for the instance **x**, you can estimate the probability <msub><mover><mi>p</mi><mo>^</mo></mover><mi>k</mi></msub> that the instance belongs to class *k* by running the scores through the softmax function ([Equation 4-21](#softmax_function)). The function computes the exponential of every score, then normalizes them (dividing by the sum of all the exponentials). The scores are generally called logits or log-odds (although they are actually unnormalized log-odds).    ##### Equation 4-21\\. Softmax function  <mrow><msub><mover accent=\"true\"><mi>p</mi> <mo>^</mo></mover> <mi>k</mi></msub> <mo>=</mo> <mi>σ</mi> <msub><mfenced separators=\"\" open=\"(\" close=\")\"><mi mathvariant=\"bold\">s</mi><mo>(</mo><mi mathvariant=\"bold\">x</mi><mo>)</mo></mfenced> <mi>k</mi></msub> <mo>=</mo> <mstyle scriptlevel=\"0\" displaystyle=\"true\"><mfrac><mrow><mtext>exp</mtext><mfenced separators=\"\" open=\"(\" close=\")\"><msub><mi>s</mi> <mi>k</mi></msub> <mrow><mo>(</mo><mi mathvariant=\"bold\">x</mi><mo>)</mo></mrow></mfenced></mrow> <mrow><munderover><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>K</mi></munderover> <mrow><mtext>exp</mtext><mfenced separators=\"\" open=\"(\" close=\")\"><msub><mi>s</mi> <mi>j</mi></msub> <mrow><mo>(</mo><mi mathvariant=\"bold\">x</mi><mo>)</mo></mrow></mfenced></mrow></mrow></mfrac></mstyle></mrow>  In this equation:    *   *K* is the number of classes.           *   **s**(**x**) is a vector containing the scores of each class for the instance **x**.           *   *σ*(**s**(**x**))[*k*] is the estimated probability that the instance **x** belongs to class *k*, given the scores of each class for that instance.              Just like the logistic regression classifier, by default the softmax regression classifier predicts the class with the highest estimated probability (which is simply the class with the highest score), as shown in [Equation 4-22](#softmax_regression_classifier_prediction).    ##### Equation 4-22\\. Softmax regression classifier prediction  <mrow><mover accent=\"true\"><mi>y</mi> <mo>^</mo></mover> <mo>=</mo> <munder><mo form=\"prefix\">argmax</mo> <mi>k</mi></munder> <mi>σ</mi> <msub><mfenced separators=\"\" open=\"(\" close=\")\"><mi mathvariant=\"bold\">s</mi><mo>(</mo><mi mathvariant=\"bold\">x</mi><mo>)</mo></mfenced> <mi>k</mi></msub> <mo>=</mo> <munder><mo form=\"prefix\">argmax</mo> <mi>k</mi></munder> <msub><mi>s</mi> <mi>k</mi></msub> <mrow><mo>(</mo> <mi mathvariant=\"bold\">x</mi> <mo>)</mo></mrow> <mo>=</mo> <munder><mo form=\"prefix\">argmax</mo> <mi>k</mi></munder> <mfenced separators=\"\" open=\"(\" close=\")\"><msup><mrow><mo>(</mo><msup><mi mathvariant=\"bold\">θ</mi> <mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msup> <mo>)</mo></mrow> <mo>⊺</mo></msup> <mi mathvariant=\"bold\">x</mi></mfenced></mrow>  The *argmax* operator returns the value of a variable that maximizes a function. In this equation, it returns the value of *k* that maximizes the estimated probability *σ*(**s**(**x**))[*k*].    ###### Tip    The softmax regression classifier predicts only one class at a time (i.e., it is multiclass, not multioutput), so it should be used only with mutually exclusive classes, such as different species of plants. You cannot use it to recognize multiple people in one picture.    Now that you know how the model estimates probabilities and makes predictions, let’s take a look at training. The objective is to have a model that estimates a high probability for the target class (and consequently a low probability for the other classes). Minimizing the cost function shown in [Equation 4-23](#cross_entropy_cost_function), called the *cross entropy*, should lead to this objective because it penalizes the model when it estimates a low probability for a target class. Cross entropy is frequently used to measure how well a set of estimated class probabilities matches the target classes.    ##### Equation 4-23\\. Cross entropy cost function  <mrow><mi>J</mi><mo>(</mo><mi mathvariant=\"bold\">Θ</mi><mo>)</mo></mrow><mo>=</mo><mrow><mo>-</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msubsup><mi>y</mi><mi>k</mi><mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup><mi>log</mi><mfenced><msubsup><mover accent=\"true\"><mi>p</mi><mo>^</mo></mover><mi>k</mi><mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></mfenced></mrow>  In this equation, <msubsup><mi>y</mi><mi>k</mi><mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> is the target probability that the *i*^(th) instance belongs to class *k*. In general, it is either equal to 1 or 0, depending on whether the instance belongs to the class or not.    Notice that when there are just two classes (*K* = 2), this cost function is equivalent to the logistic regression cost function (log loss; see [Equation 4-18](#logistic_regression_cost_function)).    The gradient vector of this cost function with regard to **θ**^((*k*)) is given by [Equation 4-24](#cross_entropy_gradient_vector_for_class_k).    ##### Equation 4-24\\. Cross entropy gradient vector for class k  <mrow><msub><mi>∇</mi> <msup><mi mathvariant=\"bold\">θ</mi> <mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msup></msub> <mi>J</mi> <mrow><mo>(</mo> <mi mathvariant=\"bold\">Θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel=\"0\" displaystyle=\"true\"><mfrac><mn>1</mn> <mi>m</mi></mfrac></mstyle> <munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>m</mi></munderover> <mrow><mrow><mo fence=\"true\" stretchy=\"true\">(</mo></mrow> <msubsup><mover accent=\"true\"><mi>p</mi> <mo>^</mo></mover> <mi>k</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mo>-</mo> <msubsup><mi>y</mi> <mi>k</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup> <mrow><mo fence=\"true\" stretchy=\"true\">)</mo></mrow> <msup><mi mathvariant=\"bold\">x</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msup></mrow></mrow>  Now you can compute the gradient vector for every class, then use gradient descent (or any other optimization algorithm) to find the parameter matrix **Θ** that minimizes the cost function.    Let’s use softmax regression to classify the iris plants into all three classes. Scikit-Learn’s `LogisticRegression` classifier uses softmax regression automatically when you train it on more than two classes (assuming you use `solver=\"lbfgs\"`, which is the default). It also applies ℓ[2] regularization by default, which you can control using the hyperparameter `C`: decrease `C` to increase regularization, as mentioned earlier.    ```", "```py    So the next time you find an iris with petals that are 5 cm long and 2 cm wide, you can ask your model to tell you what type of iris it is, and it will answer *Iris virginica* (class 2) with 96% probability (or *Iris versicolor* with 4% probability):    ```", "```py   `` `[Figure 4-26](#softmax_regression_contour_plot) shows the resulting decision boundaries, represented by the background colors. Notice that the decision boundaries between any two classes are linear. The figure also shows the probabilities for the *Iris versicolor* class, represented by the curved lines (e.g., the line labeled with 0.30 represents the 30% probability boundary). Notice that the model can predict a class that has an estimated probability below 50%. For example, at the point where all decision boundaries meet, all classes have an equal estimated probability of 33%.  ![Diagram showing the decision boundaries of softmax regression on the Iris dataset, with linear boundaries and probability contours for the Iris versicolor class.](assets/hmls_0426.png)  ###### Figure 4-26\\. Softmax regression decision boundaries    In this chapter, you learned various ways to train linear models, both for regression and for classification. You used a closed-form equation to solve linear regression, as well as gradient descent, and you learned how various penalties can be added to the cost function during training to regularize the model. Along the way, you also learned how to plot learning curves and analyze them, and how to implement early stopping. Finally, you learned how logistic regression and softmax regression work. We’ve opened up the first machine learning black boxes! In the next chapters we will open many more, starting with support vector machines.` `` ```", "```py`` ```", "```py  ```", "```py ``# Exercises    1.  Which linear regression training algorithm can you use if you have a training set with millions of features?           2.  Suppose the features in your training set have very different scales. Which algorithms might suffer from this, and how? What can you do about it?           3.  Can gradient descent get stuck in a local minimum when training a logistic regression model?           4.  Do all gradient descent algorithms lead to the same model, provided you let them run long enough?           5.  Suppose you use batch gradient descent and you plot the validation error at every epoch. If you notice that the validation error consistently goes up, what is likely going on? How can you fix this?           6.  Is it a good idea to stop mini-batch gradient descent immediately when the validation error goes up?           7.  Which gradient descent algorithm (among those we discussed) will reach the vicinity of the optimal solution the fastest? Which will actually converge? How can you make the others converge as well?           8.  Suppose you are using polynomial regression. You plot the learning curves and you notice that there is a large gap between the training error and the validation error. What is happening? What are three ways to solve this?           9.  Suppose you are using ridge regression and you notice that the training error and the validation error are almost equal and fairly high. Would you say that the model suffers from high bias or high variance? Should you increase the regularization hyperparameter *α* or reduce it?           10.  Why would you want to use:               1.  Ridge regression instead of plain linear regression (i.e., without any regularization)?                       2.  Lasso instead of ridge regression?                       3.  Elastic net instead of lasso regression?                   11.  Suppose you want to classify pictures as outdoor/indoor and daytime/nighttime. Should you implement two logistic regression classifiers or one softmax regression classifier?           12.  Implement batch gradient descent with early stopping for softmax regression without using Scikit-Learn, only NumPy. Use it on a classification task such as the iris dataset.              Solutions to these exercises are available at the end of this chapter’s notebook, at [*https://homl.info/colab-p*](https://homl.info/colab-p).    ^([1](ch04.html#id1433-marker)) A closed-form equation is only composed of a finite number of constants, variables, and standard operations: for example, *a* = sin(*b* – *c*). No infinite sums, no limits, no integrals, etc.    ^([2](ch04.html#id1475-marker)) Technically speaking, its derivative is *Lipschitz continuous*.    ^([3](ch04.html#id1476-marker)) Since feature 1 is smaller, it takes a larger change in *θ*[1] to affect the cost function, which is why the bowl is elongated along the *θ*[1] axis.    ^([4](ch04.html#id1483-marker)) Eta (*η*) is the seventh letter of the Greek alphabet.    ^([5](ch04.html#id1509-marker)) While the normal equation can only perform linear regression, the gradient descent algorithms can be used to train many other models, as you’ll see.    ^([6](ch04.html#id1524-marker)) This notion of bias is not to be confused with the bias term of linear models.    ^([7](ch04.html#id1539-marker)) Inputs are colinear when one input is equal to a linear combination of some other inputs. For example, the temperature in Celsius degrees is colinear with the temperature in Fahrenheit degrees.    ^([8](ch04.html#id1544-marker)) It is common to use the notation *J*(**θ**) for cost functions that don’t have a short name; I’ll often use this notation throughout the rest of this book. The context will make it clear which cost function is being discussed.    ^([9](ch04.html#id1545-marker)) Norms are discussed in [Chapter 2](ch02.html#project_chapter).    ^([10](ch04.html#id1552-marker)) A square matrix full of 0s except for 1s on the main diagonal (top left to bottom right).    ^([11](ch04.html#id1553-marker)) Alternatively, you can use the `Ridge` class with the `\"sag\"` solver. Stochastic average GD is a variant of stochastic GD. For more details, see the presentation [“Minimizing Finite Sums with the Stochastic Average Gradient Algorithm”](https://homl.info/12) by Mark Schmidt et al. from the University of British Columbia.    ^([12](ch04.html#id1564-marker)) You can think of a subgradient vector at a nondifferentiable point as an intermediate vector between the gradient vectors around that point.    ^([13](ch04.html#id1576-marker)) Slide #63 of the [NeurIPS 2015 Deep Learning Tutorial](https://homl.info/freelunch).    ^([14](ch04.html#id1611-marker)) Photos reproduced from the corresponding Wikipedia pages. *Iris virginica* photo by Frank Mayfield ([Creative Commons BY-SA 2.0](https://oreil.ly/O2fAq)), *Iris versicolor* photo by D. Gordon E. Robertson ([Creative Commons BY-SA 3.0](https://oreil.ly/pMbrK)), *Iris setosa* photo public domain.    ^([15](ch04.html#id1612-marker)) NumPy’s `reshape()` function allows one dimension to be –1, which means “automatic”: the value is inferred from the length of the array and the remaining dimensions.    ^([16](ch04.html#id1613-marker)) It is the set of points **x** such that *θ*[0] + *θ*[1]*x*[1] + *θ*[2]*x*[2] = 0, which defines a straight line.`` ```", "```py` ```", "```py` ```", "```py`` ```", "```py```", "``````py``````", "``````py``````", "``````py``````", "``````py``````", "``` ```", "```py```", "````py````", "```py```", "````py````", "```py` ```", "```py```", "````py````", "```py```", "````py````", "```py```", "``````py``````", "```````"]