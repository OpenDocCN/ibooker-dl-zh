<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div class="readable-text" id="p1">
<h1 class="readable-text-h"><span class="calibre22"><span class="calibre22">8</span></span> <span class="calibre22">Debugging and better understanding your code</span></h1>
</div>
<div class="readable-text">
<h3 class="introduction-header">This chapter covers</h3>
<ul class="calibre24">
<li class="readable-text1" id="p2">Determining the source of a bug</li>
<li class="readable-text1" id="p3">Fixing errors with Copilot techniques</li>
<li class="readable-text1" id="p4">Debugging code with Copilot</li>
<li class="readable-text1" id="p5">Using the VS Code debugger to see how code is functioning </li>
</ul>
</div>
<div class="readable-text" id="p6">
<p class="calibre15">There will be a point in every programmer’s career when their code isn’t doing what they want it to do. This has likely happened to you already, and, rest assured, it’s a normal part of learning to program. How do we fix the code? Sometimes, changing the prompt or better decomposing the problem like you learned in earlier chapters is sufficient to fix the problem. But what do you do when you just can’t get Copilot to give you different or better code, nor can you figure out why the code you’ve been given doesn’t work properly?</p>
</div>
<div class="readable-text" id="p7">
<p class="calibre15">This chapter serves two purposes. The primary goal is to learn how to find errors (called bugs) in the code and fix them. To find those bugs, you’ll need to fulfill the second goal, which is gaining a deeper understanding of how your code works while you’re running it.</p>
</div>
<div class="readable-text" id="p8">
<p class="calibre15">The good news is that having an error in your code is such a common occurrence for programmers that programming environments, such as Visual Studio Code (VS Code), have tools to help us uncover what’s going wrong. We’ll learn how to use that tool, called a debugger, in this chapter as well.</p>
</div>
<div class="readable-text" id="p9">
<p class="calibre15">Like the past few chapters where we started small, we’ll learn the concepts behind finding and fixing errors with some small examples, and then we’ll more authentically showcase the process by diving into a larger example that’s similar to the kind of code you’re likely to write in the future.</p>
</div>
<div class="readable-text" id="p10">
<h2 class="readable-text-h1" id="sigil_toc_id_118"><span class="calibre22">8.1</span> What causes errors (bugs)?</h2>
</div>
<div class="readable-text" id="p11">
<p class="calibre15">First up is a quick terminology lesson. Many decades ago, computers used relays or vacuum tubes rather than transistors. The story goes that Dr. Grace Hopper, while programming one of these early computers, experienced an error caused by an actual bug (a moth) in a relay. Today, we use the term bug to refer to a mistake in a program, though we’re not dealing with literal bugs anymore. Now, bugs are caused by mistakes by programmers; when we debug our code, we’re working on removing those bugs. (There can be bugs in the implementation of Python itself or even in computer hardware, but they are so rare, it’s safe to assume an error in your code is because of your code.)</p>
</div>
<div class="readable-text" id="p12">
<p class="calibre15">No one intentionally causes bugs in their code if they are genuinely trying to solve a problem. So why do bugs happen? Well, software engineers, and Copilot, make mistakes. What kind of mistakes you might ask? There are two primary categories of bugs:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p13"> <strong class="calibre17"/><em class="calibre18">Syntax errors</em>—These errors occur when the code doesn’t follow the Python syntax requirements. For example, forgetting to write a <code class="calibre25">:</code> at the end of the first line of a <code class="calibre25">for</code> loop is a syntax error. When you run Python, because it’s trying to generate machine code based on your program description, it will run into a mistake, not know what to do, and give you an error. Sometimes, these error messages are more readable than others. When people learn to program in the traditional way, without Copilot, these errors are really, really common. It takes a while to learn all the rules of Python and to make those rules a habit. Even the two of us still sometimes write code with syntax errors, despite decades of writing code. The good news is that writing code with Copilot almost entirely eliminates this problem! The bad news is that of the two types of bugs, syntax errors are the easier to find and fix. </li>
<li class="readable-text1" id="p14"> <strong class="calibre17"/><em class="calibre18">Logical errors—</em>These errors occur when there is something logically wrong with the program. For example, maybe the intent of the code is to count how many times the exact word “Dan” appears in a list of words, but the code actually counts how many words in the list contain “dan” (ignoring case) anywhere in the word. This code would be doing the wrong thing on two counts: it would count words like <em class="calibre18">dan</em> and <em class="calibre18">DAN</em> as matches even though we don’t want those to be matches, and it would find <em class="calibre18">dan</em> as any part of a word rather than the full word. That is, it would count words like <em class="calibre18">Daniel</em>, <em class="calibre18">danger</em>, and <em class="calibre18">dan</em>, even though we don’t want to count any of these! Somewhere, the code isn’t doing what it should, and we have to figure out where and why. Often, finding the logical error is the hardest part. Once we know where the mistake is, we have to fix it, and fixing these bugs can range from changing a single character to completely rewriting the code. Logical errors can happen when a prompt isn’t well described or when Copilot, for various reasons, generates the wrong code. </li>
</ul>
<div class="readable-text" id="p15">
<h2 class="readable-text-h1" id="sigil_toc_id_119"><span class="calibre22">8.2</span> How to find the bug</h2>
</div>
<div class="readable-text" id="p16">
<p class="calibre15">Finding bugs can be challenging. Fundamentally, whether you or Copilot wrote the code, you thought or Copilot “thought” the code was correct when it was written. This is why it’s often easier for a colleague to find a bug in the code rather than the author. The author can’t see the bug because they created it! </p>
</div>
<div class="readable-text" id="p17">
<p class="calibre15">Bugs aren’t new to us in this book as we’ve seen mistakes in code already, and we’ve found those errors by reading the code and/or testing. In previous chapters, we figured out the source of the bug by reading through the code. In this chapter, we’ll address the bugs that you identify when testing but can’t seem to figure out why the code is wrong. Often, you can bypass the process of figuring out why the code is wrong by trying other Copilot suggestions, using new prompts to fix the error, or asking Copilot to fix the bug for you, but in our experience, these techniques don’t always work. What we need then are more tools to help us figure out where the error is in the code.</p>
</div>
<div class="readable-text" id="p18">
<h3 class="readable-text-h2" id="sigil_toc_id_120"><span class="calibre22">8.2.1</span> Using print statements to learn about the code behavior</h3>
</div>
<div class="readable-text" id="p19">
<p class="calibre15">Fundamentally, a logical error means that there is a mismatch between what the author thought the code would do and what the code actually does. A common way to identify that mismatch is by using <code class="calibre25">print</code> statements to get insight into the behavior of the program because they tell you what the computer is actually doing. A useful practice is to print variables at various points in time to see what the values of those variables are at those points. Let’s try this for that example we just gave of looking for the word <em class="calibre18">Dan</em> in a list of words. Here’s the wrong code.</p>
</div>
<div class="browsable-container" id="p20">
<h5 class="listing-container-h"><span>Listing 8.1</span> Incorrect function for counting matching words</h5>
<div class="readable-text">
<pre class="code-area">def count_words(words):
    count = 0
    for word in words:
        if "dan" in word.lower():   <span/> #1
            count += 1
    return count</pre>
<div class="code-annotations-overlay-container">
     #1 The method lower makes the word all lowercase letters.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p21">
<p class="calibre15">You may already see what’s wrong with the code, but let’s assume we don’t know what’s going on, and we’re trying to figure out where the code went wrong. Suppose we found out that our code is wrong by running the following test case:</p>
</div>
<div class="browsable-container" id="p22">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; words = ["Dan", "danger", "Leo"]   
&gt;&gt;&gt; count_words(words)
2</pre>
</div>
</div>
<div class="readable-text" id="p23">
<p class="calibre15">We expected the answer of 1, but we got 2. Notably, including <em class="calibre18">danger</em> in this test case helped us catch the error in the code. Where in the code did things go wrong? To figure that out, we could add <code class="calibre25">print</code> statements. When you want to do this, you’ll need to read the code to figure out where to put them. Looking at this code, printing the list at the start of the function might not be a bad idea depending on the bug we’re seeing, but the bug here seems to have to do with the count and not specifically with the list of words. Printing each word in the list as the first line in the <code class="calibre25">for</code> loop may be helpful so we can check that the code is processing each word. We might print <code class="calibre25">count</code> right before it’s returned, but we already have a good idea of the value returned. These are all reasonable ideas that will help you get closer to the bug, but it’s not where we’d start. To be clear, if we started with one of these other ideas, we wouldn’t be wrong; it might just take a few more steps before finding the bug.</p>
</div>
<div class="readable-text" id="p24">
<p class="calibre15">Because the bug is counting too many words as <em class="calibre18">Dan</em> words, we’d put the <code class="calibre25">print</code> statement within the <code class="calibre25">if</code> statement right where <code class="calibre25">count</code> is incremented, as in the following listing.</p>
</div>
<div class="browsable-container" id="p25">
<h5 class="listing-container-h"><span>Listing 8.2</span> Example of a print statement to find the bug</h5>
<div class="readable-text">
<pre class="code-area">def count_words(words):
    count = 0
    for word in words:
        if "dan" in word.lower():
            print(word,"is being counted")   <span/> #1
            count += 1
    return count</pre>
<div class="code-annotations-overlay-container">
     #1 A print statement to show which words are being counted
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p26">
<p class="calibre15">Rerunning our code with the same test case, this is what is printed now:</p>
</div>
<div class="browsable-container" id="p27">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; words = ["Dan", "danger", "Leo"]   
&gt;&gt;&gt; count_words(words) 
Dan is being counted
danger is being counted
2</pre>
</div>
</div>
<div class="readable-text" id="p28">
<p class="calibre15">Aha! This would tell us that our program is counting the word <em class="calibre18">danger</em> when it shouldn’t be. We could then give Copilot a new prompt incorporating what we just learned to hopefully have Copilot fix the problem. Here’s the prompt we added in the editor, and Copilot fixed the code in the following listing.</p>
</div>
<div class="browsable-container" id="p29">
<h5 class="listing-container-h"><span>Listing 8.3</span> Using a prompt to fix a known bug</h5>
<div class="readable-text">
<pre class="code-area">def count_words(words):
    count = 0
    for word in words:
        <strong class="calibre17"># only count words that are exactly "Dan"   </strong><span/> #1
        if word == "Dan":   <span/> #2
            count += 1       #2
    return count             #2</pre>
<div class="code-annotations-overlay-container">
     #1 Prompt that causes Copilot to generate the correct code
     <br class="calibre1"/>#2 Code added by Copilot in response to the prompt
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p30">
<p class="calibre15">Once we knew the bug, it was easier to tell Copilot how to fix it. Granted, this is a basic example, but the idea applies to far more complex code. The process is often iterative. You ask the code to print something, and what it prints aligns with what you think it should be doing. You then ask the code to print something else and check it against what you expect. You keep doing this until there’s a point where what the code prints doesn’t align with what you wanted it to do. That’s when you’ve found the bug and can give Copilot a prompt to help it give you better code, or if the fix is simple, you can change the code directly.</p>
</div>
<div class="readable-text" id="p31">
<p class="calibre15">Depending on the complexity of the code, using <code class="calibre25">print</code> statements is often an effective way of debugging. We often use it as our first step in debugging.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p32">
<h5 class="callout-container-h">Debugging: An art more than a science </h5>
</div>
<div class="readable-text" id="p33">
<p class="calibre15">The iterative process when debugging is necessary because we’re genuinely confused about what the code is doing and why it isn’t matching our expectations. It’s okay to add a bunch of <code class="calibre25">print</code> statements that just tell you what you thought was happening in the first place because each of these <code class="calibre25">print</code> statements tells you where <em class="calibre18">not</em> to look for the bug and is an effective process of elimination. Figuring out where to look for bugs takes time and practice, so don’t worry if you find yourself spending a fair bit of time on it when you first start.</p>
</div>
</div>
<div class="readable-text" id="p34">
<h3 class="readable-text-h2" id="sigil_toc_id_121"><span class="calibre22">8.2.2</span> Using VS Code’s debugger to learn about the code behavior</h3>
</div>
<div class="readable-text" id="p35">
<p class="calibre15">VS Code is used by novices and professionals alike, so it has tools to help with the process of debugging. Because it’s used by professionals, debugging tools have a large number of features. For the purpose of this book, we’ll focus on a few of the most commonly used features, but feel free to look into more resources on using the VS Code debugger if you’re curious (<a href="https://code.visualstudio.com/docs/editor/debugging">https://code.visualstudio.com/docs/editor/debugging</a>).</p>
</div>
<div class="readable-text" id="p36">
<p class="calibre15">To showcase these tools, we’ll work through debugging the same function from the previous example (refer to listing 8.1) in a few ways. Listing 8.4 provides the code we’ll be working with throughout this section. Note that we’ve added the test of the <code class="calibre25">count_words</code> function to the program.</p>
</div>
<div class="browsable-container" id="p37">
<h5 class="listing-container-h"><span>Listing 8.4</span> Incorrect <code class="calibre25">count_words</code> function for debugging</h5>
<div class="readable-text">
<pre class="code-area">def count_words(words): 
    count = 0 
    for word in words: 
        if "dan" in word.lower(): 
            count += 1 
    return count 

words = ["Dan", "danger", "Leo"]    <span/> #1
print(count_words(words))            #1</pre>
<div class="code-annotations-overlay-container">
     #1 Code to call the count_words function directly
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p38">
<h4 class="readable-text-h3">Getting started with the debugger and setting breakpoints</h4>
</div>
<div class="readable-text" id="p39">
<p class="calibre15">To use the debugger, we need to set a <em class="calibre18">breakpoint </em>and start the debugger. Setting a breakpoint tells the debugger when you want to start debugging the program as it executes. Once you hit the breakpoint, you’ll be able to inspect variable values and step through the program line by line. Breakpoints are extremely useful. For a large program, you wouldn’t want to step line by line through the entire program because that could take a great deal of time. Instead, using a breakpoint, you can step through just the lines of code that are most relevant to you.</p>
</div>
<div class="readable-text" id="p40">
<p class="calibre15">To set a breakpoint, hover your mouse cursor to the left of the code, and you’ll see a dot appear. Click that dot, as shown in figure 8.1, and you’ll have a breakpoint set. For your projects, you’ll likely want to start by creating a breakpoint at the start of the function’s execution and then step through it one step at a time.<span/></p>
</div>
<div class="browsable-container" id="p41">
<img alt="figure" src="../Images/8-1.png" class="calibre66"/>
<h5 class="figure-container-h"><span>Figure 8.1</span> Creating a breakpoint in VS Code by clicking to the left of the line of code</h5>
</div>
<div class="readable-text" id="p42">
<p class="calibre15">If you see a red dot to the left of the breakpoint after you move your mouse away, as shown in figure 8.2, that means it’s properly set. <span/></p>
</div>
<div class="browsable-container" id="p43">
<img alt="figure" src="../Images/8-2.png" class="calibre67"/>
<h5 class="figure-container-h"><span>Figure 8.2</span> A breakpoint has been set on line 2 of our count_words.py file in VS Code.</h5>
</div>
<div class="readable-text" id="p44">
<p class="calibre15">You can have more than one breakpoint, but for this example, let’s just stick with the one breakpoint on line 2. (Note that you can remove a breakpoint by clicking on that red dot again.) Next, we’ll start the debugger and see how it works with the breakpoint.</p>
</div>
<div class="readable-text" id="p45">
<h4 class="readable-text-h3">How to step through the code line by line</h4>
</div>
<div class="readable-text" id="p46">
<p class="calibre15">To start the debugger, choose Run &gt; Start Debugging, as shown in figure 8.3.<span/></p>
</div>
<div class="browsable-container" id="p47">
<img alt="figure" src="../Images/8-3.png" class="calibre68"/>
<h5 class="figure-container-h"><span>Figure 8.3</span> Starting the debugger in VS Code</h5>
</div>
<div class="readable-text" id="p48">
<p class="calibre15">Once the debugger is started, you should see a screen similar to figure 8.4. (If this is the first time using the debugger, it may ask you to select a debug configuration, in which case, you’ll want to choose Python.) <span/></p>
</div>
<div class="browsable-container" id="p49">
<img alt="figure" src="../Images/8-4.png" class="calibre69"/>
<h5 class="figure-container-h"><span>Figure 8.4</span> The Debugging view in VS Code</h5>
</div>
<div class="readable-text" id="p50">
<p class="calibre15">The VS Code debugger has a number of components [1]. On the left-hand side, the Debug Side Bar contains the Variables section, Watch section, and Call Stack section. Let’s briefly examine each of these sections:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p51"> The <em class="calibre18">Variables section</em> contains the variables that are declared within the current scope (e.g., within <code class="calibre25">count_words</code>) and their current values. For example, the <code class="calibre25">words</code> parameter is defined to be a list containing <code class="calibre25">['Dan',</code> <code class="calibre25">'danger',</code> <code class="calibre25">'Leo']</code>. You can click the arrow (&gt;) to the left of <code class="calibre25">words</code> to see more details about that variable. This section is incredibly useful because you can examine the value of each variable. </li>
<li class="readable-text1" id="p52"> The <em class="calibre18">Watch section</em> contains any expressions you want to watch specifically. For example, you might add the expression: <code class="calibre25">"dan"</code> <code class="calibre25">in</code> <code class="calibre25">word.lower()</code> to the watched expressions, and you’d be able to see if it’s <code class="calibre25">True</code> or <code class="calibre25">False</code> for each different value of <code class="calibre25">word</code>. To add an expression, hover over the Watch section and click the + sign. </li>
<li class="readable-text1" id="p53"> The <em class="calibre18">Call Stack section</em> contains the functions that have been called that have led to this line of code executing. Here, the main function (called <code class="calibre25">&lt;module&gt;</code> by VS Code) called the function <code class="calibre25">count_words</code> on line 9. Within the function <code class="calibre25">count_words</code>, we’re presently on line 2. You can double-check that this is true by looking at the line of code presently highlighted as line 2 is highlighted in figure 8.4. </li>
</ul>
<div class="readable-text" id="p54">
<p class="calibre15">Speaking of which, on the right-hand side, which shows our code editor, we can see the line <code class="calibre25">count</code> <code class="calibre25">=</code> <code class="calibre25">0</code> highlighted. This is the current line of code that hasn’t yet been executed. The reason the line hasn’t been executed yet is because we set our breakpoint, shown by the arrow with a dot in it, at this line of code. When we started the debugger, it ran the code until just before executing <code class="calibre25">count</code> <code class="calibre25">=</code> <code class="calibre25">0</code>. </p>
</div>
<div class="readable-text" id="p55">
<p class="calibre15">The Debug Toolbar (figure 8.5) is critical as it drives the process once you start debugging: you can advance an instruction, restart debugging, or stop debugging. <span/></p>
</div>
<div class="browsable-container" id="p56">
<img alt="figure" src="../Images/8-5.png" class="calibre70"/>
<h5 class="figure-container-h"><span>Figure 8.5</span> The Debugging Toolbar</h5>
</div>
<div class="readable-text" id="p57">
<p class="calibre15">The buttons on the toolbar, going left to right, are</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p58"> <strong class="calibre17"/><em class="calibre18">Continue (F5)—</em>This button will advance until the next time a breakpoint is executed. In our example, line 2 of <code class="calibre25">count_words</code> never executes again, so clicking Continue will cause the program and debugging session to run to the end. </li>
<li class="readable-text1" id="p59"> <strong class="calibre17"/><em class="calibre18">Step Over (F10)—</em>This button advances to the next line of code in the current function. Step Over means that if a line of code in this function calls another function (e.g., when <code class="calibre25">word.lower()</code> is called on line 4), the debugger will stay in the <code class="calibre25">count_words</code> function and will just run the called function (e.g., <code class="calibre25">word.lower()</code>) to its completion. </li>
<li class="readable-text1" id="p60"> <strong class="calibre17"/><em class="calibre18">Step Into (F11)—</em>This button advances to the next line of code, including going into any functions that are called. Unlike Step Over, when you use Step Into, the debugger will go into any function called by the current function. For example, if you used Step Into on a line of code that calls another function, it would go into that function and continue debugging (line by line) from inside that function. By default, it doesn’t step into library function calls (e.g., <code class="calibre25">word.lower()</code> is part of the Python standard library) but will step into functions you’ve written. </li>
<li class="readable-text1" id="p61"> <strong class="calibre17"/><em class="calibre18">Step Out (Shift + F11)—</em>This button will execute the code until the present function ends and then continue debugging from after this function’s exit. </li>
<li class="readable-text1" id="p62"> <strong class="calibre17"/><em class="calibre18">Restart—</em>This button restarts the debugging process. It will restart the program, and the program will execute until its first breakpoint. </li>
<li class="readable-text1" id="p63"> <strong class="calibre17"/><em class="calibre18">Stop—</em>This button stops the debugging process. </li>
</ul>
<div class="readable-text" id="p64">
<h4 class="readable-text-h3">Stepping through the code line by line</h4>
</div>
<div class="readable-text" id="p65">
<p class="calibre15">Now that we have a handle on the debugger, let’s continue our example by using the Step Over button. Let’s click Step Over once and see how our view changes (figure 8.6). Step Over advanced to the next line of code, line 3. This means it executed </p>
</div>
<div class="browsable-container" id="p66">
<div class="readable-text">
<pre class="code-area">count = 0</pre>
</div>
</div>
<div class="readable-text" id="p67">
<p class="calibre15">and is just about ready to execute </p>
</div>
<div class="browsable-container" id="p68">
<div class="readable-text">
<pre class="code-area">for word in words:<span/></pre>
</div>
</div>
<div class="browsable-container" id="p69">
<img alt="figure" src="../Images/8-6.png" class="calibre71"/>
<h5 class="figure-container-h"><span>Figure 8.6</span> Our debugger after clicking Step Over once. The next line (line 3) is now highlighted.</h5>
</div>
<div class="readable-text" id="p70">
<p class="calibre15">We can see from various clues in the interface that the line <code class="calibre25">count</code> <code class="calibre25">=</code> <code class="calibre25">0</code> was executed. First, in the editor on the right, we can see the <code class="calibre25">for</code> loop is highlighted, and the arrow on the left points to this line of code. On the left, in the Call Stack section, we can see that it’s now on line 3 of <code class="calibre25">count_words</code> <code class="calibre25">(</code>as shown by the line <code class="calibre25">count_words</code> being highlighted and the number in the oval on the right reading 3:1). Perhaps most importantly, on the left in the Variables section, we can now see the variable <code class="calibre25">count</code> has been added to the local variables, and it has a value of <code class="calibre25">0</code>. This last piece is pretty amazing because if you were trying to read through the code and trace what is happening line by line, the line <code class="calibre25">count</code> <code class="calibre25">=</code> <code class="calibre25">0</code> on line 2 would mean that a variable count is created and assigned a value of <code class="calibre25">0</code>. This is just what the VS Code debugger has told us as well. We hope you’re starting to see how powerful this tool can be.</p>
</div>
<div class="readable-text" id="p71">
<p class="calibre15">Let’s click Step Over one more time. Now we’re stopping just before the line</p>
</div>
<div class="browsable-container" id="p72">
<div class="readable-text">
<pre class="code-area">if "dan" in word.lower():</pre>
</div>
</div>
<div class="readable-text" id="p73">
<p class="calibre15">We can see that there is now a new variable, <code class="calibre25">word</code>, which has been assigned the value <code class="calibre25">"Dan"</code>, and that’s just what we’d expect: <code class="calibre25">word</code> was given the value of the first element in the list <code class="calibre25">words</code>. This is a good spot to point out that in addition to being able to read the variables values in the Variables section, you can also just hover your mouse over any variable that’s been declared already to see its value as well. Pretty neat, huh?</p>
</div>
<div class="readable-text" id="p74">
<p class="calibre15">Let’s click Step Over one more time and see that the condition in the <code class="calibre25">if</code> statement, <code class="calibre25">"dan"</code> <code class="calibre25">in</code> <code class="calibre25">word.lower()</code>, evaluated to <code class="calibre25">True</code>, so we’re going to execute the line </p>
</div>
<div class="browsable-container" id="p75">
<div class="readable-text">
<pre class="code-area">count += 1</pre>
</div>
</div>
<div class="readable-text" id="p76">
<p class="calibre15">Now that we’re getting the hang of this, let’s keep clicking Step Over a few more times. The first time you click Step Over, it will go back to the <code class="calibre25">for</code> loop, and you can see <code class="calibre25">count</code> has incremented to <code class="calibre25">1</code>. The second time you click Step Over, it will stop at the <code class="calibre25">if</code> statement, and you can see that word is now <code class="calibre25">"danger"</code>. We could stop here and add a watch expression to see what this <code class="calibre25">if</code> statement will do. To add a watch expression, hover your mouse over the Watch section, and click the plus arrow that appears to the right of the word Watch. This will let you type anything you want. We typed <code class="calibre25">"dan"</code> <code class="calibre25">in</code> <code class="calibre25">word.lower()</code> and pressed Enter to add this watch expression, as shown in the Debug Side Bar of figure 8.7.<span/></p>
</div>
<div class="browsable-container" id="p77">
<img alt="figure" src="../Images/8-7.png" class="calibre72"/>
<h5 class="figure-container-h"><span>Figure 8.7</span> View of the debugger after adding the watch expression</h5>
</div>
<div class="readable-text" id="p78">
<p class="calibre15">If we hadn’t already found the bug earlier in this chapter, this is where we’d find it. The expression <code class="calibre25">"dan"</code> <code class="calibre25">in</code> <code class="calibre25">word.lower()</code> evaluates to <code class="calibre25">True</code>, which means <code class="calibre25">count</code> will be incremented again. But we only wanted exact matches to the word <code class="calibre25">"Dan"</code> and didn’t want <code class="calibre25">"danger"</code> to count!</p>
</div>
<div class="readable-text" id="p79">
<p class="calibre15">This is a completely reasonable way to debug a function. As we noted earlier, putting a breakpoint at the start of the function’s execution and then stepping through it one step at a time often is a great starting point for debugging. The only times you might struggle to use this approach is if the <code class="calibre25">for</code> loop ran through thousands of values before making a mistake. To address challenges like this, we might put a breakpoint in a specific spot to avoid spending a lot of time in the debugger. Let’s stop the debugger (click Stop in the Debug Toolbar), remove the breakpoint from line 2 (click the red dot to the left of the line), and try a different breakpoint.</p>
</div>
<div class="readable-text" id="p80">
<h4 class="readable-text-h3">Using a breakpoint to selectively debug</h4>
</div>
<div class="readable-text" id="p81">
<p class="calibre15">This time, let’s put the breakpoint at a point in the code we want to monitor more closely. Based on our test case showing that two words of the list “counted” when we expected just one to, we should try putting our breakpoint at the line where <code class="calibre25">count</code> is incremented, as we have in figure 8.8.<span/></p>
</div>
<div class="browsable-container" id="p82">
<img alt="figure" src="../Images/8-8.png" class="calibre73"/>
<h5 class="figure-container-h"><span>Figure 8.8</span> View of the code after placing our new breakpoint on line 5</h5>
</div>
<div class="readable-text" id="p83">
<p class="calibre15">Once we start the debugger, the code will run until the first time the <code class="calibre25">if</code> statement is evaluated to <code class="calibre25">True</code> and the line <code class="calibre25">count</code> <code class="calibre25">+=</code> <code class="calibre25">1</code> is ready to execute. Figure 8.9 offers the view of the debugger once we start it.<span/></p>
</div>
<div class="browsable-container" id="p84">
<img alt="figure" src="../Images/8-9.png" class="calibre74"/>
<h5 class="figure-container-h"><span>Figure 8.9</span> View of the debugger when it encounters the breakpoint (line 5) for the first time</h5>
</div>
<div class="readable-text" id="p85">
<p class="calibre15">We put the breakpoint at the incrementing of <code class="calibre25">count</code> because we wanted to see what item in the list is causing <code class="calibre25">count</code> to increment. Examining our local variables, we can see that <code class="calibre25">word</code> is <code class="calibre25">'Dan'</code>, and that is when we want the <code class="calibre25">count</code> variable to be incremented. Given this is what we wanted to happen, we haven’t found our bug yet.</p>
</div>
<div class="readable-text" id="p86">
<p class="calibre15">Now is when we can really take advantage of our breakpoint placement. We want the code to execute until it comes across the breakpoint again. The way to do this is to click Continue in the Debug Toolbar (refer to figure 8.5). After clicking Continue, the debugger should appear as in figure 8.10.<span/></p>
</div>
<div class="browsable-container" id="p87">
<img alt="figure" src="../Images/8-10.png" class="calibre75"/>
<h5 class="figure-container-h"><span>Figure 8.10</span> View of the debugger when it encounters the breakpoint (line 5) for the second time</h5>
</div>
<div class="readable-text" id="p88">
<p class="calibre15">In the Variables section, notice that the value of <code class="calibre25">count</code> and the value of <code class="calibre25">word</code> are highlighted. This is to tell you that because you clicked Continue, those two values have changed. The value in <code class="calibre25">count</code> increased to <code class="calibre25">1</code>, as expected, after having found the word <code class="calibre25">'Dan'</code>. The value in <code class="calibre25">word</code> updated to <code class="calibre25">'danger'</code>. Although <code class="calibre25">'danger'</code> is the next value in the list of words, we shouldn’t expect to find the code incrementing <code class="calibre25">count</code> for the word <code class="calibre25">'danger'</code>. At this point, we’d have found our bug. Notice how much quicker it can be to find a bug with a good placement of a breakpoint. But we caution that knowing the best place to put a breakpoint is a lot like knowing the best variables to print when debugging—it takes time and practice to learn how to do it well.</p>
</div>
<div class="readable-text" id="p89">
<p class="calibre15">In this section, we’ve seen how powerful the debugger can be in VS Code. It’s pretty easy to set a breakpoint and start a debugging session. As the debugger monitors the variables in the function, you can inspect those in the Debug Side Bar as the code executes.</p>
</div>
<div class="readable-text" id="p90">
<h2 class="readable-text-h1" id="sigil_toc_id_122"><span class="calibre22">8.3</span> How to fix a bug (once found)</h2>
</div>
<div class="readable-text" id="p91">
<p class="calibre15">In the old way of learning to program, this would be a short section that would tell you to fix the bug yourself. Although that’s still an option, we have a lot of choices now with Copilot. These choices include asking Copilot to fix it, giving it a new prompt for the entire function that better describes the problem in a way to avoid the bug, giving Copilot a targeted prompt to fix the spot in the code you found that was wrong, and, if it’s a small fix, making it yourself. Let’s see how we could do each of these.</p>
</div>
<div class="readable-text" id="p92">
<h3 class="readable-text-h2" id="sigil_toc_id_123"><span class="calibre22">8.3.1</span> Asking Copilot to fix your bug via Copilot Chat</h3>
</div>
<div class="readable-text" id="p93">
<p class="calibre15"><em class="calibre18"/>In the following example, we’ll interact with the Copilot Chat feature. The Copilot Chat feature lets you interact with Copilot as you might with ChatGPT but is limited to questions pertaining to programming. Feel free to interact with ChatGPT instead (available via <a href="https://openai.com">https://openai.com</a> with free tiers at the time of writing) in the same way as we interact with Copilot in this section. We’re preferential to Copilot Chat just because its interface is built in to the latest version of VS Code and the Copilot extension.</p>
</div>
<div class="readable-text" id="p94">
<p class="calibre15">In previous chapters, we’ve mostly just asked Copilot Chat for single answers, whereas in this chapter and later chapters, we’ll be using Copilot Chat to have a conversation with the tool. When we’re having a conversation with the tool, we’ll work to separate out what we write (“Human”) from Copilot’s responses (“GitHub Copilot”). Using the Copilot Chat feature, let’s see if Copilot can help us out here:</p>
</div>
<div class="readable-text4" id="p95">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>I have a function, below, that is supposed to count the number of times the word “Dan” appears in the parameter list “words”. Instead, it seems to be counting the number of times the characters “dan” appear anywhere in the list. Can you help fix this for me?</p>
</div>
<div class="browsable-container" id="p96">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">def count_words(words): </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    count = 0 </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    for word in words: </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">        if "dan" in word.lower(): </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">            count += 1 </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    return count</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p97">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Certainly! To count the number of times the word “Dan” appears in the list, you can modify the <code class="calibre25">if</code> statement to check if the whole word is equal to “Dan” (case-insensitive). Here’s the modified code:</p>
</div>
<div class="browsable-container" id="p98">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">def count_words(words): </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    count = 0 </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    for word in words: </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">        if word.lower() == "dan": </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">            count += 1 </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    return count</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p99">
<p class="calibre54">This code will count the number of times the word “Dan” (case-insensitive) appears in the list.</p>
</div>
<div class="readable-text" id="p100">
<p class="calibre15">The answer back from Copilot Chat changed the line</p>
</div>
<div class="browsable-container" id="p101">
<div class="readable-text">
<pre class="code-area">if "dan" in word.lower():</pre>
</div>
</div>
<div class="readable-text" id="p102">
<p class="calibre15">to</p>
</div>
<div class="browsable-container" id="p103">
<div class="readable-text">
<pre class="code-area">if word.lower() == "dan":</pre>
</div>
</div>
<div class="readable-text" id="p104">
<p class="calibre15">Although the change may look small, it has a big effect. The original line of code searched for the string <code class="calibre25">"dan"</code> anywhere in <code class="calibre25">word</code> (after the word has been made all lowercase letters by the <code class="calibre25">.lower()</code> method). The new line of code checks to see whether <code class="calibre25">word</code> (again, made all lowercase letters by the <code class="calibre25">.lower()</code> method) is an exact match for the string <code class="calibre25">"dan"</code>. </p>
</div>
<div class="readable-text" id="p105">
<p class="calibre15">This answer from Copilot is a step closer to a correct solution as it will only match the whole word rather than looking for an occurrence of <code class="calibre25">dan</code> anywhere in the word. However, the call to <code class="calibre25">.lower()</code> makes it case-insensitive, so it would also match <code class="calibre25">dan</code> rather than how our solution earlier (listing 8.3) was case-sensitive (it had to be exactly <code class="calibre25">Dan</code>). We’d like to be case-sensitive, so we could continue with Copilot Chat to have Copilot fix this for us.</p>
</div>
<div class="readable-text4" id="p106">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Can you give me the same code but count only the word “Dan” (case-sensitive)?</p>
</div>
<div class="readable-text4" id="p107">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Sure! Here’s the modified code that counts only the word “Dan” (case-sensitive):</p>
</div>
<div class="browsable-container" id="p108">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">def count_words(words): </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    count = 0 </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    for word in words: </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">        if word == "Dan": </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">            count += 1 </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    return count </em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p109">
<p class="calibre54">This code will count the number of times the word “Dan” (case-sensitive) appears in the list.</p>
</div>
<div class="readable-text" id="p110">
<p class="calibre15">In this case, Copilot Chat was able to solve the problem for us when we knew how the code was misfunctioning. We didn’t explicitly say what line of code was broken, but if you knew this, you could convey that to Copilot Chat as well. One advantage of knowing which line was broken, like we did here, is that we could look to make sure the fix from Copilot changes the broken line. Let’s move on and examine other options for fixing the bug.</p>
</div>
<div class="readable-text" id="p111">
<h3 class="readable-text-h2" id="sigil_toc_id_124"><span class="calibre22">8.3.2</span> Giving Copilot a new prompt for the whole function</h3>
</div>
<div class="readable-text" id="p112">
<p class="calibre15">You’ve seen us rewrite the prompt for a function a fair number of times already in this book. It simply involves rewriting the function prompt and seeing if Copilot can do better, sometimes using Ctrl-Enter to explore Copilot’s solutions. We won’t repeat this here because you’ve already seen it many times before (e.g., in chapter 6, section 6.5.2).</p>
</div>
<div class="readable-text" id="p113">
<h3 class="readable-text-h2" id="sigil_toc_id_125"><span class="calibre22">8.3.3</span> Giving Copilot a targeted prompt for part of a function</h3>
</div>
<div class="readable-text" id="p114">
<p class="calibre15">We used this technique earlier in the chapter in listing 8.3. We’ve reproduced this as listing 8.5.</p>
</div>
<div class="browsable-container" id="p115">
<h5 class="listing-container-h"><span>Listing 8.5</span> Using a prompt to fix a known bug (relisted)</h5>
<div class="readable-text">
<pre class="code-area">def count_words(words):
    count = 0
    for word in words:
        <strong class="calibre17"># only count words that are exactly "Dan"    </strong><span/> #1
        if word == "Dan":
            count += 1
    return count</pre>
<div class="code-annotations-overlay-container">
     #1 Prompt that causes Copilot to generate correct code
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p116">
<p class="calibre15">Here, we’d figured out that the previous line</p>
</div>
<div class="browsable-container" id="p117">
<div class="readable-text">
<pre class="code-area">if "dan" in word.lower():</pre>
</div>
</div>
<div class="readable-text" id="p118">
<p class="calibre15">wasn’t doing what we wanted. So, we removed the incorrect code and specifically added a prompt to say exactly what we wanted Copilot to do, and it was able to produce the correct code.</p>
</div>
<div class="readable-text" id="p119">
<h3 class="readable-text-h2" id="sigil_toc_id_126"><span class="calibre22">8.3.4</span> Modifying the code to fix the bug yourself</h3>
</div>
<div class="readable-text" id="p120">
<p class="calibre15">This approach to fixing broken code is new to this chapter. You’ve seen enough code at this point in the book that you can likely fix some code by yourself by directly modifying it. For example, suppose we wrote the following code.</p>
</div>
<div class="browsable-container" id="p121">
<h5 class="listing-container-h"><span>Listing 8.6</span> Function to count specified numbers in a list</h5>
<div class="readable-text">
<pre class="code-area">def count_between(numbers, x, y):
    count = 0
    for number in numbers:
        if number &gt;= x and number &lt;= y:
            count += 1
    return count</pre>
</div>
</div>
<div class="readable-text" id="p122">
<p class="calibre15">We’ve seen functions like this earlier in the book. It iterates through all the numbers in the list of numbers and checks if each number is bigger than or equal to <code class="calibre25">x</code> and is less than or equal to <code class="calibre25">y</code>. If a number is between <code class="calibre25">x</code> and <code class="calibre25">y</code>, it increases the <code class="calibre25">count</code>. At the end of the function, it returns the <code class="calibre25">count</code>. The code isn’t wrong here if the goal is to count numbers in the list that are between <code class="calibre25">x</code> and <code class="calibre25">y</code> (including <code class="calibre25">x</code> and <code class="calibre25">y</code>). </p>
</div>
<div class="readable-text" id="p123">
<p class="calibre15">However, the term <em class="calibre18">between</em> can be a bit ambiguous. Do you want to include <code class="calibre25">x</code> and <code class="calibre25">y</code> or just the values between them (not including them)? Suppose that when you imagined this function, you wanted to not include <code class="calibre25">x</code> and <code class="calibre25">y.</code> For example, if the list were 2, 4, 8, and you provided <code class="calibre25">x</code> and <code class="calibre25">y</code> values of 3 and 8, you would want the <code class="calibre25">count</code> to be 1 (including 4, but not 8). You might already see how the function is wrong for this goal and how to fix it, but let’s pretend you don’t realize yet that the code doesn’t match what you want.</p>
</div>
<div class="readable-text" id="p124">
<p class="calibre15">As with any function that is created either by Copilot or us, we should test the function. Fortunately, when writing the first test case, we included a value in the test case (<code class="calibre25">numbers</code>) that is equal to <code class="calibre25">x</code> (the lower bound) and equal to <code class="calibre25">y</code> (the upper bound): </p>
</div>
<div class="browsable-container" id="p125">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; print(count_between(numbers, 3, 7))
5</pre>
</div>
</div>
<div class="readable-text" id="p126">
<p class="calibre15">Testing the code at the prompt, we found that our function returns 5 as the answer, but we thought the answer should be 3. By our definition of <em class="calibre18">between</em>, we felt that only the numbers 4, 5, and 6 are between 3 and 7, so the answer should be 3, that is, there are three numbers between 3 and 7. Instead, the code gave us the answer of 5. So, we know it isn’t working correctly thanks to our test cases. Whether we go on to find the bug by inspecting the code or by using the debugging techniques from this chapter, we realize the statement</p>
</div>
<div class="browsable-container" id="p127">
<div class="readable-text">
<pre class="code-area">if number &gt;= x and number &lt;= y:</pre>
</div>
</div>
<div class="readable-text" id="p128">
<p class="calibre15">is the culprit. Here, the complete fix requires us to change the <code class="calibre25">if</code> statement from </p>
</div>
<div class="browsable-container" id="p129">
<div class="readable-text">
<pre class="code-area">if number &gt;= x and number &lt;= y:</pre>
</div>
</div>
<div class="readable-text" id="p130">
<p class="calibre15">to </p>
</div>
<div class="browsable-container" id="p131">
<div class="readable-text">
<pre class="code-area">if number &gt; x and number &lt; y:</pre>
</div>
</div>
<div class="readable-text" id="p132">
<p class="calibre15">This is a change we could just make directly, without asking for Copilot’s help (although Copilot would likely be able to help us here as well). Listing 8.7 has the fixed function after the change.</p>
</div>
<div class="browsable-container" id="p133">
<h5 class="listing-container-h"><span>Listing 8.7</span> Function to count specified numbers (corrected)</h5>
<div class="readable-text">
<pre class="code-area">def count_between(numbers, x, y):
    count = 0
    for number in numbers:
        if number &gt; x and number &lt; y:   <span/> #1
            count += 1
    return count</pre>
<div class="code-annotations-overlay-container">
     #1 Changed the &gt;= to &gt; and &lt;= to &lt; manually
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p134">
<h2 class="readable-text-h1" id="sigil_toc_id_127"><span class="calibre22">8.4</span> Modifying our workflow in light of our new skills</h2>
</div>
<div class="readable-text" id="p135">
<p class="calibre15">Now that we know how to find and fix bugs in a more deliberate manner, let’s revisit the workflow we last visited in chapter 6. Note that this workflow is about how to design a single function, so it presumes you’ve already done the function decomposition described in chapter 7 to determine the appropriate functions. The new workflow appears in figure 8.11.<span/></p>
</div>
<div class="browsable-container" id="p136">
<img alt="figure" src="../Images/8-11.png" class="calibre76"/>
<h5 class="figure-container-h"><span>Figure 8.11</span> The function design cycle with Copilot, augmented to include debugging</h5>
</div>
<div class="readable-text" id="p137">
<p class="calibre15">Although the figure is starting to get a bit complicated, most of this is what you saw previously in chapter 6. The only changes here are to include debugging. Specifically, if you’ve already tried to revise the prompt and you still can’t get code that works, then it’s time to try debugging explicitly. With the tools you’ve gained in this chapter, you’ll likely be successful at finding some bugs but not all possible bugs. If you find the bug and feel you’ve successfully fixed it, the flowchart sends you back to testing to make sure your fix worked (and didn’t break any other test cases). On the off chance you can’t get the code to work through new prompts and just can’t seem to debug it, we’ve found that problem decomposition is often your best next step. In other words, if you can’t get a function to work no matter how hard you try, the function should probably be broken into multiple functions, and you’re more likely to be successful coding those smaller functions.</p>
</div>
<div class="readable-text" id="p138">
<h2 class="readable-text-h1" id="sigil_toc_id_128"><span class="calibre22">8.5</span> Applying our debugging skills to a new problem</h2>
</div>
<div class="readable-text" id="p139">
<p class="calibre15">With our new skills in place and a new workflow, let’s try tackling a more challenging debugging problem. Remember in chapter 6 when we tried to determine the largest number of empty seats in a given row in a classroom? We’re going to solve a similar problem here.</p>
</div>
<div class="readable-text" id="p140">
<p class="calibre15">Instead of looking for empty seats, let’s say that we want to count the most students seated consecutively in a row because you’re trying to space them out better before an exam. You could also imagine using this to space out people more if they want more personal space or if there’s a pandemic. We wrote the prompt and a basic doctest, and Copilot generated a solution. The code appears in the following listing.</p>
</div>
<div class="browsable-container" id="p141">
<h5 class="listing-container-h"><span>Listing 8.8</span> First attempt to count consecutive students in a row</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def most_students(classroom):                                </strong><span/> #1
<strong class="calibre17">    '''                                                      </strong>
<strong class="calibre17">    classroom is a list of lists                             </strong>
<strong class="calibre17">    Each ' ' is an empty seat                                </strong>
<strong class="calibre17">    Each 'S' is a student                                    </strong>
<strong class="calibre17">                                                             </strong>
<strong class="calibre17">    Find the most students seated consecutively in a row     </strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    &gt;&gt;&gt; most_students([['S', ' ', 'S', ' ', 'S', 'S'],\    </strong><span/> #2
<strong class="calibre17">                       ['S', ' ', 'S', 'S', 'S', ' '],\    </strong> #2
<strong class="calibre17">                       [' ', 'S', ' ', 'S', ' ', ' ']])    </strong> #2
<strong class="calibre17">    3                                                      </strong> #2
<strong class="calibre17">    '''</strong>
    max_count = 0                         <span/> #3
    for row in classroom:                  #3
        count = 0                          #3
        for seat in row:                   #3
            if seat == 'S':                #3
                count += 1                 #3
            else:                          #3
                if count &gt; max_count:      #3
                    max_count = count      #3
                count = 0                  #3
    return max_count                       #3

import doctest                    <span/> #4
doctest.testmod(verbose=True)      #4</pre>
<div class="code-annotations-overlay-container">
     #1 Our prompt to Copilot
     <br class="calibre1"/>#2 The first test case
     <br class="calibre1"/>#3 The code from Copilot
     <br class="calibre1"/>#4 The code to run the doctest that we added
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p142">
<p class="calibre15">Given this chapter is about debugging, you can probably guess the code isn’t working correctly. We caught this bug when we read the code Copilot gave us, but it’s a subtle bug that we suspect could be missed fairly easily. If you see it already, great job, but pretend you didn’t for the rest of the chapter. If you haven’t seen it, the rest of the chapter is going to be more valuable to you.</p>
</div>
<div class="readable-text" id="p143">
<p class="calibre15">Let’s imagine then that we just wrote this prompt and test case. We read through the code, and it looks like it’s probably keeping track of the most consecutive students. As long as it sees a student in a seat, it increments the count. When there isn’t a student in the seat, it checks to see whether the count is bigger than any previously seen and resets the count. It seems like it’s at least on the right track. We included a test case, so we ran the code, and the test case passed. We’re feeling pretty good about the code but know we need to do more test cases, particularly ones to catch edge cases (remember that edge cases are uncommon cases that could break the code).</p>
</div>
<div class="readable-text" id="p144">
<p class="calibre15">We know when we work with lists, it’s good to check that the code does the right thing at the start and end of the list. To test the end of the list, let’s add a test case where the largest group of consecutive students includes the last seat and then rerun the code. Here’s the new test case we’re adding to the docstring:</p>
</div>
<div class="browsable-container" id="p145">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; most_students([['S', ' ', 'S', 'S', 'S', 'S'],\   <span/> #1
                  ['S', ' ', 'S', 'S', 'S', ' '],\
                  [' ', 'S', ' ', 'S', ' ', ' ']])
4</pre>
<div class="code-annotations-overlay-container">
     #1 The longest group of consecutive students is 4.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p146">
<p class="calibre15">We run the code again and are surprised when the test cases fail. Here’s what it told us (we reformatted the output for readability):</p>
</div>
<div class="browsable-container" id="p147">
<div class="readable-text">
<pre class="code-area">Trying:
    most_students([['S', ' ', 'S', 'S', 'S', 'S'],
                   ['S', ' ', 'S', 'S', 'S', ' '],                
                   [' ', 'S’, ' ', 'S’, ' ', ' ']])
Expecting:
    4
**********************************************************************
File "c:\Copilot\max_consecutive.py", 
line 12, in __main__.most_students

Failed example:
    most_students([['S', ' ', 'S', 'S', 'S', 'S'],
                   ['S', ' ', 'S', 'S', 'S', ' '],                
                   [' ', 'S', ' ', 'S', ' ', ' ']])
Expected:
    4
Got:
    3</pre>
</div>
</div>
<div class="readable-text" id="p148">
<p class="calibre15">That’s odd—the code seemed to be working properly. Something about this edge case has uncovered the error. At this point, we’d want to generate some hypotheses about why the code isn’t working properly to help guide our debugging efforts. (If you’re truly stumped, you could take the approach of just setting a breakpoint at the first line of code in the function and stepping through it rather than trying to create a hypothesis.) Here are two hypotheses that come to mind: </p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p149"> The updating of <code class="calibre25">count</code> is skipping the last element in the list. </li>
<li class="readable-text1" id="p150"> The updating of <code class="calibre25">max_count</code> is missing the last element in the list. </li>
</ul>
<div class="readable-text" id="p151">
<p class="calibre15">To simplify the debugging process, we removed the test that is passing (just set it aside to restore later) and are only going to run the test that is failing. The following listing shows our full code before we start the debugging process. </p>
</div>
<div class="browsable-container" id="p152">
<h5 class="listing-container-h"><span>Listing 8.9</span> Code that we’ll debug to count consecutive students</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def most_students(classroom):       </strong>
<strong class="calibre17">  '''</strong>
<strong class="calibre17">    classroom is a list of lists</strong>
<strong class="calibre17">    Each ' ' is an empty seat</strong>
<strong class="calibre17">    Each 'S' is a student</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Find the most students seated consecutively in a row</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    &gt;&gt;&gt; most_students([['S', ' ', 'S', 'S', 'S', 'S'],\    </strong><span/> #1
<strong class="calibre17">                       ['S', ' ', 'S', 'S', 'S', ' '],\    </strong> #1
<strong class="calibre17">                       [' ', 'S', ' ', 'S', ' ', ' ']])    </strong> #1
<strong class="calibre17">    4</strong>
<strong class="calibre17">    '''</strong>
    max_count = 0
    for row in classroom:
        count = 0
        for seat in row:
            if seat == 'S':
                count += 1
            else:
                if count &gt; max_count:
                    max_count = count
                count = 0
    return max_count

import doctest
doctest.testmod(verbose=True)</pre>
<div class="code-annotations-overlay-container">
     #1 Failed test case
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p153">
<p class="calibre15">We’ll start with the first hypothesis, that <code class="calibre25">count</code> isn’t updating properly at the end of the list and set a breakpoint at the updating of <code class="calibre25">count</code>. Figure 8.12 shows the first time the debugger pauses after it’s started.<span/></p>
</div>
<div class="browsable-container" id="p154">
<img alt="figure" src="../Images/8-12.png" class="calibre77"/>
<h5 class="figure-container-h"><span>Figure 8.12</span> Debugger stopping before the first update of <code class="calibre25">count</code></h5>
</div>
<div class="readable-text" id="p155">
<p class="calibre15">From the debugger, we can see that <code class="calibre25">count</code> is still <code class="calibre25">0</code>, so it hasn’t been updated yet. We’re in the first row of that first test case because <code class="calibre25">row</code> is <code class="calibre25">['S',</code> <code class="calibre25">'</code> <code class="calibre25">',</code> <code class="calibre25">'S',</code> <code class="calibre25">'S',</code> <code class="calibre25">'S',</code> <code class="calibre25">'S']</code>. The seat we’re looking at is an <code class="calibre25">'S'</code>, which is why the count is increasing. Let’s click Continue in the Debug Toolbar to see the next update of <code class="calibre25">count</code>. The state of the debugger after clicking Continue appears in figure 8.13.<span/></p>
</div>
<div class="browsable-container" id="p156">
<img alt="figure" src="../Images/8-13.png" class="calibre78"/>
<h5 class="figure-container-h"><span>Figure 8.13</span> Debugger stopping before the second update of <code class="calibre25">count</code></h5>
</div>
<div class="readable-text" id="p157">
<p class="calibre15">A fair bit has happened, it seems, since the last update of <code class="calibre25">count</code> because <code class="calibre25">max_count</code> is now <code class="calibre25">1</code>. This must have happened when the empty space was processed because <code class="calibre25">max_count</code> was set to <code class="calibre25">1</code> and <code class="calibre25">count</code> was reset back to <code class="calibre25">0</code>. At this point, we’re at the third seat in the row with a student there, and <code class="calibre25">count</code> is ready to update. We’ll want to check that <code class="calibre25">count</code> keeps updating with each new student. We clicked Continue, and <code class="calibre25">count</code> increased to <code class="calibre25">1</code>. We clicked Continue again, and the <code class="calibre25">count</code> increased to <code class="calibre25">2</code>. We click Continue once more, and the <code class="calibre25">count</code> increased to <code class="calibre25">3</code>. At this point, we’re at the last student in the row, and we want to check that <code class="calibre25">count</code> increases to <code class="calibre25">4</code>. To check this, we clicked Step Over once, and <code class="calibre25">count</code> indeed updates to <code class="calibre25">4</code>. You can see the state of the debugger at this point in figure 8.14.<span/></p>
</div>
<div class="browsable-container" id="p158">
<img alt="figure" src="../Images/8-14.png" class="calibre79"/>
<h5 class="figure-container-h"><span>Figure 8.14</span> Debugger stopping right after the fourth consecutive update of <code class="calibre25">count</code></h5>
</div>
<div class="readable-text" id="p159">
<p class="calibre15">Well, we have good news and bad news at this point. The good news is that <code class="calibre25">count</code> is properly updating. The bad news is that our first hypothesis was wrong, and we haven’t found our bug yet. We could move our breakpoint to the line where <code class="calibre25">max_ count</code> is updated (line 22) and then click Restart and start over the debugging process for our second hypothesis, but given that <code class="calibre25">count</code> is <code class="calibre25">4</code> right now in our debugger, let’s just continue to trace through the code and make sure <code class="calibre25">max_count</code> gets updated. Or rather, we know it won’t be, so we want to see why.</p>
</div>
<div class="readable-text" id="p160">
<p class="calibre15">Before clicking Step Over, we’ve got a clue already present in the debugger. This clue comes from the fact that the next line of code to execute is <code class="calibre25">for</code> <code class="calibre25">seat</code> <code class="calibre25">in</code> <code class="calibre25">row</code>. But the student we just saw was the last student in <code class="calibre25">row</code>. This means this <code class="calibre25">for</code> loop is just about to finish (meaning we won’t execute the body of the loop again, which means <code class="calibre25">max_count</code> can’t get updated). Let’s see whether that’s what happens by clicking Step Over. The state of the debugger appears in figure 8.15.<span/></p>
</div>
<div class="browsable-container" id="p161">
<img alt="figure" src="../Images/8-15.png" class="calibre80"/>
<h5 class="figure-container-h"><span>Figure 8.15</span> Debugger stopping after finishing the first row</h5>
</div>
<div class="readable-text" id="p162">
<p class="calibre15">We just finished processing the first row, but we never updated the <code class="calibre25">max_count</code>. The next line of code will pick the next <code class="calibre25">row</code>, and the line after that will set <code class="calibre25">count</code> to <code class="calibre25">0</code> again. We finished the loop over the row without ever updating <code class="calibre25">max_count</code> even though we found a <code class="calibre25">count</code> that’s bigger than the current <code class="calibre25">max_count</code>. If you don’t see the bug yet, we encourage you to step through until the next time <code class="calibre25">max_count</code> is updated, and it may be more obvious at that point. </p>
</div>
<div class="readable-text" id="p163">
<p class="calibre15">The error in the code is that it only updates <code class="calibre25">max_count</code> when it encounters an empty seat. This means that if a row ends <span/>with a student, the code to check whether <code class="calibre25">max_count</code> should be updated will never run for that row. Examining the code more closely, the test to see whether <code class="calibre25">max_count</code> should be updated and the update of <code class="calibre25">max_count</code> should both occur either outside the <code class="calibre25">if-else</code> statement or right after <code class="calibre25">count</code> is updated.</p>
</div>
<div class="readable-text" id="p164">
<p class="calibre15">This is a fix we can probably just make manually because all we need to do is move two lines of code to a better location. The code in listing 8.10 is the corrected function (without the tests or prompts).</p>
</div>
<div class="browsable-container" id="p165">
<h5 class="listing-container-h"><span>Listing 8.10</span> Corrected function to count consecutive students</h5>
<div class="readable-text">
<pre class="code-area">def most_students(classroom):
    max_count = 0
    for row in classroom:
        count = 0
        for seat in row:
            if seat == 'S':
                count += 1
                if count &gt; max_count:   <span/> #1
                    max_count = count    #1
            else:
                count = 0
    return max_count</pre>
<div class="code-annotations-overlay-container">
     #1 Moved the testing of count against max_count to immediately after the updating of count
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p166">
<p class="calibre15">This new code does pass the test that failed with the old code and the original test. After adding another test that makes sure the code works when the longest group of consecutive students appears at the start of the row, we’re more confident the code is now working properly.</p>
</div>
<div class="readable-text" id="p167">
<h2 class="readable-text-h1" id="sigil_toc_id_129"><span class="calibre22">8.6</span> Using the debugger to better understand code</h2>
</div>
<div class="readable-text" id="p168">
<p class="calibre15">We suspect you’re already pretty impressed by the debugger. We are too. When students were taught programming in the traditional manner, a lot of time was spent making sure students could essentially trace through code like a debugger would, drawing out the state of all the variables and updating them with each new line of execution. Indeed, there’s even a free tool on the web called Python Tutor [2] that creates diagrams of the state of memory that can be easier to read than a debugger, just to help new programmers learn how the code executes.</p>
</div>
<div class="readable-text" id="p169">
<p class="calibre15">Whether you like using the debugger or want to use a tool like Python Tutor, we encourage you to play with some of the code you’ve written from earlier sections of the book. In our personal experience working with people learning how to program, walking through a program line by line and watching how the state of variables changes can be a truly enlightening experience, and we hope you’ll appreciate it too.</p>
</div>
<div class="readable-text" id="p170">
<h2 class="readable-text-h1" id="sigil_toc_id_130"><span class="calibre22">8.7</span> A caution about debugging</h2>
</div>
<div class="readable-text" id="p171">
<p class="calibre15">From working with students, we’ve also seen that debugging can be a really frustrating experience for new learners [3]. When learning how to program, everyone wants their code to work, and finding and fixing bugs is time spent when things aren’t working. There are a couple of ways to help overcome this frustration. First, problem decomposition can go a really long way to helping you get code from Copilot that is right without the need for extensive debugging. Second, remember that everyone’s code doesn’t work sometimes, including ours. It’s just a natural part of the programming process and a part that can take some practice. Last, always, and we mean always, test every function you write. More often than not, when our students are really stuck debugging, it’s because there are bugs in multiple functions interacting as a result of not testing each function. When that happens, it’s exceptionally hard to find and remedy the bugs. Debugging interacting bugs is so frustrating that avoiding the experience is a big reason why both of us religiously test every function we write.</p>
</div>
<div class="readable-text" id="p172">
<p class="calibre15">The good news is that if you test every function you write and diligently break down problems into small, manageable steps, you shouldn’t find yourself debugging that often. And, if you do, you’ll be debugging the error in one function, which is what essentially every programmer on the planet does. With some practice, you’ll get the hang of it.</p>
</div>
<div class="readable-text" id="p173">
<h2 class="readable-text-h1" id="sigil_toc_id_131"><span class="calibre22">8.8</span> Exercises</h2>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p174"> You’re given a Python function that is supposed to calculate the sum of all even numbers in a list. However, the function isn’t working correctly. When you call the function with the list <code class="calibre25">[1,</code> <code class="calibre25">2,</code> <code class="calibre25">3,</code> <code class="calibre25">4]</code>, it returns <code class="calibre25">4</code> instead of <code class="calibre25">6</code>: </li>
</ol>
<div class="browsable-container" id="p175">
<div class="readable-text">
<pre class="code-area">def sum_even_numbers(numbers):
    total = 0
    for number in numbers:
        if number % 2 == 0:
            total += number
        else:
            total = 0
    return total</pre>
</div>
</div>
<div class="readable-text" id="p176">
<p class="calibre15">Identify the bug in the <code class="calibre25">sum_even_numbers</code> function, and explain how to fix it. Modify the code to correct the bug, and verify your solution with the provided test case.</p>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p177"><span class="faux-ol-li-counter">2. </span> You’re given a Python function that is supposed to find the maximum number in a list of numbers. However, the function isn’t working as expected. Your task is to determine why the function is working incorrectly, and how you can fix this (hint, think about the possible integer values in the input list): </li>
</ol>
<div class="browsable-container" id="p178">
<div class="readable-text">
<pre class="code-area">def find_max(numbers): 
    max_number = 0 
    for i in range(0, len(numbers)): 
        if numbers[i] &gt; max_number: 
            max_number = numbers[i] 
   return max_number</pre>
</div>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p179"><span class="faux-ol-li-counter">3. </span> You’re given a Python function that is supposed to check if a string is a valid password. A valid password must meet the following criteria: 
    <ol class="calibre48">
<li class="calibre30"> It must be at least 8 characters long. </li>
<li class="calibre30"> It must contain at least one uppercase letter. </li>
<li class="calibre30"> It must contain at least one lowercase letter. </li>
<li class="calibre30"> It must contain at least one digit. </li>
</ol></li>
</ol>
<div class="readable-text" id="p180">
<p class="calibre15">However, the function isn’t working correctly. Determine what is wrong with the function and fix it:</p>
</div>
<div class="browsable-container" id="p181">
<div class="readable-text">
<pre class="code-area">def is_valid_password(password):
    if len(password) &lt;= 8:
        if any(char.isupper() for char in password):
            if any(char.islower() for char in password):
                if any(char.isdigit() for char in password):
                    return True
            return False
        return False
    return False</pre>
</div>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p182"><span class="faux-ol-li-counter">4. </span> You’re writing a Python function to greet users based on the time of day. The function takes an hour (integer between 0 and 23) as input and returns a greeting message (“Good morning”, “Good afternoon”, or “Good evening”): </li>
</ol>
<div class="browsable-container" id="p183">
<div class="readable-text">
<pre class="code-area">def greet_user(hour):
  # This code has an error!
  if hour &lt; 12:
    greeting = "Good morning"
  else:
    greeting = "Good evening"
  return greeting</pre>
</div>
</div>
<div class="readable-text" id="p184">
<p class="calibre15">You’re considering using this prompt to ask Copilot to help you fix the bug: “I have a function to greet users based on the time of day, but it seems to classify noon as ‘Good evening’. Can you help me fix the logic?” The prompt mentions the problem but doesn’t pinpoint the exact error. See if you can edit the provided prompt to make it more specific and guide Copilot toward suggesting the correct fix.</p>
</div>
<div class="readable-text" id="p185">
<h2 class="readable-text-h1" id="sigil_toc_id_132">Summary</h2>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p186"> Debugging is an important skill that includes finding errors in code and then correcting them. </li>
<li class="readable-text1" id="p187"> <code class="calibre25">Print</code> statements can be an effective way of learning about what is happening in your code. </li>
<li class="readable-text1" id="p188"> The VS Code debugger is another way of learning what is happening in your code that provides powerful features for monitoring how variables change as the code executes. </li>
<li class="readable-text1" id="p189"> Once an error is uncovered, there are multiple ways to help Copilot fix the error for you, but if that fails, you can often fix the code directly. </li>
<li class="readable-text1" id="p190"> Our workflow of designing functions now includes debugging, and with the skill of debugging, you’re more apt to write the software you want. </li>
<li class="readable-text1" id="p191"> Outside of debugging, the VS Code debugger can be a powerful tool in learning more about how the code works. </li>
</ul>
</div></body></html>