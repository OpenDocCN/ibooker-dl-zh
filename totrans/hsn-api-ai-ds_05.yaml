- en: Chapter 4\. Developing the FastAPI Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#chapter_3), you created your database and the Python
    code to access the database. In this chapter, you will build on this foundation
    code to create a working API. [Table 4-1](#swc_endpoints_ch4) lists the endpoints
    that you will create to fulfill these user stories.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Endpoints for the SWC Fantasy Football API
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoint description | HTTP verb | URL |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
- en: '| API health check | GET | */* |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
- en: '| Read player list | GET | */v0/players/* |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
- en: '| Read individual player | GET | */v0/players/{player_id}/* |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
- en: '| Read performance list | GET | */v0/performances/* |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: '| Read league list | GET | */v0/leagues/* |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
- en: '| Read individual league | GET | */v0/leagues/{league_id}/* |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: '| Read team list | GET | */v0/teams/* |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| Read counts | GET | */v0/counts/* |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: You are using version 0 for your API. This will notify API consumers that the
    product is changing rapidly and they should be aware of potential *breaking changes*—changes
    that cause functionality to stop working and may require consumers to make changes
    in their program code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Continuing Your Portfolio Project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Figure 4-1](#application_components_ch4) shows the same API components you
    saw previously, with one addition: the Uvicorn web server. Uvicorn will execute
    your API code and interact with API requests.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![API components with Uvicorn](assets/haad_0401.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. API components with Uvicorn
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html#chapter_3), you completed two very important parts
    of the API: the SQLite database and the SQLAlchemy classes that enable Python
    to interact with the data. In this chapter, you will finish the rest of the components.
    You will create Pydantic *schemas* that define the structure of request and response
    messages. Then, you will create the controlling FastAPI application that stitches
    all the other components together to finish the API.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Software Used in This Chapter
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The software introduced in this chapter will focus on handling API requests
    from your consumers. [Table 4-2](#tools_table_chapter_4) lists the new tools you
    will use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. New tools used in this chapter
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '| Software name | Version | Purpose |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| FastAPI | 0 | Web framework to build the API |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| FastAPI CLI | 0 | Command-line interface for FastAPI |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| HTTPX | 0 | HTTP client for Python |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| Pydantic | 2 | Validation library |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| Uvicorn | 0 | Web server to run the API |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: FastAPI
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI is a Python web framework that is designed for building APIs. A *web
    framework* is a set of libraries that simplify common tasks for web applications.
    Other common web frameworks include Express, Flask, Django, and Ruby on Rails.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'FastAPI is built to be fast in both application performance and developer productivity.
    Because FastAPI focuses on API development, it simplifies several tasks related
    to API building and publishing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: It handles HTTP traffic, requests/responses, and other “plumbing” jobs with
    a few lines of code.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It automatically generates an OpenAPI specification file for your API, which
    is useful for integrating with other products.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes interactive documentation for your API.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports API versioning, security, and many other capabilities.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you will see as you work through the portfolio project, all of these capabilities
    provide benefits to the users of your APIs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the other frameworks I mentioned, FastAPI is a relative newcomer.
    It is an open source project created by Sebastián Ramírez Montaño in 2018.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI also includes the FastAPI CLI. This is a separate Python library that
    is used to run FastAPI from the command line.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the latest version of FastAPI is a 0.x version (e.g., 0.115).
    That version number is important because, according to semantic versioning, 0.x
    indicates that breaking changes may occur with the software.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: HTTPX
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTPX is a Python HTTP client. It is similar to the very popular requests library,
    but it supports *asynchronous calls*, which allows some tasks to finish while
    others process. The requests library only supports *synchronous calls*, which
    wait until they receive a response before continuing. HTTPX is used by pytest
    to test FastAPI programs. You will also use this library in [Chapter 7](ch07.html#chapter_7)
    to create your Python SDK.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pydantic is a data validation library, which will play a key part in the APIs
    that you build. Because APIs are used to communicate between systems, a critical
    piece of their functionality is the validation of inputs and outputs. API developers
    and data scientists typically spend a significant amount of time writing the code
    to check the data types and validate values that go into and out of the API endpoints.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Pydantic is purpose-built to address this important task. Pydantic is fast
    in two ways: it saves the developer time that would be spent to write custom Python
    validation code, and Pydantic validation code runs much faster because it is implemented
    in the Rust programming language.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these benefits, objects defined in Pydantic automatically support
    tooltips and hints in IDEs such as VS Code. FastAPI uses Pydantic to generate
    JSON Schema representations from Python code. *JSON Schema* is a standard that
    ensures consistency in JSON data structures. This Pydantic feature enables FastAPI
    to automatically generate the *OpenAPI specification*, which is an industry-standard
    file describing APIs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: For your project, you will use Pydantic version 2.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Uvicorn
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All web applications, including APIs, rely on a web server to handle the various
    administrative tasks related to handling requests and responses. You will be using
    the open source Uvicorn web server. Uvicorn is based on the *ASGI specification*,
    which provides support for both *synchronous processes* (which block the process
    while waiting for a task to be performed) and *asychronous processes* (which can
    allow another process to continue while they are waiting).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: For your project, you will be using Uvicorn 0.x.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Copying Files from Chapter 3
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To continue your portfolio project where you left it in the previous chapter,
    change the directory to *chapter4* and then copy the previous chapter’s files
    over to it. The following shows the commands and expected output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing the New Libraries in Your Codespace
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you created the *requirements.txt* file and specified
    libraries to install using the `pip3` package manager in Python. You will now
    use this process to install Pydantic, FastAPI, and Uvicorn.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Update *requirements.txt* to match the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Execute the following command to install the new libraries in your Codespace
    and verify that the libraries installed in the previous chapter still exist:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see a message that states that these libraries were successfully
    installed, such as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating Python Files for Your API
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be creating two new Python files, which are detailed in [Table 4-3](#file_table_chapter_4).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3\. Purpose of the Chapter 4 files
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '| Filename | Purpose |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| *main.py* | FastAPI file that defines routes and controls API |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| *schemas.py* | Defines the Pydantic classes that validate data sent to the
    API |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| *test_main.py* | The pytest file for the FastAPI program |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: Creating Pydantic Schemas
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pydantic classes define the structure of the data that the consumer will
    receive in their API responses. This uses a software design pattern called *data
    transfer objects* (DTO), in which you define a format for transferring data between
    a producer and consumer, without the consumer needing to know the backend format.
    In your portfolio project, the backend and frontend classes won’t look significantly
    different, but using DTOs allows complete flexibility on this point.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Although you define the classes using Python code and your code interacts with
    them as fully formed Python objects, the consumer will receive them in an HTTP
    request as a JSON object. FastAPI uses Pydantic to perform the *serialization*
    process, which is converting the Python objects into JSON for the API response.
    This means you do not need to manage serialization in your Python code, which
    simplifies your program. Pydantic 2 is written in Rust and performs this task
    much faster than Python could. In addition to performing this de-serialization
    task, Python also defines the response format in the *openapi.json* file. This
    is a standard contract that uses OpenAPI and JSON Schema. This will provide multiple
    benefits for the consumer, as you will see in subsequent chapters. Pydantic will
    take data from SQLAlchemy classes and provide it to the API users.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both SQLAlchemy and Pydantic documentation refer to their classes as models,
    which may be confusing at times. This is extra confusing for data science work,
    where models have additional meanings. For clarity, this book will refer to Pydantic
    schemas and SQLAlchemy models.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file with the following contents, and name it *schemas.py*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The schemas in this file will be used to form the responses to the API endpoints
    that you will define next. The primary schemas are directly returned to the endpoints
    and the secondary schemas are returned as an attribute of the primary schema.
    For example, the */v0/players/* endpoint URL returns a list of `Player` objects
    (primary), which has the attribute `Player.performances` (secondary). [Table 4-4](#schema_endpoint_mapping)
    shows the mapping between API endpoints and schemas.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4\. Mapping of schemas to endpoints
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoint URL | Primary schema | Secondary schema |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| */* | None | None |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| */v0/players/* | Player | Performance |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| */v0/players/{player_id}/* | Player | Performance |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| */v0/performances/* | Performance | None |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| */v0/leagues/* | League | TeamBase |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| */v0/leagues/*{league_id} | League | TeamBase |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| */v0/teams/* | Team | PlayerBase |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| */v0/counts/* | Counts | None |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: 'The `Performance` class is the first and simplest schema:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This class represents the scoring data that the consumer will receive. From
    their perspective, a *performance* is what happens when a player plays in a single
    week. If you compare the elements of this class to the SQLAlchemy models, you
    will see that it contains all of the elements that the `Performance` model contains.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`Performance` is a subclass of the Pydantic `BaseModel` class, which provides
    a lot of built-in capabilities, including validating the data types, converting
    the Python object to JSON (serializing), raising intelligent errors, and connecting
    automatically to the SQLAlchemy models.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the Pydantic data types of individual class elements are assigned
    with a colon, and not an equals sign which is what SQLAlchemy uses. (This will
    trip you up if you’re not careful.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The player data is represented in two schemas: `PlayerBase` and `Player`. Breaking
    the data into two classes allows you to share a limited version of the data in
    some situations and a full version in others. Here are those two schemas:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The performance data had a single `Performance` schema, but the player data
    has two schemas. `PlayerBase` is a subclass of `BaseModel`, and it has all the
    player fields except one: the `Performance` list. [Table 4-4](#schema_endpoint_mapping)
    shows that `PlayerBase` will be used as a secondary schema for the */v0/teams/*
    endpoint. The reason is simple: to reduce the amount of data transmitted in the
    API call. When the API user retries a list of `Team` schemas, they want to see
    all the players on that team without also getting a list of all the scoring performances
    for all the players.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The full `Player` schema is a subclass of `PlayerBase` and adds the list of
    `Performance` objects. This schema is used directly in the */v0/players/* and
    */v0/players/{player_id}/* endpoints. In those situations, the API user wants
    a list of scoring performances with the players.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the secondary use of `PlayerBase`, examine the next two schemas:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Team` object contains the statement `players: List[PlayerBase] = []`.
    As mentioned previously, this means the items in `Team.players` are of the more
    limited `PlayerBase` schema. This is the secondary usage of `PlayerBase` shown
    in [Table 4-4](#schema_endpoint_mapping) in the */v0/teams/* endpoint.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class is the `League` schema:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By now you probably noticed that `League.teams` contains `TeamBase` objects.
    This is the secondary use of `TeamBase` used in the */v0/leagues/* endpoint.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you will create a special-purpose schema to support the analytics
    provided by the *v0/counts/* endpoint. This schema does not directly map to a
    database table, so it does not include the `model_config` element. The name of
    the schema is `Counts`, and it includes the number of league, team, and player
    records in the API:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, you have designed the DTOs that will be used to send data to
    the API consumer. You are ready for the final piece: the FastAPI controller class.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your FastAPI Controller
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that all of the pieces are in place in the other Python files, you can tie
    them together with the FastAPI functionality in *main.py*. You can accomplish
    a lot with only a few lines of FastAPI code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file with the following contents, and name it *main.py*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s walk through the code in your FastAPI file. We’ll begin with the imports:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_developing_the_fastapi_code_CO1-1)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: These are methods from the FastAPI library. You will use these to identify this
    program as a FastAPI application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_developing_the_fastapi_code_CO1-2)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy `Session` will be used when this program calls *crud.py*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_developing_the_fastapi_code_CO1-3)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: You will use the `date` type to query by last changed date.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_developing_the_fastapi_code_CO1-4)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: These imports allow the FastAPI application to reference the SQLAlchemy and
    Pydantic classes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_developing_the_fastapi_code_CO1-5)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: This retrieves the shared `SessionLocal` class that is used to connect to your
    SQLite database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue reviewing the code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In FastAPI, the primary class you will work with is a `FastAPI` class. This
    class by default includes the functionality to handle much of the work that an
    API needs to perform, without requiring you to specify every detail. You create
    a `FastAPI` instance and name it `app`. This will be used in the rest of *main.py*.
    When you execute your API from the command line using Uvicorn, you will reference
    `main:app`, referring to the `app` object in *main.py*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'You define the `get_db()` function to create a database session and close the
    session when you are done with it. This function is used as a dependency in the
    API routes within *main.py*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next command is `@app.get("/")`, which is a *decorator*. A decorator is
    a statement that is added above a function definition, to give special attributes
    to it. In this case, the decorator defines that the `async def root()` function
    definition will be a FastAPI request handler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'This function will be called when a consumer accesses the root URL of the API,
    which is equivalent to `/`. It will serve as a health check for the entire API
    by returning a simple message to the consumer. The next statement defines the
    first endpoint that we have created for your user stories:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remember that [Table 4-1](#swc_endpoints_ch4) defined the endpoints that we
    planned to create as a combination of HTTP verb and URL. With FastAPI these endpoints
    (also called *routes*) are defined with the decorators above each function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The following explains how the HTTP verb and URL are specified in the decorator:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '*HTTP verb*: All of these endpoints use the `GET` verb, which is defined by
    the `@app.get()` decorator function.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*URL*: The first parameter of the `get()` function is the relative URL. For
    this first endpoint, the URL is */v0/players/*.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter of the decorator is `response_model=list[schemas.Player])`.
    This informs FastAPI that the data returned from this endpoint will be a list
    of Pydantic `Player` objects, as defined in the *schemas.py* file. This information
    will be included in the OpenAPI specification that FastAPI automatically creates
    for this API. Consumers can count on the returned data being valid according to
    this definition.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the function signature that you decorated:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Several things are going on in this function. Starting at the end, the `db`
    object is a session that is created by the `get_db()` function defined at the
    top of this file. By wrapping the function in `Depends()`, FastAPI handles the
    call for and gives the `Session` to your function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two parameters are optional integers with a default value: `skip:
    int = 0, limit: int = 100, last_name`. These are followed by two optional string
    parameters that default to `None`. These are all named parameters that have a
    defined data type and a default value. FastAPI will automatically include these
    parameters as query parameters in the API definition. Query parameters are included
    in the URL path with a question mark in front and an ampersand between.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to call this query method, the API consumer could use this request:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*HTTP verb*: GET'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*URL*: *{base URL}/v0/players/?first_name=Bryce&last_name=Young*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the body of the `read_players()` function, FastAPI is calling the `get_players()`
    function that you defined in *crud.py*. It is performing a database query. The
    `players` object receives the result of that function call. FastAPI validates
    that this object matches the definition `list[schemas.Player]`. If it does, FastAPI
    uses Pydantic to serialize the Python objects into a text JSON string and sends
    the response to the consumer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The next endpoint adds two additional FastAPI features:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, the URL path includes `{player_id}`. This is a *path parameter*, which
    is an API request parameter that is included in the URL path instead of being
    separated by question marks and ampersands, like the query parameters. Here is
    an example of how the API consumer might call this endpoint:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '*HTTP verb*: GET'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*URL*: *{base URL}/v0/players/12345?skip=10&limit=50*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function checks to see if any records were returned from the helper function,
    and if not, it raises an *HTTPException*. This is a standard method that web applications
    use to communicate status. It is good RESTful API design to use the standard [HTTP
    status codes](https://oreil.ly/cTnfI) to communicate with consumers. This makes
    the operation more predictable and reliable. This endpoint returns an HTTP status
    code of 404, which is the *not found* code. It adds the additional message that
    the item not found was the player being searched for.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The next four endpoints do not use any new features. But together they complete
    all of the user stories that we have included for your first API:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final endpoint provides counts of leagues, teams, and players:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is worth noting that, in addition to the basic options of FastAPI and Pydantic
    that you are using, many other validations and features are available. As you
    can see, these libraries accomplish a lot with only a few lines of code from you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Testing Your API
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will use pytest to test your *main.py* file. As with the *crud.py* file
    in the previous chapter, you will be testing that the correct number of records
    are returned by each API endpoint. The counts of records can be verified by the
    SQL queries in [“Loading Your Data”](ch03.html#load_your_data).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the tests for your API, create a file with the following contents,
    and name it *test_main.py*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The file begins with import statements and creation of the `TestClient` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_developing_the_fastapi_code_CO2-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '`TestClient` is a special class that allows the FastAPI program to be tested
    without running it on a web server.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_developing_the_fastapi_code_CO2-2)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: This references the FastAPI object you created in *main.py*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_developing_the_fastapi_code_CO2-3)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: This statement creates a `TestClient` that will test your application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at a few of the test functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function uses the `TestClient` to simulate an API call to the root path.
    Then, it checks the HTTP status code for a value of `200`, which means a successful
    request. Next, it looks at the JSON value returned by the API and checks that
    it matches the JSON value provided.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test function adds more functionality:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the URL passed in the `get()` statement uses the `skip` and `limit`
    parameters. The second `assert` statement checks the length of the list of players
    returned by the API to make sure it is exactly 1018.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Another test function tests the search of players by name. Although the database
    does not enforce uniqueness on player names, duplicate player names are rare,
    and names are commonly used to identify players.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'This search without a key supports the design recommended in [Chapter 1](ch01.html#chapter_1)
    for AI:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This adds two `assert` statements: one to make sure only one record was returned
    from this query (after all, there is only one Bryce Young) and another to make
    sure the `player_id` is correct.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete file contains 11 tests in all. To execute the tests, enter the
    following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You have verified that your FastAPI program works with pytest. Now it’s time
    to try it with a web server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Launching Your API
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the moment you have been waiting for: it’s time to run your API. Enter
    the following command from the command line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You will see the application startup occur as shown in [Figure 4-2](#fast_api_run_ch4).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![FastAPI running from command line](assets/haad_0402.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. FastAPI running from the command line
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Codespaces, you will also see a dialog stating “Your application running
    on port 8000 is available,” as shown in [Figure 4-3](#codespaces_api_open_browser4).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Codespaces browser window popup](assets/haad_0403.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Codespaces browser window pop-up
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click “Open in Browser” to open a browser tab outside your Codespaces. This
    browser will show a base URL ending in *app.github.dev* that contains the response
    from your API running on Codespaces. You should see the following health check
    message in your web browser:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This confirms your API is running, which is a great start.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test is to call an endpoint that retrieves data. Give that a try by
    copying and pasting the following onto the end of the base URL in your browser:
    ***/v0/performances/?skip=0&limit=1***. For example, the full URL might be *[*https://happy-pine-tree-1234-8000.app.github.dev/v0/performances/?skip=0&limit=1*](https://happy-pine-tree-1234-8000.app.github.dev/v0/performances/?skip=0&limit=1)*.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is working correctly, you should see the following data in your
    browser:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This chapter covered a lot, so it’s possible that an error occurred or you
    are not getting a successful result. Don’t worry, this happens to all of us. Here
    are a few suggestions for how to troubleshoot any problems you are running into:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Run the **`pip3 install -r requirements.txt`** command again to make sure you
    have all the updated software.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a minute to verify the path in the URL bar of your browser. Minor things
    matter, such as slashes and question marks.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the command line to see any errors that are being thrown by FastAPI.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To verify your environment with FastAPI and Uvicorn, try creating a simple API,
    such as one from the [official FastAPI tutorial](https://oreil.ly/L7QWz).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a formatting error occurs due to text wrapping, check against the files in
    the GitHub repository.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this first API endpoint is working for you, try out some more of the URLs
    from [Table 4-1](#swc_endpoints_ch4) in your browser to verify that you have completed
    all of your user stories. Congratulations, you are an API developer!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个第一个API端点对您有效，请在浏览器中尝试更多[表4-1](#swc_endpoints_ch4)中的URL，以验证您已完成所有用户故事。恭喜您，您已经成为了一名API开发者！
- en: Additional Resources
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: To explore FastAPI beyond this book, the official [FastAPI tutorial](https://oreil.ly/SFN3w)
    and [FastAPI reference documentation](https://oreil.ly/MVgVk) are both very useful.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索FastAPI超出了本书的范围，官方的[FastAPI教程](https://oreil.ly/SFN3w)和[FastAPI参考文档](https://oreil.ly/MVgVk)都非常有用。
- en: 'To learn the ins and outs of building a project with FastAPI, I recommend *FastAPI:
    Modern Python Web Development* by Bill Lubanovic (O’Reilly, 2023).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解使用FastAPI构建项目的方方面面，我推荐Bill Lubanovic的《FastAPI：现代Python Web开发》（O’Reilly，2023）。
- en: For a growing list of practical tips from an official FastAPI Expert, check
    out [Marcelo Trylesinski’s FastAPI Tips](https://oreil.ly/kludex).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取来自官方FastAPI专家的更多实用技巧列表，请查看[Marcelo Trylesinski的FastAPI技巧](https://oreil.ly/kludex)。
- en: The official [Pydantic 2.4 documentation](https://oreil.ly/2OE-8) provides information
    for the specific version of Pydantic used in this chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的[Pydantic 2.4文档](https://oreil.ly/2OE-8)提供了关于本章中使用的Pydantic特定版本的信息。
- en: The official [Uvicorn documentation](https://oreil.ly/uvicorn) has much more
    information about the capabilities of this software.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的[Uvicorn文档](https://oreil.ly/uvicorn)提供了关于此软件功能的更多信息。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you completed the API functionality for the SWC Fantasy Football
    API. You accomplished the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您完成了SWC梦幻足球API的API功能。您实现了以下内容：
- en: You installed FastAPI, SQLAlchemy, Pydantic, and Uvicorn, along with several
    supporting libraries.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已安装了FastAPI、SQLAlchemy、Pydantic和Uvicorn，以及一些支持库。
- en: You defined Pydantic schemas to represent the data that your API consumers wanted
    to receive.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您定义了Pydantic模式来表示API消费者希望接收的数据。
- en: You created a FastAPI program to process consumer requests and return data responses,
    tying everything together.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您创建了一个FastAPI程序来处理消费者请求并返回数据响应，将所有内容串联起来。
- en: You tested the API with pytest and then ran it successfully on the web server.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用pytest测试了API，然后在网络服务器上成功运行。
- en: In [Chapter 5](ch05.html#chapter_5), you will document your API using FastAPI’s
    built-in capabilities.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html#chapter_5)中，您将使用FastAPI的内置功能来记录您的API。
