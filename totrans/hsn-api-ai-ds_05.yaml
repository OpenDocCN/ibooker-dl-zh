- en: Chapter 4\. Developing the FastAPI Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#chapter_3), you created your database and the Python
    code to access the database. In this chapter, you will build on this foundation
    code to create a working API. [Table 4-1](#swc_endpoints_ch4) lists the endpoints
    that you will create to fulfill these user stories.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Endpoints for the SWC Fantasy Football API
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoint description | HTTP verb | URL |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| API health check | GET | */* |'
  prefs: []
  type: TYPE_TB
- en: '| Read player list | GET | */v0/players/* |'
  prefs: []
  type: TYPE_TB
- en: '| Read individual player | GET | */v0/players/{player_id}/* |'
  prefs: []
  type: TYPE_TB
- en: '| Read performance list | GET | */v0/performances/* |'
  prefs: []
  type: TYPE_TB
- en: '| Read league list | GET | */v0/leagues/* |'
  prefs: []
  type: TYPE_TB
- en: '| Read individual league | GET | */v0/leagues/{league_id}/* |'
  prefs: []
  type: TYPE_TB
- en: '| Read team list | GET | */v0/teams/* |'
  prefs: []
  type: TYPE_TB
- en: '| Read counts | GET | */v0/counts/* |'
  prefs: []
  type: TYPE_TB
- en: You are using version 0 for your API. This will notify API consumers that the
    product is changing rapidly and they should be aware of potential *breaking changes*—changes
    that cause functionality to stop working and may require consumers to make changes
    in their program code.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing Your Portfolio Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Figure 4-1](#application_components_ch4) shows the same API components you
    saw previously, with one addition: the Uvicorn web server. Uvicorn will execute
    your API code and interact with API requests.'
  prefs: []
  type: TYPE_NORMAL
- en: '![API components with Uvicorn](assets/haad_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. API components with Uvicorn
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html#chapter_3), you completed two very important parts
    of the API: the SQLite database and the SQLAlchemy classes that enable Python
    to interact with the data. In this chapter, you will finish the rest of the components.
    You will create Pydantic *schemas* that define the structure of request and response
    messages. Then, you will create the controlling FastAPI application that stitches
    all the other components together to finish the API.'
  prefs: []
  type: TYPE_NORMAL
- en: Software Used in This Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The software introduced in this chapter will focus on handling API requests
    from your consumers. [Table 4-2](#tools_table_chapter_4) lists the new tools you
    will use.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. New tools used in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: '| Software name | Version | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| FastAPI | 0 | Web framework to build the API |'
  prefs: []
  type: TYPE_TB
- en: '| FastAPI CLI | 0 | Command-line interface for FastAPI |'
  prefs: []
  type: TYPE_TB
- en: '| HTTPX | 0 | HTTP client for Python |'
  prefs: []
  type: TYPE_TB
- en: '| Pydantic | 2 | Validation library |'
  prefs: []
  type: TYPE_TB
- en: '| Uvicorn | 0 | Web server to run the API |'
  prefs: []
  type: TYPE_TB
- en: FastAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI is a Python web framework that is designed for building APIs. A *web
    framework* is a set of libraries that simplify common tasks for web applications.
    Other common web frameworks include Express, Flask, Django, and Ruby on Rails.
  prefs: []
  type: TYPE_NORMAL
- en: 'FastAPI is built to be fast in both application performance and developer productivity.
    Because FastAPI focuses on API development, it simplifies several tasks related
    to API building and publishing:'
  prefs: []
  type: TYPE_NORMAL
- en: It handles HTTP traffic, requests/responses, and other “plumbing” jobs with
    a few lines of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It automatically generates an OpenAPI specification file for your API, which
    is useful for integrating with other products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes interactive documentation for your API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports API versioning, security, and many other capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you will see as you work through the portfolio project, all of these capabilities
    provide benefits to the users of your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the other frameworks I mentioned, FastAPI is a relative newcomer.
    It is an open source project created by Sebastián Ramírez Montaño in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI also includes the FastAPI CLI. This is a separate Python library that
    is used to run FastAPI from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the latest version of FastAPI is a 0.x version (e.g., 0.115).
    That version number is important because, according to semantic versioning, 0.x
    indicates that breaking changes may occur with the software.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTPX is a Python HTTP client. It is similar to the very popular requests library,
    but it supports *asynchronous calls*, which allows some tasks to finish while
    others process. The requests library only supports *synchronous calls*, which
    wait until they receive a response before continuing. HTTPX is used by pytest
    to test FastAPI programs. You will also use this library in [Chapter 7](ch07.html#chapter_7)
    to create your Python SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pydantic is a data validation library, which will play a key part in the APIs
    that you build. Because APIs are used to communicate between systems, a critical
    piece of their functionality is the validation of inputs and outputs. API developers
    and data scientists typically spend a significant amount of time writing the code
    to check the data types and validate values that go into and out of the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pydantic is purpose-built to address this important task. Pydantic is fast
    in two ways: it saves the developer time that would be spent to write custom Python
    validation code, and Pydantic validation code runs much faster because it is implemented
    in the Rust programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these benefits, objects defined in Pydantic automatically support
    tooltips and hints in IDEs such as VS Code. FastAPI uses Pydantic to generate
    JSON Schema representations from Python code. *JSON Schema* is a standard that
    ensures consistency in JSON data structures. This Pydantic feature enables FastAPI
    to automatically generate the *OpenAPI specification*, which is an industry-standard
    file describing APIs.
  prefs: []
  type: TYPE_NORMAL
- en: For your project, you will use Pydantic version 2.
  prefs: []
  type: TYPE_NORMAL
- en: Uvicorn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All web applications, including APIs, rely on a web server to handle the various
    administrative tasks related to handling requests and responses. You will be using
    the open source Uvicorn web server. Uvicorn is based on the *ASGI specification*,
    which provides support for both *synchronous processes* (which block the process
    while waiting for a task to be performed) and *asychronous processes* (which can
    allow another process to continue while they are waiting).
  prefs: []
  type: TYPE_NORMAL
- en: For your project, you will be using Uvicorn 0.x.
  prefs: []
  type: TYPE_NORMAL
- en: Copying Files from Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To continue your portfolio project where you left it in the previous chapter,
    change the directory to *chapter4* and then copy the previous chapter’s files
    over to it. The following shows the commands and expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing the New Libraries in Your Codespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you created the *requirements.txt* file and specified
    libraries to install using the `pip3` package manager in Python. You will now
    use this process to install Pydantic, FastAPI, and Uvicorn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update *requirements.txt* to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following command to install the new libraries in your Codespace
    and verify that the libraries installed in the previous chapter still exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a message that states that these libraries were successfully
    installed, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating Python Files for Your API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be creating two new Python files, which are detailed in [Table 4-3](#file_table_chapter_4).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3\. Purpose of the Chapter 4 files
  prefs: []
  type: TYPE_NORMAL
- en: '| Filename | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *main.py* | FastAPI file that defines routes and controls API |'
  prefs: []
  type: TYPE_TB
- en: '| *schemas.py* | Defines the Pydantic classes that validate data sent to the
    API |'
  prefs: []
  type: TYPE_TB
- en: '| *test_main.py* | The pytest file for the FastAPI program |'
  prefs: []
  type: TYPE_TB
- en: Creating Pydantic Schemas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pydantic classes define the structure of the data that the consumer will
    receive in their API responses. This uses a software design pattern called *data
    transfer objects* (DTO), in which you define a format for transferring data between
    a producer and consumer, without the consumer needing to know the backend format.
    In your portfolio project, the backend and frontend classes won’t look significantly
    different, but using DTOs allows complete flexibility on this point.
  prefs: []
  type: TYPE_NORMAL
- en: Although you define the classes using Python code and your code interacts with
    them as fully formed Python objects, the consumer will receive them in an HTTP
    request as a JSON object. FastAPI uses Pydantic to perform the *serialization*
    process, which is converting the Python objects into JSON for the API response.
    This means you do not need to manage serialization in your Python code, which
    simplifies your program. Pydantic 2 is written in Rust and performs this task
    much faster than Python could. In addition to performing this de-serialization
    task, Python also defines the response format in the *openapi.json* file. This
    is a standard contract that uses OpenAPI and JSON Schema. This will provide multiple
    benefits for the consumer, as you will see in subsequent chapters. Pydantic will
    take data from SQLAlchemy classes and provide it to the API users.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both SQLAlchemy and Pydantic documentation refer to their classes as models,
    which may be confusing at times. This is extra confusing for data science work,
    where models have additional meanings. For clarity, this book will refer to Pydantic
    schemas and SQLAlchemy models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file with the following contents, and name it *schemas.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The schemas in this file will be used to form the responses to the API endpoints
    that you will define next. The primary schemas are directly returned to the endpoints
    and the secondary schemas are returned as an attribute of the primary schema.
    For example, the */v0/players/* endpoint URL returns a list of `Player` objects
    (primary), which has the attribute `Player.performances` (secondary). [Table 4-4](#schema_endpoint_mapping)
    shows the mapping between API endpoints and schemas.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4\. Mapping of schemas to endpoints
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoint URL | Primary schema | Secondary schema |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| */* | None | None |'
  prefs: []
  type: TYPE_TB
- en: '| */v0/players/* | Player | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| */v0/players/{player_id}/* | Player | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| */v0/performances/* | Performance | None |'
  prefs: []
  type: TYPE_TB
- en: '| */v0/leagues/* | League | TeamBase |'
  prefs: []
  type: TYPE_TB
- en: '| */v0/leagues/*{league_id} | League | TeamBase |'
  prefs: []
  type: TYPE_TB
- en: '| */v0/teams/* | Team | PlayerBase |'
  prefs: []
  type: TYPE_TB
- en: '| */v0/counts/* | Counts | None |'
  prefs: []
  type: TYPE_TB
- en: 'The `Performance` class is the first and simplest schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This class represents the scoring data that the consumer will receive. From
    their perspective, a *performance* is what happens when a player plays in a single
    week. If you compare the elements of this class to the SQLAlchemy models, you
    will see that it contains all of the elements that the `Performance` model contains.
  prefs: []
  type: TYPE_NORMAL
- en: '`Performance` is a subclass of the Pydantic `BaseModel` class, which provides
    a lot of built-in capabilities, including validating the data types, converting
    the Python object to JSON (serializing), raising intelligent errors, and connecting
    automatically to the SQLAlchemy models.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the Pydantic data types of individual class elements are assigned
    with a colon, and not an equals sign which is what SQLAlchemy uses. (This will
    trip you up if you’re not careful.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The player data is represented in two schemas: `PlayerBase` and `Player`. Breaking
    the data into two classes allows you to share a limited version of the data in
    some situations and a full version in others. Here are those two schemas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The performance data had a single `Performance` schema, but the player data
    has two schemas. `PlayerBase` is a subclass of `BaseModel`, and it has all the
    player fields except one: the `Performance` list. [Table 4-4](#schema_endpoint_mapping)
    shows that `PlayerBase` will be used as a secondary schema for the */v0/teams/*
    endpoint. The reason is simple: to reduce the amount of data transmitted in the
    API call. When the API user retries a list of `Team` schemas, they want to see
    all the players on that team without also getting a list of all the scoring performances
    for all the players.'
  prefs: []
  type: TYPE_NORMAL
- en: The full `Player` schema is a subclass of `PlayerBase` and adds the list of
    `Performance` objects. This schema is used directly in the */v0/players/* and
    */v0/players/{player_id}/* endpoints. In those situations, the API user wants
    a list of scoring performances with the players.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the secondary use of `PlayerBase`, examine the next two schemas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Team` object contains the statement `players: List[PlayerBase] = []`.
    As mentioned previously, this means the items in `Team.players` are of the more
    limited `PlayerBase` schema. This is the secondary usage of `PlayerBase` shown
    in [Table 4-4](#schema_endpoint_mapping) in the */v0/teams/* endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class is the `League` schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By now you probably noticed that `League.teams` contains `TeamBase` objects.
    This is the secondary use of `TeamBase` used in the */v0/leagues/* endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you will create a special-purpose schema to support the analytics
    provided by the *v0/counts/* endpoint. This schema does not directly map to a
    database table, so it does not include the `model_config` element. The name of
    the schema is `Counts`, and it includes the number of league, team, and player
    records in the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you have designed the DTOs that will be used to send data to
    the API consumer. You are ready for the final piece: the FastAPI controller class.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your FastAPI Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that all of the pieces are in place in the other Python files, you can tie
    them together with the FastAPI functionality in *main.py*. You can accomplish
    a lot with only a few lines of FastAPI code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file with the following contents, and name it *main.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s walk through the code in your FastAPI file. We’ll begin with the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_developing_the_fastapi_code_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These are methods from the FastAPI library. You will use these to identify this
    program as a FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_developing_the_fastapi_code_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy `Session` will be used when this program calls *crud.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_developing_the_fastapi_code_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: You will use the `date` type to query by last changed date.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_developing_the_fastapi_code_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: These imports allow the FastAPI application to reference the SQLAlchemy and
    Pydantic classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_developing_the_fastapi_code_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This retrieves the shared `SessionLocal` class that is used to connect to your
    SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue reviewing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In FastAPI, the primary class you will work with is a `FastAPI` class. This
    class by default includes the functionality to handle much of the work that an
    API needs to perform, without requiring you to specify every detail. You create
    a `FastAPI` instance and name it `app`. This will be used in the rest of *main.py*.
    When you execute your API from the command line using Uvicorn, you will reference
    `main:app`, referring to the `app` object in *main.py*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You define the `get_db()` function to create a database session and close the
    session when you are done with it. This function is used as a dependency in the
    API routes within *main.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next command is `@app.get("/")`, which is a *decorator*. A decorator is
    a statement that is added above a function definition, to give special attributes
    to it. In this case, the decorator defines that the `async def root()` function
    definition will be a FastAPI request handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function will be called when a consumer accesses the root URL of the API,
    which is equivalent to `/`. It will serve as a health check for the entire API
    by returning a simple message to the consumer. The next statement defines the
    first endpoint that we have created for your user stories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remember that [Table 4-1](#swc_endpoints_ch4) defined the endpoints that we
    planned to create as a combination of HTTP verb and URL. With FastAPI these endpoints
    (also called *routes*) are defined with the decorators above each function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following explains how the HTTP verb and URL are specified in the decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '*HTTP verb*: All of these endpoints use the `GET` verb, which is defined by
    the `@app.get()` decorator function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*URL*: The first parameter of the `get()` function is the relative URL. For
    this first endpoint, the URL is */v0/players/*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter of the decorator is `response_model=list[schemas.Player])`.
    This informs FastAPI that the data returned from this endpoint will be a list
    of Pydantic `Player` objects, as defined in the *schemas.py* file. This information
    will be included in the OpenAPI specification that FastAPI automatically creates
    for this API. Consumers can count on the returned data being valid according to
    this definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the function signature that you decorated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Several things are going on in this function. Starting at the end, the `db`
    object is a session that is created by the `get_db()` function defined at the
    top of this file. By wrapping the function in `Depends()`, FastAPI handles the
    call for and gives the `Session` to your function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two parameters are optional integers with a default value: `skip:
    int = 0, limit: int = 100, last_name`. These are followed by two optional string
    parameters that default to `None`. These are all named parameters that have a
    defined data type and a default value. FastAPI will automatically include these
    parameters as query parameters in the API definition. Query parameters are included
    in the URL path with a question mark in front and an ampersand between.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to call this query method, the API consumer could use this request:'
  prefs: []
  type: TYPE_NORMAL
- en: '*HTTP verb*: GET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*URL*: *{base URL}/v0/players/?first_name=Bryce&last_name=Young*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the body of the `read_players()` function, FastAPI is calling the `get_players()`
    function that you defined in *crud.py*. It is performing a database query. The
    `players` object receives the result of that function call. FastAPI validates
    that this object matches the definition `list[schemas.Player]`. If it does, FastAPI
    uses Pydantic to serialize the Python objects into a text JSON string and sends
    the response to the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next endpoint adds two additional FastAPI features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the URL path includes `{player_id}`. This is a *path parameter*, which
    is an API request parameter that is included in the URL path instead of being
    separated by question marks and ampersands, like the query parameters. Here is
    an example of how the API consumer might call this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '*HTTP verb*: GET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*URL*: *{base URL}/v0/players/12345?skip=10&limit=50*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function checks to see if any records were returned from the helper function,
    and if not, it raises an *HTTPException*. This is a standard method that web applications
    use to communicate status. It is good RESTful API design to use the standard [HTTP
    status codes](https://oreil.ly/cTnfI) to communicate with consumers. This makes
    the operation more predictable and reliable. This endpoint returns an HTTP status
    code of 404, which is the *not found* code. It adds the additional message that
    the item not found was the player being searched for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next four endpoints do not use any new features. But together they complete
    all of the user stories that we have included for your first API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The final endpoint provides counts of leagues, teams, and players:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that, in addition to the basic options of FastAPI and Pydantic
    that you are using, many other validations and features are available. As you
    can see, these libraries accomplish a lot with only a few lines of code from you.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Your API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will use pytest to test your *main.py* file. As with the *crud.py* file
    in the previous chapter, you will be testing that the correct number of records
    are returned by each API endpoint. The counts of records can be verified by the
    SQL queries in [“Loading Your Data”](ch03.html#load_your_data).
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the tests for your API, create a file with the following contents,
    and name it *test_main.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The file begins with import statements and creation of the `TestClient` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_developing_the_fastapi_code_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestClient` is a special class that allows the FastAPI program to be tested
    without running it on a web server.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_developing_the_fastapi_code_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This references the FastAPI object you created in *main.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_developing_the_fastapi_code_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement creates a `TestClient` that will test your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at a few of the test functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the `TestClient` to simulate an API call to the root path.
    Then, it checks the HTTP status code for a value of `200`, which means a successful
    request. Next, it looks at the JSON value returned by the API and checks that
    it matches the JSON value provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test function adds more functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the URL passed in the `get()` statement uses the `skip` and `limit`
    parameters. The second `assert` statement checks the length of the list of players
    returned by the API to make sure it is exactly 1018.
  prefs: []
  type: TYPE_NORMAL
- en: Another test function tests the search of players by name. Although the database
    does not enforce uniqueness on player names, duplicate player names are rare,
    and names are commonly used to identify players.
  prefs: []
  type: TYPE_NORMAL
- en: 'This search without a key supports the design recommended in [Chapter 1](ch01.html#chapter_1)
    for AI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds two `assert` statements: one to make sure only one record was returned
    from this query (after all, there is only one Bryce Young) and another to make
    sure the `player_id` is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete file contains 11 tests in all. To execute the tests, enter the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You have verified that your FastAPI program works with pytest. Now it’s time
    to try it with a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Your API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the moment you have been waiting for: it’s time to run your API. Enter
    the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You will see the application startup occur as shown in [Figure 4-2](#fast_api_run_ch4).
  prefs: []
  type: TYPE_NORMAL
- en: '![FastAPI running from command line](assets/haad_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. FastAPI running from the command line
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Codespaces, you will also see a dialog stating “Your application running
    on port 8000 is available,” as shown in [Figure 4-3](#codespaces_api_open_browser4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Codespaces browser window popup](assets/haad_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Codespaces browser window pop-up
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click “Open in Browser” to open a browser tab outside your Codespaces. This
    browser will show a base URL ending in *app.github.dev* that contains the response
    from your API running on Codespaces. You should see the following health check
    message in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This confirms your API is running, which is a great start.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test is to call an endpoint that retrieves data. Give that a try by
    copying and pasting the following onto the end of the base URL in your browser:
    ***/v0/performances/?skip=0&limit=1***. For example, the full URL might be *[*https://happy-pine-tree-1234-8000.app.github.dev/v0/performances/?skip=0&limit=1*](https://happy-pine-tree-1234-8000.app.github.dev/v0/performances/?skip=0&limit=1)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is working correctly, you should see the following data in your
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This chapter covered a lot, so it’s possible that an error occurred or you
    are not getting a successful result. Don’t worry, this happens to all of us. Here
    are a few suggestions for how to troubleshoot any problems you are running into:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the **`pip3 install -r requirements.txt`** command again to make sure you
    have all the updated software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a minute to verify the path in the URL bar of your browser. Minor things
    matter, such as slashes and question marks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the command line to see any errors that are being thrown by FastAPI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To verify your environment with FastAPI and Uvicorn, try creating a simple API,
    such as one from the [official FastAPI tutorial](https://oreil.ly/L7QWz).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a formatting error occurs due to text wrapping, check against the files in
    the GitHub repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this first API endpoint is working for you, try out some more of the URLs
    from [Table 4-1](#swc_endpoints_ch4) in your browser to verify that you have completed
    all of your user stories. Congratulations, you are an API developer!
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore FastAPI beyond this book, the official [FastAPI tutorial](https://oreil.ly/SFN3w)
    and [FastAPI reference documentation](https://oreil.ly/MVgVk) are both very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn the ins and outs of building a project with FastAPI, I recommend *FastAPI:
    Modern Python Web Development* by Bill Lubanovic (O’Reilly, 2023).'
  prefs: []
  type: TYPE_NORMAL
- en: For a growing list of practical tips from an official FastAPI Expert, check
    out [Marcelo Trylesinski’s FastAPI Tips](https://oreil.ly/kludex).
  prefs: []
  type: TYPE_NORMAL
- en: The official [Pydantic 2.4 documentation](https://oreil.ly/2OE-8) provides information
    for the specific version of Pydantic used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The official [Uvicorn documentation](https://oreil.ly/uvicorn) has much more
    information about the capabilities of this software.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you completed the API functionality for the SWC Fantasy Football
    API. You accomplished the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You installed FastAPI, SQLAlchemy, Pydantic, and Uvicorn, along with several
    supporting libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You defined Pydantic schemas to represent the data that your API consumers wanted
    to receive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You created a FastAPI program to process consumer requests and return data responses,
    tying everything together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You tested the API with pytest and then ran it successfully on the web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html#chapter_5), you will document your API using FastAPI’s
    built-in capabilities.
  prefs: []
  type: TYPE_NORMAL
