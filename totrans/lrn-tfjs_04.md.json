["```py\n// creating our first tensor constdataArray=[8,6,7,5,3,0,9]constfirst=tf.tensor(dataArray)![1](assets/1.png)// does the same thing constfirst_again=tf.tensor1d(dataArray)![2](assets/2.png)\n```", "```py\n// creating a 'float32' tensor (the default) constfirst=tf.tensor([1.1,2.2,3.3],null,'float32')![1](assets/1.png)// an 'int32' tensor constfirst_again=tf.tensor([1,2,3],null,'int32')![2](assets/2.png)// inferred type for boolean constthe_truth=tf.tensor([true,false,false])![3](assets/3.png)// Guess what this does constguess=tf.tensor([true,false,false],null,'int32')![4](assets/4.png)// What about this? constguess_again=tf.tensor([1,3.141592654,false])![5](assets/5.png)\n```", "```py\nconstsecond=tf.tensor1d([8,6,7,5,3,0,9])![1](assets/1.png)// Whoopsie! try{constnope=tf.tensor1d([[1],[2]])![2](assets/2.png)}catch(e){console.log(\"That's a negative Ghost Rider\")}console.log(\"Rank:\",second.rank)![3](assets/3.png)console.log(\"Size:\",second.size)![4](assets/4.png)console.log(\"Data Type:\",second.dtype)![5](assets/5.png)\n```", "```py\n// This code creates a 1D `Float32` tensor consta=tf.tensor([1,0,0,0,-1,0,1,0,0])// This code creates a 2D `Float32` tensor constb=tf.tensor([[1,0,0],[0,-1,0],[1,0,0]])// This does the same as the above but with a 1D input // array that is converted into a 2D `Float32` tensor constc=tf.tensor([1,0,0,0,-1,0,1,0,0],[3,3])![1](assets/1.png)// This code turns the 1D input array into a 2D Int32 tensor constd=tf.tensor([1,0,0,0,-1,0,1,0,0],[3,3],'int32')![2](assets/2.png)\n```", "```py\n/* Check the number of tensors in memory\n*  and the footprint size.\n*  Both of these logs should be zero.\n*/\nconsole.log(tf.memory().numTensors)\nconsole.log(tf.memory().numBytes)\n\n// Now allocate a tensor\nlet speedy = tf.tensor([1,2,3])\n// remove reference for JS\nspeedy = null\n\n/* No matter how long we wait\n*  this tensor is going to be there,\n*  until you refresh the page/server.\n*/\nconsole.log(tf.memory().numTensors)\nconsole.log(tf.memory().numBytes)\n```", "```py\n0\n0\n1\n12\n```", "```py\n// Start at zero tensors console.log('start',tf.memory().numTensors)letkeeper,chaser,seeker,beater// Now we'll create tensors inside a tidy tf.tidy(()=>{![1](assets/1.png)keeper=tf.tensor([1,2,3])chaser=tf.tensor([1,2,3])seeker=tf.tensor([1,2,3])beater=tf.tensor([1,2,3])// Now we're at four tensors in memory ![2](assets/2.png)console.log('inside tidy',tf.memory().numTensors)// protect a tensor\ntf.keep(keeper)// returned tensors survive\nreturnchaser})// Down to two ![3](assets/3.png)console.log('after tidy',tf.memory().numTensors)keeper.dispose()![4](assets/4.png)chaser.dispose()![5](assets/5.png)// Back to zero console.log('end',tf.memory().numTensors)\n```", "```py\nconst tensorArray = []\nfor (let i = 0; i < 10; i++) {\n  tensorArray.push(tf.tensor([i, i, i]))\n}\n```", "```py\nconstsnap=tf.tensor([1,2,3])constcrackle=tf.tensor([3.141592654])constpop=tf.tensor([[1,2,3],[4,5,6]])// this will show the structure but not the data console.log(snap)![1](assets/1.png)// this will print the data but not the tensor structure crackle.print()![2](assets/2.png)// Now let's go back to JavaScript console.log('Welcome Back Array!',pop.arraySync())![3](assets/3.png)console.log('Welcome Back Typed!',pop.dataSync())![4](assets/4.png)// clean up our remaining tensors! tf.dispose([snap,crackle,pop])\n```", "```py\n{\n  \"kept\": false,\n  \"isDisposedInternal\": false,\n  \"shape\": [\n    3\n  ],\n  \"dtype\": \"float32\",\n  \"size\": 3,\n  \"strides\": [],\n  \"dataId\": {},\n  \"id\": 4,\n  \"rankType\": \"1\",\n  \"scopeId\": 4\n}\n```", "```py\nTensor\n    [3.1415927]\n```", "```py\nWelcome Back Array!\n[\n  [\n    1,\n    2,\n    3\n  ],\n  [\n    4,\n    5,\n    6\n  ]\n]\n```", "```py\nWelcome Back Typed!\n{\n  \"0\": 1,\n  \"1\": 2,\n  \"2\": 3,\n  \"3\": 4,\n  \"4\": 5,\n  \"5\": 6\n}\n```", "```py\n  const mat1 = [\n    [91, 82, 13],\n    [15, 23, 62],\n    [25, 66, 63]\n  ]\n\n  const mat2 = [\n    [1, 23, 83],\n    [33, 12, 5],\n    [7, 23, 61]\n  ]\n\n  tf.matMul(mat1, mat2).print()\n```", "```py\nconstusers=['Gant','Todd','Jed','Justin']![1](assets/1.png)constbands=[![2](assets/2.png)'Nirvana','Nine Inch Nails','Backstreet Boys','N Sync','Night Club','Apashe','STP']constfeatures=[![3](assets/3.png)'Grunge','Rock','Industrial','Boy Band','Dance','Techno']// User votes ![4](assets/4.png)constuser_votes=tf.tensor([[10,9,1,1,8,7,8],[6,8,2,2,0,10,0],[0,2,10,9,3,7,0],[7,4,2,3,6,5,5]])// Music Styles ![5](assets/5.png)constband_feats=tf.tensor([[1,1,0,0,0,0],[1,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,0,0],[0,0,1,0,0,1],[0,0,1,0,0,1],[1,1,0,0,0,0]])\n```", "```py\n// User's favorite styles\nconst user_feats = tf.matMul(user_votes, band_feats)\n// Print the answers\nuser_feats.print()\n```", "```py\nTensor\n    [[27, 18, 24, 2 , 1 , 15],\n     [14, 6 , 18, 4 , 2 , 10],\n     [2 , 0 , 12, 20, 10, 10],\n     [16, 12, 15, 5 , 2 , 11]]\n```", "```py\n// Let's make them pretty consttop_user_features=tf.topk(user_feats,features.length)// Back to JavaScript consttop_genres=top_user_features.indices.arraySync()![1](assets/1.png)// print the results users.map((u,i)=>{constrankedCategories=top_genres[i].map(v=>features[v])![2](assets/2.png)console.log(u,rankedCategories)})\n```", "```py\nGant\n[\n  \"Grunge\",\n  \"Industrial\",\n  \"Rock\",\n  \"Techno\",\n  \"Boy Band\",\n  \"Dance\"\n]\nTodd\n[\n  \"Industrial\",\n  \"Grunge\",\n  \"Techno\",\n  \"Rock\",\n  \"Boy Band\",\n  \"Dance\"\n]\nJed\n[\n  \"Boy Band\",\n  \"Industrial\",\n  \"Dance\",\n  \"Techno\",\n  \"Grunge\",\n  \"Rock\"\n]\nJustin\n[\n  \"Grunge\",\n  \"Industrial\",\n  \"Rock\",\n  \"Techno\",\n  \"Boy Band\",\n  \"Dance\"\n]\n```", "```py\n// Clean up the duplicates\nconst callMeMaybe = tf.tensor([8367677, 4209111, 4209111, 8675309, 8367677])\n```"]