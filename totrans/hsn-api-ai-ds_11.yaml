- en: Chapter 9\. Using APIs for Data Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your eyes see the game much better than the numbers. But the numbers see *all*
    the games.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dean Oliver, sports statistician
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The sports world loves all forms of *data analytics*—charts, graphs, and statistics
    that describe the results of events or predict what will happen next. When a sports
    fan views those data analytics, they probably never consider what data source
    was used to create them. In many cases, the data source is an API. In this chapter,
    you will learn best practices for consuming APIs and creating data analytics products
    using Jupyter Notebooks, a popular tool used by data scientists.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Metrics for Sports Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most celebrated forms of analytics is the *custom metric*, a calculation
    that summarizes complicated behavior, ability, and outcomes as a number. Every
    sport has metrics that players, coaches, managers, and fans pay attention to.
    Baseball has the longest history with metrics, from the historical *earned run
    average* (ERA) to the modern *weighted runs created plus* (wRC+) and *wins against
    replacement* (WAR). Soccer fans and professionals alike focus on the *expected
    goals* (xG), a method of defining quality shots that has motivated a variety of
    [secret-sauce models](https://oreil.ly/HHSL0). The NBA uses the *player efficiency
    rating* (PER) to measure a basketball player’s all-around value.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most interesting work in custom metrics is happening in football,
    where the NFL has sponsored an annual analytics contest called the [Big Data Bowl](https://oreil.ly/5h1RE),
    where data students and professionals research and propose new metrics for prizes,
    job prospects, and the excitement of seeing their work included in TV broadcasts.
    It has a special track devoted to creating new custom metrics, such as *converted
    tackle opportunity* and *path analysis via swarm-tackle accuracy* (PASTA). Some
    have made their way into the broadcast booth, and more are on the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every custom metric requires a few components to succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: Question
  prefs: []
  type: TYPE_NORMAL
- en: 'What question is it trying to solve? It should be general enough to have broad
    application but specific enough to add new knowledge to the sport. For example,
    the [KenPom ranking](https://oreil.ly/2MIk3) answers the question: which college
    basketball teams deserve to make the NCAA tournament field?'
  prefs: []
  type: TYPE_NORMAL
- en: Theory
  prefs: []
  type: TYPE_NORMAL
- en: By choosing specific numbers to measure and weighing them against each other,
    you make a value judgment. You are proposing subcomponents that matter to answer
    a question.
  prefs: []
  type: TYPE_NORMAL
- en: Valid approach
  prefs: []
  type: TYPE_NORMAL
- en: Do the underlying calculations support the purpose of the metric?
  prefs: []
  type: TYPE_NORMAL
- en: Data source
  prefs: []
  type: TYPE_NORMAL
- en: Can you get data to calculate the metric at a reasonable frequency? If data
    isn’t available, your approach and the supporting theory may have to be adjusted
    out of practicality.
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs: []
  type: TYPE_NORMAL
- en: This is the fun part. The more interesting the name, the more impact it can
    have.
  prefs: []
  type: TYPE_NORMAL
- en: Using APIs as Data Sources for Fantasy Custom Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fantasy sports enthusiasts love analytics and metrics too. Fantasy league websites
    provide a lot of stats and charts, but commissioners and managers sometimes want
    to create their own. Since the fantasy league data is updated frequently, an automated
    process is key to making the calculations repeatable and consistent. To gather
    this data in software code, two primary choices are available: APIs or *web scraping*.
    Web scraping involves using program code to read the HTML from a website page
    and extract the data. The technique is powerful but brittle: every time the website
    structure changes, the web scraper code stops working and has to be modified and
    tested again. But if the league website maintains an API, the data is available
    even when changes to the layout or structure of the web page occur.'
  prefs: []
  type: TYPE_NORMAL
- en: A web search turns up various examples of fantasy managers who share their custom
    metrics for others to use. The most feature-rich metric I have found is the [Leeger
    Python library](https://oreil.ly/leegpy), which is maintained by software engineer
    Joey Greco. It is an open source project that generates custom metrics from six
    fantasy football websites. Appropriate for this chapter, Leeger uses APIs heavily.
  prefs: []
  type: TYPE_NORMAL
- en: You read some of Joey’s advice about SDKs in [Chapter 7](ch07.html#chapter_7).
    I talked to him about how he uses APIs to create metrics with Leeger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Leeger app that Joey created contains dozens of custom metrics that are
    calculated from data extracted from league website APIs. They have entertaining
    names, such as Adjusted Team Luck and Smart Wins. Here is the calculation behind
    the AWAL stat that Greco mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a Custom Metric: The Shark League Score'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it’s your turn to create a custom metric: the Shark League Score. [Figure 9-1](#ch9_architecture_jupyter)
    shows the high-level architecture of the project you will create in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![High-level architecture](assets/haad_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. High-level architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The question it seeks to answer is: “How tough is our fantasy league?” A real
    fantasy shark is a manager who knows their stuff: they are prepared for the draft,
    they scour the waiver wire for the best players, and they always seem to start
    the right lineup. A league filled with owners like this is a Shark League, and
    making the playoffs in this type of league is a badge of honor. Winning a title
    in a Shark League—​that is a victory to savor for a lifetime.'
  prefs: []
  type: TYPE_NORMAL
- en: The theory of the Shark League Score is based on a few attributes of efficient
    managers. First, Shark Leagues should be balanced from top to bottom—​there should
    be no easy weeks on the schedule. Second, the league as a whole should be picking
    up the best players and getting them in rosters to score points. One supporting
    theory is that fantasy regular season stats (usually weeks 1 through 14) are more
    appropriate than fantasy playoffs (week 15 and beyond) because all teams are playing.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few additional items that could arguably be included but are not
    supported by the SportsWorldCentral API. For instance, a Shark League should rarely
    or never have an empty roster spot in the weekly starters. Another sign of efficient
    owners is picking up the “hot free agents” before they have their big weeks—​that
    would be especially tricky to measure.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you go through the examples in this chapter, you will develop the Shark
    League Score, as well as two supporting metrics: the League Balance Score and
    League Juice Score. It’s time to get started!'
  prefs: []
  type: TYPE_NORMAL
- en: Software Used in This Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Table 9-1](#tools_table_chapter_9) lists a few of the software components
    you will begin using in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Key tools or services used in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: '| Software name | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| backoff | Python library for adding backoff and retry to web calls |'
  prefs: []
  type: TYPE_TB
- en: '| httpx | Python library for making web calls |'
  prefs: []
  type: TYPE_TB
- en: '| Jupyter Notebooks | Interactive data science environment |'
  prefs: []
  type: TYPE_TB
- en: '| pandas | Data analysis and formatting library |'
  prefs: []
  type: TYPE_TB
- en: httpx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python library you will use for calling APIs is httpx. This library is very
    similar to the popular requests library but also supports asynchronous API calls.
    For more information about httpx, read [Chapter 4](ch04.html#chapter_4).
  prefs: []
  type: TYPE_NORMAL
- en: You will use version 27.x of httpx to stay consistent with the version used
    in [Part I](part01.html#part_1).
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter Notebooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jupyter Notebooks support a unique way to perform data science. This mode is
    called *interactive computing*, and it allows you to mix code cells, Markdown
    comment cells, and results. Cells flow from the top of a notebook to the bottom,
    and variables and libraries that have been run previously are available to cells
    that run later. (If you run cells only sequentially, that would mean the cells
    below, but you can run cells out of order.) In addition to this interactive mode,
    Jupyter Notebooks also provide Markdown cells that run between code cells, which
    allows you to create richly formatted documents that interweave code, results,
    and documentation. The notebook style of programming is heavily used by data scientists,
    who value its ability to store the results of prior work along with the code that
    went into creating it.
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter Notebooks are supported out of the box with the default VS Code installation
    in your GitHub Codespace. You will run notebooks directly in VS Code by creating
    a file with the *.ipynb* extension. Project Jupyter has many more options and
    features beyond what you will learn in this chapter; you can learn more about
    them at the [Jupyter project home page](https://jupyter.org).
  prefs: []
  type: TYPE_NORMAL
- en: You will use the default version of Jupyter that comes installed in Codespaces.
  prefs: []
  type: TYPE_NORMAL
- en: pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For data scientists using Python, one of the most trusted libraries is pandas.
    For data scientists, it is one of the first imports you include in almost any
    Python program. The pandas library provides Python a data type called a `DataFrame`,
    which is a two-dimensional structure with rows and columns. This spreadsheet-like
    format is a natural way of viewing data in rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: The library also provides many methods for data manipulation, filtering, and
    formatting. As mentioned in [Chapter 1](ch01.html#chapter_1) of this book, data
    scientists spend more than one-third of their time preparing and cleansing data.
    The pandas library is a powerful tool for this type of work. The [official pandas
    user guide](https://oreil.ly/X4vXa) is a great reference for this library.
  prefs: []
  type: TYPE_NORMAL
- en: You will use the default version of pandas that comes installed in GitHub Codespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the New Libraries in Your Codespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install the libraries you need for this chapter, create a file named *chapter9/requirements.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Update *chapter9/requirements.txt* with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the standard Python logging module.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_for_data_analytics_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This library provides backoff and retry functionality for API calls. See [Chapter 7](ch07.html#chapter_7)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to install the new libraries in your Codespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should see a message that states that these libraries were successfully
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Your API in Codespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access your API data, you will need to launch v0.2 of your API in the terminal.
    For instructions, read [“Running the SportsWorldCentral (SWC) API Locally”](ch08.html#sportsworldcentral).
    Copy the URL of your API from the browser address bar to use as the base URL in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API Client File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will create a standalone Python file to make all calls to your API. By maintaining
    this file separate from the Jupyter Notebook, you keep special API-related logic
    in one place and make it available to multiple notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: You will use the backoff library to implement exponential backoff and retry
    with jitter, which makes your API calls more reliable without overwhelming the
    source API. You use the HTTPX client in a context manager style. [Chapter 7](ch07.html#chapter_7)
    uses these techniques and a few more to create a full-featured Python SDK. Using
    SDKs when available is also helpful for Jupyter Notebooks, but for this chapter,
    you will add most of the features yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Version 0.2 of the API has several new endpoints that you didn’t create in [Part I](part01.html#part_1).
    To explore the format of the new endpoints, access the interactive API docs using
    Swagger UI at the */docs* endpoint on your API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python file in the terminal as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Update *swc_simple_client.py* with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The URL endpoints are set as variables that can be used when calling the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_for_data_analytics_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement gets a reference to the log file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_for_data_analytics_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This decorator adds backoff and retry functionality to the `call_api_endpoint`
    function. For more information about the settings, see the [backoff documentation](https://oreil.ly/c_4yV).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_apis_for_data_analytics_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to pass in parameters to the API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_using_apis_for_data_analytics_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement uses the HTTPX client in a resource manager style, which makes
    the API call and then cleans up resources when it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_using_apis_for_data_analytics_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement logs the data in the API response for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_using_apis_for_data_analytics_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: If errors occur, they are logged with an `ERROR` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_using_apis_for_data_analytics_CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: In case of error, the client returns an `httpx.response` object with the error
    code and message.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Jupyter Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, run the following commands in the Terminal window at the bottom
    of the screen to create the new directory and the Jupyter Notebook you will be
    using in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you open the *chapter9/notebooks* folder in the Explorer on the left, you
    should see *shark_league_notebook.ipynb*. Click to open it. As shown in [Figure 9-2](#shark_notebook_chapter_9),
    you will see a blank cell. A Jupyter Notebook is made up of cells like these that
    you can fill with software code to run commands or Markdown-formatted text to
    provide context and explanation for the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the top-right of the file you will see Select Kernel, as shown in [Figure 9-2](#shark_notebook_chapter_9).
  prefs: []
  type: TYPE_NORMAL
- en: '![New notebook file](assets/haad_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. New notebook file
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click Select Kernel. Codespaces should prompt you to “Install/Enable suggested
    extensions Python + Jupyter” as shown in [Figure 9-3](#install_extensions_ch9).
    Select “Install/Enable suggested extensions Python + Jupyter.” Click Install in
    the additional pop-up window, if prompted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Install/enable extensions](assets/haad_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. Install/enable extensions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After the installation completes, the title of the window will change to Select
    Another Kernel and you will see the choice Python Environments. Select Python
    Environments.
  prefs: []
  type: TYPE_NORMAL
- en: The title of the window will change to “Select a Python Environment.” One Python
    version should be listed with a star next to it and the label Recommended—select
    this Python version.
  prefs: []
  type: TYPE_NORMAL
- en: Adding General Configuration to Your Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The beginning of your notebook will contain general configuration and setup.
    Hover your cursor above the empty Python cell and click +Markdown to create a
    new Markdown cell. Enter the following title in the Markdown cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run this cell by clicking the play icon on the left of the cell or by pressing
    Shift-Enter. You should see your message formatted as a title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover your cursor below this cell and click “+Code” to create a new Python
    cell. Enter the following code in the Python cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This references the Python file you created named *swc_simple_client.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Placing all the imports at the top of your notebook helps keep track of the
    libraries you are using. These imports will work for all the cells in this Jupyter
    Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Jupyter Notebooks are executed top to bottom. Although the output of Jupyter
    Notebooks is saved between sessions, the variables and imported libraries are
    not. When you start a coding session, select Execute Above Cells to rerun all
    the cells above the one you are using.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 8](ch08.html#chapter_8), logging is an important component
    of working with APIs. You will configure a log file named *shark_notebook.log*
    to store the logging messages that are generated in your notebook. These log files
    are excluded by your repository’s *.gitignore* file, so they will not be committed
    to your repository, which is a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another Markdown cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement removes any existing logging handlers configured by Codespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_for_data_analytics_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This sets the logging level to record in the log. Review [Table 7-1](ch07.html#python_logging_levels_ch7)
    for more details about Python logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code cell will contain shared variables, which are good to add after
    the import statements. In this notebook, you set a reusable variable for the base
    URL of the API and created string constants with the API endpoints. These two
    steps make the purpose of API calls clearer and help avoid manual typing errors.
    These will be available to all the cells in the notebook. Add another Markdown
    cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the quotations, you should put the base URL of the API running locally
    on Codespaces, without the backslash, for example, *https://fluffy-⁠lemur-12345-​8000.app.github.dev*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Your API Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next several cells use the imported `call_api_endpoint()` function to call
    the API and get an `httpx.Response` object. Then, they extract the API data using
    `Response.json()` and store it in a pandas DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a Markdown cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code retrieves the maximum scores for SportsWorldCentral leagues based
    on custom scoring types, which will be used for the League Juice Score. Highly
    custom values like these are examples of data that is best retrieved from the
    website’s API. Although you could potentially estimate the total possible points
    using public NFL scoring data, it would take a lot of effort and would likely
    be slightly different from the final totals the website calculates. Since the
    website makes this available, you can easily get an exact match to the league
    totals.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From this point, the contents of the code cell and the output will be displayed
    together. The code will be on top and the output will follow the `OUTPUT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This extracts the data in a dictionary format and creates a `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_for_data_analytics_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This uses the pandas `str.slice` method to get the year substring from the `week_number`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_for_data_analytics_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This uses the pandas `groupby().agg()` method to group the data by year and
    calculate the maximum points for two of the league types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll retrieve the league information. Add a Markdown cell with this
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement uses the pandas `drop` method to exclude columns from the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will retrieve the total scoring for each league to compare to the
    max potential. Add a Markdown cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This section of code includes two techniques that are useful when using pandas
    to process API data. The SportsWorldCentral API returns JSON data with several
    nested dictionaries in the `weekly_scores` element, but you want to have one row
    per week. You also want to get multiple columns out of the nested column. You
    will use the pandas `json_normalize()` function to accomplish these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This section also introduces the pandas `groupby().sum()` method, which is similar
    to the SQL `GROUP BY` statement. You will use this to total up all of the weekly
    scoring values and give a total for the entire fantasy regular season. (The NFL
    plays 18 weeks, but SportsWorldCentral considers weeks 1 through 14 the fantasy
    regular season, and the rest are the playoffs.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The pandas `json_normalize()` function breaks the nested JSON data into multiple
    rows and extracts new columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_for_data_analytics_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The pandas `str.slice()` method is used to extract the `year` and `week` values
    from the `week_number` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_for_data_analytics_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This `groupby` statement sums the fantasy points by league, team, and year.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the League Balance Score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the data loading and formatting out of the way, you can calculate your
    first metric: the League Balance Score. The intuition behind this metric is that
    a high-quality league is a balanced league. Instead of being dominated by one
    or two top teams, the league has a balance of teams that are all competitive.'
  prefs: []
  type: TYPE_NORMAL
- en: A balanced league has less variability among the team’s regular season totals.
    One way to measure for variability is to calculate the *standard deviation* of
    the values. However, leagues with high scoring systems tend to have a higher variability,
    making it difficult to compare leagues with different scoring systems. To adjust
    for this, you’ll use the *coefficient of variation* (CV) of each league’s regular
    season total scores. This takes the *standard deviation* of the league’s totals
    and divides it by the *mean* of the totals.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives you a measure of relative variability between the values that adjusts
    for the overall scoring system. The reason CV works for this situation is that
    it is *dimensionless*, which means it can be compared across values of difference
    sizes—​scoring systems in this case. Here is the exact formula you will use:'
  prefs: []
  type: TYPE_NORMAL
- en: $upper L e a g u e upper B a l a n c e upper S c o r e equals 100 minus s t
    d e v left-parenthesis upper L e a g u e upper R e g u l a r upper S e a s o n
    upper T o t a l right-parenthesis slash m e a n left-parenthesis upper L e a g
    u e upper R e g u l a r upper S e a s o n upper T o t a l right-parenthesis asterisk
    100$
  prefs: []
  type: TYPE_NORMAL
- en: A CV is lower if it varies less, but you want a metric where a higher number
    is better. You also want it to be comparable to the League Juice Score, which
    has a max value of 100\. To accomplish this, you multiply it by 100 and subtract
    it from 100 to give a number similar in scale to the League Juice Score, and so
    that a larger number is better, also matching the League Juice Score.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another Markdown cell, with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This section also uses a `lambda` command to execute Python code during the
    aggregation. You will use this in several other locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This sum value will be used in the next metric, but this is a convenient place
    to calculate it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_for_data_analytics_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This uses the pandas built-in `GroupBy.std` calculation for the standard deviation
    of the league totals.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_for_data_analytics_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This uses `lambda` to execute a calculation on the aggregated values to calculate
    the league score and scale it to match the League Juice Score.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_apis_for_data_analytics_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The pandas `sort_values` method does not change the underlying structure; it
    only sorts during the display.
  prefs: []
  type: TYPE_NORMAL
- en: The output of this cell is shown in [Figure 9-4](#league_balance_ch9).
  prefs: []
  type: TYPE_NORMAL
- en: '![League Balance Score](assets/haad_0904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4\. League Balance Score
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Calculating the League Juice Score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second metric you will calculate is the League Juice Score, which is the
    percentage of potential points that the league scored for the season. This represents
    how much juice the league owners squeezed out of the orange, that is, how many
    potential points were in the starting lineups. In fantasy football, it doesn’t
    do much good for the week’s top scorers to be sitting on someone’s bench. In a
    high-quality league, managers are setting starting lineups that get the most from
    their teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'One wrinkle to the calculation is that max points differ by the size of the
    league and the scoring type. Before you can calculate the score, you need to merge
    three DataFrames that you already prepared into a single DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '`league_stats_df`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the total points scored by each team and year
  prefs: []
  type: TYPE_NORMAL
- en: '`max_totals_grouped_df`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the custom max point totals for the regular season
  prefs: []
  type: TYPE_NORMAL
- en: '`leagues_df`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the scoring type and league size of each league, to match against custom
    max points
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact formula you will use is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: $upper L e a g u e upper J u i c e upper S c o r e equals 100 asterisk left-parenthesis
    upper L e a g u e upper T o t a l upper P o i n t s right-parenthesis slash upper
    M a x upper P o t e n t i a l upper P o i n t s right-parenthesis$
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another Markdown cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_for_data_analytics_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to combine `league_stats_df` with `max_totals_grouped_df`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_for_data_analytics_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you combine `leagues_df` with the output of the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_for_data_analytics_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the `apply()` method to execute a `lambda` function against
    each row to calculate the custom `league_juice+score` value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_apis_for_data_analytics_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: You multiply the ratio by 100 to make it a percentage, and scale it to match
    the League Balance Score.
  prefs: []
  type: TYPE_NORMAL
- en: The output of this cell is shown in [Figure 9-5](#two_metrics_chapter_9).
  prefs: []
  type: TYPE_NORMAL
- en: '![League Juice Score](assets/haad_0905.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5\. League Juice Score
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating the Shark League Score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After your API data has been manipulated, munged, and merged, you are ready
    for the payoff: building your Shark League Score. Based on your decision to weight
    the League Juice Score double, the final formula you will use is:'
  prefs: []
  type: TYPE_NORMAL
- en: $upper S h a r k upper L e a g u e upper S c o r e equals 2 asterisk left-parenthesis
    upper L e a g u e upper J u i c e upper S c o r e right-parenthesis plus upper
    L e a g u e upper B a l a n c e upper S c o r e$
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another Markdown cell, with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The output of this cell is shown in [Figure 9-6](#shark_league_ch9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Shark League Score](assets/haad_0906.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6\. Shark League Score
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Congratulations, you have calculated the Shark League Score based on customized
    data from the SportsWorldCentral API.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a discussion of the value of statistics in basketball, read [“NBA Insider:
    Is It Numbers or Talent? Sorting Fact, Fiction in NBA Stats Wave”](https://oreil.ly/DqSG-).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue building your knowledge of pandas, I recommend *Python for Data
    Analysis: Data Wrangling with pandas, NumPy, and Jupyter* (O’Reilly, 2022). It
    was written by Wes McKinney, the creator of pandas.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more detailed charts that can be created with football data from nfl_data_py,
    I recommend the book *Football Analytics with Python & R: Learning Data Science
    Through the Lens of Sports* Eager and Erickson (O’Reilly, 2023).'
  prefs: []
  type: TYPE_NORMAL
- en: For more tips on formatting Markdown for your notebook, read the [Markdown Guide](https://oreil.ly/_7OgB).
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the coefficient of variation in other domains, read [“Coefficient
    of Variation: Meaning and How to Use It”](https://oreil.ly/yO4zn).'
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to explore more uses of data analytics in fantasy football using
    Python, Nathan Braun has courses and books available at [*https://fantasycoding.com*](https://fantasycoding.com).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about creating custom metrics using API data. You
    calculated the Shark League Score and learned how to use pandas and Jupyter Notebooks
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html#chapter_10), you will build your API and data science
    skills by calling APIs in a data pipeline built with Apache Airflow.
  prefs: []
  type: TYPE_NORMAL
