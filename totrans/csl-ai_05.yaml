- en: 4 Testing the DAG with causal constraints
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 使用因果约束测试DAG
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using d-separation to reason about how causality constrains conditional independence
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用d分离来推理因果关系如何约束条件独立性
- en: Using NetworkX and pgmpy to do d-separation analysis
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetworkX和pgmpy进行d分离分析
- en: Refuting a causal DAG using conditional independence tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件独立性测试反驳因果DAG
- en: Refuting a causal DAG when there are latent variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存在潜在变量时反驳因果DAG
- en: Using and applying causal discovery algorithm constraints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和应用因果发现算法约束
- en: Our causal DAG, or any causal model, captures a set of assumptions about the
    real world. Often, those assumptions are testable with data. If we test an assumption,
    and it turns out not to hold, then our causal model is wrong. In other words,
    our test has “falsified” or “refuted” our model. When this happens, we go back
    to the drawing board, come up with a better model, and try to refute it again.
    We repeat this loop until we get a model that is robust to our attempts to refute
    it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的因果有向无环图（DAG）或任何因果模型，都捕捉了关于现实世界的一组假设。通常，这些假设可以通过数据来检验。如果我们检验一个假设，结果发现它不成立，那么我们的因果模型就是错误的。换句话说，我们的检验“证伪”或“反驳”了我们的模型。当这种情况发生时，我们回到起点，提出一个更好的模型，并再次尝试反驳它。我们重复这个循环，直到我们得到一个能够抵抗我们反驳尝试的模型。
- en: In this chapter, we’ll focus on using statistical conditional independence-based
    testing to test our causal DAG. As you learn more about the assumptions we can
    pack into a causal model, and the inferences those assumptions allow you to make,
    you’ll learn new ways to test and refute your model. The workflow you’ll learn
    for running conditional independence tests in this chapter can be applied to new
    tests you may come up with.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于使用基于统计条件独立性的测试来检验我们的因果DAG。随着你更多地了解我们可以放入因果模型中的假设，以及这些假设允许你做出的推断，你将学会新的测试和反驳模型的方法。本章中你将学习的运行条件独立性测试的工作流程可以应用于你可能提出的新的测试。
- en: 4.1 How causality induces conditional independence
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 因果关系如何导致条件独立
- en: Causal relationships constrain the data in certain ways, one of which is by
    forcing variables to be conditionally independent. This forced conditional independence
    gives us a way to test our model with data using statistical tests for independence;
    if we find strong evidence that two variables are dependent when the DAG says
    they shouldn’t be, our DAG is wrong.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因果关系以某种方式约束数据，其中之一是通过迫使变量条件独立。这种强制条件独立性为我们提供了一种使用独立性统计测试来用数据检验模型的方法；如果我们发现当DAG表明它们不应该依赖时，两个变量之间存在强烈的依赖证据，那么我们的DAG就是错误的。
- en: In this chapter, we’ll test our causal DAG using these statistical independence
    tests, including independence tests on *functions* of observed variables that
    we can run when other variables are latent in the data. At the end, we’ll look
    at how these ideas enable *causal discovery algorithms* that try to learn the
    causal DAG directly from data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用这些统计独立性测试来测试我们的因果DAG，包括当数据中的其他变量是潜在变量时，我们可以运行的关于观测变量*函数*的独立性测试。最后，我们将探讨这些想法如何使*因果发现算法*能够直接从数据中学习因果DAG。
- en: But before that, let’s see how causality induces conditional independence. Consider
    again our blood type example, shown in figure 4.1\. Your father’s blood type is
    a direct cause of yours, and your paternal grandfather’s blood type is an indirect
    cause. Despite being a cause of your blood type, your paternal grandfather’s blood
    type is conditionally independent of your blood type, given your father’s.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但在那之前，让我们看看因果关系是如何导致条件独立的。再次考虑我们的血型示例，如图4.1所示。你父亲的血型是你血型的直接原因，而你父亲的父亲的血型是间接原因。尽管是导致你血型的原因，但你的父亲的父亲的血型在给定你父亲血型的情况下与你血型条件独立。
- en: '![figure](../Images/CH04_F01_Ness.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F01_Ness.png)'
- en: Figure 4.1 Causality induces conditional independence. Your blood type is conditionally
    independent of your paternal grandfather’s blood type (an indirect cause), given
    your father’s blood type (a direct cause).
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1 因果关系导致条件独立。你的血型在给定你父亲血型（直接原因）的情况下与你父亲的父亲的血型（间接原因）条件独立。
- en: We know this from causality; the parents’ blood types completely determine the
    blood type of the child. Your paternal grandfather’s and grandmother’s blood types
    completely determined your father’s blood type, but your father’s and mother’s
    blood types completely determined yours. Once we know your father’s blood type,
    there is nothing more your paternal grandfather’s blood type can tell us. In other
    words, your grandparent’s blood type is independent of yours, given your parents.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从因果关系中得知这一点；父母的血型完全决定了孩子的血型。你父亲的和外祖母的血型完全决定了你父亲的血型，但你的父亲和母亲的血型完全决定了你的血型。一旦我们知道了你父亲的血型，就没有更多你外祖父的血型可以告诉我们了。换句话说，你的祖父母的血型在你父母的情况下是独立的。
- en: 4.1.1 Colliders
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 碰撞器
- en: Now we’ll consider the *collider,* an interesting way in which causality induces
    cases of dependence between variables that are typically independent. Consider
    the canonical example in figure 4.2\. Whether the sprinkler is on or off, and
    whether it is raining or not, are causes of whether the grass is wet, but knowing
    that the sprinkler is off won’t help you predict whether it’s raining. In other
    words, the state of the sprinkler and whether it’s raining are independent. But
    when you know the grass is wet, also knowing that the sprinkler is off tells you
    it *must* be raining. So while the state of the sprinkler and the presence or
    absence of rain are independent, they become conditionally dependent, given the
    state of the grass.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来考虑*碰撞器*，这是一种因果如何导致通常独立的变量之间产生依赖关系的有趣方式。考虑图4.2中的典型例子。水龙头开启或关闭，以及是否下雨，是草地湿润与否的原因，但知道水龙头关闭并不能帮助你预测是否在下雨。换句话说，水龙头的状态和是否下雨是独立的。但是，当你知道草地是湿的，同时知道水龙头关闭就能告诉你*一定*是在下雨。所以，虽然水龙头的状态和下雨的有无是独立的，但在给定草地状态的情况下，它们变成了条件依赖的。
- en: '![figure](../Images/CH04_F02_Ness.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH04_F02_Ness.png)'
- en: Figure 4.2 The sprinkler being on or off and whether or not it rains causes
    the grass to be wet or not. Knowing that the sprinkler is off won’t help you predict
    whether it’s raining—the sprinkler state and rain state are independent. But given
    that the grass is wet, knowing the sprinkler is off tells you it must be raining—the
    sprinkler state and rain state are conditionally dependent, given the state of
    the grass.
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2 水龙头开启或关闭以及是否下雨会导致草地湿润或不湿润。知道水龙头关闭并不能帮助你预测是否在下雨——水龙头状态和下雨状态是独立的。但是，如果知道草地是湿的，那么知道水龙头关闭就能告诉你一定是下雨了——在水龙头状态和下雨状态是条件依赖的，给定草地的状态。
- en: 'In this case “wet grass” is a *collide**r*: an effect with at least two independent
    causes. Colliders are interesting because they illustrate how causal variables
    can be independent but then become dependent if we condition on a shared effect
    variable. In conditional independence terms, the parent causes are independent
    (sprinkler ⊥ rain) but become dependent after we observe (condition on) the child
    (sprinkler ⟂̷ rain | wet grass).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“湿草地”是一个*碰撞器*：至少有两个独立原因的效果。碰撞器之所以有趣，是因为它们说明了因果变量可以是独立的，但如果我们基于一个共享的效果变量进行条件化，它们就会变得依赖。在条件独立术语中，父母的因果是独立的（水龙头
    ⊥ 雨），但在观察到孩子（基于孩子进行条件化）之后，它们变得依赖（水龙头 ⟂̷ 雨 | 湿草地）。
- en: For another example, let’s look at blood type again, as shown in figure 4.3.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们再次看看血型，如图4.3所示。
- en: '![figure](../Images/CH04_F03_Ness.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH04_F03_Ness.png)'
- en: Figure 4.3 Mothers and fathers are usually unrelated, so knowing mother’s blood
    type can’t help predict the father’s blood type. But if we know the mother’s blood
    type and the child’s blood type, it narrows down the possible blood types of the
    father.
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3 母亲和父亲通常是无关的，所以知道母亲的血型并不能帮助预测父亲的血型。但是，如果我们知道母亲的血型和孩子的血型，就能缩小父亲可能的血型范围。
- en: If we assume the mother and father are unrelated, the mother’s blood type tells
    us nothing about the father’s blood type—(mother’s blood type ⊥ father’s blood
    type). But suppose we know the child’s blood type is B. Does that help us use
    the mother’s blood type to predict the father’s blood type?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设母亲和父亲没有关系，母亲的血型并不能告诉我们父亲的血型——(母亲的血型 ⊥ 父亲的血型)。但是，如果我们知道孩子的血型是B型，这能帮助我们使用母亲的血型来预测父亲的血型吗？
- en: To answer this, examine the standard blood type table in figure 4.4\. We see
    that if mother has blood type A and the child has blood type B, then possibly
    blood types for the father are B and AB.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，请查看图4.4中的标准血型表。我们看到，如果母亲血型是A型，孩子血型是B型，那么父亲可能的血型可能是B型和AB型。
- en: '![figure](../Images/CH04_F04_Ness.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH04_F04_Ness.png)'
- en: Figure 4.4 Knowing the mother’s blood type can help you narrow down the father’s
    blood type if you know the child’s blood type.
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4 知道母亲的血型可以帮助你在知道孩子的血型的情况下缩小父亲的血型范围。
- en: Knowing the mother’s blood type alone doesn’t tell us anything about the father’s
    blood type. But if we add information about the child’s blood type (the collider),
    we can narrow down the father’s blood type from four to two possibilities. In
    other words, (mother’s blood type ⊥ father’s blood type), but the mother’s and
    father’s blood type become dependent once we condition on the child’s blood type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 仅知道母亲的血型并不能告诉我们关于父亲血型的任何信息。但如果我们添加关于孩子血型（碰撞体）的信息，我们可以将父亲的血型从四种可能性缩小到两种。换句话说，(母亲的血型
    ⊥ 父亲的血型)，但一旦我们对孩子的血型进行条件化，母亲和父亲的血型就会变得相关。
- en: Colliders show up in various parts of causal inference. In section 4.6, we’ll
    see that colliders are important in the task of causal discovery, where we try
    to learn a causal DAG from data. When we look at causal effects in chapters 7
    and 11, we’ll see how accidentally “adjusting for” colliders can introduce unwanted
    “collider bias” when inferring causal effects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞体出现在因果推断的各个部分。在第4.6节中，我们将看到碰撞体在因果发现任务中的重要性，我们试图从数据中学习一个因果DAG。当我们查看第7章和第11章中的因果效应时，我们将看到在推断因果效应时意外“调整”碰撞体如何引入不受欢迎的“碰撞体偏差”。
- en: For now, we’ll note that colliders can be at odds with our statistical intuition,
    because they describe how causal logic leads to situations where two things are
    independent but “suddenly” become dependent when you condition on a third or more
    variables.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需注意，碰撞体可能与我们的统计直觉相矛盾，因为它们描述了因果逻辑如何导致两种事物独立，但在对第三个或更多变量进行条件化时“突然”变得相关。
- en: 4.1.2 Abstracting independence with a causal graph
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 使用因果图抽象独立性
- en: '![figure](../Images/CH04_F05_Ness.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH04_F05_Ness.png)'
- en: Figure 4.5 In causal effect inference, we are interested in statistically quantifying
    how much a cause (treatment) affects an effect (outcome). *Confounders* are common
    causes that are a source of non-causal correlation between treatment and outcome.
    Causal effect inference requires “adjusting” for confounders. D-separation is
    the backbone of the theory that tells us how.
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5 在因果效应推断中，我们感兴趣的是在统计上量化一个原因（治疗）对效应（结果）的影响程度。*混杂因素*是常见的共同原因，是治疗和结果之间非因果相关性的来源。因果效应推断需要“调整”混杂因素。D分离是告诉我们如何做到这一点的理论的核心。
- en: In the previous section, we used the basic rules of blood type heredity to show
    how causality induces conditional independence. If we want to write code that
    can help us make causal inferences across different domains, we’ll need an abstraction
    for mapping causal relationships to conditional independence that doesn’t rely
    on the rules of a particular domain. “D-separation” solves this problem.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了血型遗传的基本规则来展示因果关系如何导致条件独立性。如果我们想要编写能够帮助我们跨不同领域进行因果推断的代码，我们需要一个将因果关系映射到条件独立性的抽象，这个抽象不依赖于特定领域的规则。“D分离”解决了这个问题。
- en: '*D-separation* and *d-connection* refer to how we use graphs to reason about
    conditional independence. The concepts are novel at first glance, but they will
    be some of your most important tools for graph-based causal reasoning. As a bit
    of a spoiler for chapter 7, consider the problem of causal effect inference, illustrated
    in figure 4.5\. In causal inference, you are interested in statistically quantifying
    how much a cause (often called a “treatment”) affects an effect (an “outcome”).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*D分离*和*d-连接*指的是我们如何使用图来推理条件独立性。这些概念乍一看是新颖的，但它们将成为你在基于图的因果推理中最重要的工具之一。作为第7章的一个小小的预告，考虑一下图4.5中展示的因果效应推断问题。在因果推断中，你感兴趣的是在统计上量化一个原因（通常称为“治疗”）对效应（“结果”）的影响程度。'
- en: As you saw in chapter 3, you can describe variables in a DAG in terms of their
    role in a causal inference task. One role in the task of causal effect inference
    is the *confounder*. Confounders are common causes that are a source of non-causal
    correlation between the treatment and the effect. To estimate the causal effect
    of the treatment on the outcome, we have to “adjust” for the confounder. The theoretical
    justification for doing so is based on “d-separating” the path {treatment ← confounder
    → outcome} and zooming in on the path {treatment → outcome}.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第3章中看到的，你可以用因果推断任务中变量的角色来描述DAG中的变量。在因果效应推断的任务中，一个角色是*混杂因素*。混杂因素是治疗和效果之间非因果相关性的共同原因。为了估计治疗对结果的影响，我们必须“调整”混杂因素。这样做理论上的依据是基于“d分离”路径{治疗
    ← 混杂因素 → 结果}并聚焦于路径{治疗 → 结果}。
- en: 4.2 D-separation and conditional independence
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 D分离和条件独立性
- en: 'Recall the following ideas from previous chapters:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下前几章中的以下思想：
- en: A causal DAG is a model of the data generating process (DGP).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因果DAG是数据生成过程（DGP）的一个模型。
- en: The DGP entails a joint probability distribution.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DGP包含一个联合概率分布。
- en: Causal relationships induce independence and conditional independence between
    variables in the joint probability distribution.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因果关系在联合概率分布中诱导变量之间的独立性和条件独立性。
- en: D-separation and d-connection are graphical abstractions for reasoning about
    the conditional independence in the joint probability distribution that a causal
    DAG models. The concept refers to nodes and paths between nodes in the causal
    DAG; the nodes and paths are “d-connected” or “d-separated,” where the “d” stands
    for “directional.” The idea is for a statement like “these nodes are d-separated
    in the graph” to correspond to a statement like “these variables are conditionally
    independent.” D-separation is not about stating what causes what; it is about
    whether paths between variables in the DAG indicate the absence or presence of
    dependence between those variables in the joint probability distribution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: D分离和d连接是用于推理因果DAG模型中联合概率分布的条件的独立性的图形抽象。这个概念指的是因果DAG中的节点和节点之间的路径；节点和路径是“d连接”或“d分离”的，其中“d”代表“方向”。这个想法是使一个像“这些节点在图中是d分离的”这样的陈述与一个像“这些变量在条件独立下”这样的陈述相对应。D分离不是关于陈述什么导致什么的；它是关于DAG中变量之间的路径是否表明了在联合概率分布中这些变量之间是否存在依赖。
- en: We want to make this correspondence because reasoning about graphs is easier
    than reasoning about probability distributions directly; tracing paths between
    nodes is easier than taking graduate-level classes in probability theory. Also,
    recall from chapter 2 that graphs are fundamental to algorithms and data structures,
    and that statistical modeling benefits from making conditional independence assumptions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要建立这种对应关系，因为推理图形比直接推理概率分布更容易；追踪节点之间的路径比上概率理论的高级课程更容易。此外，回想一下第2章的内容，图形是算法和数据结构的基础，统计建模从做出条件独立性假设中受益。
- en: '4.2.1 D-separation: A gateway to simplified causal analysis'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 D分离：简化因果分析的门户
- en: Suppose we have a statement that *U* and *V* are conditionally independent given
    *Z* (i.e., *U*⊥*V*|*Z*). Our task is to define a corresponding statement purely
    in graphical terms. We’ll write this statement as *U*⊥[*G*]*V*|*Z* and read it
    as “*U* and *V* are d-separated by *Z* in graph *G.*”
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个陈述，即*U*和*V*在给定*Z*的情况下是条件独立的（即*U*⊥*V*|*Z*）。我们的任务是定义一个纯粹以图形术语相对应的陈述。我们将这个陈述写成*U*⊥[*G*]*V*|*Z*，并读作“*U*和*V*在图*G*中由*Z*进行d分离。”
- en: Let *Z* represent a set of nodes called the d-separating set or “blockers.”
    In terms of conditional independence, *Z* corresponds to a set of variables we
    condition on. Our goal is to define d-separation such that the nodes in *Z* in
    some sense “block” the dependence between *U* and *V* that is implied by the causal
    structure of our DAG.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用*Z*代表一组称为d分离集或“阻塞者”的节点。在条件独立性的术语中，*Z*对应于一组我们对其条件化的变量。我们的目标是定义d分离，使得*Z*中的节点在某种意义上“阻塞”了由我们的DAG的因果结构所暗示的*U*和*V*之间的依赖。
- en: Next, let *P* be a *path*, meaning a series of connected edges (and nodes) between
    two nodes. It does not matter if the nodes on the paths are observed or not in
    your data (we’ll see how the data factors in later). Our definition of “path”
    does not depend on the orientation of the edges; for example, {*x* → *y* → *z*},
    {*x* ← *y* → *z*}, {*x* ← *y* ← *z*}, and {*x* → *y* ← *z*} are all paths between
    *x* and *z*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让*P*成为一个*路径*，意味着两个节点之间的一系列连接边（和节点）。路径上的节点是否在你的数据中被观察到并不重要（我们将在后面看到数据是如何起作用的）。我们“路径”的定义不依赖于边的方向；例如，{*x*
    → *y* → *z*}，{*x* ← *y* → *z*}，{*x* ← *y* ← *z*}和{*x* → *y* ← *z*}都是*x*和*z*之间的路径。
- en: Finally, let’s revisit the collider. A collider structure refers to a motif
    like *x* → *y* ← *z* where the middle node *y* (the collider) has incoming edges.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们重新审视碰撞器。碰撞器结构指的是像*x* → *y* ← *z*这样的模式，其中中间节点*y*（碰撞器）有入边。
- en: We’ll define d-separation now. First, two nodes *u* and *v* are said to be d-separated
    (blocked) by *Z* if all *paths* between them are d-separated by *Z*. If any of
    those paths between *u* and *v* are not d-separated, then *u* and *v* are d-connected.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义d分离。首先，如果两个节点*u*和*v*之间的所有*路径*都被*Z*分离，那么这两个节点*u*和*v*被认为是d分离（阻塞）的。如果*u*和*v*之间的任何路径没有被d分离，那么*u*和*v*是d连接的。
- en: Let’s define d-separation for a path. A path *P* is d-separated by node set
    *Z* if any of four criteria are met.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义路径的d分离。一个路径*P*如果满足以下四个标准之一，则被认为是被节点集*Z*分离的。
- en: '*P* contains a chain, *i* → *m* → *j*, such that the middle node *m* is in
    *Z.*'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*P*包含一个链*i* → *m* → *j*，其中中间节点*m*在*Z*中。'
- en: '*P* contains a chain, *i* ← *m* ← *j*, such that the middle node *m* is in
    *Z.*'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*P*包含一个链*i* ← *m* ← *j*，其中中间节点*m*在*Z*中。'
- en: '*P* contains a child-parent-child structure *i* ← *m* → *j*, such that the
    middle (parent) node *m* is in *Z.*'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*P*包含一个子父子结构*i* ← *m* → *j*，其中中间（父）节点*m*在*Z*中。'
- en: Let’s pause. Criteria 1–3 are just walking through the ways we can orient edges
    between three nodes. If this keeps up, then *P* is always d-separated if a node
    on *P* is in set *Z*. That would be nice, because it would mean that two nodes
    are d-connected (i.e., dependent) if there are any paths between them in the DAG,
    and they are d-separated if all those paths are blocked by nodes in set *Z*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下。标准1-3只是通过三种节点之间边的方向来分析。如果这样继续下去，那么如果*P*上的一个节点在集合*Z*中，那么*P*总是d分离的。那将会很棒，因为这将意味着如果DAG中存在任何路径，那么两个节点就是d连接的（即，相关的），如果所有这些路径都被集合*Z*中的节点阻塞，那么它们就是d分离的。
- en: 'Unfortunately, colliders make the fourth criterion contrary to the others:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，碰撞器使得第四个标准与其他标准相反：
- en: 4\. *P* contains a *collider* *structure*, *i* → *m* ← *j*, such that the middle
    node *m* is not in *Z,* and no descendant of *m* is in *Z.*
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. *P*包含一个*碰撞器*结构*i* → *m* ← *j*，其中中间节点*m*不在*Z*中，并且*m*的任何后代都不在*Z*中。
- en: This fourth criterion is how d-separation captures the way two independent (d-separated)
    items can become dependent when conditioning on a collider.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这第四个标准是d分离如何捕捉两个独立（d分离）的项目在条件化一个碰撞器时如何变得相关。
- en: 'Many writers conflate d-separation and conditional independence. Keep the distinction
    clear in your mind: ⊥*[G]* speaks of graphs, whereas ⊥ speaks of distributions.
    It matters because, as you’ll see later in this chapter, we’ll use d-separation
    to test our causal assumptions against statistical evidence of conditional independence
    in the data.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多作家混淆了d分离和条件独立性。请清晰地记住这种区别：⊥*[G]*指的是图，而⊥指的是分布。这很重要，因为正如你将在本章后面看到的，我们将使用d分离来测试我们的因果假设与数据中条件独立性的统计证据。
- en: '![figure](../Images/CH04_F06_Ness.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F06_Ness.png)'
- en: Figure 4.6 Does the set {*m*, *k*} d-separate path *u* → *i* → *m* → *j* → *v*?
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6集合{*m*, *k*}是否d分离路径*u* → *i* → *m* → *j* → *v*？
- en: Let’s work through a few examples.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个例子来分析。
- en: Example with chain i → m → j
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以链i → m → j为例
- en: Consider the DAG in figure 4.6, where *P* is *u* → *i* → *m* → *j* → *v*. This
    path is d-connected by default. Now let *Z* be the set {*m*, *k*}. *P* contains
    a chain *i* → *m* → *j*, and *m* is in *Z*. If we block on *Z*, the first criterion
    is satisfied, and *u* and *v* are d-separated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图4.6中的DAG，其中*P*是*u* → *i* → *m* → *j* → *v*。这条路径默认是d连接的。现在让*Z*是集合{*m*, *k*}。*P*包含一个链*i*
    → *m* → *j*，并且*m*在*Z*中。如果我们阻塞在*Z*上，第一个标准就得到了满足，并且*u*和*v*是d分离的。
- en: For some (but not all), a helpful analogy for understanding d-separation is
    an electronic circuit. Paths without colliders are d-connected and are like closed
    circuits, where electrical current flows uninhibited. “Blocking” on a node on
    that path d-separates the path and will “break the circuit” so current can’t flow.
    Blocking on *Z* (specifically, blocking on *m*, which is in *Z*) “breaks the circuit”
    as shown in figure 4.7.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些（但不是所有）情况，理解d分离的一个有用的类比是电子电路。没有对撞机的路径是d连接的，就像闭合电路，其中电流无阻碍地流动。“阻塞”路径上的节点会d分离路径，并“断开电路”，使电流无法流动。在
    *Z* 上（特别是阻塞在 *m* 上，它在 *Z* 中）阻塞“断开电路”，如图4.7所示。
- en: '![figure](../Images/CH04_F07_Ness.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F07_Ness.png)'
- en: Figure 4.7 The path is d-connected by default, but blocking on m **∈** *Z* d-separates
    the path and figuratively breaks the circuit (“**∈**” means “in”).
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7 路径默认是d连接的，但阻塞在 m **∈** *Z* 上会d分离路径，并形象地“断开电路”（“**∈**”表示“在...中”）。
- en: Example with chain i ← m → j
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以链 i ← m → j 为例
- en: 'Now consider the DAG in figure 4.8, where *P* is *u* ← *i* ← *m* → *j* → *v*.
    This path is also d-connected by default. Note that d-connection can go against
    the grain of causality. In figure 4.7, the d-connected path from *u* to *v* takes
    steps in the direction of causality: *u* to *i* (*u* ← *i*), then *i* to *m* (*i*
    ← *m*), then *m* to *j* (*m* → *j*), and then *j* to *v* (*j* → *v*). But here,
    we have two *anticausal* (meaning against the direction of causality) steps, namely
    the step from *u* to *i* (*u* ← *i*) and *i* to *m* (*i* ← *m*).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑图4.8中的DAG，其中 *P* 是 *u* ← *i* ← *m* → *j* → *v*。这条路径默认也是d连接的。请注意，d连接可以与因果关系的方向相反。在图4.7中，从
    *u* 到 *v* 的d连接路径是按照因果关系方向进行的：*u* 到 *i* (*u* ← *i*)，然后 *i* 到 *m* (*i* ← *m*)，然后
    *m* 到 *j* (*m* → *j*)，最后 *j* 到 *v* (*j* → *v*)。但在这里，我们有两个 *反因果关系*（即与因果关系方向相反）的步骤，即从
    *u* 到 *i* (*u* ← *i*) 和 *i* 到 *m* (*i* ← *m*）。
- en: '![figure](../Images/CH04_F08_Ness.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F08_Ness.png)'
- en: Figure 4.8 Does the set {*m*} d-separate path *u* ← *i* ← *m* → *j* → *v*?
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.8 是否集合 {*m*} d分离路径 *u* ← *i* ← *m* → *j* → *v*？
- en: Suppose we block on set *Z*, and *Z* contains only the node *m*. Then condition
    3 is satisfied and the path is d-separated, as illustrated in figure 4.9.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们阻塞在集合 *Z* 上，且 *Z* 只包含节点 *m*。那么条件3得到满足，路径是d分离的，如图4.9所示。
- en: '![figure](../Images/CH04_F09_Ness.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F09_Ness.png)'
- en: Figure 4.9 This path from *u* to *v* is also d-connected by default, even though
    it has some steps (*u* to *i* and *i* to *m*) that go against the direction of
    causality. Again, blocking on *m* **∈** *Z* d-separates the path and figuratively
    breaks the circuit.
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.9 从 *u* 到 *v* 的这条路径默认也是d连接的，尽管它有一些步骤（*u* 到 *i* 和 *i* 到 *m*）是违反因果关系的。再次强调，阻塞在
    *m* **∈** *Z* 上会d分离路径，并形象地“断开电路”。
- en: Colliders make d-separation weird
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对撞机使d分离变得奇怪
- en: 'The fourth criterion focuses on the collider motif *i* → *m* ← *j*: *P* contains
    a *collider* *structure*, *i* → *m* ← *j*, such that the middle node *m* is not
    in *Z,* and no descendant of *m* is in *Z.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个标准关注对撞机模式 *i* → *m* ← *j*：*P* 包含一个 *对撞机* 结构，*i* → *m* ← *j*，其中中间节点 *m* 不在
    *Z* 中，且 *m* 的任何后代都不在 *Z* 中。
- en: Let’s relate this back to our blood type example. Here *i* and *j* are the parents’
    blood types and *m* is the child’s blood type. We saw that colliders are a bit
    odd, because conditioning on the collider (the child’s blood type) induces dependence
    between two independent things (like the parents’ blood types). This oddness makes
    d-separation a bit tricky to understand at first glance. Figure 4.10 illustrates
    how colliders affect d-separation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个例子与我们的血型例子联系起来。在这里，*i* 和 *j* 是父母的血型，而 *m* 是孩子的血型。我们看到了对撞机有点奇怪，因为基于对撞机（孩子的血型）的条件会导致两个独立事物（如父母的血型）之间的依赖关系。这种奇怪性使得d分离在第一眼看起来有点难以理解。图4.10说明了对撞机如何影响d分离。
- en: '![figure](../Images/CH04_F10_Ness.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F10_Ness.png)'
- en: Figure 4.10 Colliders make d-connection tricky. Given a node *m* on a path,
    if *m* is not a collider, the path is d-connected by default and d-separated when
    you block on *m*. If *m* is a collider, the path is d-separated by default and
    d-connected when you block on *m*.
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.10 对撞机使d连接变得复杂。给定路径上的一个节点 *m*，如果 *m* 不是一个对撞机，则路径默认是d连接的，当你阻塞在 *m* 上时，路径是d分离的。如果
    *m* 是一个对撞机，则路径默认是d分离的，当你阻塞在 *m* 上时，路径是d连接的。
- en: 'The following is true of colliders:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对对撞机的描述：
- en: All paths between two nodes d-connect by default *unless that path has a collider
    motif*. A path with a collider is d-separated by default.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非路径有一个对撞机模式，否则两个节点之间的所有路径默认是d连接的。带有对撞机的路径默认是d分离的。
- en: Blocking with any node on a d-connected path will d-separate that path *unless
    that node is a collider*. Blocking on a collider will d-connect a path by default,
    as
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在d连接路径上的任何节点进行阻塞都将d分离该路径 *除非该节点是碰撞节点*。在碰撞节点上进行阻塞将默认情况下通过d连接路径，如下所示
- en: will blocking with a descendant of that collider.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将阻塞应用于该碰撞的后代。
- en: '![figure](../Images/CH04_F11_Ness.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F11_Ness.png)'
- en: Figure 4.11 Does the set {*m*} (or {*k*} or {*m*, *k*}) d-separate path *u*
    → *i* → *m* ← *j* → *v*?
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.11 集合{*m*}（或{*k*}或{*m*, *k*}）是否d分离路径 *u* → *i* → *m* ← *j* → *v*？
- en: In terms of the circuit analogy, colliders are like an open switch, which prevents
    current flow in an electronic circuit. When a path has a collider, the collider
    stops all current from passing through it. Colliders break the circuit. Blocking
    on a collider is like closing the switch, and the current that couldn’t pass through
    before now can pass through (d-connection).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在电路类比中，碰撞节点类似于一个开开关，它阻止电子电路中的电流流动。当路径有一个碰撞节点时，该节点会阻止所有电流通过。碰撞节点会中断电路。在碰撞节点上进行阻塞就像关闭开关一样，之前无法通过的电流现在可以通过了（d连接）。
- en: In the DAG in figure 4.11, is the path *u* → *i* → *m* ← *j* → *v* d-connected
    by default? No, because the path contains a collider structure *m* (*i* → *m*
    ← *j*).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在图4.11的DAG中，路径 *u* → *i* → *m* ← *j* → *v* 是否默认情况下是d连接的？不，因为该路径包含一个碰撞结构 *m*
    (*i* → *m* ← *j*）。
- en: Now consider what would happen if the blocking set *Z* included *m*. In this
    case, condition 4 is violated and the path *becomes d-connected*, as in figure
    4.12\.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如果阻塞集 *Z* 包含 *m* 会发生什么。在这种情况下，条件4被违反，路径 *变为d连接*，如图4.12所示。
- en: '![figure](../Images/CH04_F12_Ness.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F12_Ness.png)'
- en: Figure 4.12 This path from *u* to *v* is d-separated by default because it contains
    a collider *m*. The collider is analogous to an open circuit. Blocking on *m*
    or any of its descendants d-connects the path and figuratively closes the circuit.
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.12 这个从 *u* 到 *v* 的路径默认情况下是d分离的，因为它包含一个碰撞节点 *m*。碰撞节点类似于一个开路。在 *m* 或其任何后代上进行阻塞将连接路径，并形象地闭合电路。
- en: The path would also become d-connected if *Z* didn’t have *m* but just had *k*
    (or if *Z* included both *m* and *k*). Blocking on a descendant of a collider
    d-connects in the same manner as blocking on a collider.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *Z* 没有包含 *m* 但只包含 *k*（或者如果 *Z* 包含了 *m* 和 *k*），路径也会变为d连接。在碰撞节点的后代上进行阻塞与在碰撞节点上进行阻塞的方式相同。
- en: Can you guess why? It’s because the collider’s descendant is *d-connected to
    the collider*. In causal terms, we saw how, given a mother’s blood type, observing
    the child’s blood type (the collider) might reveal the father’s blood type. Suppose
    that if instead of observing the child’s blood type, we observed the child’s child’s
    blood type (call it the grandchild’s blood type). That grandchild’s blood type
    could help narrow down the child’s blood type and thus narrow down the father’s
    blood type. In other words, if the mother’s and father’s blood types are dependent,
    given the child’s blood type, and the grandchild’s blood type gives you information
    about the child’s blood type, then the mother’s and father’s blood types are dependent
    given the grandchild’s blood type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到为什么吗？这是因为碰撞的后代与碰撞节点 *d连接*。在因果术语中，我们看到了给定母亲的血型，观察孩子的血型（碰撞节点）可能会揭示父亲的血型。假设如果我们不是观察孩子的血型，而是观察孩子的孩子的血型（称为孙子的血型）。这个孙子的血型可以帮助缩小孩子的血型，从而缩小父亲的血型。换句话说，如果母亲和父亲的血型在孩子的血型给定的情况下是相关的，并且孙子的血型为你提供了关于孩子血型的信息，那么在孙子的血型给定的情况下，母亲和父亲的血型也是相关的。
- en: D-separation and sets of nodes
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D分离和节点集
- en: D-separation doesn’t just apply to pairs of nodes, it applies to pairs of sets
    of nodes. In the notation *u*⊥*v*|*Z*, *Z* can be a set of blockers, and *u* and
    *v* can be sets as well. We d-separate two sets by blocking all d-connected paths
    between members of each set. Other graph-based causal ideas, such as the do-calculus,
    also generalize to sets of nodes. If you remember that fact, we can build intuition
    on individual nodes, and that intuition will generalize to sets.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: D分离不仅适用于节点对，也适用于节点集对。在符号 *u*⊥*v*|*Z* 中，*Z* 可以是阻塞集，而 *u* 和 *v* 也可以是集。我们通过阻塞每个集合成员之间的所有d连接路径来d分离两个集合。其他基于图的因果概念，如do-calculus，也推广到节点集。如果你记住这个事实，我们就可以在单个节点上建立直觉，而这种直觉可以推广到集合。
- en: When the blocking set *Z* is the singleton set {*m*}, this set is sufficient
    to block the paths *u* → *i* → *m* → *j* → *v* in figure 4.7 and *u* ← *i* ← *m*
    → *j* → *v* in figure 4.8\. Altogether, the sets {*i*}, {*m*}, {*j*}, {*i*, *m*},
    {*i*, *j*}, {*m*, *j*}, and {*i*, *m*, *j*} all d-separate *u* and *v* on these
    two paths. However, {*i*}, {*m*}, and {*j*} are the *minimal d-separating sets*,
    meaning that all the other d-separating sets include at least one of these sets.
    The minimal d-separation sets are sufficient to d-separate the two nodes. When
    reasoning about d-separation and when implementing it in algorithms, we want to
    focus on finding minimal d-separating sets; if *U*⊥*V*|*Z* and *U*⊥*V*|*Z*, *W*
    are both true, we don’t want to waste effort on *U*⊥*V*|*Z*, *W*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当阻塞集 *Z* 是单元素集 `{*m*}` 时，这个集合足以阻塞图4.7中的路径 *u* → *i* → *m* → *j* → *v* 和图4.8中的路径
    *u* ← *i* ← *m* → *j* → *v*。总的来说，集合 `{*i*}`, `{*m*}`, `{*j*}`, `{*i*, *m*}`, `{*i*,
    *j*}`, `{*m*, *j*}` 和 `{*i*, *m*, *j*}` 都可以 d-分离这两条路径上的 *u* 和 *v*。然而，`{*i*}`,
    `{*m*}`, 和 `{*j*}` 是 *最小 d-分离集*，这意味着所有其他 d-分离集都至少包含这些集合中的一个。最小 d-分离集足以 d-分离这两个节点。在推理
    d-分离和将其实现为算法时，我们希望专注于找到最小 d-分离集；如果 *U*⊥*V*|*Z* 和 *U*⊥*V*|*Z*, *W* 都为真，我们不想在 *U*⊥*V*|*Z*,
    *W* 上浪费精力。
- en: 4.2.2 Examples of d-separating multiple paths
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 d-分离多条路径的示例
- en: Suppose we want to d-separate two nodes. Often there are multiple d-connected
    paths between those nodes. To d-separate those nodes, we need to find blockers
    that d-separate each of those paths. Let’s walk through some examples.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要 d-分离两个节点。通常在这些节点之间有多条 d-连接路径。为了 d-分离这些节点，我们需要找到能够 d-分离每条路径的阻塞器。让我们通过一些例子来了解一下。
- en: Finding a minimal d-separating set
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找最小 d-分离集
- en: In a bigger graph with more edges, the number of paths between two nodes can
    be quite large. But often longer paths often get blocked as a side-effect of blocking
    shorter paths. So we can start with shorter paths, and work our way to longer
    paths that haven’t been blocked yet, until no unblocked paths remain.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个具有更多边的更大图中，两个节点之间的路径数量可能相当大。但通常较长的路径会作为阻塞较短路径的副作用而被阻塞。因此，我们可以从较短的路径开始，逐步到尚未被阻塞的较长路径，直到没有未阻塞的路径为止。
- en: For example, *U* and *V* are d-connected in figure 4.13\. What sets of nodes
    are fully required to d-separate them?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在图4.13中，*U* 和 *V* 通过这些路径 d-连接。为了 d-分离它们，需要哪些节点集是必需的？
- en: 'In figure 4.13, *U* and *V* are d-connected through these paths:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在图4.13中，*U* 和 *V* 通过这些路径 d-连接：
- en: '*U* → *I* → *V*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* → *I* → *V*'
- en: '*U* → *J* → *V*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* → *J* → *V*'
- en: '*U* → *J* → *I* → *V*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* → *J* → *I* → *V*'
- en: First, we can d-separate *U* → *I* → *V* by blocking on *I*. Then, we d-separate
    *U* → *J* → *V* *by blo*cking on *J*. At this point, we see that our blocking
    set {*I*, *J*} already d-separates *U* → *J* → *I* → *V*, so we are done.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过在 *I* 上阻塞来 d-分离 *U* → *I* → *V*。然后，我们通过在 *J* 上阻塞来 d-分离 *U* → *J* →
    *V*。在这个时候，我们注意到我们的阻塞集合 `{*I*, *J*}` 已经 d-分离了 *U* → *J* → *I* → *V*，所以我们完成了。
- en: In another example, how do we d-separate *U* and *V* in figure 4.14?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，我们如何在图4.14中 d-分离 *U* 和 *V*？
- en: '![figure](../Images/CH04_F13_Ness.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F13_Ness.png)'
- en: Figure 4.13 We can d-separate *U* and *V* with {*I*, *J*}.
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.13 我们可以使用集合 `{*I*, *J*}` 来 d-分离 *U* 和 *V*。
- en: '![figure](../Images/CH04_F14_Ness.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F14_Ness.png)'
- en: Figure 4.14 We can d-separate *U* and *V* with sets {*I*, *M*, *K*, *J*} or
    {*I*, *M*, *K*, *L*}.
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.14 我们可以使用集合 `{*I*, *M*, *K*, *J*}` 或 `{*I*, *M*, *K*, *L*}` 来 d-分离 *U* 和
    *V*。
- en: 'There are many paths between *U* and *V*. Let’s first enumerate three of the
    shortest paths:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*U* 和 *V* 之间有许多路径。让我们首先列出三条最短的路径：'
- en: '*U* ← *I* → *V*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* ← *I* → *V*'
- en: '*U* ← *M* → *V*'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* ← *M* → *V*'
- en: '*U* ← *K* → *V*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* ← *K* → *V*'
- en: We’ll need to block on at least on {*I*, *M*, *K*} to d-separate these three
    paths. Note that *U* has another parent *J*, and there are several paths from
    *U* to *V* through *J*, but there are only two paths we haven’t already d-separated;
    *U* ← *J* → *L* → *V* and *U* ← *J* → *K* ← *L* → *V*. Both *J* and *L* will block
    these paths, so we could d-separate *U* and V with minimal sets {*I*, *M*, *K*,
    *J*} or {*I*, *M*, *K*, *L*}. Note that *U* ← *J* → *K* ← *L* → *V* was d-connected
    because we initially added *K*, a collider on this path, to our blocking set.
    Next, we look at another example of this phenomenon.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少需要在 `{*I*, *M*, *K*}` 上阻塞来 d-分离这三条路径。请注意，*U* 有另一个父节点 *J*，并且从 *U* 到 *V* 通过
    *J* 有几条路径，但我们只有两条尚未 d-分离的路径；*U* ← *J* → *L* → *V* 和 *U* ← *J* → *K* ← *L* → *V*。*J*
    和 *L* 都会阻塞这些路径，因此我们可以使用最小集合 `{*I*, *M*, *K*, *J*}` 或 `{*I*, *M*, *K*, *L*}` 来
    d-分离 *U* 和 *V*。请注意，*U* ← *J* → *K* ← *L* → *V* 是 d-连接的，因为我们最初将 *K*，这条路径上的一个碰撞器，添加到我们的阻塞集中。接下来，我们来看另一个这种现象的例子。
- en: When d-separating one path d-connects another
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当 d-分离一条路径时，会连接另一条路径
- en: When you attempt to d-separate a path between *U* and *V* by blocking on a node
    that is a collider on another path, you potentially d-connect that other path.
    That is fine, as long as you take additional steps to d-separate that path as
    well. To illustrate, consider the graph in figure 4.15\. This graph is simple
    enough that we can enumerate all of the paths.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试通过在另一条路径上的碰撞节点上阻塞来 d-分离 *U* 和 *V* 之间的路径时，你可能会 d-连接那条其他路径。这是可以的，只要你采取额外的步骤来
    d-分离那条路径。为了说明这一点，考虑图 4.15 中的图。这个图足够简单，我们可以枚举出所有的路径。
- en: '![figure](../Images/CH04_F15_Ness.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F15_Ness.png)'
- en: Figure 4.15 Blocking with *M* will block the path *U* ← *M* → *V* but would
    d-connect the path *U* ← *I* → *M* ← *J* → *V* because *M* is a collider between
    *I* and *J*. So we need to additionally block on either *I* or *J* to d-separate
    *U* ← *I* → *M* ← *J* → *V*.
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.15 使用 *M* 进行阻塞将阻塞 *U* ← *M* → *V* 的路径，但会 d-连接 *U* ← *I* → *M* ← *J* → *V*
    的路径，因为 *M* 是 *I* 和 *J* 之间的碰撞点。因此，我们需要在 *I* 或 *J* 上额外进行阻塞以 d-分离 *U* ← *I* → *M*
    ← *J* → *V*。
- en: 'Let’s start with the three d-connecting paths:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从三个 d-连接路径开始：
- en: '*U* ← *M* → *V*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* ← *M* → *V*'
- en: '*U* ← *I* → *M* → *V*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* ← *I* → *M* → *V*'
- en: '*U* ← *M* ← *J* → *V*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* ← *M* ← *J* → *V*'
- en: We also have a path *U* ← *I* → *M* ← *J* → *V*, but that is not a d-connecting
    path because *M* is a collider on that path.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个路径 *U* ← *I* → *M* ← *J* → *V*，但那不是一个 d-连接路径，因为 *M* 是该路径上的一个碰撞点。
- en: The easiest way to block all three of these d-connected paths with one node
    is to block on *M*. However, if we block on that collider, the path *U* ← *I*
    → *M* ← *J* → *V* d-connects. So we need to additionally block on *I* or *J*.
    In other words, our minimal d-separating sets are {*I*, *M*} and {*J*, *M*}.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用一个节点阻塞所有这三个 d-连接路径，即在 *M* 上进行阻塞。然而，如果我们阻塞那个碰撞点，路径 *U* ← *I* → *M* ←
    *J* → *V* 将会 d-连接。因此，我们需要在 *I* 或 *J* 上额外进行阻塞。换句话说，我们的最小 d-分离集是 {*I*, *M*} 和 {*J*,
    *M*}。
- en: 4.2.3 D-separation in code
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 代码中的 d-分离
- en: Don’t fret if you are still hazy on d-separation. We’ve defined four criteria
    for describing paths between nodes on a graph, which is just the sort of thing
    we can implement in a graph library. In Python, the graph library NetworkX already
    has a utility that checks for d-separation. You can experiment with these tools
    to build an intuition for d-separation on different graphs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对 d-分离感到困惑，不要担心。我们已定义了四个标准来描述图上节点之间的路径，这正是我们可以在图库中实现的那种类型。在 Python 中，图库
    NetworkX 已经有一个用于检查 d-分离的实用工具。你可以通过这些工具进行实验，以建立对不同图上 d-分离的直觉。
- en: Setting up your environment
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置你的环境
- en: This code was written with pgmpy version 0.1.24\. The pandas version was 2.0.3.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是用 pgmpy 版本 0.1.24 编写的。pandas 版本是 2.0.3。
- en: Let’s verify our d-separation analysis of the causal DAG shown previously in
    figure 4.15.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证之前在图 4.15 中显示的因果 DAG 的 d-分离分析。
- en: Listing 4.1 D-separation analysis of the DAG in figure 4.15
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1 图 4.15 中的 DAG 的 d-分离分析
- en: '[PRE0]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 The graph library NetworkX implements the d-separation algorithm for NetworkX
    graph objects, such as ΔiGraph (directed graph).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 图库 NetworkX 实现了针对 NetworkX 图对象（如 ΔiGraph（有向图））的 d-分离算法。'
- en: '#2 ΔAG is a base class for the BayesianNetwork class. The base class for ΔAG
    is NetworkX’s ΔiGraph. So is_d_separator will work on objects of the class ΔAG
    (and BayesianNetwork).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 ΔAG 是 BayesianNetwork 类的基类。ΔAG 的基类是 NetworkX 的 ΔiGraph。因此，is_d_separator
    将在 ΔAG（和 BayesianNetwork）类的对象上工作。'
- en: '#3 Build the graph in figure 4.11\. Blocking on a collider M blocks the path
    U ← M → V but will d-connect the path U ← I → M ← J → V, so this will print False.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 构建 4.11 图中的图。在碰撞点 *M* 上进行阻塞将阻塞 *U* ← *M* → *V*，但将 d-连接 *U* ← *I* → *M* ←
    *J* → *V* 的路径，所以这将打印 False。'
- en: '#4 Blocking on M will block U ← M → V and open (d-connect) U ← I → M ← J →
    V, but we can block that path with I and J, so this evaluates to True.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 在 *M* 上进行阻塞将阻塞 *U* ← *M* → *V* 并打开（d-连接）*U* ← *I* → *M* ← *J* → *V*，但我们可以用
    *I* 和 *J* 来阻塞那条路径，所以这评估为 True。'
- en: '#5 Blocking on both I and J is overkill. The minimal d-separating sets are
    {“M”, “I”} and {“M”, “J”}.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 同时在 *I* 和 *J* 上进行阻塞是多余的。最小 d-分离集是 {“M”， “I”} 和 {“M”， “J”}。'
- en: pgmpy also has a `get_independencies` method in the `DAG` class that enumerates
    minimal d-separating states that are true given a graph.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: pgmpy 还在 `DAG` 类中有一个 `get_independencies` 方法，它枚举了给定图中的最小 d-分离状态。
- en: Listing 4.2 Enumerating d-separations in pgmpy
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2 在 pgmpy 中枚举 d-分离
- en: '[PRE1]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 Obtain all the minimal d-separation statements that are true in the ΔAG.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取 ΔAG 中所有为真的最小 d-分离语句。'
- en: The `get_independencies` method returns the following results. (You might see
    a slight difference in the ordering of the output depending on your environment.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_independencies` 方法返回以下结果。（根据你的环境，输出的顺序可能会有细微的差异。）'
- en: '[PRE2]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the `get_independencies` function name is a misnomer; it does not
    “get independencies”; it gets d-separations. Again, don’t conflate d-separation
    in the causal graph with conditional independence in the joint probability distribution
    entailed by the DGP the graph is meant to model. Keeping this distinction in your
    mind will help you with the next task: using d-separation to test a DAG against
    evidence of conditional independence in the data.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`get_independencies` 函数的名称是一个误称；它并不“获取独立性”，而是获取 d-分离。再次提醒，不要将因果图中的 d-分离与
    DGP 所表示的联合概率分布中的条件独立性混淆。记住这个区别将有助于你完成下一个任务：使用 d-分离来测试 DAG 与数据中条件独立性的证据。
- en: 4.3 Refuting a causal DAG
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 反驳因果 DAG
- en: We have seen how to build a causal DAG. Of course, we want to find a causal
    model that fits the data well, so now we’ll evaluate the causal DAG against the
    data. We could use standard goodness-of-fit and predictive statistics to evaluate
    fit, but here we’re going to focus on *refuting* our causal DAG, using data to
    show that our model is wrong.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何构建因果 DAG。当然，我们希望找到一个与数据拟合良好的因果模型，因此现在我们将评估因果 DAG 与数据。我们可以使用标准的拟合优度和预测统计来评估拟合度，但在这里我们将专注于*反驳*我们的因果
    DAG，使用数据来证明我们的模型是错误的。
- en: Statistical models fit curves and patterns in the data. There is no “right”
    statistical model; there are just models that fit the data well. In contrast,
    causal models go beyond the data to make causal assertions about the DGP, and
    those assertions are either true or false. As modelers of causality, we try to
    find a model that fits well, but we also try to *refute* our model’s causal assertions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 统计模型拟合数据中的曲线和模式。没有“正确”的统计模型；只有拟合数据良好的模型。相比之下，因果模型超越了数据，对 DGP 进行因果断言，这些断言要么是真的，要么是假的。作为因果模型构建者，我们试图找到一个拟合良好的模型，但我们还试图*反驳*我们模型的因果断言。
- en: Refutation and Popper
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反驳与波普尔
- en: The approach to building DAGs by refutation aligns with Karl Popper’s falsifiable
    theories framework. Karl Popper was a 20th-century philosopher known for his contributions
    to the philosophy of science, particularly his theory of falsification. Popper
    argued that scientific theories cannot be proven true, but they can be tested
    and potentially falsified, or in other words, *refuted*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反驳构建 DAG 的方法与卡尔·波普尔的可证伪理论框架相一致。卡尔·波普尔是一位20世纪的哲学家，以其对科学哲学的贡献而闻名，特别是他的证伪理论。波普尔认为，科学理论不能被证明为真，但它们可以被测试，并可能被证伪，换句话说，*反驳*。
- en: We take a “Popperesque” approach to model building, meaning that we don’t merely
    want to find a model that fits the evidence. Rather, we actively search for evidence
    that refutes our model. When we find it, we reject our model, build a better one,
    and repeat.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用一种“波普尔式”的模型构建方法，这意味着我们不仅想要找到一个与证据拟合的模型。相反，我们积极寻找反驳我们模型证据。当我们找到它时，我们拒绝我们的模型，构建一个更好的模型，并重复。
- en: D-separation is our first tool for refutation. Suppose you build a causal DAG
    and it implies conditional independence. You then look for evidence in the data
    of dependence, where your DAG says there should be conditional independence. If
    you find that evidence, you have refuted your DAG. You then go back and iterate
    on the causal DAG, until you can no longer refute it, given your data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: D-分离是我们反驳的第一个工具。假设你构建了一个因果 DAG，并且它暗示了条件独立性。然后你寻找数据中的依赖性证据，在你的 DAG 中应该有条件独立性。如果你找到了这样的证据，你就反驳了你的
    DAG。然后你回到因果 DAG 上进行迭代，直到在你的数据下你不能再反驳它为止。
- en: Once you’ve done that, you move on to your downstream causal inference workflow.
    But keep this refutation mentality in mind. If you work with the same causal DAG
    repeatedly, you should always be seeking new ways to refute and iterate upon it.
    Practically, your goal is not getting the true DAG, but getting a hard-to-refute
    DAG.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这个任务，你就可以继续进行下游的因果推理工作。但请记住这种反驳心态。如果你反复使用相同的因果 DAG，你应该始终寻求新的反驳和迭代方法。实际上，你的目标不是得到真正的
    DAG，而是得到一个难以反驳的 DAG。
- en: 4.3.1 Revisiting the causal Markov property
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 重新审视因果马尔可夫属性
- en: 'Recall that we saw two aspects of the causal Markov property:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们看到了因果马尔可夫属性的两个方面：
- en: '*Local Markov property*—A node is conditionally independent of its non-descendants,
    given its parents.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*局部马尔可夫属性*——一个节点在给定其父节点的情况下，与其非后裔节点条件独立。'
- en: '*Markov factorization property*—The joint probability distribution factorizes
    into conditional distributions of variables, given their direct parents in the
    causal DAG.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*马尔可夫分解性质*—联合概率分布分解为变量的条件分布，给定因果DAG中的直接父节点。'
- en: Now we’ll introduce a third face of this property called the *global Markov
    property*. This property states that d-separation in the causal DAG implies conditional
    independence in the joint probability distribution. In notation, we write
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍这个属性的第三个方面，称为*全局马尔可夫性质*。这个属性表明，因果DAG中的d分离意味着联合概率分布中的条件独立性。在符号上，我们写成
- en: '![figure](../Images/ness-ch4-eqs-0x.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/ness-ch4-eqs-0x.png)'
- en: In plain words, that notation reads as “If *U* and *V* are d-separated by *Z*
    in graph *G*, they are conditionally independent given *Z*.” Note that if any
    of the three facets of the causal Markov property are true, they are all true.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话说，那个符号读作“如果 *U* 和 *V* 在图 *G* 中由 *Z* 分离，那么在给定 *Z* 的条件下，它们是条件独立的。”请注意，如果因果马尔可夫性质的三个方面中的任何一个为真，那么它们都是真的。
- en: The global Markov property gives us a straightforward way to refute our causal
    model. We can use d-separations to specify statistical tests for the presence
    of conditional independence. Failing tests refute the model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 全局马尔可夫性质为我们提供了一个直接反驳我们的因果模型的方法。我们可以使用d分离来指定存在条件独立性的统计检验。失败的检验反驳了模型。
- en: 4.3.2 Refutation using conditional independence tests
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 使用条件独立性检验进行反驳
- en: There are multiple ways to statistically evaluate conditional independence,
    and the most obvious is with a statistical test for conditional independence.
    pgmpy and other libraries make it relatively easy to run conditional independence
    tests. Let’s revisit the transportation model, shown again in figure 4.16.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以统计地评估条件独立性，其中最明显的方法是使用条件独立性的统计检验。pgmpy和其他库使得运行条件独立性检验相对容易。让我们重新审视运输模型，如图4.16所示。
- en: '![figure](../Images/CH04_F16_Ness.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F16_Ness.png)'
- en: Figure 4.16 The transportation model. Age (*A*) and gender (*S*) determine education
    (*E*). Education causes occupation (*O*) and residence (*R*). Occupation and residence
    cause transportation (*T*).
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.16 运输模型。年龄（*A*）和性别（*S*）决定教育（*E*）。教育导致职业（*O*）和居住地（*R*）。职业和居住地导致交通（*T*）。
- en: 'Recall that for our transportation model we were able to collect the following
    observations:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，对于我们的运输模型，我们能够收集以下观察结果：
- en: '*Age (A)*—Recorded as young (“young”) for individuals up to and including 29
    years, adult (“adult”) for individuals from 30 to 60 years old (inclusive), and
    old (“old”) for people 61 and over.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*年龄（A）*—记录为29岁及以下个人的“年轻”（“young”），30至60岁（含）个人的“成人”（“adult”），以及61岁及以上个人的“老年”（“old”）。'
- en: '*Gender (S)*—The self-reported gender of an individual, recorded as male (“M”),
    female (“F”), or other (“O”).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性别（S）*—个人的自我报告性别，记录为男性（“M”）、女性（“F”）或其他（“O”）。'
- en: '*Education (E)*—The highest level of education or training completed by the
    individual, recorded as either high school (“high”) or university degree (“uni”).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*教育（E）*—个人完成的教育或培训的最高水平，记录为高中（“high”）或大学学位（“uni”）。'
- en: '*Occupation (O)*—Employee (“emp”) or a self-employed worker (“self”).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*职业（O）*—雇员（“emp”）或自雇工人（“self”）。'
- en: '*Residence (R)*—The population size of the city the individual lives in, recorded
    as small (“small”) or big (“big”).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*居住地（R）*—个人居住的城市的人口规模，记录为小（“small”）或大（“big”）。'
- en: '*Travel (T)*—The means of transport favored by the individual, recorded as
    car (“car”), train (“train”), or other (“other”).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旅行（T）*—个人偏好的交通方式，记录为汽车（“car”）、火车（“train”）或其他（“other”）。'
- en: In the graph, *E* ⊥[*G*] *T* | *O*, *R*. So let’s test the conditional independence
    statement *E* ⊥ *T* | *O*, *R*. Statistical hypothesis tests have a *null hypothesis*
    (denoted *H*[0]*)* and an *alternative hypothesis* (denoted *H*[*a*]*)*. For statistical
    hypothesis tests of conditional independence, it is standard that the null hypothesis
    *H*[0] is the hypothesis of conditional independence, and *H*[*a*] is the hypothesis
    that the variables are not conditionally independent.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，*E* ⊥[*G*] *T* | *O*, *R*。因此，让我们检验条件独立性陈述 *E* ⊥ *T* | *O*, *R*。统计假设检验有一个*零假设*（表示为
    *H*[0]*)和一个*备择假设*（表示为 *H*[*a*]*)。对于条件独立性的统计假设检验，标准是零假设 *H*[0] 是条件独立性的假设，而 *H*[*a*]
    是变量不是条件独立的假设。
- en: A statistical hypothesis test uses the *N* data points of observed values of
    *U*, *V*, and *Z* (from an exploratory dataset) to calculate a statistic. The
    following code loads the transportation data. After loading, it creates two DataFrames,
    one with all the data and one with just the first 30 rows so we can see how sample
    size affects the significance test.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 统计假设测试使用 *N* 个观察值数据点 *U*、*V* 和 *Z*（来自探索性数据集）来计算一个统计量。以下代码加载了运输数据。加载后，它创建了两个
    DataFrame，一个包含所有数据，另一个只包含前 30 行，这样我们可以看到样本大小对显著性测试的影响。
- en: Listing 4.3 Loading the transportation data
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3 加载运输数据
- en: '[PRE3]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Subsetting the data to only 30 datapoints for explanation'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 为了解释，仅对数据进行子集化，只包含 30 个数据点'
- en: The line `print(data[0:5])` prints the first five rows of the DataFrame.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(data[0:5])` 这行代码打印出 DataFrame 的前五行。'
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Most conditional independence testing libraries will implement frequentist hypothesis
    tests. These tests will conclude in favor of *H*[*0*] or *H*[*a*] depending on
    whether a given statistic falls above or below a certain threshold. “Frequentist,”
    in this context, means that the statistic produced by the test is called a *p*-value,
    and the threshold is called a significance level, which by convention is usually
    .05 or .01.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数条件独立性测试库将实现频率假设测试。这些测试将根据给定的统计量是否高于或低于某个阈值，得出有利于 *H*[*0*] 或 *H*[*a*] 的结论。“频率主义”在这个上下文中意味着测试产生的统计量被称为
    *p*-值，而阈值被称为显著性水平，按照惯例通常是 .05 或 .01。
- en: The test favors the null hypothesis *H*[0] of conditional independence if the
    *p*-value falls above the significance threshold and the alternative hypothesis
    H[*a*] if it falls below the threshold. This frequentist approach is an optimization
    that guarantees the significance level is an upper bound on the chances of concluding
    in favor of dependence when *E* and *T* are actually conditionally independent.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *p*-值高于显著性阈值，则测试有利于条件独立性的零假设 *H*[0]；如果低于阈值，则有利于备择假设 H[*a*]。这种频率主义方法是一种优化，保证了显著性水平是当
    *E* 和 *T* 实际上条件独立时，得出有利于依赖性的结论的上限。
- en: Most software libraries provide conditional independence testing utilities that
    make specific mathematical assumptions when calculating a *p*-value. For example,
    we can run a specific conditional independence test that derives a test statistic
    that theoretically follows the chi-squared probability distribution, and then
    use this assumption to derive a *p*-value. The following code runs the test.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件库提供了条件独立性测试工具，在计算 *p*-值时做出特定的数学假设。例如，我们可以运行一个特定的条件独立性测试，该测试推导出一个理论上遵循卡方概率分布的测试统计量，然后使用这个假设推导出
    *p*-值。以下代码运行了测试。
- en: Listing 4.4 Chi-squared test of conditional independence
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4 条件独立性卡方测试
- en: '[PRE5]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 Import the chi_square test function.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入卡方测试函数。'
- en: '#2 Set the significance level to .05.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将显著性水平设置为 .05。'
- en: '#3 When the boolean argument is set to False, the test returns a tuple of three
    elements. The first two are the chi-square statistic and the corresponding p-value
    of 0.56\. The last element is a chi-squares distribution parameter called degrees
    of freedom, which is needed to calculate the p-value.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当布尔参数设置为 False 时，测试返回三个元素的元组。前两个是卡方统计量和相应的 p 值 0.56。最后一个元素是卡方分布参数，称为自由度，这是计算
    p 值所需的。'
- en: This prints the tuple `(1.1611111111111112, 0.5595873983053805, 2)`, where the
    values are chi-squared test statistic, *p*-value, and degrees of freedom respectively.
    The *p*-value is greater than the significance level, so this test favors the
    null hypothesis of conditional independence. In other words, this particular test
    did not offer falsifying evidence against our model.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出元组 `(1.1611111111111112, 0.5595873983053805, 2)`，其中值分别是卡方测试统计量、*p*-值和自由度。*p*-值大于显著性水平，因此此测试有利于条件独立性的零假设。换句话说，这个特定的测试没有提供反对我们模型的反证证据。
- en: We can jump directly to the result of the test by setting the `chi_square` function’s
    `boolean` argument to `True`. The function will then return `True` if the *p*-value
    is greater than the significance value (favoring conditional independence) and
    `False` otherwise (favoring dependence).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `chi_square` 函数的 `boolean` 参数设置为 `True` 直接跳到测试的结果。然后，如果 *p*-值大于显著性值（有利于条件独立性），函数将返回
    `True`；否则返回 `False`（有利于依赖性）。
- en: Listing 4.5 Chi-squared test with Boolean outcome
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5 带布尔结果的卡方测试
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Import the chi_square test function.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入卡方测试函数。'
- en: '#2 Set the significance level to .05.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将显著性水平设置为 .05。'
- en: '#3 When the boolean argument is set to True, the test returns a simple True
    or False outcome. It will return True if the p-value is greater than the significance
    value, which favors conditional independence. It returns False otherwise, favoring
    dependence.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当布尔参数设置为 True 时，测试返回一个简单的 True 或 False 结果。如果 p 值大于显著性值，则表示支持条件独立性，它将返回 True。否则，它返回
    False，表示支持依赖性。'
- en: This prints the result `True`. Now let’s iterate through all the d-separation
    statements we can derive from the transportation graph, and test them one by one.
    The following script will print each d-separation statement along with the outcome
    of the corresponding conditional independence test.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出结果 `True`。现在让我们遍历从运输图可以推导出的所有 d-separation 声明，并逐一测试它们。以下脚本将打印出每个 d-separation
    声明以及相应的条件独立性测试的结果。
- en: Listing 4.6 Run a chi-squared test for each d-separation statement
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6 对每个 d-separation 声明运行卡方测试
- en: '[PRE7]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result is a list of d-separation statements and whether the evidence in
    the data supports (or fails to refute) that statement.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含 d-separation 声明及其是否支持（或未能反驳）该声明的数据证据的列表。
- en: '[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can count the number of tests that pass.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算通过测试的数量。
- en: Listing 4.7 Calculate the proportion of d-separations with passing tests
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7 计算通过测试的 d-separation 的比例
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we get `0.2875`. This implies that 29% of the d-separations lack corresponding
    evidence of conditional independence in the data.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们得到 `0.2875`。这意味着 29% 的 d-separation 在数据中缺乏相应的条件独立性证据。
- en: This number seems high, but as we’ll see in section 4.4, this statistic depends
    on the size of the data and other factors. We’ll want to compare it to the result
    for other candidate DAGs. For now, the next step is to inspect these cases of
    apparent dependence where our DAG says there should be conditional independence.
    If the evidence of dependence is strong, we need to think about how to improve
    our causal DAG to explain it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字似乎很高，但正如我们将在 4.4 节中看到的，这个统计量取决于数据的大小和其他因素。我们将想要将其与其他候选 DAG 的结果进行比较。目前，下一步是检查这些明显的依赖性案例，其中我们的
    DAG 表示应该存在条件独立性。如果依赖性的证据很强，我们需要考虑如何改进我们的因果 DAG 来解释它。
- en: Earlier, I used the `chi_square` function, which constructs a specific test
    statistic with a chi-squared test distribution—the distribution used to calculate
    the *p*-value. The chi-squared distribution is just another canonical distribution,
    like the normal or Bernoulli distributions. The chi-squared distribution comes
    up frequently for discrete variables, because there are several test statistics
    in the discrete setting that either have a chi-squared distribution or get closer
    to one as the size of the data increases. Overall, independence tests have a variety
    of test statistics with different test distributions. pgmpy provides several options
    by way of calls to SciPy’s stats library.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我使用了 `chi_square` 函数，该函数使用卡方测试分布构建特定的测试统计量——用于计算 *p*-值的分布。卡方分布只是另一种典型分布，类似于正态分布或伯努利分布。卡方分布经常用于离散变量，因为在离散设置中，有几个测试统计量要么具有卡方分布，要么随着数据量的增加而越来越接近卡方分布。总的来说，独立性测试具有各种测试统计量和不同的测试分布。pgmpy
    通过调用 SciPy 的 stats 库提供了几种选项。
- en: One common concern is that the test makes strong assumptions. For example, some
    conditional independence tests between continuous variables assume any dependence
    between the variables would be *linear*. An alternative approach is to use a *permutation*
    test, which is an algorithm that constructs the *p*-value without relying on a
    canonical test distribution*.* Permutation tests make fewer assumptions but are
    computationally expensive.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的担忧是测试做出了强烈的假设。例如，一些连续变量之间的条件独立性测试假设变量之间的任何依赖性都是 *线性的*。另一种方法是使用 *排列* 测试，这是一种算法，它构建
    *p*-值而不依赖于典型测试分布*。排列测试做出的假设较少，但计算成本较高。
- en: 4.3.3 Some tests are more important than others
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 一些测试比其他测试更重要
- en: The previous analysis tested all the d-separations implied by a causal DAG.
    But some d-separations might be more important to you than others. Some dependence
    relations and conditional independence relations are pivotal to a downstream causal
    inference analysis, while others don’t affect that analysis at all.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的分析测试了由因果 DAG 暗示的所有 d-separation。但有些 d-separation 可能比其他 d-separation 更重要。一些依赖关系和条件独立性关系对于下游因果推断分析至关重要，而其他关系则根本不影响该分析。
- en: For example, consider figure 4.17, which we looked at earlier in section 3.3\.
    We added the variable *Z* to the graph because we might want to use it as an “instrumental
    variable” in the estimation of the causal effect.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑图4.17，我们在第3.3节中已经讨论过。我们添加变量 *Z* 到图中，因为我们可能希望将其用作估计因果效应的“工具变量”。
- en: '![figure](../Images/CH04_F17_Ness.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F17_Ness.png)'
- en: Figure 4.17 *Z*, *X*[0], and *X*[1] were included in the DAG because they play
    a useful role in analyzing the causal effect of *U* on *Y*. Their role depends
    on conditional independence, and it is important to test that they can indeed
    serve those roles.
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.17中包含 *Z*，*X*[0] 和 *X*[1]，因为它们在分析 *U* 对 *Y* 的因果效应中发挥了有用的作用。它们的作用取决于条件独立性，并且测试它们确实能够扮演这些角色是很重要的。
- en: We’ll discuss instrumental variables in depth in chapter 11\. For now, suffice
    it to say that for *Z* to be an instrument, it must be independent of *W*[0],
    *W*[1], and *W*[2]. So we’d pay special attention to testing that assumption.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第11章中深入讨论工具变量。现在，只需说，为了 *Z* 成为工具变量，它必须与 *W*[0]、*W*[1] 和 *W*[2] 独立。因此，我们将特别注意测试这个假设。
- en: 4.4 Caveats with conditional independence testing
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 条件独立性测试的注意事项
- en: As I mentioned, conditional independence tests are perhaps the most obvious
    way to test the conditional independence constraints implied by your proposed
    causal DAG. However, there are several caveats with using statistical tests to
    test a causal DAG. In my experience, these issues can distract analysts from their
    ultimate goal of answering a causal question. In this section, I’ll highlight
    some of these caveats and propose some alternatives to conditional independence
    testing. The main takeaway is that statistical testing is an important tool for
    building your DAG, but as with any statistical methodology, it is not a panacea
    (and that’s fine).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，条件独立性测试可能是测试你提出的因果DAG中隐含的条件独立性约束的最明显的方法。然而，使用统计测试来测试因果DAG存在一些注意事项。根据我的经验，这些问题可能会让分析师偏离他们回答因果问题的最终目标。在本节中，我将强调一些这些注意事项，并提出一些条件独立性测试的替代方案。主要启示是，统计测试是构建你的DAG的重要工具，但与任何统计方法一样，它不是万能的（这是可以的）。
- en: 4.4.1 Statistical tests always have some chance of error
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 统计测试总是存在一些错误的可能性
- en: I mentioned that with d-separation, we should not “confuse the map for the terrain”;
    d-separation is not the same thing as conditional independence. Rather, if your
    model is a good representation of causality, d-separation *implies* conditional
    independence.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到，使用d-separation时，我们不应该“把地图当作地形”；d-separation与条件独立性不是一回事。相反，如果你的模型是因果性的良好表示，d-separation
    *意味着*条件独立性。
- en: Similarly, conditional independence is not the same as *statistical evidence*
    of conditional independence. The causal structure of the DGP imposes conditional
    independence constraints on the joint probability distribution. But you can’t
    “see” the joint distribution and the independencies it contains; you can only
    “see” (and run statistical tests on) the data sampled from that distribution.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，条件独立性并不等同于条件独立性的统计证据。DGP的因果结构对联合概率分布施加了条件独立性约束。但你无法“看到”联合分布及其包含的独立性；你只能“看到”（并对从该分布中抽取的数据进行统计测试）。
- en: Just like with prediction, classification, or any other statistical pattern
    recognition procedure, the procedure for detecting these independencies in data
    can get it wrong. You can get false negatives, where a pair of variables are truly
    conditionally independent but the statistical independence test concludes they
    are dependent. You can have false positives, where a statistical independence
    test finds a pair of variables to be conditionally independent when they are not.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就像预测、分类或任何其他统计模式识别过程一样，检测数据中这些独立性的方法可能会出错。你可能会得到假阴性，即一对变量实际上是条件独立的，但统计独立性测试却得出它们是相关的结论。你可能会得到假阳性，即统计独立性测试发现一对变量是条件独立的，而实际上它们并不是。
- en: 4.4.2 Testing causal DAGs with traditional CI tests is flawed
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 使用传统的CI测试来测试因果DAG是有缺陷的
- en: I say that the proposed conditional independence tests for refutation are “flawed”
    because they violate the spirit of statistical hypothesis testing in science.
    Suppose you think you have discovered some pattern in stock prices. You are biased
    to think the pattern is more than coincidence because, if it is, you can make
    money. To be rigorous and not fall prey to your biases, your alternative hypothesis
    says the pattern is real and exploitable, whereas the null hypothesis is that
    it is just random noise. The frequentist test assumes the null hypothesis is true
    and gives you a *p*-value, which quantifies the chances that random noise could
    form a pattern at least as strong as the one you found. The test forces you to
    reject the pattern as real unless that *p*-value is really small. Most mainstream
    statistical testing libraries are designed for this use case.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为所提出的用于反驳的条件独立性检验是“有缺陷的”，因为它们违反了科学中统计假设检验的精神。假设你认为你在股票价格中发现了某种模式。你倾向于认为这种模式不仅仅是巧合，因为如果是巧合，你可以从中赚钱。为了严谨，不受到你的偏见的影响，你的备择假设应该是这种模式是真实的且可利用的，而零假设则是它只是随机噪声。频率派测试假设零假设是真实的，并给你一个*p*值，这个*p*值量化了随机噪声形成至少与你发现的模式一样强的模式的概率。这个测试迫使你拒绝这种模式是真实的，除非那个*p*值非常小。大多数主流的统计测试库都是为了这种用例设计的。
- en: When you propose a causal model, you are also biased to believe it is true.
    But causal models induce conditional independences, which by definition are the
    *absences* of patterns. In this case the null and alternative hypotheses should
    switch; the alternative should be that your model is right and there isn’t a pattern
    (and any evidence of patterns in the data is just spurious correlation), and the
    null should be that there is a pattern. It is possible to implement such a hypothesis
    test, but it is not mathematically trivial, and most mainstream statistical libraries
    like SciPy do not support this use case.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提出一个因果模型时，你也倾向于相信它是真实的。但因果模型会诱导条件独立性，根据定义，这些是*不存在*的模式。在这种情况下，零假设和备择假设应该互换；备择假设应该是你的模型是正确的，没有模式（并且数据中的任何模式证据只是虚假的相关性），而零假设应该是存在模式。可以实施这样的假设检验，但这在数学上并不简单，而且大多数主流的统计库，如SciPy，不支持这种用例。
- en: The compromise is using the traditional tests, where the null hypothesis specifies
    conditional independence less as a theoretically rigorous analysis and more as
    a *heuristic*—an empirical problem solving technique that can be suboptimal but
    sufficient to reach a good enough solution.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 妥协是使用传统的测试，其中零假设将条件独立性更多地指定为一种理论上的严谨分析，而不是一种*启发式*——一种经验性的问题解决技术，它可能不是最优的，但足以达到足够好的解决方案。
- en: 4.4.3 p-values vary with the size of the data
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 *p*值随数据大小变化
- en: The conclusion of a traditional conditional independence test depends on a significance
    threshold. If the *p*-value falls below this threshold, you favor dependence,
    and if it falls above, you favor conditional independence. The choice of threshold
    is a bit arbitrary; people tend to go with commonly selected values like .1 or
    .05 or .01.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 传统条件独立性检验的结论取决于一个显著性阈值。如果*p*值低于这个阈值，你倾向于认为存在依赖性；如果它高于这个阈值，你倾向于认为存在条件独立性。阈值的选择有点随意；人们倾向于选择常见的值，如0.1、0.05或0.01。
- en: The problem is that the *p*-value statistic varies with the size of the data.
    All else equal, as the size of the data increases, the *p*-value decreases. In
    other words, the larger the data, the more that things start to look dependent.
    If you have a large dataset, it is more likely that *p*-values will fall below
    that arbitrary threshold, and the data will look like it’s refuting the conditional
    independence implied by your DAG, even when that conditional independence is true.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于*p*值统计量随着数据大小的变化而变化。在其他条件相同的情况下，随着数据大小的增加，*p*值会降低。换句话说，数据越大，事情开始看起来越有依赖性。如果你有一个大型数据集，*p*值更有可能低于那个任意的阈值，数据看起来就像是在反驳你的DAG所暗示的条件独立性，即使这种条件独立性是真实的。
- en: To illustrate, the test of *E* ⊥ *T* | *O*, *R* in section 4.3.2 had 30 data
    points and produced a *p*-value of 0.56\. In our data, *E* ⊥ *T* | *O*, *R* is
    ground truth (via simulation), so if a test concludes against *E* ⊥ *T* | *O*,
    *R*, it is because of statistical issues with the test, not the quality of the
    data. The following bootstrap statistical analysis will show how the estimate
    of the *p*-value falls as the size of the data increases.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，4.3.2节中关于 *E* ⊥ *T* | *O*, *R* 的检验有30个数据点，产生了0.56的 *p* 值。在我们的数据中，*E* ⊥
    *T* | *O*, *R* 是真实情况（通过模拟获得），因此如果测试得出与 *E* ⊥ *T* | *O*, *R* 相反的结论，那是因为测试的统计问题，而不是数据的质量。下面的自助统计分析将展示随着数据集大小的增加，p值的估计如何下降。
- en: First, we’ll write a `sample_p_value` function that samples a *p*-value for
    a given data size. The next function, `estimate_p_value`, will do this sampling
    repeatedly and calculate a mean *p*-value, a 90% confidence interval, and the
    probability that the *p*-value falls below the significance threshold, which is
    the probability of rejecting the correct conclusion that *E* ⊥ *T* | *O*, *R*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个 `sample_p_value` 函数，用于为给定数据大小抽取一个 *p* 值。下一个函数 `estimate_p_value`
    将重复进行此抽样并计算平均 *p* 值、90%置信区间以及p值低于显著性阈值的概率，即拒绝 *E* ⊥ *T* | *O*, *R* 正确结论的概率。
- en: Listing 4.8 Bootstrap analysis of sensitivity of test of *E* **⊥** *T* | *O*,
    *R* to sample size
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8 *E* **⊥** *T* | *O*, *R* 测试对样本大小的敏感性自助分析
- en: '[PRE10]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 Given a certain data size, this function randomly samples that number of
    rows from the full dataset. It then runs the chi-squared independence test and
    returns the p-value.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 给定一定大小的数据集，此函数从完整数据集中随机抽取相应数量的行。然后运行卡方独立性检验并返回p值。'
- en: '#2 This function conducts a “bootstrap” procedure that samples 1,000 p-values
    for a given data size and calculates the mean p-value and 90% p-value confidence
    interval.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 此函数执行一个“自助”过程，为给定数据大小抽取1,000个 *p* 值，并计算平均 *p* 值和90% *p* 值置信区间。'
- en: '#3 Calculate the probability of a test concluding in favor of conditional independence.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 计算支持条件独立性的测试结论的概率。'
- en: '#4 Calculate the mean of the p-values to get the bootstrap mean.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 计算p值的平均值以获得自助平均值。'
- en: '#5 Calculate the 5th and 95th percentiles to get a 90% bootstrap confidence
    interval.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 计算第5和第95个百分位数以获得90%的自助置信区间。'
- en: '#6 Run the bootstrap analysis.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 运行自助分析。'
- en: Finally, we’ll visualize the results. We’ll plot the size of the data against
    the mean and 90% confidence intervals for the *p*-values we get for that given
    data size. We’ll also plot how the probability of concluding in favor of the true
    hypothesis (*E* ⊥ *T* | *O*, *R*) for a significance level of .05 depends on data
    size.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将可视化结果。我们将绘制数据大小与给定数据大小得到的 *p* 值的平均值和90%置信区间的对比图。我们还将绘制在显著性水平为.05的情况下，支持真实假设（*E*
    ⊥ *T* | *O*, *R*）的概率如何依赖于数据大小。
- en: Listing 4.9 Visualize dependence of conditional independence testing on data
    size
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9 可视化条件独立性测试对数据大小的依赖关系
- en: '[PRE11]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Run the bootstrap analysis to get quantiles of p-values and probability
    of concluding in favor of independence.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 运行自助分析以获取p值的分位数和得出独立性支持的结论的概率。'
- en: '#2 Plot the data size vs. p-value. At larger data sizes, the expected p-value
    falls below a threshold.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 绘制数据大小与p值的关系图。在较大的数据集大小下，预期的p值会低于阈值。'
- en: '#3 Plot data size vs. the probability of concluding in favor of independence,
    given .05 significance.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 绘制数据大小与在.05显著性水平下支持独立性的概率的关系图。'
- en: Figure 4.18 shows the first plot. The descending curve is the expected *p*-values
    at different data sizes, the vertical lines are error bars showing a 90% bootstrap
    confidence interval. By the time we get to a dataset of size 1,000, the expected
    *p*-value is below the threshold, meaning that the test favors the conclusion
    that *E* ⊥ *T* | *O*, *R* is false.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18显示了第一个图表。下降的曲线是不同数据大小下的预期 *p* 值，垂直线表示显示90%自助置信区间的误差线。当我们得到1,000个数据点的数据集时，预期的
    *p* 值低于阈值，这意味着测试倾向于得出 *E* ⊥ *T* | *O*, *R* 是错误的结论。
- en: '![figure](../Images/CH04_F18_Ness.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F18_Ness.png)'
- en: Figure 4.18 Sample size vs. expected *p*-value of the conditional independence
    test for *E***⊥** *T* | *O*, *R* (solid line). The vertical lines are the error
    bars; they show the 90% bootstrap confidence intervals. The horizontal dashed
    line is a .05 significance level, above which we favor the null hypothesis of
    conditional independence and below which we reject it. As the sample size increases,
    we eventually cross the line. Thus, the result of our refutation analysis depends
    on the size of the data.
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.18 条件独立性测试的样本量与预期 *p*-值的关系图（实线）。垂直线是误差线；它们表示90%的bootstrap置信区间。水平虚线是0.05的显著性水平，在此之上我们倾向于接受条件独立性的零假设，在此之下我们拒绝它。随着样本量的增加，我们最终会越过这条线。因此，我们的反驳分析结果取决于数据规模。
- en: Note that the lower bound of the confidence interval crosses the significance
    threshold well before 1,000, suggesting that at even lower data sizes, we have
    a good chance of rejecting the true conclusion of *E* ⊥ *T* | *O*, *R*. This becomes
    clearer in figure 4.19, where the probability of concluding in favor of the true
    conclusion decreases as the size of the data increases.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到置信区间的下限在1,000之前就已经跨过了显著性阈值，这表明即使在更小的数据规模下，我们也有很好的机会拒绝 *E* ⊥ *T* | *O*, *R*
    的真实结论。这在图4.19中更为明显，随着数据规模的增加，得出支持真实结论的概率降低。
- en: '![figure](../Images/CH04_F19_Ness.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F19_Ness.png)'
- en: Figure 4.19 As the size of the data increases, the probability of concluding
    in favor of this (true) instance of the conditional independence relation *E*
    **⊥** *T* | *O*, *R* decreases.
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.19 随着数据规模的增加，得出支持这种（真实）条件独立性关系 *E* **⊥** *T* | *O*, *R* 的概率降低。
- en: You might think that as the size of the data increases, the algorithm is detecting
    subtle dependencies between *E* and *T* that were undetectable with less data.
    Not so, for this transportation data is simulated in such a way that *E* ⊥ *T*
    | *O*, *R* is definitely true. This is a case where more data leads us to rejecting
    independence because more data leads to more spurious correlations—patterns that
    aren’t really there.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，随着数据规模的增加，算法能够检测到在较少数据下无法检测到的 *E* 和 *T* 之间的微妙依赖关系。并非如此，因为这种运输数据是模拟的，*E*
    ⊥ *T* | *O*, *R* 一定是真实的。这是一个数据更多反而导致我们拒绝独立性，因为更多数据导致更多虚假相关性的例子——这些模式实际上并不存在。
- en: A causal model is either right or wrong about causality in the DGP it describes.
    The conditional independence the model implies is either there or it’s not. Yet
    if that conditional independence is there, the test can still conclude in favor
    of dependence when the data is arbitrarily large.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个因果模型要么正确要么错误地描述了DGP中的因果关系。模型所暗示的条件独立性要么存在要么不存在。然而，如果这种条件独立性存在，当数据任意大时，测试仍然可以得出支持依赖性的结论。
- en: Again, if we view conditional independence testing as a heuristic for refuting
    our DAG, then this sensitivity to the size of the data shouldn’t upset us. Regardless
    of the data size and the significance thresholds, the *relative* differences between
    *p*-values when there is no conditional independence and when there is will be
    large and obvious.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果我们把条件独立性测试视为反驳我们的DAG的启发式方法，那么对数据规模的这种敏感性不应该让我们感到不安。无论数据规模和显著性阈值如何，当没有条件独立性时与当有条件独立性时，*p*-值之间的相对差异都将是很大且明显的。
- en: 4.4.4 The problem of multiple comparisons
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 多重比较问题
- en: In statistical hypothesis testing, the more tests you run, the more testing
    errors you rack up. The same is true when running a test for each d-separation
    implied by a causal DAG. In statistics, this problem is called the *multiple comparisons
    problem*. There are solutions to dealing with multiple comparisons problems, such
    as using *false discovery rates*. If you are familiar with such methods, applying
    them won’t hurt. If you want to learn more, see the chapter’s notes at [https://www.altdeep.ai/p/causalaibook](https://www.altdeep.ai/p/causalaibook)
    for references to false discovery rates in the context of causal modeling. But
    again, I encourage you to view traditional conditional independence testing as
    a heuristic that helps with the ultimate goal of building a good causal DAG. Focus
    on this goal and on the subsequent causal inference analysis you will conduct
    using your DAG, and avoid rabbit holes of statistical testing rigor.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计假设检验中，你进行的测试越多，累积的测试错误就越多。当对因果有向图（DAG）中每个d分离进行测试时，情况也是如此。在统计学中，这个问题被称为*多重比较问题*。有解决多重比较问题的方法，例如使用*假发现率*。如果你熟悉这些方法，应用它们不会有害。如果你想了解更多，请参阅章节的笔记，在[https://www.altdeep.ai/p/causalaibook](https://www.altdeep.ai/p/causalaibook)中可以找到关于因果建模中假发现率的参考。但再次强调，我鼓励你将传统的条件独立性测试视为一种启发式方法，它有助于实现构建良好因果有向图（DAG）的最终目标。专注于这个目标，以及你将使用你的DAG进行的后续因果推断分析，并避免陷入统计测试的繁琐细节。
- en: 4.4.5 Conditional independence testing struggles in machine learning settings
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 在机器学习设置中进行条件独立性测试的挑战
- en: Commonly used libraries for conditional independence testing are generally limited
    to one-dimensional variables with fairly simple patterns of correlation between
    them. pgmpy’s conditional independence tests, which are imported from SciPy, are
    no exception. In recent years, several nonparametric tests have been developed
    for more nuanced distributions, such as kernel-based conditional independence
    tests. Tests in the PyWhy library PyWhy-Stats are a good place to start if you
    are interested in such tests.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的条件独立性测试库通常仅限于具有相对简单相关模式的单变量。从SciPy导入的pgmpy的条件独立性测试也不例外。近年来，已经开发出针对更复杂分布的非参数测试，例如基于核的条件独立性测试。如果你对这类测试感兴趣，PyWhy库中的PyWhy-Stats库是一个不错的起点。
- en: However, in machine learning, it is common for variables to have more than one
    dimension such as vectors, matrices, and tensors. For example, one variable in
    a causal DAG might represent a matrix of pixels constituting an image. Further,
    the statistical associations between these variables can be nonlinear.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在机器学习中，变量通常具有多个维度，如向量、矩阵和张量。例如，因果有向图中的一个变量可能代表构成图像的像素矩阵。此外，这些变量之间的统计关联可能是非线性的。
- en: One solution is to focus on prediction. If two things are independent, they
    have no ability to predict one another. Suppose we have two predictive models
    *M*[1] and *M*[2]. *M*[1] predicts *Y* using *Z* as a predictor. *M*[2] predicts
    *Y* using *X* and *Z* as a predictor. Predictors can have dimensions greater than
    one. If *X* ⊥ *Y* | *Z*, then any *X* has no predictive information about *Y*
    beyond what is already provided by *Z*. So you can test *X* ⊥ *Y* | *Z* by comparing
    the model predictive accuracy of *M*[2]to *M*[1]. When the models perform similarly,
    we have evidence of conditional independence. Note that you’d want to prevent
    *M*[2] from “cheating” on its predictive accuracy by taking steps to avoid overfitting—yet
    another way spurious correlation can creep into our analysis.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是专注于预测。如果两件事物是独立的，它们就没有能力预测对方。假设我们有两个预测模型 *M*[1] 和 *M*[2]。*M*[1] 使用 *Z*
    作为预测因子来预测 *Y*。*M*[2] 使用 *X* 和 *Z* 作为预测因子来预测 *Y*。预测因子可以有超过一维的维度。如果 *X* ⊥ *Y* |
    *Z*，那么任何 *X* 都没有比 *Z* 已经提供的更多关于 *Y* 的预测信息。因此，你可以通过比较 *M*[2] 和 *M*[1] 的模型预测准确度来测试
    *X* ⊥ *Y* | *Z*。当模型表现相似时，我们就有了条件独立性的证据。请注意，你希望防止 *M*[2] 通过避免过度拟合来“作弊”，这又是虚假相关性可能悄悄进入我们分析的一种方式。
- en: 4.4.6 Final thoughts
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.6 最后的想法
- en: Conditional independence testing is an extensive and nuanced subject. Your goal
    with this testing is to refute your causal DAG, not to create the Platonic ideal
    of a conditional independence testing suite. I recommend getting a testing workflow
    that is *good enough*, and then focusing on building your DAG and using that DAG
    in downstream causal inferences. For example, if I had a mix of continuous and
    discrete variables, then rather than implementing a test that could accommodate
    my different data types, I would discretize my continuous variables (for example,
    turning age as time since birth into age brackets) and use a vanilla chi-squared
    test, to keep things moving along.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 条件独立性测试是一个广泛且复杂的主题。你的目标是反驳你的因果 DAG，而不是创建一个条件独立性测试套件的柏拉图理想。我建议找到一个“足够好”的测试工作流程，然后专注于构建你的
    DAG 并在下游因果推断中使用该 DAG。例如，如果我有一组连续和离散变量，那么我宁愿将我的连续变量离散化（例如，将出生时间以来的年龄转换为年龄组），然后使用普通的卡方检验，以保持事情顺利进行。
- en: 4.5 Refuting a causal DAG given latent variables
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 在潜在变量给定的情况下反驳因果 DAG
- en: The method of testing DAGs with conditional independence has a latent variable
    problem. If a variable in our causal DAG is latent (not observed in the data),
    we can’t run any conditional independence tests involving that variable. That
    is a major problem; if a variable is an important part of the DGP, we can’t exclude
    it from our DAG simply because we can’t test independence assertions with that
    variable.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件独立性测试 DAG 的方法存在潜在变量问题。如果我们的因果 DAG 中的一个变量是潜在的（在数据中未观察到），我们就无法运行涉及该变量的任何条件独立性测试。这是一个大问题；如果变量是
    DGP 的重要部分，我们无法仅仅因为我们无法测试与该变量的独立性断言而将其排除在我们的 DAG 之外。
- en: To illustrate, consider the causal DAG in figure 4.20\. This figure represents
    how smoking behavior (*S*) is influenced both by the cost of cigarettes (*C*)
    as well as genetic factors (denoted *D* as in “DNA”) that make one more or less
    prone to nicotine addiction. Those same genetic factors influence one’s likelihood
    of getting lung cancer (*L*). In this model, smoking’s effect on cancer is *mediated*
    through tar buildup (*T*) in the lungs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑图 4.20 中的因果 DAG。此图表示吸烟行为 (*S*) 受香烟成本 (*C*) 以及遗传因素（用“DNA”中的 *D* 表示）的影响，这些因素使一个人更容易或更不容易上瘾于尼古丁。相同的遗传因素影响一个人患肺癌
    (*L*) 的可能性。在这个模型中，吸烟对癌症的影响是通过肺部焦油积累 (*T*) 来*中介*的。
- en: '![figure](../Images/CH04_F20_Ness.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F20_Ness.png)'
- en: Figure 4.20 A causal DAG representing smoking’s effect on cancer. The variable
    for genetics (*D*) is gray because it is unobserved in the data, so we can’t run
    tests for conditional independencies involving *D*. However, we can test other
    types of constraints.
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.20 表示吸烟对癌症影响的因果 DAG。遗传变量 (*D*) 为灰色，因为它在数据中未观察到，因此我们无法运行涉及 *D* 的条件独立性测试。然而，我们可以测试其他类型的约束。
- en: 'If we have data observing all these variables, we can run conditional independence
    tests targeting the following d-separations: (*C* ⊥*[G]* *T* | *S*), (*C* ⊥*[G]*
    *L* | *D*, *T*), (*C* ⊥*[G]* *L* | *D*, *S*), (*C* ⊥*[G]* *D*), (*S* ⊥*[G]* *L*
    | *D*, *T*), and (*T* ⊥*[G]* *D* | *S*). But suppose we don’t have data on the
    genetics variable (*D*). For example, perhaps measuring this genetics feature
    requires an infeasibly expensive and invasive laboratory test. Of all the d-separations
    we listed, the only one not involving *D* is (*C* ⊥*[G]* *T* | *S*). We are down
    from six to one feasible conditional independence test with which to test our
    DAG.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有观察所有这些变量的数据，我们可以运行以下 d-separations 的条件独立性测试：(*C* ⊥*[G]* *T* | *S*), (*C*
    ⊥*[G]* *L* | *D*, *T*), (*C* ⊥*[G]* *L* | *D*, *S*), (*C* ⊥*[G]* *D*), (*S* ⊥*[G]*
    *L* | *D*, *T*), 和 (*T* ⊥*[G]* *D* | *S*)。但是，假设我们没有关于遗传变量 (*D*) 的数据。例如，可能需要一种不切实际昂贵且侵入性的实验室测试来测量这种遗传特征。在我们列出的所有
    d-separations 中，唯一不涉及 *D* 的是 (*C* ⊥*[G]* *T* | *S*）。我们从一个可行的条件独立性测试减少到只有一个，以测试我们的
    DAG。
- en: In general, a proposed causal model can have various implications for the joint
    probability distributions that are testable with data. The conditional independence
    implied by the graph structure is one type of testable implication. But some of
    the model’s implications are testable in cases of latent variables. In this section,
    we’re going to look at how we can test a DAG with one of these latent variable–related
    constraints.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个提出的因果模型可以对可由数据测试的联合概率分布产生各种影响。由图结构隐含的条件独立性是一种可测试的影响。但模型的一些影响在潜在变量的情况下是可测试的。在本节中，我们将探讨如何测试一个具有这些潜在变量相关约束的
    DAG。
- en: 4.5.1 An example of a testable implication that works with latent variables
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 一个与潜在变量一起工作的可测试含义的例子
- en: The causal Markov assumption says d-separations imply conditional independence
    in the data. So far, we’ve explored direct conditional independence between variables,
    but when some variables are latent, the graph can imply conditional independence
    *between functions of observed variables*. These implications are called “Verma
    constraints” in the literature, though I will use the less jargony “functional
    constraints.”
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因果马尔可夫假设表明，d-分离意味着数据中的条件独立性。到目前为止，我们已经探讨了变量之间的直接条件独立性，但当某些变量是潜在变量时，图可以暗示观察变量函数之间的条件独立性。这些含义在文献中被称为“Verma约束”，尽管我将使用更口语化的“功能约束”。
- en: 'To illustrate, the DAG in figure 4.20 with latent variable *D* has the following
    functional constraint (for now, don’t worry about how its derived):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，图4.20中的DAG具有以下功能约束（现在不用担心它是如何导出的）：
- en: '![figure](../Images/ness-ch4-eqs-1x.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/ness-ch4-eqs-1x.png)'
- en: Just as the d-separation (*C* ⊥*[G]* *T* | *S*) implies that the conditional
    independence statement (*C* ⊥ *T* | *S*) should hold for the observational joint
    distribution, the functional constraint (*C* ⊥*[G]* *h*(*L*, *C*, *T*)) implies
    that *C* is independent of some function *h*(.) of variables *L*, *C*, and *T*
    in the observational joint distribution. Both implications are testable since
    they don’t involve *D*. We now have two tests we can run instead of one.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如d-分离（*C* ⊥*[G]* *T* | *S*）意味着条件独立性陈述（*C* ⊥ *T* | *S*）应该对观测联合分布成立一样，功能约束（*C*
    ⊥*[G]* *h*(*L*, *C*, *T*））意味着在观测联合分布中，*C*与变量*L*，*C*和*T*的某个函数*h*(.)是独立的。这两个含义都是可测试的，因为它们不涉及*D*。我们现在有两个测试可以运行，而不是一个。
- en: '*h*(.) has two components:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*(.)有两个组成部分：'
- en: '*P*(*l*|*c*, *s*, *t*) is a function that returns the probability that *L*
    = *l* (suppose *l* is “true” for “has lung cancer” and “false” for “no lung cancer”),
    given *C* = *c*, *S* = *s*, and *T* = *t*.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*P*(*l*|*c*, *s*, *t*)是一个函数，它返回*L* = *l*（假设*l*对于“有肺癌”是“真”，对于“无肺癌”是“假”），给定*C*
    = *c*，*S* = *s*，和*T* = *t*的概率。'
- en: '*P*(*s*|*c*) is a function that returns the probability that *S* = *s* (suppose
    *s* is “low,” “medium,” or “high” depending on how heavily a smoker smokes) given
    the cost of cigarettes *C* = *c*.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*P*(*s*|*c*)是一个函数，它返回*S* = *s*（假设*s*根据吸烟者吸烟的强度是“低”、“中”或“高”）的概率，给定香烟的成本*C* =
    *c*。'
- en: '*h*(.) then sums over all values of *S*. The function’s output is a random
    variable that, according to the DAG, should be independent of *C*. *h*(*l*, *c*,
    *t*) is a function of *P*(*l*|*c*, *s*, *t*) and *P*(*s*|*c*), and it may feel
    odd thinking about independence in terms of probability functions. Remember that
    the independence relation is itself just a function of joint probability distributions.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*(.)随后对所有*S*的值进行求和。该函数的输出是一个随机变量，根据DAG，它应该与*C*独立。*h*(*l*, *c*, *t*)是*P*(*l*|*c*,
    *s*, *t*)和*P*(*s*|*c*)的函数，并且从概率函数的角度考虑独立性可能感觉有些奇怪。记住，独立性关系本身只是联合概率分布的函数。'
- en: Next, we’ll fit models of *P*(*l*|*c*, *s*, *t*) and *P*(*s*|*c*) from data
    and test this independence relation. But first, we’ll look at libraries that let
    us enumerate functional constraints like (*C* ⊥[*G*] *h*(*L*, *C*, *T*)) from
    a DAG just like we could enumerate d-separations with pgmpy’s `get_independencies`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从数据中拟合*P*(*l*|*c*, *s*, *t*)和*P*(*s*|*c*)的模型，并测试这个独立性关系。但首先，我们将查看允许我们从有向无环图（DAG）中枚举像(*C*
    ⊥[*G*] *h*(*L*, *C*, *T*）这样的功能约束的库，就像我们可以使用pgmpy的`get_independencies`枚举d-分离一样。
- en: 4.5.2 Libraries and perspectives on testing functional constraints
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 测试功能约束的库和视角
- en: How do we derive functional constraints like *C* ⊥[*G*] *h*(*L*, *C*, *T*)?
    Like d-separation, we can derive this type of constraint algorithmically from
    the graph. One implementation is in the `verma.constraints` function in the causaleffect
    R library. This function takes in the DAG with nodes labeled as latent and returns
    a set of testable constraints just like pgmpy’s `get_independencies`. For Python,
    the library Y0 (pronounced “why-not”) has a `r_get_verma_constraints` function
    (as of version 0.2.10), which is a wrapper that calls causaleffect’s R code. I’ll
    omit the Python code here because it requires installing R, but visit www.altdeep.ai/causalAIbook
    for links to libraries and references.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何推导出像 *C* ⊥[*G*] *h*(*L*, *C*, *T*) 这样的功能约束？就像 d-separation 一样，我们可以从图中算法性地推导出这种约束。一个实现是在
    causaleffect R 库中的 `verma.constraints` 函数。这个函数接受标记为潜变量的 DAG，并返回一组可测试的约束，就像 pgmpy
    的 `get_independencies` 一样。对于 Python，Y0 库（发音为“why-not”）有一个 `r_get_verma_constraints`
    函数（截至版本 0.2.10），这是一个包装器，调用 causaleffect 的 R 代码。这里我将省略 Python 代码，因为它需要安装 R，但请访问
    www.altdeep.ai/causalAIbook 获取库和参考链接。
- en: Mathematical intuition for functional constraints, and some advice
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 功能约束的数学直觉和一些建议
- en: Our goal for this section is only to show that there are ways to test your causal
    model even when there are latent variables. Functional constraints are one way
    to do this, but we don’t want to over-index on this particular flavor of testable
    implication. It is more important to avoid the dangerous mindset of limiting ourselves
    only to DAGs that are fully observed in the data.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本节的目标只是表明，即使在存在潜在变量的情况下，也有测试你的因果模型的方法。功能约束是其中一种方法，但我们不想过分强调这种特定的可测试含义。更重要的是避免只限制
    ourselves 只到数据中完全观察到的 DAG 的危险心态。
- en: That said, for the curious, I’ll offer a very high-level intuition for the math.
    Recall that the local Markov property says that *a* *node is conditionally independent
    of its non-descendants, given its parents*. From there, we derive graphical criteria
    called d-separation that lets us find sets of nodes where this applies, we write
    a graph algorithm that uses those criteria to enumerate d-separations, and we
    use that algorithm to enumerate some conditional independence tests we can run.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对于好奇的人来说，我将提供一个非常高级的数学直觉。回想一下，局部马尔可夫性质表明*一个节点在给定其父节点的情况下对其非后代是条件独立的*。从那里，我们推导出称为
    d-separation 的图形标准，使我们能够找到适用此性质的一组节点，我们编写一个使用这些标准的图算法来枚举 d-separation，并使用该算法来枚举我们可以运行的某些条件独立性测试。
- en: 'For a given node *X*, let’s say “orphaned cousins” means non-descendants of
    *X* that share a latent ancestor of *X*. Here is, in informal terms, a latent
    variable analog to the local Markov property: *A node is conditionally independent
    of its non-descendants given its nearest observed ancestors, its orphaned cousins,
    and other nearest observed ancestors of those cousins*. Just as with d-separations,
    we can derive graphical criteria to identify individual cases where this applies.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的节点 *X*，让我们说“孤儿堂兄弟”是指与 *X* 共享潜在祖先的非后代。用非正式的话说，这是一个局部马尔可夫性质的潜在变量类似物：*一个节点在给定其最近的观察祖先、其孤儿堂兄弟以及这些堂兄弟的其他最近的观察祖先的情况下对其非后代是条件独立的*。就像
    d-separation 一样，我们可以推导出图形标准来识别适用此情况的个别案例。
- en: Recall that we can factorize the joint probability distribution such that each
    factor is the conditional probability of a node’s outcome, given its parents.
    The probability functions in the functional constraint (like the *P*(*l*|*c*,
    *s*, *t*) and *P*(*s*|*c*) terms in *h*(*l*,*c*,*t*)) come into the picture once
    we start marginalizing that factorization over the latent variables and doing
    subsequent probability math.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们可以将联合概率分布分解，使得每个因子都是给定其父节点的节点结果的条件概率。当我们开始对潜在变量进行边缘化分解并执行后续的概率数学运算时，功能约束中的概率函数（如
    *h*(*l*,*c*,*t*) 中的 *P*(*l*|*c*, *s*, *t*) 和 *P*(*s*|*c*) 项）就进入了画面。
- en: See the references listed at [https://www.altdeep.ai/p/causalaibook](https://www.altdeep.ai/p/causalaibook)
    if you want to deep dive. But my warning from the previous section holds here—*our
    goal is to falsify our DAG and move on to our target causal inference**.* Beware
    of falling down statistical, mathematical, and theoretical rabbit holes on the
    way to that goal.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解，请参阅 [https://www.altdeep.ai/p/causalaibook](https://www.altdeep.ai/p/causalaibook)
    中列出的参考文献。但请注意，前一部分的警告也适用于这里——*我们的目标是证伪我们的 DAG 并继续进行我们的目标因果推断**。在追求这个目标的过程中，要小心不要陷入统计、数学和理论上的兔子洞。
- en: Now that we have a new testable implication in the form of *C* ⊥*[G]* *h*(*L*,
    *C*, *T*), let’s test it out.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新的可测试的蕴涵，形式为 *C* ⊥*[G]* *h*(*L*, *C*, *T*)，让我们来测试它。
- en: 4.5.3 Testing a functional constraint
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 测试功能约束
- en: 'To test (*C* ⊥*[G]* *h*(*L*, *C*, *T*)), we have to calculate *h*(*l*, *c*,
    *t*) = *∑*[S]*P*(*l*|*c*, *s*, *t*)*P*(*s*|*c*) for each item in our data. That
    requires us to model *P*(*l*| *c*, *s*, *t*) and *P*(*s*|*c*). There are several
    modeling approaches we could go with, but we’ll use a naive Bayes classifier for
    this example so we can stick with using the pgmpy and pandas libraries. We’ll
    take the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 (*C* ⊥*[G]* *h*(*L*, *C*, *T*))，我们必须计算 *h*(*l*, *c*, *t*) = *∑*[S]*P*(*l*|*c*,
    *s*, *t*)*P*(*s*|*c*) 对于我们数据中的每个项目。这需要我们建模 *P*(*l*| *c*, *s*, *t*) 和 *P*(*s*|*c*)。我们可以选择几种建模方法，但我们将使用朴素贝叶斯分类器来举例，这样我们就可以继续使用
    pgmpy 和 pandas 库。我们将采取以下步骤：
- en: Discretize cost (*C*) so we can treat it as a discrete variable.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将成本 (*C*) 离散化，以便我们可以将其视为一个离散变量。
- en: Use pgmpy to fit a naive Bayes classifier to *P*(*l*| *c*, *s*, *t*) and *P*(*s*|*c*).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pgmpy 将朴素贝叶斯分类器拟合到 *P*(*l*| *c*, *s*, *t*) 和 *P*(*s*|*c*)。
- en: Write a function that takes in values of *L*, *C*, *T* and calculates *h*(*L*,
    *C*, *T*).
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受 *L*、*C*、*T* 的值并计算 *h*(*L*, *C*, *T*)。
- en: Apply that function to each row in the data to get a new column of *h*(*L*,
    *C*, *T*) values.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该函数应用于数据中的每一行，以获得新的 *h*(*L*, *C*, *T*) 值列。
- en: Run an independence test between that column and the *C* column.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该列和 *C* 列之间运行独立性测试。
- en: Setting up your environment
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置您的环境
- en: The following code uses pgmpy version 0.1.19 because versions up to 0.1.24 (current
    at the time of writing) have a bug (already reported) that can cause issues with
    some of the naive Bayes classifier inference code. You don’t need to do this if
    you use another method of calculating *P*(*l*|*c*, *s*, *t*) and *P*(*s*|*c*).
    For stability, we’ll also use pandas version 1.4.3, which was the version when
    pgmpy 0.1.19 was current. Note that if you have installed later versions of pgmpy
    and pandas, you might have to uninstall those versions before installing these,
    or you could just spin up a new Python environment. Visit [https://www.altdeep.ai/p/causalaibook](https://www.altdeep.ai/p/causalaibook)
    for links to the Jupyter notebooks with the code and notes on setting up a working
    environment.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 pgmpy 版本 0.1.19，因为截至编写时，版本 0.1.24 及之前的版本存在一个已报告的漏洞，可能会影响一些朴素贝叶斯分类器推理代码。如果您使用其他方法计算
    *P*(*l*|*c*, *s*, *t*) 和 *P*(*s*|*c*)，则无需执行此操作。为了稳定性，我们还将使用 pandas 版本 1.4.3，这是
    pgmpy 0.1.19 当前的版本。请注意，如果您已安装 pgmpy 和 pandas 的后续版本，您可能需要在安装这些版本之前卸载它们，或者您可以启动一个新的
    Python 环境。有关带有代码和设置工作环境说明的 Jupyter 笔记本链接，请访问 [https://www.altdeep.ai/p/causalaibook](https://www.altdeep.ai/p/causalaibook)。
- en: First, we’ll import the data. We’ll also discretize the cost of cigarettes (*C*)
    so it is more amenable to modeling with pgmpy.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入数据。我们还将离散化香烟的成本 (*C*)，使其更适合使用 pgmpy 进行建模。
- en: Listing 4.10 Importing and formatting cigarette and cancer data
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10 导入和格式化香烟和癌症数据
- en: '[PRE12]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 Load the CSV file into a pandas ΔataFrame.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将 CSV 文件加载到 pandas ΔataFrame 中。'
- en: '#2 Δiscretize cost (C) into a discrete variable with three levels to facilitate
    conditional impendence tests.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将成本 (C) 离散化为三个级别的离散变量，以方便进行条件独立性测试。'
- en: '#3 Δiscretize cost (C) into a discrete variable with three levels to facilitate
    conditional impendence tests.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将成本 (C) 离散化为三个级别的离散变量，以方便进行条件独立性测试。'
- en: '#4 Turn lung cancer (L) from a Boolean to a string, so the conditional independence
    test will treat it as a discrete variable.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将肺癌 (L) 从布尔值转换为字符串，以便条件独立性测试将其视为一个离散变量。'
- en: The `print(data_disc)` line prints out the elements of the `data_disc` DataFrame.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(data_disc)` 行打印出 `data_disc` DataFrame 的元素。'
- en: '[PRE13]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we need to model *P*(*l*| *c*, *s*, *t*) and *P*(*s*|*c*). We’ll opt for
    a naive Bayes classifier, a probabilistic model that “naively” assumes that, in
    the case of *P*(*l*| *c*, *s*, *t*), cost (*C*), smoking (*S*), and tar (*T*)
    are conditionally independent given lung cancer status (*L*). According to our
    causal DAG, that is clearly not true, but that doesn’t matter if all we want is
    a good way to calculate probability values for *L* given *C*, *S*, and *T*. A
    naive Bayes classifier will do that well enough.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要建模 *P*(*l*| *c*, *s*, *t*) 和 *P*(*s*|*c*)。我们将选择朴素贝叶斯分类器，这是一个“天真”地假设在 *P*(*l*|
    *c*, *s*, *t*) 的情况下，成本 (*C*)、吸烟 (*S*) 和焦油 (*T*) 在肺癌状态 (*L*) 给定的情况下是条件独立的概率模型。根据我们的因果图，这显然是不正确的，但如果我们只想找到一种计算给定
    *C*、*S* 和 *T* 的 *L* 的概率值的好方法，那就没关系了。朴素贝叶斯分类器可以很好地做到这一点。
- en: Listing 4.11 Fit naive Bayes classifier of *P*(*l*| *c*, *s*, *t*)
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11 适配 *P*(*l*| *c*, *s*, *t*) 的朴素贝叶斯分类器
- en: '[PRE14]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 We’ll use a naive Bayes classifier in pgmpy to calculate the probability
    value for a given value of L given values of C, S, and T. In this case, we’ll
    use variable elimination.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们将在 pgmpy 中使用朴素贝叶斯分类器来计算给定 C, S, 和 T 的值的 L 的概率值。在这种情况下，我们将使用变量消除。'
- en: '#2 We’ll use a naive Bayes classifier in pgmpy to calculate the probability
    value for a given value of L given values of C, S, and T. In this case, we’ll
    use variable elimination.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们将在 pgmpy 中使用朴素贝叶斯分类器来计算给定 C, S, 和 T 的值的 L 的概率值。在这种情况下，我们将使用变量消除。'
- en: Now we’ll do the same for *P*(*s*|*c*).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对 *P*(*s*|*c*) 执行相同的操作。
- en: Listing 4.12 Fit naive Bayes classifier of *P*(*s*|*c*)
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12 适配 *P*(*s*|*c*) 的朴素贝叶斯分类器
- en: '[PRE15]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we’ll bring these together to implement the *h*(*L*, *T*, *C*) function.
    The following code uses a `for` loop to do the summation over *S*.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将这些值组合起来以实现 *h*(*L*, *T*, *C*) 函数。以下代码使用 `for` 循环对 *S* 进行求和。
- en: Listing 4.13 Combine models to create *h*(*L*, *T*, *C*)
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13 合并模型以创建 *h*(*L*, *T*, *C*)
- en: '[PRE16]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 Implement h(L, C, T).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 实现 h(L, C, T)。'
- en: '#2 Implement the summation of P(l|c,s,t) * P(s|c) over s.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 实现对 P(l|c,s,t) * P(s|c) 在 s 上的求和。'
- en: Now, we’ll calculate the full set of outcomes for set {*C*, *T*, *L*}. Given
    these outcomes, we can calculate the *h*(*L*, *C*, *T*) for each of these combinations
    using the preceding function.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将计算集合 {*C*, *T*, *L*} 的全部结果。给定这些结果，我们可以使用前面的函数计算每个组合的 *h*(*L*, *C*, *T*)。
- en: Listing 4.14 Calculate the outcome combinations of *C*, *T*, and *L*
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14 计算 *C*, *T*, 和 *L* 的结果组合
- en: '[PRE17]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 Calculate these values for each possible combination of outcomes of L, C,
    and T. First, we use list comprehensions to make a ΔataFrame containing all the
    combinations.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 计算 L, C, 和 T 的每个可能结果组合的这些值。首先，我们使用列表推导式创建一个包含所有组合的 DataFrame。'
- en: Printing this shows all combinations of outcomes for *C*, *T*, and *L*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 打印这些值显示了 *C*, *T*, 和 *L* 的所有结果组合。
- en: '[PRE18]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For each of these outcomes, we’ll apply *h*(*L*, *C*, *T*).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些结果中的每一个，我们将应用 *h*(*L*, *C*, *T*)。
- en: Listing 4.15 Calculate *h*(*L*, *C*, *T*) for each outcome of C, T, L
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.15 为 C, T, L 的每个结果计算 *h*(*L*, *C*, *T*)
- en: '[PRE19]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now for each joint outcome of *C*, *T*, and *L*, we have a value of *h*(*L*,
    *C*, *T*).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于 *C*, *T*, 和 *L* 的每个联合结果，我们都有一个 *h*(*L*, *C*, *T*) 的值。
- en: '[PRE20]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, we’ll merge this `h_func` distribution into the dataset such that for
    each row of our data, we get a value of *h*(*L*, *C*, *T*).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这个 `h_func` 分布合并到数据集中，使得对于我们的数据中的每一行，我们都能得到一个 *h*(*L*, *C*, *T*) 的值。
- en: Listing 4.16 Merge to get a value of *h*(*L*, *C*, *T*) for each row in the
    data
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.16 合并以获取数据集中每行的 *h*(*L*, *C*, *T*) 值
- en: '[PRE21]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 Add a column representing the variable h(L, C, T).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 添加一个表示变量 h(L, C, T) 的列。'
- en: 'We see the result with `print(df_mod)`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `print(df_mod)` 看到结果：
- en: '[PRE22]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The functional constraint says that *C* and *h*(*L*, *C*, *T*) should be independent,
    so we can look at the evidence of independence between the `h_func` column and
    the *C* column. Since we discretized *C*, our calculated outcomes for *h*(*L*,
    *C*, *T*) are technically discrete, so we could use a chi-squared test. But *h*(*L*,
    *C*, *T*) is continuous in theory, so instead we’ll use a box plot to visualize
    dependence between the two variables. The functional constraint says *C* and *h*(*L*,
    *C*, *T*) should be independent, so we’ll use a box plot that plots values of
    *h*(*L*, *C*, *T*) against values of *C* to visually inspect whether *C* and *h*(*L*,
    *C*, *T*) look independent.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 功能约束表明 *C* 和 *h*(*L*, *C*, *T*) 应该是独立的，因此我们可以查看 `h_func` 列和 *C* 列之间的独立性证据。由于我们对
    *C* 进行了离散化，我们计算 *h*(*L*, *C*, *T*) 的结果在技术上也是离散的，因此我们可以使用卡方检验。但是，从理论上讲，*h*(*L*,
    *C*, *T*) 是连续的，所以我们将使用箱线图来可视化两个变量之间的依赖性。功能约束表明 *C* 和 *h*(*L*, *C*, *T*) 应该是独立的，因此我们将使用一个箱线图，该图将
    *h*(*L*, *C*, *T*) 的值与 *C* 的值进行对比，以直观地检查 *C* 和 *h*(*L*, *C*, *T*) 是否看起来是独立的。
- en: Listing 4.17 Box plot visualizing independence between *C* and *h*(*L*, *C*,
    *T*)
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17 可视化 *C* 和 *h*(*L*, *C*, *T*) 之间的独立性
- en: '[PRE23]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This produces figure 4.21.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了图 4.21。
- en: '![figure](../Images/CH04_F21_Ness.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F21_Ness.png)'
- en: Figure 4.21 A box plot visualization of cost (*C*) on the *x*-axis and the function
    *h*(*L*, *C*, *T*) on the *y*-axis (labeled “Sum product”). The overlap of the
    distributions of the sum product for each value of *C* supports the functional
    constraints assertion that these two quantities are independent.
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.21 在 *x*-轴上显示成本 (*C*) 的箱线图可视化，以及在 *y*-轴上显示函数 *h*(*L*, *C*, *T*)（标记为“乘积和”）。对于每个
    *C* 值的乘积和分布的重叠支持了功能约束断言，即这两个量是独立的。
- en: The *x*-axis in figure 4.21 is different levels of cost (low, medium, and high).
    The *y*-axis represents values of the sum. Figure 4.21 is a box wand whiskers
    plot; each box is a representation of the distribution of the sum product for
    a given value of *C*. The top and bottom of the boxes are the quartiles of the
    distribution, the lines in the middle of the boxes are the median, and the shorter
    horizonal lines are the max and min values (for low cost, the median, upper quartile,
    and max are quite close). In summary, it looks as though the distributions of
    the sum product don’t change much across the different levels of cost; that’s
    what independence is supposed to look like.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21中的*x*-轴表示不同的成本水平（低、中、高）。*y*-轴表示总和的值。图4.21是一个箱线图；每个箱子代表给定*C*值的总和乘积的分布。箱子的顶部和底部是分布的四分位数，箱子中间的线是中位数，较短的横向线是最大值和最小值（对于低成本，中位数、上四分位数和最大值非常接近）。总的来说，看起来总和乘积的分布在不同成本水平上变化不大；这正是独立性应有的样子。
- en: We can also derive a *p*-value using an *analysis of variance* (ANOVA) approach,
    this time using an F-test rather than a chi-squared test. The following code uses
    the statsmodels library to run an ANOVA test.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用方差分析（ANOVA）方法推导出*p*-值，这次使用F检验而不是卡方检验。以下代码使用statsmodels库运行ANOVA测试。
- en: Note  “PR( >F)” means the probability of seeing an F-statistic for a given variable
    (in our case, *C*) is at least as large as the F-statistic calculated from the
    data, assuming that the variable is independent of `sum_product` (i.e., the *p*-value).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意： “PR(>F)”表示对于一个给定变量（在我们的例子中是*C*）看到F统计量的概率至少与从数据中计算出的F统计量一样大，假设该变量与`sum_product`（即*p*-值）独立。
- en: Listing 4.18 Using ANOVA to evaluate independence
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.18 使用ANOVA评估独立性
- en: '[PRE24]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 A recipe for doing ANOVA using the statmodels library'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用statmodels库进行ANOVA的食谱'
- en: '#2 Returns a high p-value, which supports (fails to falsify) the assertion
    that h(L, C, T) and C are independent'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 返回高*p*-值，支持（未能证伪）h(L, C, T)和C独立的断言'
- en: '#3 Just as a sanity check, we run the same test to see whether h(L, C, T) looks
    independent of T and L. Unlike C, T and L should not be independent of h(L, C,
    T) and as expected, these tests return much smaller p-values, indicating dependence.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 仅作为一个合理性检查，我们运行相同的测试来查看h(L, C, T)是否看起来独立于T和L。与*C*不同，T和L不应该独立于h(L, C, T)，正如预期的那样，这些测试返回的*p*-值要小得多，表明存在依赖性。'
- en: We print the *p*-value for *C* with `print(aov_table["PR(>F)"]["C"])` and get
    ~0.1876\. That *p*-value indicates we can’t reject the null hypothesis of independence,
    so it looks like the data supports the constraint. We also run the same test for
    *T* and *L* and, as expected, these are much smaller, indicating evidence of dependence.
    They are lower, both falling below the common .1 threshold where a standard hypothesis
    test would reject the hypothesis that *h*(*L*, *C*, *T*) is independent of *T*
    and *L*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`print(aov_table["PR(>F)"]["C"])`打印出*C*的*p*-值，得到约0.1876。这个*p*-值表明我们不能拒绝独立性的零假设，所以看起来数据支持约束。我们也对*T*和*L*进行了相同的测试，正如预期的那样，这些值要小得多，表明存在依赖性。它们都低于常见的0.1阈值，在这个阈值下，标准假设检验将拒绝*h*(*L*,
    *C*, *T*)独立于*T*和*L*的假设。
- en: 4.5.4 Final thoughts on testable implications
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.4 关于可测试含义的最终思考
- en: A DAG’s d-separation and functional constraints imply that certain conditional
    independencies should hold in the joint probability distribution *if* the DAG
    is a good causal model of the DGP. We can falsify the DAG by running statistical
    tests for conditional independence.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有向无环图（DAG）的d分离和功能约束意味着，如果DAG是DGP的良好因果模型，那么在联合概率分布中应该存在某些条件独立性。我们可以通过运行条件独立性统计测试来证伪DAG。
- en: More generally, a causal model can have different mathematical implications
    for the underlying joint probability distribution, and some of these can be tested.
    For example, if your model assumed the relationship between a cause and effect
    was linear, you could look for evidence of nonlinearity in the data (we’ll see
    more about functional causal assumptions in chapter 6). And, of course, you can
    falsify your model’s implications with experiments (as we’ll see in chapter 7).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，因果模型可以对潜在的联合概率分布有不同的数学含义，其中一些可以进行测试。例如，如果你的模型假设原因和效果之间的关系是线性的，你可以在数据中寻找非线性证据（我们将在第6章中了解更多关于功能因果假设的内容）。当然，你也可以通过实验来证伪你的模型含义（我们将在第7章中看到）。
- en: The better we get at causal modeling, the better we get at testing and falsifying
    our causal models. But remember, don’t let the statistical and mathematical nuances
    of testing distract you from your goal of getting a good enough model and moving
    on to your target causal inference.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在因果建模方面越擅长，我们在测试和证伪我们的因果模型方面就越擅长。但请记住，不要让测试中的统计和数学细微差别分散你的注意力，你的目标是获得一个足够好的模型，并继续进行你的目标因果推断。
- en: 4.6 Primer on (the perils of) causal discovery
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 因果发现（及其风险）简介
- en: In the previous workflow, we proposed a causal DAG, considered what implications
    (like conditional independence) the DAG had for the observational joint distribution,
    and then tested those implications with the data. What if we went in the other
    direction? What if we analyzed the data for statistical evidence of causality
    induced constraints, and then constructed a causal DAG that is consistent with
    those constraints?
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的流程中，我们提出了一个因果有向图（DAG），考虑了DAG对观测联合分布的潜在影响（如条件独立性），然后使用数据对这些影响进行测试。如果我们反过来操作会怎样？如果我们分析数据以寻找因果约束的统计证据，然后构建一个与这些约束一致的因果DAG呢？
- en: 'This describes the task of *causal discovery*: statistical learning of causal
    DAGs from data. In this section, I’ll provide a brief primer on causal discovery
    and cover what you need to know to make use of this class of algorithms.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了*因果发现*的任务：从数据中统计学习因果DAG。在本节中，我将提供因果发现的简要介绍，并涵盖你需要知道的内容，以便使用这类算法。
- en: Beware the false promises of causal discovery
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警惕因果发现的虚假承诺
- en: Causal discovery algorithms are often presented as magical tools that convert
    any dataset, no matter how limited in quality, into a causal DAG. That false promise
    discourages the mindset of modeling the DGP (rather than the data) and falsifying
    candidate models. It is also why it is hard to find consistent use cases for discovery
    in practice. This section takes the approach of framing how discovery algorithms
    work and where they fail, rather than going through a list of algorithms. I’ll
    conclude with advice about how to effectively incorporate these algorithms into
    your analysis workflow.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因果发现算法通常被宣传为神奇的工具，可以将任何数据集（无论质量如何有限）转换为因果DAG。这种虚假承诺阻碍了建模DGP（而不是数据）和证伪候选模型的思维模式。这也是为什么在实践中很难找到一致的发现用例。本节将采用一种方法，即阐述发现算法的工作原理和失败的地方，而不是列出一系列算法。我将通过关于如何有效地将这些算法融入你的分析工作流程的建议来结束。
- en: We’ll start with an overview of key ideas that underpin discovery algorithms.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从支撑发现算法的关键思想概述开始。
- en: 4.6.1 Approaches to causal discovery
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 因果发现方法
- en: There are several approaches to causal discovery. Some algorithms (often called
    *constraint-based* algorithms) do what I just suggested—reverse engineer a graph
    from evidence of conditional independence in the data. Other algorithms (often
    called *score-based* algorithms) turn the causal DAG into an explanatory model
    of the data and find causal DAGs that have a high goodness-of-fit score. Yet another
    approach is to assume additional constraints on the functional relationships between
    parents and children in the causal DAG, as we’ll see with structural causal models
    in chapter 6.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因果发现有几种方法。一些算法（通常称为*基于约束*算法）做的是我刚才建议的事情——从数据中条件独立性的证据中逆向工程一个图。其他算法（通常称为*基于评分*算法）将因果DAG转化为数据的解释模型，并找到具有高拟合度评分的因果DAG。还有一种方法是假设因果DAG中父节点和子节点之间功能关系的额外约束，正如我们在第6章中将要看到的结构因果模型。
- en: The space of possible DAGs is a discrete space. One class of approaches tries
    to soften this space into a continuous space and use continuous optimization techniques.
    The popularity of automatic differentiation libraries for deep learning have accelerated
    this trend.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的DAG空间是一个离散空间。一类方法试图将这个空间软化成一个连续空间，并使用连续优化技术。深度学习自动微分库的流行加速了这一趋势。
- en: Because the space of DAGs can be quite large, it is useful to incorporate prior
    knowledge to constrain the size of that space. This often takes the form of specifying
    what edges must be present or what must be absent, or of using Bayesian priors
    on graph structure.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DAG的空间可能相当大，因此引入先验知识以约束该空间的大小是有用的。这通常表现为指定必须存在的边或必须不存在的边，或者使用图结构的贝叶斯先验。
- en: Some causal discovery algorithms can work with experimental data. This requires
    telling the algorithm which variables were set by the experimenter (or as we’ll
    say starting in chapter 7, which were “intervened upon”).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 一些因果发现算法可以处理实验数据。这需要告诉算法哪些变量是由实验者设置的（或者从第7章开始，我们将说这些变量是“干预”的）。
- en: To get started with causal discovery using Python, I recommend the PyWhy libraries
    for causal discovery such as causal-learn and DoDiscover.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Python进行因果发现，我推荐使用PyWhy库进行因果发现，如causal-learn和DoDiscover。
- en: 4.6.2 Causal discovery, causal faithfulness, and latent variable assumptions
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 因果发现、因果忠实性和潜在变量假设
- en: 'The causal Markov property assumes that if our DAG is true, d-separations in
    that DAG imply conditional independence statements in the joint probability of
    the variables:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 因果马尔可夫性质假设如果我们的DAG是真实的，那么该DAG中的d分离意味着变量联合概率中的条件独立性陈述：
- en: '![figure](../Images/ness-ch4-eqs-2x.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/ness-ch4-eqs-2x.png)'
- en: '*Causal faithfulness* (or just “faithfulness”) is the converse statement—conditional
    independence in the joint distribution implies d-separation in the graph:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*因果忠实性*（或简称“忠实性”）是相反的陈述——联合分布中的条件独立性意味着图中d分离：'
- en: '![figure](../Images/ness-ch4-eqs-3x.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/ness-ch4-eqs-3x.png)'
- en: Many causal discovery algorithms rely on an assumption that faithfulness holds.
    It may not.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 许多因果发现算法依赖于忠实性成立的假设。这可能并不成立。
- en: Discovery and faithfulness violations
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发现与忠实性违反
- en: In section 4.4, we used the Markov property to test a candidate DAG; given a
    d- separation statement that held for the DAG, we ran a statistical test to check
    for empirical evidence of the conditional independence implied by that d-separation.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.4节中，我们使用了马尔可夫性质来测试一个候选DAG；给定一个对于DAG成立的d分离语句，我们运行一个统计测试来检查该d分离所隐含的条件独立性的经验证据。
- en: Imagine you wanted to build your graph by going in reverse. You detect evidence
    of an instance of conditional independence in your data, and then you limit your
    space of candidate DAGs to those consistent with the implied d-separation. You
    do this iteratively until you’ve narrowed down the space of candidate DAGs. Some
    discovery algorithms do some version of this procedure, and those that do are
    relying on a faithfulness assumption.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想要通过逆向构建你的图。你在数据中检测到条件独立性的实例证据，然后你将候选DAG的空间限制为与隐含的d分离一致的DAG。你这样迭代进行，直到你缩小了候选DAG的空间。一些发现算法执行某种版本的此过程，并且那些执行此过程的算法依赖于忠实性假设。
- en: Note  Algorithms that match evidence of conditional independence to d-separation
    are often called “constraint-based” discovery algorithms. A well-known example
    is the PC algorithm. Constraint-based algorithms find DAGs that are *constrained*
    to be consistent with the empirical evidence of causality.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：将条件独立性的证据与d分离相匹配的算法通常被称为“基于约束”的发现算法。一个著名的例子是PC算法。基于约束的算法找到与因果性经验证据一致的DAG。
- en: 'The trouble comes from “faithfulness violations”—special cases where conditional
    independence in a joint probability distribution does not map to d-separation
    statements in a ground truth DAG. A simple example of a faithfulness violation
    is the case of a three-variable system that can decompose as follows: *P*(*x*,
    *y*, *z*) = *P*(*x*, *y*)*P*(*y*, *z*)*P*(*x*, *z*). That is, for any value of
    one variable, the association between the other two variables is always the same.
    You could detect this peculiar form of independence in data, but you can’t represent
    it with d-separation in a DAG. (If you don’t believe me, try.)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 麻烦来自于“忠实性违反”——在联合概率分布中条件独立性不映射到真实DAG中的d分离语句的特殊情况。一个简单的忠实性违反的例子是一个可以如下分解的三变量系统：*P*(*x*,
    *y*, *z*) = *P*(*x*, *y*)*P*(*y*, *z*)*P*(*x*, *z*)。也就是说，对于任何一个变量的任何值，其他两个变量之间的关联总是相同的。你可以在数据中检测到这种奇特的独立性形式，但你不能在DAG中使用d分离来表示它。（如果你不相信我，可以试试。）
- en: Researchers worry about these special cases because they mean a discovery algorithm
    that relies on faithfulness doesn’t generalize to all distributions. When you
    use these algorithms, you are assuming faithfulness holds for you problem domain,
    and that’s not something you can test. However, violations of causal faithfulness
    are not typically the biggest source of headaches in practical causal discovery.
    That honor is reserved for latent variables.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员担心这些特殊情况，因为这意味着一个依赖于忠实性的发现算法并不能推广到所有分布。当你使用这些算法时，你是在假设忠实性在你所面临的问题域中成立，而这并不是你可以测试的事情。然而，因果忠实性的违反通常并不是实际因果发现中最大的头痛来源。这个荣誉留给了潜在变量。
- en: The challenge of latent variables
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 潜在变量的挑战
- en: The bigger pain is that most causal discovery algorithms, yet again, have a
    latent variable problem. To illustrate, suppose the true causal DAG was the DAG
    in figure 4.22.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的问题是，大多数因果发现算法再次面临潜在变量问题。为了说明这一点，假设真实的因果图是图4.22中的图。
- en: '![figure](../Images/CH04_F22_Ness.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F22_Ness.png)'
- en: Figure 4.22 Assume this is the true causal DAG. Here, *B*, *C*, and *D* are
    conditionally independent, given *A*.
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.22 假设这是真实的因果图。在这里，*B*、*C*和*D*在给定*A*的条件下是条件独立的。
- en: In this DAG, variables *B*, *C*, and *D* are conditionally independent of one
    another, given *A*. Now suppose that *A* were not observed in the data. With *A*
    as a latent variable, the discovery algorithm can’t run tests like *B* ⊥ *C* |
    *A*. The algorithm will detect a dependence between *B*, *C*, and *D* but will
    not find conditional independence between the three given *A*, and it might possibly
    return a DAG like figure 4.23, which reflects these results.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，变量*B*、*C*和*D*在给定*A*的条件下相互独立。现在假设数据中没有观察到*A*。以*A*作为潜在变量，发现算法无法运行*B* ⊥ *C*
    | *A*这样的测试。算法会检测到*B*、*C*和*D*之间的依赖性，但不会在给定*A*的情况下找到三个变量之间的条件独立性，并且它可能会返回如图4.23所示的图，反映了这些结果。
- en: '![figure](../Images/CH04_F23_Ness.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F23_Ness.png)'
- en: Figure 4.23 If *A* is latent, conditional independence tests that condition
    on *A* can’t be run. The algorithm would detect dependence between *B*, *C*, and
    *D* but no conditional independence given *A*, and it might possibly return a
    graph such as this.
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.23 如果*A*是潜在的，那么基于*A*的条件独立性测试无法运行。算法会检测到*B*、*C*和*D*之间的依赖性，但不会发现给定*A*的条件独立性，并且它可能会返回如图所示的图。
- en: The remedy for this problem is to provide strong domain-specific assumptions
    about the latent variable structure in the discovery algorithm. A few generic
    discovery algorithms provide some accommodation for latent variable assumptions
    (the causal-learn library has a few). But this is rare, because it is hard to
    make it easy for users to specify domain-specific assumptions while still generalizing
    across domains.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是在发现算法中提供关于潜在变量结构的强领域特定假设。一些通用的发现算法为潜在变量假设提供了一些适应（例如，因果-学习库有几个）。但这很少见，因为很难在跨领域泛化的同时让用户容易地指定领域特定假设。
- en: 4.6.3 Equivalence classes and PDAGs
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.3 等价类和PDAGs
- en: Let’s suppose our algorithm were to correctly recover all the true conditional
    independence statements from data and map them back to a true set of d-separation
    statements (causal faithfulness holds). The problem we face now is that multiple
    causal DAGs may have the same set of d-separation statements. This set of candidate
    DAGs is called a *Markov equivalence class*. The true causal DAG would be one
    of a possibly large set of members of this class.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的算法能够从数据中正确地恢复所有真实的条件独立性陈述，并将它们映射回一个真实的d分离陈述集（因果忠实性成立）。我们现在面临的问题是，多个因果图可能具有相同的d分离陈述集。这个候选因果图的集合被称为*马尔可夫等价类*。真实的因果图将是这个可能很大的集合中的一个成员。
- en: For example, suppose the DAG on the left of figure 4.24 were the ground truth
    DAG. The DAG on the right of the graph differs from the correct graph in the edge
    between *A* and *T*. The two graphs have the same set of d-separation. In fact,
    we can also change the directions of the edges between {*L*, *S*} and {*B*, *S*}
    and still be in the same equivalence class, except for introducing a collider
    {*L* → *S* ← *B*}, because a new collider would change the set of d-separations.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设图4.24左边的图是真实因果图。图右边的图在*A*和*T*之间的边与正确的图不同。这两个图有相同的d分离集。实际上，我们还可以改变{*L*，*S*}和{*B*，*S*}之间的边的方向，仍然处于相同的等价类，除了引入一个碰撞器{*L*
    → *S* ← *B*}，因为新的碰撞器会改变d分离集。
- en: '![figure](../Images/CH04_F24_Ness.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH04_F24_Ness.png)'
- en: Figure 4.24 Supposing the DAG on the left is the ground truth DAG, the (wrong)
    DAG on the right is in the same Markov equivalence class. The PDAG in the middle
    represents the equivalence class, where undirected edges represent edges where
    members disagree on direction.
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.24假设左边的DAG是真实DAG，右边的（错误）DAG与马尔可夫等价类相同。中间的PDAG代表等价类，其中无向边缘表示成员对方向存在分歧的边缘。
- en: Some discovery algorithms will return a partially directed acyclic graph (PDAG),
    such as the DAG in the center of figure 4.24\. In the PDAG, undirected edges correspond
    to edges where there is disagreement on the edge’s direction between members of
    the Markov equivalence class. This is nice, because we get a graphical representation
    of the equivalence class, and the algorithm can potentially search through the
    space of PDAGs instead of the larger space of DAGs.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一些发现算法会返回部分定向无环图（PDAG），如图4.24中心的DAG所示。在PDAG中，无向边缘对应于马尔可夫等价类成员之间对边缘方向存在分歧的边缘。这很好，因为我们得到了等价类的图形表示，并且算法可以潜在地在PDAG的空间而不是更大的DAG空间中搜索。
- en: Colliders and discovery
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对撞机和发现
- en: Colliders feature prominently in causal discovery because they allow us to orient
    edges in the DAG from evidence of statistical dependence alone. Suppose we are
    using data to attempt to construct the ground-truth DAG in figure 4.24\. We find
    evidence of dependence in the data of an edge between *A* and *T*. The idea of
    Markov equivalence means that evidence is not enough to determine the direction
    of that edge. Generally, evidence of dependence and independence in the data can
    imply the presence of edges but not their direction.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对撞机在因果发现中占有重要地位，因为它们使我们能够仅根据统计依赖的证据来定向DAG中的边缘。假设我们正在使用数据尝试构建图4.24中的真实DAG。我们在数据中发现了*A*和*T*之间边缘的依赖性证据。马尔可夫等价性的想法意味着证据不足以确定该边缘的方向。通常，数据中的依赖性和独立性证据可以暗示存在边缘，但无法确定其方向。
- en: Colliders are the exception. It is possible to detect colliders like {*T* →
    *E* ← *L*} from evidence of independence and dependence alone; if the data suggests
    *T* and *L* are independent, but become dependent when conditioning on *E*, you
    have evidence of a collider with directed edges {*T* → *E* ← *L*}.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对撞机是个例外。仅从独立性和依赖性的证据中，我们可以检测到像{*T* → *E* ← *L*}这样的对撞机；如果数据表明*T*和*L*是独立的，但在条件化*E*时变得依赖，那么你就有了具有定向边缘{*T*
    → *E* ← *L*}的对撞机的证据。
- en: 'Colliders can also force orientation of edges outside of the collider. For
    example, consider the edge between *E* and *X* in the ground-truth DAG in figure
    4.23\. We might infer the existence of that edge from the following evidence in
    the data:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对撞机还可以强制对撞机外的边缘进行定向。例如，考虑图4.23中真实DAG中*E*和*X*之间的边缘。我们可能从以下数据中的证据推断出该边缘的存在：
- en: '*E* and *X* are dependent.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*和*X*是相关的。'
- en: '*T* and *X* are dependent.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*T*和*X*是相关的。'
- en: '*T* and *X* are independent, given *E*.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定*E*的情况下，*T*和*X*是独立的。
- en: An edge between *E* and *X* is consistent with that evidence, but should we
    go with *E* → *X* or *E* ← *X*? Here, the collider {*T* → *E* ← *L*} helps; it
    already oriented the edge *T* → *E*, so adding *E* ← *X* would induce another
    collider {*T* → *E* ← *X*}. That collider would suggest *T* and *X* are independent
    but become dependent when conditioning on *E*, which violates the second and third
    observed items of evidence. So we conclude the edge is oriented as *E* → *X* by
    process of elimination.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*和*X*之间的边缘与该证据一致，但我们应该选择*E* → *X*还是*E* ← *X*？在这里，对撞机{*T* → *E* ← *L*}有帮助；它已经定向了边缘*T*
    → *E*，因此添加*E* ← *X*将诱导另一个对撞机{*T* → *E* ← *X*}。这个对撞机会表明*T*和*X*是独立的，但在条件化*E*时变得依赖，这违反了观察到的第二和第三项证据。因此，我们通过排除法得出结论，该边缘的方向是*E*
    → *X*。'
- en: Some causal discovery algorithms essentially algorithmicize this kind of logic.
    But remember, this logic breaks down when latent variables induce dependence between
    observed variables.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一些因果发现算法本质上算法化了这种逻辑。但记住，当潜在变量在观测变量之间诱导依赖时，这种逻辑就会失效。
- en: That said, PDAGs and Markov equivalence classes only capture equivalence between
    DAGs encoding the same set of conditional independence constraints. If you want
    to find all graphs that satisfy an additional layer of constraining assumptions,
    such as all graphs that have the same posterior probability given a certain prior,
    then the PDAG might not be sufficient.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，PDAG和马尔可夫等价类仅捕获编码相同一组条件独立性约束的DAG之间的等价性。如果你想找到所有满足额外约束假设的图，例如给定某个先验概率具有相同后验概率的所有图，那么PDAG可能就不够了。
- en: If we go only on conditional independence, data can’t distinguish between members
    of the Markov equivalence class, because having the same set of d-separations
    means having the same evidence of conditional independence in the data. This is
    an example of a *lack of causal identification*—when our data and a set of causal
    assumptions are not sufficient to disambiguate between possible answers to a causal
    question (in this case “what is the right causal DAG?”). We’ll explore causal
    identification in depth in chapter 10.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只依赖于条件独立性，数据无法区分马尔可夫等价类中的成员，因为拥有相同的d分离集合意味着在数据中拥有相同的条件独立性证据。这是一个*缺乏因果识别*的例子——当我们的数据和一组因果假设不足以区分因果问题的可能答案时（在这种情况下，“正确的因果DAG是什么？”）。我们将在第10章深入探讨因果识别。
- en: 4.6.4 How to think about causal discovery
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.4 如何思考因果发现
- en: In section 4.3, I argued that testing for causality induced constraints like
    conditional independence using off-the-shelf hypothesis testing libraries should
    be viewed more as a heuristic approach to refuting your causal DAG than a rigorous
    statistical procedure for validating the DAG. Similarly, I argued that for the
    practical user, off-the-shelf causal discovery algorithms should be viewed as
    a tool for exploratory data analysis during a human-driven causal DAG building
    process. The more you can input various types of domain knowledge and knowledge
    of latent variables into these algorithms, the better. But even then, they will
    produce obvious errors. Just as with the hypothesis testing case, avoid rabbit
    holes of trying to “fix” the discovery algorithm so it doesn’t make these errors.
    Use causal discovery as one imperfect tool in your broader project of building
    a good causal DAG and running the subsequent causal inference analysis.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.3节中，我论证了使用现成的假设测试库来测试因果诱导的约束，如条件独立性，应被视为一种反驳你的因果DAG的启发式方法，而不是验证DAG的严格统计程序。同样，我论证了对于实际用户来说，现成的因果发现算法应被视为在人为驱动的因果DAG构建过程中进行探索性数据分析的工具。你能够将这些算法输入更多类型的领域知识和潜在变量的知识，就越好。但即便如此，它们仍会产生明显的错误。就像假设测试案例一样，避免陷入试图“修复”发现算法以避免这些错误的兔子洞。将因果发现作为构建一个好的因果DAG和进行后续因果推断分析更广泛项目中的一个不完美的工具。
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Causal modeling induces conditional independence constraints on the joint probability
    distribution. D-separation provides a graphical representation of conditional
    independence constraints.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因果建模在联合概率分布上引入了条件独立性约束。D分离提供了条件独立性约束的图形表示。
- en: Building an intuition for d-separation is important for reasoning about causal
    effect inference and other queries.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立对d分离的直觉对于推理因果效应推断和其他查询非常重要。
- en: The colliders might make d-separation confusing, but you can build intuition
    by using d-separation functions in NetworkX and pgmpy.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞器可能会使d分离变得复杂，但你可以通过在NetworkX和pgmpy中使用d分离函数来建立直觉。
- en: Using traditional conditional independence testing libraries to test d-separation
    has its challenges. The tests are sensitive to sample size, they don’t work well
    in many machine learning settings, and their hypotheses are misaligned.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传统的条件独立性测试库来测试d分离有其挑战。这些测试对样本大小敏感，在许多机器学习环境中表现不佳，并且它们的假设不匹配。
- en: Because of these challenges, it is best to view the attempts to falsify the
    DAG using off-the-shelf conditional independence testing libraries as more of
    a heuristic. Focus on the overall goal of building a good (i.e., hard to refute)
    causal DAG and moving on to your downstream causal inference task. Avoid fixating
    on theoretical rigor in statistical hypothesis testing.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这些挑战，最好将使用现成的条件独立性测试库来尝试否定DAG视为更多是一种启发式方法。专注于构建一个好的（即难以反驳的）因果DAG和继续进行下游因果推断任务的整体目标。避免在统计假设检验中过分关注理论严谨性。
- en: When there are latent variables, a causal DAG may still have testable implications
    for functions of the observed variables.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存在潜在变量时，因果DAG对于观察变量函数的测试性含义仍然可能存在。
- en: Causal discovery refers to the use of statistical algorithms to recover a causal
    DAG from data.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因果发现是指使用统计算法从数据中恢复因果DAG。
- en: The causal faithfulness property assumes conditional independence in the joint
    probability distribution maps to a true set of d-separations that hold in the
    ground truth causal DAG.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因果忠实性属性假设在联合概率分布中条件独立性映射到在真实因果DAG中保持的真正的d分离集合。
- en: A Markov equivalence class of DAGs is a set of DAGs with the same set of d-separations.
    Assuming you have the true set of d-separations, the ground truth causal DAG generally
    shares that set with other (wrong) DAGs.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DAGs的马尔可夫等价类是一组具有相同d分离集的DAGs。假设你拥有真实的d分离集，那么真实的因果DAG通常与其他（错误的）DAGs共享这个集合。
- en: Causal discovery is especially vulnerable to latent variables.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因果发现特别容易受到潜在变量的影响。
- en: The more you can constrain causal inference with prior assumptions, such as
    latent structure and which edges cannot possibly exist and which must exist, the
    better.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能通过先验假设（如潜在结构和哪些边不可能存在以及哪些必须存在）来约束因果推理越多，效果越好。
- en: Causal discovery algorithms are useful exploratory data analysis tools in the
    process of building a causal DAG, but they are not reliable replacements for that
    process. Again, focus on the overall goal of building a good causal DAG and moving
    on to the downstream causal inference analysis. Avoid trying to “fix” causal discovery
    algorithms so they don’t produce obvious errors in your domain.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因果发现算法在构建因果DAG的过程中是很有用的探索性数据分析工具，但它们并不是该过程的可靠替代品。再次强调，关注构建一个好的因果DAG和进行下游因果推理分析的整体目标。避免试图“修复”因果发现算法，以免在你的领域产生明显的错误。
