- en: appendix A Discovering graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, we explore the theory and implementations of graphs that are
    most pertinent to using the GNNs covered in the rest of the book. The goal is
    to help those of you who are less familiar with graphs learn enough to follow
    the book (if you’re familiar with graphs, you can skip this appendix). We establish
    basic definitions, concepts, and nomenclature, and then survey how the theory
    is realized in real systems. This foundation is not only necessary to follow the
    material in this book but also for building the insights that make architecting
    custom systems and troubleshooting errors easier.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in a rapidly evolving field, the ability to quickly absorb new
    academic and technical literature is crucial for staying up to date with the state
    of the art. We also provide the basic background to pick up the essence of relevant
    published papers. In this appendix, we’ll use a running example of a social networking
    dataset to demonstrate the concepts. This is a dataset of more than 1,900 professionals
    and their industry relationships. Figure A.1 visualizes this graph (generated
    using Graphistry).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure A.1 A stylized visualization of the example social network, consisting
    of industry professionals and their relationships. The nodes (dots) are the professionals,
    and the edges (lines) denote a relationship between people. In this visualization,
    created using Graphistry, the left image shows an edge diverge out of the frame
    (bottom right). The right image is the entire graph, showing the cut-off edges
    and nodes.**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A.1 Graph fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with some definitions, and then we’ll see how the concepts work.
  prefs: []
  type: TYPE_NORMAL
- en: Key terms
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Graph*—A data type consisting of nodes and edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Node*—Also called a *vertex* or *point*, a node is an endpoint in a graph.
    They are connected by edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Edge*—Also called a *link* or *relationship*, an edge connects nodes. They
    can be directed or undirected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![sidebar figure](../Images/A-unnumb.png)'
  prefs: []
  type: TYPE_IMG
- en: Loops and three types of edges
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Directed edge*—A directed edge, usually represented by an arrow, denotes a
    one-way relationship or flow from one node to another.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Undirected edge*—An undirected edge has no direction. In such an edge, a relationship
    or flow can go in either direction.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adjacent*—The property that two nodes are directly connected via an edge.
    Such nodes are said to be *joined*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Self-loop*—An edge that connects a node to itself. Such edges can be directed
    or undirected.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Parallel edges*—Multiple edges that connect the same two nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Weights*—One important attribute of an edge is weight, which is a numerical
    value assigned to an edge. Such an attribute can describe the intensity of the
    connection, or some other real-world value, such as length (if a graph modeled
    cities on a road map).'
  prefs: []
  type: TYPE_NORMAL
- en: These concepts give us the tools to create the simplest graphs. With a simple
    graph created from these concepts, we could derive network properties explained
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: While real-world graphs are complex, simple graphs can often effectively represent
    them for various purposes. For example, though our social graph data contains
    node features (covered in section A.1.2), to create the visualization in figure
    A.1, we only used node and edge information.
  prefs: []
  type: TYPE_NORMAL
- en: A.1.1 Graph properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following subsections, we discuss some of the more important properties
    of graphs. Many of the software programs and databases in the graph ecosystem
    (described in section A.3) should have the capability to compute some or all of
    these properties.
  prefs: []
  type: TYPE_NORMAL
- en: Size/order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re often interested in the overall number of nodes and edges in a graph.
    Formal names for these properties are *size* (the number of edges) and *order*
    (the number of nodes). In our social graph, the number of nodes is 1,933, and
    the number of edges is 12,239.
  prefs: []
  type: TYPE_NORMAL
- en: Degree distribution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A degree distribution is simply the distribution of the degrees of all the nodes
    in a graph. This can be shown as a histogram, as in figure A.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *degree* of a node is the number of adjacent nodes in an undirected graph.
    For directed graphs, there are two types of degrees a node can have: an *in-degree*
    for edges directed to the node and an *out-degree* for edges directed outward
    from the node. Self-loops often are given a count of 2 when calculating degree.
    If edges are given weights, a *weighted degree* can also account for these weights.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.2 A histogram showing the degree distribution of our social graph
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Related to the concept of a degree is that of a node’s neighborhood. For a given
    node, its adjacent nodes are also called its *neighbors*. The set of all its neighbors
    is called its *neighborhood*. The number of vertices in a node’s neighborhood
    is equal to that node’s degree.
  prefs: []
  type: TYPE_NORMAL
- en: Connectedness
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A graph is a set of nodes and edges. In general, however, there is no condition
    that says for an undirected graph, every node can be reached by any other node
    within the same network. It can happen that within the same graph, sets of nodes
    are utterly separated from one another; that is, no edge links them.
  prefs: []
  type: TYPE_NORMAL
- en: An undirected graph where any node can reach any other node is called a *connected
    graph*. It may seem obvious that all graphs must be connected, but this is often
    not the case. Graphs that have discontinuities (where a node or set of nodes are
    unlinked to the rest of the graph) are *disconnected graphs*. Another way to think
    about this is that in a connected graph, there is a path or walk whereby every
    node can reach every other node in the graph. For a disconnected graph, each disconnected
    piece is called a *component*. For a directed graph, where it’s not always possible
    to reach any node from any other node, a *strongly connected graph* is one where
    every node can reach every other node.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the human population can be considered a disconnected social
    graph if we consider every individual human as a node and our communication channels
    as edges. While most of the population can be said to be connected by modern communication
    channels, there are hermits who chose to live off the grid and isolated hunter-gatherer
    tribes that reject contact with the rest of the world. In other use cases, there
    are often discontinuities in the network and its data.
  prefs: []
  type: TYPE_NORMAL
- en: Examining our social graph, we see it’s disconnected with a large component
    that contains most of the nodes. Figures A.3 and A.4 show the entire graph, and
    the large connected component. If we focus on the large connected component, we
    find that the number of nodes is 1,698 and the number of edges is 12,222.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.3 Our entire social graph, which is disconnected. (`NetworkX` was used
    to generate this figure.) We observe a large connected component at the center,
    surrounded by disconnected nodes and small components consisting of two to three
    nodes.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![figure](../Images/A-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.4 The connected component of the social graph. (NetworkX was used to
    generate this figure.) Compare this to figure A.1, which is the same graph visualized
    using Graphistry. Differences in the parameters used in the algorithms, as well
    as visual features, account for the distinctiveness of the two figures.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Graph traversals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a graph, we can imagine traveling from a given node *a* to a second node
    *b*. Such a trip may require passing only one edge or passing several edges and
    nodes. Such a trip is called a *traversal*, or a *walk*, among other names. A
    traversal from one node to another is sometimes called a *hop*. Traversing a series
    of nodes is said to be done in *n* hops. A walk can be *open* or *closed*. Open
    walks have an ending node that is different from the starting node. A closed walk
    starts and ends with the same node.
  prefs: []
  type: TYPE_NORMAL
- en: A *path* is a walk where no node is encountered more than once. A *cycle* is
    a closed path (with the exception of the starting node, which is also the ending
    node, no node is encountered twice). A *trail* is a walk where no edge is encountered
    more than once, and a *circuit* is a closed trail. Examples of these different
    types of paths are given in figure A.5\. Note how the number of steps (or hops)
    changes between different types of paths.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that for a given pair of nodes, we could find walks and paths between
    them. Of the paths we could navigate, there will be the shortest one (or maybe
    more than one path will tie for shortest). The length of this path is called the
    *distance* or *shortest path length*.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.5 Five types of paths
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we zoom out and examine the entire graph and its node pairs, we can list
    all the shortest path lengths. One of these distances will be the longest (or
    more than one may tie for longest). The largest distance is the *diameter* of
    the graph. The diameter is often used to characterize and compare graphs.
  prefs: []
  type: TYPE_NORMAL
- en: If we take our list of distances and average them, we’ll generate the *average
    path length* of the graph. Average path length is another important measure for
    graphs. Both average path length and diameter give an indication of the density
    of the graph. Higher values for these metrics imply more connections, which in
    turn allow a greater variety of paths, both longer and shorter.
  prefs: []
  type: TYPE_NORMAL
- en: For our social graph, the diameter of our largest component is 10\. The diameter
    is undefined for the entire graph, as it’s unconnected.
  prefs: []
  type: TYPE_NORMAL
- en: Subgraphs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a graph of nodes and edges. A *subgraph* is a subset of these nodes
    and edges. Subgraphs are of importance when these neighborhoods in the graph have
    properties that are distinct from other locations in the graph. Subgraphs occur
    in connected and disconnected graphs. A component of a disconnected graph is a
    subgraph.
  prefs: []
  type: TYPE_NORMAL
- en: Clustering coefficient
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A node may have a high degree, but how well connected is its neighborhood? We
    can imagine an apartment building where everyone knows the landlord, but no one
    knows their neighbors (what a sad place!). The landlord would have a clustering
    coefficient of 0\. At the other extreme, we could have an apartment where the
    landlord knows all the tenants, and every tenant knows every other tenant. Then,
    the landlord would have a clustering coefficient of 1 (such a situation, where
    all the nodes in a network are connected to every other node is called a *complete
    graph* or *fully connected graph*). Of course, there will be intermediate cases
    where only some of the tenants know one another, and these situations will have
    coefficients between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: The dimension of a graph
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In machine learning and engineering in general, *dimension* is used in several
    ways. This term can be confusing as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even within the topic of graphs, the term is used in a few ways in articles
    and academic literature. However, the term is often not explicitly defined or
    clarified. Thus, in the following list, we attempt to deconstruct the meaning
    of this term:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Size/shape of datasets*—In this case, dimension refers to the number of features
    in a dataset. Low-dimensional datasets are implied to be small enough to visualize
    (i.e., two or three features) or small enough to be computationally viable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mathematical definitions*—In math, the dimension of a graph has more strict
    definitions. In linear algebra, graphs can be represented in vector spaces, and
    the dimension is an attribute of these vector spaces [1].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Geometric definition*—There is also a geometric definition of a graph’s dimension.
    This definition relates a graph’s dimension to the least number of Euclidean dimensions
    that will allow a graph’s edges to be of unit size 1 [1].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.1.2 Characteristics of nodes and edges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the most basic type of graph, we have a collection of nodes and edges, without
    parallel edges or self-loops. For this basic graph, we have a geometric structure
    only. While even this basic graph structure is useful, often more complexity is
    desired to properly model a situation for real-world problems and use cases. For
    example, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reduce the geometric restrictions discussed earlier. Explicitly, these restrictions
    are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each edge is incident to two nodes, one on each end of the edge.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Between two nodes, only one edge can exist.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No self-loops are used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With these restrictions relaxed, we’re able to model more situations at the
    cost of more complex graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Add *properties* to our graph elements (nodes, edges, the graph itself).
    A property or feature is data tied to a specific element. Depending on the context,
    terms such as *labels*, *attributes*, and *decorators* are used in place of *properties*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section and the next, we’ll discuss the characteristics and variants
    of nodes, edges, and entire graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Node properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following list, we outline some of the different properties that nodes
    might contain. These become features in many data science or GNN tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Names, IDs, and unique identifiers*—A name or an ID is a unique identifier.
    Many graph systems will either assign an identifier such as an index to a node,
    or allow the user to specify an ID. In our social graph, each node has a unique
    alphanumeric ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Labels*—Within a graph, nodes may fall within certain classes or groups. For
    example, a graph modeling a social network may group people by their country of
    residence (USA, PRC, Nigeria) or their level of activity within the network (frequent
    user, occasional user). In this way, in contrast to the unique identifiers explained
    earlier, we’d expect several nodes to share the same label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Properties/attributes/features*—Properties that aren’t IDs or labels are usually
    called attributes or features. While such properties don’t have to be unique to
    a node, they don’t describe a node class either. Properties can be based on structural
    or nonstructural qualities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Structural/topological properties*—Intrinsic characteristics of a node are
    related to the node’s topological properties and the geometrical structure of
    the graph in proximity to the node. Two examples are listed here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A node’s degree, which, as we learned, is the number of incident edges it has.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A node’s centrality, which is a measure of how important a node is relative
    to the nodes in its neighborhood.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By employing graph analytical methods (described in section A.4) characteristics
    of nodes, relative to their local environment, can be identified. These can be
    incorporated into certain GNN problems as features. Node embeddings such as those
    generated by transductive methods (chapter 2) are another example of a property
    based on the graph’s local structure.
  prefs: []
  type: TYPE_NORMAL
- en: '*Nonstructural properties*—These are often based on real-world attributes.
    Taking the example of our social graph, we have two categorical properties: a
    person’s job category (e.g., scientist, marketer, administrator) and the type
    of company they work for (e.g., medical, transportation, consulting). These examples
    are categorical attributes. It’s possible to have numerical attributes, such as
    *years of experience* or *average number of direct reports* in all current and
    past roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Edge properties —*Properties for edges mirror those for nodes. The most often
    used and important edge property is that of the edge weight, described earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge variations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike nodes, there are a few geometric variants of edges that can be used to
    make a graph model more descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: '*Parallel edges*—Meaning more than one edge between two nodes *u* and *v*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Directionality*—Edges can have no direction or one direction. Because nodes
    *u* and *v* can have parallel edges connecting them, it’s possible to have two
    edges with opposite directionality or multiple edges with some combination of
    directions or undirectionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bidirectionality*—The case where between two nodes, both directions are represented
    in the respective edges. In practice, this term is used in a few ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To describe nondirected edges, or simple edges.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To describe two edges that have opposite directions (shown in figure A.6).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![figure](../Images/A-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.6 From top to bottom, between two nodes, an example of an undirected
    edge, a directed edge from left to right, a directed edge from right to left,
    and two directed edges traversing both directions (bidirectionality)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To describe an edge that has a direction at each end. This usage, while popular
    in the literature, is fairly rare in practical systems at the time of writing.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Self-loops*—Discussed previously, a self-loop, or loop, is the case where
    both ends of an edge connect to the same node. Where would one encounter a self-loop
    in the real world? For our social graph, let’s keep all the nodes, and consider
    a case where an edge would be an email sent from one professional to another.
    Sometimes, people send emails to themselves (for reminders). For such a scenario,
    an email to oneself could be modeled as a self-loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.1.3 Categories of graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Different categories of graphs depend on the node and edge characteristics
    we’ve just described. Following are the graph categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Simple graph*—A graph whose edges can’t be parallel edges or self-loops. Simple
    graphs can be connected or disconnected, as well as directed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Weighted graph*—A graph that uses weights. Our social graph has no weights;
    another way to express having no weights is to set all weights to 1 or 0\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Multigraphs —*A graph that is permitted to have multiple edges between any
    two nodes and multiple self-loops for any one node. A simple graph could be a
    special case of a multigraph if we’re working within a problem where we could
    add more edges and self-loops to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Di-graphs*—Another term for a directed graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*K-partite graphs*—In many graphs, we may have a situation where we have two
    or more groups of nodes, where edges are only allowed between groups and not between
    nodes of the same group. “Partite” refers to the partitions of node groups, and
    “k” refers to the number of those partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Monopartite graph*—A graph in which there is only one group of nodes and one
    group of edges. A monopartite social graph could consist of only “Texan” nodes
    connected with “work colleague” edges. For example, in a social graph, nodes can
    belong to “New Yorkers” or “Texans” groups, and relationships can belong to “friend”
    or “work colleague” groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bipartite (or bi-graph) graph*—A graph that has two node partitions within
    a graph. Nodes of one group can only connect to nodes of a second type and not
    to nodes within their own group. In our social graph example, nodes can belong
    to “New Yorkers” or “Texans” groups, and relationships can belong to “friend”
    or “work colleague” groups. In this graph, no New Yorkers would be adjacent to
    other New Yorkers, and the same for Texans. This is shown in figure A.7\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![figure](../Images/A-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.7 A bipartite graph. There are two types of nodes (upper and lower
    row of circles). In a bipartite graph, nodes can’t be connected to nodes of the
    same type (those in the same row). This is also an example of a heterogeneous
    graph.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For more than three partitions, the requirement that adjacent nodes can’t be
    the same type still holds. In practice, *k* can be a large number.
  prefs: []
  type: TYPE_NORMAL
- en: '*Trees*—A tree is a well-studied data structure in machine learning and is
    a special case of a graph. It’s a connected graph without cycles. Another way
    to describe a graph without cycles is *acyclic*. In the data science and deep
    learning worlds, a well-known example is the directed acyclic graph (DAG), used
    in designing and governing data workflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hypergraphs*—Up to now, our graphs have consisted of edges that connect to
    two nodes or one node (a self-loop). For a hypergraph, an edge can be incident
    to more than two nodes. These data structures have a range of applications, including
    ones that involve the use of GNNs. This is shown in figure A.8\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Heterogeneous graphs*—A heterogeneous graph has multiple node and edge types,
    while a multirelational graph has multiple edge types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![figure](../Images/A-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.8 One undirected hypergraph, illustrated in two ways. On the left,
    we have a graph whose edges are represented by shaded areas and marked by letters,
    and whose vertices are dots, marked by numbers. On the right, we have a graph
    whose edge lines (marked by letters) connect up to three nodes (circles marked
    by numbers). Node 8 has no edge. Node 7 has a self-loop.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A.2 Graph representations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a conceptual idea of what graphs are, we move on to how to
    work with them. First, we focus on data structures most relevant to building graph
    algorithms and storing graph data. We’ll see that some of these structures, particularly
    the adjacency matrix, play a prominent role in the GNN algorithms we study in
    the bulk of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll examine a few graph data models. These are important in designing
    and managing how databases and other data systems deal with network data. Lastly,
    we’ll briefly take a look at how graph data is exposed to analysts and engineers
    via APIs and query languages.
  prefs: []
  type: TYPE_NORMAL
- en: A.2.1 Basic graph data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few important ways to represent graphs that can be ported to a
    computational environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adjacency matrix*—A node-to-node matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Incidence matrix*—An edge-to-node matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Edge lists*—A list of edges by their nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adjacency lists*—Lists of each node’s adjacent nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Degree matrix*—Node-to-node matrix of degree values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Laplacian matrix*—The degree matrix minus the adjacency matrix (**D**-**A**).
    This is useful in spectral theory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are by no means the only ways to represent a graph, but from a survey
    of the literature, software, storage formats, and libraries, these are the most
    prevalent. In practice, a graph may not be permanently stored as one of these
    structures, but to execute a needed operation, a graph or subgraph may be transformed
    from one representation to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'What representations are used depends on many factors that should be weighed
    in planning. These factors include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Size of graph*—How many vertices and edges does the graph contain, and how
    much are these expected to scale?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Density of graph*—Is the graph sparse or dense? We’ll touch on these terms
    in the next subsection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Complexity of the graph’s structure*—Is the graph closer to a simple graph,
    or one that uses one or more of the variations discussed previously?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Algorithms to be used*—For a given algorithm, a given data structure may perform
    relatively weakly or strongly compared to others. In the following subsections,
    for each structure, we’ll touch on two simple algorithms to compare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Costs to do CRUD (create, read, updated, delete) operations*—How will you
    modify your graph (including creating, reading, updating, or deleting nodes, edges,
    and their attributes) over the course of your operations and how frequently will
    you do so?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In many data projects, transformation from one data structure to another is
    common to accommodate particular operations. So, it’s normal to employ two or
    more of the previously mentioned data structures in a project. In this case, understanding
    the compute effort to execute the transformation is key. For the most popular
    structures, graph libraries allow methods that allow seamless transformations,
    but given the considerations listed previously, executing these transformations
    could take unexpected time or cost.
  prefs: []
  type: TYPE_NORMAL
- en: For the following discussion, we’ll talk about how these data structures are
    used to store topological information about graphs. The only attributes we’ll
    consider are node IDs and edge weights. To illustrate these concepts, let’s use
    the weighted graph, consisting of five nodes, as shown in figure A.9\. Circles
    indicate nodes with their IDs; rectangles are the edge weights.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.9 An example graph with different weighted edges and labeled nodes
    from 0 to 4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now dive into those six popular ways of representing graphs so they can
    be used computationally.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a graph with *n* nodes, an *adjacency matrix* represents the graph as an
    *N* × *N* matrix format, where each row or column describes the edge between two
    nodes. For our example graph, shown previously in figure A.9, we have five columns
    and five rows. These rows and columns are labeled for each node. Cells of the
    matrix denote adjacency.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrices can be used for simple directed and undirected graphs. They
    can also be used for graphs with self-loops. In an unweighted graph, each cell
    is either 0 (no adjacency) or 1 (adjacency). For a weighted graph, the values
    in the cells are the edge weights. For unweighted parallel edges, the values of
    the cells are the number of edges.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, a weighted, undirected graph, the corresponding adjacency matrix
    is shown in table A.1\. Because our graph is undirected, the adjacency matrix
    is symmetric. For directed graphs, symmetry is possible but not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Table A.1 An adjacency matrix for the graph in figure A.9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0**  | 0  | 0  | 0  | 3  | 5  |'
  prefs: []
  type: TYPE_TB
- en: '| **1**  | 0  | 0  | 0  | 1  | 1  |'
  prefs: []
  type: TYPE_TB
- en: '| **2**  | 0  | 0  | 0  | 3  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| **3**  | 3  | 1  | 3  | 0  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| **4**  | 5  | 1  | 0  | 0  | 0  |'
  prefs: []
  type: TYPE_TB
- en: By inspecting this matrix, we can get a quick visual understanding of the characteristics
    of the matrix. We can see, for example, how many degrees node 1 has and get a
    general idea of the distribution of the degrees. We also see that there are more
    empty spaces (cells with a 0 value) than edges. This ease of using the matrix
    to draw quick insights for small graphs is one advantage of adjacency matrices.
    Even for large graphs, plotting the adjacency matrix can indicate certain subgraph
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrices, and matrix representations in general, allow you to analyze
    graphs by using linear algebra. One relevant example is spectral graph theory
    (which underlies a few GNN algorithms).
  prefs: []
  type: TYPE_NORMAL
- en: 'Adjacency matrices are straightforward to implement in Python. The matrix in
    our example can be created using a list of lists, or a NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With our adjacency matrix as a NumPy array, let’s explore another property
    of our graph. From our visual inspection of our matrix, we noticed many more zero
    values than nonzero values. This makes it a sparse matrix. *Sparse matrices*,
    that is, matrices with a large proportion of zero values, can take up unnecessary
    storage or memory space and increase calculation times. *Dense matrices*, contrarily,
    contain a large proportion of nonzero matrices. The following determines the sparsity
    of our matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, our matrix has a sparsity of 0.6, meaning 60% of the values in this matrix
    are zeros.
  prefs: []
  type: TYPE_NORMAL
- en: Sparsity using node degree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to think about sparsity is in terms of node degree. Let’s derive
    the sparsity value just shown from the perspective of the node degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple, undirected graph of *n* nodes, each node can make at most *n-1*
    connections, and thus have a maximum degree of *n-1*. The maximum number of edges
    can be calculated using combinatorics: because each edge represents a pair of
    nodes, for a set of *n* nodes, the maximum number of edges is “*n* choose 2”,
    that is, *(n C 2)* or *n*(*n* – 1)/2\. However, for our small matrix, we have
    a directed graph, which is clear because the adjacency matrix isn’t symmetric.
    This means that both directions count separately and need to times by 2\. Hence,
    for our small matrix, the maximum number of possible edges is 5(5 – 1) = 20\.
    The density of a graph is defined as the actual number of edges, *e*,over all
    possible edges, and sparsity can then be defined as 1 – density. In our example,
    this leads to a quantity that disagrees with what was calculated using the matrix
    alone, namely (1 – 10/20) = 0.5, which is not equal to 0.6 in the preceding code
    snippet. This is because we haven’t considered self-loops, which is standard practice
    for graph theory. If we included self-loops, we would have five additional possible
    edges (or 5^2), resulting in (1 – 10/25), or 0.6, matching the value in the earlier
    code. This highlights that care needs to be taken when reporting on the sparsity
    of a graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, think of a graph that has not five, but millions or billions of nodes.
    Such graphs exist in the real world, and quite often the sparsity can be orders
    of magnitudes less than 0.6\. For undirected simple graphs, the adjacency matrix
    is symmetric, so only half the storage is needed. Most of the memory or storage
    containing the adjacency matrix would be devoted to zero values. Thus, the high
    sparsity of this data structure leads to memory inefficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of complexity, for a simple graph, the space complexity would be **O**(*n*²),
    for undirected simple graphs. For an undirected graph, due to the symmetry, the
    space complexity would be **O**(*n*(*n*–1)/2).
  prefs: []
  type: TYPE_NORMAL
- en: 'For time complexity, this of course depends on the task or the algorithm. Let’s
    look at two rudimentary tasks that we’ll also address for adjacency list and edge
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the existence of an edge between a particular pair of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the neighbors of a node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first task, we simply check the row and column corresponding to those
    nodes. This would take **O**(1) time. For the second, we need to check every item
    in that node’s row; this would take **O**(deg(*n*)) time, where deg(*n*) is the
    degree of the node.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the advantages of adjacency matrices are that they can quickly
    check connections between nodes and are easy to visually interpret. The downsides
    are that they are less space-efficient for sparse matrices. The computational
    tradeoffs depend on your algorithm. They shine in cases where we have small and
    dense graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Incidence matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the adjacency matrix has a row and column for every node, an *incidence
    matrix* represents every edge as a column and every node as a row. Using the same
    graph shown earlier in figure A.9, we can construct an incidence matrix, which
    we show in table A.2.
  prefs: []
  type: TYPE_NORMAL
- en: Table A.2 Incidence matrix for the example graph in figure A.9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0**  | 0  | 3  | 5  | 0  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| **1**  | 0  | 0  | 0  | 1  | 1  |'
  prefs: []
  type: TYPE_TB
- en: '| **2**  | 3  | 0  | 0  | 0  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| **3**  | 3  | 3  | 0  | 1  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| **4**  | 0  | 0  | 5  | 0  | 1  |'
  prefs: []
  type: TYPE_TB
- en: An incidence matrix can represent wider variations of graph types than an adjacency
    matrix. Multigraphs and hypergraphs are straightforward to express with this data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: How does the incidence matrix perform with respect to space and time? To store
    the data of a simple graph, the incidence matrix has a space complexity of **O**(*|E|*
    * *|V|*), where *|V|* is the number of nodes (*V* for vertices), and *|E|* is
    the number of edges. Thus, it’s superior to the adjacency matrix for graphs with
    fewer edges than nodes, including sparse matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea of time complexity, we turn to our two simple tasks: checking
    for an edge, and finding a node’s neighbors. To check the existence of an edge,
    an incidence matrix has a time complexity of O(*|E|* * *|V|*), far slower than
    the adjacency matrix, which does this in constant time. To find the neighbors
    of a node, an incidence matrix also takes O(*|E|* * *|V|*).'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, incidence matrices have space advantages when used with sparse matrices.
    For time performance, they have slow performance on the simple tasks we covered.
    The overall advantage of using incidence matrices is for unambiguously representing
    complex graphs, such as multigraphs and hypergraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In an *adjacency list*, the aim is to show which vertices each node is adjacent
    to. So, for *n* nodes, we have *n* lists of neighbors corresponding to each node.
    Depending on what data structures are used for the lists, properties may also
    be included in the summary. For our example, a simple adjacency list is shown
    in figure A.10.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.10 Our example graph and its adjacency list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Such an adjacency list can be accomplished in python using a dictionary with
    each node as the keys, and lists of the adjacent nodes as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can improve on the dictionary values to allow for the inclusion of the weights
    of the neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For undirected graphs, the set of nodes doesn’t have to be ordered. Because
    the adjacency list doesn’t devote space to node pairs that aren’t neighbors, we
    see that adjacency lists lack the sparsity problems of adjacency matrices. So,
    to store this data structure, we have a space complexity of **O**(n + v), where
    *n* is the number of nodes, and *v* is the number of edges.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the two computational tasks, checking the existence of an edge
    (task 1) would take **O**(deg(node)) time, where deg(node) is the degree of either
    node. For this, we simply check every item in that node’s list, where for the
    worst case, we’d have to check them all. For task 2, finding a node’s neighbors
    would also take **O**(deg(node)) time, because we have to inspect every item in
    that node’s list whose length is the node’s degree.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize the tradeoffs of an adjacency list. The advantages are that
    they are relatively efficient in terms of storage because only edge relationships
    are stored. This means a sparse matrix would take up less space stored as an adjacency
    list than as an adjacency matrix. Computationally, the tradeoffs depend on the
    algorithm you’re running and the type of graph you’re using as input data.
  prefs: []
  type: TYPE_NORMAL
- en: Edge lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compared to the preceding two representations, *edge lists* are relatively
    simple. They consist of a set of doubles (two nodes) or triples (two nodes and
    an edge weight). These identify a unique edge thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: Node, node (edge weight), for an undirected graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source node, destination node (edge weight), for a directed graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edge lists can represent single, unconnected nodes. For our example graph,
    the edge list would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, we can create this as a set of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On performance, for storage, the space complexity of an edge list is O(*e*),
    where *e* is the number of edges. Regarding our two tasks shown previously, to
    establish the existence of a particular edge will have a time complexity of **O**(*e*),
    assuming an unordered edge list. To discover all the neighbors of a node, **O**(*e*)
    is the space complexity. In each case, we have to go through the edges in the
    list one by one to check for the edge or the node’s neighbor. So, from a compute
    performance point of view, edge lists have a disadvantage compared to the other
    two data structures, especially for executing more complex algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: However, another advantage of edge lists is that they are more compact than
    adjacency lists or adjacency matrices. Additionally, they are simple to both create
    and interpret. For example, we could store an edge list as a text file where each
    line only consists of two identifiers separated by a space. For many systems and
    databases, edge lists in CSV or text files are the default option to serialize
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The Laplacian matrix
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One data representation of a graph that is highly valuable in analyzing graphs
    is the Laplacian matrix, as mentioned earlier. This matrix is key to the development
    of graph spectral theory, which is in turn critical to the development of spectral-based
    GNN methods.
  prefs: []
  type: TYPE_NORMAL
- en: To produce the Laplacian matrix, we subtract the adjacency matrix from the degree
    matrix (D – A). The degree matrix is a node-to-node matrix whose values are the
    degree of a particular node. The degree matrix for our example graph is given
    in the first table and the Laplacian matrix follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![sidebar figure](../Images/table_A-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Degree matrix for our example graph
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![sidebar figure](../Images/table_A-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Laplacian matrix for our example graph
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In practice, Laplacian matrices aren’t used for storage or as a basis for graph
    operations like the other data structures covered in this section. Their advantages
    lie in spectral analysis. We discuss spectral graph analysis in chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: A.2.2 Relational databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re steadily marching from theory to implementation. In the previous section,
    we reviewed common data structures used to represent graphs and their tradeoffs.
    Graphs can be implemented in these structures from scratch in your preferred programming
    language and are also implemented in popular graph processing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: With the listed data structures, we have a variety of ways to implement the
    structural information in graphs. But graphs and their elements often come with
    useful attributes and metadata.
  prefs: []
  type: TYPE_NORMAL
- en: A *relational database* is an organized way to represent the structural information,
    attributes, and metadata of a graph. Very much related to this is the notion of
    a *schema*, which is a framework that explicitly defines the elements that make
    up a graph (i.e., varieties of nodes and edges, attributes, etc.), and explicitly
    defines how these elements work together.
  prefs: []
  type: TYPE_NORMAL
- en: Data models and schemas are critical parts of the scaffolding used to design
    graph systems such as graph databases and graph processing systems, and they often
    build on the data structures reviewed in the previous section. We’ll review three
    such models and provide examples of real systems where they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Minimalist graph data model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest relational database uses only nodes, edges, and weights. It can
    be used on directed or undirected graphs. If weights are used, they can be retrieved
    using a lookup table.
  prefs: []
  type: TYPE_NORMAL
- en: Pregel, Google’s graph processing framework, which other popular frameworks
    are based on (including Apache Giraph used by Facebook, and Apache Spark GraphX),
    relies on such a directed graph. There, both edges and nodes have an identifier
    and a single numerical value, which can be interpreted as a weight or attribute.
  prefs: []
  type: TYPE_NORMAL
- en: RDF graph data model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Resource Description Framework (RDF; aka Triple Stores) models follow a subject-predicate-object
    pattern, where nodes are subjects and objects, and edges are predicates. Nodes
    and edges have one main attribute, which can be a unique resource identifier (URI)
    or a literal. URIs, in essence, identify the type of node or edge being described.
    Examples of literals can be specific timestamps or dates. Predicates represent
    relationships. Such triples (subject-predicate-object) represent what are called
    *facts* in this context. Usually, facts are directed and flow in the direction
    from subject to object.
  prefs: []
  type: TYPE_NORMAL
- en: Popular graph databases that use the RDF model include Amazon’s Neptune (Neptune
    also allows the use of labeled property graphs [LPGs]), Virtuoso, and Stardog.
  prefs: []
  type: TYPE_NORMAL
- en: Property graph data model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In property graphs (aka LPGs), allowances are made to confer various metadata
    to nodes and edges. Such metadata include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Identifiers* —Distinguish individual nodes and edges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Labels* —Describe classes (or subsets) of nodes or edges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attributes or properties* —Describe individual nodes or edges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes have an ID and a set of key/value pairs that can be used to supply additional
    attributes (also called properties). Similarly, edges have an ID and a set of
    key/value pairs for attributes.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the property graph as the minimalist graph extended by adding
    labels and removing the restrictions on the types and number of attributes. Figure
    A.11 provides a look at a property graph and its equivalent RDF graph. Popular
    graph databases that use models based on the property graph include Neo4j, Azure
    Cosmos, and TigerGraph.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.11 Example of a property graph and its equivalent RDF graph
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Nongraph data model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a variety of databases and systems that use neither RDF nor LPG. These
    databases and systems store or express nodes, edges, and attributes within other
    storage frameworks, such as document stores, key value stores, and even within
    a relational database framework.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge graphs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although the term is used widely in academic, commercial, and practitioner circles,
    there is no unifying definition of a knowledge graph. Most relevant to GNNs, we
    define a *knowledge graph* as a representation of knowledge discretized into facts,
    as defined earlier. In other words, a knowledge graph is a multigraph set onto
    a specific *subject-relationship-object* schema.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge graphs may be represented with RDF schemas, but there are other data
    models and graph models that can accommodate knowledge graphs. GNN methods are
    used to embed the data in the nodes and edges, establish the quality of facts,
    and discover new entities and relations. An example of a knowledge graph is shown
    in figure A.12\.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.12 An example of a knowledge graph representing an academic research
    network within a university’s physics department. The graph illustrates both hierarchical
    relationships, such as professors and students being members of the department,
    and behavioral relationships, such as professors supervising students and authoring
    papers. Entities such as Prof, Student, Paper, and Topic are connected through
    semantically meaningful relationships (e.g., Supervises, Wrote, and Inspires).
    Entities also have detailed features (e.g., Name, Department, and Type) to provide
    further context. The semantic connections and features enable advanced querying
    and analysis of complex academic interactions.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Node and edge types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In graphs that have a schema, including knowledge graphs, the edges and nodes
    can be assigned a *type*. *Types* are part of a defined schema, and as such, govern
    how data elements interact with each other. They also often have a descriptive
    aspect. To distinguish *types* from *properties*, consider that while types help
    define the rules of how data elements work together and how they are interpreted
    by the data system, properties are descriptive only.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate types, we can use a road map analogy, where towns are nodes,
    and passages between them are edges. Our edges may include highways, footpaths,
    canals, or bike paths. Each one is a type. Due to geography, towns can be surrounded
    by swamps, sit atop mountain peaks, or have other obstacles and impediments to
    one versus another passage. For towns separated by a desert, passage is only possible
    by a highway. For other towns, passages can be by multiple passage types. In building
    this analogy, we see that our town nodes also have types defined by their proximate
    geography: swamp town, desert town, island town, valley town.'
  prefs: []
  type: TYPE_NORMAL
- en: A.2.3 How graphs are exposed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve talked about relational data structures and relational databases to understand
    how graphs are constructed and stored. In real life, however, most of us won’t
    build graphs from scratch or from the bottom up. When constructing and analyzing
    graphs, there will be a layer of abstraction between us and the primitive data.
    In what ways, then, is a graph exposed to the data scientist or engineer? Next,
    we’ll briefly explain the following two ways and then discuss the graph ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '*APIs* —Using graph libraries or data processing systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Query languages* —Querying graph databases via specialized query languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'APIs: Graph objects in graph systems'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using a graph library or processing software, usually we want the graph
    we work with to have certain properties and to be able to execute operations on
    the graph. From this lens, it’s helpful to think of graphs as software objects
    that can be operated on by software functions.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, an effective way to implement these is to have a graph class, with
    some operations implemented as methods of the graph class or as standalone functions.
    Nodes and edges can be attributes of the graph class, or they can have their own
    node and edge classes. Properties of graphs implemented in this way can be attributes
    of the respective classes.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is `NetworkX`, a Python-based graph processing library. `NetworkX`
    implements a graph class. Nodes can be any hashable object; examples of node objects
    are integers, strings, files, and even functions. Edges are tuple objects of their
    respective nodes. Both nodes and edges can have properties implemented as Python
    dictionaries. Following are two short lists of typical methods and attributes
    of graph classes found in libraries and processing systems.
  prefs: []
  type: TYPE_NORMAL
- en: Basic methods of graph objects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following list, we outline some of the methods that can be applied to
    graph objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Graph_Creation`—A constructor that creates a new graph object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add_Node`, `Add_Edge`—Adds nodes or edges, and their attributes and labels,
    if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get_Node`, `Get_Edge`—Retrieves stored nodes or edges, with specified attributes
    and labels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update_Node`, `Updage_Edge`, `Update_Graph`—Updates properties and attributes
    of nodes, edges, and graph objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delete_Node`, `Delete_Edge`—Deletes a specified node or edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic attributes of graph objects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following list, we outline some of the attributes for graph objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number_of_Nodes`, `Number_of_Edges`—A constructor that creates a new graph
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node_Neighbors`—Retrieves the adjacent nodes or incident edges of a node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node_List`, `Edge_List`—Adds nodes or edges and their attributes and labels,
    if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Connected_Graph`—Retrieves stored nodes or edges, with specified attributes
    and labels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Graph_State`—Retrieves global attributes, labels, and properties of the graph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Directed_Graph`—Deletes a specified node or edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph query languages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When working with a graph in a graph database, a query language is used. For
    most relational databases, some variant of SQL is used as the standard language.
    In the graph database space, there is no standard query language. Following are
    the languages that currently stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Gremlin*—A language that can be written declaratively or imperatively, which
    is designed for database or processing system queries. Developed by the Apache
    TinkerPop project, Gremlin is used in several databases (Titan, OrientDB) and
    processing systems (Giraph, Hadoop, Spark).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cypher*—A declarative language for property graph–based database queries.
    Developed by Neo4j, Cypher is used by Neo4j and several other databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SPARQL*—A declarative query language for RDF-based database queries. SPARQL
    is used by Amazon Neptune, AllegroGraph, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.3 Graph systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve covered the basic building blocks that allow us to implement graphs in
    a programming language. In practice, you’ll seldom create a graph from scratch
    because you’ll load data into memory or a database using a library or API. The
    field of graph libraries, databases, and commercial software is broad and growing
    rapidly. A good way to determine what to use is to start with your use case and
    requirements, and then choose your development and deployment architecture from
    there. This section will briefly give an overview of this landscape to help you.
    The taxonomy we develop here is by no means absolute but should serve as a useful
    guideline.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, commercial and open source tools for graph analysis,
    machine learning modeling, visualization, and storage are expanding relatively
    rapidly. With a lot of overlap between tools and functions, as well as many hybrid
    tools that don’t neatly fit into any category, there is no clean delineation of
    segments. Given this, we just highlight basic methods and focus on the most popular
    tools in the following segments:'
  prefs: []
  type: TYPE_NORMAL
- en: Graph databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph compute engines (or graph frameworks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualization libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNN libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.3.1 Graph databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graph databases are the graph analogues of traditional relational databases
    from a functional standpoint. Such databases were devised to handle transactions
    focused on Online Transaction Processing (OLTP). They allow CRUD transactions
    and also tend to follow ACID (atomicity, consistency, isolation, and durability)
    principles regarding the integrity of the data. Graph databases of this type differ
    from relational databases in that they store data using graph data models and
    schemas. At the time of writing, the most popular graph databases are Neo4j, Microsoft
    Cosmos DB, OrientDB, and ArangoDB. Except for Neo4j, these databases support multiple
    models, including property graphs. Neo4j supports property graphs only. The most
    popular databases that support RDF models are Virtuoso and Amazon Neptune.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to property graphs and RDF databases, other types of nongraph databases
    are used to store graph data. Document stores, relational databases, and key-value
    stores are examples. To use such nongraph databases with graph data models, you
    must carefully define how the existing schema maps to the graph elements and their
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: A.3.2 Graph compute engines (or graph frameworks)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graph compute engines are designed to make queries using batches of data. Such
    queries can output aggregate statistics or output graph-specific items, such as
    cluster identification and find shortest paths. These data systems tend to follow
    the Online Application Processing (OLAP) model. It’s not unusual for such systems
    to work closely with a graph database, which serves the input data batches needed
    for the analytic queries. Examples of such systems include Apache Spark’s GraphX,
    Giraph, and Stanford Network Analysis Platform (SNAP).
  prefs: []
  type: TYPE_NORMAL
- en: A.3.3 Visualization libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graph visualization tools share characteristics with graph compute engines,
    as they are geared toward analytics versus transactional queries and computations.
    However, such tools are designed to create aesthetic and useful images of the
    networks under analysis. In the best visualization tools, these images are interactive
    and dynamic. Outputs of visualization systems can be optimized for presentation
    on the web, or in printed format with high definition. Examples of such tools
    are Gephi, Cytoscape, and Tulip.
  prefs: []
  type: TYPE_NORMAL
- en: A.3.4 GNN libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last segment of graph tools is the central subject of this book. Here, we’re
    grouping software tools that create graph embeddings with tools that train the
    models using graph data. At the time of writing, there are many solutions available.
    Graph representation tools range from dedicated, standalone libraries (PyTorch
    BigGraph [PBG]) to graph systems that have embedding as a feature (Neo4j as a
    database and SNAP as a compute framework).
  prefs: []
  type: TYPE_NORMAL
- en: GNN libraries come as standalone libraries, and as libraries that use TensorFlow
    or PyTorch as a backend. In this text, the focus will be on PyTorch Geometric
    (PyG). Other popular libraries include Deep Graph Library (DGL; a standalone library)
    and Spektral, which uses Kera and TensorFlow as a backend. The best libraries
    implement not only a range of deep learning layers but also the available benchmark
    datasets.
  prefs: []
  type: TYPE_NORMAL
- en: A.4 Graph algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the field of graphs has been around for a while, the number of different
    graph algorithms is vast. Understanding well-used graph algorithms can provide
    valuable context with which to think about the algorithms used in neural networks.
    Graph algorithms can also serve as sources of node, edge, or graph features for
    GNNs. Finally, as with all machine learning methods, sometimes a statistical model
    isn’t the best solution. Understanding the analytical landscape can help when
    deciding whether or not to use a GNN solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we review two types of graph algorithms, *search algorithms*
    and *shortest path*. We provide a general description, explaining why they are
    important. For an in-depth treatment on this topic, review the references for
    this appendix at the end of the book, particularly [1–3].
  prefs: []
  type: TYPE_NORMAL
- en: A.4.1 Traversal and search algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In section A.1.1, we discussed the concept of a walk and a path. In these fundamental
    concepts, we get from one node in a graph to another by traversing a set of nodes
    and edges between them.
  prefs: []
  type: TYPE_NORMAL
- en: For large graphs with many nonunique walks and paths between node pairs, how
    do we decide which path to take? Similarly, for graphs we haven’t explored and
    don’t have a map of, what is the best way to create that map? Wrapped into these
    questions is the problem of what direction to take when traversing a graph at
    a particular node. For a node of degree 1, this answer is trivial; for a node
    with degree 100, the answer is less so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traversal algorithms offer systematic ways to walk a graph. For such algorithms,
    we start at a node, and following a set of rules, we decide on the next node to
    hop to. Often, as we conduct the walk, we keep track of nodes and edges that have
    been encountered. For certain algorithms, if we outline the path taken, we can
    end up with a tree structure. Three well known strategies for traversal are given
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Breadth first* —A breadth-first traversal prefers to explore all of the immediate
    neighbors of a node before going further away. This is also known as breadth-first
    search (BFS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Depth first* —With depth-first search (DFS), rather than explore every immediate
    neighbor first, we follow each new node without regard to its relationship to
    the current node. This is done in such a way that every node is encountered *at
    least* once, and every edge is encountered *exactly* once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are versions of DFS and BFS for directed graphs as well.
  prefs: []
  type: TYPE_NORMAL
- en: '*Random* —In random traversals, in contrast to BFS and DFS, where traversal
    is governed by a set of rules, traversal to the next node is done randomly. For
    a starting node of degree 4 in a random traversal with a uniform distribution,
    each neighboring node would have a 25% chance of being chosen. Such methods are
    used in algorithms such as DeepWalk and Node2Vec (covered in chapter 2).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.4.2 Shortest path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An enduring problem highly related to graphs is that of the shortest path.
    Interest in solving this problem has existed for decades (a great survey paper
    of shortest path methods was published as far back as 1969 [4]), with several
    distinct algorithms existing. Modern applications of shortest path methods are
    used in navigation applications, such as finding the fastest route to a destination.
    Variations of such algorithms include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Shortest path between
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two nodes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two nodes on a path that includes specified nodes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All nodes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One node to all others
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranked shortest paths (i.e., second shortest path, third shortest, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such algorithms can also take into account weights in graphs. In these cases,
    shortest path algorithms are also called least-cost algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: A highly lauded algorithm for least-cost determination is Dijkstra’s algorithm.
    Given a node, it finds the shortest path to every other node or to a specified
    node. As this algorithm progresses, it traverses the graph while keeping track
    of the distance and connecting nodes (to the start node) of each node it encounters.
    It prioritizes the nodes encountered by their shortest (or least-cost) path to
    the start node. As the algorithm traverses, it prioritizes low-cost paths.
  prefs: []
  type: TYPE_NORMAL
- en: A.5 How to read GNN literature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNNs are a rapidly proliferating topic. New methods and techniques have been
    proposed in a short span of time. Though this book focuses on practical and commercial
    applications of graphs, much of the state of the art in this field is disclosed
    in academic journals and conferences. Knowing how to effectively study publications
    from these sources is essential to keep up to speed with the field and to encounter
    valuable ideas that can be implemented in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this short section, we list some commonly used notations to describe graphs
    in technical publications as well as a few tips on reading academic literature
    for the practitioner. These tips are especially for those interested in using
    the methodology in a paper but are working under time constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: To efficiently extract value from a paper, be selective on which sections of
    the publication to focus on. It’s important to clearly understand the problem
    statement and the solution to translate this into code. This might sound obvious,
    but many papers include sections that, for a practitioner, can be distracting
    at best. Mathematical proofs and long historical notes are good examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive trend is the increasing inclusion of code and data in research papers
    to enhance reproducibility. However, replicating results may still be challenging
    due to factors like model-specific optimizations or hardware constraints. If you
    encounter difficulties, reaching out to the authors can often provide valuable
    clarification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look closely at indicators of the application scope of the problem and solution.
    An exciting development may not be applicable to your problem, and it may not
    be immediately obvious. Similarly, don’t take all claims for state-of-the-art
    results at face value. The academic world is extremely competitive and claimed
    state-of-the-art results may not hold, especially if a paper isn’t yet peer-reviewed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.5.1 Common graph notations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In mathematical notation, a graph is described as a set of nodes and edges:'
  prefs: []
  type: TYPE_NORMAL
- en: (A.1) *G* = (*V*, *E  *)
  prefs: []
  type: TYPE_NORMAL
- en: 'where *V* and *E* are collections or sets of vertices (nodes) and edges, respectively.
    When we want to express the count of elements in these collections, we use *|V|*
    and *|E|*. In the following list, we outline some of the typical nomenclature
    for the mathematics of graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: For directed graphs, an accented G (*![equation image](../Images/eq-appendix-a-269-1.png)*)
    is sometimes, but not always used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual nodes and edges are denoted by lowercase letters, *v* and *e*, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When referring to a pair of adjacent nodes, we use *u* and *v*. Thus, an edge
    can also be expressed as {*u*, *v*}, or *uv*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with weighted graphs, a weight for a particular edge is expressed
    as *w*(*e*). In terms of an edge’s nodes, we can include the weight as {*u*, *v*,
    *w*}.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To express the features of a graph or its elements, we use the notation *x*
    or **x** when the features are expressed as a vector or matrix, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For graph representations, because many such representations are matrices,
    bold letters are used to express them: **A** for the adjacency matrix, **L** for
    the Laplacian matrix, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
