- en: appendix A Discovering graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A 发现图
- en: In this appendix, we explore the theory and implementations of graphs that are
    most pertinent to using the GNNs covered in the rest of the book. The goal is
    to help those of you who are less familiar with graphs learn enough to follow
    the book (if you’re familiar with graphs, you can skip this appendix). We establish
    basic definitions, concepts, and nomenclature, and then survey how the theory
    is realized in real systems. This foundation is not only necessary to follow the
    material in this book but also for building the insights that make architecting
    custom systems and troubleshooting errors easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们探讨了与本书中涵盖的GNNs最相关的图理论和实现。目标是帮助那些不太熟悉图的人学习足够的知识来跟随本书（如果你熟悉图，可以跳过这个附录）。我们建立了基本定义、概念和命名法，然后概述了理论如何在现实系统中实现。这个基础不仅对于跟随本书中的材料是必要的，而且对于构建使构建定制系统和错误排除更容易的见解也是必要的。
- en: Additionally, in a rapidly evolving field, the ability to quickly absorb new
    academic and technical literature is crucial for staying up to date with the state
    of the art. We also provide the basic background to pick up the essence of relevant
    published papers. In this appendix, we’ll use a running example of a social networking
    dataset to demonstrate the concepts. This is a dataset of more than 1,900 professionals
    and their industry relationships. Figure A.1 visualizes this graph (generated
    using Graphistry).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在一个快速发展的领域，快速吸收新的学术和技术文献的能力对于跟上最前沿的状态至关重要。我们还提供了基本背景，以便抓住相关已发表论文的精髓。在这个附录中，我们将使用一个社交网络数据集的运行示例来展示这些概念。这是一个包含1900多名专业人士及其行业关系的数据库。图A.1可视化了这个图（使用Graphistry生成）。
- en: '![figure](../Images/A-1.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-1.png)'
- en: '**Figure A.1 A stylized visualization of the example social network, consisting
    of industry professionals and their relationships. The nodes (dots) are the professionals,
    and the edges (lines) denote a relationship between people. In this visualization,
    created using Graphistry, the left image shows an edge diverge out of the frame
    (bottom right). The right image is the entire graph, showing the cut-off edges
    and nodes.**'
  id: totrans-4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**图A.1 示例社交网络的风格化可视化，包括行业专业人士及其关系。节点（点）是专业人士，边（线）表示人与人之间的关系。在这个使用Graphistry创建的可视化中，左图显示一条边从框架中发散出来（右下角）。右图是整个图，显示了截断的边和节点。**'
- en: A.1 Graph fundamentals
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 图的基本概念
- en: Let’s start with some definitions, and then we’ll see how the concepts work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些定义开始，然后我们将看到这些概念是如何工作的。
- en: Key terms
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关键术语
- en: '*Graph*—A data type consisting of nodes and edges.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图*—由节点和边组成的数据类型。'
- en: '*Node*—Also called a *vertex* or *point*, a node is an endpoint in a graph.
    They are connected by edges.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点*—也称为*顶点*或*点*，节点是图中的一个端点。它们通过边连接。'
- en: '*Edge*—Also called a *link* or *relationship*, an edge connects nodes. They
    can be directed or undirected.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*边*—也称为*链接*或*关系*，边连接节点。它们可以是定向的或非定向的。'
- en: '![sidebar figure](../Images/A-unnumb.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![sidebar figure](../Images/A-unnumb.png)'
- en: Loops and three types of edges
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 环和三种类型的边
- en: '*Directed edge*—A directed edge, usually represented by an arrow, denotes a
    one-way relationship or flow from one node to another.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*有向边*—有向边，通常用箭头表示，表示从一个节点到另一个节点的一个方向关系或流动。'
- en: '*Undirected edge*—An undirected edge has no direction. In such an edge, a relationship
    or flow can go in either direction.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*无向边*—无向边没有方向。在这样的边中，关系或流动可以朝两个方向进行。'
- en: '*Adjacent*—The property that two nodes are directly connected via an edge.
    Such nodes are said to be *joined*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*相邻*—两个节点通过边直接连接的性质。这样的节点被称为*连接*。'
- en: '*Self-loop*—An edge that connects a node to itself. Such edges can be directed
    or undirected.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*自环*—连接到节点的边。这样的边可以是定向的或非定向的。'
- en: '*Parallel edges*—Multiple edges that connect the same two nodes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行边*—连接相同两个节点的多条边。'
- en: '*Weights*—One important attribute of an edge is weight, which is a numerical
    value assigned to an edge. Such an attribute can describe the intensity of the
    connection, or some other real-world value, such as length (if a graph modeled
    cities on a road map).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*权重*—边的一个重要属性是权重，它是一个分配给边的数值。这样的属性可以描述连接的强度，或者某些其他现实世界的值，例如长度（如果图是按照道路地图模拟城市）。'
- en: These concepts give us the tools to create the simplest graphs. With a simple
    graph created from these concepts, we could derive network properties explained
    in the following section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念为我们提供了创建最简单图的工具。通过从这些概念创建简单图，我们可以推导出下节中解释的网络属性。
- en: While real-world graphs are complex, simple graphs can often effectively represent
    them for various purposes. For example, though our social graph data contains
    node features (covered in section A.1.2), to create the visualization in figure
    A.1, we only used node and edge information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现实世界的图很复杂，但简单的图往往可以有效地代表它们，用于各种目的。例如，尽管我们的社交图数据包含节点特征（在 A.1.2 节中介绍），但要创建图
    A.1 中的可视化，我们只使用了节点和边的信息。
- en: A.1.1 Graph properties
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1 图属性
- en: In the following subsections, we discuss some of the more important properties
    of graphs. Many of the software programs and databases in the graph ecosystem
    (described in section A.3) should have the capability to compute some or all of
    these properties.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将讨论图的一些更重要的属性。图生态系统中的许多软件程序和数据库（在 A.3 节中描述）应该能够计算这些属性的一些或全部。
- en: Size/order
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大小/阶数
- en: We’re often interested in the overall number of nodes and edges in a graph.
    Formal names for these properties are *size* (the number of edges) and *order*
    (the number of nodes). In our social graph, the number of nodes is 1,933, and
    the number of edges is 12,239.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常对图中节点和边的总数感兴趣。这些属性的正式名称是 *大小*（边的数量）和 *阶数*（节点的数量）。在我们的社交图中，节点的数量是 1,933，边的数量是
    12,239。
- en: Degree distribution
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 度分布
- en: A degree distribution is simply the distribution of the degrees of all the nodes
    in a graph. This can be shown as a histogram, as in figure A.2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 度分布简单来说就是图中所有节点的度的分布。这可以表示为直方图，如图 A.2 所示。
- en: 'The *degree* of a node is the number of adjacent nodes in an undirected graph.
    For directed graphs, there are two types of degrees a node can have: an *in-degree*
    for edges directed to the node and an *out-degree* for edges directed outward
    from the node. Self-loops often are given a count of 2 when calculating degree.
    If edges are given weights, a *weighted degree* can also account for these weights.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的 *度* 是无向图中相邻节点的数量。对于有向图，一个节点可以有三种类型的度：指向该节点的边的 *入度* 和从节点向外延伸的边的 *出度*。在计算度时，自环通常被计为
    2。如果边有权重，则 *加权度* 也可以考虑这些权重。
- en: '![figure](../Images/A-2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-2.png)'
- en: Figure A.2 A histogram showing the degree distribution of our social graph
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.2 展示了我们社交图度分布的直方图
- en: Related to the concept of a degree is that of a node’s neighborhood. For a given
    node, its adjacent nodes are also called its *neighbors*. The set of all its neighbors
    is called its *neighborhood*. The number of vertices in a node’s neighborhood
    is equal to that node’s degree.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与度的概念相关的是节点的邻域。对于给定的节点，其相邻节点也称为其 *邻居*。所有邻居的集合称为其 *邻域*。节点邻域中的顶点数等于该节点的度。
- en: Connectedness
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连通性
- en: A graph is a set of nodes and edges. In general, however, there is no condition
    that says for an undirected graph, every node can be reached by any other node
    within the same network. It can happen that within the same graph, sets of nodes
    are utterly separated from one another; that is, no edge links them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图是由节点和边组成的集合。然而，通常没有条件说明对于无向图，同一网络中的每个节点都可以被任何其他节点到达。可能发生的情况是，在同一图中，节点集完全相互分离；也就是说，没有边将它们连接起来。
- en: An undirected graph where any node can reach any other node is called a *connected
    graph*. It may seem obvious that all graphs must be connected, but this is often
    not the case. Graphs that have discontinuities (where a node or set of nodes are
    unlinked to the rest of the graph) are *disconnected graphs*. Another way to think
    about this is that in a connected graph, there is a path or walk whereby every
    node can reach every other node in the graph. For a disconnected graph, each disconnected
    piece is called a *component*. For a directed graph, where it’s not always possible
    to reach any node from any other node, a *strongly connected graph* is one where
    every node can reach every other node.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 任何节点都可以到达任何其他节点的无向图称为 *连通图*。这似乎很明显，所有图都必须是连通的，但这种情况通常并不成立。具有不连续性（节点或节点集未与其他图的其他部分连接）的图称为
    *不连通图*。另一种思考方式是，在连通图中，存在一条路径或行进方式，使得每个节点都可以到达图中的其他节点。对于不连通图，每个不连通的部分称为 *组件*。对于有向图，如果不可能从任何节点到达任何其他节点，则
    *强连通图* 是每个节点都可以到达其他节点的图。
- en: As an example, the human population can be considered a disconnected social
    graph if we consider every individual human as a node and our communication channels
    as edges. While most of the population can be said to be connected by modern communication
    channels, there are hermits who chose to live off the grid and isolated hunter-gatherer
    tribes that reject contact with the rest of the world. In other use cases, there
    are often discontinuities in the network and its data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们把每一个个体人类视为一个节点，把我们的通信渠道视为边，那么人类人口可以被视为一个断开的社交图。虽然大多数人口可以通过现代通信渠道连接起来，但还有一些隐士选择脱离电网生活，以及拒绝与世界其他地区接触的孤立狩猎采集部落。在其他用例中，网络及其数据通常存在不连续性。
- en: Examining our social graph, we see it’s disconnected with a large component
    that contains most of the nodes. Figures A.3 and A.4 show the entire graph, and
    the large connected component. If we focus on the large connected component, we
    find that the number of nodes is 1,698 and the number of edges is 12,222.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的社交图，我们看到它是断开的，有一个包含大多数节点的大的分量。图A.3和A.4显示了整个图和大的连通分量。如果我们专注于大的连通分量，我们会发现节点数是1,698，边数是12,222。
- en: '![figure](../Images/A-3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-3.png)'
- en: Figure A.3 Our entire social graph, which is disconnected. (`NetworkX` was used
    to generate this figure.) We observe a large connected component at the center,
    surrounded by disconnected nodes and small components consisting of two to three
    nodes.
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.3 我们整个社交图，它是断开的。（本图使用`NetworkX`生成。）我们观察到中心有一个大的连通分量，周围是断开的节点和由两到三个节点组成的小分量。
- en: '![figure](../Images/A-4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-4.png)'
- en: Figure A.4 The connected component of the social graph. (NetworkX was used to
    generate this figure.) Compare this to figure A.1, which is the same graph visualized
    using Graphistry. Differences in the parameters used in the algorithms, as well
    as visual features, account for the distinctiveness of the two figures.
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.4 社交图的连通分量。（本图使用NetworkX生成。）与图A.1进行比较，图A.1是使用Graphistry可视化的相同图。算法中使用的参数以及视觉特征的不同，导致了这两个图的不同之处。
- en: Graph traversals
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图遍历
- en: In a graph, we can imagine traveling from a given node *a* to a second node
    *b*. Such a trip may require passing only one edge or passing several edges and
    nodes. Such a trip is called a *traversal*, or a *walk*, among other names. A
    traversal from one node to another is sometimes called a *hop*. Traversing a series
    of nodes is said to be done in *n* hops. A walk can be *open* or *closed*. Open
    walks have an ending node that is different from the starting node. A closed walk
    starts and ends with the same node.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个图中，我们可以想象从一个给定的节点*a*到第二个节点*b*的旅行。这样的旅行可能只需要通过一条边，或者通过几条边和节点。这样的旅行被称为*遍历*，或者*游走*，还有其他名称。从一个节点到另一个节点的遍历有时被称为*跳跃*。跨越一系列节点被称为*跳数*。一个游走可以是*开放的*或*封闭的*。开放的游走有一个与起始节点不同的结束节点。封闭的游走以相同的节点开始和结束。
- en: A *path* is a walk where no node is encountered more than once. A *cycle* is
    a closed path (with the exception of the starting node, which is also the ending
    node, no node is encountered twice). A *trail* is a walk where no edge is encountered
    more than once, and a *circuit* is a closed trail. Examples of these different
    types of paths are given in figure A.5\. Note how the number of steps (or hops)
    changes between different types of paths.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径*是一种没有节点被多次遇到的游走。*环*是一个封闭的路径（除了起始节点也是结束节点，没有节点被遇到两次）。*迹*是一种没有边被多次遇到的游走，而*回路*是一个封闭的迹。这些不同类型路径的例子在图A.5中给出。注意不同类型的路径之间步数（或跳跃数）的变化。'
- en: Imagine that for a given pair of nodes, we could find walks and paths between
    them. Of the paths we could navigate, there will be the shortest one (or maybe
    more than one path will tie for shortest). The length of this path is called the
    *distance* or *shortest path length*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，对于一对给定的节点，我们可以在它们之间找到游走和路径。在我们能导航的路径中，将会有最短的一条（或者可能有超过一条路径长度相同）。这条路径的长度被称为*距离*或*最短路径长度*。
- en: '![figure](../Images/A-5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-5.png)'
- en: Figure A.5 Five types of paths
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.5 五种类型的路径
- en: If we zoom out and examine the entire graph and its node pairs, we can list
    all the shortest path lengths. One of these distances will be the longest (or
    more than one may tie for longest). The largest distance is the *diameter* of
    the graph. The diameter is often used to characterize and compare graphs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大并检查整个图及其节点对，我们可以列出所有最短路径长度。其中之一将是最长（或者可能多个距离并列最长）。最大的距离是图的*直径*。直径常用于描述和比较图。
- en: If we take our list of distances and average them, we’ll generate the *average
    path length* of the graph. Average path length is another important measure for
    graphs. Both average path length and diameter give an indication of the density
    of the graph. Higher values for these metrics imply more connections, which in
    turn allow a greater variety of paths, both longer and shorter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的距离列表取平均值，我们将生成图的*平均路径长度*。平均路径长度是图的重要度量之一。平均路径长度和直径都给出了图密度的指示。这些度量指标的高值意味着更多的连接，这反过来又允许有更多种类的路径，无论是更长还是更短。
- en: For our social graph, the diameter of our largest component is 10\. The diameter
    is undefined for the entire graph, as it’s unconnected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的社交图，我们最大组件的直径是10。整个图的直径是未定义的，因为它是不连通的。
- en: Subgraphs
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子图
- en: Consider a graph of nodes and edges. A *subgraph* is a subset of these nodes
    and edges. Subgraphs are of importance when these neighborhoods in the graph have
    properties that are distinct from other locations in the graph. Subgraphs occur
    in connected and disconnected graphs. A component of a disconnected graph is a
    subgraph.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由节点和边组成的图。*子图*是这些节点和边的子集。当图中这些邻域具有与其他图中的其他位置不同的属性时，子图就很重要。子图出现在连通图和断开图之中。断开图的组件就是一个子图。
- en: Clustering coefficient
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 聚类系数
- en: A node may have a high degree, but how well connected is its neighborhood? We
    can imagine an apartment building where everyone knows the landlord, but no one
    knows their neighbors (what a sad place!). The landlord would have a clustering
    coefficient of 0\. At the other extreme, we could have an apartment where the
    landlord knows all the tenants, and every tenant knows every other tenant. Then,
    the landlord would have a clustering coefficient of 1 (such a situation, where
    all the nodes in a network are connected to every other node is called a *complete
    graph* or *fully connected graph*). Of course, there will be intermediate cases
    where only some of the tenants know one another, and these situations will have
    coefficients between 0 and 1.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点可能具有高度，但它的邻域连接得有多好呢？我们可以想象一个公寓楼，每个人都知道房东，但没有人知道他们的邻居（多么悲哀的地方啊！）房东的聚类系数将是0。在另一个极端，我们可能有一个公寓，房东知道所有租户，每个租户也知道其他租户。那么，房东的聚类系数将是1（所有网络中的节点都相互连接的情况称为*完全图*或*全连接图*）。当然，也会有中间情况，只有一些租户相互认识，这些情况将具有介于0和1之间的系数。
- en: The dimension of a graph
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图的维度
- en: In machine learning and engineering in general, *dimension* is used in several
    ways. This term can be confusing as a result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习和工程的一般应用中，*维度*被以几种方式使用。这个术语可能会令人困惑。
- en: 'Even within the topic of graphs, the term is used in a few ways in articles
    and academic literature. However, the term is often not explicitly defined or
    clarified. Thus, in the following list, we attempt to deconstruct the meaning
    of this term:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在图的主题内部，这个术语在文章和学术文献中也有几种用法。然而，这个术语通常并没有明确定义或阐明。因此，在以下列表中，我们试图分解这个术语的含义：
- en: '*Size/shape of datasets*—In this case, dimension refers to the number of features
    in a dataset. Low-dimensional datasets are implied to be small enough to visualize
    (i.e., two or three features) or small enough to be computationally viable.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据集的大小/形状*——在这种情况下，维度指的是数据集中特征的数量。低维数据集意味着足够小，可以可视化（即，两个或三个特征）或足够小，可以计算可行。'
- en: '*Mathematical definitions*—In math, the dimension of a graph has more strict
    definitions. In linear algebra, graphs can be represented in vector spaces, and
    the dimension is an attribute of these vector spaces [1].'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数学定义*——在数学中，图的维度有更严格的定义。在线性代数中，图可以在向量空间中表示，维度是这些向量空间的属性[1]。'
- en: '*Geometric definition*—There is also a geometric definition of a graph’s dimension.
    This definition relates a graph’s dimension to the least number of Euclidean dimensions
    that will allow a graph’s edges to be of unit size 1 [1].'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*几何定义*—也存在图的维度的几何定义。这个定义将图的维度与允许图边为单位大小1的最小欧几里得维度相关联[1]。'
- en: A.1.2 Characteristics of nodes and edges
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2 节点和边的特征
- en: 'In the most basic type of graph, we have a collection of nodes and edges, without
    parallel edges or self-loops. For this basic graph, we have a geometric structure
    only. While even this basic graph structure is useful, often more complexity is
    desired to properly model a situation for real-world problems and use cases. For
    example, we can do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的图类型中，我们有一组节点和边，没有并行边或自环。对于这个基本图，我们只有一个几何结构。虽然即使这个基本的图结构也是有用的，但通常还需要更多的复杂性来正确地模拟现实世界问题和用例。例如，我们可以做以下事情：
- en: 'Reduce the geometric restrictions discussed earlier. Explicitly, these restrictions
    are as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少前面讨论的几何限制。具体来说，这些限制如下：
- en: Each edge is incident to two nodes, one on each end of the edge.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条边都与两个节点相关联，一个在边的每一端。
- en: Between two nodes, only one edge can exist.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个节点之间，只能存在一条边。
- en: No self-loops are used.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用自环。
- en: With these restrictions relaxed, we’re able to model more situations at the
    cost of more complex graphs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在放宽这些限制后，我们能够以更复杂的图代价来模拟更多的情况。
- en: 2\. Add *properties* to our graph elements (nodes, edges, the graph itself).
    A property or feature is data tied to a specific element. Depending on the context,
    terms such as *labels*, *attributes*, and *decorators* are used in place of *properties*.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 向我们的图元素（节点、边、图本身）添加*属性*。属性或特征是与特定元素相关的数据。根据上下文，可以使用*标签*、*属性*和*装饰器*等术语来代替*属性*。
- en: In this section and the next, we’ll discuss the characteristics and variants
    of nodes, edges, and entire graphs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和下一节中，我们将讨论节点、边以及整个图的特征和变体。
- en: Node properties
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 节点属性
- en: 'In the following list, we outline some of the different properties that nodes
    might contain. These become features in many data science or GNN tasks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们概述了节点可能包含的一些不同属性。这些属性在许多数据科学或GNN任务中成为特征：
- en: '*Names, IDs, and unique identifiers*—A name or an ID is a unique identifier.
    Many graph systems will either assign an identifier such as an index to a node,
    or allow the user to specify an ID. In our social graph, each node has a unique
    alphanumeric ID.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*名称、ID和唯一标识符*—名称或ID是一个唯一标识符。许多图系统要么将索引等标识符分配给节点，要么允许用户指定ID。在我们的社交图中，每个节点都有一个唯一的字母数字ID。'
- en: '*Labels*—Within a graph, nodes may fall within certain classes or groups. For
    example, a graph modeling a social network may group people by their country of
    residence (USA, PRC, Nigeria) or their level of activity within the network (frequent
    user, occasional user). In this way, in contrast to the unique identifiers explained
    earlier, we’d expect several nodes to share the same label.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标签*—在图中，节点可能属于某些类别或组。例如，模拟社交网络的图可能根据居住国（美国、中国、尼日利亚）或网络内的活动水平（频繁用户、偶尔用户）对人们进行分组。这样，与前面解释的唯一标识符不同，我们预计几个节点将共享相同的标签。'
- en: '*Properties/attributes/features*—Properties that aren’t IDs or labels are usually
    called attributes or features. While such properties don’t have to be unique to
    a node, they don’t describe a node class either. Properties can be based on structural
    or nonstructural qualities.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性/属性/特征*—不是ID或标签的属性通常被称为属性或特征。虽然这样的属性不必对节点是唯一的，但它们也不描述节点类。属性可以基于结构或非结构特性。'
- en: '*Structural/topological properties*—Intrinsic characteristics of a node are
    related to the node’s topological properties and the geometrical structure of
    the graph in proximity to the node. Two examples are listed here:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构/拓扑属性*—节点的内在特性与节点的拓扑属性以及节点附近的图几何结构相关。以下列出了两个例子：'
- en: A node’s degree, which, as we learned, is the number of incident edges it has.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的度，正如我们所学的，是它拥有的入边数量。
- en: A node’s centrality, which is a measure of how important a node is relative
    to the nodes in its neighborhood.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的中心性，这是一个衡量节点相对于其邻域中节点重要性的度量。
- en: By employing graph analytical methods (described in section A.4) characteristics
    of nodes, relative to their local environment, can be identified. These can be
    incorporated into certain GNN problems as features. Node embeddings such as those
    generated by transductive methods (chapter 2) are another example of a property
    based on the graph’s local structure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用图分析方法（在第 A.4 节中描述）可以识别节点相对于其局部环境的特征。这些特征可以作为某些 GNN 问题中的特征。例如，由归纳方法（第 2 章）生成的节点嵌入是基于图局部结构的另一个属性示例。
- en: '*Nonstructural properties*—These are often based on real-world attributes.
    Taking the example of our social graph, we have two categorical properties: a
    person’s job category (e.g., scientist, marketer, administrator) and the type
    of company they work for (e.g., medical, transportation, consulting). These examples
    are categorical attributes. It’s possible to have numerical attributes, such as
    *years of experience* or *average number of direct reports* in all current and
    past roles.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非结构属性*—这些通常基于现实世界的属性。以我们的社交图为例，我们有两个分类属性：一个人的职业类别（例如，科学家、营销人员、管理员）以及他们工作的公司类型（例如，医疗、交通、咨询）。这些示例是分类属性。还可能有数值属性，例如
    *工作经验年数* 或 *平均直接下属人数* 在所有当前和过去的角色中。'
- en: '*Edge properties —*Properties for edges mirror those for nodes. The most often
    used and important edge property is that of the edge weight, described earlier.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边属性*—边的属性与节点的属性相似。最常用且重要的边属性是边权重，这在前面已经描述过。'
- en: Edge variations
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边的变化
- en: Unlike nodes, there are a few geometric variants of edges that can be used to
    make a graph model more descriptive.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与节点不同，边有一些几何变体可以用来使图模型更具描述性。
- en: '*Parallel edges*—Meaning more than one edge between two nodes *u* and *v*.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平行边*—指两个节点 *u* 和 *v* 之间有多于一条边。'
- en: '*Directionality*—Edges can have no direction or one direction. Because nodes
    *u* and *v* can have parallel edges connecting them, it’s possible to have two
    edges with opposite directionality or multiple edges with some combination of
    directions or undirectionality.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方向性*—边可以没有方向或一个方向。因为节点 *u* 和 *v* 可以通过平行边连接，所以可能有两个方向相反的边或多个具有某些方向组合或无方向的边。'
- en: '*Bidirectionality*—The case where between two nodes, both directions are represented
    in the respective edges. In practice, this term is used in a few ways:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双向性*—在两个节点之间，两个方向都在各自的边中表示出来。在实践中，这个术语有几种用法：'
- en: To describe nondirected edges, or simple edges.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要描述非定向边，或简单边。
- en: To describe two edges that have opposite directions (shown in figure A.6).
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要描述两个方向相反的边（如图 A.6 所示）。
- en: '![figure](../Images/A-6.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-6.png)'
- en: Figure A.6 From top to bottom, between two nodes, an example of an undirected
    edge, a directed edge from left to right, a directed edge from right to left,
    and two directed edges traversing both directions (bidirectionality)
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.6 从上到下，两个节点之间，一个无向边、一个从左到右的有向边、一个从右到左的有向边，以及两个双向的有向边（双向性）
- en: To describe an edge that has a direction at each end. This usage, while popular
    in the literature, is fairly rare in practical systems at the time of writing.
  id: totrans-88
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要描述每个端点都有方向的边。这种用法在文献中很流行，但在写作时，在实际系统中相当罕见。
- en: '*Self-loops*—Discussed previously, a self-loop, or loop, is the case where
    both ends of an edge connect to the same node. Where would one encounter a self-loop
    in the real world? For our social graph, let’s keep all the nodes, and consider
    a case where an edge would be an email sent from one professional to another.
    Sometimes, people send emails to themselves (for reminders). For such a scenario,
    an email to oneself could be modeled as a self-loop.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自环*—之前已讨论，自环或环是指边的两端都连接到同一个节点。在现实世界中，在哪里会遇到自环？对于我们的社交图，让我们保留所有节点，并考虑一个边将是一个从一位专业人士发送给另一位专业人士的电子邮件的情况。有时，人们会给自己发送电子邮件（作为提醒）。在这种情况下，给自己发送的电子邮件可以建模为自环。'
- en: A.1.3 Categories of graphs
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3 图的类别
- en: 'Different categories of graphs depend on the node and edge characteristics
    we’ve just described. Following are the graph categories:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类别的图取决于我们刚刚描述的节点和边特征。以下是一些图类别：
- en: '*Simple graph*—A graph whose edges can’t be parallel edges or self-loops. Simple
    graphs can be connected or disconnected, as well as directed.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单图*—边的边不能是平行边或自环的图。简单图可以是连通的或断开的，也可以是有向的。'
- en: '*Weighted graph*—A graph that uses weights. Our social graph has no weights;
    another way to express having no weights is to set all weights to 1 or 0\.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加权图*—使用权重的图。我们的社交图没有权重；另一种表达没有权重的说法是将所有权重设置为1或0。'
- en: '*Multigraphs —*A graph that is permitted to have multiple edges between any
    two nodes and multiple self-loops for any one node. A simple graph could be a
    special case of a multigraph if we’re working within a problem where we could
    add more edges and self-loops to it.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多重图*—允许任何两个节点之间有多个边和任何单个节点有多个自环的图。如果我们在一个可以添加更多边和自环的问题中工作，一个简单图可以是多重图的一个特例。'
- en: '*Di-graphs*—Another term for a directed graph.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有向图*—有向图的另一种说法。'
- en: '*K-partite graphs*—In many graphs, we may have a situation where we have two
    or more groups of nodes, where edges are only allowed between groups and not between
    nodes of the same group. “Partite” refers to the partitions of node groups, and
    “k” refers to the number of those partitions.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*K部图*—在许多图中，我们可能有两个或更多节点组的情况，其中边只允许在组之间，而不是在同一组内的节点之间。 “Partite”指的是节点组的分区，“k”指的是这些分区的数量。'
- en: '*Monopartite graph*—A graph in which there is only one group of nodes and one
    group of edges. A monopartite social graph could consist of only “Texan” nodes
    connected with “work colleague” edges. For example, in a social graph, nodes can
    belong to “New Yorkers” or “Texans” groups, and relationships can belong to “friend”
    or “work colleague” groups.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单部图*—只有一个节点组和一条边组的图。一个单部社交图可能只包含“德克萨斯人”节点和“工作同事”边。例如，在社交图中，节点可以属于“纽约人”或“德克萨斯人”组，关系可以属于“朋友”或“工作同事”组。'
- en: '*Bipartite (or bi-graph) graph*—A graph that has two node partitions within
    a graph. Nodes of one group can only connect to nodes of a second type and not
    to nodes within their own group. In our social graph example, nodes can belong
    to “New Yorkers” or “Texans” groups, and relationships can belong to “friend”
    or “work colleague” groups. In this graph, no New Yorkers would be adjacent to
    other New Yorkers, and the same for Texans. This is shown in figure A.7\.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双部图（或双图）*—在图中有两个节点分区的图。一个组的节点只能连接到第二类型的节点，而不能连接到它们自己的组内的节点。在我们的社交图示例中，节点可以属于“纽约人”或“德克萨斯人”组，关系可以属于“朋友”或“工作同事”组。在这个图中，没有纽约人会与另一个纽约人相邻，德克萨斯人也是如此。这如图A.7所示。'
- en: '![figure](../Images/A-7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-7.png)'
- en: Figure A.7 A bipartite graph. There are two types of nodes (upper and lower
    row of circles). In a bipartite graph, nodes can’t be connected to nodes of the
    same type (those in the same row). This is also an example of a heterogeneous
    graph.
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.7 双部图。有两种类型的节点（圆圈的上下行）。在双部图中，节点不能连接到同一类型的节点（同一行的节点）。这也是一个异构图的例子。
- en: For more than three partitions, the requirement that adjacent nodes can’t be
    the same type still holds. In practice, *k* can be a large number.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于超过三个分区，相邻节点不能是同一类型的要求仍然成立。在实践中，*k* 可以是一个很大的数。
- en: '*Trees*—A tree is a well-studied data structure in machine learning and is
    a special case of a graph. It’s a connected graph without cycles. Another way
    to describe a graph without cycles is *acyclic*. In the data science and deep
    learning worlds, a well-known example is the directed acyclic graph (DAG), used
    in designing and governing data workflows.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*树*—树是机器学习中研究得很好的数据结构，是图的一个特例。它是一个无环的连通图。另一种描述无环图的方式是*无环的*。在数据科学和深度学习领域，一个著名的例子是用于设计和治理数据工作流的定向无环图（DAG）。'
- en: '*Hypergraphs*—Up to now, our graphs have consisted of edges that connect to
    two nodes or one node (a self-loop). For a hypergraph, an edge can be incident
    to more than two nodes. These data structures have a range of applications, including
    ones that involve the use of GNNs. This is shown in figure A.8\.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*超图*—到目前为止，我们的图由连接两个节点或一个节点（自环）的边组成。对于超图，一条边可以与超过两个节点相关。这些数据结构有各种应用，包括涉及使用GNNs的应用。这如图A.8所示。'
- en: '*Heterogeneous graphs*—A heterogeneous graph has multiple node and edge types,
    while a multirelational graph has multiple edge types.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异构图*—异构图有多个节点和边类型，而多关系图有多个边类型。'
- en: '![figure](../Images/A-8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-8.png)'
- en: Figure A.8 One undirected hypergraph, illustrated in two ways. On the left,
    we have a graph whose edges are represented by shaded areas and marked by letters,
    and whose vertices are dots, marked by numbers. On the right, we have a graph
    whose edge lines (marked by letters) connect up to three nodes (circles marked
    by numbers). Node 8 has no edge. Node 7 has a self-loop.
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.8 两种方式展示的一个无向超图。在左边，我们有一个图，其边由阴影区域表示，并用字母标记，其顶点由点表示，并用数字标记。在右边，我们有一个图，其边线（用字母标记）连接最多三个节点（用数字标记的圆圈）。节点8没有边。节点7有一个自环。
- en: A.2 Graph representations
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 图表示
- en: Now that we have a conceptual idea of what graphs are, we move on to how to
    work with them. First, we focus on data structures most relevant to building graph
    algorithms and storing graph data. We’ll see that some of these structures, particularly
    the adjacency matrix, play a prominent role in the GNN algorithms we study in
    the bulk of this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对图的概念有了基本的了解，我们将继续探讨如何与它们一起工作。首先，我们关注与构建图算法和存储图数据最相关的数据结构。我们将看到，其中一些结构，尤其是邻接矩阵，在我们这本书的大部分内容中研究的GNN算法中起着突出的作用。
- en: Next, we’ll examine a few graph data models. These are important in designing
    and managing how databases and other data systems deal with network data. Lastly,
    we’ll briefly take a look at how graph data is exposed to analysts and engineers
    via APIs and query languages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考察几种图数据模型。这些在设计和管理数据库以及其他数据系统如何处理网络数据方面非常重要。最后，我们将简要地看看图数据是如何通过API和查询语言暴露给分析师和工程师的。
- en: A.2.1 Basic graph data structures
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 基本图数据结构
- en: 'There are a few important ways to represent graphs that can be ported to a
    computational environment:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种重要的图表示方法可以移植到计算环境中：
- en: '*Adjacency matrix*—A node-to-node matrix.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*邻接矩阵*—节点到节点的矩阵。'
- en: '*Incidence matrix*—An edge-to-node matrix.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关联矩阵*—边到节点的矩阵。'
- en: '*Edge lists*—A list of edges by their nodes.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边列表*—按节点列出的边列表。'
- en: '*Adjacency lists*—Lists of each node’s adjacent nodes.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*邻接表*—每个节点的相邻节点列表。'
- en: '*Degree matrix*—Node-to-node matrix of degree values.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*度矩阵*—节点到节点的度值矩阵。'
- en: '*Laplacian matrix*—The degree matrix minus the adjacency matrix (**D**-**A**).
    This is useful in spectral theory.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拉普拉斯矩阵*—度矩阵减去邻接矩阵（**D**-**A**）。这在谱理论中很有用。'
- en: These are by no means the only ways to represent a graph, but from a survey
    of the literature, software, storage formats, and libraries, these are the most
    prevalent. In practice, a graph may not be permanently stored as one of these
    structures, but to execute a needed operation, a graph or subgraph may be transformed
    from one representation to another.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝不是表示图的唯一方式，但从文献、软件、存储格式和库的调查来看，这些是最普遍的。在实践中，图可能不会永久存储为这些结构之一，但为了执行所需的操作，图或子图可能需要从一种表示转换为另一种表示。
- en: 'What representations are used depends on many factors that should be weighed
    in planning. These factors include the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的表示取决于许多应该被考虑在计划中的因素。以下是一些因素：
- en: '*Size of graph*—How many vertices and edges does the graph contain, and how
    much are these expected to scale?'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图的规模*—图包含多少个顶点和边，以及这些预计会扩展到多大？'
- en: '*Density of graph*—Is the graph sparse or dense? We’ll touch on these terms
    in the next subsection.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图的密度*—图是稀疏的还是密集的？我们将在下一小节中涉及这些术语。'
- en: '*Complexity of the graph’s structure*—Is the graph closer to a simple graph,
    or one that uses one or more of the variations discussed previously?'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图结构的复杂性*—图更接近于简单图，还是使用之前讨论的变体之一？'
- en: '*Algorithms to be used*—For a given algorithm, a given data structure may perform
    relatively weakly or strongly compared to others. In the following subsections,
    for each structure, we’ll touch on two simple algorithms to compare.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*要使用的算法*—对于给定的算法，与其它数据结构相比，一个给定的数据结构可能表现相对较弱或较强。在以下小节中，对于每个结构，我们将简要介绍两个简单的算法进行比较。'
- en: '*Costs to do CRUD (create, read, updated, delete) operations*—How will you
    modify your graph (including creating, reading, updating, or deleting nodes, edges,
    and their attributes) over the course of your operations and how frequently will
    you do so?'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行 CRUD（创建、读取、更新、删除）操作的成本*—在你的操作过程中，你将如何修改你的图（包括创建、读取、更新或删除节点、边及其属性），以及你将多久进行一次这样的操作？'
- en: In many data projects, transformation from one data structure to another is
    common to accommodate particular operations. So, it’s normal to employ two or
    more of the previously mentioned data structures in a project. In this case, understanding
    the compute effort to execute the transformation is key. For the most popular
    structures, graph libraries allow methods that allow seamless transformations,
    but given the considerations listed previously, executing these transformations
    could take unexpected time or cost.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: For the following discussion, we’ll talk about how these data structures are
    used to store topological information about graphs. The only attributes we’ll
    consider are node IDs and edge weights. To illustrate these concepts, let’s use
    the weighted graph, consisting of five nodes, as shown in figure A.9\. Circles
    indicate nodes with their IDs; rectangles are the edge weights.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-9.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Figure A.9 An example graph with different weighted edges and labeled nodes
    from 0 to 4
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now dive into those six popular ways of representing graphs so they can
    be used computationally.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a graph with *n* nodes, an *adjacency matrix* represents the graph as an
    *N* × *N* matrix format, where each row or column describes the edge between two
    nodes. For our example graph, shown previously in figure A.9, we have five columns
    and five rows. These rows and columns are labeled for each node. Cells of the
    matrix denote adjacency.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrices can be used for simple directed and undirected graphs. They
    can also be used for graphs with self-loops. In an unweighted graph, each cell
    is either 0 (no adjacency) or 1 (adjacency). For a weighted graph, the values
    in the cells are the edge weights. For unweighted parallel edges, the values of
    the cells are the number of edges.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: For our example, a weighted, undirected graph, the corresponding adjacency matrix
    is shown in table A.1\. Because our graph is undirected, the adjacency matrix
    is symmetric. For directed graphs, symmetry is possible but not guaranteed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Table A.1 An adjacency matrix for the graph in figure A.9
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| **0**  | 0  | 0  | 0  | 3  | 5  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| **1**  | 0  | 0  | 0  | 1  | 1  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| **2**  | 0  | 0  | 0  | 3  | 0  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| **3**  | 3  | 1  | 3  | 0  | 0  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| **4**  | 5  | 1  | 0  | 0  | 0  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: By inspecting this matrix, we can get a quick visual understanding of the characteristics
    of the matrix. We can see, for example, how many degrees node 1 has and get a
    general idea of the distribution of the degrees. We also see that there are more
    empty spaces (cells with a 0 value) than edges. This ease of using the matrix
    to draw quick insights for small graphs is one advantage of adjacency matrices.
    Even for large graphs, plotting the adjacency matrix can indicate certain subgraph
    structures.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrices, and matrix representations in general, allow you to analyze
    graphs by using linear algebra. One relevant example is spectral graph theory
    (which underlies a few GNN algorithms).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Adjacency matrices are straightforward to implement in Python. The matrix in
    our example can be created using a list of lists, or a NumPy array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With our adjacency matrix as a NumPy array, let’s explore another property
    of our graph. From our visual inspection of our matrix, we noticed many more zero
    values than nonzero values. This makes it a sparse matrix. *Sparse matrices*,
    that is, matrices with a large proportion of zero values, can take up unnecessary
    storage or memory space and increase calculation times. *Dense matrices*, contrarily,
    contain a large proportion of nonzero matrices. The following determines the sparsity
    of our matrix:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, our matrix has a sparsity of 0.6, meaning 60% of the values in this matrix
    are zeros.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Sparsity using node degree
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to think about sparsity is in terms of node degree. Let’s derive
    the sparsity value just shown from the perspective of the node degree.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple, undirected graph of *n* nodes, each node can make at most *n-1*
    connections, and thus have a maximum degree of *n-1*. The maximum number of edges
    can be calculated using combinatorics: because each edge represents a pair of
    nodes, for a set of *n* nodes, the maximum number of edges is “*n* choose 2”,
    that is, *(n C 2)* or *n*(*n* – 1)/2\. However, for our small matrix, we have
    a directed graph, which is clear because the adjacency matrix isn’t symmetric.
    This means that both directions count separately and need to times by 2\. Hence,
    for our small matrix, the maximum number of possible edges is 5(5 – 1) = 20\.
    The density of a graph is defined as the actual number of edges, *e*,over all
    possible edges, and sparsity can then be defined as 1 – density. In our example,
    this leads to a quantity that disagrees with what was calculated using the matrix
    alone, namely (1 – 10/20) = 0.5, which is not equal to 0.6 in the preceding code
    snippet. This is because we haven’t considered self-loops, which is standard practice
    for graph theory. If we included self-loops, we would have five additional possible
    edges (or 5^2), resulting in (1 – 10/25), or 0.6, matching the value in the earlier
    code. This highlights that care needs to be taken when reporting on the sparsity
    of a graph.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Now, think of a graph that has not five, but millions or billions of nodes.
    Such graphs exist in the real world, and quite often the sparsity can be orders
    of magnitudes less than 0.6\. For undirected simple graphs, the adjacency matrix
    is symmetric, so only half the storage is needed. Most of the memory or storage
    containing the adjacency matrix would be devoted to zero values. Thus, the high
    sparsity of this data structure leads to memory inefficiencies.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In terms of complexity, for a simple graph, the space complexity would be **O**(*n*²),
    for undirected simple graphs. For an undirected graph, due to the symmetry, the
    space complexity would be **O**(*n*(*n*–1)/2).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'For time complexity, this of course depends on the task or the algorithm. Let’s
    look at two rudimentary tasks that we’ll also address for adjacency list and edge
    lists:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Checking the existence of an edge between a particular pair of nodes
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the neighbors of a node
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first task, we simply check the row and column corresponding to those
    nodes. This would take **O**(1) time. For the second, we need to check every item
    in that node’s row; this would take **O**(deg(*n*)) time, where deg(*n*) is the
    degree of the node.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the advantages of adjacency matrices are that they can quickly
    check connections between nodes and are easy to visually interpret. The downsides
    are that they are less space-efficient for sparse matrices. The computational
    tradeoffs depend on your algorithm. They shine in cases where we have small and
    dense graphs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Incidence matrix
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the adjacency matrix has a row and column for every node, an *incidence
    matrix* represents every edge as a column and every node as a row. Using the same
    graph shown earlier in figure A.9, we can construct an incidence matrix, which
    we show in table A.2.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Table A.2 Incidence matrix for the example graph in figure A.9
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| **0**  | 0  | 3  | 5  | 0  | 0  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| **1**  | 0  | 0  | 0  | 1  | 1  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| **2**  | 3  | 0  | 0  | 0  | 0  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| **3**  | 3  | 3  | 0  | 1  | 0  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| **4**  | 0  | 0  | 5  | 0  | 1  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: An incidence matrix can represent wider variations of graph types than an adjacency
    matrix. Multigraphs and hypergraphs are straightforward to express with this data
    structure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: How does the incidence matrix perform with respect to space and time? To store
    the data of a simple graph, the incidence matrix has a space complexity of **O**(*|E|*
    * *|V|*), where *|V|* is the number of nodes (*V* for vertices), and *|E|* is
    the number of edges. Thus, it’s superior to the adjacency matrix for graphs with
    fewer edges than nodes, including sparse matrices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea of time complexity, we turn to our two simple tasks: checking
    for an edge, and finding a node’s neighbors. To check the existence of an edge,
    an incidence matrix has a time complexity of O(*|E|* * *|V|*), far slower than
    the adjacency matrix, which does this in constant time. To find the neighbors
    of a node, an incidence matrix also takes O(*|E|* * *|V|*).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Overall, incidence matrices have space advantages when used with sparse matrices.
    For time performance, they have slow performance on the simple tasks we covered.
    The overall advantage of using incidence matrices is for unambiguously representing
    complex graphs, such as multigraphs and hypergraphs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency lists
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In an *adjacency list*, the aim is to show which vertices each node is adjacent
    to. So, for *n* nodes, we have *n* lists of neighbors corresponding to each node.
    Depending on what data structures are used for the lists, properties may also
    be included in the summary. For our example, a simple adjacency list is shown
    in figure A.10.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-10.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure A.10 Our example graph and its adjacency list
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Such an adjacency list can be accomplished in python using a dictionary with
    each node as the keys, and lists of the adjacent nodes as values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can improve on the dictionary values to allow for the inclusion of the weights
    of the neighbors:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For undirected graphs, the set of nodes doesn’t have to be ordered. Because
    the adjacency list doesn’t devote space to node pairs that aren’t neighbors, we
    see that adjacency lists lack the sparsity problems of adjacency matrices. So,
    to store this data structure, we have a space complexity of **O**(n + v), where
    *n* is the number of nodes, and *v* is the number of edges.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the two computational tasks, checking the existence of an edge
    (task 1) would take **O**(deg(node)) time, where deg(node) is the degree of either
    node. For this, we simply check every item in that node’s list, where for the
    worst case, we’d have to check them all. For task 2, finding a node’s neighbors
    would also take **O**(deg(node)) time, because we have to inspect every item in
    that node’s list whose length is the node’s degree.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize the tradeoffs of an adjacency list. The advantages are that
    they are relatively efficient in terms of storage because only edge relationships
    are stored. This means a sparse matrix would take up less space stored as an adjacency
    list than as an adjacency matrix. Computationally, the tradeoffs depend on the
    algorithm you’re running and the type of graph you’re using as input data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Edge lists
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compared to the preceding two representations, *edge lists* are relatively
    simple. They consist of a set of doubles (two nodes) or triples (two nodes and
    an edge weight). These identify a unique edge thusly:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Node, node (edge weight), for an undirected graph
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source node, destination node (edge weight), for a directed graph
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edge lists can represent single, unconnected nodes. For our example graph,
    the edge list would be the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Python, we can create this as a set of tuples:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On performance, for storage, the space complexity of an edge list is O(*e*),
    where *e* is the number of edges. Regarding our two tasks shown previously, to
    establish the existence of a particular edge will have a time complexity of **O**(*e*),
    assuming an unordered edge list. To discover all the neighbors of a node, **O**(*e*)
    is the space complexity. In each case, we have to go through the edges in the
    list one by one to check for the edge or the node’s neighbor. So, from a compute
    performance point of view, edge lists have a disadvantage compared to the other
    two data structures, especially for executing more complex algorithms.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: However, another advantage of edge lists is that they are more compact than
    adjacency lists or adjacency matrices. Additionally, they are simple to both create
    and interpret. For example, we could store an edge list as a text file where each
    line only consists of two identifiers separated by a space. For many systems and
    databases, edge lists in CSV or text files are the default option to serialize
    data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The Laplacian matrix
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One data representation of a graph that is highly valuable in analyzing graphs
    is the Laplacian matrix, as mentioned earlier. This matrix is key to the development
    of graph spectral theory, which is in turn critical to the development of spectral-based
    GNN methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: To produce the Laplacian matrix, we subtract the adjacency matrix from the degree
    matrix (D – A). The degree matrix is a node-to-node matrix whose values are the
    degree of a particular node. The degree matrix for our example graph is given
    in the first table and the Laplacian matrix follows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![sidebar figure](../Images/table_A-1.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Degree matrix for our example graph
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![sidebar figure](../Images/table_A-2.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Laplacian matrix for our example graph
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In practice, Laplacian matrices aren’t used for storage or as a basis for graph
    operations like the other data structures covered in this section. Their advantages
    lie in spectral analysis. We discuss spectral graph analysis in chapter 3.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: A.2.2 Relational databases
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re steadily marching from theory to implementation. In the previous section,
    we reviewed common data structures used to represent graphs and their tradeoffs.
    Graphs can be implemented in these structures from scratch in your preferred programming
    language and are also implemented in popular graph processing libraries.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: With the listed data structures, we have a variety of ways to implement the
    structural information in graphs. But graphs and their elements often come with
    useful attributes and metadata.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: A *relational database* is an organized way to represent the structural information,
    attributes, and metadata of a graph. Very much related to this is the notion of
    a *schema*, which is a framework that explicitly defines the elements that make
    up a graph (i.e., varieties of nodes and edges, attributes, etc.), and explicitly
    defines how these elements work together.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Data models and schemas are critical parts of the scaffolding used to design
    graph systems such as graph databases and graph processing systems, and they often
    build on the data structures reviewed in the previous section. We’ll review three
    such models and provide examples of real systems where they are used.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Minimalist graph data model
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest relational database uses only nodes, edges, and weights. It can
    be used on directed or undirected graphs. If weights are used, they can be retrieved
    using a lookup table.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Pregel, Google’s graph processing framework, which other popular frameworks
    are based on (including Apache Giraph used by Facebook, and Apache Spark GraphX),
    relies on such a directed graph. There, both edges and nodes have an identifier
    and a single numerical value, which can be interpreted as a weight or attribute.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: RDF graph data model
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Resource Description Framework (RDF; aka Triple Stores) models follow a subject-predicate-object
    pattern, where nodes are subjects and objects, and edges are predicates. Nodes
    and edges have one main attribute, which can be a unique resource identifier (URI)
    or a literal. URIs, in essence, identify the type of node or edge being described.
    Examples of literals can be specific timestamps or dates. Predicates represent
    relationships. Such triples (subject-predicate-object) represent what are called
    *facts* in this context. Usually, facts are directed and flow in the direction
    from subject to object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Popular graph databases that use the RDF model include Amazon’s Neptune (Neptune
    also allows the use of labeled property graphs [LPGs]), Virtuoso, and Stardog.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Property graph data model
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In property graphs (aka LPGs), allowances are made to confer various metadata
    to nodes and edges. Such metadata include the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*Identifiers* —Distinguish individual nodes and edges.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Labels* —Describe classes (or subsets) of nodes or edges.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attributes or properties* —Describe individual nodes or edges.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes have an ID and a set of key/value pairs that can be used to supply additional
    attributes (also called properties). Similarly, edges have an ID and a set of
    key/value pairs for attributes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the property graph as the minimalist graph extended by adding
    labels and removing the restrictions on the types and number of attributes. Figure
    A.11 provides a look at a property graph and its equivalent RDF graph. Popular
    graph databases that use models based on the property graph include Neo4j, Azure
    Cosmos, and TigerGraph.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-11.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: Figure A.11 Example of a property graph and its equivalent RDF graph
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Nongraph data model
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a variety of databases and systems that use neither RDF nor LPG. These
    databases and systems store or express nodes, edges, and attributes within other
    storage frameworks, such as document stores, key value stores, and even within
    a relational database framework.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge graphs
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although the term is used widely in academic, commercial, and practitioner circles,
    there is no unifying definition of a knowledge graph. Most relevant to GNNs, we
    define a *knowledge graph* as a representation of knowledge discretized into facts,
    as defined earlier. In other words, a knowledge graph is a multigraph set onto
    a specific *subject-relationship-object* schema.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge graphs may be represented with RDF schemas, but there are other data
    models and graph models that can accommodate knowledge graphs. GNN methods are
    used to embed the data in the nodes and edges, establish the quality of facts,
    and discover new entities and relations. An example of a knowledge graph is shown
    in figure A.12\.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/A-12.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Figure A.12 An example of a knowledge graph representing an academic research
    network within a university’s physics department. The graph illustrates both hierarchical
    relationships, such as professors and students being members of the department,
    and behavioral relationships, such as professors supervising students and authoring
    papers. Entities such as Prof, Student, Paper, and Topic are connected through
    semantically meaningful relationships (e.g., Supervises, Wrote, and Inspires).
    Entities also have detailed features (e.g., Name, Department, and Type) to provide
    further context. The semantic connections and features enable advanced querying
    and analysis of complex academic interactions.
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Node and edge types
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In graphs that have a schema, including knowledge graphs, the edges and nodes
    can be assigned a *type*. *Types* are part of a defined schema, and as such, govern
    how data elements interact with each other. They also often have a descriptive
    aspect. To distinguish *types* from *properties*, consider that while types help
    define the rules of how data elements work together and how they are interpreted
    by the data system, properties are descriptive only.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate types, we can use a road map analogy, where towns are nodes,
    and passages between them are edges. Our edges may include highways, footpaths,
    canals, or bike paths. Each one is a type. Due to geography, towns can be surrounded
    by swamps, sit atop mountain peaks, or have other obstacles and impediments to
    one versus another passage. For towns separated by a desert, passage is only possible
    by a highway. For other towns, passages can be by multiple passage types. In building
    this analogy, we see that our town nodes also have types defined by their proximate
    geography: swamp town, desert town, island town, valley town.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: A.2.3 How graphs are exposed
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve talked about relational data structures and relational databases to understand
    how graphs are constructed and stored. In real life, however, most of us won’t
    build graphs from scratch or from the bottom up. When constructing and analyzing
    graphs, there will be a layer of abstraction between us and the primitive data.
    In what ways, then, is a graph exposed to the data scientist or engineer? Next,
    we’ll briefly explain the following two ways and then discuss the graph ecosystem:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '*APIs* —Using graph libraries or data processing systems'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Query languages* —Querying graph databases via specialized query languages'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'APIs: Graph objects in graph systems'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using a graph library or processing software, usually we want the graph
    we work with to have certain properties and to be able to execute operations on
    the graph. From this lens, it’s helpful to think of graphs as software objects
    that can be operated on by software functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In Python, an effective way to implement these is to have a graph class, with
    some operations implemented as methods of the graph class or as standalone functions.
    Nodes and edges can be attributes of the graph class, or they can have their own
    node and edge classes. Properties of graphs implemented in this way can be attributes
    of the respective classes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is `NetworkX`, a Python-based graph processing library. `NetworkX`
    implements a graph class. Nodes can be any hashable object; examples of node objects
    are integers, strings, files, and even functions. Edges are tuple objects of their
    respective nodes. Both nodes and edges can have properties implemented as Python
    dictionaries. Following are two short lists of typical methods and attributes
    of graph classes found in libraries and processing systems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Basic methods of graph objects
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following list, we outline some of the methods that can be applied to
    graph objects:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`Graph_Creation`—A constructor that creates a new graph object'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add_Node`, `Add_Edge`—Adds nodes or edges, and their attributes and labels,
    if any'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get_Node`, `Get_Edge`—Retrieves stored nodes or edges, with specified attributes
    and labels'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update_Node`, `Updage_Edge`, `Update_Graph`—Updates properties and attributes
    of nodes, edges, and graph objects'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delete_Node`, `Delete_Edge`—Deletes a specified node or edge'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic attributes of graph objects
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following list, we outline some of the attributes for graph objects:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`Number_of_Nodes`, `Number_of_Edges`—A constructor that creates a new graph
    object'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node_Neighbors`—Retrieves the adjacent nodes or incident edges of a node'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node_List`, `Edge_List`—Adds nodes or edges and their attributes and labels,
    if any'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Connected_Graph`—Retrieves stored nodes or edges, with specified attributes
    and labels'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Graph_State`—Retrieves global attributes, labels, and properties of the graph'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Directed_Graph`—Deletes a specified node or edge'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph query languages
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When working with a graph in a graph database, a query language is used. For
    most relational databases, some variant of SQL is used as the standard language.
    In the graph database space, there is no standard query language. Following are
    the languages that currently stand out:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '*Gremlin*—A language that can be written declaratively or imperatively, which
    is designed for database or processing system queries. Developed by the Apache
    TinkerPop project, Gremlin is used in several databases (Titan, OrientDB) and
    processing systems (Giraph, Hadoop, Spark).'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cypher*—A declarative language for property graph–based database queries.
    Developed by Neo4j, Cypher is used by Neo4j and several other databases.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SPARQL*—A declarative query language for RDF-based database queries. SPARQL
    is used by Amazon Neptune, AllegroGraph, and others.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.3 Graph systems
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve covered the basic building blocks that allow us to implement graphs in
    a programming language. In practice, you’ll seldom create a graph from scratch
    because you’ll load data into memory or a database using a library or API. The
    field of graph libraries, databases, and commercial software is broad and growing
    rapidly. A good way to determine what to use is to start with your use case and
    requirements, and then choose your development and deployment architecture from
    there. This section will briefly give an overview of this landscape to help you.
    The taxonomy we develop here is by no means absolute but should serve as a useful
    guideline.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, commercial and open source tools for graph analysis,
    machine learning modeling, visualization, and storage are expanding relatively
    rapidly. With a lot of overlap between tools and functions, as well as many hybrid
    tools that don’t neatly fit into any category, there is no clean delineation of
    segments. Given this, we just highlight basic methods and focus on the most popular
    tools in the following segments:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Graph databases
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph compute engines (or graph frameworks)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualization libraries
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNN libraries
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.3.1 Graph databases
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graph databases are the graph analogues of traditional relational databases
    from a functional standpoint. Such databases were devised to handle transactions
    focused on Online Transaction Processing (OLTP). They allow CRUD transactions
    and also tend to follow ACID (atomicity, consistency, isolation, and durability)
    principles regarding the integrity of the data. Graph databases of this type differ
    from relational databases in that they store data using graph data models and
    schemas. At the time of writing, the most popular graph databases are Neo4j, Microsoft
    Cosmos DB, OrientDB, and ArangoDB. Except for Neo4j, these databases support multiple
    models, including property graphs. Neo4j supports property graphs only. The most
    popular databases that support RDF models are Virtuoso and Amazon Neptune.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In addition to property graphs and RDF databases, other types of nongraph databases
    are used to store graph data. Document stores, relational databases, and key-value
    stores are examples. To use such nongraph databases with graph data models, you
    must carefully define how the existing schema maps to the graph elements and their
    attributes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: A.3.2 Graph compute engines (or graph frameworks)
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graph compute engines are designed to make queries using batches of data. Such
    queries can output aggregate statistics or output graph-specific items, such as
    cluster identification and find shortest paths. These data systems tend to follow
    the Online Application Processing (OLAP) model. It’s not unusual for such systems
    to work closely with a graph database, which serves the input data batches needed
    for the analytic queries. Examples of such systems include Apache Spark’s GraphX,
    Giraph, and Stanford Network Analysis Platform (SNAP).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: A.3.3 Visualization libraries
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graph visualization tools share characteristics with graph compute engines,
    as they are geared toward analytics versus transactional queries and computations.
    However, such tools are designed to create aesthetic and useful images of the
    networks under analysis. In the best visualization tools, these images are interactive
    and dynamic. Outputs of visualization systems can be optimized for presentation
    on the web, or in printed format with high definition. Examples of such tools
    are Gephi, Cytoscape, and Tulip.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: A.3.4 GNN libraries
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last segment of graph tools is the central subject of this book. Here, we’re
    grouping software tools that create graph embeddings with tools that train the
    models using graph data. At the time of writing, there are many solutions available.
    Graph representation tools range from dedicated, standalone libraries (PyTorch
    BigGraph [PBG]) to graph systems that have embedding as a feature (Neo4j as a
    database and SNAP as a compute framework).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: GNN libraries come as standalone libraries, and as libraries that use TensorFlow
    or PyTorch as a backend. In this text, the focus will be on PyTorch Geometric
    (PyG). Other popular libraries include Deep Graph Library (DGL; a standalone library)
    and Spektral, which uses Kera and TensorFlow as a backend. The best libraries
    implement not only a range of deep learning layers but also the available benchmark
    datasets.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: A.4 Graph algorithms
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the field of graphs has been around for a while, the number of different
    graph algorithms is vast. Understanding well-used graph algorithms can provide
    valuable context with which to think about the algorithms used in neural networks.
    Graph algorithms can also serve as sources of node, edge, or graph features for
    GNNs. Finally, as with all machine learning methods, sometimes a statistical model
    isn’t the best solution. Understanding the analytical landscape can help when
    deciding whether or not to use a GNN solution.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we review two types of graph algorithms, *search algorithms*
    and *shortest path*. We provide a general description, explaining why they are
    important. For an in-depth treatment on this topic, review the references for
    this appendix at the end of the book, particularly [1–3].
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: A.4.1 Traversal and search algorithms
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In section A.1.1, we discussed the concept of a walk and a path. In these fundamental
    concepts, we get from one node in a graph to another by traversing a set of nodes
    and edges between them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: For large graphs with many nonunique walks and paths between node pairs, how
    do we decide which path to take? Similarly, for graphs we haven’t explored and
    don’t have a map of, what is the best way to create that map? Wrapped into these
    questions is the problem of what direction to take when traversing a graph at
    a particular node. For a node of degree 1, this answer is trivial; for a node
    with degree 100, the answer is less so.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Traversal algorithms offer systematic ways to walk a graph. For such algorithms,
    we start at a node, and following a set of rules, we decide on the next node to
    hop to. Often, as we conduct the walk, we keep track of nodes and edges that have
    been encountered. For certain algorithms, if we outline the path taken, we can
    end up with a tree structure. Three well known strategies for traversal are given
    here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '*Breadth first* —A breadth-first traversal prefers to explore all of the immediate
    neighbors of a node before going further away. This is also known as breadth-first
    search (BFS).'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Depth first* —With depth-first search (DFS), rather than explore every immediate
    neighbor first, we follow each new node without regard to its relationship to
    the current node. This is done in such a way that every node is encountered *at
    least* once, and every edge is encountered *exactly* once.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are versions of DFS and BFS for directed graphs as well.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '*Random* —In random traversals, in contrast to BFS and DFS, where traversal
    is governed by a set of rules, traversal to the next node is done randomly. For
    a starting node of degree 4 in a random traversal with a uniform distribution,
    each neighboring node would have a 25% chance of being chosen. Such methods are
    used in algorithms such as DeepWalk and Node2Vec (covered in chapter 2).'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.4.2 Shortest path
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An enduring problem highly related to graphs is that of the shortest path.
    Interest in solving this problem has existed for decades (a great survey paper
    of shortest path methods was published as far back as 1969 [4]), with several
    distinct algorithms existing. Modern applications of shortest path methods are
    used in navigation applications, such as finding the fastest route to a destination.
    Variations of such algorithms include the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Shortest path between
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two nodes
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two nodes on a path that includes specified nodes
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All nodes
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One node to all others
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranked shortest paths (i.e., second shortest path, third shortest, etc.)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such algorithms can also take into account weights in graphs. In these cases,
    shortest path algorithms are also called least-cost algorithms.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: A highly lauded algorithm for least-cost determination is Dijkstra’s algorithm.
    Given a node, it finds the shortest path to every other node or to a specified
    node. As this algorithm progresses, it traverses the graph while keeping track
    of the distance and connecting nodes (to the start node) of each node it encounters.
    It prioritizes the nodes encountered by their shortest (or least-cost) path to
    the start node. As the algorithm traverses, it prioritizes low-cost paths.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: A.5 How to read GNN literature
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNNs are a rapidly proliferating topic. New methods and techniques have been
    proposed in a short span of time. Though this book focuses on practical and commercial
    applications of graphs, much of the state of the art in this field is disclosed
    in academic journals and conferences. Knowing how to effectively study publications
    from these sources is essential to keep up to speed with the field and to encounter
    valuable ideas that can be implemented in code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'In this short section, we list some commonly used notations to describe graphs
    in technical publications as well as a few tips on reading academic literature
    for the practitioner. These tips are especially for those interested in using
    the methodology in a paper but are working under time constraints:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: To efficiently extract value from a paper, be selective on which sections of
    the publication to focus on. It’s important to clearly understand the problem
    statement and the solution to translate this into code. This might sound obvious,
    but many papers include sections that, for a practitioner, can be distracting
    at best. Mathematical proofs and long historical notes are good examples.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive trend is the increasing inclusion of code and data in research papers
    to enhance reproducibility. However, replicating results may still be challenging
    due to factors like model-specific optimizations or hardware constraints. If you
    encounter difficulties, reaching out to the authors can often provide valuable
    clarification.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look closely at indicators of the application scope of the problem and solution.
    An exciting development may not be applicable to your problem, and it may not
    be immediately obvious. Similarly, don’t take all claims for state-of-the-art
    results at face value. The academic world is extremely competitive and claimed
    state-of-the-art results may not hold, especially if a paper isn’t yet peer-reviewed.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.5.1 Common graph notations
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In mathematical notation, a graph is described as a set of nodes and edges:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: (A.1) *G* = (*V*, *E  *)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'where *V* and *E* are collections or sets of vertices (nodes) and edges, respectively.
    When we want to express the count of elements in these collections, we use *|V|*
    and *|E|*. In the following list, we outline some of the typical nomenclature
    for the mathematics of graphs:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: For directed graphs, an accented G (*![equation image](../Images/eq-appendix-a-269-1.png)*)
    is sometimes, but not always used.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual nodes and edges are denoted by lowercase letters, *v* and *e*, respectively.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When referring to a pair of adjacent nodes, we use *u* and *v*. Thus, an edge
    can also be expressed as {*u*, *v*}, or *uv*.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with weighted graphs, a weight for a particular edge is expressed
    as *w*(*e*). In terms of an edge’s nodes, we can include the weight as {*u*, *v*,
    *w*}.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To express the features of a graph or its elements, we use the notation *x*
    or **x** when the features are expressed as a vector or matrix, respectively.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For graph representations, because many such representations are matrices,
    bold letters are used to express them: **A** for the adjacency matrix, **L** for
    the Laplacian matrix, and so on.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
