- en: Appendix A. Autodiff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix explains how PyTorch’s automatic differentiation (autodiff) feature
    works, and how it compares to other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you define a function *f*(*x*, *y*) = *x*²*y* + *y* + 2, and you need
    its partial derivatives ∂*f*/∂*x* and ∂*f*/∂*y*, typically to perform gradient
    descent (or some other optimization algorithm). Your main options are manual differentiation,
    finite difference approximation, forward-mode autodiff, and reverse-mode autodiff.
    PyTorch implements reverse-mode autodiff, but to fully understand it, it’s useful
    to look at the other options first. So let’s go through each of them, starting
    with manual differentiation.
  prefs: []
  type: TYPE_NORMAL
- en: Manual Differentiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first approach to compute derivatives is to pick up a pencil and a piece
    of paper and use your calculus knowledge to derive the appropriate equation. For
    the function *f*(*x*, *y*) just defined, it is not too hard; you just need to
    use five rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The derivative of a constant is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derivative of *λx* is *λ* (where *λ* is a constant).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derivative of *x*^λ is *λx*^(*λ*) ^– ¹, so the derivative of *x*² is 2*x*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derivative of a sum of functions is the sum of these functions’ derivatives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derivative of *λ* times a function is *λ* times its derivative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From these rules, you can derive [Equation A-1](#partial_derivatives_equations).
  prefs: []
  type: TYPE_NORMAL
- en: Equation A-1\. Partial derivatives of *f*(*x*, *y*)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: <mtable displaystyle="true"><mtr><mtd columnalign="right"><mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mi>y</mi><mo>)</mo></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>y</mi></mrow>
    <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle> <mo>+</mo> <mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mn>2</mn></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>=</mo> <mi>y</mi> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mi>y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mi>y</mi><mo>)</mo></mrow> <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>y</mi></mrow>
    <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle> <mo>+</mo> <mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mn>2</mn></mrow> <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn> <mo>+</mo>
    <mn>0</mn> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></mtd></mtr></mtable>
  prefs: []
  type: TYPE_NORMAL
- en: This approach can become very tedious for more complex functions, and you run
    the risk of making mistakes. Fortunately, there are other options. Let’s look
    at finite difference approximation now.
  prefs: []
  type: TYPE_NORMAL
- en: Finite Difference Approximation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that the derivative *h*′(*x*[0]) of a function *h*(*x*) at a point *x*[0]
    is the slope of the function at that point. More precisely, the derivative is
    defined as the limit of the slope of a straight line going through this point
    *x*[0] and another point *x* on the function, as *x* gets infinitely close to
    *x*[0] (see [Equation A-2](#derivative_definition)).
  prefs: []
  type: TYPE_NORMAL
- en: Equation A-2\. Definition of the derivative of a function *h*(*x*) at point
    *x*[0]
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: <mrow><msup><mi>h</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>0</mn></msub>
    <mo>)</mo></mrow></mrow> <mrow><mo>=</mo> <munder><mo movablelimits="true" form="prefix">lim</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>→</mo><msub><mi>x</mi>
    <mn>0</mn></msub></mrow></mstyle></munder> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>h</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow></mrow> <mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi>
    <mn>0</mn></msub></mrow></mfrac></mstyle></mrow> <mrow><mo>=</mo> <munder><mo
    movablelimits="true" form="prefix">lim</mo> <mstyle scriptlevel="0" displaystyle="false"><mrow><mi>ε</mi><mo>→</mo><mn>0</mn></mrow></mstyle></munder>
    <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>+</mo><mi>ε</mi><mo>)</mo></mrow><mo>-</mo><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow></mrow> <mi>ε</mi></mfrac></mstyle></mrow>
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we wanted to calculate the partial derivative of *f*(*x*, *y*) with regard
    to *x* at *x* = 3 and *y* = 4, we could compute *f*(3 + *ε*, 4) – *f*(3, 4) and
    divide the result by *ε*, using a very small value for *ε*. This type of numerical
    approximation of the derivative is called a *finite difference approximation*,
    and this specific equation is called *Newton’s difference quotient*. That’s exactly
    what the following code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the result is imprecise (and it gets worse for more complicated
    functions). The correct results are respectively 24 and 10, but instead we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]  [PRE3]'
  prefs: []
  type: TYPE_NORMAL
