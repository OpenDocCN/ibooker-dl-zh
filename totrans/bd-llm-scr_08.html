<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div class="readable-text" id="p1"> 
   <h1 class=" readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">appendix B</span></span> <span class="chapter-title-text">References and further reading</span></h1> 
  </div> 
  <div class="readable-text" id="p2"> 
   <h2 class=" readable-text-h2">Chapter 1</h2> 
  </div> 
  <div class="readable-text" id="p3"> 
   <p>Custom-built LLMs are able to outperform general-purpose LLMs as a team at Bloomberg showed via a version of GPT pretrained on finance data from scratch. The custom LLM outperformed ChatGPT on financial tasks while maintaining good performance on general LLM benchmarks:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p101111"> “BloombergGPT: A Large Language Model for Finance” (2023) by Wu et al., <a href="https://arxiv.org/abs/2303.17564">https://arxiv.org/abs/2303.17564</a> </li> 
  </ul> 
  <div class="readable-text" id="p4"> 
   <p>Existing LLMs can be adapted and fine-tuned to outperform general LLMs as well, which teams from Google Research and Google DeepMind showed in a medical context:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p1011111"> “Towards Expert-Level Medical Question Answering with Large Language Models” (2023) by Singhal et al., <a href="https://arxiv.org/abs/2305.09617">https://arxiv.org/abs/2305.09617</a> </li> 
  </ul> 
  <div class="readable-text" id="p5"> 
   <p>The following paper proposed the original transformer architecture:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p1011112"> “Attention Is All You Need” (2017) by Vaswani et al., <a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a> </li> 
  </ul> 
  <div class="readable-text" id="p6"> 
   <p>On the original encoder-style transformer, called BERT, see</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p10111123"> “BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding” (2018) by Devlin et al., <a href="https://arxiv.org/abs/1810.04805">https://arxiv.org/abs/1810.04805</a> </li> 
  </ul> 
  <div class="readable-text" id="p7"> 
   <p>The paper describing the decoder-style GPT-3 model, which inspired modern LLMs and will be used as a template for implementing an LLM from scratch in this book, is</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p10111124"> “Language Models are Few-Shot Learners” (2020) by Brown et al., <a href="https://arxiv.org/abs/2005.14165">https://arxiv.org/abs/2005.14165</a> </li> 
  </ul> 
  <div class="readable-text" id="p8"> 
   <p>The following covers the original vision transformer for classifying images, which illustrates that transformer architectures are not only restricted to text inputs:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p10111125"> “An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale” (2020) by Dosovitskiy et al., <a href="https://arxiv.org/abs/2010.11929">https://arxiv.org/abs/2010.11929</a> </li> 
  </ul> 
  <div class="readable-text" id="p9"> 
   <p>The following experimental (but less popular) LLM architectures serve as examples that not all LLMs need to be based on the transformer architecture:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p10"> “RWKV: Reinventing RNNs for the Transformer Era” (2023) by Peng et al., <a href="https://arxiv.org/abs/2305.13048">https://arxiv.org/abs/2305.13048</a> </li> 
   <li class="readable-text" id="p11"> “Hyena Hierarchy: Towards Larger Convolutional Language Models” (2023) by Poli et al., <a href="https://arxiv.org/abs/2302.10866">https://arxiv.org/abs/2302.10866</a> </li> 
   <li class="readable-text" id="p12"> “Mamba: Linear-Time Sequence Modeling with Selective State Spaces” (2023) by Gu and Dao, <a href="https://arxiv.org/abs/2312.00752">https://arxiv.org/abs/2312.00752</a> </li> 
  </ul> 
  <div class="readable-text" id="p13"> 
   <p>Meta AI’s model is a popular implementation of a GPT-like model that is openly available in contrast to GPT-3 and ChatGPT:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p1254321"> “Llama 2: Open Foundation and Fine-Tuned Chat Models” (2023) by Touvron et al., <a href="https://arxiv.org/abs/2307.092881">https://arxiv.org/abs/2307.092881</a> </li> 
  </ul> 
  <div class="readable-text" id="p14"> 
   <p>For readers interested in additional details about the dataset references in section 1.5, this paper describes the publicly available <em>The Pile</em> dataset curated by Eleuther AI:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p12111"> “The Pile: An 800GB Dataset of Diverse Text for Language Modeling” (2020) by Gao et al., <a href="https://arxiv.org/abs/2101.00027">https://arxiv.org/abs/2101.00027</a> </li> 
  </ul> 
  <div class="readable-text" id="p15"> 
   <p>The following paper provides the reference for InstructGPT for fine-tuning GPT-3, which was mentioned in section 1.6 and will be discussed in more detail in chapter 7:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p121111"> “Training Language Models to Follow Instructions with Human Feedback” (2022) by Ouyang et al., <a href="https://arxiv.org/abs/2203.02155">https://arxiv.org/abs/2203.02155</a> </li> 
  </ul> 
  <div class="readable-text" id="p16"> 
   <h2 class=" readable-text-h2">Chapter 2</h2> 
  </div> 
  <div class="readable-text" id="p17"> 
   <p>Readers who are interested in discussion and comparison of embedding spaces with latent spaces and the general notion of vector representations can find more information in the first chapter of my book:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p121112"> Machine Learning Q and AI (2023) by Sebastian Raschka, <a href="https://leanpub.com/machine-learning-q-and-ai">https://leanpub.com/machine-learning-q-and-ai</a> </li> 
  </ul> 
  <div class="readable-text" id="p18"> 
   <p>The following paper provides more in-depth discussions of how byte pair encoding is used as a tokenization method:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p121113"> “Neural Machine Translation of Rare Words with Subword Units” (2015) by Sennrich et al., <a href="https://arxiv.org/abs/1508.07909">https://arxiv.org/abs/1508.07909</a> </li> 
  </ul> 
  <div class="readable-text" id="p19"> 
   <p>The code for the byte pair encoding tokenizer used to train GPT-2 was open-sourced by OpenAI:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p121114"> <a href="https://github.com/openai/gpt-2/blob/master/src/encoder.py">https://github.com/openai/gpt-2/blob/master/src/encoder.py</a> </li> 
  </ul> 
  <div class="readable-text" id="p20"> 
   <p>OpenAI provides an interactive web UI to illustrate how the byte pair tokenizer in GPT models works:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p121115"> <a href="https://platform.openai.com/tokenizer">https://platform.openai.com/tokenizer</a> </li> 
  </ul> 
  <div class="readable-text" id="p21"> 
   <p>For readers interested in coding and training a BPE tokenizer from the ground up, Andrej Karpathy’s GitHub repository <code>minbpe</code> offers a minimal and readable implementation:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p121116"> “A Minimal Implementation of a BPE Tokenizer,” <a href="https://github.com/karpathy/minbpe">https://github.com/karpathy/minbpe</a> </li> 
  </ul> 
  <div class="readable-text" id="p22"> 
   <p>Readers who are interested in studying alternative tokenization schemes that are used by some other popular LLMs can find more information in the SentencePiece and WordPiece papers:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p23"> “SentencePiece: A Simple and Language Independent Subword Tokenizer and Detokenizer for Neural Text Processing” (2018) by Kudo and Richardson, <a href="https://aclanthology.org/D18-2012/">https://aclanthology.org/D18-2012/</a> </li> 
   <li class="readable-text" id="p24"> “Fast WordPiece Tokenization” (2020) by Song et al., <a href="https://arxiv.org/abs/2012.15524">https://arxiv.org/abs/2012.15524</a> </li> 
  </ul> 
  <div class="readable-text" id="p25"> 
   <h2 class=" readable-text-h2">Chapter 3</h2> 
  </div> 
  <div class="readable-text" id="p26"> 
   <p>Readers interested in learning more about Bahdanau attention for RNN and language translation can find detailed insights in the following paper:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p121117"> “A Minimal Implementation of a BPE Tokenizer,” <a href="https://github.com/karpathy/minbpe">https://github.com/karpathy/minbpe</a> </li> 
  </ul> 
  <div class="readable-text" id="p27"> 
   <p>The concept of self-attention as scaled dot-product attention was introduced in the original transformer paper:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p121118"> “Attention Is All You Need” (2017) by Vaswani et al., <a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a> </li> 
  </ul> 
  <div class="readable-text" id="p28"> 
   <p>FlashAttention is a highly efficient implementation of a self-attention mechanism, which accelerates the computation process by optimizing memory access patterns. FlashAttention is mathematically the same as the standard self-attention mechanism but optimizes the computational process for efficiency:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p29"> “FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness” (2022) by Dao et al., <a href="https://arxiv.org/abs/2205.14135">https://arxiv.org/abs/2205.14135</a> </li> 
   <li class="readable-text" id="p30"> “FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning” (2023) by Dao, <a href="https://arxiv.org/abs/2307.08691">https://arxiv.org/abs/2307.08691</a> </li> 
  </ul> 
  <div class="readable-text" id="p31"> 
   <p>PyTorch implements a function for self-attention and causal attention that supports FlashAttention for efficiency. This function is beta and subject to change:</p> 
   <ul> 
    <li class="readable-text" id="p121119"> <code>scaled_dot_product_attention</code> documentation: <a href="https://mng.bz/NRJd">https://mng.bz/NRJd</a> </li> 
   </ul> 
   <div class="readable-text" id="p32"> 
    <p>PyTorch also implements an efficient <code>MultiHeadAttention</code> class based on the <code>scaled_</code> <code>dot_product</code> function:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1219"> <code>MultiHeadAttention</code> documentation: <a href="https://mng.bz/DdJV">https://mng.bz/DdJV</a> </li> 
   </ul> 
   <div class="readable-text" id="p33"> 
    <p>Dropout is a regularization technique used in neural networks to prevent overfitting by randomly dropping units (along with their connections) from the neural network during training:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1218"> “Dropout: A Simple Way to Prevent Neural Networks from Overfitting” (2014) by Srivastava et al., <a href="https://jmlr.org/papers/v15/srivastava14a.html">https://jmlr.org/papers/v15/srivastava14a.html</a> </li> 
   </ul> 
   <div class="readable-text" id="p34"> 
    <p>While using the multi-head attention based on scaled-dot product attention remains the most common variant of self-attention in practice, authors have found that it’s possible to also achieve good performance without the value weight matrix and projection layer:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1217"> “Simplifying Transformer Blocks” (2023) by He and Hofmann, <a href="https://arxiv.org/abs/2311.01906">https://arxiv.org/abs/2311.01906</a> </li> 
   </ul> 
   <div class="readable-text" id="p35"> 
    <h2 class=" readable-text-h2">Chapter 4</h2> 
   </div> 
   <div class="readable-text" id="p36"> 
    <p>The following paper introduces a technique that stabilizes the hidden state dynamics neural networks by normalizing the summed inputs to the neurons within a hidden layer, significantly reducing training time compared to previously published methods:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1216"> “Layer Normalization” (2016) by Ba, Kiros, and Hinton, <a href="https://arxiv.org/abs/1607.06450">https://arxiv.org/abs/1607.06450</a> </li> 
   </ul> 
   <div class="readable-text" id="p37"> 
    <p>Post-LayerNorm, used in the original transformer model, applies layer normalization after the self-attention and feed forward networks. In contrast, Pre-LayerNorm, as adopted in models like GPT-2 and newer LLMs, applies layer normalization before these components, which can lead to more stable training dynamics and has been shown to improve performance in some cases, as discussed in the following papers:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p38"> “On Layer Normalization in the Transformer Architecture” (2020) by Xiong et al., <a href="https://arxiv.org/abs/2002.04745">https://arxiv.org/abs/2002.04745</a> </li> 
    <li class="readable-text" id="p39"> “ResiDual: Transformer with Dual Residual Connections” (2023) by Tie et al., <a href="https://arxiv.org/abs/2304.14802">https://arxiv.org/abs/2304.14802</a> </li> 
   </ul> 
   <div class="readable-text" id="p40"> 
    <p>A popular variant of LayerNorm used in modern LLMs is RMSNorm due to its improved computing efficiency. This variant simplifies the normalization process by normalizing the inputs using only the root mean square of the inputs, without subtracting the mean before squaring. This means it does not center the data before computing the scale. RMSNorm is described in more detail in </p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1215"> “Root Mean Square Layer Normalization” (2019) by Zhang and Sennrich, <a href="https://arxiv.org/abs/1910.07467">https://arxiv.org/abs/1910.07467</a> </li> 
   </ul> 
   <div class="readable-text" id="p41"> 
    <p>The Gaussian Error Linear Unit (GELU) activation function combines the properties of both the classic ReLU activation function and the normal distribution’s cumulative distribution function to model layer outputs, allowing for stochastic regularization and nonlinearities in deep learning models:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1214"> “Gaussian Error Linear Units (GELUs)” (2016) by Hendricks and Gimpel, <a href="https://arxiv.org/abs/1606.08415">https://arxiv.org/abs/1606.08415</a> </li> 
   </ul> 
   <div class="readable-text" id="p42"> 
    <p>The GPT-2 paper introduced a series of transformer-based LLMs with varying sizes—124 million, 355 million, 774 million, and 1.5 billion parameters:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1213"> “Language Models Are Unsupervised Multitask Learners” (2019) by Radford et al., <a href="http://mng.bz/DMv0">http://mng.bz/DMv0</a> </li> 
   </ul> 
   <div class="readable-text" id="p43"> 
    <p>OpenAI’s GPT-3 uses fundamentally the same architecture as GPT-2, except that the largest version (175 billion) is 100x larger than the largest GPT-2 model and has been trained on much more data. Interested readers can refer to the official GPT-3 paper by OpenAI and the technical overview by Lambda Labs, which calculates that training GPT-3 on a single RTX 8000 consumer GPU would take 665 years:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p44"> “Language Models are Few-Shot Learners” (2023) by Brown et al., <a href="https://arxiv.org/abs/2005.14165">https://arxiv.org/abs/2005.14165</a> </li> 
    <li class="readable-text" id="p45"> “OpenAI’s GPT-3 Language Model: A Technical Overview,” <a href="https://lambdalabs.com/blog/demystifying-gpt-3">https://lambdalabs.com/blog/demystifying-gpt-3</a> </li> 
   </ul> 
   <div class="readable-text" id="p46"> 
    <p>NanoGPT is a code repository with a minimalist yet efficient implementation of a GPT-2 model, similar to the model implemented in this book. While the code in this book is different from nanoGPT, this repository inspired the reorganization of a large GPT Python parent class implementation into smaller submodules:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1212"> “NanoGPT, a Repository for Training Medium-Sized GPTs, <a href="https://github.com/karpathy/nanoGPT">https://github.com/karpathy/nanoGPT</a> </li> 
   </ul> 
   <div class="readable-text" id="p47"> 
    <p>An informative blog post showing that most of the computation in LLMs is spent in the feed forward layers rather than attention layers when the context size is smaller than 32,000 tokens is:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12101"> “In the Long (Context) Run” by Harm de Vries, <a href="https://www.harmdevries.com/post/context-length/">https://www.harmdevries.com/post/context-length/</a> </li> 
   </ul> 
   <div class="readable-text" id="p48"> 
    <h2 class=" readable-text-h2">Chapter 5</h2> 
   </div> 
   <div class="readable-text" id="p49"> 
    <p>For information on detailing the loss function and applying a log transformation to make it easier to handle for mathematical optimization, see my lecture video:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p124321"> L8.2 Logistic Regression Loss Function, <a href="https://www.youtube.com/watch?v=GxJe0DZvydM">https://www.youtube.com/watch?v=GxJe0DZvydM</a> </li> 
   </ul> 
   <div class="readable-text" id="p50"> 
    <p>The following lecture and code example by the author explain how PyTorch’s cross-entropy functions works under the hood:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p51"> L8.7.1 OneHot Encoding and Multi-category Cross Entropy, <a href="https://www.youtube.com/watch?v=4n71-tZ94yk">https://www.youtube.com/watch?v=4n71-tZ94yk</a> </li> 
    <li class="readable-text" id="p52"> Understanding Onehot Encoding and Cross Entropy in PyTorch, <a href="https://mng.bz/o05v">https://mng.bz/o05v</a> </li> 
   </ul> 
   <div class="readable-text" id="p53"> 
    <p>The following two papers detail the dataset, hyperparameter, and architecture details used for pretraining LLMs:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p54"> “Pythia: A Suite for Analyzing Large Language Models Across Training and Scaling” (2023) by Biderman et al., <a href="https://arxiv.org/abs/2304.01373">https://arxiv.org/abs/2304.01373</a> </li> 
    <li class="readable-text" id="p55"> “OLMo: Accelerating the Science of Language Models” (2024) by Groeneveld et al., <a href="https://arxiv.org/abs/2402.00838">https://arxiv.org/abs/2402.00838</a> </li> 
   </ul> 
   <div class="readable-text" id="p56"> 
    <p>The following supplementary code available for this book contains instructions for preparing 60,000 public domain books from Project Gutenberg for LLM training:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243211"> Pretraining GPT on the Project Gutenberg Dataset, <a href="https://mng.bz/Bdw2">https://mng.bz/Bdw2</a> </li> 
   </ul> 
   <div class="readable-text" id="p57"> 
    <p>Chapter 5 discusses the pretraining of LLMs, and appendix D covers more advanced training functions, such as linear warmup and cosine annealing. The following paper finds that similar techniques can be successfully applied to continue pretraining already pretrained LLMs, along with additional tips and insights:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243212"> “Simple and Scalable Strategies to Continually Pre-train Large Language Models” (2024) by Ibrahim et al., <a href="https://arxiv.org/abs/2403.08763">https://arxiv.org/abs/2403.08763</a> </li> 
   </ul> 
   <div class="readable-text" id="p58"> 
    <p>BloombergGPT is an example of a domain-specific LLM created by training on both general and domain-specific text corpora, specifically in the field of finance:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243213"> “BloombergGPT: A Large Language Model for Finance” (2023) by Wu et al., <a href="https://arxiv.org/abs/2303.17564">https://arxiv.org/abs/2303.17564</a> </li> 
   </ul> 
   <div class="readable-text" id="p59"> 
    <p>GaLore is a recent research project that aims to make LLM pretraining more efficient. The required code change boils down to just replacing PyTorch’s <code>AdamW</code> optimizer in the training function with the <code>GaLoreAdamW</code> optimizer provided by the <code>galore-torch</code> Python package:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p60"> “GaLore: Memory-Efficient LLM Training by Gradient Low-Rank Projection” (2024) by Zhao et al., <a href="https://arxiv.org/abs/2403.03507">https://arxiv.org/abs/2403.03507</a> </li> 
    <li class="readable-text" id="p61"> GaLore code repository, <a href="https://github.com/jiaweizzhao/GaLore">https://github.com/jiaweizzhao/GaLore</a> </li> 
   </ul> 
   <div class="readable-text" id="p62"> 
    <p>The following papers and resources share openly available, large-scale pretraining datasets for LLMs that consist of hundreds of gigabytes to terabytes of text data:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p63"> “Dolma: An Open Corpus of Three Trillion Tokens for LLM Pretraining Research” (2024) by Soldaini et al., <a href="https://arxiv.org/abs/2402.00159">https://arxiv.org/abs/2402.00159</a> </li> 
    <li class="readable-text" id="p64"> “The Pile: An 800GB Dataset of Diverse Text for Language Modeling” (2020) by Gao et al., <a href="https://arxiv.org/abs/2101.00027">https://arxiv.org/abs/2101.00027</a> </li> 
    <li class="readable-text" id="p65"> “The RefinedWeb Dataset for Falcon LLM: Outperforming Curated Corpora with Web Data, and Web Data Only,” (2023) by Penedo et al., <a href="https://arxiv.org/abs/2306.01116">https://arxiv.org/abs/2306.01116</a> </li> 
    <li class="readable-text" id="p66"> “RedPajama,” by Together AI, <a href="https://mng.bz/d6nw">https://mng.bz/d6nw</a> </li> 
    <li class="readable-text" id="p67"> The FineWeb Dataset, which includes more than 15 trillion tokens of cleaned and deduplicated English web data sourced from CommonCrawl, <a href="https://mng.bz/rVzy">https://mng.bz/rVzy</a> </li> 
   </ul> 
   <div class="readable-text" id="p68"> 
    <p>The paper that originally introduced top-k sampling is</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243214"> “Hierarchical Neural Story Generation” (2018) by Fan et al., <a href="https://arxiv.org/abs/1805.04833">https://arxiv.org/abs/1805.04833</a> </li> 
   </ul> 
   <div class="readable-text" id="p69"> 
    <p>An alternative to top-k sampling is top-p sampling (not covered in chapter 5), which selects from the smallest set of top tokens whose cumulative probability exceeds a threshold <em>p</em>, while top-k sampling picks from the top <em>k</em> tokens by probability:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243215"> Top-p sampling, <a href="https://en.wikipedia.org/wiki/Top-p_sampling">https://en.wikipedia.org/wiki/Top-p_sampling</a> </li> 
   </ul> 
   <div class="readable-text" id="p70"> 
    <p>Beam search (not covered in chapter 5) is an alternative decoding algorithm that generates output sequences by keeping only the top-scoring partial sequences at each step to balance efficiency and quality:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243216"> “Diverse Beam Search: Decoding Diverse Solutions from Neural Sequence Models” (2016) by Vijayakumar et al., <a href="https://arxiv.org/abs/1610.02424">https://arxiv.org/abs/1610.02424</a> </li> 
   </ul> 
   <div class="readable-text" id="p71"> 
    <h2 class=" readable-text-h2">Chapter 6</h2> 
   </div> 
   <div class="readable-text" id="p72"> 
    <p>Additional resources that discuss the different types of fine-tuning are</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p73"> “Using and Finetuning Pretrained Transformers,” <a href="https://mng.bz/VxJG">https://mng.bz/VxJG</a> </li> 
    <li class="readable-text" id="p74"> “Finetuning Large Language Models,” <a href="https://mng.bz/x28X">https://mng.bz/x28X</a> </li> 
   </ul> 
   <div class="readable-text" id="p75"> 
    <p>Additional experiments, including a comparison of fine-tuning the first output token versus the last output token, can be found in the supplementary code material on GitHub:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243217"> Additional spam classification experiments, <a href="https://mng.bz/AdJx">https://mng.bz/AdJx</a> </li> 
   </ul> 
   <div class="readable-text" id="p76"> 
    <p>For a binary classification task, such as spam classification, it is technically possible to use only a single output node instead of two output nodes, as I discuss in the following article:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243218"> “Losses Learned—Optimizing Negative Log-Likelihood and Cross-Entropy in PyTorch,” <a href="https://mng.bz/ZEJA">https://mng.bz/ZEJA</a> </li> 
   </ul> 
   <div class="readable-text" id="p77"> 
    <p>You can find additional experiments on fine-tuning different layers of an LLM in the following article, which shows that fine-tuning the last transformer block, in addition to the output layer, improves the predictive performance substantially:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1243219"> “Finetuning Large Language Models,” <a href="https://mng.bz/RZJv">https://mng.bz/RZJv</a> </li> 
   </ul> 
   <div class="readable-text" id="p78"> 
    <p>Readers can find additional resources and information for dealing with imbalanced classification datasets in the imbalanced-learn documentation:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12432110"> “Imbalanced-Learn User Guide,” <a href="https://mng.bz/2KNa">https://mng.bz/2KNa</a> </li> 
   </ul> 
   <div class="readable-text" id="p79"> 
    <p>For readers interested in classifying spam emails rather than spam text messages, the following resource provides a large email spam classification dataset in a convenient CSV format similar to the dataset format used in chapter 6:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p120011"> Email Spam Classification Dataset, <a href="https://mng.bz/1GEq">https://mng.bz/1GEq</a> </li> 
   </ul> 
   <div class="readable-text" id="p80"> 
    <p>GPT-2 is a model based on the decoder module of the transformer architecture, and its primary purpose is to generate new text. As an alternative, encoder-based models such as BERT and RoBERTa can be effective for classification tasks:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p81"> “BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding” (2018) by Devlin et al., <a href="https://arxiv.org/abs/1810.04805">https://arxiv.org/abs/1810.04805</a> </li> 
    <li class="readable-text" id="p82"> “RoBERTa: A Robustly Optimized BERT Pretraining Approach” (2019) by Liu et al., <a href="https://arxiv.org/abs/1907.11692">https://arxiv.org/abs/1907.11692</a> </li> 
    <li class="readable-text" id="p83"> “Additional Experiments Classifying the Sentiment of 50k IMDB Movie Reviews,” <a href="https://mng.bz/PZJR">https://mng.bz/PZJR</a> </li> 
   </ul> 
   <div class="readable-text" id="p84"> 
    <p>Recent papers are showing that the classification performance can be further improved by removing the causal mask during classification fine-tuning alongside other modifications:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p85"> “Label Supervised LLaMA Finetuning” (2023) by Li et al., <a href="https://arxiv.org/abs/2310.01208">https://arxiv.org/abs/2310.01208</a> </li> 
    <li class="readable-text" id="p86"> “LLM2Vec: Large Language Models Are Secretly Powerful Text Encoders” (2024) by BehnamGhader et al., <a href="https://arxiv.org/abs/2404.05961">https://arxiv.org/abs/2404.05961</a> </li> 
   </ul> 
   <div class="readable-text" id="p87"> 
    <h2 class=" readable-text-h2">Chapter 7</h2> 
   </div> 
   <div class="readable-text" id="p88"> 
    <p>The Alpaca dataset for instruction fine-tuning contains 52,000 instruction–response pairs and is one of the first and most popular publicly available datasets for instruction fine-tuning:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p120111"> “Stanford Alpaca: An Instruction-Following Llama Model,” <a href="https://github.com/tatsu-lab/stanford_alpaca">https://github.com/tatsu-lab/stanford_alpaca</a> </li> 
   </ul> 
   <div class="readable-text" id="p89"> 
    <p>Additional publicly accessible datasets suitable for instruction fine-tuning include</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p90"> LIMA, <a href="https://huggingface.co/datasets/GAIR/lima">https://huggingface.co/datasets/GAIR/lima</a>  
     <ul> 
      <li> For more information, see “LIMA: Less Is More for Alignment,” Zhou et al., <a href="https://arxiv.org/abs/2305.11206">https://arxiv.org/abs/2305.11206</a> </li> 
     </ul></li> 
    <li class="readable-text" id="p91"> UltraChat, <a href="https://huggingface.co/datasets/openchat/ultrachat-sharegpt">https://huggingface.co/datasets/openchat/ultrachat-sharegpt</a> 
     <ul> 
      <li> A large-scale dataset consisting of 805,000 instruction–response pairs; for more information, see “Enhancing Chat Language Models by Scaling High-quality Instructional Conversations,” by Ding et al., <a href="https://arxiv.org/abs/2305.14233">https://arxiv.org/abs/2305.14233</a> </li> 
     </ul></li> 
    <li class="readable-text" id="p92"> Alpaca GPT4, <a href="https://mng.bz/Aa0p">https://mng.bz/Aa0p</a> </li> 
    <li> An Alpaca-like dataset with 52,000 instruction–response pairs generated with GPT-4 instead of GPT-3.5 </li> 
   </ul> 
   <div class="readable-text" id="p93"> 
    <p>Phi-3 is a 3.8-billion-parameter model with an instruction-fine-tuned variant that is reported to be comparable to much larger proprietary models, such as GPT-3.5:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p1200111"> “Phi-3 Technical Report: A Highly Capable Language Model Locally on Your Phone” (2024) by Abdin et al., <a href="https://arxiv.org/abs/2404.14219">https://arxiv.org/abs/2404.14219</a> </li> 
   </ul> 
   <div class="readable-text" id="p94"> 
    <p>Researchers propose a synthetic instruction data generation method that generates 300,000 high-quality instruction-response pairs from an instruction fine-tuned Llama-3 model. A pretrained Llama 3 base model fine-tuned on these instruction examples performs comparably to the original instruction fine-tuned Llama-3 model:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12001112"> “Magpie: Alignment Data Synthesis from Scratch by Prompting Aligned LLMs with Nothing” (2024) by Xu et al., <a href="https://arxiv.org/abs/2406.08464">https://arxiv.org/abs/2406.08464</a> </li> 
   </ul> 
   <div class="readable-text" id="p95"> 
    <p>Research has shown that not masking the instructions and inputs in instruction fine-tuning effectively improves performance on various NLP tasks and open-ended generation benchmarks, particularly when trained on datasets with lengthy instructions and brief outputs or when using a small number of training examples:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12001113"> “Instruction Tuning with Loss Over Instructions” (2024) by Shi, <a href="https://arxiv.org/abs/2405.14394">https://arxiv.org/abs/2405.14394</a> </li> 
   </ul> 
   <div class="readable-text" id="p96"> 
    <p>Prometheus and PHUDGE are openly available LLMs that match GPT-4 in evaluating long-form responses with customizable criteria. We don’t use these because at the time of this writing, they are not supported by Ollama and thus cannot be executed efficiently on a laptop:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p97"> “Prometheus: Inducing Finegrained Evaluation Capability in Language Models” (2023) by Kim et al., <a href="https://arxiv.org/abs/2310.08491">https://arxiv.org/abs/2310.08491</a> </li> 
    <li class="readable-text" id="p98"> “PHUDGE: Phi-3 as Scalable Judge” (2024) by Deshwal and Chawla, “<a href="https://arxiv.org/abs/2405.08029">https://arxiv.org/abs/2405.08029</a> </li> 
    <li class="readable-text" id="p99"> “Prometheus 2: An Open Source Language Model Specialized in Evaluating Other Language Models” (2024), by Kim et al., <a href="https://arxiv.org/abs/2405.01535">https://arxiv.org/abs/2405.01535</a> </li> 
   </ul> 
   <div class="readable-text" id="p100"> 
    <p>The results in the following report support the view that large language models primarily acquire factual knowledge during pretraining and that fine-tuning mainly enhances their efficiency in using this knowledge. Furthermore, this study explores how fine-tuning large language models with new factual information affects their ability to use preexisting knowledge, revealing that models learn new facts more slowly and their introduction during fine-tuning increases the model’s tendency to generate incorrect information:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12001114"> “Does Fine-Tuning LLMs on New Knowledge Encourage Hallucinations?” (2024) by Gekhman, <a href="https://arxiv.org/abs/2405.05904">https://arxiv.org/abs/2405.05904</a> </li> 
   </ul> 
   <div class="readable-text" id="p101"> 
    <p>Preference fine-tuning is an optional step after instruction fine-tuning to align the LLM more closely with human preferences. The following articles by the author provide more information about this process:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p102"> “LLM Training: RLHF and Its Alternatives,” <a href="https://mng.bz/ZVPm">https://mng.bz/ZVPm</a> </li> 
    <li class="readable-text" id="p103"> “Tips for LLM Pretraining and Evaluating Reward Models,” <a href="https://mng.bz/RNXj">https://mng.bz/RNXj</a> </li> 
   </ul> 
   <div class="readable-text" id="p104"> 
    <h2 class=" readable-text-h2">Appendix A</h2> 
   </div> 
   <div class="readable-text" id="p105"> 
    <p>While appendix A should be sufficient to get you up to speed, if you are looking for more comprehensive introductions to deep learning, I recommend the following books:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p106"> <em>Machine Learning with PyTorch and Scikit-Learn</em> (2022) by Sebastian Raschka, Hayden Liu, and Vahid Mirjalili. ISBN 978-1801819312 </li> 
    <li class="readable-text" id="p107"> <em>Deep Learning with PyTorch</em> (2021) by Eli Stevens, Luca Antiga, and Thomas Viehmann. ISBN 978-1617295263 </li> 
   </ul> 
   <div class="readable-text" id="p108"> 
    <p>For a more thorough introduction to the concepts of tensors, readers can find a 15-minute video tutorial that I recorded:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12001115"> “Lecture 4.1: Tensors in Deep Learning,” <a href="https://www.youtube.com/watch?v=JXfDlgrfOBY">https://www.youtube.com/watch?v=JXfDlgrfOBY</a> </li> 
   </ul> 
   <div class="readable-text" id="p109"> 
    <p>If you want to learn more about model evaluation in machine learning, I recommend my article</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12001116"> “Model Evaluation, Model Selection, and Algorithm Selection in Machine Learning” (2018) by Sebastian Raschka, <a href="https://arxiv.org/abs/1811.12808">https://arxiv.org/abs/1811.12808</a> </li> 
   </ul> 
   <div class="readable-text" id="p110"> 
    <p>For readers who are interested in a refresher or gentle introduction to calculus, I’ve written a chapter on calculus that is freely available on my website:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12001117"> “Introduction to Calculus,” by Sebastian Raschka, <a href="https://mng.bz/WEyW">https://mng.bz/WEyW</a> </li> 
   </ul> 
   <div class="readable-text" id="p111"> 
    <p>Why does PyTorch not call <code>optimizer.zero_grad()</code> automatically for us in the background? In some instances, it may be desirable to accumulate the gradients, and PyTorch will leave this as an option for us. If you want to learn more about gradient accumulation, please see the following article:</p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12001118"> “Finetuning Large Language Models on a Single GPU Using Gradient Accumulation” by Sebastian Raschka, <a href="https://mng.bz/8wPD">https://mng.bz/8wPD</a> </li> 
   </ul> 
   <div class="readable-text" id="p112"> 
    <p>This appendix covers DDP, which is a popular approach for training deep learning models across multiple GPUs. For more advanced use cases where a single model doesn’t fit onto the GPU, you may also consider PyTorch’s Fully Sharded Data Parallel (FSDP) method, which performs distributed data parallelism and distributes large layers across different GPUs. For more information, see this overview with further links to the API documentation: </p> 
   </div> 
   <ul> 
    <li class="readable-text" id="p12001119"> “Introducing PyTorch Fully Sharded Data Parallel (FSDP) API,” <a href="https://mng.bz/EZJR">https://mng.bz/EZJR</a> </li> 
   </ul> 
  </div>
 </div></div></body></html>