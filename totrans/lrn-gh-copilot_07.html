<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Using Copilot to Document and Explain Code"><div class="chapter" id="ch06">
<h1><span class="label">Chapter 6. </span>Using Copilot to Document <span class="keep-together">and Explain Code</span></h1>

<p><a contenteditable="false" data-type="indexterm" data-primary="code" data-secondary="documenting" id="xi_codedocumenting644"/>A<a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="for code" id="xi_documentationforcode645"/>s developers, we all know that having good documentation with our code is essential. The documentation within the codebase makes it more understandable, reviewable, and maintainable in the long run. Documentation in the code is a crucial contributor to the overall quality of the code and the quality of the product built from the code.</p>

<p>However, we also know that taking the time and effort to create good documentation can seem tedious and can feel like a much lower priority than the fun of making the code itself. So, continuing with the theme of how Copilot can help you beyond coding suggestions and answering questions, let’s look at how it can help automate this task.</p>

<p>In this chapter, we’ll look at several aspects of using Copilot’s documentation capabilities, including generating documentation via the editor and chat interfaces. But we’ll also show you how to leverage Copilot to produce content for use cases you may not have considered, such as external documentation for APIs, functional documentation, and more.</p>

<p>We’ll also look at how to use Copilot to explain code. While this is an often overlooked feature of Copilot, it has tremendous potential for helping engineers at all levels understand code and algorithms. Some beneficial use cases include explaining code from an unfamiliar language or framework, checking the logic of your code with explanations, and leveraging Copilot to explain commands happening in the <span class="keep-together">terminal</span>.</p>

<p>Let’s dive in and get started by looking at how Copilot’s documentation capabilities can be leveraged throughout your development cycle.</p>

<section data-type="sect1" data-pdf-bookmark="Documenting Content"><div class="sect1" id="id127">
<h1>Documenting Content</h1>

<p><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="content" id="xi_documentationcontent6174"/><a contenteditable="false" data-type="indexterm" data-primary="contents" data-secondary="documenting" id="xi_contentsdocumenting6174"/>Many developers know they can use Copilot’s documentation capabilities to produce header documentation and comments in the body of their code. But the exact mechanisms to do this can be confusing. You can use shortcut functions, but these are limited in what they do. In the first part of this section, we’ll focus on how to most easily generate program documentation inline and through Copilot’s chat interface.</p>

<p>Beyond the basic<em> document my code</em> functionality, Copilot can be used for several broader documentation tasks. It can generate framework-specific documentation (such as for Swagger), developer-facing documentation for APIs, and even functional documentation. In the latter part of this section, we’ll cover those extended use cases where you can leverage more of the power of Copilot for different kinds of documentation. But let’s start with the basics.</p>

<section data-type="sect2" data-pdf-bookmark="Generating Documentation Inline"><div class="sect2" id="id61">
<h2>Generating Documentation Inline</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="generating inline" id="xi_documentationgeneratinginline6244"/><a contenteditable="false" data-type="indexterm" data-primary="inline documentation" id="xi_inlinedocumentation6244"/>Here’s a code listing for a function (written in Go) that creates a new Kubernetes service for a custom resource:</p>

<pre data-type="programlisting" translate="no">
func newServiceForPod(cr *roarappv1alpha1.RoarApp) *corev1.Service {

    strPort := strconv.Itoa(nextPort)
    labels := map[string]string{
        "app": cr.Name,
    }

    return &amp;corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      cr.Name + "-service-" + strPort,
            Namespace: cr.Namespace,
        },
        Spec: corev1.ServiceSpec{
            Selector: labels,
            Ports: []corev1.ServicePort{{
                Protocol:   corev1.ProtocolTCP,
                Port:       8089,
                TargetPort: intstr.FromInt(8080),
                NodePort:   int32(nextPort),
            }},
            Type: corev1.ServiceTypeNodePort,
        },
    }
}
</pre>

<p class="pagebreak-before">The most direct/shortest path to getting documentation generated for this function inline is to invoke the inline chat interface via the <em>Meta<a contenteditable="false" data-type="indexterm" data-primary="Meta notation" id="id713"/></em>-I key combination and use the shortcut command <code translate="no">/doc<a contenteditable="false" data-type="indexterm" data-primary="/doc command" id="id714"/></code>, as shown in <a data-type="xref" href="#using-shortcut-doc-co">Figure 6-1</a>.</p>

<figure><div id="using-shortcut-doc-co" class="figure"><img alt="" src="assets/lghc_0601.png" width="906" height="510"/>
<h6><span class="label">Figure 6-1. </span>Using the shortcut <code>/doc</code> command</h6>
</div></figure>

<p>Copilot will then generate basic documentation for the function. This will likely consist of only comments above the function, as shown in the following listing and in <a data-type="xref" href="#generated-doc-results">Figure 6-2</a>:</p>

<pre data-type="programlisting" translate="no">
// newServiceForPod creates a new Kubernetes Service resource for a 
given RoarApp custom resource.
// The Service is configured as a NodePort service, exposing a 
specific port for external access.
//
// Parameters:
//   - cr: A pointer to a RoarApp custom resource instance.
//
// Returns:
//   - A pointer to a corev1.Service object configured with the 
specified labels, ports, and namespace.
</pre>

<figure><div id="generated-doc-results" class="figure"><img alt="" src="assets/lghc_0602.png" width="1178" height="644"/>
<h6><span class="label">Figure 6-2. </span>Generated doc results</h6>
</div></figure>

<p>This is useful as far as it goes—adding comments about the purpose, parameters, and return values of the function. What is missing is any additional comments or documentation in the <em>body</em> of the function. Even if we were to provide a more extensive command such as <code translate="no">add doc to my code</code>, Copilot will default to using the <code translate="no">/doc<a contenteditable="false" data-type="indexterm" data-primary="/doc command" id="id715"/> </code>command again, and we’ll get similar results. This is true currently regardless of which chat interface we use.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id716">
<h1>Documentation from Comments</h1>

<p><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="from comments" id="id717"/><a contenteditable="false" data-type="indexterm" data-primary="comments" data-secondary="documentation from" id="id718"/>You can also generate documentation from comments by using Copilot, as shown in <a data-type="xref" href="#creating-documentatio">Figure 6-3</a>.</p>

<figure><div id="creating-documentatio" class="figure"><img alt="" src="assets/lghc_0603.png" width="973" height="165"/>
<h6><span class="label">Figure 6-3. </span>Creating documentation from comments</h6>
</div></figure>

<p>You need to use wording like <strong><code>create documentation</code></strong> to trigger Copilot. However, as shown, the results are more simplistic. And this is probably less useful since you’re having to create a comment yourself to get Copilot to create comments.</p>
</div></aside>

<p>Recall that, when working directly in the editor, Copilot targets minimal, quick responses that don’t disrupt the flow of work and can be reviewed and accepted or discarded easily.</p>

<p>Typically, if we want or need more substantial responses from Copilot, we can use the separate, dedicated chat interface. That also holds for generating documentation, as you’ll see in the next section<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_documentationgeneratinginline6244" id="id719"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_inlinedocumentation6244" id="id720"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Generating Documentation Through Chat"><div class="sect2" id="id62">
<h2>Generating Documentation Through Chat</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="generating through chat" id="xi_documentationgeneratingthroughchat61014"/><a contenteditable="false" data-type="indexterm" data-primary="Copilot Chat" data-secondary="generating documentation through" id="xi_CopilotChatgeneratingdocumentationthrough61014"/>If we switch to the separate chat interface and give Copilot the same direction to add documentation to our code, we get a more extensive and detailed response (<a data-type="xref" href="#telling-copilot-to-ad">Figure 6-4</a>).</p>

<figure><div id="telling-copilot-to-ad" class="figure"><img alt="" src="assets/lghc_0604.png" width="1167" height="640"/>
<h6><span class="label">Figure 6-4. </span>Telling Copilot to add documentation to the code from the main chat</h6>
</div></figure>

<p>The complete listing, as generated with comments, is available in the <a href="https://oreil.ly/zHnkm">book’s GitHub repository</a>. A few excerpts are shared in the next listing. You can see that Copilot not only inserted substantially more header comments but also added multiple comments throughout the body of the function:</p>

<pre data-type="programlisting" translate="no">
// newServiceForPod creates a new Kubernetes Service resource for a
 given RoarApp custom resource.
// The Service is configured as a NodePort service, exposing a 
specific port for external access.
//
// Parameters:
//   - cr: A pointer to a RoarApp custom resource instance.
//
// Returns:
//   - A pointer to a corev1.Service object configured with the 
specified labels, ports, and namespace.
func newServiceForPod(cr *roarappv1alpha1.RoarApp) *corev1.Service {

    // Convert the next available port to a string for use in the 
service name.
    strPort := strconv.Itoa(nextPort)

    // Define labels to associate the service with the corresponding
 RoarApp instance.
    labels := map[string]string{
        "app": cr.Name,
    }

    // Create and return a new Service object.
 ...
</pre>

<p>Let’s take this a step further. Since Copilot Chat can understand natural language, we can submit a prompt to have documentation generated to help anyone reading the code. We can tell Copilot in chat to “verbosely comment the selected function so anyone can understand what it is doing.” The resulting change from the original (uncommented) function can be seen in the <a href="https://oreil.ly/jTDZV">GitHub repository</a><a contenteditable="false" data-type="indexterm" data-primary="GitHub repository" id="id721"/><a contenteditable="false" data-type="indexterm" data-primary="repositories" data-secondary="GitHub" id="id722"/>. Other than some wording changes, the main differences are some extra lines of comments for each main section that talks about how the pieces are used or managed. Also some comments are added at the end of lines where an identifier may need to be better understood. <a data-type="xref" href="#updated-lines-from-is">Figure 6-5</a> shows an excerpt from these changes.</p>

<figure><div id="updated-lines-from-is" class="figure"><img alt="" src="assets/lghc_0605.png" width="1021" height="602"/>
<h6><span class="label">Figure 6-5. </span>Updated lines from issuing a verbose comment command</h6>
</div></figure>

<p>This is an improvement. If we want even more, we can specifically target each line in the function body. Here’s a prompt we can use for that: “verbosely comment the function body so that anyone can easily understand what each line is doing.”</p>

<p>With this prompt, we get a further verbose set of comments for the function body with more detailed comments for several of the elements. The full listing is available <a href="https://oreil.ly/rZBRV">online</a>, but <a data-type="xref" href="#more-verbose-comments">Figure 6-6</a> shows an excerpt of the differences.</p>

<figure><div id="more-verbose-comments" class="figure"><img alt="" src="assets/lghc_0606.png" width="1358" height="765"/>
<h6><span class="label">Figure 6-6. </span>More verbose comments</h6>
</div></figure>

<div data-type="note" epub:type="note">
<h1>Comment Versus Documentation</h1>

<p><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="comment versus" id="id723"/><a contenteditable="false" data-type="indexterm" data-primary="comments" data-secondary="documentation versus" id="id724"/>You may have noticed that we are telling Copilot to <em>comment</em> our code versus <em>document</em> it. Since documentation in code is done via comments, either of these terms can be used in this situation for prompts. Strictly speaking, when we ask Copilot for documentation, it may default to creating a block of comments only at the start of the method/function, as we saw earlier.</p>
</div>

<p>Ultimately, you could combine the previous prompts into a single one to accomplish all the modifications. Here’s an example that seems to work well:</p>

<pre>
verbosely document the function header and body so that anyone can easily
understand what the overall function and each line is doing</pre>

<p>One other nice aspect about Copilot’s documentation capabilities is that it can recognize when code has a documentation framework that can be used with it<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_documentationgeneratingthroughchat61014" id="id725"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_CopilotChatgeneratingdocumentationthrough61014" id="id726"/>.</p>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Generating Framework-Compatible Documentation"><div class="sect2" id="id63">
<h2 class="less_space">Generating Framework-Compatible Documentation</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="generating framework-compatible" id="xi_documentationgeneratingframeworkcompatible61694"/><a contenteditable="false" data-type="indexterm" data-primary="framework-compatible documentation, generating" id="xi_frameworkcompatibledocumentationgenerating61694"/>Different programming languages have their own documentation styles. For example, C#<a contenteditable="false" data-type="indexterm" data-primary="C#" id="id727"/> has XMLDoc<a contenteditable="false" data-type="indexterm" data-primary="XMLDoc" id="id728"/>, Python<a contenteditable="false" data-type="indexterm" data-primary="Python" id="id729"/> has pydoc<a contenteditable="false" data-type="indexterm" data-primary="pydoc" id="id730"/>, and JavaScript<a contenteditable="false" data-type="indexterm" data-primary="JavaScript" id="id731"/> has JSDoc<a contenteditable="false" data-type="indexterm" data-primary="JSDoc" id="id732"/>. If Copilot recognizes that the code is in a language that has a standard documentation tool associated with it, it will default to creating comments ready for that tool. This can be very useful for integration with the development environment and other tools and is often preferred to plain comments.</p>

<p>For example, consider a Java class definition containing a single method that begins as shown here:</p>

<pre data-type="programlisting" translate="no">
package com.demo.util;

import org.codehaus.jettison.json.JSONArray;
import org.codehaus.jettison.json.JSONObject;
import java.sql.ResultSet;
import org.owasp.esapi.ESAPI;

public class ToJSON {

    
    public JSONArray toJSONArray(ResultSet rs) throws Exception {

            JSONArray json = new JSONArray(); //JSON array that will
 be returned
            String temp = null;

            try {

                 //we will need the column names, this will save the
 table meta-data like column names.
                 java.sql.ResultSetMetaData rsmd = rs.getMetaData();

</pre>

<p>If we tell Copilot to “document this class,” it will add an extensive set of comments. The full listing is available <a href="https://oreil.ly/LCxOH">online</a>, but a few excerpts are included next:</p>

<pre data-type="programlisting" translate="no">
package com.demo.util;

// Importing necessary libraries for JSON processing and SQL result
 handling
...
import java.sql.ResultSet;
// Importing ESAPI for security purposes, though it's not used in
 the provided snippet
import org.owasp.esapi.ESAPI;

/**
* The ToJSON class provides a method to convert a ResultSet from a 
database query
* into a JSONArray. This is useful for creating JSON APIs that 
interact with relational databases.
...
*/
public class ToJSON {

    /**
     * Converts a given ResultSet into a JSONArray.
     * Each row in the ResultSet will be converted into a JSONObject,
     * and each column in the row will be added to the JSONObject 
...
     *
     * @param rs The ResultSet to be converted. This ResultSet is 
typically obtained from executing
     *           a SQL query against a database.
     * @return JSONArray containing the data from the ResultSet. 
Each element in the JSONArray
     *         corresponds to a row in the ResultSet, represented as
 a JSONObject.
     * @throws Exception If there is an error during the conversion 
process. This could be due to
...
     */
    public JSONArray toJSONArray(ResultSet rs) throws Exception {
        JSONArray json = new JSONArray(); // Initializes the JSON 
array that will be populated and returned
        String temp = null; // Temporary string to hold data, not 
used in the provided snippet
...
</pre>

<p>The header comments above the class definition, and at its start, are generated in a form that is compatible with processing by the Javadoc<a contenteditable="false" data-type="indexterm" data-primary="Javadoc" id="id733"/> tooling. The <code translate="no">/**</code> and <code translate="no">@param</code>, <code translate="no">@return</code>, and <code translate="no">@throw</code> parts are all formatting pieces that Javadoc would use to generate HTML documentation for the class. <a data-type="xref" href="#javadoc-generated-fro">Figure 6-7</a> shows an example of the generated Javadoc originating from the comments added by Copilot.</p>

<figure><div id="javadoc-generated-fro" class="figure"><img alt="" src="assets/lghc_0607.png" width="1295" height="885"/>
<h6><span class="label">Figure 6-7. </span>Javadoc generated from Copilot comments</h6>
</div></figure>

<p>Beyond generating documentation for the basic documentation frameworks, we can also use Copilot for another common need: documenting APIs<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_documentationgeneratingframeworkcompatible61694" id="id734"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_frameworkcompatibledocumentationgenerating61694" id="id735"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Generating Documentation for APIs"><div class="sect2" id="id64">
<h2>Generating Documentation for APIs</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="generating for APIs" id="xi_documentationgeneratingforAPIs62574"/><a contenteditable="false" data-type="indexterm" data-primary="APIs, generating documentation for" id="xi_APIsgeneratingdocumentationfor62574"/>If your project is set up for an API documentation framework like <a href="https://swagger.io">Swagger</a><a contenteditable="false" data-type="indexterm" data-primary="Swagger" id="id736"/>, you can have Copilot generate the corresponding Swagger documentation for your APIs. Let’s look at an example.</p>

<p>Suppose we have a simple application that manages a directory of employees for a company. The application is written in Java and already configured for Swagger. We can tell Copilot to generate print-ready Swagger documentation for the APIs, referencing a particular file, with the prompt “create print-ready Swagger documentation for the APIS in #file:EmployeeController.java.”</p>

<div data-type="note" epub:type="note">
<h1>print-ready</h1>

<p>We used the term<em> print-ready<a contenteditable="false" data-type="indexterm" data-primary="print-ready" id="id737"/></em> in the prompt to ensure that Copilot generates the actual documentation format instead of trying to regenerate the code comments. We could also use terms like <em>publish-ready<a contenteditable="false" data-type="indexterm" data-primary="publish-ready" id="id738"/></em> or <em>publishable<a contenteditable="false" data-type="indexterm" data-primary="publishable" id="id739"/></em>.</p>
</div>

<p>Copilot’s response is shown in <a data-type="xref" href="#swagger-doc-from-code">Figure 6-8</a>, and the full output is available in the book’s <a href="https://oreil.ly/Kj8Lj">GitHub repository</a><a contenteditable="false" data-type="indexterm" data-primary="GitHub repository" id="id740"/><a contenteditable="false" data-type="indexterm" data-primary="repositories" data-secondary="GitHub" id="id741"/>.</p>

<figure><div id="swagger-doc-from-code" class="figure"><img alt="" src="assets/lghc_0608.png" width="965" height="771"/>
<h6><span class="label">Figure 6-8. </span>Swagger documentation from code</h6>
</div></figure>

<p>A key for this to work (in addition to the <code>print-ready</code> descriptor) is being specific with the files that you point Copilot to via the <code translate="no">#file </code>selector (or multiple selectors if you need to reference more than one file). Simply pointing Copilot to the entire workspace with a similar prompt (such as “@workspace create Swagger<a contenteditable="false" data-type="indexterm" data-primary="Swagger" id="id742"/> documentation for the APIs”) will usually result in Copilot explaining <em>how to create</em> the Swagger documentation in your project versus dumping it out<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_documentationgeneratingforAPIs62574" id="id743"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_APIsgeneratingdocumentationfor62574" id="id744"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Creating Functional Documentation"><div class="sect2" id="id65">
<h2>Creating Functional Documentation</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="creating functional" id="xi_documentationcreatingfunctional62794"/><a contenteditable="false" data-type="indexterm" data-primary="functional documentation, creating" id="xi_functionaldocumentationcreating62794"/>Copilot is also capable of creating functional documentation that is targeted toward external users. For an example, we can leverage the same API code that we used in the preceding section. In this case, our prompt might look something like this: “create functional documentation explaining the various public APIs in #file:Employee​Con⁠troller.java.”</p>

<p class="pagebreak-before"><a data-type="xref" href="#generated-functional">Figure 6-9</a> shows the start of the actual functional API doc generated from the prompt. Note that the output includes some prose style, in an easy-to-read format, but with the necessary details outlined for the API structure. It’s not shown here, but Copilot also outlined a set of steps first that it would follow for this, including <em><span class="keep-together">Identifying</span> Public APIs</em>, <em>Method Signatures</em>, and <em>Endpoint Mapping</em>. The full output can be viewed in the book’s <a href="https://oreil.ly/lV7jV">GitHub repo</a><a contenteditable="false" data-type="indexterm" data-primary="GitHub repository" id="id745"/><a contenteditable="false" data-type="indexterm" data-primary="repositories" data-secondary="GitHub" id="id746"/>.</p>

<figure><div id="generated-functional" class="figure"><img alt="" src="assets/lghc_0609.png" width="1429" height="714"/>
<h6><span class="label">Figure 6-9. </span>Generated functional documentation</h6>
</div></figure>

<p class="pagebreak-before">In general, the same caveat applies for generating this kind of documentation as it did for generating API documentation in the previous section: indicate specific files for the prompt to act on as opposed to trying to ask Copilot to operate against the entire workspace. However, we can ask some general questions by using <code translate="no">@workspace<a contenteditable="false" data-type="indexterm" data-primary="@workspace chat participant" id="id747"/></code> and get good summary documentation. For example, if we ask “@workspace what are the API’s parameters and what does it return?”, we get a useful summary. The full listing is available <a href="https://oreil.ly/sXKOv">online</a>, and an excerpt is also shown in <a data-type="xref" href="#querying-api-paramete">Figure 6-10</a><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_documentationcreatingfunctional62794" id="id748"/>.</p>

<figure><div id="querying-api-paramete" class="figure"><img alt="" src="assets/lghc_0610.png" width="1418" height="671"/>
<h6><span class="label">Figure 6-10. </span>Querying API parameters<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_functionaldocumentationcreating62794" id="id749"/></h6>
</div></figure>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Extracting Summary Documentation from the Code"><div class="sect2" id="id66">
<h2>Extracting Summary Documentation from the Code</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="summary documentation, extracting from code" id="xi_summarydocumentationextractingfromcode62974"/><a contenteditable="false" data-type="indexterm" data-primary="documentation" data-secondary="extracting summary" id="xi_documentationextractingsummary62974"/>Copilot can also be used to extract a high-level summary of the key documentation from certain types of projects. This can be extremely useful for quickly understanding the significant details of the codebase for a project. Referencing the Java Swagger project in the preceding section, we can gather key information from it with the prompt “@workspace extract the key documentation from the code.”</p>

<p>In our case, Copilot extracted data from the <em>pom.xml</em> file, the <em>README.md</em> file, and the relevant <em>*.java</em> files. Copilot then provided key high-level details on the project’s structure, dependencies, Swagger configuration, and testing. <a data-type="xref" href="#key-documentation-ext">Figure 6-11</a> shows an excerpt, and the full listing can be seen <a href="https://oreil.ly/wSmbs">on GitHub</a>.</p>

<figure><div id="key-documentation-ext" class="figure"><img alt="" src="assets/lghc_0611.png" width="1199" height="701"/>
<h6><span class="label">Figure 6-11. </span>Key documentation extracted from code</h6>
</div></figure>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id750">
<h1>Copying and Exporting Chat Conversations</h1>

<p><a contenteditable="false" data-type="indexterm" data-primary="copying chat conversations" id="id751"/><a contenteditable="false" data-type="indexterm" data-primary="exporting chat conversations" id="id752"/><a contenteditable="false" data-type="indexterm" data-primary="Copilot Chat" data-secondary="copying conversations" id="id753"/><a contenteditable="false" data-type="indexterm" data-primary="Copilot Chat" data-secondary="exporting conversations" id="id754"/>If you want to grab the content from a chat conversation, you have a couple of options. The simplest is just to right-click in the conversation and select either Copy or Copy All. Copy grabs the current conversation. Copy All grabs all the conversations in the current chat.</p>

<p>You also can click the Views and More Actions control (which looks like three dots) in the top left of the current chat and open the chat in a new editor session in the current IDE, or pop out the current chat to its own standalone window.</p>

<p>It’s important to remember that when you are copying from a chat, what you are getting is the text in Markdown format<a contenteditable="false" data-type="indexterm" data-primary="Markdown format" id="id755"/>. To see the text presented in the same way as it displays in the chat panel, you need to save the copied text as a Markdown file (<em>.md</em> extension) and view it in a tool that can display Markdown files.</p>

<p>Alternatively, if you are using VS Code or a codespace, you can export the conversation in JSON format through the Command Palette. To do this, open the Command Palette and search for <strong><code translate="no">Chat: Export Chat</code></strong>. Ensure that you have the cursor active in a conversation in the chat panel first.</p>
</div></aside>

<p>That completes our survey of the various ways that Copilot can help you with producing documentation. Let’s move to a similar, but arguably more important, functionality that Copilot provides: explaining content<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_documentationcontent6174" id="id756"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_contentsdocumenting6174" id="id757"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_summarydocumentationextractingfromcode62974" id="id758"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_documentationextractingsummary62974" id="id759"/>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Explaining Content"><div class="sect1" id="id67">
<h1>Explaining Content</h1>

<p><a contenteditable="false" data-type="indexterm" data-primary="contents" data-secondary="explaining" id="xi_contentsexplaining63244"/><a contenteditable="false" data-type="indexterm" data-primary="explaining content" id="xi_explainingcontent63244"/>In addition to providing documentation for what code does, Copilot is also able to provide explanations for content it works with and generates. This feature can be helpful in multiple use cases:</p>

<ul>
	<li>Understanding code in a language new to you</li>
	<li>Understanding generated code and conventions</li>
	<li>Summarizing code logic</li>
	<li>Explaining what might go wrong in the code</li>
	<li>Explaining what was done in the terminal</li>
	<li>Explaining how to do something in the terminal</li>
</ul>

<p>We’ll briefly dive into each one of these areas in this section. A couple of common points apply across all of these:</p>

<ul>
	<li>The prompt is the key here. Getting the prompt correct for the situation and using it to state clearly what you want is the most important prerequisite to having Copilot explain something well.</li>
	<li>While we will generally use <em>explain</em> as a key term in our prompt, it’s not always required. You can also ask <em>why, how</em>, or other types of questions as appropriate.</li>
</ul>

<section data-type="sect2" data-pdf-bookmark="Understanding Code in a Language New to You"><div class="sect2" id="id68">
<h2>Understanding Code in a Language New to You</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="Go code" id="xi_Gocode63454"/><a contenteditable="false" data-type="indexterm" data-primary="code" data-secondary="Go" id="xi_codeGo63454"/>Suppose you are a Python programmer, but you’ve just been given an assignment to implement a new project in Go. Copilot can assist you with creating the code as well as understanding the key points of working with Go. For example, you can give Copilot a prompt like “I’m a Python programmer. What are the most significant things I need to understand about how to write Go code?”</p>

<p>When asked this question while I was writing this chapter, Copilot responded with information about the following 12 areas:</p>

<ul class="two-col">
	<li>Static typing</li>
	<li>Compilation</li>
	<li>Syntax differences</li>
	<li>Packages and imports</li>
	<li>Functions</li>
	<li>Error handling</li>
	<li>Concurrency</li>
	<li>Structs and methods</li>
	<li>Pointers</li>
	<li>Standard library</li>
	<li>Tooling</li>
	<li>Interfaces</li>
</ul>

<p>In some cases, Copilot also showed brief code snippets to illustrate the points and finished the explanation with “Understanding these key differences will help you transition from Python to Go more smoothly.” You can see the entire output from the chat <a href="https://oreil.ly/roJZB">on GitHub</a>.</p>

<p>You can also select specific parts of your code and have Copilot explain how they work with the <code translate="no">/explain</code> shortcut command. You can even tell Copilot to translate existing code into the new language. As always, though, you should verify that any suggestion or response that Copilot provides is accurate and appropriate for your <span class="keep-together">situation</span><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_Gocode63454" id="id760"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_codeGo63454" id="id761"/>.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id762">
<h1>Copilot as Teacher</h1>

<p><a contenteditable="false" data-type="indexterm" data-primary="GitHub Copilot" data-secondary="as a teacher" id="id763"/>One of the other, less common ways to utilize Copilot to help learn a new language is to utilize it as a <em>teacher</em> and ask it to give you a problem to solve in the new language. Here’s an example:</p>

<p>Prompt: Explain how to code a function in Go by giving me a problem to complete.</p>

<p>Copilot helpfully produces a response with the following:</p>

<ul>
	<li>Problem statement</li>
	<li>Steps to solve the problem</li>
	<li>Actual Go code to successfully complete the problem</li>
</ul>

<p>The full output can be seen <a href="https://oreil.ly/4RVS5">on GitHub</a>.</p>
</div></aside>

<p>Copilot is helpful not only in understanding the basics of a new language but also in highlighting conventions that the language uses and the purpose of automatically generated code in that language.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Understanding Generated Code and Conventions"><div class="sect2" id="id69">
<h2>Understanding Generated Code and Conventions</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="generated code" id="xi_generatedcode63924"/><a contenteditable="false" data-type="indexterm" data-primary="code" data-secondary="generated" id="xi_codegenerated63924"/>Suppose you are new to Kubernetes and Go and need to create a Kubernetes operator<a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="operators" id="id764"/> to manage custom resources. You would probably use the <a href="https://oreil.ly/Lfz8O">Operator SDK</a><a contenteditable="false" data-type="indexterm" data-primary="Operator SDK" id="id765"/> to generate the starting structure for your project in Go. </p>

<p>The SDK automatically generates utility files, including ones with cryptic names like <em>zz_generated.deepcopy.go</em>. One of the first things you might want to know is what this generated file is used for. To get the answer, you can simply ask Copilot, “What is the code in #file:api/v1alpha1/zz_generated.deepcopy used for?” Copilot’s response (excerpted in <a data-type="xref" href="#copilot-explaining-wh">Figure 6-12</a>) provides an introduction and then a breakdown of its purpose. The entire response can be found <a href="https://oreil.ly/I0-3j">on GitHub</a>.</p>

<figure><div id="copilot-explaining-wh" class="figure"><img alt="" src="assets/lghc_0612.png" width="1023" height="477"/>
<h6><span class="label">Figure 6-12. </span>Copilot explaining what code is used for</h6>
</div></figure>

<p>In these kinds of responses, Copilot will usually provide a summary at the end of the output that can be helpful to quickly get the gist of the response. In this case, Copilot notes, “In summary, zz_generated.deepcopy.go is an auto-generated file that provides necessary deep copy functions for custom resource types in Kubernetes, ensuring proper handling and manipulation of these resources.”</p>

<p>You might also wonder why the code is named the way it is. We can ask Copilot about the naming convention with a prompt like “Why is this file named starting with zz_?” Copilot provides a helpful, conversational answer with a list of reasons for the convention, as shown in <a data-type="xref" href="#copilot-explanation-f">Figure 6-13</a>.</p>

<figure><div id="copilot-explanation-f" class="figure"><img alt="" src="assets/lghc_0613.png" width="1140" height="467"/>
<h6><span class="label">Figure 6-13. </span>Copilot explanation for the <span class="roman">zz_ naming</span> convention</h6>
</div></figure>

<p>In addition to understanding the general conventions and main themes of a language, Copilot can help explain the overall logic of a set of code<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_generatedcode63924" id="id766"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_codegenerated63924" id="id767"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Explaining the Logic Used in a Section of Code"><div class="sect2" id="id70">
<h2>Explaining the Logic Used in a Section of Code</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="logic, explaining logic used in code" id="xi_logicexplaininglogicusedincode64144"/><a contenteditable="false" data-type="indexterm" data-primary="code" data-secondary="explaining logic used in" id="xi_codeexplaininglogicusedin64144"/>Summarizing code logic more generally can be helpful in various use cases, including these:</p>

<ul>
	<li>Quickly getting a handle on code you’ve inherited or must maintain</li>
	<li>Learning about code written in a language or framework that’s new to you</li>
	<li>Checking your understanding from reviewing the code</li>
	<li>Having another explanation of how the code works for code reviews, pull requests, etc.</li>
</ul>

<p>The goal is to have Copilot outline the general logic and related pieces, such as the main components used, in a non-language-specific way. We want Copilot’s explanation to be in a conversational tone, as if we were interacting with another developer.</p>

<p>The actual prompt you use for this can vary, but here’s an example for the same controller file that we’ve been referencing: “@workspace: summarize the logic in #file:controllers/roarapp_controller.go.”</p>

<p>From this prompt, Copilot provides output that starts with an overall explanation of what the code is intended to do: “reconciling the state of ... custom resources in a Kubernetes cluster.”</p>

<p>Copilot then provides a summary of the key components in the file and what each does. These include the data structures, annotations, and functions. An excerpt from this output is shown in <a data-type="xref" href="#copilot-summarizing-t">Figure 6-14</a>, and the complete output can be seen <a href="https://oreil.ly/5oG3v">on GitHub</a>.</p>

<figure><div id="copilot-summarizing-t" class="figure"><img alt="" src="assets/lghc_0614.png" width="1240" height="524"/>
<h6><span class="label">Figure 6-14. </span>Copilot summarizing the logic used in a file</h6>
</div></figure>

<p>Another good prompt to consider is simply swapping the keyword <em>workflow</em> for <em>logic</em>, as in “@workspace: summarize the workflow in #file:controllers/roarapp_controller.go.” This should yield a slightly simpler response but with similar information on the various components.</p>

<p>One other interesting way to learn about, and understand, the code flips the traditional <em>explain</em> use case. Instead of asking Copilot to explain how or what code does, we can ask it about potential problems with the code<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_logicexplaininglogicusedincode64144" id="id768"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_codeexplaininglogicusedin64144" id="id769"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Explaining What Might Go Wrong with a Set of Code"><div class="sect2" id="id71">
<h2>Explaining What Might Go Wrong with a Set of Code</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="code" data-secondary="explaining what may go wrong" id="id770"/>Another approach when having Copilot explain code is to have it identify any potential problems with the code. This can be used for code you’ve written, are investigating, or have inherited, for example.</p>

<p>Going back to the Kubernetes custom resource example that we’ve been using in this chapter, we can choose to ask Copilot what could go wrong with the code that implements the custom controller in the editor. The prompt we use for this is “@workspace: explain what might go wrong with the code in #file:controllers/roarapp_​controller.go.”</p>

<div data-type="note" epub:type="note">
<h1>Using @workspace and #file</h1>

<p>Remember, we can use variables like <code translate="no">#selection<a contenteditable="false" data-type="indexterm" data-primary="#selection variable" id="id771"/></code> or <code>#file<a contenteditable="false" data-type="indexterm" data-primary="#file variable" id="id772"/></code> in the prompt string to focus Copilot on the context we want it to consider for its response. But in some cases, we may also need to use the <code translate="no">@workspace<a contenteditable="false" data-type="indexterm" data-primary="@workspace chat participant" id="id773"/></code> identifier to ensure that Copilot looks at related pieces and takes into account the full picture of what else might affect this code.</p>
</div>

<p>Copilot, in turn, provides a detailed answer listing out several areas to look at that include the following:</p>

<ul class="two-col">
	<li>Error handling</li>
	<li>Resource conflicts</li>
	<li>Requeue logic</li>
	<li>Resource cleanup</li>
	<li>Concurrency issues</li>
	<li>Logging</li>
	<li>Validation</li>
	<li>RBAC permissions</li>
</ul>

<p>The full output for this can be seen in the <a href="https://oreil.ly/v7I75">GitHub repo file</a><a contenteditable="false" data-type="indexterm" data-primary="GitHub repository" id="id774"/><a contenteditable="false" data-type="indexterm" data-primary="repositories" data-secondary="GitHub" id="id775"/>.</p>

<p>Now that we’ve looked at different ways Copilot can explain what’s happening in code, let’s finish up by looking at how Copilot can help explain things in the context of another domain—the terminal.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Explaining Items from the Terminal"><div class="sect2" id="id72">
<h2>Explaining Items from the Terminal</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="terminal" data-secondary="explaining items from" id="xi_terminalexplainingitemsfrom64744"/>Copilot is able to access the terminal to explain details about the last command via the <code translate="no">#terminalLastCommand<a contenteditable="false" data-type="indexterm" data-primary="#terminalLastCommand keyword" id="id776"/></code> keyword. For example, assume we ran the <code translate="no">ps<a contenteditable="false" data-type="indexterm" data-primary="ps command" id="id777"/></code> command as shown here as our most recent command:</p>

<pre data-type="programlisting" translate="no">
@techupskills ➜ /workspaces/op-new (main) $ ps -aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME 
COMMAND
codespa+       1  0.0  0.0   1136   640 ?        Ss   14:30   0:00 
 /sbin/docker-init
codespa+       8  0.0  0.0   7236  1920 ?        S    14:30   0:00
 sleep infinity
root          23  0.0  0.0  12196  3484 ?        Ss   14:30   0:00
 sshd: /usr/sbin/s
codespa+     338  0.0  0.0   2616  1536 ?        Ss   14:30   0:00
 /bin/sh</pre>

<p>If we wanted more details on what this command was doing, we could query Copilot with a prompt like “explain #terminalLastCommand.” As you can see in <a data-type="xref" href="#copilot-explaining-th">Figure 6-15</a>, Copilot identifies the last command and provides an explanation of the command, its options, and its output.</p>

<figure><div id="copilot-explaining-th" class="figure"><img alt="" src="assets/lghc_0615.png" width="1184" height="520"/>
<h6><span class="label">Figure 6-15. </span>Copilot explaining the last terminal command</h6>
</div></figure>

<p class="pagebreak-before">The full output can be seen <a href="https://oreil.ly/yCMOO">in GitHub</a>.</p>

<p>Copilot can also explain selected content from the terminal. For example, if we ran a <code translate="no">git status<a contenteditable="false" data-type="indexterm" data-primary="git status command" id="id778"/></code> command previously, we can highlight that and ask Copilot to explain it with the prompt “explain the commands in #terminalSelection.” Copilot will then provide info on that, as shown in <a data-type="xref" href="#explaining-a-command">Figure 6-16</a>.</p>

<figure><div id="explaining-a-command" class="figure"><img alt="" src="assets/lghc_0616.png" width="1873" height="883"/>
<h6><span class="label">Figure 6-16. </span>Explaining a command selected in the terminal</h6>
</div></figure>

<p>You don’t have to select a command to explain. You can also select any text displayed in the terminal, such as the output of a command. Suppose we select the text “Your branch is up to date with ‘origin/main’.” in the output of the <code translate="no">git status</code> command. Since the identifier already references any content selected in the terminal, we can shorten our prompt to “explain #terminalSelection.”</p>

<p class="pagebreak-before">Copilot will then explain the meaning of that selected phrase. <a data-type="xref" href="#explaining-git-status">Figure 6-17</a> shows an excerpt from the output for this prompt.</p>

<figure><div id="explaining-git-status" class="figure"><img alt="" src="assets/lghc_0617.png" width="1201" height="703"/>
<h6><span class="label">Figure 6-17. </span>Explaining the <code>git status</code> command as selected in terminal</h6>
</div></figure>

<p>You can also have Copilot explain <em>how</em> to do something via the terminal. That’s the subject of our last section in this chapter<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_terminalexplainingitemsfrom64744" id="id779"/>.</p>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Explaining How to Do Something in the Terminal"><div class="sect2" id="id73">
<h2 class="less_space">Explaining How to Do Something in the Terminal</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="terminal" data-secondary="explaining how to do something in" id="xi_terminalexplaininghowtodosomethingin65174"/>Copilot can supply the process and commands to do operations in the terminal. As an example, we can ask Copilot how to create a new branch in our GitHub repository. We can utilize the <code translate="no">@terminal </code>context and prompt Copilot with: “@terminal How do I create a new branch for my GitHub repository?”</p>

<p>In response, Copilot provides the usual conversational process description along with the actual commands that you can run in the terminal. <a data-type="xref" href="#explaining-how-to-cre">Figure 6-18</a> shows an excerpt from the output, which you can see in full on <a href="https://oreil.ly/0t1il">GitHub</a>.</p>

<figure><div id="explaining-how-to-cre" class="figure"><img alt="" src="assets/lghc_0618.png" width="1062" height="608"/>
<h6><span class="label">Figure 6-18. </span>Explaining how to create a new branch via the terminal</h6>
</div></figure>

<div data-type="note" epub:type="note">
<h1>Similar Results</h1>

<p>You can also achieve a similar result with a prompt that references <em>command line</em>, as in “How can I create a new branch in my GitHub repository using the command line<a contenteditable="false" data-type="indexterm" data-primary="command line" id="id780"/>?”</p>
</div>

<p>The same technique is applicable when you may not know the command to use. For example, if we give Copilot the query “@terminal how do I see the list of running processes?”, it responds with multiple approaches that can be used from the terminal, as shown in <a data-type="xref" href="#how-to-see-running-pr">Figure 6-19</a>.</p>

<figure><div id="how-to-see-running-pr" class="figure"><img alt="" src="assets/lghc_0619.png" width="1200" height="580"/>
<h6><span class="label">Figure 6-19. </span>How to see running processes via the terminal</h6>
</div></figure>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="id74">
<h1>Conclusion</h1>

<p>In this chapter, we’ve explored how Copilot can help you with documentation and explanations. At the basic level, Copilot can document your source code by inserting comments throughout. A shortcut <code translate="no">/doc</code> command typically provides header documentation. You can tell Copilot to produce more extensive comments via prompts that include specific directions, such as “verbosely comment.” This illustrates a useful working tip for Copilot: if you aren’t getting what you expect or need, try using a more verbose, detailed prompt. You can reject the suggested changes if they are not what you wanted and continue to iterate on your prompt.</p>

<p>Beyond just the basic commenting, Copilot can also generate more extensive documentation for particular use cases. For example, it can generate API documentation and functional documentation suitable (after review) for sharing with others. This can provide a significant time savings over having to create this type of documentation in a less automated way.</p>

<p>Similar to its documentation capability, Copilot also can explain many aspects of a codebase. This functionality can be used to explain general concepts and principles needed to use a new language or framework and also provide explanations for conventions that you may not be familiar with.</p>

<p>But, most significantly, Copilot can explain and summarize how the logic and processing for a set of code works. This can be especially useful if you are trying to learn, or have to maintain, code that you are not familiar with.</p>

<p>A less common use for the explain functionality can be to explain what might go wrong with a set of code. This is an easy way to have Copilot essentially<em> review </em>the code and look for potential gaps and problems. This can be very useful if you are trying to assess weaknesses in the code and make sure vulnerable sections are addressed.</p>

<p>Lastly, we looked at the ability to use Copilot’s explain functionality with a terminal. This falls into two categories. The first is selecting some output or referencing the last terminal command with a special identifier and having Copilot explain the meaning. The second involves asking Copilot how to do something in the terminal and having it provide a conversational explanation along with the exact commands to run in the terminal to accomplish the task.</p>

<p>While we have seen how valuable and extensive Copilot’s capabilities can be, it’s important to remember that it can be inaccurate and provide out-of-date information as results. This happens because Copilot’s knowledge base is only as up-to-date as the recency of the data that was used to train the underlying models it leverages.</p>

<p>In the next chapter, we’ll look at how to deal with Copilot basing suggestions and responses on out-of-date information and how to work around those situations<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_documentationforcode645" id="id781"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_codedocumenting644" id="id782"/>.</p>
</div></section>
</div></section></div></div></body></html>