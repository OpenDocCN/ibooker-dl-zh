["```py\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ngraph = nx.Graph()\n\nnodes = list(range(5))                        ①\ngraph.add_nodes_from(nodes)\n\nedges = [(0,1),(1,2), (1,3), (2,3),(3,4)]     ②\ngraph.add_edges_from(edges)\n\nnx.draw_networkx(graph, font_color=\"white\")\n```", "```py\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ngraph = nx.DiGraph()       ①\nnodes = list(range(5))\nedges = [(0,1),(1,2), (1,3), (2,3),(3,4)]\ngraph.add_edges_from(edges)\ngraph.add_nodes_from(nodes)\nnx.draw_networkx(graph, font_color=\"white\")\n```", "```py\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ngraph = nx.MultiGraph()\nnodes = list(range(5))\nedges = [(0,1),(0,1),(4,3),(1,2), (1,3), (2,3),(3,4),(0,1)]\ngraph.add_nodes_from(nodes)\ngraph.add_edges_from(edges)\n\npos = nx.kamada_kawai_layout(graph)                                   ①\nax = plt.gca()     \n\nfor e in graph.edges:                                                 ②\n     ax.annotate(\"\",xy=pos[e[0]], xycoords='data', xytext=pos[e[1]],  ②\n          ➥textcoords='data', arrowprops=dict(arrowstyle=\"-\",        ②\n          ➥connectionstyle=f\"arc3, rad={0.3*e[2]}\"),zorder=1)        ②\n\nnx.draw_networkx_nodes(graph, pos)                                    ③\nnx.draw_networkx_labels(graph,pos, font_color='w')                    ③\n\nplt.show()\n```", "```py\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ngraph = nx.DiGraph()\nnodes = list(range(5))\nedges = [(0,1), (0,2),(4,1),(1,2),(2,3)]\ngraph.add_nodes_from(nodes)\ngraph.add_edges_from(edges)\n\nnx.draw_networkx(graph, nx.kamada_kawai_layout(graph), with_labels=True,\n➥ font_color='w')\nplt.show()\n\nnx.is_directed_acyclic_graph(graph)    ①\n```", "```py\nimport hypernetx as hnx\n\ndata = {\n     0: (\"A\",\"B\",\"G\"),\n     1: (\"A\",\"C\",\"D\",\"E\",\"F\"),\n     2: (\"B\",\"F\"),\n     3: (\"A\",\"B\",\"D\",\"E\",\"F\",\"G\")\n}                            ①\nH = hnx.Hypergraph(data)     ②\nhnx.draw(H)                  ③\n```", "```py\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nG = nx.Graph()                                              ①\n\nG.add_node(\"Device1\", pos=(0,0))                            ②\nG.add_node(\"Device2\", pos=(0,2))                            ②\nG.add_node(\"Device3\", pos=(2,0))                            ②\nG.add_node(\"Device4\", pos=(2,2)) \n\nG.add_weighted_edges_from([(\"Device1\", \"Device2\", 45.69),\n                           (\"Device1\", \"Device3\", 56.34),\n                           (\"Device2\", \"Device4\", 18.5)])   ③\n\npos = nx.get_node_attributes(G, 'pos')                      ④\nnx.draw_networkx(G, pos, with_labels=True)                  ⑤\nnx.draw_networkx_edge_labels(G, pos,                        ⑤\n➥edge_labels={(u, v): d['weight'] for                      ⑤\n➥u, v, d in G.edges(data=True)})                           ⑤\nplt.show() \n```", "```py\nimport osmnx as ox\nimport matplotlib.pyplot as plt\n\nplace_name = \"University of Toronto\"     \n\ngraph = ox.graph_from_address(place_name)   ①\nox.plot_graph(graph,figsize=(10,10))\n```", "```py\ngraph = ox.graph_from_address(place_name)\nox.folium.plot_graph_folium(graph)\n```", "```py\nimport folium\n\ncenter=(43.662643, -79.395689)                                           ①\nsource_point = (43.664527, -79.392442)                                   ②\ndestination_point = (43.659659, -79.397669)                              ③\n\nm = folium.Map(location=center, zoom_start=15)                           ④\nfolium.Marker(location=source_point,icon=folium.                         ⑤\n➥Icon(color='red',icon='camera', prefix='fa')).add_to(m)                ⑤\nfolium.Marker(location=center,icon=folium.Icon(color='blue',             ⑤\n➥icon='graduation-cap', prefix='fa')).add_to(m)                         ⑤\nfolium.Marker(location=destination_point,icon=folium.Icon(color='green', ⑤\n➥icon='university', prefix='fa')).add_to(m)                             ⑤\n```", "```py\nInputs: Source node, Destination node\nOutput: Route from source to destination\n\nInitialize *queue* ← a FIFO initialized with source node\nInitialize *explored* ← empty\nInitialize *found* ← False\n\nWhile *queue* is not empty and *found* is False do\n    Set *node* ← *queue.*dequeue()\n    Add *node* to *explored*\n    For *child* in *node.*expand() do\n        If *child* is not in *explored* and *child* is not in *queue* then\n            If *child* is *destination* then\n                Update *route* ← *child* route()\n                Update *found* ← True\n            Add *child* to *queue*\nReturn *route*\n```", "```py\n#!pip install optalgotools\nfrom optalgotools.algorithms.graph_search import BFS    ①\n\ninit_state = [[1,4,2], [3,7,5], [6,0,8]]\n\ngoal_state = [[0,1,2], [3,4,5], [6,7,8]]\n\ninit_state = State(init_state)                          ②\ngoal_state = State(goal_state)   \n\nif not init_state.is_solvable():                        ③\n     print(\"This puzzle is not solvable.\")\nelse:\n\n    solution = BFS(init_state, goal_state)\n    print(f\"Process time: {solution.time} s\")\n    print(f\"Space required: {solution.space} bytes\")\n    print(f\"Explored states: {solution.explored}\")\n    visualize(solution.result)                          ④\n```", "```py\nProcess time: 0.015625 s\nSpace required: 624 bytes\nExplored states: 7\n```", "```py\nInputs: Source node, Destination node\nOutput: Route from source to destination\n\nInitialize *Stack* ← a LIFO initialized with *source*node\nInitialize *Explored* ← empty\nInitialize *Found* ← False\n\nWhile *stack* is not empty and *found* is False do\n    Set *node* ← *stack*.pop()\n    Add *node* to *explored*\n    For *child* in *node*.expand() do\n        If *child* is not in *explored* and *child* is not in *stack* then\n            If *child* is *destination* then\n               Update *route* ← *child*.route()\n               Update *found* ← True\n            Add *child* to *stack*\nReturn *route*\n```", "```py\nfrom optalgotools.algorithms.graph_search import DFS\n\ninit_state = [[1,4,2],[3,7,5],[6,0,8]]\ngoal_state = [[0,1,2],[3,4,5],[6,7,8]]\n\ninit_state = State(init_state)\ngoal_state = State(goal_state)\n\nif not init_state.is_solvable():                           ①\n     print(\"This puzzle is not solvable.\")\nelse:\n     solution = DFS(init_state, goal_state)                ②\n     print(f\"Process time: {solution.time} s\")\n     print(f\"Space required: {solution.space} bytes\")\n     print(f\"Explored states: {solution.explored}\")\n     print(f\"Number of steps: {len(solution.result)}\")\n```", "```py\nProcess time: 0.5247 s\nSpace required: 624 bytes\nExplored states: 29\nNumber of steps: 30\n```", "```py\nInputs: A graph with weighted edges and a source node\nOutput: Shortest path from the source to all other nodes in the graph\n\nInitialize *shortest_dist* ← empty\nInitialize *unrelaxed_nodes* ← empty\nInitialize *seen* ← empty\n\nFor *node* in *graph*\n    Set *shortest_dist[node]* = Infinity\n    Add *node* to *unrelaxed_nodes*\n    Set *shortest_dist[source]* ← 0\n\nWhile *unrelaxed_nodes* is not empty do\n    Set *node* ← *unrelaxed_nodes*.pop()\n    Add *node* to *seen*\n    For *child* in *node*.expand() do\n        If *child* in *seen* then skip\n        Update *distance* ← *shortest_dist[node]* + length of edge to *child*\n        If *distance* < *shortest_dist[child]* then\n           Update *shortest_dist[child]* ← *distance*\n           Update *child.parent* ← node\nReturn *shortest_dist*\n```", "```py\nInputs: A graph with edges, a source node, a destination node\nOutput: Shortest path from source to destination in the graph\n\nInitialize *priority_queue* ← *source*\nInitialize *found* ← False\nInitialize *seen* ← *source*\n\nWhile *priority_queue* is not empty and *found* is False do\n    Set *node* ← priority_queue.pop()\n    Update *seen* ← *node*\n    Update node_cost ← cumulative distance from source\n    If *node* is *destination* then\n        Update *route* ← *node*.route()\n        Update *found* ← True\n    For child in node.expand() do\n        If child in priority_queue then\n            If child.priority < priority_queue[child].priority then\n               Set priority_queue[child].priority = child.priority\n        Else\n            Update priority_queue ← child\n        Update priority_queue[child].priority ← node_cost\nReturn route\n```", "```py\nInputs: A graph, a source node, a destination node\nOutput: Shortest path from source to destination in the graph\n\nInitialize *frontier_f* ← initialized with source\nInitialize *frontier_b* ← initialized with destination\nInitialize *explored_f* ← empty\nInitialize *explored_b* ← empty\nInitialize *found* ← False\nInitialize *collide* ← False\nInitialize *altr_expand* ← False\n\nWhile *frontier_f* is not empty and *frontier_b* is not empty and not *collide* and not *found* do\n    If altr_expand then\n        Set node ← frontier_f.pop()\n        Add node to explored_f\n        For child in node.expand() do\n            If child in explored_f then continue\n            If child is destination then\n                Update route ← child.route()\n                Update found ← True\n            If child in explored_b then\n                Update route ← child.route() + reverse(overlapped.route())\n                Update collide ← True\n            Add child to frontier_f\n        Update altr_expand ← not altr_expand\n    Else\n        Update node ← frontier_b.pop()\n        Add node to explored_b\n        For child in node.expand() do\n            If child in explored_b then continue\n            If child is origin then\n               Update route ← child.route()\n               Update found ← True\n            If child in explored_f then\n               Update route ← reverse(child.route()) + overlapped.route()\n               Update collide ← True\n            Add child to frontier_b\n        Update altr_expand ← not altr_expand\nReturn route\n```"]