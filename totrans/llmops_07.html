<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Evaluation for LLMs"><div class="chapter" id="ch07_evaluation_for_llms_1748896751667823">
<h1><span class="label">Chapter 7. </span>Evaluation for LLMs</h1>

<p>Language<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="evaluating" data-type="indexterm" id="icd701"/><a contenteditable="false" data-primary="evaluation" data-type="indexterm" id="icd702"/> models have become increasingly sophisticated, but assessing their effectiveness accurately remains a significant challenge.</p>

<p>The importance of LLM evaluation has garnered attention not only from academia but also from industry stakeholders. This convergence of research and testing efforts signifies the importance of the problem and the collective determination to find effective solutions. It also accelerates the pace of innovation, helping researchers understand and improve these models further.</p>

<p>In academia, researchers have been exploring new methodologies, developing innovative metrics, and conducting rigorous experiments to push the boundaries of LLM evaluation Although there are some leading contenders, there are no clear winners yet, since many metrics and scoreboards end up being useful for just a short period or for a narrow set of applications. Regardless, industry players are keenly aware of the practical implications of LLM performance.</p>

<p>At its core, evaluation aims to gauge how well an LLM accomplishes its intended purpose, whether it’s generating coherent and contextually relevant text, understanding user input, or completing specific tasks. In this chapter, you’ll learn about a systematic framework designed to tackle this challenge for different applications, along with some tips on what has worked.</p>

<section data-type="sect1" data-pdf-bookmark="Why Evaluation Is a Hard Problem"><div class="sect1" id="ch07_why_evaluation_is_a_hard_problem_1748896751668070">
<h1>Why Evaluation Is a Hard Problem</h1>

<p><em>Evaluating</em> LLMs<a contenteditable="false" data-primary="evaluation" data-secondary="difficulty of" data-type="indexterm" id="icd706"/> is the process of assessing their performance and capabilities. It involves a combination of methods to determine how well an LLM achieves its intended purpose and adheres to ethical guidelines.</p>

<p>Developing and deploying ML<a contenteditable="false" data-primary="ML (machine learning)" data-secondary="testing and evaluation" data-type="indexterm" id="icd703x"/> solutions requires creating new types of testing and evaluation than those used in traditional software development. In particular, ML models use random numbers during training and need to be tested in aggregate across datasets, as well as on specific atomic pieces of data that can help validate that the training worked correctly. However, once the models are trained, most ML models are deterministic in that they don’t use random methods to make inferences; i.e., that the same inputs will always produce the same outputs.</p>

<p>In contrast, LLMs use random numbers during training and making inferences, so the same input can produce different outputs even if there have been no changes in the model. Several other assumptions no longer hold or need to be augmented. This chapter will explore several open questions around datasets, metrics, and methodology selection.</p>

<p>Any operational ML solution must provide some expected performance characteristics before going into production. You also need a way to monitor it effectively to identify and fix any performance problems after deployment. Model evaluation helps:</p>

<ul>
	<li>
	<p>Ensure that the model is performing as expected</p>
	</li>
	<li>
	<p>Identify areas where the model can be improved</p>
	</li>
	<li>
	<p>Ensure that the model is being used safely and responsibly</p>
	</li>
</ul>

<p>Why is evaluating LLMs so hard? There are several reasons:</p>

<ul>
	<li>
	<p>First, human language is very complex and can be difficult to quantify. This makes it difficult to develop accurate quality evaluation metrics.</p>
	</li>
	<li>
	<p>Language models are typically trained on large datasets of text. This makes it difficult to find a representative sample of text that the model has never seen before to use for evaluation.</p>
	</li>
	<li>
	<p>Language models can exhibit bias in line with the datasets they are trained on, generating text that violates social, ethical, or legal norms.</p>
	</li>
</ul>

<p>The difficulty of interpreting why LLMs generate particular outputs can lead to challenges around reproducibility and consistent experimental design.</p>

<p>LLMs are trained on massive amounts of data, and the number of possible inputs they can receive is practically infinite, so it’s impossible to exhaustively test them on every scenario. Evaluating even a tiny fraction of possibilities is a monumental task. Therefore, we must content ourselves with evaluating categories of scenarios, such as:</p>

<ul>
	<li>
	<p>Informativeness and factuality</p>

	<ul>
		<li>
		<p>Is the output factually correct?</p>
		</li>
		<li>
		<p>Does the output contain sufficient information relevant to the input prompt?</p>
		</li>
		<li>
		<p>Is the generated text a complete response to the input?</p>
		</li>
	</ul>
	</li>
	<li>
	<p>Fluency and coherence</p>

	<ul>
		<li>
		<p>Are the outputs grammatically correct and readable?</p>
		</li>
		<li>
		<p>Do they follow a logical flow?</p>
		</li>
		<li>
		<p>Is the output language at an appropriate level?</p>
		</li>
	</ul>
	</li>
	<li>
	<p>Engagement and style</p>

	<ul>
		<li>
		<p>How engaging and interesting are the LLM’s outputs?</p>
		</li>
		<li>
		<p>Is the writing style appropriate?</p>
		</li>
	</ul>
	</li>
	<li>
	<p>Safety and <a contenteditable="false" data-primary="bias" data-secondary="evaluating as category" data-type="indexterm" id="id1064"/>bias</p>

	<ul>
		<li>
		<p>What harmful content could this LLM generate?</p>
		</li>
		<li>
		<p>Could the output be used to put people at risk?</p>
		</li>
		<li>
		<p>Is the output using biased concepts or language?</p>
		</li>
	</ul>
	</li>
	<li>
	<p>Grounding</p>

	<ul>
		<li>
		<p>How well grounded is the LLM’s response in real-world information?</p>
		</li>
		<li>
		<p>Does it offer appropriate references?</p>
		</li>
		<li>
		<p>Does it avoid hallucinations?</p>
		</li>
	</ul>
	</li>
	<li>
	<p>Efficiency</p>

	<ul>
		<li>
		<p>What computational resources does the LLM require to generate outputs?</p>
		</li>
		<li>
		<p>How long does it take to start generating the response?</p>
		</li>
		<li>
		<p>How long does it take to generate a complete response?</p>
		</li>
	</ul>
	</li>
</ul>

<p>While there are clear success metrics for some types of tasks (e.g., accuracy in image recognition: “Is this a picture of a bird?”), what constitutes a “good” response from an LLM can be subjective. Does the output provide relevant information? Is it creative? Is it factually accurate? These goals can conflict, making it hard to design a single metric that captures everything. “Good performance” can mean several things.</p>

<p>Another difference between evaluating ML and LLM models is that when an ML model fails an evaluation task, the developing team usually turns<a contenteditable="false" data-primary="interpretability" data-type="indexterm" id="id1065"/> to <em>interpretability </em>tools that explain why the model made decisions. Such tools try to understand the internal mechanisms of models by running an extremely large number of examples through a model and measuring how changes in the input influence the output. Since most ML models are deterministic (the same input will always provide the same <span class="keep-together">output),</span> these tools allow developers to understand what parts of the input are important for generating some outputs, essentially improving their understanding of how the model works internally. <a contenteditable="false" data-primary="ML (machine learning)" data-secondary="testing and evaluation" data-startref="icd703x" data-type="indexterm" id="id1066"/>​As of today, interpretability tools are unavailable for LLMs because LLMs have too many parameters and are nondeterministic; thus, an immense quantity of examples and computation time would be needed to understand their internal <a contenteditable="false" data-primary="evaluation" data-secondary="difficulty of" data-startref="icd706" data-type="indexterm" id="id1067"/>​workings.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Evaluating Performance"><div class="sect1" id="ch07_evaluating_performance_1748896751668148">
<h1>Evaluating Performance</h1>

<p>There<a contenteditable="false" data-primary="evaluation" data-secondary="metrics for" data-type="indexterm" id="icd703"/><a contenteditable="false" data-primary="metrics" data-type="indexterm" id="icd707"/> are a number of ways to evaluate and monitor the accuracy of LLM-based solutions during development and after deployment. <em>Manually checking</em> the output for accuracy and correctness can be time-consuming, and it depends on the judgment of evaluators. <em>Automatic evaluation</em> uses tools to evaluate the accuracy of the LLM’s output; essentially, you’re using LLMs to evaluate LLMs. <a contenteditable="false" data-primary="feedback loops" data-type="indexterm" id="id1068"/>User feedback is also helpful in identifying areas where the LLM is performing poorly and needs improvement.</p>

<p>Most importantly, you cannot evaluate an LLM without an application. In many LLM applications, users know which real-world performance metrics would be useful. For example, let’s say your company is using LLMs to generate text scripts for web advertisements. When humans write the advertising copy, a typical evaluation method is to perform an <em>A/B test</em>, <a contenteditable="false" data-primary="A/B testing" data-type="indexterm" id="id1069"/>randomly offering different options to similar audiences, A and B, and measuring the success rate (for example, number of ad clicks) of each audience. If the success rate for the audience receiving option A is different enough from that of option B to be statistically significant, the company would select option A as the more successful script. The same method can be used on LLM-generated copy. Indeed, for many common ML tasks, such as classifying text, identifying images, and counting objects, it makes sense to simply use the existing pre-LLM methods and metrics.</p>

<p>There are, however, some metrics that are specific to<a contenteditable="false" data-primary="NLP (natural language processing)" data-secondary="metrics for" data-type="indexterm" id="id1070"/> NLP and don’t require user involvement, making them less costly and good choices to evaluate LLMs.</p>

<p>Since a major part of what LLMs do is generate content, we use a set of metrics called<a contenteditable="false" data-primary="generative metrics" data-type="indexterm" id="id1071"/> <em>generative metrics</em> to measure the quality of the content generated. The most basic of these, called<a contenteditable="false" data-primary="n-gram-based metrics" data-type="indexterm" id="id1072"/> n<em>-gram-based metrics</em>, assess the similarity between generated text and existing data by examining the overlap of sequences of <em>n</em> words. To use this metric for an evaluation, you should know the expected “correct” answer, and you can compare how many of the <em>n</em> words generated by the LLM are in the correct answer.</p>

<p>For example, if <em>n</em> equals 1, the comparison looks at individual words; if <em>n</em> equals 2, it considers pairs of words; and so on. These metrics quantify the degree of similarity based on the shared <em>n</em>-grams, providing insights into the coherence and relevance of the generated text compared to the correct answer.</p>

<p>For example, one of your tests could be “Q: What’s the capital of France? A: Paris.” The <em>n</em>-gram test can be very simple and will work well when the LLM answers “Paris” (100% of the <em>n</em>-grams match) but won’t perform well when the LLM provides the correct answer “The capital of France is Paris.” Since you were expecting the answer to be Paris, only 16.6% of the words in the second answer match the correct answer, and you may think that the LLM is not performing as well as it really is.</p>

<p>Second<em>,<a contenteditable="false" data-primary="similarity-based metrics" data-type="indexterm" id="id1073"/> similarity-based metrics </em>aim to capture various aspects of similarity between generated text and a reference text. They<a contenteditable="false" data-primary="MoverScore" data-type="indexterm" id="id1074"/><a contenteditable="false" data-primary="SemScore" data-type="indexterm" id="id1075"/><a contenteditable="false" data-primary="BERTScore" data-type="indexterm" id="id1076"/> include:</p>

<dl>
	<dt>BERTScore</dt>
	<dd>
	<p>Measures both content overlap and fluency</p>
	</dd>
	<dt>SemScore</dt>
	<dd>
	<p>Checks that the generated text conveys the same meaning and intent as the reference text</p>
	</dd>
	<dt>MoverScore</dt>
	<dd>
	<p>Calculates the minimum amount of “work” required to transform one text into another</p>
	</dd>
</dl>

<p>These metrics compare how similar two whole sentences are by computing embeddings and comparing them. Using the same example as before, the LLM answers “It’s Paris” and “The capital of France is Paris” will both generate a high score, as both these sentences have similar meanings. One problem is that the sentence “Teh KaPiTaLL of Franceland is PARIS” will also score high in terms of meaning similarity, even though it’s full of spelling errors and uses the made-up word “Franceland.”</p>

<p>Therefore, we<a contenteditable="false" data-primary=" LLM-based metrics" data-seealso="metrics" data-type="indexterm" id="id1077"/> turn to <em>LLM-based metrics</em>, which use other LLMs to evaluate the target LLM’s generation quality and identify potential <a contenteditable="false" data-primary="hallucinations" data-type="indexterm" id="kab992"/>hallucinations. These metrics identify correct answers and can also evaluate fluency and grammatical correctness, but they are expensive to compute. Here are some popular metrics and the papers that define how to implement and use them:</p>

<dl>
	<dt><a href="https://oreil.ly/IzuUL">G-Eval</a></dt>
	<dd>
	<p>Scores<a contenteditable="false" data-primary="G-Eval" data-type="indexterm" id="id1078"/> the generated text based on its coherence, fluency, and factual consistency as judged by another LLM.</p>
	</dd>
	<dt><a href="https://oreil.ly/nMMsh">UniEval</a></dt>
	<dd>
	<p>Considers<a contenteditable="false" data-primary="UniEval" data-type="indexterm" id="id1079"/> multiple factors like fluency, grammaticality, and factual coherence through an ensemble of LLM evaluators.</p>
	</dd>
	<dt><a href="https://oreil.ly/ylJna">GPTScore</a></dt>
	<dd>
	<p>Designed<a contenteditable="false" data-primary="GPTScore" data-type="indexterm" id="id1080"/> specifically for GPT-like models, it uses an LLM to evaluate aspects like coherence, safety, and factual consistency.</p>
	</dd>
	<dt><a href="https://oreil.ly/UwZvJ">TRUE</a></dt>
	<dd>
	<p>Uses <a contenteditable="false" data-primary="TRUE" data-type="indexterm" id="id1081"/>other LLMs to assess factual correctness and identify potential factual <span class="keep-together">hallucinations.</span></p>
	</dd>
	<dt><a href="https://oreil.ly/8AKE9">SelfCheckGPT</a></dt>
	<dd>
	<p>Designed<a contenteditable="false" data-primary="SelfCheckGPT" data-type="indexterm" id="id1082"/> for GPT models, it focuses on identifying logical inconsistencies and factual errors in the generated text.</p>
	</dd>
</dl>

<p>These metrics are configurable to your specific use case. Although many provide example questions and expected answers in their papers, you should generate a question-and-answer database that is applicable to your use case.</p>

<p>There are also many general<a contenteditable="false" data-primary="benchmarks, for LLM performance" data-type="indexterm" id="icd701x"/> benchmarks for LLMs that have the goal of evaluating how well an LLM performs as a general problem-solver, without focusing on a specific task. These benchmarks tend to be more useful if you’re building a platform-level LLM, like Google’s <a contenteditable="false" data-primary="Google Gemini" data-type="indexterm" id="id1083"/><a contenteditable="false" data-primary="Gemini, Google" data-type="indexterm" id="id1084"/>Gemini or <a contenteditable="false" data-primary="OpenAI" data-secondary="ChatGPT" data-type="indexterm" id="id1085"/><a contenteditable="false" data-primary="ChatGPT" data-secondary="benchmarks" data-type="indexterm" id="id1086"/>OpenAI’s ChatGPT. Although such benchmark results are useful in some aspects and appear frequently in marketing materials that describe how good a model is, they suffer from an important drawback: they can’t tell how well a model will perform on a specific task. It’s possible that model A performs substantially better than model B in general tasks and therefore on a general benchmark like GLUE, but model B may perform better than model A in the tasks you need it to do; for example, analyzing legal documents. It is therefore important to understand these benchmarks for what they are: an aggregate score of general <span class="keep-together">applicability.</span></p>

<p>Some of the top benchmarks are listed in <a data-type="xref" href="#ch07_table_1_1748896751659531">Table 7-1</a>, but keep in mind that this is an active area of research, with new benchmarks being proposed all the<a contenteditable="false" data-primary="GLUE (General Language Understanding Evaluation)" data-type="indexterm" id="id1087"/><a contenteditable="false" data-primary="MMLU (Massive Multitask Language Understanding)" data-type="indexterm" id="id1088"/><a contenteditable="false" data-primary="Massive Multitask Language Understanding (MMLU)" data-type="indexterm" id="id1089"/><a contenteditable="false" data-primary="TruthfulQA" data-type="indexterm" id="id1090"/><a contenteditable="false" data-primary="HellaSwag" data-type="indexterm" id="id1091"/><a contenteditable="false" data-primary="SuperGLUE" data-type="indexterm" id="id1092"/><a contenteditable="false" data-primary="General Language Understanding Evaluation (GLUE)" data-type="indexterm" id="id1093"/> time.</p>

<table id="ch07_table_1_1748896751659531">
	<caption><span class="label">Table 7-1. </span>General LLM benchmarks</caption>
	<thead>
		<tr>
			<th>Benchmark</th>
			<th>Description</th>
			<th>Focus</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="subheading"><a href="https://oreil.ly/rcLR4">General Language Understanding Evaluation</a> (GLUE)</td>
			<td>
			<p>Suite of tasks assessing core NLP abilities</p>
			</td>
			<td>
			<p>Natural language understanding (NLU)</p>
			</td>
		</tr>
		<tr>
			<td class="subheading"><a href="https://oreil.ly/mpepc">SuperGLUE</a></td>
			<td>
			<p>Successor to GLUE, featuring more challenging tasks</p>
			</td>
			<td>
			<p>NLU</p>
			</td>
		</tr>
		<tr>
			<td class="subheading"><a href="https://oreil.ly/2VpX9">HellaSwag</a></td>
			<td>
			<p>Focuses on reasoning and commonsense understanding</p>
			</td>
			<td>
			<p>Natural language inference (NLI)</p>
			</td>
		</tr>
		<tr>
			<td class="subheading"><a href="https://oreil.ly/adQ-N">TruthfulQA</a></td>
			<td>
			<p>Evaluates factual correctness and avoidance of factual hallucinations</p>
			</td>
			<td>
			<p>Question qnswering (QA)</p>
			</td>
		</tr>
		<tr>
			<td class="subheading"><a data-primary="Massive Multitask Language Understanding (MMLU) benchmark" href="https://oreil.ly/0xT-x">Massive Multitask Language Understanding</a> (MMLU)</td>
			<td>
			<p>Large-scale benchmark on diverse tasks</p>
			</td>
			<td>
			<p>Multi-task learning</p>
			</td>
		</tr>
	</tbody>
</table>

<p>These benchmarks are public, and <a contenteditable="false" data-primary="hallucinations" data-startref="kab992" data-type="indexterm" id="id1094"/>so are their question-and-answer pairs. This allows different LLMs to be compared on the exact same criteria and therefore allows comparisons between LLMs.</p>

<p class="pagebreak-before">However, this creates a problem: LLM developers can train the model simply to perform well on the benchmarks, like a student memorizing the answers to an upcoming exam. This is a very serious problem in practice. It’s not uncommon to see an LLM perform well in general benchmarks, only to perform below the level of GPT-3.5 (a now-obsolete but inexpensive model) in a practical application, like describing a scene. When this happens, there’s usually little reason to use the model that has the higher general scores—your users should have the final word.</p>

<p>Another problem is that LLMs are highly sensitive to the compatibility of the data used in training and prompts used in evaluation. A seemingly minor change in the prompt can lead to drastically different outputs. This makes it difficult to design prompts that consistently elicit the desired response and assess the LLM’s true <span class="keep-together">capabilities.</span></p>

<p>For example, some models may respond better when asked to “think step-by-step” (<a href="https://oreil.ly/YIrYf">Wei et al., 2023</a>), while others might respond better when asked politely, with prompts starting with “please.” These are the results of training bias. In this example, if the portion of the training dataset that contained more polite instructions had a higher proportion of correct answers, simply adding “please” to all prompts will yield better results on benchmarks.</p>

<p>LLMs use another trick that students frequently use to improve their exam scores when they don’t know the answer to a question: they repeat or paraphrase parts of the question or prompt in their responses. This can create a false sense of understanding or agreement, making the text produced for the answer highly related to the question, even when the quality of the answer itself is low.</p>

<p>In summary, benchmarks can be useful to compare LLMs with other LLMs, but be aware of their limitations and use them with <a contenteditable="false" data-primary="benchmarks, for LLM performance" data-startref="icd701x" data-type="indexterm" id="id1095"/>​care.</p>

<p>Some applications of LLM are so common that they deserve special attention, like RAG and multi-agent systems. Although the metrics described here can be used to evaluate RAG and multi-agent systems, each of them has its own specific metrics, described in the next sections.</p>

<section data-type="sect2" data-pdf-bookmark="Evaluating What Breaks Before It Breaks Everything"><div class="sect2" id="new_pages_what_breaks">
<h2>Evaluating What Breaks Before It Breaks Everything</h2>

<p>When LLMs first entered production environments, their early failures appeared sporadic and unpredictable. These initial glitches were often dismissed as the model simply “acting weird,” a kind of random quirkiness rather than a systemic issue. However, as usage expanded and data accumulated, clearer, more consistent patterns of failure began to surface. These patterns are not traditional software bugs, like segmentation faults or crashes, but rather what we call failure modes (see <a data-type="xref" href="#table0702">Table 7-2</a>).</p>

<table id="table0702">
	<caption><span class="label">Table 7-2. </span>Common LLM failure modes and where evaluation can catch them</caption>
	<thead>
		<tr>
			<th>Failure mode</th>
			<th>Where to evaluate</th>
			<th>Tools/signals</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Hallucinations</td>
			<td>Retrieval, prompt, inference</td>
			<td>Similarity to source, factual checks</td>
		</tr>
		<tr>
			<td>Prompt regressions</td>
			<td>Orchestration</td>
			<td>Prompt diffing, quality degradation logs</td>
		</tr>
		<tr>
			<td>Latency spikes</td>
			<td>Inference, retrieval</td>
			<td>p95/p99 latency metrics, tracing</td>
		</tr>
		<tr>
			<td>Data drift</td>
			<td>Input, retrieval</td>
			<td>Embedding shifts, cluster distribution</td>
		</tr>
		<tr>
			<td>Inconsistent behavior</td>
			<td>Inference</td>
			<td>Session-level tracing, repeat queries</td>
		</tr>
		<tr>
			<td>Safety violations</td>
			<td>Output</td>
			<td>Toxicity filters, PII detection</td>
		</tr>
	</tbody>
</table>

<p><em>Failure modes</em> represent recurring but explainable breakdowns that arise due to a fundamental mismatch between the model’s internal assumptions and the complex realities of real-world data and interactions. Unlike conventional software errors that trigger exceptions or cause program crashes, failure modes are often “silent failures”. The system continues to operate normally on the surface, producing outputs that look syntactically valid and stylistically coherent. Yet beneath this veneer, these outputs can be factually incorrect, ethically problematic, or structurally flawed. This subtlety makes failure modes particularly insidious, as they evade detection by traditional debugging methods, which typically rely on outright crashes or obvious error signals.</p>

<p>Therefore, the evaluation paradigm for LLMs must evolve beyond reactive debugging toward a more proactive approach (see <a data-type="xref" href="#fig0701">Figure 7-1</a>). Instead of waiting for failures to disrupt users, the goal becomes to anticipate and detect these failure modes early, before they propagate harm or misinformation. This proactive detection requires sophisticated monitoring frameworks that combine automated metrics, human-in-the-loop validation, and domain-specific checks to identify when the model’s assumptions no longer hold, or when outputs deviate from expected behavior. By shifting evaluation from post-hoc fixes to continuous, anticipatory oversight, we can better ensure the reliability, safety, and ethical integrity of LLM deployments at scale.</p>

<figure class="width-90"><div id="fig0701" class="figure"><img src="assets/llmo_0701.png" width="1255" height="530"/>
<h6><span class="label">Figure 7-1. </span>Evaluating traditional ML models versus LLMs</h6>
</div></figure>

<p>Let us try to understand the most common failure modes in modern LLM pipelines and identify where observability and evaluation tools can intercept them early.</p>

<section data-type="sect3" data-pdf-bookmark="Hallucinations"><div class="sect3" id="new_pages_hallucinations">
<h3>Hallucinations</h3>

<p>Among the various failure modes LLMs exhibit, hallucinations stand out as the most infamous and challenging to manage. Hallucinations happen when an LLM produces responses that are linguistically fluent and confident, yet factually incorrect or completely fabricated. This phenomenon arises because LLMs generate text by predicting the most statistically likely token sequences based on their training data, rather than querying a reliable, up-to-date factual knowledge base. Therefore, hallucinations are an inherent risk, especially when LLMs are applied in high-stakes domains such as healthcare, finance, or legal services, where inaccurate or misleading information can lead to serious consequences.</p>

<p>Evaluating hallucinations extends beyond simply detecting isolated factual errors. Instead, it demands a systematic, longitudinal approach to pattern monitoring. This typically involves logging all generated outputs and, where possible, comparing them to verified ground truths. When exact ground-truth data isn’t accessible, one alternative strategy is conducting consistency checks across multiple generations of the model’s responses to detect contradictions or instability. These evaluation methods help identify individual hallucinations as well as the conditions and contexts in which they occur more frequently.</p>

<p>In RAG systems, hallucinations often signal problems in the retrieval component. For instance, if the retriever fetches irrelevant, outdated, or low-quality documents, the LLM is more likely to generate incorrect or fabricated content. This interdependence makes it important to maintain observability across both the retrieval and inference layers. Comprehensive monitoring frameworks that track the quality and relevance of retrieved documents alongside the model’s output can help diagnose whether hallucinations are stemming from retrieval failures, generative errors, or a combination of both. Understanding these root causes is essential for designing targeted mitigation strategies, such as improving retrieval accuracy, integrating more reliable knowledge sources, or incorporating verification mechanisms during generation.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Prompt regressions"><div class="sect3" id="new_pages_promt_regressions">
<h3>Prompt regressions</h3>

<p><em>Prompt regression</em> represents a particularly subtle yet deeply frustrating failure mode in LLM deployments. Unlike obvious output errors, prompt regressions arise from seemingly minor changes to the prompt templates, such as renaming variables, inserting or removing whitespace, or adjusting formatting, that unexpectedly degrade the quality of the model’s outputs. These degradations are often not immediately apparent, making them harder to detect and diagnose in real time.</p>

<p>The challenge is compounded by the inherent <a contenteditable="false" data-primary="nondeterministic/nondeterminism" data-type="indexterm" id="id1096"/>nondeterminism of LLMs: given the same input, the model may generate different outputs across runs, due to sampling methods and stochastic token prediction. This variability makes it difficult to reproduce prompt regressions consistently, posing a significant barrier to traditional debugging approaches.</p>

<p>To manage this complexity, robust evaluation systems must integrate detailed prompt versioning and logging capabilities. Tracking changes at a granular level is essential, as is supporting prompt diffs that highlight exactly what was modified between versions. By correlating these prompt changes with measurable metrics, such as declines in response helpfulness, factual accuracy, or structural coherence, teams can precisely pinpoint when and how regressions begin to manifest.</p>

<p>This systematic correlation enables effective root-cause analysis, allowing developers to identify the problematic prompt iterations swiftly. More importantly, it empowers teams to roll back to previously stable prompt versions when they detect regressions, preserving output quality and user trust. In this way, prompt-regression monitoring becomes part of a proactive evaluation strategy to ensure that subtle prompt-engineering tweaks don’t unintentionally erode model performance or reliability over time.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Latency spikes"><div class="sect3" id="new_pages_latency_spikes">
<h3>Latency spikes</h3>

<p>Regardless of a system’s intelligence or sophistication, users uniformly reject slow and unresponsive experiences. Latency, especially spikes occurring at the high end of the distribution, such as the 95th (p95) or 99th percentiles (p99) is particularly damaging. These tail latencies, though rare in frequency, disproportionately impact user experience by causing noticeable delays and, in some cases, triggering downstream timeouts or failures in interconnected systems.</p>

<p>Effective evaluation of latency requires continuous, fine-grained monitoring that tracks not only average response times but also token usage patterns and relevant system-level metrics. This comprehensive observability is important for detecting abrupt increases in latency early, before they degrade service quality at scale.</p>

<p>When such latency spikes occur, robust tracing mechanisms become indispensable for root cause analysis. These tools enable engineers to dissect the request pipeline and identify bottlenecks or failure points. Potential culprits may include excessively long input prompts that increase processing time, delays within retrieval components responsible for fetching relevant documents, or bottlenecks in upstream dependencies, such as vector databases or external APIs. Additionally, changes to the underlying model version or system infrastructure can introduce unexpected latency regressions.</p>

<p>Without this level of observability, latency spikes remain invisible to monitoring dashboards and alerting systems until end users experience degraded performance or failures. Therefore, embedding end-to-end tracing and real-time latency monitoring into the evaluation workflow is essential for maintaining smooth, predictable system behavior and ensuring a consistently responsive user experience.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Data drift"><div class="sect3" id="new_pages_data_drift">
<h3>Data drift</h3>

<p>In live production environments, user behavior and input data are in a state of continuous flux. This dynamic landscape often leads to data drift, a phenomenon where the foundational assumptions embedded in a system–such as expected input formats, distributions of user intents, or the nature of contextual embeddings–gradually diverge from the evolving reality of incoming data.</p>

<p>Data drift manifests in several distinct ways. Input drift typically shows up as an increase in adversarial or malformed queries that deviate from the original training or design expectations. This can stress the system’s robustness and degrade output quality. Retriever drift occurs when the relevance of the documents returned by retrieval components declines, even if the retrieval algorithms and configurations remain unchanged. Similarly, embedding drift arises when the vector representations used to compare semantic similarity become less effective, causing retrieval systems to fail despite stable system parameters.</p>

<p>Effectively evaluating drift demands rigorous statistical monitoring of input feature distributions over time. Techniques include cluster analyses of query types to detect emerging user intents or new patterns of interaction, histograms of token lengths to track shifts in input verbosity, and continuous measurement of embedding similarity scores to catch subtle shifts in semantic representation. These quantitative early-warning signals allow engineering teams to anticipate when the system’s assumptions will no longer hold.</p>

<p>By proactively detecting drift, teams gain the opportunity to retrain models, refresh retrieval indexes, and redesign prompt templates before any degradation becomes noticeable to end users. This anticipatory approach ensures that the system adapts seamlessly to evolving data landscapes, maintaining both accuracy and user satisfaction over time.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Inconsistent behavior"><div class="sect3" id="new_pages_inconsistent">
<h3>Inconsistent behavior</h3>

<p>The inherently stochastic nature of LLM generation means that repeating the exact same query multiple times can yield different responses on each occasion, a phenomenon called <a contenteditable="false" data-primary="nondeterministic/nondeterminism" data-type="indexterm" id="id1097"/>nondeterminism. This variability is a natural consequence of probabilistic token sampling strategies, which promote diversity and creativity in generated text. However, this randomness presents a fundamental challenge for use cases where auditability, compliance, and reproducibility are critical. In such contexts, inconsistent outputs can undermine trust, complicate debugging, and even violate regulatory requirements.</p>

<p>Evaluating and managing inconsistent behavior requires a session-level tracing framework that goes beyond simply logging inputs and outputs. It must capture rich contextual metadata alongside each interaction, including model hyperparameters like temperature and top-k sampling values, specific model versions, and any relevant prior conversation history or user interactions. This comprehensive trace allows teams to reconstruct and analyze the exact environment and conditions that produced a given output.</p>

<p>With detailed session-level logs (see <a data-type="xref" href="#fig0702">Figure 7-2</a>), it becomes possible to identify patterns of variability, correlate output inconsistencies with particular settings or context changes, and enforce reproducibility where necessary by fixing sampling parameters or replaying interaction sequences. This granular level of evaluation is essential for deploying LLMs responsibly in sensitive domains where predictable, verifiable behavior is nonnegotiable.</p>

<figure><div id="fig0702" class="figure"><img src="assets/llmo_0702.png" width="758" height="640"/>
<h6><span class="label">Figure 7-2. </span>Logging styles vary in scope, from isolated events to full sessions</h6>
</div></figure>

<p>Consistency can be enforced selectively, using deterministic decoding strategies like greedy or beam search, although this typically sacrifices output diversity. The key is balancing consistency where required and building monitoring systems that highlight inconsistency when it matters.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Ethical and compliance risks"><div class="sect3" id="new_pages_risks">
<h3>Ethical and compliance risks</h3>

<p>LLMs can inadvertently produce toxic content or biased language, leak private information, or be vulnerable to jailbreak prompts. These risks carry serious legal and reputational consequences. To mitigate them, evaluation tools must integrate automated filters and classifiers that flag problematic outputs in real time, as we discussed earlier in the chapter. Metrics such as safety scores, toxicity indices, and bias measurements should be collected alongside model metadata for auditing purposes.</p>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Metrics for RAG Applications"><div class="sect2" id="ch07_metrics_for_rag_applications_1748896751668215">
<h2>Metrics for RAG Applications</h2>

<p>A <a contenteditable="false" data-primary="evaluation" data-secondary="metrics for" data-tertiary="RAG applications" data-type="indexterm" id="icd704"/><a contenteditable="false" data-primary="metrics" data-secondary="RAG applications" data-type="indexterm" id="icd708"/><a contenteditable="false" data-primary="RAG (retrieval-augmented generation)" data-secondary="metrics" data-type="indexterm" id="icd708a"/>RAG application uses an LLM to generate text, but it helps the LLM be more precise by retrieving data from a knowledge base and appending that data to the user prompt. RAG applications go through the steps <a contenteditable="false" data-primary="workflows" data-secondary="RAG" data-type="indexterm" id="id1098"/>shown<a contenteditable="false" data-primary="RAG (retrieval-augmented generation)" data-secondary="application workflow" data-type="indexterm" id="id1099"/> in <a data-type="xref" href="#ch07_figure_1_1748896751654685">Figure 7-3</a>.</p>

<figure><div id="ch07_figure_1_1748896751654685" class="figure"><img src="assets/llmo_0703.png" width="1435" height="190"/>
<h6><span class="label">Figure 7-3. </span>RAG application workflow</h6>
</div></figure>

<p>Let’s look at each step in more detail:</p>

<dl>
	<dt>User input</dt>
	<dd>
	<p>The user submits a question or prompt to the RAG application.</p>
	</dd>
	<dt>Retrieval</dt>
	<dd>
	<p>The application utilizes a retrieval system to search a database of relevant documents or text data, such as <em>n</em> articles, manuals, code snippets, or any other information relevant to the LLM’s domain. The retrieval system identifies the most relevant portions of the data based on the user’s query, using techniques like vector similarity search.</p>
	</dd>
	<dt>Prompt augmentation</dt>
	<dd>
	<p>The application concatenates a developer-crafted prompt with the retrieved text from the previous step and the original user input.</p>
	</dd>
	<dt>LLM generation</dt>
	<dd>
	<p>The augmented prompt is then sent to the LLM, which uses the additional context it provides to generate a response and present it to the user.</p>
	</dd>
</dl>

<p>In addition to the generation metrics described in the previous section, RAGs can benefit from retrieval metrics that assess the effectiveness of the retrieval component. Some key retrieval metrics include:</p>

<dl>
	<dt>Recall</dt>
	<dd>
	<p>This<a contenteditable="false" data-primary="recall (sensitivity; true positive rate)" data-type="indexterm" id="id1100"/><a contenteditable="false" data-primary="sensitivity (recall; true positive rate)" data-type="indexterm" id="id1101"/><a contenteditable="false" data-primary="true positive rate (recall; sensitivity)" data-type="indexterm" id="id1102"/> measures how thoroughly the system gathers the material that really matters. To compute it, you start with a “ground-truth” collection of documents that experts have already judged relevant to a query. When the retrieval step runs, you look at the overlap between this authoritative set and the documents the system produced. If the engine surfaces almost every item the experts identified, recall is considered high; if it misses many of them, recall is low. You can measure the result as a percentage.</p>
	</dd>
	<dt>Mean reciprocal rank (MRR)</dt>
	<dd>
	<p>This<a contenteditable="false" data-primary="MRR (mean reciprocal rank)" data-type="indexterm" id="id1103"/><a contenteditable="false" data-primary="mean reciprocal rank (MRR)" data-type="indexterm" id="id1104"/> measures how quickly a user sees the first genuinely useful result. For each query, scan the ranked list from the top until you encounter the first relevant document and note its position. A document in the first slot is ideal, one in the fifth slot is less impressive, and so on. You then convert those positions into scores that reward early appearance and average the scores across many queries. A high MRR means that users usually encounter something relevant right at or near the top of the page. Although you can use whatever scoring mechanism you want, a typical way to score a search that retrieves <em>n</em> documents is to assign <em>n</em> points if a correct answer comes in the first position, <em>n</em> – 1 if it comes in the second position, and so on.</p>
	</dd>
	<dt>Mean average precision (MAP)</dt>
	<dd>
	<p>This<a contenteditable="false" data-primary="MAP (mean average precision)" data-type="indexterm" id="id1105"/><a contenteditable="false" data-primary="mean average precision (MAP)" data-type="indexterm" id="id1106"/> evaluates both the placement and consistency of relevant items throughout the list. Working down through the results for a single query, you keep a running tally so that every time another relevant document appears, you check what fraction of everything seen so far is relevant. When you finish the list, you average those interim fractions to summarize that one query. For example, if your retrieval step is expected to return three results and the three results returned are relevant, the average precision is 100%. If the first and second results are relevant, the AP is (100% + 100% + 0%) / 3 = 67%. If the first and third results are relevant, the AP is (100% + 0% + 67%) / 3 = 56%. Repeating the process for many queries and averaging again yields MAP. For example, the MAP of the last two queries is (67%+ 56%) / 2 = 61%. A high value indicates that relevant documents show up frequently and are distributed toward the top of the result rather than being scattered sparsely or bunched near the bottom.</p>
	</dd>
	<dt>Context precision</dt>
	<dd>
	<p>This<a contenteditable="false" data-primary="context precision" data-type="indexterm" id="id1107"/> metric looks at the flip side of recall; i.e., given everything the retriever returned, how much of it is genuinely helpful? You inspect each passage to decide whether it supports the language model’s task or merely adds noise. When the bulk of retrieved results match the ground-truth collection of documents, context precision is high; when irrelevant or misleading passages dominate, the score drops. You can measure context precision as a percentage.</p>
	</dd>
	<dt>Relevance</dt>
	<dd>
	<p>This<a contenteditable="false" data-primary="relevance" data-type="indexterm" id="id1108"/> approach provides a balance between precision and recall. It considers both how completely the retrieved set covers the needed facts and how free it is of extraneous material. High relevance means the context supplied to the language model simultaneously contains nearly all critical information and avoids clutter, thereby giving the model an ideal foundation for an accurate, focused response. Although you can calculate relevance by taking the simple average (or even the sum) of precision and recall, practitioners typically take the harmonic mean of precision and recall (this is called the F1-score), which makes balanced results like 60% precision and 60% recall score higher than unbalanced results like 90% precision and 30% recall.</p>
	</dd>
</dl>

<p>While you can measure each of these metrics on your own, in practice you’re likely to use an evaluation tool. Most evaluation tools can measure both the retrieval metrics just described and the generation metrics described in the previous section. For simple applications, you can<a contenteditable="false" data-primary="Ragas" data-type="indexterm" id="id1109"/> use an <a href="https://oreil.ly/QUyLl">existing framework</a> like <a href="https://oreil.ly/JkFwY">Ragas</a> that provides prebuilt functionality and streamlined workflow. Ragas is a Python-based application that contains all the previous metrics and can measure the outputs of your application and summarize the results in a single score. Ragas is also designed to be user-friendly, with clear documentation and examples. This makes it easier for researchers and developers, even those without extensive coding experience, to evaluate their RAG systems.</p>

<p>For most production applications, you will need a customizable evaluator that allows you to define your own metrics, add your own datasets, and integrate tests with your CI/CD tools; for example, by automatically running a set of tests after a new model version is deployed. One popular<a contenteditable="false" data-primary=" LangSmith" data-type="indexterm" id="id1110"/> open source tool to perform these tasks is the <a href="https://oreil.ly/F8EVF">LangSmith</a> toolset, created by the makers of <a contenteditable="false" data-primary="LangChain" data-type="indexterm" id="id1111"/>LangChain.</p>

<p>To perform evaluations in LangSmith, you first define a dataset of test cases and one or more evaluators. For each evaluator, you can define a metric (such as the metrics in this chapter) or a rubric that explains, in English, how to score answers. You can use the LangSmith programming interface to connect the output of your LLM to the evaluator and automatically score it.</p>

<p>Because LangSmith offers an SDK, you can run the tests during development, but you can also run the tests whenever you deploy a new model. You do this by creating a script that sends prompts to the new model and uses LangSmith to evaluate the answers as soon as the model is deployed by your CI/CD tool.</p>

<p>You can also use the SDK to create a script that periodically runs a test in production using a fixed dataset to see whether a model is<a contenteditable="false" data-primary="drift" data-type="indexterm" id="id1112"/> <em>drifting</em>; that is, whether the model’s performance is changing over time. In general, you would expect that running the same test over the same dataset would have the same score, but if you’re using an LLM service like <a contenteditable="false" data-primary="OpenAI" data-secondary="GPT series" data-type="indexterm" id="id1113"/><a contenteditable="false" data-primary="GPT (generative pretrained transformer) series" data-type="indexterm" id="id1114"/><a contenteditable="false" data-primary="generative pretrained transformer (GPT) series" data-type="indexterm" id="id1115"/>OpenAI’s GPT API or <a contenteditable="false" data-primary="Google Gemini" data-type="indexterm" id="id1116"/><a contenteditable="false" data-primary="Gemini, Google" data-type="indexterm" id="id1117"/>Google’s Gemini API, the underlying model can change outside of your control. This is called<a contenteditable="false" data-primary="model drift" data-type="indexterm" id="id1118"/> <em>model drift</em> and is explained in more detail at the end of this chapter. In any case, running a periodic test as described here will let you detect model <a contenteditable="false" data-primary="evaluation" data-secondary="metrics for" data-startref="icd704" data-tertiary="RAG applications" data-type="indexterm" id="id1119"/><a contenteditable="false" data-primary="metrics" data-secondary="RAG applications" data-startref="icd708" data-type="indexterm" id="id1120"/><a contenteditable="false" data-primary="RAG (retrieval-augmented generation)" data-secondary="metrics" data-startref="icd708a" data-type="indexterm" id="id1121"/>drift.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Metrics for Agentic Systems"><div class="sect2" id="ch07_metrics_for_agentic_systems_1748896751668272">
<h2>Metrics for Agentic Systems</h2>

<p>In <a contenteditable="false" data-primary="evaluation" data-secondary="metrics for" data-tertiary="agentic systems" data-type="indexterm" id="icd705"/><a contenteditable="false" data-primary="metrics" data-secondary="agentic systems" data-type="indexterm" id="icd709"/><a contenteditable="false" data-primary="agentic systems" data-secondary="metrics" data-type="indexterm" id="icd709a"/>late 2024, the term <em>agentic system</em> started to become more popular. In the context of LLMs, an agentic system is an AI system with several internal modules and multiple steps that can autonomously plan, decide, and act to pursue high-level goals with only strategic human oversight. In an agentic system, the user sends a request to a coordinating LLM that breaks the requests into tasks. The coordinating LLM then sends each task to itself, to other LLMs, or to specialist programs. It compiles their responses and provides the compilation to the user. This multistep process generates a myriad of evaluation issues.</p>

<p>All the metrics defined earlier in this chapter still apply; thus, if one of the components of the agentic system is a RAG system, you can use the RAG metrics, and for content-generating LLMs, you can use the generative metrics defined toward the beginning of this chapter. There are, however, additional complexities:</p>

<dl>
	<dt>Dynamic behavior</dt>
	<dd>
	<p>Agents can exhibit emergent behaviors based on their interactions, making it hard to predict outcomes or when these behaviors will occur.</p>
	</dd>
	<dt>Context sensitivity</dt>
	<dd>
	<p>The performance of agents can vary significantly based on context, requiring extensive testing across different scenarios.</p>
	</dd>
	<dt>Continuous learning</dt>
	<dd>
	<p>Many LLMs and agents adapt over time based on interactions, making static evaluations less relevant.</p>
	</dd>
	<dt>Feedback loops</dt>
	<dd>
	<p>The presence of <a contenteditable="false" data-primary="feedback loops" data-type="indexterm" id="kab999"/>feedback loops between agents can create nonlinear effects that are hard to replicate.</p>
	</dd>
	<dt>Integration with existing systems</dt>
	<dd>
	<p>Deploying agents in real-world environments can reveal unforeseen issues that aren’t present in simulated settings.</p>
	</dd>
	<dt>Environmental variability</dt>
	<dd>
	<p>Changes in the operational environment can lead to unexpected behaviors, complicating the evaluation process.</p>
	</dd>
	<dt>Multiple goals</dt>
	<dd>
	<p>Agents may have conflicting objectives or collaborate in ways that require balancing multiple criteria, complicating evaluation metrics. Sometimes two agents have poor metrics individually but collaborate well and generate output that is better than would be produced by collaboration between two different agents with better individual metrics.</p>
	</dd>
</dl>

<p>In practice, it’s easier to evaluate the end product of the agentic collaboration. Therefore, the two main ways of evaluating agentic systems are human evaluators and LLM evaluators. While human evaluation is considered the gold standard, it can be expensive and time-consuming. On the other hand, using LLMs as evaluators often strikes a good balance among cost, quality, and effectiveness, but it can occasionally be biased. Two other problems are that LLMs are opaque and resource intensive. If you use an LLM evaluator, don’t be completely hands-off. An LLM evaluating a model can start to perform poorly, so it’s advisable to have some level of human double-checking. Additionally, there is no universally accepted set of metrics for evaluating agentic systems, leading to inconsistencies.</p>

<p>Also, resource constraints (on computational power and memory, for example) limit how much evaluation one can do. Resource consumption may vary widely for different configurations, affecting scalability assessments.</p>

<p>For any LLM-based agentic system there<a contenteditable="false" data-primary="agentic systems" data-secondary="evaluation of" data-type="indexterm" id="id1122"/> are four key evaluation objectives:</p>

<dl>
	<dt>Examine its internal properties.</dt>
	<dd>
	<p>This means looking at its core language skills, how well it grasps context, whether it can learn and transfer knowledge, and how readily unexpected abilities (emergent behaviors) appear. You also ask how quickly it adapts to new environments or tasks and how effectively multiple agents cooperate. Evidence comes from coherence and relevance in answers, comprehension during live interactions, decision-making in controlled scenarios, and responsiveness when the situation changes. Logs and simulations reveal collective behaviors, while longitudinal testing shows whether performance improves, plateaus, or degrades over time. To measure performance, you can use the metrics defined previously.</p>
	</dd>
	<dt>Audit performance at the engineering level.</dt>
	<dd>
	<p>You<a contenteditable="false" data-primary="audits, for performance" data-type="indexterm" id="id1123"/> care about efficiency, scalability, and robustness when things go wrong. Measure the computational resources used to fulfill tasks. Stress tests show what happens as you scale up the number of agents or workloads, and fault injection experiments probe resilience and recovery strategies under adverse conditions.</p>
	</dd>
	<dt>Focus on the quality of interaction.</dt>
	<dd>
	<p>Here you want to know how engaging, clear, and trustworthy the dialogue feels to human users. Metrics such as session length, turn-taking frequency, and response latency quantify engagement, while surveys probe perceived reliability, conversational coherence, and relationship warmth. Observational studies of real-world use round out the picture by documenting how users actually behave around the agent.</p>
	</dd>
	<dt>Measure user satisfaction.</dt>
	<dd>
	<p>Ultimately, people must feel the system helps them accomplish their goals, and it should leave them with a positive emotional impression. You can capture explicit feedback on task success (like a thumbs-up or thumbs-down after each response), run sentiment analysis on user comments, and conduct surveys that gauge both moment-to-moment emotions and overall approval.</p>
	</dd>
</dl>

<p>One typical way to measure success is to calculate the net promoter score (NPS) by asking users “How likely are you to recommend the system for a task?” and give a score between 0 and 10 inclusive. Users who give a score of 9 or 10 are considered <em>promoters</em>, and users who give scores between 0 and 6 are considered <em>detractors</em>. The NPS is calculated as % Promoters – % Detractors. It can range from +100 (every user is a promoter) to –100 (every user is a detractor). Scores above +30 indicate strong performance.</p>

<p>Together, these four perspectives—system properties, technical performance, interaction quality, and user satisfaction—provide a holistic, complementary view of how well an agentic LLM system actually works in practice.</p>

<p>Given the complexity of measuring agentic systems, practitioners usually use different measurement strategies at different steps of the system-development process. If you were to break the development of an agentic system down into three steps, then model development and training, deployment, and production monitoring would be the different metrics that are most important at each stage.</p>

<section data-type="sect3" data-pdf-bookmark="Stage 1: Model development and training and integration into the agentic system"><div class="sect3" id="ch07_stage_1_model_development_and_training_and_integr_1748896751668329">
<h3>Stage 1: Model development and training and integration into the agentic system</h3>

<p>While the model is still in the lab, focus on <em>intrinsic capabilities</em>:</p>

<dl>
	<dt>Language abilities</dt>
	<dd>
	<p>Track response coherence and end-user comprehension. You can use the generative metrics and the associated tools described in this chapter.</p>
	</dd>
	<dt>Integration</dt>
	<dd>
	<p>Measure how each component of the agentic system is used when a user request comes in. Test whether the appropriate agents are involved in the tasks. For example, if you have a program that performs math (a calculator agent) that should be called by your orchestrating LLM when the user enters a math question, ensure that this is what actually happens. If it isn’t, you may need to adjust your orchestrating prompt.</p>
	</dd>
</dl>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Stage 2: Agentic system deployment"><div class="sect3" id="ch07_stage_2_agentic_system_deployment_1748896751668378">
<h3>Stage 2: Agentic system deployment</h3>

<p>With a trained model checkpoint in hand, you now ask, “Will people trust this system and find it useful?”</p>

<dl>
	<dt>Trust and reliability</dt>
	<dd>
	<p>Use survey-based internal user trust scores. The NPS metric defined previously is a good indicator of whether users like the system and find it useful.</p>
	</dd>
	<dt>User–agent relationship</dt>
	<dd>
	<p>Long-form user interviews and quick user satisfaction polls can tell you how test users feel about the system.</p>
	</dd>
	<dt>Overall satisfaction and perceived effectiveness</dt>
	<dd>
	<p>A/B tasks, success rate tallies, and sentiment analysis of open-text feedback provide ground truth.</p>
	</dd>
</dl>

<p>Built-in survey widgets make it easy to collect this data in a controlled sandbox before you expose the system to real customers.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Stage 3: Production"><div class="sect3" id="ch07_stage_3_production_1748896751668424">
<h3>Stage 3: Production</h3>

<p>At scale, you watch for higher-order phenomena and operational health:</p>

<dl>
	<dt>Agent component utilization</dt>
	<dd>
	<p>Check whether component agents are being used as you expected. You may have created several specialist agents in anticipation of user workloads, but if some are not being used, it may make sense to shut them down and move their functionality to the orchestrating LLM where answers will be provided quickly.</p>
	</dd>
	<dt>Engagement</dt>
	<dd>
	<p>Measure average session duration and per-user interaction frequency as leading indicators of churn. Are users completing tasks? Are they returning day after day to complete more tasks?</p>
	</dd>
	<dt>Computational efficiency</dt>
	<dd>
	<p>As with any computational system, monitor the computational resources. Log average task completion time and resource utilization (CPU/GPU) to spot bottlenecks before your cloud bill <a contenteditable="false" data-primary="evaluation" data-secondary="metrics for" data-startref="icd705" data-tertiary="agentic systems" data-type="indexterm" id="id1124"/><a contenteditable="false" data-primary="metrics" data-secondary="agentic systems" data-startref="icd709" data-type="indexterm" id="id1125"/><a contenteditable="false" data-primary="agentic systems" data-secondary="metrics" data-startref="icd709a" data-type="indexterm" id="id1126"/>spikes.</p>
	</dd>
</dl>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="General Evaluation Considerations"><div class="sect1" id="ch07_general_evaluation_considerations_1748896751668480">
<h1>General Evaluation Considerations</h1>

<p>Ultimately, the success of your system is measured by its<a contenteditable="false" data-primary="user evaluation, of LLMs" data-type="indexterm" id="id1127"/> users. The main goal of metrics that can be automatically measured is to catch errors and improve the system to improve the user experience without frustrating users. However, as much as you can afford to do so, conduct user studies over an extended period to track changes in trust and satisfaction as users interact with your product.</p>

<p>NPS is a quick and useful one-question indicator of success and for that reason is widely adopted in many industries.</p>

<p>Satisfaction widgets are also very useful; for example, you can collect user feedback after each interaction by adding “thumbs-up” and “thumbs-down” buttons after each response, providing user feedback on real-world interactions.</p>

<p>You can also use commercial monitoring platforms <a contenteditable="false" data-primary="Weights &amp; Biases" data-type="indexterm" id="id1128"/>like <a href="https://wandb.ai/site">Weights &amp; Biases</a> or develop your own metrics with the LangSmith <a contenteditable="false" data-primary="LangSmith" data-type="indexterm" id="id1129"/>tool described earlier in this chapter to monitor your system in production. LangSmith can automatically evaluate the outputs of the agentic system. Weights &amp; Biases can collect metrics, show dashboards, and emit alerts when metrics become lower than some threshold you define.</p>

<p>By integrating channels for immediate user feedback, you can learn from user interactions and improve your application over time. This iterative process of collecting feedback and updating your application ensures that it adapts to user preferences, ultimately enhancing trust and <a contenteditable="false" data-primary="feedback loops" data-startref="kab999" data-type="indexterm" id="id1130"/>satisfaction.</p>

<section data-type="sect2" data-pdf-bookmark="The Value of Automated Metrics"><div class="sect2" id="ch07_the_value_of_automated_metrics_1748896751668527">
<h2>The Value of Automated Metrics</h2>

<p>As <a contenteditable="false" data-primary="evaluation" data-secondary="metrics for" data-tertiary="value of automated metrics" data-type="indexterm" id="id1131"/><a contenteditable="false" data-primary="metrics" data-secondary="value of automated metrics" data-type="indexterm" id="id1132"/>shown in <a data-type="xref" href="ch06.html#ch06_api_first_llm_deployment_1748919660052702">Chapter 6</a>, automated metrics can make it a lot easier for you to see whether changes are improving your application. For example, let’s say you have an application that generates text that describes an image. Your existing prompt has an NPS of 90%, but a new paper is proposing a different prompting technique (for example, using bullet points). If your metrics are automated, it’s easier to create<a contenteditable="false" data-primary="A/B testing" data-type="indexterm" id="id1133"/> an A/B test, offering output from the existing prompt to audience A and from the new prompt to audience B. You should expect the NPS of audience A to remain close to 90% (since it’s using the existing prompt). If the NPS of audience B, the one using the new prompt, is higher, you can decide to switch everyone to the new prompt.</p>

<p>Another use of A/B tests is to improve computational efficiency. LLMOps practitioners frequently try to reduce prompts while keeping the same performance. Since most LLMs are priced (or consume resources) based on prompt size, you want to use the smallest prompt that achieves a given quality threshold. You don’t even need to generate the smaller prompts yourself; you can use an LLM to summarize or reduce existing prompts while keeping the meaning and intention of the original prompt. If you have automated metrics, you can then test several prompts and select the smallest one that achieves your performance requirements. This can save enormous amounts of money and resources. Of course, you can also do this without using automated metrics, but it will take a lot <a contenteditable="false" data-primary="evaluation" data-secondary="metrics for" data-startref="icd703" data-type="indexterm" id="id1134"/><a contenteditable="false" data-primary="metrics" data-startref="icd707" data-type="indexterm" id="id1135"/>longer.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Model Drift"><div class="sect2" id="ch07_model_drift_1748896751668572">
<h2>Model Drift</h2>

<p>LLMs <a contenteditable="false" data-primary="evaluation" data-secondary="model drift and" data-type="indexterm" id="id1136"/><a contenteditable="false" data-primary="model drift" data-type="indexterm" id="id1137"/><a contenteditable="false" data-primary="drift" data-type="indexterm" id="id1138"/>are under constant development, with new models and new model versions coming up all the time. The performance of your application can drift because of a change in the model. Sometimes it improves, but sometimes it declines. If you don’t measure it, you won’t know.</p>

<p>For example, the popular GPT-3.5 Turbo model has four versions, the first two of which ceased to work on February 13, 2025. For users who configured their settings to “auto-update,” calls to these deprecated versions started going to the latest version automatically. For all other users, they just started returning errors.</p>

<p>In both cases, LLMOps would help. The latter case is more obvious, as even the most basic of monitoring systems (receiving lots of angry emails from disappointed users) will catch it.</p>

<p>The former case, when a model automatically changes to a new version, can generate unexpected issues. For example, it’s possible that some guardrails that you had to implement to prevent errors in earlier versions of the model are not necessary anymore. A typical case is dedicating a large portion of the prompt to safeguards against biases and offensive answers. Newer versions of models typically incorporate defenses against several known attacks, so including these defenses in your prompts might become just a waste of money.</p>

<p>A more difficult scenario is when performance unexpectedly drops. It’s possible for a prompt that worked with the old version to stop working with the new version, for unknown reasons.</p>

<p>Ideally, you would know about the version shift ahead of time so you could perform tests and make adjustments while both versions are still available. However, not all applications developed during the initial AI boom were built with metrics and monitoring in mind. Many developers were surprised when their applications suddenly stopped working or started giving different results due to a change in the backend of their cloud model provider.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Traditional Metrics Aren’t Enough"><div class="sect1" id="new_pages_traditional_metrics">
<h1>Traditional Metrics Aren’t Enough</h1>

<p>As we discussed earlier, in the RAG and Agents Evaluation section, standard metrics such as accuracy and loss have long served as foundational indicators of model performance during the training and validation phases. These metrics effectively quantify how well a model fits its training data or generalizes to held-out validation sets. However, they fall short in capturing the nuanced and multifaceted failure modes that emerge once models are deployed in complex, real-world production environments.</p>

<p>In production, outputs can be syntactically fluent and stylistically polished, yet harbor hallucinations, latent biases, or structural inconsistencies that traditional metrics like accuracy or loss simply do not detect. These subtle issues often have serious downstream consequences, from propagating misinformation to causing ethical violations and user dissatisfaction.</p>

<p>As a result, production-level evaluation demands toolsets and frameworks that are specifically designed for continuous, real-time monitoring of model behavior. These systems focus on detecting anomalies, tracking data and concept drift, assessing user impact, and identifying emerging ethical risks. Effective evaluation in this context requires more than just recognizing failure modes; it calls for architecting comprehensive observability pipelines that can capture these failures early and with high fidelity.</p>

<p>Such observability systems must be capable of tracing errors back to the precise stages in the inference or data-processing pipeline where they arose, whether that means input preprocessing, retrieval components, the generative model itself, or post-processing layers. Such granular mapping lets engineering teams perform rapid root-cause analysis, prioritize fixes, and confidently roll out mitigations. This proactive, end-to-end monitoring infrastructure transforms evaluation from a reactive afterthought into a strategic, integral part of maintaining reliability, safety, and ethical integrity in LLM-powered systems at scale.</p>

<section data-type="sect2" data-pdf-bookmark="The Observability Pipeline"><div class="sect2" id="new_pages_observability_pipeline">
<h2>The Observability Pipeline</h2>

<p>Evaluation can no longer be an afterthought, applied only after a response is generated. It must be embedded throughout the LLM pipeline, from initial input to final user feedback (see <a data-type="xref" href="#fig0704">Figure 7-4</a>).</p>

<figure><div id="fig0704" class="figure"><img src="assets/llmo_0704.png" width="899" height="539"/>
<h6><span class="label">Figure 7-4. </span>Observability pipeline for LLMs</h6>
</div></figure>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Preprocessing and Prompt Construction"><div class="sect2" id="new_pages_preprocessing">
<h2>Preprocessing and Prompt Construction</h2>

<p>LLM deployment failures often trace back not to the model itself, but to the prompts it receives. In production environments, prompts are rarely fixed, handcrafted snippets. Instead, they are dynamically generated, assembled from templates, and parameterized based on upstream data sources or evolving user state. This dynamism introduces complexity and variability that can subtly undermine the system’s performance if not carefully managed.</p>

<p>Evaluation at the prompt stage focuses on several critical dimensions. First, prompts must be syntactically valid, correctly formatted, and free from errors that could disrupt parsing or tokenization. Second, they need to be semantically coherent, providing clear, unambiguous instructions that align with the model’s expected input format. Third, rigorous version control of prompt templates and their variants is essential. By capturing every prompt version and structural modification, teams gain traceability that links downstream inference errors directly back to specific prompt changes.</p>

<p>To prevent cascading failures during model inference, it’s important to detect malformed inputs early, such as missing context variables or incorrectly injected parameters. Monitoring metrics like prompt token length distribution is another key operational practice. Excessively long prompts risk being truncated, which can omit vital context and degrade the output quality. Conversely, prompts that are too short may fail to provide sufficient context, effectively starving the model of the information it needs to generate accurate and relevant responses. By continuously tracking these distributions, teams can proactively identify regressions and intervene before they impact end users’ experience.</p>

<p>As prompt engineering matures into a formalized discipline, evaluation in this stage evolves from reactive debugging toward a model of foundational pipeline governance. This shift emphasizes systematic oversight, reproducibility, and controlled iteration, ensuring that prompt generation remains a stable, reliable cornerstone of the overall LLM inference pipeline.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Retrieval in RAG Pipelines"><div class="sect2" id="new_pages_retrieval">
<h2>Retrieval in RAG Pipelines</h2>

<p>In RAG systems, failures frequently originate not within the LLM itself, but within the retrieval stage. Evaluating retrieval performance is therefore critical. It involves assessing multiple dimensions: the contextual relevance of retrieved documents, the freshness of the information, and timeliness relative to the query’s intent and domain.</p>

<p>Effective RAG observability frameworks should log the exact set of documents retrieved for each user query, to enable retrospective analysis and reproducibility. Quantitative metrics, such as similarity scores between retrieved documents and verified ground-truth sources, provide objective measures of retrieval accuracy. Monitoring retrieval latency is also essential, since delays in fetching documents directly impact the system’s overall responsiveness and the user experience.</p>

<p>One of the most powerful evaluation techniques in this context is <em>embedding similarity drift detection</em>. By continuously tracking the statistical distributions of query and document embeddings, teams can detect subtle shifts that may signal degradation in retrieval quality. These shifts often precede more obvious failures, such as hallucinations or vague, nonspecific responses, caused by irrelevant or outdated documents. Once this kind of drift is detected, timely interventions include retraining the retriever, refreshing the index, and reconfiguring the retrieval pipeline.</p>

<p>Without this granular observability, it becomes extremely challenging to differentiate failures caused by retrieval issues from those arising in the generation stage. Properly instrumented evaluation pipelines that span both the retrieval and generation <span class="keep-together">components</span> are thus indispensable for maintaining the reliability, accuracy, and user trustworthiness of RAG-powered enterprise LLM systems.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="LLM Inference"><div class="sect2" id="new_pages_inference">
<h2>LLM Inference</h2>

<p>At the inference stage, the key metrics span several dimensions. Factual accuracy assesses whether the generated text aligns with verifiable truth, while hallucination rate measures the frequency of hallucinations. Fluency evaluates the readability and coherence of outputs. Latency tracks response times, which directly affect user experience and system throughput.</p>

<p>To enable deep diagnostics, observability systems must log detailed metadata for every inference call:</p>

<ul>
	<li>
	<p>Token counts for both inputs and outputs reveal usage patterns and potential truncations.</p>
	</li>
	<li>
	<p>Temperature and other sampling parameters clarify the probabilistic nature of generation.</p>
	</li>
	<li>
	<p>Model versioning lets you trace performance changes to specific code or model updates.</p>
	</li>
	<li>
	<p>Abrupt shifts in completion length may indicate truncation errors or latent failures that aren’t immediately obvious in the delivered responses, making this <span class="keep-together">metric</span> particularly valuable.</p>
	</li>
</ul>

<p>Beyond surface metrics, internal evaluation techniques provide an additional layer of quality assurance. Self-consistency checks, which compare multiple generations of the same prompt, can identify outputs that are superficially fluent but inconsistent <span class="keep-together">or contradictory.</span> Similarly, confidence scores derived from auxiliary evaluators or <span class="keep-together">specialized</span> classifiers help flag outputs that deviate from the expected factual or ethical standards.</p>

<p>Inference is rarely a standalone process; it’s usually embedded within intricate chains or pipelines involving multiple calls, retrieval steps, and post-processing. This is where structured logging and trace visualization tools become essential. These tools enable real-time monitoring, facilitate root-cause analysis, and empower teams to pinpoint precisely where failures or inefficiencies occur within complex workflows. Together, these observability practices elevate inference evaluation from a passive measurement to an active governance mechanism that’s essential for maintaining reliability, accuracy, and trustworthiness in deployed LLM systems.</p>
</div></section>

<section class="pagebreak-before" data-type="sect2" data-pdf-bookmark="Postprocessing and Output Validation"><div class="sect2" id="new_pages_postprocessing">
<h2 class="less_space">Postprocessing and Output Validation</h2>

<p>After the generation phase, outputs typically undergo a <em>postprocessing</em> stage, where formatting, cleanup, and structural adjustments prepare the data for delivery to end users or downstream systems. Although this step may seem straightforward, even minor structural errors introduced here can cascade into significant failures throughout the application stack.</p>

<p>Evaluation at the post-processing stage centers on <em>structural validation</em>. This involves verifying that the generated outputs conform to expected formats: for instance, ensuring that JSON responses are syntactically valid, adhere strictly to predefined schemas, and include all mandatory fields. This is important, because outputs that appear grammatically correct can still be functionally unusable if key data elements are missing or malformed.</p>

<p>Automated tooling plays a vital role here. <em>Schema validators</em> check systematically for structural integrity, while additional automated checks can detect empty completions or other anomalies that could disrupt downstream processing. In high-stakes domains and compliance-critical applications, undetected errors during post-processing risk triggering silent failures or even regulatory breaches, with potentially severe consequences.</p>

<p>By elevating postprocessing to a formal, evaluable stage within the overall system pipeline, teams gain the ability to proactively detect and remediate structural issues before they propagate. This perspective transforms post-processing from a passive formatting step into a critical checkpoint for ensuring output reliability, correctness, and compliance in production LLM deployments.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Capturing Feedback"><div class="sect2" id="new_pages_feedback">
<h2>Capturing Feedback</h2>

<p>Feedback data includes signals like user ratings, thumbs-up/down, direct textual feedback, and implicit behavioral indicators, like engagement duration, query abandonment, and rates of escalation to human agents.</p>

<p>Consistently capturing and integrating this feedback grounds your evaluation firmly in real-world user experience, revealing nuanced gaps and failure modes that static internal benchmarks and offline testing might overlook. Metrics in this stage serve as vital usability indicators that directly inform system refinement priorities. These include <em>dwell time</em>, which measures how long users engage with generated content; <em>abandonment rates</em>, which signal frustration or dissatisfaction, and <em>retry frequency</em>, which can indicate unclear or unhelpful responses.</p>

<p>Evaluation platforms like LangSmith facilitate rubric-driven scoring of outputs, along dimensions like factuality, relevance, and structural correctness. These scores are enriched with metadata, including model versions, prompt variants, and contextual information, enabling fine-grained traceability and longitudinal performance <span class="keep-together">analysis.</span></p>

<p>As approaches like human-in-the-loop fine-tuning and reward modeling mature, feedback transitions from a passive measurement tool into an active driver of continuous improvement. User signals become training data that dynamically steers model updates and pipeline adjustments, closing the loop between deployment and <span class="keep-together">iteration.</span></p>

<p>Every stage of the pipeline yields unique and complementary insights into your system’s health. Their real power emerges when these observations are integrated holistically into an end-to-end observability framework. This interconnected visibility is critical for maintaining robust, reliable, and user-centered LLM applications in dynamic production environments.</p>

<p>At its core, observability is an anomaly-detection problem. You’re looking for patterns or deviations from expected behavior in your system’s metrics, logs, traces, and outputs. Like a smoke detector, the goal isn’t to catch every minor issue but to catch the ones that matter before they spread into serious failures. Post-LLM evaluation metrics that you likely set up in training, these observability metrics cover the remainder of the pipeline. You can do this across four stages, each with its own <span class="keep-together">benefits:</span></p>

<dl>
	<dt>Stage 1: Threshold-based alerts</dt>
	<dd>
	<p>This is the simplest form. Here, you can set explicit limits on key metrics, like API response times over 2 seconds or token counts exceeding 1024. When thresholds are crossed, tools like <a contenteditable="false" data-primary="Prometheus" data-type="indexterm" id="id1139"/>Prometheus collect the data, and <a contenteditable="false" data-primary="Grafana" data-type="indexterm" id="id1140"/>Grafana triggers alerts that notify teams via Slack or issue trackers. It’s straightforward and fast to implement, but may miss complex or evolving issues since the thresholds are static.</p>
	</dd>
	<dt>Stage 2: Statistical anomaly detection</dt>
	<dd>
	<p>Here, you move beyond fixed limits by analyzing metric behavior over time using rolling statistics, such as moving averages and z-scores. For example, a sudden spike in latency with a high z-score signals an anomaly worth investigating. Grafana dashboards paired with AlertManager highlight these deviations, and integrating with trace tools like LangSmith helps pinpoint which requests or outputs caused the alert. This method adapts to normal fluctuations, reducing false <span class="keep-together">positives.</span></p>
	</dd>
	<dt>Stage 3: Drift detection</dt>
	<dd>
	<p>This monitors changes in input data or retrieval quality that can degrade AI performance over time. For instance, if user queries shift or similarity scores in retriever embeddings drop, it’s a sign that data or retrieval may be stale. Using libraries like FAISS for embedding analysis and frameworks like <a contenteditable="false" data-primary="LangChain" data-type="indexterm" id="id1141"/>LangChain for pipeline monitoring, you can detect these shifts early. Automated workflows then refresh retrievers or retrain the models, thus keeping the system accurate and <span class="keep-together">relevant.</span></p>
	</dd>
	<dt>Stage 4: Feedback Signal Monitoring</dt>
	<dd>
	<p>User feedback and fallback behaviors provide direct insight into real-world system health. A drop in positive ratings or an increase in fallback (default) responses indicates issues in user experience or model degradation. Tools like LangSmith and MLflow link this feedback to specific model versions and deployments, helping teams diagnose the root cause and decide whether to rollback or retrain.</p>
	</dd>
</dl>

<p>A robust observability system combines all these four layers. While the following tools mentioned are my general suggestions, feel free to stick with the stack you already have:</p>

<ul>
	<li>
	<p>Prometheus <a contenteditable="false" data-primary="Prometheus" data-type="indexterm" id="id1142"/>collects runtime metrics (CPU, memory, latency, token usage).</p>
	</li>
	<li>
	<p>Grafana <a contenteditable="false" data-primary="Grafana" data-type="indexterm" id="id1143"/>offers real-time dashboards and alerting on thresholds and statistical anomalies.</p>
	</li>
	<li>
	<p>MLflow/ZenML <a contenteditable="false" data-primary="MLFlow" data-type="indexterm" id="id1144"/>tracks <a contenteditable="false" data-primary="ZenML" data-type="indexterm" id="id1145"/>model versions and experiment metadata.</p>
	</li>
	<li>
	<p>LangSmith <a contenteditable="false" data-primary="LangSmith" data-type="indexterm" id="id1146"/>provides trace-level insights and connects feedback signals to model performance.</p>
	</li>
</ul>

<p>My goal here is not to recommend tools but to provide you with some references. Regardless of the tool you choose, or even if you choose to hard-code everything, what matters most is your implementation technique. By layering simple threshold alerts, adaptive statistical methods, drift detection, and user feedback monitoring, you can build a comprehensive pipeline that catches everything from obvious breaches to subtle degradations in AI system health.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="ch07_conclusion_1748896751668616">
<h1>Conclusion</h1>

<p>This chapter covered general LLM evaluation metrics and additional considerations for two specific cases: RAG and multi-agent systems. The importance of automatically collecting metrics cannot be overstated. It can mean the difference between having a successful and trusted application and waking up to lots of angry users.</p>

<p>While the chapter has focused on general principles that work regardless of the specific metrics used, it also points to the latest metrics and frameworks available as of the writing of this chapter. Keep in mind that this is a very active area of research. However, while new metrics may be created at any time, the principles will <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="evaluating" data-startref="icd701" data-type="indexterm" id="id1147"/><a contenteditable="false" data-primary="evaluation" data-startref="icd702" data-type="indexterm" id="id1148"/>remain the same.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="References"><div class="sect1" id="ch07_references_1748896751668660">
<h1>References</h1>

<p>CoreWeave. n.d. <a href="https://wandb.ai/site">Weights &amp; Biases</a>, accessed May 21, 2025.</p>

<p>Es, Shahul, et al. <a href="https://oreil.ly/QUyLl">“Ragas: Automated Evaluation of Retrieval Augmented Generation”</a>, arXiv, April 2025.</p>

<p>Fu, Jinlan, et al. <a href="https://oreil.ly/ylJna">“GPTScore: Evaluate as You Desire”</a>, arXiv, February 2023.</p>

<p>Hendrycks, Dan, et al. <a href="https://oreil.ly/0xT-x">“Measuring Massive Multitask Language Understanding”</a>, arXiv, January 2021.</p>

<p>Honovich, Or, et al. <a href="https://oreil.ly/UwZvJ">“TRUE: Re-Evaluating Factual Consistency Evaluation”</a>, arXiv, May 2022.</p>

<p>LangSmith. n.d. <a href="https://oreil.ly/F8EVF">“Get Started with LangSmith”</a>, accessed May 21, 2025.</p>

<p>Lin, Stephanie, et al. <a href="https://oreil.ly/adQ-N">“TruthfulQA: Measuring How Models Mimic Human Falsehoods”</a>, arXiv, May 2022.</p>

<p>Liu, Yang, et al. <a href="https://oreil.ly/IzuUL">“G-Eval: NLG Evaluation Using GPT-4 with Better Human Alignment”</a>, arXiv, May 2023.</p>

<p>Machan, J. J. n.d. <a href="https://oreil.ly/JkFwY">Ragas</a>, accessed May 21, 2025.</p>

<p>Manakul, Potsawee, et al. <a href="https://oreil.ly/8AKE9">“SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models”</a>, arXiv, October 2023.</p>

<p>Wang, Alex, et al. <a href="https://oreil.ly/rcLR4">“GLUE: A Multi-Task Benchmark and Analysis Platform for Natural Language Understanding”</a>, arXiv, February 2019.</p>

<p>Wang, Alex, et al. <a href="https://oreil.ly/mpepc">“SuperGLUE: A Stickier Benchmark for General-Purpose Language Understanding Systems”</a>, arXiv, February 2020.</p>



<p>Wei, Jason, et al. <a href="https://oreil.ly/YIrYf">“Chain-of-Thought Prompting Elicits Reasoning in Large Language Models”</a>, arXiv, January 2023.</p>

<p>Zellers, Rowan, et al. <a href="https://oreil.ly/2VpX9">“HellaSwag: Can a Machine Really Finish Your Sentence?”</a>, arXiv, May 2019.</p>

<p>Zhong, Ming, et al. <a href="https://oreil.ly/nMMsh">“Towards a Unified Multi-Dimensional Evaluator for Text Generation”</a>, arXiv, October 2022.</p>
</div></section>
</div></section></div></div></body></html>