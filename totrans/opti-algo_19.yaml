- en: Appendix C. Exercises and solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, you will find a comprehensive set of exercises and their corresponding
    solutions, organized by chapter, to enhance your understanding and the application
    of the material presented in this book. These exercises are designed to reinforce
    the concepts, theories, and practical skills covered throughout the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.1 Chapter 2: A deeper look at search and optimization'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.1.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice: Choose the correct answer for each of the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   _________ is the class of decision problems that can be solved by nondeterministic
    polynomial algorithms and whose solutions are hard to find but easy to verify.
  prefs: []
  type: TYPE_NORMAL
- en: a.  P
  prefs: []
  type: TYPE_NORMAL
- en: b.  NP
  prefs: []
  type: TYPE_NORMAL
- en: c.  co-NP
  prefs: []
  type: TYPE_NORMAL
- en: d.  NP-complete
  prefs: []
  type: TYPE_NORMAL
- en: e.  NP-hard
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   Which of the following benchmark (toy) problems is not NP-complete?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Bin packing
  prefs: []
  type: TYPE_NORMAL
- en: b.  Knapsack problem
  prefs: []
  type: TYPE_NORMAL
- en: c.  Minimum spanning tree
  prefs: []
  type: TYPE_NORMAL
- en: d.  Hamiltonian circuit
  prefs: []
  type: TYPE_NORMAL
- en: e.  Vertex cover problem
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   _________ is the class of decision problems whose “No” answer can be
    verified in polynomial time.
  prefs: []
  type: TYPE_NORMAL
- en: a.  P
  prefs: []
  type: TYPE_NORMAL
- en: b.  NP
  prefs: []
  type: TYPE_NORMAL
- en: c.  co-NP
  prefs: []
  type: TYPE_NORMAL
- en: d.  NP-complete
  prefs: []
  type: TYPE_NORMAL
- en: e.  NP-hard
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   Which of the following real-world problems is NP-hard?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Image matching
  prefs: []
  type: TYPE_NORMAL
- en: b.  Single machine scheduling
  prefs: []
  type: TYPE_NORMAL
- en: c.  Combinational equivalence checking
  prefs: []
  type: TYPE_NORMAL
- en: d.  Capacitated vehicle routing problem (CVRP)
  prefs: []
  type: TYPE_NORMAL
- en: e.  Container/truck loading
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   _________ is a theory that focuses on classifying computational problems
    according to their resource usage and relating these classes to each other.
  prefs: []
  type: TYPE_NORMAL
- en: a.  Optimization complexity
  prefs: []
  type: TYPE_NORMAL
- en: b.  Time complexity
  prefs: []
  type: TYPE_NORMAL
- en: c.  Computational complexity
  prefs: []
  type: TYPE_NORMAL
- en: d.  Operation research
  prefs: []
  type: TYPE_NORMAL
- en: e.  Decision complexity
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Describe the following search and optimization problems in terms of decision
    variable (univariate, bivariate, multivariate); objective functions (mono-objective,
    multi-objective, no objective function, or constraint-satisfaction problem); constraints;
    (hard constraints, soft constraints, both hard and soft constraints, unconstrained);
    and linearity (linear programming (LP), quadratic programming (QP), nonlinear
    programming (NLP)).
  prefs: []
  type: TYPE_NORMAL
- en: a.  Minimize *y* + cos(*x*²), sin(*x*) – *x × y*, and 1 / (*x* + *y*)²
  prefs: []
  type: TYPE_NORMAL
- en: b.  Maximize 2 – e^((1 –) *^x*^) subject to –3 ≤ *x* *< 10*
  prefs: []
  type: TYPE_NORMAL
- en: c.  Maximize 3 *× x* – *y* / 5 subject to –2 ≤ *x* < 3, 0 < *y* ≤ 3, and *x*
    + *y* = 4
  prefs: []
  type: TYPE_NORMAL
- en: d.  The school districting problem consists of determining the groups of students
    attending each school of a school board located over a given territory in a way
    that maximizes the contiguity of school sectors, taking into consideration a number
    of hard constraints such as school capacity for each grade and class capacity.
    Walkability and keeping students in the same school from year to year are considered
    soft constraints in this problem.
  prefs: []
  type: TYPE_NORMAL
- en: e.  The knapsack problem is an example of a combinatorial problem whose solution
    takes the form of a combination where the order doesn’t matter. As illustrated
    in figure C.1, given a set of items, each with a utility and a weight, the task
    is to select a subset of items to maximize the total utility while ensuring that
    the total weight of the selected items does not exceed a predefined capacity.
    The decision to include or exclude each item is binary.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F01_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.1 Each item has a utility and a weight, and we want to maximize the
    utility of the contents of the knapsack. The problem is constrained by the capacity
    of the bag.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   For the following optimization problems, state the type of the problem
    (design, planning, or control problem) based on the permissible time to solve
    the problem and the expected quality of the solutions. Suggest the appropriate
    algorithm required to handle the optimization problem (offline versus online).
  prefs: []
  type: TYPE_NORMAL
- en: a.  Find the optimal wind park design where the number and types of wind turbines
    need to be chosen and placed based on the wind conditions and wind park area.
  prefs: []
  type: TYPE_NORMAL
- en: b.  Find multiple vehicle routes starting and ending at different depots so
    that all customer demands are fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: c.  Create a fitness assistant for runners and cyclists that seamlessly automates
    the multiple tasks involved in planning fitness activities. The planner will assess
    an athlete’s current fitness level and individual training goals in order to create
    a fitness plan. The planner will also generate and recommend geographical routes
    that are both popular and customized to the user’s goals, level, and scheduled
    time, thus reducing the challenges involved in the planning stage. The suggested
    fitness plans will continuously adapt based on each user’s progress toward their
    fitness goals, thus keeping the athlete challenged and motivated.
  prefs: []
  type: TYPE_NORMAL
- en: d.  Find a set of flights with departure and arrival times and aircraft assignments
    that maximize profits, given demand and revenues for every flight, route information
    distances, times, operating restrictions, aircraft characteristics and operating
    costs, and operational and managerial constraints.
  prefs: []
  type: TYPE_NORMAL
- en: e.  Find the optimal schedule for delivery cargo bikes, semi and fully autonomous
    last-mile delivery trucks, self-driving delivery robots or delivery drones to
    maximize customer satisfaction and minimize delivery costs, taking into consideration
    the capacity of the vehicle, type of delivery service (a couple of days delivery,
    next-day delivery, or same-day delivery with some extra surcharge), delivery time,
    drop-off locations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: f.  Plan on-demand responsive transit during pandemics to support the transportation
    of essential workers and essential trips to pharmacies and grocery stores for
    the general public, especially the elderly, taking into consideration store operating
    hours, capacity, and online delivery options.
  prefs: []
  type: TYPE_NORMAL
- en: g.  Find a collision-free path for a vehicle from a start position to a given
    goal position, amid a collection of obstacles, in such a way that minimizes the
    estimated time of arrival and the consumed energy.
  prefs: []
  type: TYPE_NORMAL
- en: h.  Develop a trip planner that minimizes total commute time, maximizes the
    average ratings of attractions, maximizes the duration spent at each of these
    attractions, and effectively minimizes idle time when someone visits a city.
  prefs: []
  type: TYPE_NORMAL
- en: i.  Find school bus loading patterns and schedules such that the number of routes
    is minimized, the total distance traveled by all buses is kept to a minimum, no
    bus is overloaded, and the time required to traverse any route does not exceed
    a maximum time policy.
  prefs: []
  type: TYPE_NORMAL
- en: j.  Minimize deadheading for shared mobility companies (minimize the miles driven
    with no passenger) or for delivery services providers (minimize the miles driven
    without cargo).
  prefs: []
  type: TYPE_NORMAL
- en: k.  Plan or replan transport corridors and city streets to accommodate more
    pedestrians, cyclists, and riders in shared transportation and fewer cars.
  prefs: []
  type: TYPE_NORMAL
- en: l.  Find the optimal placement for bus stops, traffic sensors, micro mobility
    stations, EV charging stations, air taxi takeoff and landing locations, walking
    routes, and cycling lanes for active mobility.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Modify listing 2.6 to define the animal feed mix problem data using Python
    dictionaries or to read the problem data from a CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: C.1.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice
  prefs: []
  type: TYPE_NORMAL
- en: 1.1\. b) NP
  prefs: []
  type: TYPE_NORMAL
- en: 1.2\. c) Minimum spanning tree
  prefs: []
  type: TYPE_NORMAL
- en: 1.3\. c) co-NP
  prefs: []
  type: TYPE_NORMAL
- en: 1.4\. d) Capacitated vehicle routing problem (CVRP)
  prefs: []
  type: TYPE_NORMAL
- en: 1.5\. c) Computational complexity
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Optimization problem description
  prefs: []
  type: TYPE_NORMAL
- en: a.  Bivariate, multi-objective, unconstrained, nonlinear programming
  prefs: []
  type: TYPE_NORMAL
- en: b.  Univariate, mono-objective, hard constraints, nonlinear programming
  prefs: []
  type: TYPE_NORMAL
- en: c.  Bivariate, mono-objective, hard constraints, linear programming
  prefs: []
  type: TYPE_NORMAL
- en: d.  Multivariate, mono-objective, both hard and soft constraints, linear programming
    (see Jacques A. Ferland and Gilles Guénette, “Decision support system for the
    school districting problem” [1])
  prefs: []
  type: TYPE_NORMAL
- en: e.  Bivariate, mono-objective, hard constraints, linear programming
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Optimization problem and process
  prefs: []
  type: TYPE_NORMAL
- en: a.  Design problem. Offline optimization.
  prefs: []
  type: TYPE_NORMAL
- en: b.  Planning problem during the process of generating the route, and control
    problem during rerouting. Offline optimization during planning, and online optimization
    during rerouting.
  prefs: []
  type: TYPE_NORMAL
- en: c.  Planning problem to generate the plans and control problem for adaptation.
    Offline optimization during the planning phase, and online during the adaptation
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: d.  Design problem to generate the flight schedule, and planning problem if
    adaptation is required, such as in the case of faulty aircraft or cancellation
    due to weather conditions. Offline optimization, and online optimization if adaptation
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: e.  Planning problem during path generation, and control problem during rerouting
    for adaptive motion planning. Online optimization.
  prefs: []
  type: TYPE_NORMAL
- en: f.  Planning problem for scheduling, and control problem if rerouting is involved.
    Online optimization.
  prefs: []
  type: TYPE_NORMAL
- en: g.  Planning problem to generate the plans, and control problem for adaptation.
    Online optimization.
  prefs: []
  type: TYPE_NORMAL
- en: h.  Planning problem. Offline optimization.
  prefs: []
  type: TYPE_NORMAL
- en: i.  Design problem. Offline optimization.
  prefs: []
  type: TYPE_NORMAL
- en: j.  Planning problem. Online optimization.
  prefs: []
  type: TYPE_NORMAL
- en: k.  Design problem. Offline optimization.
  prefs: []
  type: TYPE_NORMAL
- en: l.  Design problem. Offline optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The next listing shows the steps for defining the animal feed mix problem
    data using Python dictionaries or to read the problem data from a CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.1 Animal feed mix problem—defining data using dictionaries
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: ① Create a list of ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: ② Dictionary of unit cost (cents/kg).
  prefs: []
  type: TYPE_NORMAL
- en: ③ Dictionary of calcium (kg/kg).
  prefs: []
  type: TYPE_NORMAL
- en: ④ Dictionary of protein (kg/kg).
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Create a model.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Dictionary called 'ingredient_vars' is created to contain the referenced variables.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Add the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Add the five constraints.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Solve the problem using PuLP's choice of solver.
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Print the results.
  prefs: []
  type: TYPE_NORMAL
- en: We can also read the problem data from a CSV file as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.2 Animal feed mix problem—reading problem data from a CSV file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: ① Read the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: ② Convert data frame to a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create a model.
  prefs: []
  type: TYPE_NORMAL
- en: ④ A dictionary called 'ingredient_vars' is created to contain the referenced
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Add the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Add the five constraints.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Solve the problem using PuLP's choice of solver.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Print the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running listing C.2 produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'C.2 Chapter 3: Blind search algorithms'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.2.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: '1.1.   Big *O* specifically describes the limiting behavior of a function (worst-case
    scenario) when the argument tends toward a particular value or infinity, usually
    in terms of simpler functions. What is the big *O* of this expression: nlog(*n*)
    + log(2*n*)?'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Linearithmic
  prefs: []
  type: TYPE_NORMAL
- en: b.  Loglinear
  prefs: []
  type: TYPE_NORMAL
- en: c.  Quasilinear
  prefs: []
  type: TYPE_NORMAL
- en: d.  All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   Which blind search algorithm implements a stack operation for searching
    the states?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Breadth-first search (BFS)
  prefs: []
  type: TYPE_NORMAL
- en: b.  Uniform-cost search (UCS)
  prefs: []
  type: TYPE_NORMAL
- en: c.  Bidirectional search (BS)
  prefs: []
  type: TYPE_NORMAL
- en: d.  Depth-first search (DFS)
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   A tree is a connected graph with no circuits and no self-loops.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   For a very large workspace where the goal is deep within the workspace,
    the number of nodes could expand exponentially, and a depth-first search will
    demand a very large memory requirement.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Best-first is a mixed-depth and breadth-first search that uses heuristic
    values and expands the most desirable unexpanded node.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   In design problems or strategic functions, optimality is usually traded
    in for speed gains.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   Graph traversal algorithms outperform shortest path algorithms in applications
    where the weights of edges in a graph are all equal.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   In Dijkstra’s algorithm, the priority queue is implemented using which
    data structure?.
  prefs: []
  type: TYPE_NORMAL
- en: a.  Stack
  prefs: []
  type: TYPE_NORMAL
- en: b.  Queue
  prefs: []
  type: TYPE_NORMAL
- en: c.  Heap
  prefs: []
  type: TYPE_NORMAL
- en: d.  Array
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   When is breadth-first search optimal?
  prefs: []
  type: TYPE_NORMAL
- en: a.  When there are fewer nodes
  prefs: []
  type: TYPE_NORMAL
- en: b.  When all step costs are equal
  prefs: []
  type: TYPE_NORMAL
- en: c.  When all step costs are unequal
  prefs: []
  type: TYPE_NORMAL
- en: d.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. Which blind search algorithm combines DFS’s space-efficiency and BFS’s
    fast search by incrementing the depth limit until the goal is reached?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Depth-limited search (DLS)
  prefs: []
  type: TYPE_NORMAL
- en: b.  Iterative deepening search (IDS)
  prefs: []
  type: TYPE_NORMAL
- en: c.  Uniform-cost search (UCS)
  prefs: []
  type: TYPE_NORMAL
- en: d.  Bidirectional search (BS)
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.11. Which term describes an algorithm with a computational complexity of *O*(*n*
    log*n*)?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Logarithmic
  prefs: []
  type: TYPE_NORMAL
- en: b.  Exponential
  prefs: []
  type: TYPE_NORMAL
- en: c.  Quasilinear
  prefs: []
  type: TYPE_NORMAL
- en: d.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.12. Which search algorithm is implemented with an empty first in, first out
    queue?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Depth-first search
  prefs: []
  type: TYPE_NORMAL
- en: b.  Breadth-first search
  prefs: []
  type: TYPE_NORMAL
- en: c.  Bidirectional search
  prefs: []
  type: TYPE_NORMAL
- en: d.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Consider the simplified map shown in figure C.2, where the edges are labeled
    with actual distances between the cities. State the path from city A to city M
    that would be produced by BFS and the path produced by DFS.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F02_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.2 A simplified map
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Find the big *O* notation for the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  10*n* + nlog(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: b.  4 + *n*/5
  prefs: []
  type: TYPE_NORMAL
- en: c.  *n*⁵ – 20*n*³ + 170*n* + 208
  prefs: []
  type: TYPE_NORMAL
- en: d.  *n* + 10log(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Consider the search space in figure C.3, where S is the start node and
    G1 and G2 are the goal nodes. Edges are labeled with the value of a cost function;
    the number gives the cost of traversing the arc. Above each node is the value
    of a heuristic function; the number gives the estimate of the distance to the
    goal. Assume that uninformed search algorithms always choose the left branch first
    when there is a choice. For each of the depth-first search (DFS) and breadth-first
    search (BFS) strategies
  prefs: []
  type: TYPE_NORMAL
- en: a.  Indicate which goal state is reached first (if any).
  prefs: []
  type: TYPE_NORMAL
- en: b.  List, in order, all the states that are popped off the OPEN list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F03_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.3 A graph search exercise
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Solve the crossword puzzle in figure C.4.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F04_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.4 Blind search crossword puzzle
  prefs: []
  type: TYPE_NORMAL
- en: Across
  prefs: []
  type: TYPE_NORMAL
- en: 2.   A depth-first search with a predetermined depth limit
  prefs: []
  type: TYPE_NORMAL
- en: 7.   A blind search algorithm that solves the single-source shortest path problem
    for a weighted graph with non-negative edge costs
  prefs: []
  type: TYPE_NORMAL
- en: 8.   A search algorithm that combines forward and backward search
  prefs: []
  type: TYPE_NORMAL
- en: 10.   A graph traversal algorithm that first explores nodes going through one
    adjacent to the root, then the next adjacent, until it finds a solution or until
    it reaches a dead end
  prefs: []
  type: TYPE_NORMAL
- en: 11.   A variant of Dijkstra’s algorithm that is appropriate for large graphs
  prefs: []
  type: TYPE_NORMAL
- en: 13.   A function that is slightly faster than linear complexity
  prefs: []
  type: TYPE_NORMAL
- en: 14.   A graph in which multiple edges may connect the same pair of vertices
  prefs: []
  type: TYPE_NORMAL
- en: 15.   A last in, first out (LIFO) data structure
  prefs: []
  type: TYPE_NORMAL
- en: Down
  prefs: []
  type: TYPE_NORMAL
- en: 1.   A search algorithm that combines DFS’s space-efficiency and BFS’s fast
    search by incrementing the depth limit until the goal is reached
  prefs: []
  type: TYPE_NORMAL
- en: 2.   A graph used by Twitter to represent following
  prefs: []
  type: TYPE_NORMAL
- en: 3.   A graph traversal search algorithm that is preferred when the tree is deep
  prefs: []
  type: TYPE_NORMAL
- en: 4.   A generalization of a graph in which generalized edges can join any number
    of nodes
  prefs: []
  type: TYPE_NORMAL
- en: 5.   The type of graph used in LinkedIn to represent users, groups, unregistered
    persons, posts, skills, and jobs
  prefs: []
  type: TYPE_NORMAL
- en: 6.   A notation used to describe the performance or complexity of an algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 9.   The process of exploring the structure of a tree or a graph by visiting
    the nodes following a certain well-defined rule
  prefs: []
  type: TYPE_NORMAL
- en: 12.   A first in, first out (FIFO) data structure
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint:** Spaces or dashes *must* be used if the answer consists of two or
    more words.'
  prefs: []
  type: TYPE_NORMAL
- en: C.2.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   d) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   d) Depth-first search (DFS)
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   b) False
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   b) False
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   c) Heap
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   b) When all step costs are equal
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. b) Iterative deepening search (IDS)
  prefs: []
  type: TYPE_NORMAL
- en: 1.11. c) Quasilinear
  prefs: []
  type: TYPE_NORMAL
- en: 1.12. b) Breadth-first search
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The route obtained by BFS to go from A to M is
  prefs: []
  type: TYPE_NORMAL
- en: 'A→B→H→C→E→I→L→D→F→J→K→M→H→G→J→K→M:'
  prefs: []
  type: TYPE_NORMAL
- en: tracking back, the final route is A→H→L→M.
  prefs: []
  type: TYPE_NORMAL
- en: The route obtained by DFS to go from A to M is A→B→H→C→E→F→G→J→K→I→M.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   The solutions are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  *O*(nlogn)
  prefs: []
  type: TYPE_NORMAL
- en: b.  *O*(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: c.  *O*(*n*⁵)
  prefs: []
  type: TYPE_NORMAL
- en: d.  *O*(logn)
  prefs: []
  type: TYPE_NORMAL
- en: '4.   The solutions are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Search strategy | a | b |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Depth-first search** **(DFS)**Let’s assume that the nodes are expanded
    based on their lexicographical order (i.e., among the children of S, A is expanded
    first, since lexicographically, it is ordered before B and C). | G2 | S, A, D,
    H, J, G2 |'
  prefs: []
  type: TYPE_TB
- en: '| **Breadth-first search** **(BFS)**The status of the queue evolves such that[S],
    [S,A,B,C], [S,A,B,C,D,H], [S,A,B,C,D,H,G1]Note: Since H is already visited by
    A, it is not pushed again to the queue when being visited by B. However, it is
    reached twice. | G1 | S, A, B, C, D, H, H, G1 |'
  prefs: []
  type: TYPE_TB
- en: 5.   The crossword puzzle solutions are shown in figure C.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F05_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.5 Blind search crossword puzzle solution
  prefs: []
  type: TYPE_NORMAL
- en: 'C.3 Chapter 4: Informed search algorithms'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.3.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1   How many shortcuts will we have to add to the augmented graph if we decide
    to contract node E in figure C.6?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F06_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.6 Contracting node E
  prefs: []
  type: TYPE_NORMAL
- en: a.  0
  prefs: []
  type: TYPE_NORMAL
- en: b.  1
  prefs: []
  type: TYPE_NORMAL
- en: c.  2
  prefs: []
  type: TYPE_NORMAL
- en: d.  3
  prefs: []
  type: TYPE_NORMAL
- en: 1.2   The A* algorithm is a special version of
  prefs: []
  type: TYPE_NORMAL
- en: a.  Breadth-first search
  prefs: []
  type: TYPE_NORMAL
- en: b.  Depth-first search
  prefs: []
  type: TYPE_NORMAL
- en: c.  Hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: d.  Best-first search
  prefs: []
  type: TYPE_NORMAL
- en: e.  Dijkstra’s algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 1.3   Which of the following is *not* a variant of the hill climbing algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Complex hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: b.  Steepest-ascent hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: c.  Random-restart hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: d.  Steepest-ascent hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: e.  All of the above are variants of hill climbing.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4   If *f*(*n*) is the evaluation function (cost) of a path through *n* to
    the goal for each node, and *h*(*n*) is an estimated cost from *n* to the goal,
    such as the straight-line distance from *n* to the goal, what is the heuristic
    function of greedy best-first search?
  prefs: []
  type: TYPE_NORMAL
- en: a.  *f*(*n*) ≠ *h*(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: b.  *f*(*n*) < *h*(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: c.  *f*(*n*) = *h*(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: d.  *f*(*n*) > *h*(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: 1.5   In the directed weighted graph in figure C.7, how many shortcuts are needed
    if we contract the white node?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F07_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.7 Directed graph
  prefs: []
  type: TYPE_NORMAL
- en: a.  0
  prefs: []
  type: TYPE_NORMAL
- en: b.  1
  prefs: []
  type: TYPE_NORMAL
- en: c.  2
  prefs: []
  type: TYPE_NORMAL
- en: d.  3
  prefs: []
  type: TYPE_NORMAL
- en: e.  4
  prefs: []
  type: TYPE_NORMAL
- en: 1.6   The search strategy that uses problem-specific knowledge is known as
  prefs: []
  type: TYPE_NORMAL
- en: a.  Informed search
  prefs: []
  type: TYPE_NORMAL
- en: b.  Best-first search
  prefs: []
  type: TYPE_NORMAL
- en: c.  A* search
  prefs: []
  type: TYPE_NORMAL
- en: d.  Heuristic search
  prefs: []
  type: TYPE_NORMAL
- en: e.  All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.7   Which of the following is an algorithm used to solve the MST problem?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Kruskal
  prefs: []
  type: TYPE_NORMAL
- en: b.  Borůvka
  prefs: []
  type: TYPE_NORMAL
- en: c.  Jarník-Prim
  prefs: []
  type: TYPE_NORMAL
- en: d.  Chazelle
  prefs: []
  type: TYPE_NORMAL
- en: e.  All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.8   Hill climbing is an informed breadth-first search that demands little
    in terms of memory and computational overhead.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.9   Node ordering methods for CH include
  prefs: []
  type: TYPE_NORMAL
- en: a.  Edge difference
  prefs: []
  type: TYPE_NORMAL
- en: b.  Iterative updates
  prefs: []
  type: TYPE_NORMAL
- en: c.  Number of contracted neighbors
  prefs: []
  type: TYPE_NORMAL
- en: d.  Shortcut cover
  prefs: []
  type: TYPE_NORMAL
- en: e.  All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 A* is optimal if *h*(*n*) is an admissible heuristic, i.e., *h*(*n*) never
    overestimates the cost to reach the goal.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 The edge difference is the number of shortcuts introduced when contracting
    a node minus the number of incoming edges onto the node.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.12 Best-first is a mixed depth- and breadth-first search that uses heuristic
    values and expands the most desirable unexpanded node.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.13 What is the evaluation function in A* search?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Estimated cost from the current node to the goal node
  prefs: []
  type: TYPE_NORMAL
- en: b.  Cost of the path through the current node to the goal node
  prefs: []
  type: TYPE_NORMAL
- en: c.  Sum of the path cost through the current node to the goal node and the estimated
    cost from the current node to the goal node
  prefs: []
  type: TYPE_NORMAL
- en: d.  Average of the path cost through the current node to the goal node and the
    estimated cost from the current node to the goal node
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.14 Which search is complete and optimal when *h*(*n*) is consistent?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Best-first search
  prefs: []
  type: TYPE_NORMAL
- en: b.  Depth-first search
  prefs: []
  type: TYPE_NORMAL
- en: c.  Both best-first and depth-first search
  prefs: []
  type: TYPE_NORMAL
- en: d.  A* search
  prefs: []
  type: TYPE_NORMAL
- en: 1.15 In the contraction hierarchies (CH) algorithm, we contract nodes based
    on which of the following?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Decreasing order of their importance
  prefs: []
  type: TYPE_NORMAL
- en: b.  Increasing order of their importance
  prefs: []
  type: TYPE_NORMAL
- en: 1.16 The A* search algorithm tries to reduce the total number of states explored
    by incorporating a heuristic estimate of the cost to get the goal from a given
    state.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.17 The hill climbing algorithm is a local greedy search algorithm that tries
    to improve the efficiency of breadth-first search.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.18 In CH, the importance of a node may change during the contraction process,
    necessitating the recomputation of its importance.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.19 A beam search with a beam width equal to the number of nodes in each level
    is the same as
  prefs: []
  type: TYPE_NORMAL
- en: a.  Breadth-first search
  prefs: []
  type: TYPE_NORMAL
- en: b.  Depth-first search
  prefs: []
  type: TYPE_NORMAL
- en: c.  Hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: d.  Best-first search
  prefs: []
  type: TYPE_NORMAL
- en: e.  Dijkstra’s algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 1.20 In CH, the order of contraction does not affect the query performance.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Consider the search space in figure C.8, where S is the start node and
    G1 and G2 are the goal nodes. The edges are labeled with the value of a cost function;
    the number gives the cost of traversing the arc. Above each node is the value
    of a heuristic function; the number gives the estimate of the distance to the
    goal. Using A* search strategy
  prefs: []
  type: TYPE_NORMAL
- en: a.  Indicate which goal state is reached first (if any)
  prefs: []
  type: TYPE_NORMAL
- en: b.  List in order all the states that are popped off until one of the goal state
    is found
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F08_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.8 Search space
  prefs: []
  type: TYPE_NORMAL
- en: 3.   In the word search puzzle shown in figure C.9, find the hidden terms used
    in this chapter. You can search horizontally (from left to right or from right
    to left), vertically (from top to bottom or from bottom to top), or diagonally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F09_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.9 Informed search word-search puzzle
  prefs: []
  type: TYPE_NORMAL
- en: C.3.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1   a) 0 (no shortcut needed because a witness path exists between A and D)
  prefs: []
  type: TYPE_NORMAL
- en: 1.2   d) Best-first search
  prefs: []
  type: TYPE_NORMAL
- en: 1.3   a) Complex hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: 1.4   c) *f*(*n*) = *h*(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: 1.5   c) 2
  prefs: []
  type: TYPE_NORMAL
- en: 1.6   e) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.7   e) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.8   b) False (It is a variant of depth-first search.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.9   e) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 b) False (Edge difference is the number of shortcuts introduced when contracting
    a node minus the total degree of the node; i.e., the sum of the number of incoming
    edges onto the node plus the number of outgoing edges emanating from the node.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.12 a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.13 b) Cost of the path through the current node to the goal node
  prefs: []
  type: TYPE_NORMAL
- en: 1.14 d) A* search
  prefs: []
  type: TYPE_NORMAL
- en: 1.15 b) Increasing order of their importance
  prefs: []
  type: TYPE_NORMAL
- en: 1.16 a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.17 b) False
  prefs: []
  type: TYPE_NORMAL
- en: 1.18 a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.19 a) Breadth-first search
  prefs: []
  type: TYPE_NORMAL
- en: 1.20 b) False (The order of contraction does not affect the success of CH but
    will affect the preprocessing time and the query time. Some contraction ordering
    systems minimize the number of the shortcuts added in the augmented graph, and
    thus the overall running time.)
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The order of expansion is based on the sum of edge weights *g*(*n*) and
    the heuristic estimation *h*(*n*); i.e., *f*(*n*) = *g*(*n*) + *h*(*n*). For example,
    starting from S, *f*(A) = 8, *f*(B) = 18, and *f*(C) = 9, so the queue would look
    like [A,B,C] because *f*(A) < *f*(C) < *f*(B).
  prefs: []
  type: TYPE_NORMAL
- en: At the next step, when A is popped off the queue, nodes D and H are evaluated
    such that *f*(D) = *d*(S,A) + *d*(A,D) + *h*(D) = 1 + 5 + 4 = 10, and *f*(H) =
    *d*(S,A) + *d*(A,H) + *h*(H) = 19, and pushing them onto the queue in order will
    result in [A,C,D,B,H].
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the next node to be expanded would be C, which adds E and F to the
    queue with *f*(E) = 11 and *f*(F) = 19: [A,C,D,E,B,H,F]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the next node is D, which causes an update on *f*(H) = *d*(S,A) + *d*(A,D)
    + *d*(D,H) + *h*(H) = 1 + 5 + 2 + 6 = 14 that subsequently repositions it in the
    queue: [A,C,D,E,H,B,F]. The same strategy should be followed until one of the
    goals is found.'
  prefs: []
  type: TYPE_NORMAL
- en: a.  G1
  prefs: []
  type: TYPE_NORMAL
- en: b.  S, A, C, D, E, H, B, G1
  prefs: []
  type: TYPE_NORMAL
- en: 3.   The solution to the word search puzzle is shown in figure C.10.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F10_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.10 Informed search word-search puzzle solution
  prefs: []
  type: TYPE_NORMAL
- en: The word directions and start points are formatted as (direction, *X, Y*).
  prefs: []
  type: TYPE_NORMAL
- en: A-START (E, 7, 10)
  prefs: []
  type: TYPE_NORMAL
- en: BEAM SEARCH (E, 8, 6)
  prefs: []
  type: TYPE_NORMAL
- en: BEST-FIRST (E, 8, 9)
  prefs: []
  type: TYPE_NORMAL
- en: DEPTH-FIRST (E, 7, 12)
  prefs: []
  type: TYPE_NORMAL
- en: DOWNWARD GRAPH
  prefs: []
  type: TYPE_NORMAL
- en: (E, 3, 11)
  prefs: []
  type: TYPE_NORMAL
- en: EDGE DIFFERENCE (E, 2, 4)
  prefs: []
  type: TYPE_NORMAL
- en: HAVERSINE (E, 2, 8)
  prefs: []
  type: TYPE_NORMAL
- en: HILL CLIMBING (E, 5, 1)
  prefs: []
  type: TYPE_NORMAL
- en: INFORMED SEARCH (E, 3, 3)
  prefs: []
  type: TYPE_NORMAL
- en: KRUSKAL ALGORITHM (E, 2, 7)
  prefs: []
  type: TYPE_NORMAL
- en: WITNESS PATH (S,1, 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'C.4 Chapter 5: Simulated annealing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.4.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1   Simulated Annealing, unlike hill climbing, incorporates a probabilistic
    mechanism that allows it to accept downward steps, influenced by the current temperature
    and the quality of the move being considered.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.2   Simulated annealing is an optimization technique that always guarantees
    finding the global optimum solution.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.3   Dual annealing is an implementation of generalized hill climbing.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.4   In totally adaptive SA, a random combination of previously accepted steps
    and parameters are used to estimate new steps and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.5   The simulated annealing algorithm explores more of the search space when
    the temperature gets lower.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   Which cooling schedule asymptotically converges toward the global minimum
    but requires prohibitive computing time?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Linear cooling schedule
  prefs: []
  type: TYPE_NORMAL
- en: b.  Geometric cooling schedule
  prefs: []
  type: TYPE_NORMAL
- en: c.  Logarithmic cooling schedule
  prefs: []
  type: TYPE_NORMAL
- en: d.  Exponential cooling schedule
  prefs: []
  type: TYPE_NORMAL
- en: e.  Nonmonotonic adaptive cooling schedule
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   SA uses a thermal jump to avoid getting trapped in local minima while
    quantum annealing relies on quantum tunneling.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The Rosenbrock function, often referred to as the “valley” or “banana”
    function, is a nonconvex function that is defined as *f*(*x*,*y*) = (1 – *x*)²
    + 100(*y* – *x*²)². This is a standard test function and quite tough for most
    conventional solvers.
  prefs: []
  type: TYPE_NORMAL
- en: a.  Use listing 5.1 or 5.2 or implement your own version of the simulated annealing
    algorithm from scratch or using one the libraries mentioned in section A.4 of
    appendix A to find the global minimum of this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'b.  This banana function is still relatively simple, as it has a curved narrow
    valley. Other functions, such as the egg crate function, are strongly multimodal
    and highly nonlinear. Solve this egg crate function as an example of a highly
    nonlinear multimodal function: *f*(*x*,*y*) = *x*² + *y*² + 25[sin²(*x*) + sin²(*y*)].
    Consider the domain (*x*,*y*) ∈ [–5,5] × [–5,5]. It would take about 2,500 evaluations
    to get an optimal solution accurate to the third decimal place.'
  prefs: []
  type: TYPE_NORMAL
- en: c.  Investigate the rate of convergence of simulated annealing for different
    cooling schedules.
  prefs: []
  type: TYPE_NORMAL
- en: d.  For standard SA, the cooling schedule is a monotonically decreasing function.
    There is no reason why we should not use other forms of cooling. For example,
    we can use *T*(*i*) = *T*[o] cos²(*i*)*e*^–*^α^i*, *α* *> 0*. Modify the code
    implemented in the previous step to study the behavior of various functions as
    a cooling schedule.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Modify listing 5.5, or use ASA-GS [2], or implement your own version of
    simulated annealing to conduct a comparative study between different TSP datasets
    (see listing B.2 in appendix B to see how to get access to TSP instances). Fill
    in table C.1 with the tour length obtained by simulated annealing.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.1 SA solutions for different TSP datasets
  prefs: []
  type: TYPE_NORMAL
- en: '| Dataset | Best known solution | SA solution | CPU time (s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| burma14ulysses22oliver30att48eil51eil75kroA100d198 | 30.875875.665142033,52442653521,28215,780
    |  |  |'
  prefs: []
  type: TYPE_TB
- en: '4.   Solve TSP for 20 major US cities as shown in figure C.11\. In this TSP,
    a travelling salesman must visit a number US cities starting from a specific city.
    Assume the following cities, defined by their names and GPS latitude and longitude
    coordinates: New York City (40.72, –74.00); Philadelphia (39.95, –75.17); Baltimore
    (39.28, –76.62); Charlotte (35.23, –80.85); Memphis (35.12, –89.97); Jacksonville
    (30.32, –81.70); Houston (29.77, –95.38); Austin (30.27, –97.77); San Antonio
    (29.53, –98.47); Fort Worth (32.75, –97.33); Dallas (32.78, –96.80); San Diego
    (32.78, –117.15); Los Angeles (34.05, –118.25); San Jose (37.30, –121.87); San
    Francisco (37.78, –122.42); Indianapolis (39.78, –86.15); Phoenix (33.45, –112.07);
    Columbus (39.98, –82.98); Chicago (41.88, –87.63); and Detroit (42.33, –83.05).
    Visualize the cities and the generated solution as a NetworkX graph using the
    GPS coordinates of each city.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F11_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.11 Travelling salesman problem (TSP) for 20 largest US cities
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Solve the crossword puzzle in figure C.12.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F12_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.12 Simulated annealing crossword puzzle
  prefs: []
  type: TYPE_NORMAL
- en: Across
  prefs: []
  type: TYPE_NORMAL
- en: 6.   An optimization process that searches an energy landscape to find the optimal
    or near-optimal solution by applying quantum effects
  prefs: []
  type: TYPE_NORMAL
- en: 7.   The probability of acceptance or rejection of neighboring solutions
  prefs: []
  type: TYPE_NORMAL
- en: 10.   A cooling process by which the temperature is decreased very quickly during
    the first iterations but the speed of the exponential decay is slowed down later
  prefs: []
  type: TYPE_NORMAL
- en: 11.   A cooling schedule in which the maximum number of iterations needs to
    be specified
  prefs: []
  type: TYPE_NORMAL
- en: 12.   Compared to this search algorithm, the main difference is that SA probabilistically
    allows downward steps controlled by current temperature and how bad a move is.
  prefs: []
  type: TYPE_NORMAL
- en: 13.   A cooling schedule that requires a prohibitive computing time
  prefs: []
  type: TYPE_NORMAL
- en: Down
  prefs: []
  type: TYPE_NORMAL
- en: 1.   A stochastic or probabilistic model that describes a sequence of possible
    moves in which the probability of each move depends only on the state attained
    in the previous move
  prefs: []
  type: TYPE_NORMAL
- en: 2.   A cooling schedule that explicitly takes into consideration how the search
    is progressing
  prefs: []
  type: TYPE_NORMAL
- en: 3.   A cooling schedule that decreases the temperature by a cooling factor
  prefs: []
  type: TYPE_NORMAL
- en: 4.   An optimization process based on the physical annealing process
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Probability distribution used in transition probability of simulated annealing
  prefs: []
  type: TYPE_NORMAL
- en: 8.   A quantum mechanical phenomenon whereby a wavefunction can propagate through
    a potential barrier
  prefs: []
  type: TYPE_NORMAL
- en: 9.   State of the system at which no better or worse moves are being accepted
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Spaces and dashes *must* be used if the answer consists of two words.'
  prefs: []
  type: TYPE_NORMAL
- en: C.4.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  prefs: []
  type: TYPE_NORMAL
- en: 1.1   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.2   b) False
  prefs: []
  type: TYPE_NORMAL
- en: 1.3   b) False (Dual annealing is an implementation of the generalized simulated
    annealing algorithm.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.4   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.5   b) False (The simulated annealing algorithm exploits the search space
    when the temperature gets lower.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.6   c) Logarithmic cooling schedule
  prefs: []
  type: TYPE_NORMAL
- en: 1.7   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The generic forms of __problem_base.py and _sa.py, provided in the book’s
    GitHub repo, can be used to solve this problem. You can also modify listing 5.1
    or 5.2 to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   You can use listing 5.5 or the ASA-GS implementation [1] to run simulated
    annealing with selected parameters on different TSP instances and report your
    results. In listing 5.5, replace the permanent link with the link corresponding
    to the TSP instance. For example, click on burma14.tsp, click on the button with
    three dots at the upper-right corner, and select Copy Permalink. Consider tuning
    the algorithm’s parameters to get close to the best tour length known (so far)
    for each dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   The next listing shows how to use the generic solver implemented as part
    of the optalgo-tools package to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.3 Solving TSP using SA
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As a continuation of listing C.3, the following code shows how to solve this
    problem using the simanneal Python library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ① Test the annealer with a TSP as per the simanneal module.
  prefs: []
  type: TYPE_NORMAL
- en: ② Swap two cities in the route.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Calculate the length of the route.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Initial state, a randomly ordered itinerary
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set New York City as the home city.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the route and its cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation, the following code can be used to visualize the problem
    and its solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ① Reverse the lat and long for a correct visualization.
  prefs: []
  type: TYPE_NORMAL
- en: ② Create an independent shallow copy of the graph and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Draw the closest edges on each node only.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Draw the route.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Visualize.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code produces the visualization shown in figure C.13.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F13_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.13 Solution for the 20 major US cities TSP using simanneal
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A shows examples of available Python libraries, such as scikit-opt,
    DEAP, OR-Tools and simanneal, that can solve this problem using simulated annealing
    and other metaheuristics.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   The solution to the crossword puzzle is shown in figure C.14.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F14_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.14 Simulated annealing crossword puzzle solution
  prefs: []
  type: TYPE_NORMAL
- en: 'C.5 Chapter 6: Tabu search'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.5.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   In TS, non-improving solutions are conditionally accepted in order to
    escape from a local optimum.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   A frequency-based memory maintains information about how recently a search
    point has been visited.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   In order to increase the efficiency for solving some problems, TS uses
    memory via a tabu list to avoid revisiting recently visited neighborhoods.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   The stopping criteria to terminate TS can be
  prefs: []
  type: TYPE_NORMAL
- en: a.  Neighborhood is empty
  prefs: []
  type: TYPE_NORMAL
- en: b.  Number of iterations is larger than a specified threshold
  prefs: []
  type: TYPE_NORMAL
- en: c.  Evidence shows that an optimum solution has been obtained
  prefs: []
  type: TYPE_NORMAL
- en: d.  All of the above (a, b, and c)
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above (a, b, or c)
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Tabu-active moves are stored in a long-term memory.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   For large and difficult problems (scheduling, quadratic assignment, and
    vehicle routing), tabu search obtains solutions that often represent a global
    optimum or near-optimum.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   Recency memory is used to increase intensification of the search by remembering
    neighbors with good solutions.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   Aspiration criteria are used to revoke tabu-active moves as a way to
    avoid search stagnation.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   TS can be considered a combination of random search and memory structures.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. When the length of the tabu list is too small, the algorithm can get trapped
    in cycles, and when it’s too long, many moves could be prevented at each iteration,
    leading to stagnation.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 2.   As shown in appendix B, the Schwefel function is complex, with many local
    minima. Figure C.15 shows the two-dimensional form of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F15_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.15 The Schwefel function
  prefs: []
  type: TYPE_NORMAL
- en: Modify listing 6.1 to solve the Schwefel function using tabu search.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Apple filed US Patent 7790637 B2 for a composite laminate that includes
    seven sheets stacked one over another and a scrim layer. Seven planar sheets of
    fibers impregnated with a resin (e.g., a viscous liquid substance) are placed
    with different orientations to improve the strength of the composite laminate,
    as illustrated in figure C.16\. The scrim layer is the cosmetic layer, which is
    a different material and is bonded to the outside to improve the cosmetic exterior
    surface and consistent appearance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F16_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.16 Composite laminate design—Apple’s US patent 7790637 B2
  prefs: []
  type: TYPE_NORMAL
- en: The way the seven layers are ordered results in different levels of strength
    in the composite laminate. Assume that the pairwise strength gain or loss is given
    by the empirical values in figure C.17\. Positive values represent a strength
    gain in the case of contact between the two layers (up or down), and negative
    values represent the strength loss.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F17_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.17 Pairwise strength gain or loss
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we want to find the optimal ordered combination (i.e., permutation)
    of the seven fiber sheets to maximize the composite laminate strength. Perform
    four hand iterations of tabu search to show the steps of the algorithm to solve
    this problem. Write Python code to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Write Python code to use tabu search to solve the simple assembly line
    balancing problem, type 1 (SALBP-1), with the machine and worker constraints described
    in Kamarudin and Rashid’s paper “Modelling of Simple Assembly Line Balancing Problem
    Type 1 (SALBP-1) with Machine and Worker Constraints” [3].
  prefs: []
  type: TYPE_NORMAL
- en: 5.   In the word search puzzle in figure C.18, find the hidden terms commonly
    used in tabu search. You can search horizontally (from left to right or right
    to left), vertically (from top to bottom or bottom to top), or diagonally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F18_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.18 TS word search puzzle
  prefs: []
  type: TYPE_NORMAL
- en: C.5.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   b) False (Recency-based memory maintains information about how recently
    a search point has been visited.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   d) All of the above (a, b, and c)
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   b) False (Tabu-active moves are stored in a short-term memory.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   b) False (TS can be considered a combination of combination of local
    search and memory structures.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. a) True
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Listing C.4 in the book’s GitHub repository shows how to solve the Schwefel
    function using tabu search.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Figure C.19 shows the TS initialization and first iteration for the composite
    laminate problem. The number of possible permutations without repetition is *n*!.
    The number of possible solutions for ordering the seven fiber sheets is 7! = 5,040.
    To generate a neighboring solution, fiber sheet swapping can be used. The neighborhood
    is defined as any other solution that is obtained by a pairwise exchange of any
    two sheets in the solution. If we let the number of nodes *n* = 7, pairwise exchange
    *k* = 2. The number of neighbors is the number of combinations without repetition
    *C*(*n*,*k*) or *n*-choose-*k*: *C*(*n*,*k*) = *n*! / (*k*!(*n* – *k*)!) = 21
    neighbors. Let’s assume that the tabu tenure is set at 3 iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F19_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.19 TS initialization for the composite laminate design
  prefs: []
  type: TYPE_NORMAL
- en: Figures C.20 through C.22 show iterations 1, 2, and 3 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F20_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.20 Composite laminate design—iteration 1
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F21_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.21 Composite laminate design—iteration 2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F22_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.22 Composite laminate design—iteration 3
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration, we generate a number of candidate solution using layer swapping,
    and we select the move that results in the maximum delta value, which is the difference
    between the previous solution and the new solution in terms of strength gain.
    In the next iteration, shown in figure C.23, there is no move with a positive
    gain, so the best (non-tabu) move will be non-improving. The move (a,e) is selected,
    since it has a tabu tenure of only one iteration compared to the other tabu-active
    best move (a,b). This means that the tabu status of (a,e) can be overridden by
    applying the aspiration criteria.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F23_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.23 Composite laminate design—TS iteration 4 and aspiration criterion
  prefs: []
  type: TYPE_NORMAL
- en: To show the diversification using frequency-based memory, assume that the solution
    reached after 26 iterations is [a c f b g e d], and the strength value is 23\.
    Assume that we will penalize the solution based on its frequency in usage (a highly
    repetitive solution gets more penalties). The tabu structure is updated based
    on both recency-based (upper triangle) and frequency-based (lower triangle) memories,
    as shown in figure C.24a. The five top candidates after swapping are shown in
    figure C.24b.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F24_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.24 a) Recency- and frequency-based memory, b) five top candidates after
    swapping with their penalty values
  prefs: []
  type: TYPE_NORMAL
- en: We need to diversify when no admissible improving moves exist. Non-improving
    moves are penalized by assigning larger penalties to more frequent swaps. According
    to the penalized value, swap (a,f) is chosen. Listing C.5 shows the solution of
    the composite laminate problem using tabu search.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.5 Solving the composite laminate problem using tabu search
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ① Import the SHEETS problem instance, which contains the composite laminate
    design problem description.
  prefs: []
  type: TYPE_NORMAL
- en: ② Import the tabu search solver.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create different sheets objects. For a complete list of the supported parameters,
    see the SHEETS class in the sheets.py file in the optalgotools.problems module.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a TS object to help in solving the composite laminate problem.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Get an initial random solution, and check its cost.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Run TS, and evaluate the best solution cost.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Listing C.6 shows a snippet of the code for solving the SALBP-1 problem
    using tabu search.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.6 Solving the SALBP-1 problem using tabu search
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ① Read the data from appendix B directly using the URL.
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the cycle time.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Get an initial solution.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Ensure the feasibility of the solution considering the task precedence constraint.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Run the tabu search.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Calculate the smoothing index of the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Visualize the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the complete code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Complete code is available in the book’s GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   The solution to the word search puzzle is shown in figure C.25.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F25_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.25 TS word search puzzle solution
  prefs: []
  type: TYPE_NORMAL
- en: The word directions and start points are formatted as (Direction, *X, Y*)
  prefs: []
  type: TYPE_NORMAL
- en: ADAPTIVE MEMORY (W, 17, 13)
  prefs: []
  type: TYPE_NORMAL
- en: ASPIRATION CRITERIA (W, 23, 15)
  prefs: []
  type: TYPE_NORMAL
- en: DIVERSIFICATION (W, 23, 14)
  prefs: []
  type: TYPE_NORMAL
- en: FREQUENCY-BASED MEMORY (W, 21, 7)
  prefs: []
  type: TYPE_NORMAL
- en: INTENSIFICATION (E, 8, 8)
  prefs: []
  type: TYPE_NORMAL
- en: LOCAL SEARCH (W, 16, 6)
  prefs: []
  type: TYPE_NORMAL
- en: LONG-TERM MEMORY (E, 1, 10)
  prefs: []
  type: TYPE_NORMAL
- en: RECENCY (E, 12, 1)
  prefs: []
  type: TYPE_NORMAL
- en: RESPONSIVE EXPLORATION (W, 23, 16)
  prefs: []
  type: TYPE_NORMAL
- en: SENSORY MEMORY (W, 16, 3)
  prefs: []
  type: TYPE_NORMAL
- en: SHORT-TERM MEMORY (W, 16, 4)
  prefs: []
  type: TYPE_NORMAL
- en: TABU LIST (E, 6, 12)
  prefs: []
  type: TYPE_NORMAL
- en: TABU SEARCH (E, 1, 5)
  prefs: []
  type: TYPE_NORMAL
- en: TABU STRUCTURE (W, 23, 2)
  prefs: []
  type: TYPE_NORMAL
- en: TABU TENURE (E, 12, 5)
  prefs: []
  type: TYPE_NORMAL
- en: WORKING MEMORY (W, 20, 9)
  prefs: []
  type: TYPE_NORMAL
- en: 'C.6 Chapter 7: Genetic algorithm'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.6.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   Given a binary string 1101001100101101 and another binary string yxyyxyxxyyyxyxxy
    in which the values 0 and 1 are denoted by x and y, what offspring result from
    applying 1-point crossover on the two strings at a randomly selected recombination
    point?
  prefs: []
  type: TYPE_NORMAL
- en: a.  yxxyyyxyxxy11010 and yxyyx01100101101
  prefs: []
  type: TYPE_NORMAL
- en: b.  11010yxxyyyxyxxy and yxyyx01100101101
  prefs: []
  type: TYPE_NORMAL
- en: c.  11010yxxyyyxyxxy and 01100101101yxyyx
  prefs: []
  type: TYPE_NORMAL
- en: d.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   In binary genetic algorithms, how does the bitwise mutation operator
    work?
  prefs: []
  type: TYPE_NORMAL
- en: a.  It swaps the positions of two randomly chosen bits.
  prefs: []
  type: TYPE_NORMAL
- en: b.  It averages the values of two randomly chosen bits.
  prefs: []
  type: TYPE_NORMAL
- en: c.  It flips a randomly chosen bit in the binary representation.
  prefs: []
  type: TYPE_NORMAL
- en: d.  It reverses the order of a randomly chosen segment of bits.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   The name of the position on the chromosome every gene has is called
  prefs: []
  type: TYPE_NORMAL
- en: a.  Allele
  prefs: []
  type: TYPE_NORMAL
- en: b.  Locus
  prefs: []
  type: TYPE_NORMAL
- en: c.  Genotype
  prefs: []
  type: TYPE_NORMAL
- en: d.  Phenotype
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   In the steady-state model of genetic algorithms, how are new offspring
    introduced into the population?
  prefs: []
  type: TYPE_NORMAL
- en: a.  By replacing the entire population
  prefs: []
  type: TYPE_NORMAL
- en: b.  By replacing a small fraction of the population
  prefs: []
  type: TYPE_NORMAL
- en: c.  By adding them to the existing population
  prefs: []
  type: TYPE_NORMAL
- en: d.  By replacing the worst individuals in the population
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Suppose you have the population shown in table C.2.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.2 Given population
  prefs: []
  type: TYPE_NORMAL
- en: '| Individual | Individual 1 | Individual 2 | Individual 3 | Individual 4 |
    Individual 5 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Fitness | 12 | 25 | 8 | 53 | 10 |'
  prefs: []
  type: TYPE_TB
- en: 'Rank-based selection attempts to remove problems of fitness-proportionate selection
    (FPS) by basing selection probabilities on relative rather than absolute fitness.
    Assume that the ranking process is linear ranking, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F25_Khamis-EQ01.png)'
  prefs: []
  type: TYPE_IMG
- en: where *N* is the number of individuals in the population and *r* is the rank
    associated with each individual in this population (the least fit individual has
    *r* = 1, the fittest individual *r* = *N*). *SP* is the selection pressure (assume
    *SP* = 1.5). Which two individuals will be selected if we use this linear ranking-based
    selection?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Individuals 1 and 2
  prefs: []
  type: TYPE_NORMAL
- en: b.  Individuals 1 and 3
  prefs: []
  type: TYPE_NORMAL
- en: c.  Individuals 2 and 3
  prefs: []
  type: TYPE_NORMAL
- en: d.  Individuals 2 and 4
  prefs: []
  type: TYPE_NORMAL
- en: e.  Individuals 3 and 4
  prefs: []
  type: TYPE_NORMAL
- en: f.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   Which selection method in genetic algorithms involves choosing a fixed
    number of individuals at random and selecting the best among them?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Roulette wheel selection
  prefs: []
  type: TYPE_NORMAL
- en: b.  Rank selection
  prefs: []
  type: TYPE_NORMAL
- en: c.  Tournament selection
  prefs: []
  type: TYPE_NORMAL
- en: d.  Stochastic universal sampling (SUS)
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   In P-metaheuristics, the computational cost of the Latin hypercube strategy
    is the same as the pseudo-random initialization strategy.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   In binary genetic algorithms, which type of chromosome encoding is used?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Real value
  prefs: []
  type: TYPE_NORMAL
- en: b.  Permutation
  prefs: []
  type: TYPE_NORMAL
- en: c.  Binary
  prefs: []
  type: TYPE_NORMAL
- en: d.  Tree
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   Which of the following methods can be used to convert a minimization
    problem into a maximization problem in optimization?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Adding a constant to the objective function
  prefs: []
  type: TYPE_NORMAL
- en: b.  Taking the reciprocal of the objective function
  prefs: []
  type: TYPE_NORMAL
- en: c.  Negating the objective function
  prefs: []
  type: TYPE_NORMAL
- en: d.  Scaling the objective function by a factor
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. Which of the following is an advantage of the steady-state model compared
    to the generational model in genetic algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Faster convergence
  prefs: []
  type: TYPE_NORMAL
- en: b.  Better diversity preservation
  prefs: []
  type: TYPE_NORMAL
- en: c.  Lower computational cost
  prefs: []
  type: TYPE_NORMAL
- en: d.  More robust mutation operators
  prefs: []
  type: TYPE_NORMAL
- en: 1.11. In a binary genetic algorithm, what does the mutation operator do to an
    individual’s genes?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Reverses the gene value (1 to 0 or 0 to 1)
  prefs: []
  type: TYPE_NORMAL
- en: b.  Randomly assigns a new gene value (0 or 1)
  prefs: []
  type: TYPE_NORMAL
- en: c.  Swaps the positions of two genes
  prefs: []
  type: TYPE_NORMAL
- en: d.  Combines genes from different individuals
  prefs: []
  type: TYPE_NORMAL
- en: 1.12. Which of the following is a commonly used crossover method in binary genetic
    algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Single-point crossover
  prefs: []
  type: TYPE_NORMAL
- en: b.  Two-point crossover
  prefs: []
  type: TYPE_NORMAL
- en: c.  Uniform crossover
  prefs: []
  type: TYPE_NORMAL
- en: d.  All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.13. What is the primary difference between generational and steady-state models
    in genetic algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Selection methods
  prefs: []
  type: TYPE_NORMAL
- en: b.  Crossover operators
  prefs: []
  type: TYPE_NORMAL
- en: c.  Mutation operators
  prefs: []
  type: TYPE_NORMAL
- en: d.  Replacement strategies
  prefs: []
  type: TYPE_NORMAL
- en: 1.14. Which crossover method in binary genetic algorithms involves exchanging
    genetic material between parent chromosomes based on a predefined probability
    for each gene?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Single-point crossover
  prefs: []
  type: TYPE_NORMAL
- en: b.  Two-point crossover
  prefs: []
  type: TYPE_NORMAL
- en: c.  Uniform crossover
  prefs: []
  type: TYPE_NORMAL
- en: d.  Arithmetic crossover
  prefs: []
  type: TYPE_NORMAL
- en: 1.15. What is a potential disadvantage of using a high mutation rate in binary
    genetic algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Loss of diversity in the population
  prefs: []
  type: TYPE_NORMAL
- en: b.  Premature convergence
  prefs: []
  type: TYPE_NORMAL
- en: c.  Disruption of good solutions
  prefs: []
  type: TYPE_NORMAL
- en: d.  Decreased selection pressure
  prefs: []
  type: TYPE_NORMAL
- en: 1.16. In the generational model of genetic algorithms, what happens to the population
    in each generation?
  prefs: []
  type: TYPE_NORMAL
- en: a.  A small fraction of the population is replaced.
  prefs: []
  type: TYPE_NORMAL
- en: b.  The entire population is replaced.
  prefs: []
  type: TYPE_NORMAL
- en: c.  The population remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: d.  The population size is gradually reduced.
  prefs: []
  type: TYPE_NORMAL
- en: 1.17. When using a transformation to convert a minimization problem into a maximization
    problem, which property of the optimal solution must be preserved?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Feasibility
  prefs: []
  type: TYPE_NORMAL
- en: b.  Optimality
  prefs: []
  type: TYPE_NORMAL
- en: c.  Dominance
  prefs: []
  type: TYPE_NORMAL
- en: d.  Convexity
  prefs: []
  type: TYPE_NORMAL
- en: 1.18. What are the primary operators used in genetic algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Initialization, pooling, and backpropagation
  prefs: []
  type: TYPE_NORMAL
- en: b.  Selection, crossover, and mutation
  prefs: []
  type: TYPE_NORMAL
- en: c.  Convolution, pooling, and activation
  prefs: []
  type: TYPE_NORMAL
- en: d.  Forward propagation, backward propagation, and optimization
  prefs: []
  type: TYPE_NORMAL
- en: 1.19. Which of the following is an advantage of the generational model compared
    to the steady-state model in genetic algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: b.  Improved diversity preservation
  prefs: []
  type: TYPE_NORMAL
- en: b.  Faster convergence
  prefs: []
  type: TYPE_NORMAL
- en: c.  Lower computational cost
  prefs: []
  type: TYPE_NORMAL
- en: d.  Better handling of constraints
  prefs: []
  type: TYPE_NORMAL
- en: '1.20. Suppose you need to solve the following function maximization problem
    using a binary genetic algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F25_Khamis-EQ02.png)'
  prefs: []
  type: TYPE_IMG
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *O[i]* is the objective function value of individual *i* and *O[i]* = –(*x*
    – 6.4)².
  prefs: []
  type: TYPE_NORMAL
- en: •   *N* is the population size.
  prefs: []
  type: TYPE_NORMAL
- en: •   *V* is a large value to ensure non-negative fitness values.
  prefs: []
  type: TYPE_NORMAL
- en: The value of *V* is the maximum value of the second term of the fitness function
    *f*(*x*) so that the fitness value corresponding to the maximum value of the objective
    function is 0\. How many bits are required to represent the solution with precision
    0.1?
  prefs: []
  type: TYPE_NORMAL
- en: a.   6 bits
  prefs: []
  type: TYPE_NORMAL
- en: b.   7 bits
  prefs: []
  type: TYPE_NORMAL
- en: c.   8 bits
  prefs: []
  type: TYPE_NORMAL
- en: d.   9 bits
  prefs: []
  type: TYPE_NORMAL
- en: e. 10 bits
  prefs: []
  type: TYPE_NORMAL
- en: f.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The Ackley function is a nonlinear, multimodal function with a large number
    of local minima, making it a challenging optimization problem. The general form
    of the Ackley function is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F25_Khamis-EQ03.png)'
  prefs: []
  type: TYPE_IMG
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *x* = (*x*[1], *x*[2], ..., *x[d]*) is the input vector.
  prefs: []
  type: TYPE_NORMAL
- en: •   *a, b*, and *c* are positive constants (usually *a* = 20, *b* = 0.2, and
    *c* = 2 × *π*).
  prefs: []
  type: TYPE_NORMAL
- en: •   d is the dimension of the input vector.
  prefs: []
  type: TYPE_NORMAL
- en: The function has a global minimum at the origin (*x[i] =* 0), where *f(x) =*
    0, and it is surrounded by several local minimam, as shown in figure C.26.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F26_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.26 The Ackley function
  prefs: []
  type: TYPE_NORMAL
- en: The presence of these local minima makes it difficult for optimization algorithms
    to find the global minimum, especially those that can get stuck in local minima.
    Write Python code to solve a 6D Ackley function.
  prefs: []
  type: TYPE_NORMAL
- en: C.6.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   b) 11010yxxyyyxyxxy and yxyyx01100101101
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   c) It flips a randomly chosen bit in the binary representation.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   b) Locus
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   b) By replacing a small fraction of the population
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Considering the following linear ranking
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F26_Khamis-EQ04.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Individual | Individual 1 | Individual 2 | Individual 3 | Individual 4 |
    Individual 5 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Fitness | 12 | 25 | 8 | 53 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Ranking r | 3 | 4 | 1 | 5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| p(r) | 0.175 | **0**.**2** | 0.125 | **0**.**225** | 0.15 |'
  prefs: []
  type: TYPE_TB
- en: Individuals 4 and 2 will be selected, as they have the highest probability.
    So the correct answer is d.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   c) Tournament selection
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   c) Binary
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   b and c) Taking the reciprocal of the objective function, and negating
    the objective function
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. c) Lower computational cost
  prefs: []
  type: TYPE_NORMAL
- en: 1.11. a) Reverses the gene value (1 to 0 or 0 to 1)
  prefs: []
  type: TYPE_NORMAL
- en: 1.12. d) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.13. d) Replacement strategies
  prefs: []
  type: TYPE_NORMAL
- en: 1.14. c) Uniform crossover
  prefs: []
  type: TYPE_NORMAL
- en: 1.15. c) Disruption of good solutions
  prefs: []
  type: TYPE_NORMAL
- en: 1.16. b) The entire population is replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 1.17. b) Optimality
  prefs: []
  type: TYPE_NORMAL
- en: 1.18. b) Selection, crossover, and mutation
  prefs: []
  type: TYPE_NORMAL
- en: 1.19. a) Improved diversity preservation
  prefs: []
  type: TYPE_NORMAL
- en: 1.20. d) 9 bits
  prefs: []
  type: TYPE_NORMAL
- en: Given 0.0 <= *x* <= 31.5 with a precision of 0.1
  prefs: []
  type: TYPE_NORMAL
- en: '•   Calculate the range size: (31.5 – 0) = 31.5'
  prefs: []
  type: TYPE_NORMAL
- en: '•   Divide the range size by the desired precision: 31.5 / 0.1 = 315'
  prefs: []
  type: TYPE_NORMAL
- en: '•   Round up to the nearest whole number: 315'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have 315 steps (values) to represent the numbers from 0.0 to 31.5 with
    a precision of 0.1:'
  prefs: []
  type: TYPE_NORMAL
- en: number_of_bits = ceil(log[2](number_of_steps)) = ceil(log[2](315)) ≈ ceil(8.29)
    = 9
  prefs: []
  type: TYPE_NORMAL
- en: 'So you need 9 bits to represent the numbers from 0.0 to 31.5 with a precision
    of 0.1.2\. Listing C.8 shows a snippet of the code to solve the Ackley function
    using a genetic algorithm implemented from scratch or based on the pymoo open
    source library. We start by defining constants for the genetic algorithm and Ackley
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.8 Solving the Ackley function using GA
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the `decode` function to convert the binary genome to real values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function defines the fitness function (Ackley function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now define the crossover function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The mutation function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s time to create an initial population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now run the genetic algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: ① Calculate the fitness score for each genome in the population.
  prefs: []
  type: TYPE_NORMAL
- en: ② Print out the best fitness score for each generation.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Select the best half of the population to act as parents for the next generation.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Generate the next generation by applying crossover and mutation.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Replace the current population with the new generation of children.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can print the best genome and its fitness as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can print the best genome, decode the best genome, and then print the decision
    variables in real values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can solve this problem faster using GA implemented in pymoo as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'C.7 Chapter 8: Genetic algorithm variants'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.7.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Assume that a company is trying to choose the optimal location for a new
    facility. The decision variables *x*[1] and *x*[2] represent the coordinates of
    the potential location for the new facility in a 2D plane. The company needs to
    minimize the distance squared between the new facility and an existing facility
    at the location (2, 1). This could represent the need to minimize transportation
    costs between the two facilities. Moreover, the company aims to maximize the distance
    squared between the new facility and a competitor’s facility at the location (3,
    4). This could represent the need to establish a competitive advantage by distancing
    the new facility from the competitor. The new facility must be located within
    a certain region due to zoning regulations or other restrictions. It also must
    adhere to environmental constraints or property boundaries. This multi-objective
    constrained optimization problem can be formulated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize *f*[1](*x*[1], *x*[2]) = √((*x*[1] – 2)² + (*x*[2] – 1)²) (distance
    between the company facilities)
  prefs: []
  type: TYPE_NORMAL
- en: Maximize *f*[1](*x*[1], *x*[2]) = √((*x*[1] – 3)² + (*x*[2] – 4)²) (distance
    between the new facility and a competitor’s facility)
  prefs: []
  type: TYPE_NORMAL
- en: such that
  prefs: []
  type: TYPE_NORMAL
- en: '*g*[1](*x*[1], *x*[2]) = 2*x*[1] + *x*[2] – 6 ≤ 0 (zoning regulations)'
  prefs: []
  type: TYPE_NORMAL
- en: '*g*[2](*x*[1], *x*[2]) = 2*x*[1] – *x*[2] – 2 ≤ 0 (environmental constraints
    or property boundaries)'
  prefs: []
  type: TYPE_NORMAL
- en: 0 ≤ *x*[1] ≤ 5 (boundary constraint)
  prefs: []
  type: TYPE_NORMAL
- en: 0 ≤ *x*[2] ≤ 5 (boundary constraint)
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code to find the optimal location for the new facility.
  prefs: []
  type: TYPE_NORMAL
- en: '2.   The All Ones problem, also known as the Max Ones problem, is a simple
    problem that aims to maximize the number of ones in a binary string of a fixed
    length. For a 10-bit All Ones problem, the optimal solution takes this form: [1111111111].
    The problem is described by K. Sutner in his article “Linear cellular automata
    and the Garden-of-Eden” [4] as follows: suppose each of the squares of an *n*
    × *n* chessboard is equipped with an indicator light and a button. If a square’s
    button is pressed, the light for that square will change from off to on or vice
    versa; the same happens to the lights of all the edge-adjacent squares. Initially
    all lights are off. The goal of the All Ones problem is to find a sequence of
    buttons that can be pressed in such a way that all lights are on at the end. This
    problem itself may not have direct applications, but it is used as a test problem
    to compare the performance of various algorithms. Write Python code to find a
    solution for the 10-bit All Ones problem using a genetic algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Assume that there are 10 parcels to be loaded in the cargo bike in figure
    C.27.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F27_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.27 Cargo bike loading problem for 10 items with given weight, profit,
    and efficiency (profit/weight)
  prefs: []
  type: TYPE_NORMAL
- en: Each parcel has its own weight, profit, and efficiency value (profit per kg).
    The goal is to select the parcels to be loaded in such a way that the utility
    function *f*[1] is maximized and the weight function *f*[2] is minimized.
  prefs: []
  type: TYPE_NORMAL
- en: '*f*[1] = Σ*E[i]*, *i* = 0, 1, ..., *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*f*[2] = |Σ*w[i]* – *C*|, 50 is added if and only if Σ*w[i]* > *C*.'
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *n* is the total number of packages.
  prefs: []
  type: TYPE_NORMAL
- en: •   *E[i]* is the efficiency of package *i*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *w[i]* is the weight of package *i*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *C* is the maximum capacity of the bike.
  prefs: []
  type: TYPE_NORMAL
- en: A penalty of 50 is added if and only if the total weight of the added parcels
    exceeds the maximum capacity. Write Python code to determine which items should
    be loaded for maximum efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: '4.   In the opencast mining problem described by Guéret et al. in their book
    “Linear programming” [5], the opencast uranium mine is divided into blocks for
    exploitation. As illustrated in figure C.28, there are 18 blocks of 10,000 tons
    on three levels, identified based on the results of test drilling. The pit needs
    to be terraced to allow trucks to reach the bottom, and the pit is limited in
    the west by a village and in the east by a group of mountains. To extract a block,
    three blocks of the level above it need to be extracted due to constraints on
    the slope: the block immediately on top of it, and the blocks to the right and
    to the left. There are different costs associated with extracting blocks depending
    on their level. Level 1 blocks cost $100 per ton to extract, level 2 blocks cost
    $200 per ton, and level 3 blocks cost $300 per ton. However, the hatched blocks,
    which are formed of a very hard rock rich in quartz, cost $1,000 per ton to extract.
    The blocks that contain uranium are displayed in a gray shade: these are blocks
    0, 6, 9, 11, 16, and 17\. These blocks have different market values, with block
    17 being rich in ore but made of the same hard rock as the other hatched blocks.
    The market values of blocks 0, 6, 9, 11, 16, and 17 are $200, $300, $500, $200,
    $1,000, and $1,200 per ton, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F28_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.28 Opencast mining problem
  prefs: []
  type: TYPE_NORMAL
- en: a.  Write a Python code to determine which blocks to extract to maximize the
    total profit, given by Σ(VALUE – COST) × *x[i]* for *x* = 0,1,…,17, where *x[i]*
    is an assignment binary variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'b.  Assume that the time duration required to process the blocks is [1, 1,
    1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 4, 4, 3, 4] depending on the block level and
    the hardness of the block. Write Python code to determine which blocks to extract
    to maximize the discounted profit and increased cost given by the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F28_Khamis-EQ14a.png)'
  prefs: []
  type: TYPE_IMG
- en: '5.   In the Chapter 8/Projects folder in the book’s GitHub repository, the
    following sample research projects are provided for review and experimentation:'
  prefs: []
  type: TYPE_NORMAL
- en: •   *Routing*—Addresses using the genetic algorithm to find the shortest path
    between two points of interest in Vaughan, a municipality to the north of Toronto.
  prefs: []
  type: TYPE_NORMAL
- en: •   *Bus routing*—Addresses the school bus routing problem, formulating the
    problem as a contained multi-objective optimization problem. The cluster-first
    route-second scheme, genetic algorithm, and adaptive genetic algorithm are applied
    to solve this problem. The performance of these algorithms is evaluated using
    real data from public schools in the city of Winchester, Virginia, USA.
  prefs: []
  type: TYPE_NORMAL
- en: '•   *Location allocation*—Tackles the placement of drone delivery stations
    using bio-inspired optimization algorithms. The solution framework consists of
    two stages: the first tackles the location planning problem of stations, while
    the second deals with the allocation of delivery demand to located stations.'
  prefs: []
  type: TYPE_NORMAL
- en: C.7.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   The next listing shows how to solve the facility allocation problem using
    NSGA-II.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.9 Solving the facility allocation problem using NSGA-II
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: ① Zooning constraint
  prefs: []
  type: TYPE_NORMAL
- en: ② Environment/property constraint
  prefs: []
  type: TYPE_NORMAL
- en: The complete listing, available in the book’s GitHub repository, also shows
    how to perform decision making to select the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The All Ones problem solution is shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.10 Solving the All Ones problem using GA
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code defines an `AllOnes` class that extends the `Problem` class from pymoo.
    The `_evaluate` method of the `AllOnes` class calculates the fitness of an individual
    by counting the number of ones in the binary string and returning the negative
    of that count (because pymoo minimizes objective functions).
  prefs: []
  type: TYPE_NORMAL
- en: 3.   The solution to the cargo bike loading problem is shown in the next listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.11 Solving the cargo bike loading problem using GA
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: ① Define the problem.
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the problem inputs.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create a problem instance.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the genetic algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Run the optimization.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the results.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Visualize the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code produces the solution shown in figure C.29.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F29_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.29 Cargo bike loading solution
  prefs: []
  type: TYPE_NORMAL
- en: 4.   The next listing shows the steps to solve the opencast mining problem.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.12 Solving the opencast mining problem
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ① Blocks in the mine
  prefs: []
  type: TYPE_NORMAL
- en: ② Blocks in levels 2 and 3
  prefs: []
  type: TYPE_NORMAL
- en: ③ Cost of blocks.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Value of blocks
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Define the ARC for each block in LEVEL23.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation, you can visualize the precedence of extraction of blocks
    in levels 2 and 3 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ① Create the directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: ② Add the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Add precedence edges.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a pos dictionary with a default position for all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Update the positions of nodes that have a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Draw the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Figure C.30 shows the precedence graph for extracting blocks in levels 2 and
    3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F30_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.30 Precedence graph for extracting blocks in levels 2 and 3
  prefs: []
  type: TYPE_NORMAL
- en: As a continuation of listing C.12, the following code snippet shows how to define
    the problem as a single objective constrained optimization problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define the GA solver and apply it to solve the problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The complete version of listing C.12 in the book’s GitHub repository includes
    the Pareto optimization implementation, which treats the problem as a multi-objective
    optimization problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.8 Chapter 9: Particle swarm optimization'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.8.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   Which of the following is a drawback of the star structure in PSO?
  prefs: []
  type: TYPE_NORMAL
- en: a.  It may lead to premature convergence to a suboptimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: b.  It may cause the algorithm to converge too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: c.  It may cause the algorithm to become stuck in local optima.
  prefs: []
  type: TYPE_NORMAL
- en: d.  It does not allow the algorithm to explore the search space effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   Asynchronous PSO usually produces better results because it causes the
    particles to use more up-to-date information.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   What is the difference between the cognitive and social components in
    PSO?
  prefs: []
  type: TYPE_NORMAL
- en: a.  The cognitive component is based on the particle’s own experience, while
    the social component is based on the experience of the swarm as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: b.  The cognitive component is based on the experience of the particle’s neighbors,
    while the social component is based on the particle’s own experience.
  prefs: []
  type: TYPE_NORMAL
- en: c.  The cognitive component is based on random perturbations, while the social
    component is based on gradient information.
  prefs: []
  type: TYPE_NORMAL
- en: d.  The cognitive and social components are the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   Ring topology, or lbest PSO, has been shown to converge faster than other
    network structures, but with a susceptibility to be trapped in local minima.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   In binary PSO (BPSO), each bit in the binary strings is updated by considering
    its current state, the best state it has held so far, and the best state of its
    neighboring bits.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   In PSO, the velocity model that makes particles behave like independent
    hill climbers is
  prefs: []
  type: TYPE_NORMAL
- en: a.  Cognitive-only model
  prefs: []
  type: TYPE_NORMAL
- en: b.  Social-only model
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   PSO is guaranteed to find the global optimum of a function.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   What is the role of the acceleration coefficients in the PSO algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: a.  To control the speed of the particles
  prefs: []
  type: TYPE_NORMAL
- en: b.  To control the exploration/exploitation trade-off
  prefs: []
  type: TYPE_NORMAL
- en: c.  To control the swarm size
  prefs: []
  type: TYPE_NORMAL
- en: d.  To control the mutation rate
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   PSO is a local search algorithm that is only able to find local optima.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. PSO was originally developed for continuous-valued spaces.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: '2.   In the restaurant game described by Martin et al. in their article “Local
    termination criteria for swarm intelligence: A comparison between local stochastic
    diffusion search and ant nest-site selection,” [6], a group of delegates attends
    a long conference in an unfamiliar town. Each night they have to find somewhere
    to dine. There is a large choice of restaurants, each of which offers a large
    variety of meals. The problem the group faces is to find the best restaurant,
    which is the restaurant where the maximum number of delegates would enjoy dining.
    Even a parallel exhaustive search through the restaurant and meal combinations
    would take too long to accomplish. If you were to solve this problem using PSO,
    how would you describe the three components of the velocity update in the context
    of this problem?'
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Ridesharing is a successful implementation of the sharing economy business
    model where personal vehicles are shared by their owners or drivers with individual
    travelers who have similar itineraries and schedules. The ridesharing problem
    is a multi-objective constrained optimization problem. A non-comprehensive list
    of optimization goals for ridesharing includes
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the total travel distance or time of drivers’ trips
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the total travel time of passengers’ trips
  prefs: []
  type: TYPE_NORMAL
- en: •   Maximizing the number of matched (served) requests
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the cost for the drivers’ trips
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the cost for the passengers’ trips
  prefs: []
  type: TYPE_NORMAL
- en: •   Maximizing the driver’s earnings
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the passenger’s waiting time
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the total number of drivers required
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the ridesharing problem shown in figure C.31, where the objective
    is to come up with a schedule for drivers that minimizes the total distances of
    vehicles’ trips. The statement of this multi-objective optimization is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find *s* that minimizes *f*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F30_Khamis-EQ16.png)'
  prefs: []
  type: TYPE_IMG
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *f* is the total distance of vehicles’ trips to serve all the passengers.
  prefs: []
  type: TYPE_NORMAL
- en: •   *s[i,j]* is 1 if location *j* is assigned within the schedule of the driver
    and 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: •   *d[i,j]* is the distance between two points within the route, where
  prefs: []
  type: TYPE_NORMAL
- en: '*d[i,j]* = √((*x[i]* – *x[j]*)² + (*y[i]* – *y[j]*)²'
  prefs: []
  type: TYPE_NORMAL
- en: •   *P* is the passenger set, with known pickup and delivery points.
  prefs: []
  type: TYPE_NORMAL
- en: •   *V* is the vehicle set, with predefined initial and final locations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F31_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.31 The ridesharing problem
  prefs: []
  type: TYPE_NORMAL
- en: Given the pickup and drop-off locations of five passengers (table C.3) and the
    initial and final locations of the two drivers (table C.4), define a suitable
    representation for a particle (i.e., a candidate solution) that represents each
    driver’s schedule and evaluates its fitness.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.3 Pickup and drop-off locations of the passengers
  prefs: []
  type: TYPE_NORMAL
- en: '| Passengers | Pickup x-coordinate | Pickup y-coordinate | Drop-off x-coordinate
    | Drop-off y-coordinate |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P1 | 9 | 9 | 4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| P2 | 8 | 5 | 2 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| P3 | 6 | 1 | 8 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| P4 | 7 | 6 | 9 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| P5 | 3 | 5 | 10 | 3 |'
  prefs: []
  type: TYPE_TB
- en: Table C.4 Initial and final locations of the drivers
  prefs: []
  type: TYPE_NORMAL
- en: '| Drivers | Initial x-coordinate | Initial y-coordinate | Final x-coordinate
    | Final y-coordinate |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | 4 | 1 | 8 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| B | 1 | 6 | 9 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '4.   Consider the trip itinerary planning problem where the objective is to
    provide an optimal travel itinerary for tourists visiting a new city, taking into
    consideration the quality of the places to be visited, the proximity of the attractions
    to one another, and how much of the day can be completely occupied with little
    idle time. The problem is stated as following:'
  prefs: []
  type: TYPE_NORMAL
- en: Find *X* which optimizes *f*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F31_Khamis-EQ18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'subject to the following constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: •   The duration of the itinerary must not exceed total time in a given day,
    which is set to 480 minutes. This is expressed as the summation of the duration
    of each venue and total commute time to be visited in an itinerary. This means
    that *Z[d]* + *Z[c]* <= 480 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: •   There should never be repetitions of the same venue in a solution.
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *X* = [*Z[d] Z[c] Z[r]*]*^T*
  prefs: []
  type: TYPE_NORMAL
- en: •   *Z[d]* represents the duration of the itinerary (minutes).
  prefs: []
  type: TYPE_NORMAL
- en: •   *Z[c]* represents the total commute time in the itinerary.
  prefs: []
  type: TYPE_NORMAL
- en: •   *Z[r]* represents the average rating of all the venues in an itinerary.
    The ratings are derived from Yelp, Google reviews, or others.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.5 lists the commute times between 10 attractions.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.5 Commute time between attractions
  prefs: []
  type: TYPE_NORMAL
- en: '| Commute time (mins) | To |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| From | 0 | 10 | 20 | 7 | 11 | 8 | 19 | 7 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 1 | 0 | 12 | 14 | 1 | 7 | 12 | 10 | 22 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 12 | 0 | 25 | 21 | 28 | 1 | 22 | 12 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 14 | 25 | 0 | 15 | 15 | 25 | 4 | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | 21 | 15 | 0 | 25 | 22 | 11 | 10 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 7 | 28 | 15 | 25 | 0 | 28 | 14 | 28 | 29 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 12 | 1 | 25 | 22 | 28 | 0 | 22 | 12 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 10 | 22 | 4 | 11 | 14 | 22 | 0 | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 22 | 12 | 6 | 10 | 28 | 12 | 3 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 22 | 12 | 6 | 10 | 29 | 12 | 2 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: The durations and ratings for the different attractions are listed in table
    C.6.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.6 Ratings and durations for attractions
  prefs: []
  type: TYPE_NORMAL
- en: '| ID | Rating | Duration (mins) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Starting hotel |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | 120 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 | 60 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0 | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | 120 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1 | 60 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 4 | 60 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 0 | 60 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 2 | 120 |'
  prefs: []
  type: TYPE_TB
- en: Define a suitable representation of a particle (i.e., a candidate solution),
    and carry out two hand iterations to show how to solve this problem using PSO,
    assuming a swarm size of 4.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   *Trilateration* is used to identify the location of a moving object such
    as a connected vehicle or a cellphone. This process uses the distance between
    the vehicle and three or more known cell towers to determine the location of the
    vehicle. By measuring the signal strength of the device’s signal at each tower,
    the distance between the device and each tower can be calculated. The intersection
    of the three (or more) circles created by these distance measurements gives an
    estimate of the device’s location. As shown in figure C.32, three cell towers
    advertise their coordinates and transmit a reference signal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.32 Cell tower trilateration
  prefs: []
  type: TYPE_NORMAL
- en: 'The connected vehicle uses the reference signal to estimate distances to each
    of the cells *r[i]*. These distance measurements *r[i]* may be subject to noise.
    Assume that the associated error is given by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The vehicle position (*ϕ*[0], *λ*[0]) is the position that minimizes the following
    objective function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ20.png)'
  prefs: []
  type: TYPE_IMG
- en: Write Python code to find the vehicle’s position using PSO.
  prefs: []
  type: TYPE_NORMAL
- en: '6.   A coffee shop offers two sizes of coffee: small and large. The cost of
    making a small coffee is $1, and the cost of making a large coffee is $1.50\.
    The coffee shop sells small coffees for $2 each and large coffees for $3 each.
    The coffee shop wants to maximize its profit, but it also wants to ensure that
    it sells at least 50 small coffees and 75 large coffees and at most 300 and 450
    respectively per day. This problem can be formulated as an optimization problem
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Maximize profit = 2*x*[1] + 3*x*[2] - (*x*[1] + 1.5*x*[2])
  prefs: []
  type: TYPE_NORMAL
- en: Subject to
  prefs: []
  type: TYPE_NORMAL
- en: 50 ≤ *x*[1] ≤ 300
  prefs: []
  type: TYPE_NORMAL
- en: 75 ≤ *x*[2] ≤ 450
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *x*[1] is the number of small coffees to make.
  prefs: []
  type: TYPE_NORMAL
- en: •   *x*[2] is the number of large coffees to make.
  prefs: []
  type: TYPE_NORMAL
- en: Profit is the total profit, where the first term in the equation represents
    the revenue from selling the coffees, and the second term represents the cost
    of making the coffees. Write Python code to find the optimal number of small coffees
    and large coffees to make every day.
  prefs: []
  type: TYPE_NORMAL
- en: 7.   A hospital wants to optimize the scheduling of its doctors to minimize
    the overall cost of labor while ensuring that enough doctors are available to
    meet patient demand. Each doctor has a different hourly rate, and there are different
    levels of patient demand at different times of the day. The goal is to find the
    optimal schedule that minimizes the total cost of labor while meeting the minimum
    doctor requirements during both peak and non-peak hours.
  prefs: []
  type: TYPE_NORMAL
- en: The hospital must schedule at least four doctors during peak hours and at least
    two doctors during non-peak hours. The hospital can hire part-time doctors at
    a lower hourly rate, but they can only work during non-peak hours. The hospital
    also has the option of paying overtime to full-time doctors to meet demand during
    peak hours, but at a higher hourly rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem can be mathematically described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimize the total cost of labor: *f*(*x*) = Σ(*c[i]* × *x[i]*) + Σ(*c[i]^o*
    × *x[i]^o*) + Σ(*c[j]^p* × *x[j]^p*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'subject to the following constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '•   Σ*x[i]* + Σ*x[i]^o* ≥ 4: At least four doctors must be scheduled during
    peak hours.'
  prefs: []
  type: TYPE_NORMAL
- en: '•   Σ*x[i]^p* ≥ 2: At least two doctors must be scheduled during non-peak hours.'
  prefs: []
  type: TYPE_NORMAL
- en: '•   *x[i]*, *x[i]^o*, *x[j]^p* ≥ 0: Non-negativity constraints'
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *i* is the index for full-time doctors, *i* = 1, 2, ..., *m*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *j* is the index for part-time doctors, *j* = 1, 2, ..., *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Predefined parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: •   *c[i]* is the hourly rate for full-time doctor *i*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *c[i]^o* is the overtime hourly rate for full-time doctor *i*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *c[j]^p* is the hourly rate for part-time doctor *j*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decision variables:'
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[i]* is the number of hours worked by full-time doctor *i* during peak
    hours.
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[i]^o* is the number of overtime hours worked by full-time doctor *i*
    during peak hours.
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[j]^p* is the number of hours worked by part-time doctor *j* during non-peak
    hours.
  prefs: []
  type: TYPE_NORMAL
- en: Assume the full-time rates of full-time doctors are [30, 35, 40, 45, 50], their
    overtime rates are 1.5 times the full-time rates, and the part-time doctors’ rates
    are [25, 27, 29, 31, 33]. Write Python code to solve this problem using PSO.
  prefs: []
  type: TYPE_NORMAL
- en: '8.   In neighborhood *Y* of city *X*, there are eight schools that collectively
    possess 100 microscopes for use in biology classes. These resources, however,
    are not uniformly distributed amongst the schools. With recent changes in student
    enrollment, four schools have more microscopes than needed, while the other four
    schools are in need of additional ones. To address this problem, Dr. Rachel Carson,
    who is in charge of the biology department at city *X*.''s school board, decides
    to use a mathematical model. She chooses to use the transportation problem model,
    a strategy aimed at efficiently allocating resources while minimizing transportation
    costs as per R. Lovelace in his article “Open source tools for geographic analysis
    in transport planning” [7]. The model represents supply *n* and demand *m* as
    unit weights of decision variables at various points in a network, with the cost
    of transporting a unit from a supply point to a demand point equivalent to the
    time or distance between nodes. This data is captured in an *n***m* cost matrix.
    The formal statement of this integer linear programming problem is described in
    Daskin’s book “Network and Discrete Location: Models, Algorithms, and Applications”
    [8] as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ28.png)'
  prefs: []
  type: TYPE_IMG
- en: subject to the following constraints
  prefs: []
  type: TYPE_NORMAL
- en: •   Σ*[j]*[∈]*[J] x[ij]* ≤ *S[i]* ∀ *i* ∈ *I*
  prefs: []
  type: TYPE_NORMAL
- en: •   Σ*[j]*[∈]*[J] x[ij]* ≥ *D[i]* ∀ *j* ∈ *J*
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[ij]* ≥ 0 ∀ *i* ∈ *I* and ∀ *j* ∈ *J*
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *i* is each potential origin node.
  prefs: []
  type: TYPE_NORMAL
- en: •   *I* is the complete set of potential origin nodes.
  prefs: []
  type: TYPE_NORMAL
- en: •   *j* is each potential destination node.
  prefs: []
  type: TYPE_NORMAL
- en: •   *J* is the complete set of potential nodes.
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[ij]* is the amount to be shipped from ∀ *i* ∈ *I* to ∀ *j* ∈ *J*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *c[ij]* is per unit shipping costs between all *i*, *j* pairs.
  prefs: []
  type: TYPE_NORMAL
- en: •   *S[i]* is node *i* supply for ∀ *i* ∈ *I*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *D[j]* is node *i* demand for ∀ *j* ∈ *J*.
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code to solve this problem using PSO. Visualize the solution on
    a geospatial map.
  prefs: []
  type: TYPE_NORMAL
- en: 9.   In the Chapter 9/Projects folder in the book’s GitHub repository, the following
    sample research projects are provided for review and experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: •   Routing—Addresses using PSO to find the shortest path between two points
    of interest in Toronto
  prefs: []
  type: TYPE_NORMAL
- en: •   Bus stops placement—Addresses how to use PSO to find the optimal placement
    of bus stops in the Waterloo/Kitchener area, Ontario, Canada
  prefs: []
  type: TYPE_NORMAL
- en: C.8.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   c) It may cause the algorithm to become stuck in local optima.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   a) The cognitive component is based on the particle’s own experience,
    while the social component is based on the experience of the swarm as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   b) False
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   a) Cognitive-only model
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   b) False
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   b) To control the exploration/exploitation trade-off
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   b) False (PSO is designed to explore the search space globally and has
    the potential to find the global optimum.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. a) True
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Imagine a group of delegates visiting an unfamiliar city for a conference.
    They are trying to find the best restaurant in town using PSO principles. The
    town is large, and each delegate starts at a different location. Each delegate
    has a preferred way of exploring restaurants, like walking along certain streets
    or visiting specific neighborhoods. This is similar to the inertia component in
    PSO, where particles maintain their current velocity and direction, ensuring they
    don’t change their exploration pattern too abruptly.
  prefs: []
  type: TYPE_NORMAL
- en: As each delegate visits different restaurants, they remember the best one they’ve
    been to so far (their personal best). If they come across a less appealing restaurant,
    they’re more likely to return to their favorite one, knowing it was a good choice
    based on their own experience. This is the cognitive component, where particles
    in PSO are attracted to their personal best positions, following their past experiences
    and individual preferences.
  prefs: []
  type: TYPE_NORMAL
- en: The delegates also communicate with each other via group chat, sharing their
    experiences and the locations of the best restaurants they’ve found. If someone
    discovers an outstanding restaurant, others might decide to visit that place and
    try it for themselves, even if it wasn’t their personal favorite. This is the
    social component, where particles in PSO are influenced by the global best position
    or the collective knowledge of the swarm.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Due to the discrete nature of the formulated problem, permutation-based
    PSO should be used. A particle in this algorithm represents an ordering of the
    passengers to be picked up and dropped off by each driver. In this problem, we
    have two vehicles, A and B, and five passenger requests to match (P1–P5). For
    example, a candidate solution for a problem with five passengers and two drivers
    would have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A^+ | P3^+ | P4^+ | P3^– | P5^+ | P4^– | P5^– | A^– |'
  prefs: []
  type: TYPE_TB
- en: '| B^+ | P1^+ | P2^+ | P2^– | P1^– | B^– |  |  |'
  prefs: []
  type: TYPE_TB
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   + denotes the pickup points of passengers’ requests and the vehicles’ sources.
  prefs: []
  type: TYPE_NORMAL
- en: •   – denotes the delivery points of passengers’ requests and the vehicles’
    destinations
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution can be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •   Vehicle A source point → passenger 3 pickup → passenger 4 pickup → passenger
    3 drop-off → passenger 5 pickup → passenger 4 drop-off → passenger 5 drop-off
    → vehicle A destination.
  prefs: []
  type: TYPE_NORMAL
- en: •   Vehicle B source point → passenger 1 pickup → passenger 1 pickup → passenger
    2 drop-off → passenger 2 drop-off → vehicle B destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two schedules can be also concatenated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A^+ | P3^+ | P4^+ | P3^- | P5^+ | P4^- | P5^- | A^- | B^+ | P1^+ | P2^+ |
    P2^- | P1^- | B^- |'
  prefs: []
  type: TYPE_TB
- en: 'We use the objective function to evaluate this solution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ32.png)'
  prefs: []
  type: TYPE_IMG
- en: For a more comprehensive discussion of the ride-matching problem with time windows
    (RMPTW) and an extended version of this simplified problem, see Herbawi and Weber’s
    article “A genetic and insertion heuristic algorithm for solving the dynamic ridematching
    problem with time windows” [9].
  prefs: []
  type: TYPE_NORMAL
- en: '4.   Binary PSO (BPSO) is used to handle this problem. A binary string is used
    to describe the attractions to be visited. For example, [0 0 1 0 1 0 0 0 0] means
    visit attractions 3 and 5\. The velocity is calculated using the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ33.png)'
  prefs: []
  type: TYPE_IMG
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *i* is the particle number.
  prefs: []
  type: TYPE_NORMAL
- en: •   *d* is the dimension or the attraction.
  prefs: []
  type: TYPE_NORMAL
- en: •   *v[k]^(id)* is the velocity at iteration *k* for particle *i* and dimension
    *d*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *pbest[k]^(id)* is the personal best at iteration *t* for particle *i* and
    dimension *d*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *gbest[k]^d* is the global best at iteration *k* for dimension *d*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[k]^(id)* is the current position at iteration *k* for particle *i* and
    dimension *d*.
  prefs: []
  type: TYPE_NORMAL
- en: •   *ϕ*[1], *ϕ*[2] are uniformly generated random numbers between 0 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the velocity vector is updated, the sigmoid value of each of the velocities
    is updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A new position with the sigmoid value of the velocity is created. Next the
    particle position is updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ35.png)'
  prefs: []
  type: TYPE_IMG
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *r* is a uniformly generated random number between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: •   *sig*(*v[k]*[+1]*^(id)*) is the sigmoid value of the velocity at *v[k]*[+1]*^(id)*
  prefs: []
  type: TYPE_NORMAL
- en: Table C.7 Initialization
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *ϕ*[1] | *ϕ*[2] | *v*[01] | *v*[02] | *v*[03] | *v*[04] | *v*[05] | *v*[06]
    | *v*[07] | *v*[08] | *v*[09] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Let *p[i]* be the current binary value for the position of attraction *i* for
    a particle as shown in table C.8.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.8 Binary value for the positions of the 9 attractions
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Table C.9 Initialization: Fitness evaluation'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] | Total commute time | Total places visited | Average rating | Total
    duration | *f*(*x[i]*) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 34 | 2 | 2.000 | 180 | 0.700
    |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 19 | 2 | 5.000 | 240 | 2.405
    |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 76 | 2 | 2.500 | 180 | 0.809
    |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 30 | 2 | 3.000 | 180 | 1.059
    |'
  prefs: []
  type: TYPE_TB
- en: Table C.10 Particle’s current personal best at initialization
  prefs: []
  type: TYPE_NORMAL
- en: '|  | pbest[01] | pbest [02] | pbest [03] | pbest [04] | pbest [05] | pbest
    [06] | pbest [07] | pbest [08] | pbest [09] | pbestVal |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0.700 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 2.405 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0.809 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1.059 |'
  prefs: []
  type: TYPE_TB
- en: 'Table C.11 Iteration 1: Velocity update'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *ϕ*[1] | *ϕ*[2] | *v*[11] | *v*[12] | *v*[13] | *v*[14] | *v*[15] | *v*[16]
    | *v*[17] | *v*[18] | *v*[19] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0.958 | 0.830 | -0.830 | -0.830 | 0.830 | 0.000 | 0.000 | 0.000
    | 0.000 | 0.830 | 0.000 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 1.347 | 1.517 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 |
    0.000 | 0.000 | 0.000 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 1.320 | 1.649 | 0.000 | -1.649 | 1.649 | 0.000 | -1.649 | 0.000
    | 0.000 | 1.649 | 0.000 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 0.757 | 0.678 | -0.678 | 0.000 | 0.678 | 0.000 | 0.000 | 0.000 |
    -0.678 | 0.678 | 0.000 |'
  prefs: []
  type: TYPE_TB
- en: Table C.12 Updated sigmoid velocity values of the particle after iteration 1
  prefs: []
  type: TYPE_NORMAL
- en: '|  | sig(*v*[11]) | sig(*v*[12]) | sig(*v*[13]) | sig(*v*[14]) | sig(*v*[15])
    | sig(*v*[16]) | sig(*v*[17]) | sig(*v*[18]) | sig(*v*[19]) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0.304 | 0.304 | 0.696 | 0.500 | 0.500 | 0.500 | 0.500 | 0.696 |
    0.500 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 |
    0.500 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0.500 | 0.161 | 0.839 | 0.500 | 0.161 | 0.500 | 0.500 | 0.839 |
    0.500 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 0.337 | 0.500 | 0.663 | 0.500 | 0.500 | 0.500 | 0.337 | 0.663 |
    0.500 |'
  prefs: []
  type: TYPE_TB
- en: Table C.13 Uniformly generated random numbers for deciding particle updated
    after iteration 1
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *r*[11] | *r*[12] | *r*[13] | *r*[14] | *r*[15] | *r*[16] | *r*[17] |
    *r*[18] | *r*[19] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.477 | 0.724 | 0.875 | 0.654 | 0.088 | 0.089 | 0.853 | 0.925 | 0.528
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.673 | 0.530 | 0.438 | 0.785 | 0.218 | 0.763 | 0.838 | 0.749 | 0.590
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0.534 | 0.086 | 0.301 | 0.763 | 0.653 | 0.754 | 0.809 | 0.974 | 0.763
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0.218 | 0.697 | 0.875 | 0.854 | 0.116 | 0.941 | 0.678 | 0.742 | 0.965
    |'
  prefs: []
  type: TYPE_TB
- en: 'Iteration 1: Global best is 2.405, and the best particle is *x*[2] = [0 0 1
    0 0 0 0 0 0].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration 2: Velocity update'
  prefs: []
  type: TYPE_NORMAL
- en: Table C.14 Updated particle state and fitness function after iteration 2
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] | Total commute time | Total places visited | Average rating | Total
    duration | *f*(*x[i]*) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 64 | 2 | 3.500 | 180 | 1.158
    |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 37 | 2 | 5.000 | 300 | 2.901
    |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 70 | 2 | 2.500 | 240 | 1.091
    |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 24 | 2 | 4.500 | 240 | 2.143
    |'
  prefs: []
  type: TYPE_TB
- en: Table C.15 Updated personal best of the particle after iteration 2
  prefs: []
  type: TYPE_NORMAL
- en: '|  | pbest[11] | pbest [12] | pbest [13] | pbest [14] | pbest [15] | pbest
    [16] | pbest [17] | pbest [18] | pbest [19] | pbestVal |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1.158 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 2.901 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1.091 |'
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 2.143 |'
  prefs: []
  type: TYPE_TB
- en: The global best is 2.901, and the best particle is *x*[2] = [0 0 1 0 1 0 0 0
    0]. Repeat until the stopping criteria is fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   The next listing shows the steps for solving the trilateration problem
    using PSO.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.13 Solving the trilateration problem using PSO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ① Define the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: ② Set up the PSO algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Initialize GlobalBestPSO, and minimize the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Print the results.
  prefs: []
  type: TYPE_NORMAL
- en: 6.   The next listing shows the steps for solving the coffee shop problem.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.14 Solving the coffee shop problem using PSO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: ① Import the required libraries.
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the fitness function.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the number of particles and iterations.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the lower and upper bounds of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set the optimizer options.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Initialize the optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Perform the optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 7.   The next listing shows the steps for solving the doctor scheduling problem.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.15 Solving the doctor scheduling problem using PSO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: ① Set full-time hourly rates, overtime rates, and part-time doctor rates.
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the three decision variables.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define the total cost as an objective function.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the constraints and add them as a penalty in the cost function.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Initialize the bounds.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Set the options for PSO.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Create an instance of PSO.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Perform the optimization.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Extract optimal values of the decision variables x1, x2, and x3.
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of listing C.15, available in the book’s GitHub repo, contains
    a function to print and visualize the results. Figure C.33 shows the hours worked
    for each doctor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F33_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.33 Hours worked by each doctor
  prefs: []
  type: TYPE_NORMAL
- en: 8.   The next listing shows the steps for solving the supply chain optimization
    problem using PSO. We start by importing the required libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.16 Solving the supply chain optimization problem using PSO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the problem data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: ① Schools with microscopes available
  prefs: []
  type: TYPE_NORMAL
- en: ② Schools with microscopes requested
  prefs: []
  type: TYPE_NORMAL
- en: ③ Number of microscopes available at each school
  prefs: []
  type: TYPE_NORMAL
- en: ④ Number of microscopes requested at each school
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Number of variables
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation of listing C.16, the following function generates random
    locations around a center point to represent the supply and demand schools in
    the selected city (using Toronto as an example). We calculate the distances between
    the schools using geopy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: ① For reproducibility
  prefs: []
  type: TYPE_NORMAL
- en: ② Set the center of the map.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Generate random GPS coordinates (lat, long) for the supply schools.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Generate random GPS coordinates (lat, long) for the demand schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Calculate geodesic distances between the schools in km.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class defines the transportation problem in a format compatible
    with pymoo. It defines the decision variables, constraints, and the objective
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a problem object and a PSO solver as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line is used to run 150 iterations of the PSO solver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet is used to print the solution obtained by the PSO
    solver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: ① Extract the solution.
  prefs: []
  type: TYPE_NORMAL
- en: ② Number of supply points
  prefs: []
  type: TYPE_NORMAL
- en: ③ Number of demand points
  prefs: []
  type: TYPE_NORMAL
- en: ④ Print each supply point.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Print each demand point.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the shipping cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the randomness included in the implementation, the code will produce
    output that is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet can be used to visualize the solution of a spatial
    map using folium:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: ① Normalize function
  prefs: []
  type: TYPE_NORMAL
- en: ② Normalize soln array
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define a color list.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a map centered at downtown Toronto.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Add markers for supply schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Add markers for demand schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Add lines (edges) between supply and demand schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Show the map.
  prefs: []
  type: TYPE_NORMAL
- en: Figure C.34 shows a solution that may be produced by PSO.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F34_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.34 School microscopes supply and demand
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of listing C.16, available in the book’s [GitHub repo](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20C/Chapter%209/Listing%20C.16_Supply_demand.ipynb),
    also shows how to solve this problem using the genetic algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.9 Chapter 10: Other swarm intelligence algorithms to explore'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.9.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Match the terms and descriptions shown in table C.16.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.16
  prefs: []
  type: TYPE_NORMAL
- en: '| Terms | Descriptions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. Ant colony system (ACS) | a. Bees that search for new food sources after
    exhausting their current ones |'
  prefs: []
  type: TYPE_TB
- en: '| 2\. Stigmergy | b. Positive feedback about food path causes that path to
    be followed by more and more ants |'
  prefs: []
  type: TYPE_TB
- en: '| 3\. Scout bees | c. A pheromone update method that doesn’t take the desirability
    of the solution into account |'
  prefs: []
  type: TYPE_TB
- en: '| 4\. Max-min ant system (MMAS) | d. The maximum number of unsuccessful attempts
    made by a scout bee to find a new food source |'
  prefs: []
  type: TYPE_TB
- en: '| 5\. Autocatalytic behavior | e. Bees that probabilistically choose food sources
    depending on the fitness of the solutions found by the employed bees |'
  prefs: []
  type: TYPE_TB
- en: '| 6\. Ant density model | f. Indirect communication among social insects through
    environmental modifications that serve as external memory |'
  prefs: []
  type: TYPE_TB
- en: '| 7\. Onlooker bees | g. A pheromone update method that uses local information
    to update the pheromone concentrations |'
  prefs: []
  type: TYPE_TB
- en: '| 8\. Ant-cycle | h. An ACO variation that uses an elitist strategy called
    pseudo-random proportional action rule |'
  prefs: []
  type: TYPE_TB
- en: '| 9\. Ant System (AS) | i. An ACO variant that adds a memory capability by
    including a tabu list |'
  prefs: []
  type: TYPE_TB
- en: '| 10\. Trial limit | k. An ACO variation that overcomes stagnation |'
  prefs: []
  type: TYPE_TB
- en: 2.   Write Python code to find the shortest path between a source point and
    a destination point using the ant colony optimization algorithm. Assume that you’re
    currently standing at the King Edward VII equestrian statue in the city of Toronto
    with GPS coordinates (43.664527, –79.392442). Imagine you’re a student at the
    University of Toronto, and you’re already running late for your Optimization Algorithms
    lecture at the Bahen Centre for Information Technology with GPS coordinates (43.659659,
    –79.397669). Visualize the obtained route on a map centered on King’s College
    Circle with GPS coordinates (43.661667, –79.395) so you can reach your destination.
    Feel free to use the helping functions available in the optalgotools package,
    such as `Node`, `cost`, and `draw_route`. Use the code to experiment with different
    search spaces (different areas of interest, different origins, and destinations)
    and different algorithm parameter settings.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Reverse osmosis (RO) is a very effective and important process for desalination
    and water waste reclamation. Assume that you need to maximize the RO high pressure
    pump power. This power depends of a number of parameters according to the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F34_Khamis-EQ36.png)'
  prefs: []
  type: TYPE_IMG
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: •   *HP* is the RO high pressure pump power in kW.
  prefs: []
  type: TYPE_NORMAL
- en: •   *M[d]* is the RO productivity in m3/d and is in the range of 41.67 < M*[d]*
    <416.67 m³/d.
  prefs: []
  type: TYPE_NORMAL
- en: •   *N[v]* is number of pressure vessels and is ranged as 1 < N*[v]* < 200.
  prefs: []
  type: TYPE_NORMAL
- en: •   ∆*π* is the net osmotic pressure across the membrane and is in the range
    1400 < ∆*π* < 2600 kPa.
  prefs: []
  type: TYPE_NORMAL
- en: •   *RR* is the recovery ratio and is ranged as 1 < RR < 50%.
  prefs: []
  type: TYPE_NORMAL
- en: •   *η* is the efficiency of the high pressure pump and is in the range of 0.70
    < *η* < 0.85.
  prefs: []
  type: TYPE_NORMAL
- en: •   *ρ* is the density of water.
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code to find the optimal values of the decision variables (*Md,
    Nv*, ∆*π, RR, η*, and *ρ*) to maximize HP using the ant colony optimization (ACO)
    algorithm. Solve the same problem using the `optimize` solver in SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Solve the supply and demand problem introduced in exercise 8 of chapter
    9 using the ant colony optimization (ACO) algorithm. Use mixed integer distributed
    ant colony optimization (MIDACO) to solve this problem. MIDACO ([www.midaco-solver.com](http://www.midaco-solver.com))
    is a numerical high-performance software for solving single- and multi-objective
    optimization problems. It is based on ACO with an extension for mixed integer
    search domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install MIDACO, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.  Download MIDACO Python Gateway ([midaco.py](http://www.midaco-solver.com/index.php/download/python)),
    and remove the .txt extension.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.  Download the appropriate library file ([midacopy.dll](http://www.midaco-solver.com/index.php/download/python)
    or midacopy.so).
  prefs: []
  type: TYPE_NORMAL
- en: 3\.  Store all the files in the same folder on your PC.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.  Import `midaco` into your Jupyter notebook.
  prefs: []
  type: TYPE_NORMAL
- en: MIDACO is licensed software with a limited free license that enables optimization
    with up to four variables (two supply schools and two demand schools).
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the following reduced problem data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: ① Schools with microscopes available
  prefs: []
  type: TYPE_NORMAL
- en: ② Schools with microscopes requested
  prefs: []
  type: TYPE_NORMAL
- en: ③ Number of microscopes available at each school
  prefs: []
  type: TYPE_NORMAL
- en: ④ Number of microscopes requested at each school
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code to solve this problem using MIDACO. Visualize the solution
    on a geospatial map. For a larger number of schools, you can obtain an unlimited
    license or request a free academic trial of the unlimited version that can support
    up to 100,000 variables.
  prefs: []
  type: TYPE_NORMAL
- en: C.9.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Answers
  prefs: []
  type: TYPE_NORMAL
- en: 1-h, 2-f, 3-a, 4-k, 5-b, 6-c, 7-e, 8-g, 9-i, 10-d
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Listing C.17 shows the steps to find and visualize the shortest path between
    two points of interest in the city of Toronto. The code uses helping functions
    from optalgotools such as Node, cost, and draw_route. We start by defining and
    visualizing the search space as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.17 Solving a routing problem using ACO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: ① Set King’s College Circle, Toronto, ON as the center of the map.
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a graph.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the King Edward VII equestrian statue as the origin.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the Bahen Centre for Information Technology at University of Toronto as
    the destination.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Get the osmid of the nearest nodes to the origin and destination points.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Create the origin and destination nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Mark both the source and destination nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Visualize the search space.
  prefs: []
  type: TYPE_NORMAL
- en: 'AS a continuation of listing C.17, we can initialize the parameters of the
    ACO algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: ① Set alpha, a parameter to control the influence of pheromones.
  prefs: []
  type: TYPE_NORMAL
- en: ② Set beta, a parameter to control the influence of desirability of the city
    transition.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Randomize the pheromones.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Randomize the pheromones.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ A function to calculate pheromone levels
  prefs: []
  type: TYPE_NORMAL
- en: 'We now implement the ACO procedure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: ① Place the ant at the origin node.
  prefs: []
  type: TYPE_NORMAL
- en: ② Probabilistically choose a child to explore.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Add all the non-explored children in case we need to explore them later.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the chosen child to be the next node to explore.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Update the pheromones.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ If the route is newly discovered, add it to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now print the best route and its cost and visualize the obtained route
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Figure C.35 shows the optimal route generated by ACO.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F35_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.35 Optimal route generated by ACO
  prefs: []
  type: TYPE_NORMAL
- en: 3.   The next listing shows the steps for solving the reverse osmosis (RO) high
    pressure pump power maximization problem using ACO.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.18 Solving the RO high pressure pump power maximization problem with
    ACO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: ① Define the range for each decision variable.
  prefs: []
  type: TYPE_NORMAL
- en: ② Density of water in kg/m^3
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the ACO parameters.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Initialize the pheromone matrix.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Initialize the best solution and its corresponding power.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Construct solutions for each ant.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Calculate the power for the current solution.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Store the solution and its power.
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Update the best solution if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: ⑪ Update pheromone trails based on the power of each solution.
  prefs: []
  type: TYPE_NORMAL
- en: ⑫ Print the optimal values of the decision variables and the optimal HP.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the generated output is show here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As a continuation of listing C.18, the following code snippet shows the steps
    for solving this problem using the `optimize` solver in SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: ① Import the scipy optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the objective function with a negative sign for minimization, as per
    scipy's requirement.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the bounds for the decision variables.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set an initial guess.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Solve the optimization problem using sequential least squares programming
    (SLSQP).
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the optimal values of the decision variables and the optimal HP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated output is show here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can fine-tune the ACO parameters to get results comparable to those of the
    SciPy optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   The next listing shows the steps for solving the supply and demand problem
    using the MIDACO solver. We start by importing the libraries and setting the problem
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.19 Solving the supply and demand problem using MIDACO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: ① Import the MIDACO solver.
  prefs: []
  type: TYPE_NORMAL
- en: ② Set the schools with microscopes available.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the schools with microscopes requested.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the number of microscopes available at each school.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set the number of microscopes requested at each school.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation, we’ll generate random GPS coordinates for the supply and
    demand schools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: ① Create a geolocator object.
  prefs: []
  type: TYPE_NORMAL
- en: ② Get the coordinates of Toronto.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Function to generate random locations around a center point
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the random seed to ensure reproducibility of random numbers generated.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Generate random GPS coordinates (lat, long) for the supply schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Generate random GPS coordinates (lat, long) for the demand schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Calculate geodesic distances between the schools in km.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Calculate the cost matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The following function defines the main ingredients of the optimization problem,
    including the objective function and the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: ① Initialize the array for objectives F(X).
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize the array for constraints G(X).
  prefs: []
  type: TYPE_NORMAL
- en: ③ Objective functions F(X)
  prefs: []
  type: TYPE_NORMAL
- en: ④ Candidate solution
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Inequality constraints G(X) >= 0 must come second in g[me:m-1]
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Return the objective function and constraint evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in using MIDACO is to define the problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: ① Free limited license that supports up to 4 variables.
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize the dictionary containing the problem specifications.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Initialize the dictionary containing the MIDACO options.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Handle for problem function name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem dimensions are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: ① Number of objectives
  prefs: []
  type: TYPE_NORMAL
- en: ② Number of variables (in total)
  prefs: []
  type: TYPE_NORMAL
- en: ③ Number of integer variables (0 <= ni <= n)
  prefs: []
  type: TYPE_NORMAL
- en: ④ Number of constraints (in total)
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Number of equality constraints (0 <= me <= m)
  prefs: []
  type: TYPE_NORMAL
- en: 'The lower and upper bounds `xl` and `xu` are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The starting point `x` is set as the lower bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The stopping criteria are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: ① Maximum number of function evaluation
  prefs: []
  type: TYPE_NORMAL
- en: ② Maximum time limit in seconds (e.g., 1 day = 60*60*24)
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the printing options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: ① Print-frequency for current best solution
  prefs: []
  type: TYPE_NORMAL
- en: ② Save screen and solution [0 for no and 1 for yes]
  prefs: []
  type: TYPE_NORMAL
- en: 'MIDACO offers the option to evaluate multiple solution candidates in parallel
    (aka co-evaluation or fine-grained parallelization). According to the MIDACO user
    manual, for a parallelization factor of *P* = 10, the potential speed-up is around
    10 times, while for a parallelization factor of *P* = 100, the potential speed
    up is around 70 times. We can set the parallelization factor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '① Serial: 0 or 1, Parallel: 2,3,4,5,6,7,8...'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run `midaco` to solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet is used to print the solution obtained by the PSO
    solver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: ① Number of supply points
  prefs: []
  type: TYPE_NORMAL
- en: ② Number of demand points
  prefs: []
  type: TYPE_NORMAL
- en: ③ Print each supply point.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Print each demand point.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Print the shipping cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will produce output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet can be used to visualize the solution of a spatial
    map using folium:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: ① Normalize function.
  prefs: []
  type: TYPE_NORMAL
- en: ② Normalize solution array.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define a color list.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a map centered at downtown Toronto.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Add markers for supply schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Add markers for demand schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Add lines (edges) between supply and demand schools.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Show the map.
  prefs: []
  type: TYPE_NORMAL
- en: Figure C.36 shows the solution obtained using MIDACO.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F36_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.36 Supply and demand problem solution obtained by MIDACO
  prefs: []
  type: TYPE_NORMAL
- en: For a higher number of schools, you can obtain an unlimited license or request
    a free academic trial of the unlimited version that can support up to 100,000
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.10 Chapter 11: Supervised and unsupervised learning'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.10.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   What are the traditional categories of machine learning algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: b.  Supervised, unsupervised, unreinforced
  prefs: []
  type: TYPE_NORMAL
- en: b.  Supervised, hybrid, reinforcement
  prefs: []
  type: TYPE_NORMAL
- en: c.  Supervised, unsupervised, hybrid, reinforcement
  prefs: []
  type: TYPE_NORMAL
- en: d.  Unsupervised, semi-supervised, hybrid
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   The Kohonen map is trained using supervised learning to produce a two-dimensional
    representation of the input space of the training samples.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   What kind of tasks are common in supervised learning?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Clustering and data reduction
  prefs: []
  type: TYPE_NORMAL
- en: b.  Classification and regression
  prefs: []
  type: TYPE_NORMAL
- en: c.  Feature extraction and anomaly detection
  prefs: []
  type: TYPE_NORMAL
- en: d.  Dimensionality reduction and normalization
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   What is the task of clustering in unsupervised learning?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Group objects based on certain similarity measures
  prefs: []
  type: TYPE_NORMAL
- en: b.  Identify traffic signs in a self-driving car
  prefs: []
  type: TYPE_NORMAL
- en: c.  Map input features to known labels or classes
  prefs: []
  type: TYPE_NORMAL
- en: d.  Optimize a model’s performance by feedback loop
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   The pointer-network (Ptr-Net) model is designed to address specific limitations
    of conventional sequence-to-sequence (seq2seq) models, particularly in tasks involving
    variable-length output sequences.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   In reinforcement learning, how does a learning agent learn to make decisions?
  prefs: []
  type: TYPE_NORMAL
- en: a.  By minimizing the error between predicted and actual classes
  prefs: []
  type: TYPE_NORMAL
- en: b.  By identifying clusters within the input data
  prefs: []
  type: TYPE_NORMAL
- en: c.  By maximizing cumulative reward through actions in an environment
  prefs: []
  type: TYPE_NORMAL
- en: d.  By mapping input features to known labels or classes
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   What does deep learning (DL) enable in machine learning?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Feature representation learning at different levels of abstractions
  prefs: []
  type: TYPE_NORMAL
- en: b.  Classification of different objects based on labeled data
  prefs: []
  type: TYPE_NORMAL
- en: c.  Grouping of similar data points based on certain measures
  prefs: []
  type: TYPE_NORMAL
- en: d.  Reward-based decision-making in an interactive environment
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   Graph embedding learns a mapping from a low-dimensional continuous domain
    to a discrete high-dimensional graph domain.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   How does DL reduce the need for extensive data preprocessing?
  prefs: []
  type: TYPE_NORMAL
- en: a.  By using a large amount of unlabeled data for training
  prefs: []
  type: TYPE_NORMAL
- en: b.  By learning through interactions in a feedback loop
  prefs: []
  type: TYPE_NORMAL
- en: c.  By approximating mapping functions between data and known labels
  prefs: []
  type: TYPE_NORMAL
- en: d.  By learning discriminative features from raw data automatically
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. Why is graph-structured data important in the field of combinatorial optimization?
  prefs: []
  type: TYPE_NORMAL
- en: a.  It helps to maximize cumulative rewards
  prefs: []
  type: TYPE_NORMAL
- en: b.  It assists in mapping functions between data and labels
  prefs: []
  type: TYPE_NORMAL
- en: c.  It captures and represents the relationships and constraints between elements
  prefs: []
  type: TYPE_NORMAL
- en: d.  It groups objects based on similarity measures
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Match the terms and descriptions shown in table C.17.
  prefs: []
  type: TYPE_NORMAL
- en: Table C.17
  prefs: []
  type: TYPE_NORMAL
- en: '| Terms | Descriptions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. Self-organizing map (SOM) | a. A polygon that fully encompasses a given
    set of points with maximum area and minimum boundary or circumference of the shape.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2\. Convex hull | b. A mechanism that allows the model to dynamically prioritize
    which parts of the input are most relevant for each output it''s trying to predict,
    making it more effective at understanding context and reducing confusion from
    long input sequences |'
  prefs: []
  type: TYPE_TB
- en: '| 3\. Pointer-network (Ptr-Net) | c. A type of artificial neural network that
    is trained using unsupervised learning to produce a low-dimensional (typically
    two-dimensional), discretized representation of the input space of the training
    samples |'
  prefs: []
  type: TYPE_TB
- en: '| K-hop neighborhood | d. A set of neighboring nodes at a distance less than
    or equal to K |'
  prefs: []
  type: TYPE_TB
- en: '| 5\. Attention mechanism | e. A type of neural network architecture designed
    to deal with variable-sized input data sequences |'
  prefs: []
  type: TYPE_TB
- en: '3.   Find the shortest path to visit 20 major US cities starting from New York
    City using self-organizing maps. The cities are given by the names and GPS latitude
    and longitude coordinates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •   New York City (40.72, –74.00)
  prefs: []
  type: TYPE_NORMAL
- en: •   Philadelphia (39.95, –75.17)
  prefs: []
  type: TYPE_NORMAL
- en: •   Baltimore (39.28, –76.62)
  prefs: []
  type: TYPE_NORMAL
- en: •   Charlotte (35.23, –80.85)
  prefs: []
  type: TYPE_NORMAL
- en: •   Memphis (35.12, –89.97)
  prefs: []
  type: TYPE_NORMAL
- en: •   Jacksonville (30.32, –81.70)
  prefs: []
  type: TYPE_NORMAL
- en: •   Houston (29.77, –95.38)
  prefs: []
  type: TYPE_NORMAL
- en: •   Austin (30.27, –97.77)
  prefs: []
  type: TYPE_NORMAL
- en: •   San Antonio (29.53, –98.47)
  prefs: []
  type: TYPE_NORMAL
- en: •   Fort Worth (32.75, –97.33)
  prefs: []
  type: TYPE_NORMAL
- en: •   Dallas (32.78, –96.80)
  prefs: []
  type: TYPE_NORMAL
- en: •   San Diego (32.78, –117.15)
  prefs: []
  type: TYPE_NORMAL
- en: •   Los Angeles (34.05, –118.25)
  prefs: []
  type: TYPE_NORMAL
- en: •   San Jose (37.30, –121.87)
  prefs: []
  type: TYPE_NORMAL
- en: •   San Francisco (37.78, –122.42)
  prefs: []
  type: TYPE_NORMAL
- en: '•   Indianapolis'': (39.78, –86.15)'
  prefs: []
  type: TYPE_NORMAL
- en: •   Phoenix (33.45, –112.07)
  prefs: []
  type: TYPE_NORMAL
- en: •   Columbus (39.98, –82.98)
  prefs: []
  type: TYPE_NORMAL
- en: •   Chicago (41.88, –87.63)
  prefs: []
  type: TYPE_NORMAL
- en: •   Detroit (42.33, –83.05)
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Optimizing the hyperparameters can significantly improve the performance
    of the ML model. Tune the hyperparameters in listing 11.6, and observe the effect
    on the ConvexNet model’s performance with different testing datasets. The hyperparameters
    to be tuned include
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of input features for the model
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of embedding dimensions
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of hidden units in the model
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of attention heads in the multi-head self-attention mechanism
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of layers in the model
  prefs: []
  type: TYPE_NORMAL
- en: •   The dropout probability
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of training epochs
  prefs: []
  type: TYPE_NORMAL
- en: •   The batch size used during training
  prefs: []
  type: TYPE_NORMAL
- en: •   The learning rate for the optimizer
  prefs: []
  type: TYPE_NORMAL
- en: C.10.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   c) Supervised, unsupervised, hybrid, reinforcement
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   b) False (The Kohonen map is trained using unsupervised learning to produce
    a low-dimensional representation of the input space of the training samples, not
    supervised learning.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   b) Classification and regression
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   a) Group objects based on certain similarity measures
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   c) By maximizing cumulative reward through actions in an environment
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   a) Feature representation learning at different levels of abstractions
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   b) False (Graph embedding learns a mapping from a discrete high-dimensional
    graph domain to a low-dimensional continuous domain, not the other way around.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   d) By learning discriminative features from raw data automatically
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. c) It captures and represents the relationships and constraints between
    elements
  prefs: []
  type: TYPE_NORMAL
- en: 2.   1-c, 2-a, 3-e, 4-d, and 5-b.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   MiniSom is used in this listing. MiniSom is a minimalistic and Numpy-based
    implementation of the SOM. You can install this library using !pip install minisom.
  prefs: []
  type: TYPE_NORMAL
- en: The next listing shows how to solve the 20-city TSP using self-organizing maps.
    We start by importing the libraries and modules, defining the cities of interest,
    and calculating the haversine distances between pairs of cities.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.20 Solving TSP using SOM
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: ① Define latitude and longitude for twenty major US cities.
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a haversine distance matrix based on latitude-longitude coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Convert the distance dictionary into a dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Get the haversine distances between pairs of cities.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a SOM to solve the TSP instance. This SOM is 1D with *N* neurons.
    The dimensionality of the input data is 2 (latitude and longitude coordinates).
    The sigma parameter is used for the Gaussian neighborhood function. This parameter
    controls the spread of the influence of neighboring neurons during training. The
    learning rate determines the step size of weight updates during training. The
    neighborhood function used during training is set to Gaussian, which means the
    influence of neighboring neurons decreases with distance. The seed for the random
    number generator is set to 50 to ensure reproducibility of the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: ① Set the number of neurons (nodes) for the 1D SOM.
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a self-organizing map with 1xN_neurons grid.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Initialize the weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet generates a set of visualizations to show the progress
    of the SOM training:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Figure C.37 shows the visualized plots.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F37_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.37 Progress of SOM training with increasing numbers of iterations
  prefs: []
  type: TYPE_NORMAL
- en: 'C.11 Chapter 12: Reinforcement learning'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.11.1 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   In reinforcement learning, what does the term “reward” represent?
  prefs: []
  type: TYPE_NORMAL
- en: a.  The penalty for performing an action
  prefs: []
  type: TYPE_NORMAL
- en: b.  The immediate feedback received from the environment
  prefs: []
  type: TYPE_NORMAL
- en: c.  The probability of taking a particular action
  prefs: []
  type: TYPE_NORMAL
- en: d.  The number of steps taken by the agent
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   The goal of reinforcement learning is to
  prefs: []
  type: TYPE_NORMAL
- en: a.  Minimize the cumulative reward
  prefs: []
  type: TYPE_NORMAL
- en: b.  Find the shortest path to the goal state
  prefs: []
  type: TYPE_NORMAL
- en: c.  Learn an optimal policy to maximize cumulative rewards
  prefs: []
  type: TYPE_NORMAL
- en: d.  Achieve a deterministic environment
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   Which of the following RL algorithms is considered model-free?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Expert iteration
  prefs: []
  type: TYPE_NORMAL
- en: b.  Proximal policy optimization (PPO)
  prefs: []
  type: TYPE_NORMAL
- en: c.  Imagination-augmented agents (I2A)
  prefs: []
  type: TYPE_NORMAL
- en: d.  None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   The concept of a “discount factor” in reinforcement learning is used
    to
  prefs: []
  type: TYPE_NORMAL
- en: a.  Reduce the size of the state space
  prefs: []
  type: TYPE_NORMAL
- en: b.  Decrease the rewards obtained from the environment
  prefs: []
  type: TYPE_NORMAL
- en: c.  Balance the importance of immediate rewards and future rewards
  prefs: []
  type: TYPE_NORMAL
- en: d.  Encourage exploration over exploitation
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Which of the following RL algorithms is considered an on-policy RL method?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Q-learning
  prefs: []
  type: TYPE_NORMAL
- en: b.  Twin-delayed deep deterministic policy gradient (TD3)
  prefs: []
  type: TYPE_NORMAL
- en: c.  Deep deterministic policy gradient (DDPG)
  prefs: []
  type: TYPE_NORMAL
- en: d.  Proximal policy optimization (PPO)
  prefs: []
  type: TYPE_NORMAL
- en: 1.6   PPO-clip and PPO-penalty are two variants of the policy gradient method
    designed to address potential instability during training.
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   Which multi-armed bandit strategy randomly selects a slot machine at
    each trial without considering past results?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Exploit-only greedy strategy
  prefs: []
  type: TYPE_NORMAL
- en: b.  Epsilon-greedy strategy
  prefs: []
  type: TYPE_NORMAL
- en: c.  Upper confidence bound (UCB) strategy
  prefs: []
  type: TYPE_NORMAL
- en: d.  Explore-only strategy
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   In the *ε*-greedy strategy, how does the agent balance exploration and
    exploitation?
  prefs: []
  type: TYPE_NORMAL
- en: a.  It always selects the machine with the highest estimated mean reward.
  prefs: []
  type: TYPE_NORMAL
- en: b.  It randomly selects a machine with a certain probability (epsilon) and otherwise
    selects the machine with the highest estimated mean reward.
  prefs: []
  type: TYPE_NORMAL
- en: c.  It explores all machines equally during each trial.
  prefs: []
  type: TYPE_NORMAL
- en: d.  It focuses on exploiting the current best machine only.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   What does “regret” measure in the multi-armed bandit problem?
  prefs: []
  type: TYPE_NORMAL
- en: a.  The difference between the maximum possible reward and the reward obtained
    from each selected machine
  prefs: []
  type: TYPE_NORMAL
- en: b.  The number of times the agent chooses to explore a new machine
  prefs: []
  type: TYPE_NORMAL
- en: c.  The total time spent in the same single state
  prefs: []
  type: TYPE_NORMAL
- en: d.  The total number of arms or actions available to the agent
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. What does the Markov decision process (MDP) represent in the context of
    reinforcement learning?
  prefs: []
  type: TYPE_NORMAL
- en: a.  A process that involves making decisions without considering state transitions
  prefs: []
  type: TYPE_NORMAL
- en: b.  A method for supervised learning using labeled datasets
  prefs: []
  type: TYPE_NORMAL
- en: c.  A mathematical framework for planning under uncertainty, in which actions
    influence future states with certain probabilities
  prefs: []
  type: TYPE_NORMAL
- en: d.  A type of optimization algorithm for clustering data
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Imagine you are a digital marketer running an online advertising campaign.
    You have several ad variations that you can display to users, each with its own
    click-through rate (CTR) or conversion rate. Click-through measures the rate at
    which users click on a link, while conversion measures the rate at which users
    complete a desired action after clicking on the link, such as making a purchase,
    signing up for a newsletter, or completing a form. Your goal is to maximize user
    engagement or conversions by selecting the most effective ad variation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume you have three ad variations, represented by arms A1, A2, and A3\.
    Each ad variation has an associated probability distribution of click-through
    or conversion rates, denoted as Q1, Q2, and Q3\. These probability distributions
    represent the likelihood of a user clicking on each ad variation. At each time
    step *t*, you need to choose an ad variation *A* to display to users. When ad
    variation *A* is displayed, users interact with it, and you observe the outcome,
    which can be a click or a conversion. The outcome is drawn from the probability
    distribution *Q*(*A*), representing the likelihood of a click or conversion for
    ad variation *A*. Assume that the three probability distributions Q1, Q2, and
    Q3 are normal distributions with means of {7, 10, 6} and standard deviations of
    {0.45, 0.65, 0.35} respectively. Your objective is to maximize the cumulative
    number of clicks over a series of ad displays (let’s say 10,000 ad displays).
    Write Python code to implement an *ε*-greedy strategy to determine which ad variation
    to display at each time step based on the estimated click-through rates.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   The taxi environment is based on the taxicab, or ride-hailing, problem,
    where a taxi must pick up a passenger from one location and drop them off at another
    specified location. The goal of the agent is to learn a policy that navigates
    the taxi through the grid to pick up and drop off passengers while maximizing
    the cumulative reward. When the episode starts, the taxi is at a random square,
    and the passenger is at a random location. The taxi drives to the passenger’s
    location, picks them up, drives to the passenger’s destination (another one of
    the four specified locations), and drops off the passenger. Once the passenger
    is dropped off, the episode ends. The states, actions, and rewards are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '•   States (observation space includes 500 discrete states): 25 taxi positions
    (any location within the 5 × 5 grid world); 5 passenger locations (0: R(ed); 1:
    G(reen); 2: Y(ellow); 3: B(lue); 4: in taxi) and 4 destinations (0: R(ed); 1:
    G(reen); 2: Y(ellow); 3: B(lue)). Thus, this taxi environment has a total of 5
    × 5 × 5 × 4 = 500 possible states.'
  prefs: []
  type: TYPE_NORMAL
- en: '•   Actions (action space includes 6 discrete actions): 0 = move south; 1 =
    move north; 2 = move east; 3 = move west; 4 = pick up passenger, and 5 = drop
    off passenger.'
  prefs: []
  type: TYPE_NORMAL
- en: '•   Rewards: +20 (a high positive reward for a successful drop off); –10 (a
    penalty for executing pickup and drop-off actions illegally, such as if the agent
    tries to drop off a passenger in a wrong location), and –1 (a slight negative
    reward for not making it to the destination after every time step, to mimic the
    delay).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write Python code to show how to use A2C to learn the optimal policy for this
    environment. Experiment with vectorized environments where multiple independent
    environments are stacked into a single environment. Vectorized environments enable
    you to run multiple instances of an environment in parallel. Instead of training
    an RL agent on one environment per step, it allows you to train it on *n* environments
    per step. For example, if you want to run four parallel environments, you can
    specify this number when you create the environment, as follows: `env = make_vec_env("Taxi-v3",
    n_envs=4, seed=0`.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.   In preparing for a scheduled flight, an airline’s flight operations team
    is tasked with selecting the best flight route and service according to the shared
    context. The shared context represents the type of flight (domestic or international)
    and the type of passengers (business class, economy class, or a mix). The flight
    operations team must decide the best strategy for flight route, meal service,
    and in-flight entertainment. The options are represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •   *Flight route*—The most direct route, a fuel-efficient route that may be
    longer, or a route that avoids turbulence but may require more time
  prefs: []
  type: TYPE_NORMAL
- en: •   *Meal service*—Full meal with multiple options, a simple meal with fewer
    options, or just snacks and beverages
  prefs: []
  type: TYPE_NORMAL
- en: •   *In-flight entertainment*—Movies and music, in-flight Wi-Fi service, or
    a combination of both
  prefs: []
  type: TYPE_NORMAL
- en: The reward is how satisfactory the chosen options are for a given flight (shared
    context). The reward function receives as arguments the shared context (the type
    of flight and passenger class) and the selected actions for each option (the chosen
    flight route, meal service, and in-flight entertainment). To mirror real-world
    scenarios and complexities, we inject normal noise in the reward value. The objective
    is to select the best action from the available combinatorial actions in such
    a way that it maximizes the total reward. Write Python code to train and test
    a contextual bandit for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Listing 11.4 shows how to solve TSP using an ML model pretrained with a
    supervised approach or a reinforcement learning approach. Replace the supervised
    learning model sl-ar-var-20pnn-gnn-max_20200308T172931 with the pretrained RL
    model rl-ar-var-20pnn-gnn-max_20200313T002243, and report your observations.
  prefs: []
  type: TYPE_NORMAL
- en: 6.   The gym-electric-motor (GEM) package is a Python toolbox designed for simulating
    and controlling electric motors. It is built upon OpenAI Gym environments and
    is suitable for classical control simulations and reinforcement learning experiments.
    Use GEM to define a permanent magnet synchronous motor (PMSM) environment as shown
    in figure C.38\. For more information about PMSM and GEM, see Traue et al.’s article
    “Toward a reinforcement learning environment toolbox for intelligent electric
    motor control” [10].
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F38_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.38 The gym-electric-motor (GEM) environment described in Traue et al
    's article [9]
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.24, provided in the book’s GitHub repo, provides a simplified implementation
    of PPO for electric motor control. This code is used to train a control model
    (a PPO RL agent) to control the current for a permanent magnet synchronous motor.
    This agent mainly controls the converter that converts the supply currents to
    the currents flowing into the motor. Experiment with different parameters in this
    algorithm and consider trying other RL models available in Stable-Baselines3 (SB3).
  prefs: []
  type: TYPE_NORMAL
- en: C.11.2 Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   b) The immediate feedback received from the environment
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   c) Learn an optimal policy to maximize cumulative rewards.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   b) Proximal policy optimization (PPO)
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   c) Balance the importance of immediate rewards and future rewards.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   d) Proximal policy optimization (PPO)
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   a) True
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   d) Explore-only strategy
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   b) It randomly selects a machine with a certain probability (epsilon)
    and otherwise selects the machine with the highest estimated mean reward.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   a) The difference between the maximum possible reward and the reward
    obtained from each selected machine
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. c) A mathematical framework for planning under uncertainty, in which actions
    influence future states with certain probabilities
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Listing C.21 shows an implementation of a *ε*-greedy strategy to determine
    which ad variation to display at each time step based on the estimated click-through
    rates. In this code snippet, 10,000 ad displays are simulated. The estimates of
    the click-through rates for each ad variation are updated after each display.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.21 Online advertising using MAB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: ① Initialize the number of arms (actions).
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize the number of trials (ads).
  prefs: []
  type: TYPE_NORMAL
- en: ③ Probability distribution of each arm
  prefs: []
  type: TYPE_NORMAL
- en: ④ Counters for each arm
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Select an initial arm.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Set the epsilon value of the epsilon-greedy algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Exploitation
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Add a small constant to avoid division by zero.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Exploration
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Calculate and print the estimated click-through rates.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, `counts` keeps track of the number of times each ad variation
    has been displayed, and `rewards` keeps track of the total number of clicks for
    each ad variation. At the end of the script, the estimated click-through rates
    for each ad variation are calculated and printed.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Listing C.22 shows the steps of learning the optimal policy for the taxicab
    problem using A2C. This code uses Stable-Baselines3 (SB3), a library for reinforcement
    learning, to train an agent using A2C on the Taxi-v3 environment. The SB3 function
    make_vec_env is used to create a vectorized environment that can run multiple
    parallel environments in the same process. The SB3 function evaluate_policy is
    used to evaluate the learned policy of the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.22 Dispatching a taxicab using A2C RL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: ① Create a vectorized environment with a single parallel environment (n_envs=1).
  prefs: []
  type: TYPE_NORMAL
- en: ② Print the observation and action spaces of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create an A2C agent with MlpPolicy as the policy network.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Train the A2C agent on the Taxi-v3 environment for 10,000 timesteps.
  prefs: []
  type: TYPE_NORMAL
- en: After the training is complete, the agent will have learned an optimal policy
    for navigating the Taxi-v3 environment to efficiently pick up and drop off passengers
    at the correct locations. The following code snippet visualizes the learned policy
    by rendering the Taxi-v3 environment using the trained A2C agent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: ① Create an empty list to store the frames (images) of the rendered environment.
  prefs: []
  type: TYPE_NORMAL
- en: ② Retrieve the environment associated with the model.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Reset the environment and obtain the initial observation after the reset.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Predict an action based on the current observation.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Get a new observation and the reward.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Render the environment as an RGB image.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Clear the output for the next image.
  prefs: []
  type: TYPE_NORMAL
- en: '4.   Listing C.23 shows the implementation of a contextual bandit for an airline’s
    flight operations using the Vowpal Wabbit Python library. The shared context is
    defined by two lists: flight_types and passenger_classes. The possible choices,
    or actions, for the bandit problem are defined by flight_routes, meal_services,
    and entertainment_options. The reward_function calculates the reward associated
    with a particular combination of flight route, meal service, and entertainment
    option. The rewards are generated using a normal distribution with different means
    for different choices. The standard deviation (scale) is set to 0.05, implying
    that the rewards are sampled from a normal distribution with a small amount of
    variance.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.23 Contextual bandit for an airline’s flight operations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: ① Set the shared context.
  prefs: []
  type: TYPE_NORMAL
- en: ② Set possible choices/action options.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Calculate the reward associated with a particular combination of options.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation, the following two utility functions are defined. `generate_combinations`
    generates combinations of flight routes, meal services, and entertainment options,
    along with their associated descriptions. `sample_truck_pmf` performs sampling
    based on a probability mass function (PMF):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a contextual bandit using the Vowpal Wabbit (VW) library
    and evaluate its performance over a specified number of iterations. This contextual
    bandit will make decisions (select actions) in the context of different flight
    types and passenger classes to maximize the expected reward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the key arguments to create contextual bandit:'
  prefs: []
  type: TYPE_NORMAL
- en: •   `--cb_explore_adf`—Enables contextual bandit exploration with action-dependent
    features
  prefs: []
  type: TYPE_NORMAL
- en: •   `--epsilon 0.2`—Sets the exploration rate to 0.2, meaning that the bandit
    will explore non-greedy actions with a probability of 0.2 (20% of the time)
  prefs: []
  type: TYPE_NORMAL
- en: •   `--interactions AA AU AAU`—Specifies three-way interactions between features
    AA, AU, and AAU
  prefs: []
  type: TYPE_NORMAL
- en: •   `-l 0.05`—Sets the learning rate to 0.05, which controls the step size in
    the learning process
  prefs: []
  type: TYPE_NORMAL
- en: •   `--power_t 0`—Specifies that the learning rate is constant (no learning
    rate decay)
  prefs: []
  type: TYPE_NORMAL
- en: •   `num_iterations = 2500`
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet allows us to run the created contextual bandit to
    make decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: ① Set the number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize an empty to store the rewards at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Select a random shared context in each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Generate all possible combinations of flight routes, meal services, and entertainment
    options based on the chosen shared context.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Predict the expected reward for each action (combination).
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Sample an index from the predicted rewards.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Retrieve individual choices for flight route, meal service, and entertainment.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Calculate the reward associated with the chosen action (combination) and shared
    context.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Append the reward information to the example.
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Learn from the updated examples.
  prefs: []
  type: TYPE_NORMAL
- en: ⑪ Close the workspace and finalize the learning process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can print the average reward during training as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Figure C.39 shows the progress of an average reward obtained in each iteration
    during the learning process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F39_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure C.39 Average reward in each iteration during the learning process
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete version of listing C.23 provided in the book’s GitHub repo defines
    a `test_model` function and then tests the contextual bandit model using a given
    shared context. The `test_model` function is defined to test the contextual bandit
    model by simulating a single decision-making instance for a given shared context.
    It takes four parameters—`shared_context`, `flight_routes`, `meal_services`, and
    `entertainment_options`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: ① Generate all possible combinations of flight routes, meal services, and entertainment
    options based on the given shared context.
  prefs: []
  type: TYPE_NORMAL
- en: ② Predict the expected reward for each action (combination) based on the provided
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Sample an index from the predicted rewards.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Retrieve the chosen action (combination).
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Retrieve individual choices for flight route, meal service, and entertainment.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Calculate the expected reward associated with the chosen action and shared
    context.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Print the chosen action and the expected reward.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Set a specific shared context.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Test the contextual bandit model's decision-making process for this specific
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will generate the output like the following for the given context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '5.   Replacing the included supervised learning model, sl-ar-var-20pnn-gnn-max_20200308T172931,
    with the pretrained RL model, rl-ar-var-20pnn-gnn-max_20200313T002243, in listing
    11.4 is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 6.   Listing C.24, available in the book’s GitHub repo, provides a simplified
    implementation of PPO for electric motor control. Experiment with the different
    parameters of this algorithm and consider trying other RL models available in
    SB3, such as advantage actor-critic (A2C), soft actor-critic (SAC), deep deterministic
    policy gradient (DDPG), deep Q network (DQN), hindsight experience replay (HER),
    and twin delayed DDPG (TD3).
  prefs: []
  type: TYPE_NORMAL
