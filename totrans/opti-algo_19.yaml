- en: Appendix C. Exercises and solutions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. 练习和解答
- en: In this appendix, you will find a comprehensive set of exercises and their corresponding
    solutions, organized by chapter, to enhance your understanding and the application
    of the material presented in this book. These exercises are designed to reinforce
    the concepts, theories, and practical skills covered throughout the chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，您将找到一套全面的练习及其相应的解答，按章节组织，以增强您对本书中所呈现材料的概念、理论和实际技能的理解和应用。这些练习旨在加强全书各章节中涵盖的概念、理论和实践技能。
- en: 'C.1 Chapter 2: A deeper look at search and optimization'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 第2章：深入探讨搜索和优化
- en: C.1.1 Exercises
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1.1 练习
- en: '1.   Multiple choice: Choose the correct answer for each of the following questions.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题：为以下每个问题选择正确的答案。
- en: 1.1.   _________ is the class of decision problems that can be solved by nondeterministic
    polynomial algorithms and whose solutions are hard to find but easy to verify.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   _________ 是一类可以通过非确定性多项式算法解决的问题，其解决方案难以找到但易于验证。
- en: a.  P
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: a.  P
- en: b.  NP
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: b.  NP
- en: c.  co-NP
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: c.  co-NP
- en: d.  NP-complete
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: d.  NP-complete
- en: e.  NP-hard
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: e.  NP-hard
- en: 1.2.   Which of the following benchmark (toy) problems is not NP-complete?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   以下哪个基准（玩具）问题不是 NP-complete？
- en: a.  Bin packing
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: a.  二进制装箱
- en: b.  Knapsack problem
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: b.  背包问题
- en: c.  Minimum spanning tree
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: c.  最小生成树
- en: d.  Hamiltonian circuit
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: d.  汉密尔顿回路
- en: e.  Vertex cover problem
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: e.  顶点覆盖问题
- en: 1.3.   _________ is the class of decision problems whose “No” answer can be
    verified in polynomial time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   _________ 是一类决策问题，其“否”答案可以在多项式时间内验证。
- en: a.  P
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: a.  P
- en: b.  NP
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: b.  NP
- en: c.  co-NP
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: c.  co-NP
- en: d.  NP-complete
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: d.  NP-complete
- en: e.  NP-hard
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: e.  NP-hard
- en: 1.4.   Which of the following real-world problems is NP-hard?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   以下哪个现实世界问题是 NP-hard？
- en: a.  Image matching
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: a.  图像匹配
- en: b.  Single machine scheduling
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: b.  单机调度
- en: c.  Combinational equivalence checking
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: c.  组合等价性检查
- en: d.  Capacitated vehicle routing problem (CVRP)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: d.  容量车辆路径问题（CVRP）
- en: e.  Container/truck loading
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: e.  容器/卡车装载
- en: 1.5.   _________ is a theory that focuses on classifying computational problems
    according to their resource usage and relating these classes to each other.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   _________ 是一种理论，它专注于根据资源使用情况对计算问题进行分类，并将这些类别相互关联。
- en: a.  Optimization complexity
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: a.  优化复杂度
- en: b.  Time complexity
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: b.  时间复杂度
- en: c.  Computational complexity
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: c.  计算复杂度
- en: d.  Operation research
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: d.  运筹学
- en: e.  Decision complexity
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: e.  决策复杂度
- en: 2.   Describe the following search and optimization problems in terms of decision
    variable (univariate, bivariate, multivariate); objective functions (mono-objective,
    multi-objective, no objective function, or constraint-satisfaction problem); constraints;
    (hard constraints, soft constraints, both hard and soft constraints, unconstrained);
    and linearity (linear programming (LP), quadratic programming (QP), nonlinear
    programming (NLP)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   用决策变量（单变量，双变量，多变量）；目标函数（单目标，多目标，无目标函数，或约束满足问题）；约束；（硬约束，软约束，硬软约束，无约束）；以及线性（线性规划（LP），二次规划（QP），非线性规划（NLP））来描述以下搜索和优化问题。
- en: a.  Minimize *y* + cos(*x*²), sin(*x*) – *x × y*, and 1 / (*x* + *y*)²
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: a.  最小化 *y* + cos(*x*²), sin(*x*) – *x × y*，以及 1 / (*x* + *y*)²
- en: b.  Maximize 2 – e^((1 –) *^x*^) subject to –3 ≤ *x* *< 10*
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: b.  在 –3 ≤ *x* *< 10* 的约束下最大化 2 – e^((1 –) *^x*^)
- en: c.  Maximize 3 *× x* – *y* / 5 subject to –2 ≤ *x* < 3, 0 < *y* ≤ 3, and *x*
    + *y* = 4
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: c.  在 –2 ≤ *x* < 3, 0 < *y* ≤ 3, 和 *x* + *y* = 4 的约束下最大化 3 *× x* – *y* / 5
- en: d.  The school districting problem consists of determining the groups of students
    attending each school of a school board located over a given territory in a way
    that maximizes the contiguity of school sectors, taking into consideration a number
    of hard constraints such as school capacity for each grade and class capacity.
    Walkability and keeping students in the same school from year to year are considered
    soft constraints in this problem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: d.  学校区域划分问题包括确定在给定区域内学校委员会所属的每个学校的学生群体，以最大化学校区域连续性，同时考虑一系列硬约束，如每个年级的学校容量和班级容量。在这个问题中，步行可达性和保持学生每年在同一个学校被认为是软约束。
- en: e.  The knapsack problem is an example of a combinatorial problem whose solution
    takes the form of a combination where the order doesn’t matter. As illustrated
    in figure C.1, given a set of items, each with a utility and a weight, the task
    is to select a subset of items to maximize the total utility while ensuring that
    the total weight of the selected items does not exceed a predefined capacity.
    The decision to include or exclude each item is binary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: e. 背包问题是一个组合问题示例，其解决方案形式为组合，其中顺序不重要。如图C.1所示，给定一组物品，每个物品都有效用和重量，任务是选择物品的子集以最大化总效用，同时确保所选物品的总重量不超过预定义的容量。是否包含或排除每个物品的决定是二元的。
- en: '![](../Images/APPC_F01_Khamis.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F01_Khamis.png)'
- en: Figure C.1 Each item has a utility and a weight, and we want to maximize the
    utility of the contents of the knapsack. The problem is constrained by the capacity
    of the bag.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.1 每个物品都有效用和重量，我们希望最大化背包内容的效用。该问题受背包容量的限制。
- en: 3.   For the following optimization problems, state the type of the problem
    (design, planning, or control problem) based on the permissible time to solve
    the problem and the expected quality of the solutions. Suggest the appropriate
    algorithm required to handle the optimization problem (offline versus online).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 对于以下优化问题，根据解决问题的允许时间和预期解决方案的质量，基于问题类型（设计、规划或控制问题）提出适当的算法（离线或在线）来处理优化问题。
- en: a.  Find the optimal wind park design where the number and types of wind turbines
    need to be chosen and placed based on the wind conditions and wind park area.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: a. 找到最佳的风电场设计，其中需要根据风条件和风电场面积选择和放置风力涡轮机的数量和类型。
- en: b.  Find multiple vehicle routes starting and ending at different depots so
    that all customer demands are fulfilled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: b. 找到多个车辆路线，这些路线从不同的仓库开始和结束，以便满足所有客户需求。
- en: c.  Create a fitness assistant for runners and cyclists that seamlessly automates
    the multiple tasks involved in planning fitness activities. The planner will assess
    an athlete’s current fitness level and individual training goals in order to create
    a fitness plan. The planner will also generate and recommend geographical routes
    that are both popular and customized to the user’s goals, level, and scheduled
    time, thus reducing the challenges involved in the planning stage. The suggested
    fitness plans will continuously adapt based on each user’s progress toward their
    fitness goals, thus keeping the athlete challenged and motivated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: c. 为跑步者和骑自行车者创建一个健身助手，无缝自动化规划健身活动所涉及的多项任务。规划者将评估运动员当前的健身水平和个人训练目标，以便制定健身计划。规划者还将生成并推荐既受欢迎又符合用户目标、水平和预定时间的地理路线，从而减少规划阶段所涉及到的挑战。建议的健身计划将根据每个用户向健身目标进步的情况持续调整，从而保持运动员的挑战性和动力。
- en: d.  Find a set of flights with departure and arrival times and aircraft assignments
    that maximize profits, given demand and revenues for every flight, route information
    distances, times, operating restrictions, aircraft characteristics and operating
    costs, and operational and managerial constraints.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: d. 在给定每班航班的需求和收入、路线信息（距离、时间）、运营限制、飞机特性和运营成本以及运营和管理约束的情况下，找到一组航班，其出发和到达时间以及飞机分配最大化利润。
- en: e.  Find the optimal schedule for delivery cargo bikes, semi and fully autonomous
    last-mile delivery trucks, self-driving delivery robots or delivery drones to
    maximize customer satisfaction and minimize delivery costs, taking into consideration
    the capacity of the vehicle, type of delivery service (a couple of days delivery,
    next-day delivery, or same-day delivery with some extra surcharge), delivery time,
    drop-off locations, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: e. 找到交付货物的自行车、半自动和全自动最后一英里配送卡车、自动驾驶配送机器人或配送无人机最优调度方案，以最大化客户满意度并最小化配送成本，同时考虑车辆容量、配送服务类型（几天配送、次日配送或加额外费用的当日配送）、配送时间、投放地点等因素。
- en: f.  Plan on-demand responsive transit during pandemics to support the transportation
    of essential workers and essential trips to pharmacies and grocery stores for
    the general public, especially the elderly, taking into consideration store operating
    hours, capacity, and online delivery options.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: f. 在疫情期间，计划按需响应式公共交通，以支持必要工作人员的运输以及公众（尤其是老年人）前往药店和杂货店的必要行程，同时考虑商店营业时间、容量和在线配送选项。
- en: g.  Find a collision-free path for a vehicle from a start position to a given
    goal position, amid a collection of obstacles, in such a way that minimizes the
    estimated time of arrival and the consumed energy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: g. 在一组障碍物中，为车辆从起始位置到给定的目标位置找到一条无碰撞路径，以最小化估计的到达时间和消耗的能量。
- en: h.  Develop a trip planner that minimizes total commute time, maximizes the
    average ratings of attractions, maximizes the duration spent at each of these
    attractions, and effectively minimizes idle time when someone visits a city.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: h. 开发一个行程规划器，以最小化总通勤时间，最大化景点平均评分，最大化在每个景点停留的时间，并在有人访问城市时有效地最小化闲置时间。
- en: i.  Find school bus loading patterns and schedules such that the number of routes
    is minimized, the total distance traveled by all buses is kept to a minimum, no
    bus is overloaded, and the time required to traverse any route does not exceed
    a maximum time policy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: i. 找到校车装载模式和日程安排，使得路线数量最小化，所有校车行驶的总距离保持在最低，没有校车超载，并且穿越任何路线所需的时间不超过最大时间政策。
- en: j.  Minimize deadheading for shared mobility companies (minimize the miles driven
    with no passenger) or for delivery services providers (minimize the miles driven
    without cargo).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: j. 最小化共享移动公司（最小化无乘客驾驶的里程）或配送服务提供商（最小化无货物驾驶的里程）的空驶。
- en: k.  Plan or replan transport corridors and city streets to accommodate more
    pedestrians, cyclists, and riders in shared transportation and fewer cars.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: k. 规划或重新规划交通走廊和城市街道，以容纳更多的行人、自行车和共享交通的骑行者，以及更少的汽车。
- en: l.  Find the optimal placement for bus stops, traffic sensors, micro mobility
    stations, EV charging stations, air taxi takeoff and landing locations, walking
    routes, and cycling lanes for active mobility.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: l. 找到公交车站、交通传感器、微移动站、电动汽车充电站、空中出租车起飞和降落位置、步行路线和自行车道的最佳位置，以促进活跃的移动性。
- en: 4.   Modify listing 2.6 to define the animal feed mix problem data using Python
    dictionaries or to read the problem data from a CSV file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   修改列表2.6，使用Python字典定义动物饲料混合问题数据，或从CSV文件中读取问题数据。
- en: C.1.2 Solutions
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1.2 解决方案
- en: 1.   Multiple choice
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题
- en: 1.1\. b) NP
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1\. b) NP
- en: 1.2\. c) Minimum spanning tree
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2\. c) 最小生成树
- en: 1.3\. c) co-NP
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3\. c) co-NP
- en: 1.4\. d) Capacitated vehicle routing problem (CVRP)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4\. d) 容量车辆路径问题 (CVRP)
- en: 1.5\. c) Computational complexity
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5\. c) 计算复杂性
- en: 2.   Optimization problem description
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   优化问题描述
- en: a.  Bivariate, multi-objective, unconstrained, nonlinear programming
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: a. 二元，多目标，无约束，非线性规划
- en: b.  Univariate, mono-objective, hard constraints, nonlinear programming
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: b. 单变量，单目标，硬约束，非线性规划
- en: c.  Bivariate, mono-objective, hard constraints, linear programming
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: c. 二元，单目标，硬约束，线性规划
- en: d.  Multivariate, mono-objective, both hard and soft constraints, linear programming
    (see Jacques A. Ferland and Gilles Guénette, “Decision support system for the
    school districting problem” [1])
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: d. 多变量，单目标，既有硬约束又有软约束，线性规划（参见Jacques A. Ferland和Gilles Guénette，“学校划区问题的决策支持系统”
    [1]）
- en: e.  Bivariate, mono-objective, hard constraints, linear programming
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: e. 二元，单目标，硬约束，线性规划
- en: 3.   Optimization problem and process
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   优化问题和过程
- en: a.  Design problem. Offline optimization.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: a. 设计问题。离线优化。
- en: b.  Planning problem during the process of generating the route, and control
    problem during rerouting. Offline optimization during planning, and online optimization
    during rerouting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在生成路线过程中的规划问题，以及在重新路由过程中的控制问题。规划阶段的离线优化，以及重新路由阶段的在线优化。
- en: c.  Planning problem to generate the plans and control problem for adaptation.
    Offline optimization during the planning phase, and online during the adaptation
    phase.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: c. 生成计划的规划问题，以及适应的控制问题。规划阶段的离线优化，以及适应阶段的在线优化。
- en: d.  Design problem to generate the flight schedule, and planning problem if
    adaptation is required, such as in the case of faulty aircraft or cancellation
    due to weather conditions. Offline optimization, and online optimization if adaptation
    is required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: d. 生成飞行计划的工程设计问题，以及在需要适应的情况下（例如，飞机故障或因天气条件取消）的规划问题。离线优化，以及在需要适应的情况下进行在线优化。
- en: e.  Planning problem during path generation, and control problem during rerouting
    for adaptive motion planning. Online optimization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: e. 在路径生成过程中的规划问题，以及在自适应运动规划中的重新路由过程中的控制问题。在线优化。
- en: f.  Planning problem for scheduling, and control problem if rerouting is involved.
    Online optimization.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: f. 调度问题的规划问题，以及涉及重新路由的控制问题。规划阶段的在线优化。
- en: g.  Planning problem to generate the plans, and control problem for adaptation.
    Online optimization.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: g.  规划问题以生成计划，控制问题以适应。在线优化。
- en: h.  Planning problem. Offline optimization.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: h.  规划问题。离线优化。
- en: i.  Design problem. Offline optimization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: i.  设计问题。离线优化。
- en: j.  Planning problem. Online optimization.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: j.  规划问题。在线优化。
- en: k.  Design problem. Offline optimization.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: k.  设计问题。离线优化。
- en: l.  Design problem. Offline optimization.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: l.  设计问题。离线优化。
- en: 4\. The next listing shows the steps for defining the animal feed mix problem
    data using Python dictionaries or to read the problem data from a CSV file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 下一个列表显示了使用Python字典定义动物饲料混合问题数据或从CSV文件读取问题数据的步骤。
- en: Listing C.1 Animal feed mix problem—defining data using dictionaries
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.1 动物饲料混合问题——使用字典定义数据
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Create a list of ingredients.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个成分列表。
- en: ② Dictionary of unit cost (cents/kg).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ② 单位成本（美分/kg）词典。
- en: ③ Dictionary of calcium (kg/kg).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 钙（kg/kg）词典。
- en: ④ Dictionary of protein (kg/kg).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 蛋白质（kg/kg）词典。
- en: ⑤ Create a model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建模型。
- en: ⑥ Dictionary called 'ingredient_vars' is created to contain the referenced variables.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 创建名为'ingredient_vars'的字典以包含引用的变量。
- en: ⑦ Add the objective function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 添加目标函数。
- en: ⑧ Add the five constraints.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 添加五个约束条件。
- en: ⑨ Solve the problem using PuLP's choice of solver.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 使用PuLP的求解器选择解决问题。
- en: ⑩ Print the results.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 打印结果。
- en: We can also read the problem data from a CSV file as follows.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以如下从CSV文件中读取问题数据。
- en: Listing C.2 Animal feed mix problem—reading problem data from a CSV file
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.2 动物饲料混合问题——从CSV文件读取问题数据
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Read the CSV file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ① 读取CSV文件。
- en: ② Convert data frame to a dictionary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将数据帧转换为字典。
- en: ③ Create a model.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建模型。
- en: ④ A dictionary called 'ingredient_vars' is created to contain the referenced
    variables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建名为'ingredient_vars'的字典以包含引用的变量。
- en: ⑤ Add the objective function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 添加目标函数。
- en: ⑥ Add the five constraints.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 添加五个约束条件。
- en: ⑦ Solve the problem using PuLP's choice of solver.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用PuLP的求解器选择解决问题。
- en: ⑧ Print the results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 打印结果。
- en: 'Running listing C.2 produces the following results:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表C.2产生以下结果：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'C.2 Chapter 3: Blind search algorithms'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 第3章：盲搜索算法
- en: C.2.1 Exercises
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和真/假题：为以下每个问题选择正确的答案。
- en: '1.1.   Big *O* specifically describes the limiting behavior of a function (worst-case
    scenario) when the argument tends toward a particular value or infinity, usually
    in terms of simpler functions. What is the big *O* of this expression: nlog(*n*)
    + log(2*n*)?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   大O符号特别描述了当参数趋向于特定值或无穷大时函数的极限行为（最坏情况），通常用更简单的函数来表示。这个表达式的big O是什么：nlog(*n*)
    + log(2*n*)？
- en: a.  Linearithmic
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: a.  线性对数
- en: b.  Loglinear
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: b.  对数线性
- en: c.  Quasilinear
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: c.  准线性
- en: d.  All of the above
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: d.  所有上述选项
- en: 1.2.   Which blind search algorithm implements a stack operation for searching
    the states?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   哪个盲搜索算法实现了状态搜索的栈操作？
- en: a.  Breadth-first search (BFS)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: a.  广度优先搜索（BFS）
- en: b.  Uniform-cost search (UCS)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: b.  均匀代价搜索（UCS）
- en: c.  Bidirectional search (BS)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: c.  双向搜索（BS）
- en: d.  Depth-first search (DFS)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: d.  深度优先搜索（DFS）
- en: e.  None of the above
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上皆非
- en: 1.3.   A tree is a connected graph with no circuits and no self-loops.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   树是一个无环无自环的连通图。
- en: a.  True
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.4.   For a very large workspace where the goal is deep within the workspace,
    the number of nodes could expand exponentially, and a depth-first search will
    demand a very large memory requirement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   在一个非常大的工作空间中，目标位于工作空间的深处，节点数量可能会呈指数级增长，深度优先搜索将需要非常大的内存需求。
- en: a.  True
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.5.   Best-first is a mixed-depth and breadth-first search that uses heuristic
    values and expands the most desirable unexpanded node.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   最佳优先搜索是一种混合深度和广度优先搜索，它使用启发式值并扩展最期望的未扩展节点。
- en: a.  True
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.6.   In design problems or strategic functions, optimality is usually traded
    in for speed gains.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   在设计问题或战略函数中，通常为了速度的提升而牺牲最优性。
- en: a.  True
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.7.   Graph traversal algorithms outperform shortest path algorithms in applications
    where the weights of edges in a graph are all equal.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   在图中边的权重都相等的应用中，图遍历算法优于最短路径算法。
- en: a.  True
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.8.   In Dijkstra’s algorithm, the priority queue is implemented using which
    data structure?.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   在Dijkstra算法中，优先队列使用哪种数据结构实现？
- en: a.  Stack
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: a.  栈
- en: b.  Queue
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: b.  队列
- en: c.  Heap
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: c.  堆
- en: d.  Array
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: d.  数组
- en: 1.9.   When is breadth-first search optimal?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9. 广度优先搜索何时是最佳选择？
- en: a.  When there are fewer nodes
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: a. 当节点较少时
- en: b.  When all step costs are equal
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: b. 当所有步骤成本相等时
- en: c.  When all step costs are unequal
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: c. 当所有步骤成本不相等时
- en: d.  None of the above
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: 1.10. Which blind search algorithm combines DFS’s space-efficiency and BFS’s
    fast search by incrementing the depth limit until the goal is reached?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. 哪个盲搜索算法通过增加深度限制直到达到目标，结合了DFS的空间效率和 BFS的快速搜索？
- en: a.  Depth-limited search (DLS)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: a. 深度限制搜索（DLS）
- en: b.  Iterative deepening search (IDS)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: b. 迭代加深搜索（IDS）
- en: c.  Uniform-cost search (UCS)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: c. 均匀代价搜索（UCS）
- en: d.  Bidirectional search (BS)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: d. 双向搜索（BS）
- en: e.  None of the above
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: e. 以上都不是
- en: 1.11. Which term describes an algorithm with a computational complexity of *O*(*n*
    log*n*)?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11. 哪个术语描述了一个计算复杂度为 *O*(*n* log*n*) 的算法？
- en: a.  Logarithmic
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: a. 对数
- en: b.  Exponential
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: b. 指数
- en: c.  Quasilinear
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: c. 准线性
- en: d.  None of the above
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: 1.12. Which search algorithm is implemented with an empty first in, first out
    queue?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12. 哪个搜索算法使用一个空的前进先出队列实现？
- en: a.  Depth-first search
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: a. 深度优先搜索
- en: b.  Breadth-first search
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: b. 广度优先搜索
- en: c.  Bidirectional search
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: c. 双向搜索
- en: d.  None of the above
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: 2.   Consider the simplified map shown in figure C.2, where the edges are labeled
    with actual distances between the cities. State the path from city A to city M
    that would be produced by BFS and the path produced by DFS.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 考虑图C.2中显示的简化地图，其中边标有城市之间的实际距离。说明BFS和DFS产生的从城市A到城市M的路径。
- en: '![](../Images/APPC_F02_Khamis.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F02_Khamis.png)'
- en: Figure C.2 A simplified map
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.2 一个简化的地图
- en: '3.   Find the big *O* notation for the following functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 找出以下函数的大O表示法：
- en: a.  10*n* + nlog(*n*)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: a. 10*n* + nlog(*n*)
- en: b.  4 + *n*/5
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: b. 4 + *n*/5
- en: c.  *n*⁵ – 20*n*³ + 170*n* + 208
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: c. *n*⁵ – 20*n*³ + 170*n* + 208
- en: d.  *n* + 10log(*n*)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: d. *n* + 10log(*n*)
- en: 4.   Consider the search space in figure C.3, where S is the start node and
    G1 and G2 are the goal nodes. Edges are labeled with the value of a cost function;
    the number gives the cost of traversing the arc. Above each node is the value
    of a heuristic function; the number gives the estimate of the distance to the
    goal. Assume that uninformed search algorithms always choose the left branch first
    when there is a choice. For each of the depth-first search (DFS) and breadth-first
    search (BFS) strategies
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 考虑图C.3中的搜索空间，其中S是起始节点，G1和G2是目标节点。边标有成本函数的值；数字给出穿越弧的成本。每个节点上方是启发函数的值；数字给出到目标距离的估计。假设在存在选择时，无信息搜索算法总是首先选择左分支。对于深度优先搜索（DFS）和广度优先搜索（BFS）策略
- en: a.  Indicate which goal state is reached first (if any).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: a. 指出首先达到的目标状态（如果有）。
- en: b.  List, in order, all the states that are popped off the OPEN list.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: b. 按顺序列出从OPEN列表中弹出的所有状态。
- en: '![](../Images/APPC_F03_Khamis.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F03_Khamis.png)'
- en: Figure C.3 A graph search exercise
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.3 一个图搜索练习
- en: 5.   Solve the crossword puzzle in figure C.4.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 解决图C.4中的填字游戏。
- en: '![](../Images/APPC_F04_Khamis.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F04_Khamis.png)'
- en: Figure C.4 Blind search crossword puzzle
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.4 盲搜索填字游戏
- en: Across
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 横向
- en: 2.   A depth-first search with a predetermined depth limit
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 一个具有预定深度限制的深度优先搜索
- en: 7.   A blind search algorithm that solves the single-source shortest path problem
    for a weighted graph with non-negative edge costs
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 一个盲搜索算法，用于解决加权图的单源最短路径问题，其中边的成本为非负
- en: 8.   A search algorithm that combines forward and backward search
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 一个结合正向和反向搜索的搜索算法
- en: 10.   A graph traversal algorithm that first explores nodes going through one
    adjacent to the root, then the next adjacent, until it finds a solution or until
    it reaches a dead end
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 一个图遍历算法，首先探索通过根节点相邻的节点，然后是下一个相邻的节点，直到找到解决方案或达到死胡同
- en: 11.   A variant of Dijkstra’s algorithm that is appropriate for large graphs
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 一个适用于大型图的Dijkstra算法的变体
- en: 13.   A function that is slightly faster than linear complexity
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 13. 一个比线性复杂度略快的函数
- en: 14.   A graph in which multiple edges may connect the same pair of vertices
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 14. 一个图中可能有多条边连接相同的顶点对
- en: 15.   A last in, first out (LIFO) data structure
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 15. 后进先出（LIFO）数据结构
- en: Down
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 向下
- en: 1.   A search algorithm that combines DFS’s space-efficiency and BFS’s fast
    search by incrementing the depth limit until the goal is reached
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 一个搜索算法，通过增加深度限制直到达到目标，结合了DFS的空间效率和 BFS的快速搜索
- en: 2.   A graph used by Twitter to represent following
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 2. Twitter用来表示关注的图
- en: 3.   A graph traversal search algorithm that is preferred when the tree is deep
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   当树很深时，优先选择的图遍历搜索算法
- en: 4.   A generalization of a graph in which generalized edges can join any number
    of nodes
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   一种图的泛化，其中泛化边可以连接任意数量的节点
- en: 5.   The type of graph used in LinkedIn to represent users, groups, unregistered
    persons, posts, skills, and jobs
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   LinkedIn用于表示用户、群组、未注册人员、帖子、技能和工作的图形类型
- en: 6.   A notation used to describe the performance or complexity of an algorithm
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   用于描述算法性能或复杂性的符号
- en: 9.   The process of exploring the structure of a tree or a graph by visiting
    the nodes following a certain well-defined rule
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 9.   通过遵循某个定义良好的规则访问节点来探索树或图形结构的过程
- en: 12.   A first in, first out (FIFO) data structure
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 12.   一种先进先出（FIFO）数据结构
- en: '**Hint:** Spaces or dashes *must* be used if the answer consists of two or
    more words.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：如果答案由两个或多个单词组成，则必须使用空格或破折号。'
- en: C.2.2 Solutions
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.2 解决方案
- en: 1.   Multiple choice and true/false
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多选题和判断题
- en: 1.1.   d) All of the above
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   d) 所有这些
- en: 1.2.   d) Depth-first search (DFS)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   d) 深度优先搜索 (DFS)
- en: 1.3.   a) True
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   a) 正确
- en: 1.4.   b) False
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   b) 错误
- en: 1.5.   a) True
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   a) 正确
- en: 1.6.   b) False
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   b) 错误
- en: 1.7.   a) True
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   a) 正确
- en: 1.8.   c) Heap
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   c) 堆
- en: 1.9.   b) When all step costs are equal
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   b) 当所有步骤成本相等时
- en: 1.10. b) Iterative deepening search (IDS)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. b) 迭代加深搜索（IDS）
- en: 1.11. c) Quasilinear
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11. c) 近线性
- en: 1.12. b) Breadth-first search
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12. b) 广度优先搜索
- en: 2.   The route obtained by BFS to go from A to M is
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   从A到M通过BFS得到的路径是
- en: 'A→B→H→C→E→I→L→D→F→J→K→M→H→G→J→K→M:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'A→B→H→C→E→I→L→D→F→J→K→M→H→G→J→K→M:'
- en: tracking back, the final route is A→H→L→M.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪回溯，最终路径是 A→H→L→M。
- en: The route obtained by DFS to go from A to M is A→B→H→C→E→F→G→J→K→I→M.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从A到M通过DFS得到的路径是 A→B→H→C→E→F→G→J→K→I→M。
- en: '3.   The solutions are the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   以下是一些解决方案：
- en: a.  *O*(nlogn)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: a.  *O*(nlogn)
- en: b.  *O*(*n*)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: b.  *O*(*n*)
- en: c.  *O*(*n*⁵)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: c.  *O*(*n*⁵)
- en: d.  *O*(logn)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: d.  *O*(logn)
- en: '4.   The solutions are the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   以下是一些解决方案：
- en: '| Search strategy | a | b |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 搜索策略 | a | b |'
- en: '| --- | --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Depth-first search** **(DFS)**Let’s assume that the nodes are expanded
    based on their lexicographical order (i.e., among the children of S, A is expanded
    first, since lexicographically, it is ordered before B and C). | G2 | S, A, D,
    H, J, G2 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **深度优先搜索** **(DFS)**假设节点根据它们的字典顺序扩展（即，在S的子节点中，A首先扩展，因为在字典上，它排在B和C之前）。 | G2
    | S, A, D, H, J, G2 |'
- en: '| **Breadth-first search** **(BFS)**The status of the queue evolves such that[S],
    [S,A,B,C], [S,A,B,C,D,H], [S,A,B,C,D,H,G1]Note: Since H is already visited by
    A, it is not pushed again to the queue when being visited by B. However, it is
    reached twice. | G1 | S, A, B, C, D, H, H, G1 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **广度优先搜索** **(BFS)**队列的状态演变如下[S]，[S,A,B,C]，[S,A,B,C,D,H]，[S,A,B,C,D,H,G1]注意：由于H已经被A访问过，当B访问它时，它不会被再次推入队列。然而，它被访问了两次。
    | G1 | S, A, B, C, D, H, H, G1 |'
- en: 5.   The crossword puzzle solutions are shown in figure C.5.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   跨字谜的解决方案显示在图C.5中。
- en: '![](../Images/APPC_F05_Khamis.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F05_Khamis.png)'
- en: Figure C.5 Blind search crossword puzzle solution
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.5 盲搜索字谜解决方案
- en: 'C.3 Chapter 4: Informed search algorithms'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.3 第4章：启发式搜索算法
- en: C.3.1 Exercises
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多选题和判断题：为以下每个问题选择正确的答案。
- en: 1.1   How many shortcuts will we have to add to the augmented graph if we decide
    to contract node E in figure C.6?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1   如果我们决定在图C.6中合并节点E，我们需要在增强图中添加多少条捷径？
- en: '![](../Images/APPC_F06_Khamis.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F06_Khamis.png)'
- en: Figure C.6 Contracting node E
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.6 合并节点E
- en: a.  0
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: a.  0
- en: b.  1
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: b.  1
- en: c.  2
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: c.  2
- en: d.  3
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: d.  3
- en: 1.2   The A* algorithm is a special version of
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2   A*算法是以下哪种算法的特殊版本？
- en: a.  Breadth-first search
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: a.  广度优先搜索
- en: b.  Depth-first search
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: b.  深度优先搜索
- en: c.  Hill climbing
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: c.  爬山法
- en: d.  Best-first search
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: d.  最佳优先搜索
- en: e.  Dijkstra’s algorithm
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: e.  Dijkstra算法
- en: 1.3   Which of the following is *not* a variant of the hill climbing algorithm?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3   以下哪项不是爬山算法的变体？
- en: a.  Complex hill climbing
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: a.  复杂的爬山法
- en: b.  Steepest-ascent hill climbing
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: b.  最陡上升爬山法
- en: c.  Random-restart hill climbing
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: c.  随机重启爬山法
- en: d.  Steepest-ascent hill climbing
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: d.  最陡上升爬山法
- en: e.  All of the above are variants of hill climbing.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: e.  所有这些都是爬山算法的变体。
- en: 1.4   If *f*(*n*) is the evaluation function (cost) of a path through *n* to
    the goal for each node, and *h*(*n*) is an estimated cost from *n* to the goal,
    such as the straight-line distance from *n* to the goal, what is the heuristic
    function of greedy best-first search?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4   如果*f*(*n*)是通过*n*到目标路径的评估函数（成本），而*h*(*n*)是从*n*到目标的估计成本，例如从*n*到目标的目标距离，那么贪婪最佳优先搜索的启发式函数是什么？
- en: a.  *f*(*n*) ≠ *h*(*n*)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: a.  *f*(*n*) ≠ *h*(*n*)
- en: b.  *f*(*n*) < *h*(*n*)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: b.  *f*(*n*) < *h*(*n*)
- en: c.  *f*(*n*) = *h*(*n*)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: c.  *f*(*n*) = *h*(*n*)
- en: d.  *f*(*n*) > *h*(*n*)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: d.  *f*(*n*) > *h*(*n*)
- en: 1.5   In the directed weighted graph in figure C.7, how many shortcuts are needed
    if we contract the white node?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5   在图C.7中的有向加权图中，如果我们收缩白色节点，需要多少条捷径？
- en: '![](../Images/APPC_F07_Khamis.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F07_Khamis.png)'
- en: Figure C.7 Directed graph
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.7 有向图
- en: a.  0
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: a.  0
- en: b.  1
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: b.  1
- en: c.  2
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: c.  2
- en: d.  3
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: d.  3
- en: e.  4
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: e.  4
- en: 1.6   The search strategy that uses problem-specific knowledge is known as
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6   使用特定问题知识的搜索策略被称为
- en: a.  Informed search
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: a.  启发式搜索
- en: b.  Best-first search
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: b.  最佳优先搜索
- en: c.  A* search
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: c.  A*搜索
- en: d.  Heuristic search
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: d.  启发式搜索
- en: e.  All of the above
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上所有
- en: 1.7   Which of the following is an algorithm used to solve the MST problem?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7   以下哪个算法用于解决最小生成树（MST）问题？
- en: a.  Kruskal
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: a.  克鲁斯卡尔
- en: b.  Borůvka
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: b.  博鲁夫卡
- en: c.  Jarník-Prim
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: c.  焦点-普里姆
- en: d.  Chazelle
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: d.  查泽勒
- en: e.  All of the above
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上所有
- en: 1.8   Hill climbing is an informed breadth-first search that demands little
    in terms of memory and computational overhead.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8   梯度上升是一种信息丰富的广度优先搜索，对内存和计算开销要求不高。
- en: a.  True
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.9   Node ordering methods for CH include
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9   CH的节点排序方法包括
- en: a.  Edge difference
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: a.  边差异
- en: b.  Iterative updates
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: b.  迭代更新
- en: c.  Number of contracted neighbors
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: c.  收缩邻居的数量
- en: d.  Shortcut cover
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: d.  捷径覆盖
- en: e.  All of the above
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上所有
- en: 1.10 A* is optimal if *h*(*n*) is an admissible heuristic, i.e., *h*(*n*) never
    overestimates the cost to reach the goal.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10 如果*h*(*n*)是可接受的启发式，即*h*(*n*)从不高估到达目标成本，那么A*是最佳的。
- en: a.  True
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.11 The edge difference is the number of shortcuts introduced when contracting
    a node minus the number of incoming edges onto the node.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11 边差异是在收缩节点时引入的捷径数量减去进入节点的入边数量。
- en: a.  True
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.12 Best-first is a mixed depth- and breadth-first search that uses heuristic
    values and expands the most desirable unexpanded node.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12 最佳优先搜索是一种混合深度和广度优先搜索，它使用启发式值并扩展最理想的未扩展节点。
- en: a.  True
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.13 What is the evaluation function in A* search?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 1.13 A*搜索中的评估函数是什么？
- en: a.  Estimated cost from the current node to the goal node
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: a.  从当前节点到目标节点的估计成本
- en: b.  Cost of the path through the current node to the goal node
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: b.  通过当前节点到目标节点的路径成本
- en: c.  Sum of the path cost through the current node to the goal node and the estimated
    cost from the current node to the goal node
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: c.  通过当前节点到目标节点的路径成本和从当前节点到目标节点的估计成本之和
- en: d.  Average of the path cost through the current node to the goal node and the
    estimated cost from the current node to the goal node
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: d.  通过当前节点到目标节点的路径成本和从当前节点到目标节点的估计成本的平均值
- en: e.  None of the above
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上都不是
- en: 1.14 Which search is complete and optimal when *h*(*n*) is consistent?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 1.14 当*h*(*n*)一致时，哪种搜索是完整的且最优的？
- en: a.  Best-first search
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: a.  最佳优先搜索
- en: b.  Depth-first search
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: b.  深度优先搜索
- en: c.  Both best-first and depth-first search
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: c.  最佳优先搜索和深度优先搜索
- en: d.  A* search
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: d.  A*搜索
- en: 1.15 In the contraction hierarchies (CH) algorithm, we contract nodes based
    on which of the following?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 1.15 在收缩层次（CH）算法中，我们根据以下哪个因素收缩节点？
- en: a.  Decreasing order of their importance
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: a.  重要性递减顺序
- en: b.  Increasing order of their importance
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: b.  重要性递增顺序
- en: 1.16 The A* search algorithm tries to reduce the total number of states explored
    by incorporating a heuristic estimate of the cost to get the goal from a given
    state.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 1.16 A*搜索算法通过结合从给定状态到达目标的启发式成本估计来尝试减少探索的总状态数。
- en: a.  True
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.17 The hill climbing algorithm is a local greedy search algorithm that tries
    to improve the efficiency of breadth-first search.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 1.17 梯度上升算法是一种局部贪婪搜索算法，它试图提高广度优先搜索的效率。
- en: a.  True
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.18 In CH, the importance of a node may change during the contraction process,
    necessitating the recomputation of its importance.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 1.18 在CH中，节点的重要性可能在收缩过程中发生变化，需要重新计算其重要性。
- en: a.  True
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.19 A beam search with a beam width equal to the number of nodes in each level
    is the same as
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 1.19 带有与每层节点数相等的波束宽度的波束搜索与
- en: a.  Breadth-first search
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: a.  广度优先搜索
- en: b.  Depth-first search
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: b.  深度优先搜索
- en: c.  Hill climbing
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: c.  爬山法
- en: d.  Best-first search
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: d.  最佳优先搜索
- en: e.  Dijkstra’s algorithm
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: e.  Dijkstra算法
- en: 1.20 In CH, the order of contraction does not affect the query performance.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 1.20 在CH中，收缩的顺序不影响查询性能。
- en: a.  True
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 2.   Consider the search space in figure C.8, where S is the start node and
    G1 and G2 are the goal nodes. The edges are labeled with the value of a cost function;
    the number gives the cost of traversing the arc. Above each node is the value
    of a heuristic function; the number gives the estimate of the distance to the
    goal. Using A* search strategy
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   考虑图C.8中的搜索空间，其中S是起始节点，G1和G2是目标节点。边标有成本函数的值；数字给出穿越弧的成本。每个节点上方是启发式函数的值；数字给出到目标距离的估计。使用A*搜索策略
- en: a.  Indicate which goal state is reached first (if any)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: a.  指出首先达到哪个目标状态（如果有）
- en: b.  List in order all the states that are popped off until one of the goal state
    is found
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: b.  按顺序列出所有弹出的状态，直到找到目标状态之一
- en: '![](../Images/APPC_F08_Khamis.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F08_Khamis.png)'
- en: Figure C.8 Search space
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.8 搜索空间
- en: 3.   In the word search puzzle shown in figure C.9, find the hidden terms used
    in this chapter. You can search horizontally (from left to right or from right
    to left), vertically (from top to bottom or from bottom to top), or diagonally.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   在图C.9所示的单词搜索谜题中，找到本章中使用的隐藏术语。你可以水平搜索（从左到右或从右到左），垂直搜索（从上到下或从下到上），或对角线搜索。
- en: '![](../Images/APPC_F09_Khamis.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F09_Khamis.png)'
- en: Figure C.9 Informed search word-search puzzle
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.9 信息搜索单词搜索谜题
- en: C.3.2 Solutions
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3.2 解决方案
- en: '1.   Multiple choice and true/false:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和判断题：
- en: 1.1   a) 0 (no shortcut needed because a witness path exists between A and D)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1   a) 0（不需要捷径，因为A和D之间存在见证路径）
- en: 1.2   d) Best-first search
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2   d) 最佳优先搜索
- en: 1.3   a) Complex hill climbing
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3   a) 复杂爬山法
- en: 1.4   c) *f*(*n*) = *h*(*n*)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4   c) *f*(*n*) = *h*(*n*)
- en: 1.5   c) 2
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5   c) 2
- en: 1.6   e) All of the above
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6   e) 所有上述选项
- en: 1.7   e) All of the above
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7   e) 所有上述选项
- en: 1.8   b) False (It is a variant of depth-first search.)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8   b) 错误（它是深度优先搜索的一个变体。）
- en: 1.9   e) All of the above
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9   e) 所有上述选项
- en: 1.10 a) True
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10 a) 正确
- en: 1.11 b) False (Edge difference is the number of shortcuts introduced when contracting
    a node minus the total degree of the node; i.e., the sum of the number of incoming
    edges onto the node plus the number of outgoing edges emanating from the node.)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11 b) 错误（边差异是在收缩节点时引入的捷径数减去节点的总度数；即，进入节点的边数之和加上从节点发出的边数。）
- en: 1.12 a) True
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12 a) 正确
- en: 1.13 b) Cost of the path through the current node to the goal node
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 1.13 b) 从当前节点到目标节点的路径成本
- en: 1.14 d) A* search
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 1.14 d) A*搜索
- en: 1.15 b) Increasing order of their importance
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 1.15 b) 按重要性递增的顺序
- en: 1.16 a) True
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 1.16 a) 正确
- en: 1.17 b) False
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 1.17 b) 错误
- en: 1.18 a) True
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 1.18 a) 正确
- en: 1.19 a) Breadth-first search
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 1.19 a) 广度优先搜索
- en: 1.20 b) False (The order of contraction does not affect the success of CH but
    will affect the preprocessing time and the query time. Some contraction ordering
    systems minimize the number of the shortcuts added in the augmented graph, and
    thus the overall running time.)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 1.20 b) 错误（收缩的顺序不影响CH的成功，但会影响预处理时间和查询时间。一些收缩顺序系统最小化在增强图中添加的捷径数，从而影响总体运行时间。）
- en: 2.   The order of expansion is based on the sum of edge weights *g*(*n*) and
    the heuristic estimation *h*(*n*); i.e., *f*(*n*) = *g*(*n*) + *h*(*n*). For example,
    starting from S, *f*(A) = 8, *f*(B) = 18, and *f*(C) = 9, so the queue would look
    like [A,B,C] because *f*(A) < *f*(C) < *f*(B).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   扩展的顺序基于边权重之和 *g*(*n*) 和启发式估计 *h*(*n*)；即，*f*(*n*) = *g*(*n*) + *h*(*n*)。例如，从S开始，*f*(A)
    = 8，*f*(B) = 18，*f*(C) = 9，因此队列将看起来像[A,B,C]，因为*f*(A) < *f*(C) < *f*(B)。
- en: At the next step, when A is popped off the queue, nodes D and H are evaluated
    such that *f*(D) = *d*(S,A) + *d*(A,D) + *h*(D) = 1 + 5 + 4 = 10, and *f*(H) =
    *d*(S,A) + *d*(A,H) + *h*(H) = 19, and pushing them onto the queue in order will
    result in [A,C,D,B,H].
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步，当A从队列中弹出时，节点D和H将被评估，*f*(D) = *d*(S,A) + *d*(A,D) + *h*(D) = 1 + 5 + 4 =
    10，*f*(H) = *d*(S,A) + *d*(A,H) + *h*(H) = 19，按照顺序将它们推入队列将导致[A,C,D,B,H]。
- en: 'Therefore, the next node to be expanded would be C, which adds E and F to the
    queue with *f*(E) = 11 and *f*(F) = 19: [A,C,D,E,B,H,F]'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，下一个要扩展的节点将是C，它将E和F添加到队列中，其中*f*(E) = 11和*f*(F) = 19: [A,C,D,E,B,H,F]'
- en: 'Hence, the next node is D, which causes an update on *f*(H) = *d*(S,A) + *d*(A,D)
    + *d*(D,H) + *h*(H) = 1 + 5 + 2 + 6 = 14 that subsequently repositions it in the
    queue: [A,C,D,E,H,B,F]. The same strategy should be followed until one of the
    goals is found.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一个节点是 D，这导致 *f*(H) = *d*(S,A) + *d*(A,D) + *d*(D,H) + *h*(H) = 1 + 5 + 2
    + 6 = 14 的更新，随后将其重新定位到队列中：[A,C,D,E,H,B,F]。应遵循相同的策略，直到找到其中一个目标。
- en: a.  G1
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: a.  G1
- en: b.  S, A, C, D, E, H, B, G1
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: b.  S, A, C, D, E, H, B, G1
- en: 3.   The solution to the word search puzzle is shown in figure C.10.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   单词搜索谜题的解决方案如图 C.10 所示。
- en: '![](../Images/APPC_F10_Khamis.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F10_Khamis.png)'
- en: Figure C.10 Informed search word-search puzzle solution
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.10 信息搜索单词搜索谜题解决方案
- en: The word directions and start points are formatted as (direction, *X, Y*).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 方向和起点以 (方向, *X, Y*) 的格式表示。
- en: A-START (E, 7, 10)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: A-START (E, 7, 10)
- en: BEAM SEARCH (E, 8, 6)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: BEAM SEARCH (E, 8, 6)
- en: BEST-FIRST (E, 8, 9)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: BEST-FIRST (E, 8, 9)
- en: DEPTH-FIRST (E, 7, 12)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: DEPTH-FIRST (E, 7, 12)
- en: DOWNWARD GRAPH
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: DOWNWARD GRAPH
- en: (E, 3, 11)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: (E, 3, 11)
- en: EDGE DIFFERENCE (E, 2, 4)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: EDGE DIFFERENCE (E, 2, 4)
- en: HAVERSINE (E, 2, 8)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: HAVERSINE (E, 2, 8)
- en: HILL CLIMBING (E, 5, 1)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: HILL CLIMBING (E, 5, 1)
- en: INFORMED SEARCH (E, 3, 3)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: INFORMED SEARCH (E, 3, 3)
- en: KRUSKAL ALGORITHM (E, 2, 7)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: KRUSKAL ALGORITHM (E, 2, 7)
- en: WITNESS PATH (S,1, 1)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: WITNESS PATH (S,1, 1)
- en: 'C.4 Chapter 5: Simulated annealing'
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.4 第 5 章：模拟退火
- en: C.4.1 Exercises
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.4.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和判断题：为以下每个问题选择正确的答案。
- en: 1.1   Simulated Annealing, unlike hill climbing, incorporates a probabilistic
    mechanism that allows it to accept downward steps, influenced by the current temperature
    and the quality of the move being considered.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1   与爬山法不同，模拟退火结合了概率机制，允许它接受下降步骤，受当前温度和考虑的移动质量的影响。
- en: a.  True
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.2   Simulated annealing is an optimization technique that always guarantees
    finding the global optimum solution.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2   模拟退火是一种优化技术，它始终保证找到全局最优解。
- en: a.  True
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.3   Dual annealing is an implementation of generalized hill climbing.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3   双重退火是广义爬山法的实现。
- en: a.  True
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.4   In totally adaptive SA, a random combination of previously accepted steps
    and parameters are used to estimate new steps and parameters.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4   在完全自适应的模拟退火中，使用先前接受的一组步骤和参数的随机组合来估计新的步骤和参数。
- en: a.  True
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.5   The simulated annealing algorithm explores more of the search space when
    the temperature gets lower.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5   当温度降低时，模拟退火算法探索更多的搜索空间。
- en: a.  True
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.6.   Which cooling schedule asymptotically converges toward the global minimum
    but requires prohibitive computing time?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   哪种冷却计划在渐近收敛到全局最小值时需要可观的计算时间？
- en: a.  Linear cooling schedule
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: a.  线性冷却计划
- en: b.  Geometric cooling schedule
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: b.  几何冷却计划
- en: c.  Logarithmic cooling schedule
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: c.  对数冷却计划
- en: d.  Exponential cooling schedule
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: d.  指数冷却计划
- en: e.  Nonmonotonic adaptive cooling schedule
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: e.  非单调自适应冷却计划
- en: 1.7.   SA uses a thermal jump to avoid getting trapped in local minima while
    quantum annealing relies on quantum tunneling.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   模拟退火使用热跃迁来避免陷入局部最小值，而量子退火则依赖于量子隧穿。
- en: a.  True
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 2.   The Rosenbrock function, often referred to as the “valley” or “banana”
    function, is a nonconvex function that is defined as *f*(*x*,*y*) = (1 – *x*)²
    + 100(*y* – *x*²)². This is a standard test function and quite tough for most
    conventional solvers.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   罗森布鲁克函数，通常被称为“山谷”或“香蕉”函数，是一个非凸函数，定义为 *f*(*x*,*y*) = (1 – *x*)² + 100(*y*
    – *x*²)²。这是一个标准的测试函数，对于大多数传统求解器来说相当困难。
- en: a.  Use listing 5.1 or 5.2 or implement your own version of the simulated annealing
    algorithm from scratch or using one the libraries mentioned in section A.4 of
    appendix A to find the global minimum of this function.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: a.  使用列表 5.1 或 5.2 或从头开始实现模拟退火算法的版本，或者使用附录 A 中 A.4 节提到的库来找到该函数的全局最小值。
- en: 'b.  This banana function is still relatively simple, as it has a curved narrow
    valley. Other functions, such as the egg crate function, are strongly multimodal
    and highly nonlinear. Solve this egg crate function as an example of a highly
    nonlinear multimodal function: *f*(*x*,*y*) = *x*² + *y*² + 25[sin²(*x*) + sin²(*y*)].
    Consider the domain (*x*,*y*) ∈ [–5,5] × [–5,5]. It would take about 2,500 evaluations
    to get an optimal solution accurate to the third decimal place.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: b.  这个香蕉函数仍然相对简单，因为它有一个弯曲的狭窄山谷。其他函数，如蛋格函数，具有强烈的多个峰值和高度非线性。以下是一个高度非线性多峰函数的例子：*f*(*x*,*y*)
    = *x*² + *y*² + 25[sin²(*x*) + sin²(*y*)]。考虑域(*x*,*y*) ∈ [–5,5] × [–5,5]。要得到一个精确到小数点后三位的最佳解，大约需要2,500次评估。
- en: c.  Investigate the rate of convergence of simulated annealing for different
    cooling schedules.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: c.  调查模拟退火对不同冷却计划的收敛速度。
- en: d.  For standard SA, the cooling schedule is a monotonically decreasing function.
    There is no reason why we should not use other forms of cooling. For example,
    we can use *T*(*i*) = *T*[o] cos²(*i*)*e*^–*^α^i*, *α* *> 0*. Modify the code
    implemented in the previous step to study the behavior of various functions as
    a cooling schedule.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: d.  对于标准SA，冷却计划是一个单调递减的函数。我们没有理由不使用其他形式的冷却。例如，我们可以使用 *T*(*i*) = *T*[o] cos²(*i*)*e*^–*^α^i*,
    *α* > 0。修改之前步骤中实现的代码，以研究各种函数作为冷却计划的行为。
- en: 3.   Modify listing 5.5, or use ASA-GS [2], or implement your own version of
    simulated annealing to conduct a comparative study between different TSP datasets
    (see listing B.2 in appendix B to see how to get access to TSP instances). Fill
    in table C.1 with the tour length obtained by simulated annealing.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   修改列表5.5，或使用ASA-GS [2]，或实现自己的模拟退火版本以对不同TSP数据集进行对比研究（参见附录B中的列表B.2以了解如何获取TSP实例）。用模拟退火得到的行程长度填写表C.1。
- en: Table C.1 SA solutions for different TSP datasets
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.1 不同TSP数据集的SA解
- en: '| Dataset | Best known solution | SA solution | CPU time (s) |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 数据集 | 已知最佳解 | SA解 | CPU时间（秒） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| burma14ulysses22oliver30att48eil51eil75kroA100d198 | 30.875875.665142033,52442653521,28215,780
    |  |  |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 缅甸14乌利塞斯22奥利弗30阿特48艾尔51艾尔75克罗A100d198 | 30.875875.665142033,52442653521,28215,780
    |  |  |'
- en: '4.   Solve TSP for 20 major US cities as shown in figure C.11\. In this TSP,
    a travelling salesman must visit a number US cities starting from a specific city.
    Assume the following cities, defined by their names and GPS latitude and longitude
    coordinates: New York City (40.72, –74.00); Philadelphia (39.95, –75.17); Baltimore
    (39.28, –76.62); Charlotte (35.23, –80.85); Memphis (35.12, –89.97); Jacksonville
    (30.32, –81.70); Houston (29.77, –95.38); Austin (30.27, –97.77); San Antonio
    (29.53, –98.47); Fort Worth (32.75, –97.33); Dallas (32.78, –96.80); San Diego
    (32.78, –117.15); Los Angeles (34.05, –118.25); San Jose (37.30, –121.87); San
    Francisco (37.78, –122.42); Indianapolis (39.78, –86.15); Phoenix (33.45, –112.07);
    Columbus (39.98, –82.98); Chicago (41.88, –87.63); and Detroit (42.33, –83.05).
    Visualize the cities and the generated solution as a NetworkX graph using the
    GPS coordinates of each city.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   解决图C.11所示的20个主要美国城市的TSP问题。在这个TSP中，旅行商必须从一个特定的城市开始访问多个美国城市。假设以下城市，由它们的名称和GPS纬度和经度坐标定义：纽约市（40.72,
    –74.00）；费城（39.95, –75.17）；巴尔的摩（39.28, –76.62）；夏洛特（35.23, –80.85）；孟菲斯（35.12, –89.97）；杰克逊维尔（30.32,
    –81.70）；休斯顿（29.77, –95.38）；奥斯汀（30.27, –97.77）；圣安东尼奥（29.53, –98.47）；沃斯堡（32.75,
    –97.33）；达拉斯（32.78, –96.80）；圣地亚哥（32.78, –117.15）；洛杉矶（34.05, –118.25）；圣何塞（37.30,
    –121.87）；旧金山（37.78, –122.42）；印第安纳波利斯（39.78, –86.15）；凤凰城（33.45, –112.07）；哥伦布（39.98,
    –82.98）；芝加哥（41.88, –87.63）；底特律（42.33, –83.05）。使用每个城市的GPS坐标将城市和生成的解决方案可视化为一个NetworkX图。
- en: '![](../Images/APPC_F11_Khamis.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F11_Khamis.png)'
- en: Figure C.11 Travelling salesman problem (TSP) for 20 largest US cities
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.11 20个最大美国城市的旅行商问题（TSP）
- en: 5.   Solve the crossword puzzle in figure C.12.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   解决图C.12中的填字游戏
- en: '![](../Images/APPC_F12_Khamis.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F12_Khamis.png)'
- en: Figure C.12 Simulated annealing crossword puzzle
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.12 模拟退火填字游戏
- en: Across
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 横向
- en: 6.   An optimization process that searches an energy landscape to find the optimal
    or near-optimal solution by applying quantum effects
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   通过应用量子效应在能量景观中搜索以找到最优或近似最优解的优化过程
- en: 7.   The probability of acceptance or rejection of neighboring solutions
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 7.   接受或拒绝邻近解的概率
- en: 10.   A cooling process by which the temperature is decreased very quickly during
    the first iterations but the speed of the exponential decay is slowed down later
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 10.   一种冷却过程，在最初的迭代中温度迅速降低，但随后指数衰减的速度减慢
- en: 11.   A cooling schedule in which the maximum number of iterations needs to
    be specified
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 11.   需要指定最大迭代次数的冷却计划
- en: 12.   Compared to this search algorithm, the main difference is that SA probabilistically
    allows downward steps controlled by current temperature and how bad a move is.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 12.   与此搜索算法相比，主要区别在于SA概率性地允许由当前温度和移动的好坏控制的向下步骤。
- en: 13.   A cooling schedule that requires a prohibitive computing time
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 13.   一种需要禁用计算时间的冷却计划
- en: Down
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 向下
- en: 1.   A stochastic or probabilistic model that describes a sequence of possible
    moves in which the probability of each move depends only on the state attained
    in the previous move
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   一种随机或概率模型，描述了一系列可能的移动，其中每个移动的概率仅取决于前一个移动达到的状态
- en: 2.   A cooling schedule that explicitly takes into consideration how the search
    is progressing
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   一种明确考虑搜索进展情况的冷却计划
- en: 3.   A cooling schedule that decreases the temperature by a cooling factor
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   一种通过冷却因子降低温度的冷却计划
- en: 4.   An optimization process based on the physical annealing process
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   基于物理退火过程的优化过程
- en: 5.   Probability distribution used in transition probability of simulated annealing
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   用于模拟退火转换概率的概率分布
- en: 8.   A quantum mechanical phenomenon whereby a wavefunction can propagate through
    a potential barrier
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 8.   一种量子力学现象，其中波函数可以通过势垒传播
- en: 9.   State of the system at which no better or worse moves are being accepted
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 9.   系统状态，其中不接受更好或更差的移动
- en: 'Hint: Spaces and dashes *must* be used if the answer consists of two words.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果答案由两个单词组成，则必须使用空格和破折号。
- en: C.4.2 Solutions
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.4.2 解决方案
- en: 1.   Multiple choice and true/false
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和真/假题
- en: 1.1   a) True
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1   a) 正确
- en: 1.2   b) False
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2   b) 错误
- en: 1.3   b) False (Dual annealing is an implementation of the generalized simulated
    annealing algorithm.)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3   b) 错误（双重退火是广义模拟退火算法的一种实现。）
- en: 1.4   a) True
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4   a) 正确
- en: 1.5   b) False (The simulated annealing algorithm exploits the search space
    when the temperature gets lower.)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5   b) 错误（模拟退火算法在温度降低时利用搜索空间。）
- en: 1.6   c) Logarithmic cooling schedule
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6   c) 对数冷却计划
- en: 1.7   a) True
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7   a) 正确
- en: 2.   The generic forms of __problem_base.py and _sa.py, provided in the book’s
    GitHub repo, can be used to solve this problem. You can also modify listing 5.1
    or 5.2 to solve this problem.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   书中GitHub仓库提供的__problem_base.py和_sa.py的通用形式可以用来解决这个问题。您还可以修改列表5.1或5.2来解决这个问题。
- en: 3.   You can use listing 5.5 or the ASA-GS implementation [1] to run simulated
    annealing with selected parameters on different TSP instances and report your
    results. In listing 5.5, replace the permanent link with the link corresponding
    to the TSP instance. For example, click on burma14.tsp, click on the button with
    three dots at the upper-right corner, and select Copy Permalink. Consider tuning
    the algorithm’s parameters to get close to the best tour length known (so far)
    for each dataset.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   您可以使用列表5.5或ASA-GS实现[1]在不同的TSP实例上运行具有选定参数的模拟退火，并报告您的结果。在列表5.5中，将永久链接替换为对应于TSP实例的链接。例如，点击burma14.tsp，点击右上角的三个点按钮，并选择复制永久链接。考虑调整算法的参数，以接近每个数据集已知的最佳行程长度（到目前为止）。
- en: 4.   The next listing shows how to use the generic solver implemented as part
    of the optalgo-tools package to solve this problem.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   以下列表显示了如何使用optalgo-tools包中实现的一般求解器来解决这个问题。
- en: Listing C.3 Solving TSP using SA
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.3 使用SA解决TSP问题
- en: '[PRE3]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a continuation of listing C.3, the following code shows how to solve this
    problem using the simanneal Python library:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表C.3的延续，以下代码展示了如何使用simanneal Python库来解决这个问题：
- en: '[PRE4]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Test the annealer with a TSP as per the simanneal module.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用simanneal模块中的TSP测试退火器。
- en: ② Swap two cities in the route.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在路线上交换两个城市。
- en: ③ Calculate the length of the route.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 计算路线的长度。
- en: ④ Initial state, a randomly ordered itinerary
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 初始状态，一个随机排序的行程
- en: ⑤ Set New York City as the home city.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将纽约市设为家乡城市。
- en: ⑥ Print the route and its cost.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印路线及其成本。
- en: 'As a continuation, the following code can be used to visualize the problem
    and its solution:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 作为延续，以下代码可以用来可视化问题和解决方案：
- en: '[PRE5]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Reverse the lat and long for a correct visualization.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ① 反转经纬度以正确可视化。
- en: ② Create an independent shallow copy of the graph and attributes.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个独立的浅拷贝的图和属性。
- en: ③ Draw the closest edges on each node only.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 仅在每个节点上绘制最近的边。
- en: ④ Draw the route.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 绘制路线。
- en: ⑤ Visualize.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 可视化。
- en: Running this code produces the visualization shown in figure C.13.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生图 C.13 所示的可视化。
- en: '![](../Images/APPC_F13_Khamis.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F13_Khamis.png)'
- en: Figure C.13 Solution for the 20 major US cities TSP using simanneal
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.13 使用 simanneal 解决 20 个主要美国城市 TSP 的解决方案
- en: Appendix A shows examples of available Python libraries, such as scikit-opt,
    DEAP, OR-Tools and simanneal, that can solve this problem using simulated annealing
    and other metaheuristics.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 A 展示了可用于解决此问题的 Python 库示例，例如 scikit-opt、DEAP、OR-Tools 和 simanneal，它们可以使用模拟退火和其他元启发式算法来解决这个问题。
- en: 5.   The solution to the crossword puzzle is shown in figure C.14.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   填字游戏的解决方案如图 C.14 所示。
- en: '![](../Images/APPC_F14_Khamis.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F14_Khamis.png)'
- en: Figure C.14 Simulated annealing crossword puzzle solution
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.14 模拟退火填字游戏解决方案
- en: 'C.5 Chapter 6: Tabu search'
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.5 第六章：禁忌搜索
- en: C.5.1 Exercises
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.5.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择和判断题：为以下每个问题选择正确的答案。
- en: 1.1.   In TS, non-improving solutions are conditionally accepted in order to
    escape from a local optimum.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   在 TS 中，为了逃离局部最优，非改进解在条件上被接受。
- en: a.  True
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.2.   A frequency-based memory maintains information about how recently a search
    point has been visited.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   基于频率的记忆维护有关搜索点最近访问的信息。
- en: a.  True
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.3.   In order to increase the efficiency for solving some problems, TS uses
    memory via a tabu list to avoid revisiting recently visited neighborhoods.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   为了提高解决某些问题的效率，TS 通过禁忌列表使用记忆来避免重新访问最近访问过的邻域。
- en: a.  True
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.4.   The stopping criteria to terminate TS can be
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   终止 TS 的停止标准可以是
- en: a.  Neighborhood is empty
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: a.  邻域为空
- en: b.  Number of iterations is larger than a specified threshold
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: b.  迭代次数大于指定的阈值
- en: c.  Evidence shows that an optimum solution has been obtained
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: c.  证据表明已获得最优解
- en: d.  All of the above (a, b, and c)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: d.  以上皆对（a, b, 和 c）
- en: e.  None of the above (a, b, or c)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上皆非（a, b, 或 c）
- en: 1.5.   Tabu-active moves are stored in a long-term memory.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   禁忌搜索的禁忌移动被存储在长期记忆中。
- en: a.  True
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.6.   For large and difficult problems (scheduling, quadratic assignment, and
    vehicle routing), tabu search obtains solutions that often represent a global
    optimum or near-optimum.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   对于大型和困难的问题（如调度、二次分配和车辆路径），禁忌搜索通常能获得代表全局最优或近似最优的解。
- en: a.  True
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.7.   Recency memory is used to increase intensification of the search by remembering
    neighbors with good solutions.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   使用近期记忆通过记住具有良好解决方案的邻居来增加搜索的强度。
- en: a.  True
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.8.   Aspiration criteria are used to revoke tabu-active moves as a way to
    avoid search stagnation.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   使用渴望标准来撤销禁忌搜索的禁忌移动，作为避免搜索停滞的一种方式。
- en: a.  True
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.9.   TS can be considered a combination of random search and memory structures.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   TS 可以被视为随机搜索和记忆结构的组合。
- en: a.  True
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.10. When the length of the tabu list is too small, the algorithm can get trapped
    in cycles, and when it’s too long, many moves could be prevented at each iteration,
    leading to stagnation.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. 当禁忌列表的长度太短时，算法可能会陷入循环，而当它太长时，每次迭代可能会阻止许多移动，导致停滞。
- en: a.  True
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 2.   As shown in appendix B, the Schwefel function is complex, with many local
    minima. Figure C.15 shows the two-dimensional form of the function.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   如附录 B 所示，Schwefel 函数复杂，具有许多局部最小值。图 C.15 展示了该函数的二维形式。
- en: '![](../Images/APPC_F15_Khamis.png)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F15_Khamis.png)'
- en: Figure C.15 The Schwefel function
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.15 Schwefel 函数
- en: Modify listing 6.1 to solve the Schwefel function using tabu search.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表 6.1 修改为使用禁忌搜索解决 Schwefel 函数。
- en: 3.   Apple filed US Patent 7790637 B2 for a composite laminate that includes
    seven sheets stacked one over another and a scrim layer. Seven planar sheets of
    fibers impregnated with a resin (e.g., a viscous liquid substance) are placed
    with different orientations to improve the strength of the composite laminate,
    as illustrated in figure C.16\. The scrim layer is the cosmetic layer, which is
    a different material and is bonded to the outside to improve the cosmetic exterior
    surface and consistent appearance.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   苹果申请了美国专利 7790637 B2，该专利是一种复合材料层压板，包括七层叠加在一起，并有一个隔网层。将浸渍有树脂（例如，一种粘稠液体物质）的七层平面纤维放置在不同的方向上，以提高复合材料层的强度，如图
    C.16 所示。隔网层是装饰层，它是一种不同的材料，并粘附在外部，以改善装饰外观和一致性。
- en: '![](../Images/APPC_F16_Khamis.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F16_Khamis.png)'
- en: Figure C.16 Composite laminate design—Apple’s US patent 7790637 B2
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.16 复合层压板设计——苹果的美国专利7790637 B2
- en: The way the seven layers are ordered results in different levels of strength
    in the composite laminate. Assume that the pairwise strength gain or loss is given
    by the empirical values in figure C.17\. Positive values represent a strength
    gain in the case of contact between the two layers (up or down), and negative
    values represent the strength loss.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 七层排列的方式导致复合层压板具有不同的强度水平。假设成对强度增益或损失由图C.17中的经验值给出。正值表示两层接触时（向上或向下）的强度增益，负值表示强度损失。
- en: '![](../Images/APPC_F17_Khamis.png)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F17_Khamis.png)'
- en: Figure C.17 Pairwise strength gain or loss
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.17 成对强度增益或损失
- en: Assume that we want to find the optimal ordered combination (i.e., permutation)
    of the seven fiber sheets to maximize the composite laminate strength. Perform
    four hand iterations of tabu search to show the steps of the algorithm to solve
    this problem. Write Python code to solve this problem.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到七个纤维层最优的有序组合（即排列），以最大化复合层压板的强度。进行四次禁忌搜索的手动迭代，以展示算法解决问题的步骤。编写Python代码来解决这个问题。
- en: 4.   Write Python code to use tabu search to solve the simple assembly line
    balancing problem, type 1 (SALBP-1), with the machine and worker constraints described
    in Kamarudin and Rashid’s paper “Modelling of Simple Assembly Line Balancing Problem
    Type 1 (SALBP-1) with Machine and Worker Constraints” [3].
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   编写Python代码使用禁忌搜索来解决简单装配线平衡问题，类型1（SALBP-1），其中机器和工人约束由Kamarudin和Rashid的论文“Modelling
    of Simple Assembly Line Balancing Problem Type 1 (SALBP-1) with Machine and Worker
    Constraints” [3] 描述。
- en: 5.   In the word search puzzle in figure C.18, find the hidden terms commonly
    used in tabu search. You can search horizontally (from left to right or right
    to left), vertically (from top to bottom or bottom to top), or diagonally.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   在图C.18的单词搜索谜题中，找到禁忌搜索中常用的隐藏术语。你可以水平搜索（从左到右或从右到左），垂直搜索（从上到下或从下到上），或对角线搜索。
- en: '![](../Images/APPC_F18_Khamis.png)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F18_Khamis.png)'
- en: Figure C.18 TS word search puzzle
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.18 TS单词搜索谜题
- en: C.5.2 Solutions
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.5.2 解决方案
- en: 1.   Multiple choice and true/false
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和判断题
- en: 1.1.   a) True
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   a) 正确
- en: 1.2.   b) False (Recency-based memory maintains information about how recently
    a search point has been visited.)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   b) 错误（基于最近性的记忆维护有关搜索点最近访问的信息。）
- en: 1.3.   a) True
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   a) 正确
- en: 1.4.   d) All of the above (a, b, and c)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   d) 所有上述选项（a、b和c）
- en: 1.5.   b) False (Tabu-active moves are stored in a short-term memory.)
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   b) 错误（禁忌活跃移动存储在短期记忆中。）
- en: 1.6.   a) True
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   a) 正确
- en: 1.7.   a) True
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   a) 正确
- en: 1.8.   a) True
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   a) 正确
- en: 1.9.   b) False (TS can be considered a combination of combination of local
    search and memory structures.)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   b) 错误（禁忌搜索可以被视为局部搜索和记忆结构的组合。）
- en: 1.10. a) True
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. a) 正确
- en: 2.   Listing C.4 in the book’s GitHub repository shows how to solve the Schwefel
    function using tabu search.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   书籍GitHub仓库中的列表C.4展示了如何使用禁忌搜索解决Schwefel函数。
- en: '3.   Figure C.19 shows the TS initialization and first iteration for the composite
    laminate problem. The number of possible permutations without repetition is *n*!.
    The number of possible solutions for ordering the seven fiber sheets is 7! = 5,040.
    To generate a neighboring solution, fiber sheet swapping can be used. The neighborhood
    is defined as any other solution that is obtained by a pairwise exchange of any
    two sheets in the solution. If we let the number of nodes *n* = 7, pairwise exchange
    *k* = 2. The number of neighbors is the number of combinations without repetition
    *C*(*n*,*k*) or *n*-choose-*k*: *C*(*n*,*k*) = *n*! / (*k*!(*n* – *k*)!) = 21
    neighbors. Let’s assume that the tabu tenure is set at 3 iterations.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   图C.19显示了复合层压板问题的TS初始化和第一次迭代。不重复的可能排列数为*n*!。排列七个纤维层的可能解数为7! = 5,040。要生成相邻解，可以使用纤维层交换。邻域定义为通过交换解中任意两个层而获得的任何其他解。如果我们让节点数*n*
    = 7，成对交换*k* = 2。邻域的数量是不重复的组合数*C*(*n*,*k*)或*n*-choose-*k*：*C*(*n*,*k*) = *n*! /
    (*k*!(*n* – *k*)!) = 21个邻域。假设禁忌任期设置为3次迭代。
- en: '![](../Images/APPC_F19_Khamis.png)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F19_Khamis.png)'
- en: Figure C.19 TS initialization for the composite laminate design
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.19 复合层压板设计的禁忌搜索初始化
- en: Figures C.20 through C.22 show iterations 1, 2, and 3 respectively.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.20至C.22分别显示了迭代1、2和3。
- en: '![](../Images/APPC_F20_Khamis.png)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F20_Khamis.png)'
- en: Figure C.20 Composite laminate design—iteration 1
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.20 复合层压板设计——迭代1
- en: '![](../Images/APPC_F21_Khamis.png)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F21_Khamis.png)'
- en: Figure C.21 Composite laminate design—iteration 2
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.21 复合材料层压板设计——第2次迭代
- en: '![](../Images/APPC_F22_Khamis.png)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F22_Khamis.png)'
- en: Figure C.22 Composite laminate design—iteration 3
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.22 复合材料层压板设计——第3次迭代
- en: In each iteration, we generate a number of candidate solution using layer swapping,
    and we select the move that results in the maximum delta value, which is the difference
    between the previous solution and the new solution in terms of strength gain.
    In the next iteration, shown in figure C.23, there is no move with a positive
    gain, so the best (non-tabu) move will be non-improving. The move (a,e) is selected,
    since it has a tabu tenure of only one iteration compared to the other tabu-active
    best move (a,b). This means that the tabu status of (a,e) can be overridden by
    applying the aspiration criteria.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们通过层交换生成多个候选解，并选择导致最大delta值的移动，即前一个解和新的解在强度增益方面的差异。在下一个迭代中，如图C.23所示，没有具有正增益的移动，因此最佳（非禁忌）移动将是非改进的。选择移动（a,e），因为它与其他禁忌活跃的最佳移动（a,b）相比只有一期的禁忌期限。这意味着（a,e）的禁忌状态可以通过应用渴望标准来覆盖。
- en: '![](../Images/APPC_F23_Khamis.png)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F23_Khamis.png)'
- en: Figure C.23 Composite laminate design—TS iteration 4 and aspiration criterion
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.23 复合材料层压板设计——TS迭代4和渴望标准
- en: To show the diversification using frequency-based memory, assume that the solution
    reached after 26 iterations is [a c f b g e d], and the strength value is 23\.
    Assume that we will penalize the solution based on its frequency in usage (a highly
    repetitive solution gets more penalties). The tabu structure is updated based
    on both recency-based (upper triangle) and frequency-based (lower triangle) memories,
    as shown in figure C.24a. The five top candidates after swapping are shown in
    figure C.24b.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示基于频率的记忆的多样化，假设在第26次迭代后达到的解是[a c f b g e d]，强度值为23。假设我们将根据其在使用中的频率来惩罚解（高度重复的解会受到更多的惩罚）。禁忌结构根据基于最近性（上三角）和基于频率（下三角）的记忆进行更新，如图C.24a所示。交换后的前五个候选解如图C.24b所示。
- en: '![](../Images/APPC_F24_Khamis.png)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F24_Khamis.png)'
- en: Figure C.24 a) Recency- and frequency-based memory, b) five top candidates after
    swapping with their penalty values
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.24 a) 基于最近性和频率的记忆，b) 交换后的前五个候选解及其惩罚值
- en: We need to diversify when no admissible improving moves exist. Non-improving
    moves are penalized by assigning larger penalties to more frequent swaps. According
    to the penalized value, swap (a,f) is chosen. Listing C.5 shows the solution of
    the composite laminate problem using tabu search.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 当不存在可接受的改进步骤时，我们需要进行多样化。非改进步骤通过分配更大的惩罚给更频繁的交换来受到惩罚。根据惩罚值，选择交换（a,f）。列表C.5展示了使用禁忌搜索解决复合材料层压板问题的解决方案。
- en: Listing C.5 Solving the composite laminate problem using tabu search
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.5 使用禁忌搜索解决复合材料层压板问题
- en: '[PRE6]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Import the SHEETS problem instance, which contains the composite laminate
    design problem description.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入SHEETS问题实例，其中包含复合材料层压板设计问题的描述。
- en: ② Import the tabu search solver.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入禁忌搜索求解器。
- en: ③ Create different sheets objects. For a complete list of the supported parameters,
    see the SHEETS class in the sheets.py file in the optalgotools.problems module.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建不同的sheets对象。有关支持的参数的完整列表，请参阅optalgotools.problems模块中sheets.py文件中的SHEETS类。
- en: ④ Create a TS object to help in solving the composite laminate problem.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建一个TS对象以帮助解决复合材料层压板问题。
- en: ⑤ Get an initial random solution, and check its cost.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 获取一个初始随机解，并检查其成本。
- en: ⑥ Run TS, and evaluate the best solution cost.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 运行TS，评估最佳解的成本。
- en: 4.   Listing C.6 shows a snippet of the code for solving the SALBP-1 problem
    using tabu search.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 列表C.6展示了使用禁忌搜索解决SALBP-1问题的代码片段。
- en: Listing C.6 Solving the SALBP-1 problem using tabu search
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.6 使用禁忌搜索解决SALBP-1问题
- en: '[PRE7]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Read the data from appendix B directly using the URL.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ① 直接使用URL从附录B读取数据。
- en: ② Define the cycle time.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义周期时间。
- en: ③ Get an initial solution.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 获取一个初始解。
- en: ④ Ensure the feasibility of the solution considering the task precedence constraint.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 确保解决方案在考虑任务优先级约束下的可行性。
- en: ⑤ Run the tabu search.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 运行禁忌搜索。
- en: ⑥ Calculate the smoothing index of the best solution.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 计算最佳解的平滑指数。
- en: ⑦ Visualize the solution.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 可视化解决方案。
- en: 'Running the complete code produces the following output:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完整代码产生以下输出：
- en: '[PRE8]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Complete code is available in the book’s GitHub repo.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可在本书的GitHub仓库中找到。
- en: 5.   The solution to the word search puzzle is shown in figure C.25.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   单词搜索谜题的解决方案如图 C.25 所示。
- en: '![](../Images/APPC_F25_Khamis.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F25_Khamis.png)'
- en: Figure C.25 TS word search puzzle solution
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.25 TS 单词搜索谜题解决方案
- en: The word directions and start points are formatted as (Direction, *X, Y*)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 方向和起点以 (方向, *X, Y*) 格式表示
- en: ADAPTIVE MEMORY (W, 17, 13)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 适应性记忆 (W, 17, 13)
- en: ASPIRATION CRITERIA (W, 23, 15)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 憧憬标准 (W, 23, 15)
- en: DIVERSIFICATION (W, 23, 14)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 多样化 (W, 23, 14)
- en: FREQUENCY-BASED MEMORY (W, 21, 7)
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 基于频率的记忆 (W, 21, 7)
- en: INTENSIFICATION (E, 8, 8)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 强化 (E, 8, 8)
- en: LOCAL SEARCH (W, 16, 6)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 局部搜索 (W, 16, 6)
- en: LONG-TERM MEMORY (E, 1, 10)
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 长期记忆 (E, 1, 10)
- en: RECENCY (E, 12, 1)
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 近期记忆 (E, 12, 1)
- en: RESPONSIVE EXPLORATION (W, 23, 16)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 反应性探索 (W, 23, 16)
- en: SENSORY MEMORY (W, 16, 3)
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉记忆 (W, 16, 3)
- en: SHORT-TERM MEMORY (W, 16, 4)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 短期记忆 (W, 16, 4)
- en: TABU LIST (E, 6, 12)
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 禁忌列表 (E, 6, 12)
- en: TABU SEARCH (E, 1, 5)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 禁忌搜索 (E, 1, 5)
- en: TABU STRUCTURE (W, 23, 2)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 禁忌结构 (W, 23, 2)
- en: TABU TENURE (E, 12, 5)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 禁忌任期 (E, 12, 5)
- en: WORKING MEMORY (W, 20, 9)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 工作记忆 (W, 20, 9)
- en: 'C.6 Chapter 7: Genetic algorithm'
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.6 第七章：遗传算法
- en: C.6.1 Exercises
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.6.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择和真/假：为以下每个问题选择正确答案。
- en: 1.1.   Given a binary string 1101001100101101 and another binary string yxyyxyxxyyyxyxxy
    in which the values 0 and 1 are denoted by x and y, what offspring result from
    applying 1-point crossover on the two strings at a randomly selected recombination
    point?
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   给定一个二进制字符串 1101001100101101 和另一个二进制字符串 yxyyxyxxyyyxyxxy，其中值 0 和 1 由 x
    和 y 表示，在随机选择的重组点应用单点交叉后，这两个字符串会产生什么样的后代？
- en: a.  yxxyyyxyxxy11010 and yxyyx01100101101
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: a.  yxxyyyxyxxy11010 和 yxyyx01100101101
- en: b.  11010yxxyyyxyxxy and yxyyx01100101101
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: b.  11010yxxyyyxyxxy 和 yxyyx01100101101
- en: c.  11010yxxyyyxyxxy and 01100101101yxyyx
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: c.  11010yxxyyyxyxxy 和 01100101101yxyyx
- en: d.  None of the above
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: d.  以上皆非
- en: 1.2.   In binary genetic algorithms, how does the bitwise mutation operator
    work?
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   在二进制遗传算法中，位突变操作符是如何工作的？
- en: a.  It swaps the positions of two randomly chosen bits.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: a.  它交换两个随机选择的位的位置。
- en: b.  It averages the values of two randomly chosen bits.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: b.  它平均两个随机选择的位的值。
- en: c.  It flips a randomly chosen bit in the binary representation.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: c.  它翻转二进制表示中的随机选择的位。
- en: d.  It reverses the order of a randomly chosen segment of bits.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: d.  它反转随机选择的位段顺序。
- en: 1.3.   The name of the position on the chromosome every gene has is called
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   每个基因在染色体上的位置名称称为
- en: a.  Allele
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: a.  等位基因
- en: b.  Locus
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: b.  突变位点
- en: c.  Genotype
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: c.  基因型
- en: d.  Phenotype
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: d.  表型
- en: e.  None of the above
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上皆非
- en: 1.4.   In the steady-state model of genetic algorithms, how are new offspring
    introduced into the population?
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   在遗传算法的稳态模型中，如何将新的后代引入种群？
- en: a.  By replacing the entire population
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: a.  通过替换整个种群
- en: b.  By replacing a small fraction of the population
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: b.  通过替换种群的一小部分
- en: c.  By adding them to the existing population
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: c.  通过将它们添加到现有种群中
- en: d.  By replacing the worst individuals in the population
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: d.  通过替换种群中的最差个体
- en: 1.5.   Suppose you have the population shown in table C.2.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   假设你有一个表 C.2 中所示的种群。
- en: Table C.2 Given population
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 表 C.2 给定种群
- en: '| Individual | Individual 1 | Individual 2 | Individual 3 | Individual 4 |
    Individual 5 |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| 个人 | 个人 1 | 个人 2 | 个人 3 | 个人 4 | 个人 5 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Fitness | 12 | 25 | 8 | 53 | 10 |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| 适应性 | 12 | 25 | 8 | 53 | 10 |'
- en: 'Rank-based selection attempts to remove problems of fitness-proportionate selection
    (FPS) by basing selection probabilities on relative rather than absolute fitness.
    Assume that the ranking process is linear ranking, as follows:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 基于排名的选择试图通过基于相对适应性而不是绝对适应性来解决问题，以解决适应性比例选择（FPS）的问题。假设排名过程是线性排名，如下所示：
- en: '![](../Images/APPC_F25_Khamis-EQ01.png)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F25_Khamis-EQ01.png)'
- en: where *N* is the number of individuals in the population and *r* is the rank
    associated with each individual in this population (the least fit individual has
    *r* = 1, the fittest individual *r* = *N*). *SP* is the selection pressure (assume
    *SP* = 1.5). Which two individuals will be selected if we use this linear ranking-based
    selection?
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *N* 是种群中个体的数量，*r* 是与种群中每个个体关联的排名（最不适应的个体有 *r* = 1，最适应的个体 *r* = *N*）。*SP*
    是选择压力（假设 *SP* = 1.5）。如果我们使用基于线性排名的选择，哪两个个体将被选中？
- en: a.  Individuals 1 and 2
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: a.  个人 1 和 2
- en: b.  Individuals 1 and 3
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: b.  个人 1 和 3
- en: c.  Individuals 2 and 3
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: c.  个人 2 和 3
- en: d.  Individuals 2 and 4
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: d.  个人 2 和 4
- en: e.  Individuals 3 and 4
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: e.  个人 3 和 4
- en: f.  None of the above
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: f.  以上皆非
- en: 1.6.   Which selection method in genetic algorithms involves choosing a fixed
    number of individuals at random and selecting the best among them?
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6. 在遗传算法中，哪种选择方法涉及随机选择固定数量的个体，并从中选择最佳者？
- en: a.  Roulette wheel selection
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: a. 轮盘赌选择
- en: b.  Rank selection
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: b. 排名选择
- en: c.  Tournament selection
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: c. 征服选择
- en: d.  Stochastic universal sampling (SUS)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: d. 随机均匀抽样（SUS）
- en: 1.7.   In P-metaheuristics, the computational cost of the Latin hypercube strategy
    is the same as the pseudo-random initialization strategy.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7. 在P元启发式算法中，拉丁超立方策略的计算成本与伪随机初始化策略相同。
- en: a.  True
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b.  False
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: 1.8.   In binary genetic algorithms, which type of chromosome encoding is used?
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8. 在二进制遗传算法中，使用哪种类型的染色体编码？
- en: a.  Real value
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: a. 实数值
- en: b.  Permutation
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: b. 排列
- en: c.  Binary
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: c. 二进制
- en: d.  Tree
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: d. 树
- en: 1.9.   Which of the following methods can be used to convert a minimization
    problem into a maximization problem in optimization?
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9. 以下哪种方法可以用于将优化问题中的最小化问题转换为最大化问题？
- en: a.  Adding a constant to the objective function
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: a. 将常数加到目标函数上
- en: b.  Taking the reciprocal of the objective function
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: b. 取目标函数的倒数
- en: c.  Negating the objective function
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: c. 取反目标函数
- en: d.  Scaling the objective function by a factor
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: d. 将目标函数按因子缩放
- en: 1.10. Which of the following is an advantage of the steady-state model compared
    to the generational model in genetic algorithms?
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. 与代际模型相比，稳态模型在遗传算法中的优势是什么？
- en: a.  Faster convergence
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: a. 更快的收敛速度
- en: b.  Better diversity preservation
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: b. 更好的多样性保持
- en: c.  Lower computational cost
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: c. 更低的计算成本
- en: d.  More robust mutation operators
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: d. 更鲁棒的突变算子
- en: 1.11. In a binary genetic algorithm, what does the mutation operator do to an
    individual’s genes?
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11. 在二进制遗传算法中，突变算子对个体的基因做了什么？
- en: a.  Reverses the gene value (1 to 0 or 0 to 1)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: a. 反转基因值（1到0或0到1）
- en: b.  Randomly assigns a new gene value (0 or 1)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: b. 随机分配新的基因值（0或1）
- en: c.  Swaps the positions of two genes
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: c. 交换两个基因的位置
- en: d.  Combines genes from different individuals
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: d. 结合来自不同个体的基因
- en: 1.12. Which of the following is a commonly used crossover method in binary genetic
    algorithms?
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12. 以下哪项是二进制遗传算法中常用的交叉方法？
- en: a.  Single-point crossover
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: a. 单点交叉
- en: b.  Two-point crossover
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: b. 双点交叉
- en: c.  Uniform crossover
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: c. 均匀交叉
- en: d.  All of the above
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上所有
- en: 1.13. What is the primary difference between generational and steady-state models
    in genetic algorithms?
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 1.13. 遗传算法中，代际模型与稳态模型之间的主要区别是什么？
- en: a.  Selection methods
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: a. 选择方法
- en: b.  Crossover operators
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: b. 交叉算子
- en: c.  Mutation operators
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: c. 突变算子
- en: d.  Replacement strategies
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: d. 替换策略
- en: 1.14. Which crossover method in binary genetic algorithms involves exchanging
    genetic material between parent chromosomes based on a predefined probability
    for each gene?
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 1.14. 在二进制遗传算法中，哪种交叉方法涉及根据每个基因预定义的概率在父代染色体之间交换遗传物质？
- en: a.  Single-point crossover
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: a. 单点交叉
- en: b.  Two-point crossover
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: b. 双点交叉
- en: c.  Uniform crossover
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: c. 均匀交叉
- en: d.  Arithmetic crossover
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: d. 算术交叉
- en: 1.15. What is a potential disadvantage of using a high mutation rate in binary
    genetic algorithms?
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 1.15. 使用高突变率在二进制遗传算法中可能存在的潜在缺点是什么？
- en: a.  Loss of diversity in the population
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: a. 种群多样性的丧失
- en: b.  Premature convergence
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: b. 过早收敛
- en: c.  Disruption of good solutions
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: c. 优秀解决方案的破坏
- en: d.  Decreased selection pressure
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: d. 减少选择压力
- en: 1.16. In the generational model of genetic algorithms, what happens to the population
    in each generation?
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 1.16. 在遗传算法的代际模型中，每一代种群会发生什么变化？
- en: a.  A small fraction of the population is replaced.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: a. 替换一小部分种群。
- en: b.  The entire population is replaced.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: b. 完全替换整个种群。
- en: c.  The population remains the same.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: c. 种群保持不变。
- en: d.  The population size is gradually reduced.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: d. 种群大小逐渐减少。
- en: 1.17. When using a transformation to convert a minimization problem into a maximization
    problem, which property of the optimal solution must be preserved?
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 1.17. 当使用转换将最小化问题转换为最大化问题时，必须保留最优解的哪个属性？
- en: a.  Feasibility
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: a. 可行性
- en: b.  Optimality
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: b. 最优性
- en: c.  Dominance
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: c. 领先
- en: d.  Convexity
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: d. 凸性
- en: 1.18. What are the primary operators used in genetic algorithms?
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 1.18. 遗传算法中主要使用的算子有哪些？
- en: a.  Initialization, pooling, and backpropagation
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: a. 初始化、池化和反向传播
- en: b.  Selection, crossover, and mutation
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: b. 选择、交叉和突变
- en: c.  Convolution, pooling, and activation
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: c. 卷积、池化和激活
- en: d.  Forward propagation, backward propagation, and optimization
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: d.  前向传播、反向传播和优化
- en: 1.19. Which of the following is an advantage of the generational model compared
    to the steady-state model in genetic algorithms?
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 1.19. 与稳态模型相比，以下哪项是遗传算法中代际模型的优势？
- en: b.  Improved diversity preservation
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: b.  改善多样性保持
- en: b.  Faster convergence
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: b.  收敛更快
- en: c.  Lower computational cost
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: c.  较低的计算成本
- en: d.  Better handling of constraints
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: d.  更好地处理约束
- en: '1.20. Suppose you need to solve the following function maximization problem
    using a binary genetic algorithm:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 1.20. 假设你需要使用二进制遗传算法来解决以下函数最大化问题：
- en: '![](../Images/APPC_F25_Khamis-EQ02.png)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F25_Khamis-EQ02.png)'
- en: where
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *O[i]* is the objective function value of individual *i* and *O[i]* = –(*x*
    – 6.4)².
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: •   *O[i]* 是个体 *i* 的目标函数值，且 *O[i]* = –(*x* – 6.4)²。
- en: •   *N* is the population size.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: •   *N* 是种群大小。
- en: •   *V* is a large value to ensure non-negative fitness values.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: •   *V* 是一个很大的值，以确保适应度值非负。
- en: The value of *V* is the maximum value of the second term of the fitness function
    *f*(*x*) so that the fitness value corresponding to the maximum value of the objective
    function is 0\. How many bits are required to represent the solution with precision
    0.1?
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '*V* 的值是适应度函数 *f*(*x*) 第二项的最大值，使得对应目标函数最大值的适应度值为0。为了以0.1的精度表示解，需要多少位？'
- en: a.   6 bits
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: a.   6位
- en: b.   7 bits
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: b.   7位
- en: c.   8 bits
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: c.   8位
- en: d.   9 bits
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: d.   9位
- en: e. 10 bits
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: e. 10位
- en: f.  None of the above
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: f.  以上皆非
- en: 2.   The Ackley function is a nonlinear, multimodal function with a large number
    of local minima, making it a challenging optimization problem. The general form
    of the Ackley function is
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   Ackley函数是一个非线性、多模态函数，具有大量局部最小值，使其成为一个具有挑战性的优化问题。Ackley函数的一般形式是
- en: '![](../Images/APPC_F25_Khamis-EQ03.png)'
  id: totrans-716
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F25_Khamis-EQ03.png)'
- en: where
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *x* = (*x*[1], *x*[2], ..., *x[d]*) is the input vector.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x* = (*x*[1], *x*[2], ..., *x[d]*) 是输入向量。
- en: •   *a, b*, and *c* are positive constants (usually *a* = 20, *b* = 0.2, and
    *c* = 2 × *π*).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: •   *a, b*, 和 *c* 是正常数（通常 *a* = 20, *b* = 0.2, 和 *c* = 2 × *π*）.
- en: •   d is the dimension of the input vector.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: •   d 是输入向量的维度。
- en: The function has a global minimum at the origin (*x[i] =* 0), where *f(x) =*
    0, and it is surrounded by several local minimam, as shown in figure C.26.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在原点有全局最小值（*x[i] =* 0），其中 *f(x) =* 0，并且它被几个局部最小值所包围，如图C.26所示。
- en: '![](../Images/APPC_F26_Khamis.png)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F26_Khamis.png)'
- en: Figure C.26 The Ackley function
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.26 Ackley函数
- en: The presence of these local minima makes it difficult for optimization algorithms
    to find the global minimum, especially those that can get stuck in local minima.
    Write Python code to solve a 6D Ackley function.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 这些局部最小值的存在使得优化算法难以找到全局最小值，尤其是那些可能陷入局部最小值的算法。请编写Python代码来解决一个6D Ackley函数。
- en: C.6.2 Solutions
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.6.2 解决方案
- en: 1.   Multiple choice and true/false
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和是非题
- en: 1.1.   b) 11010yxxyyyxyxxy and yxyyx01100101101
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   b) 11010yxxyyyxyxxy and yxyyx01100101101
- en: 1.2.   c) It flips a randomly chosen bit in the binary representation.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   c) 随机翻转二进制表示中的某个位
- en: 1.3.   b) Locus
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   b) 突变位点
- en: 1.4.   b) By replacing a small fraction of the population
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   b) 通过替换种群的一小部分
- en: 1.5.   Considering the following linear ranking
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   考虑以下线性排名
- en: '![](../Images/APPC_F26_Khamis-EQ04.png)'
  id: totrans-732
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F26_Khamis-EQ04.png)'
- en: '| Individual | Individual 1 | Individual 2 | Individual 3 | Individual 4 |
    Individual 5 |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| 个体 | 个体1 | 个体2 | 个体3 | 个体4 | 个体5 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Fitness | 12 | 25 | 8 | 53 | 10 |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| 适应度 | 12 | 25 | 8 | 53 | 10 |'
- en: '| Ranking r | 3 | 4 | 1 | 5 | 2 |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: '| 排名r | 3 | 4 | 1 | 5 | 2 |'
- en: '| p(r) | 0.175 | **0**.**2** | 0.125 | **0**.**225** | 0.15 |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '| p(r) | 0.175 | **0**.**2** | 0.125 | **0**.**225** | 0.15 |'
- en: Individuals 4 and 2 will be selected, as they have the highest probability.
    So the correct answer is d.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 个体4和个体2将被选中，因为它们具有最高的概率。所以正确答案是d。
- en: 1.6.   c) Tournament selection
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   c) 赛选
- en: 1.7.   a) True
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   a) 正确
- en: 1.8.   c) Binary
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   c) 二进制
- en: 1.9.   b and c) Taking the reciprocal of the objective function, and negating
    the objective function
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   b和c) 取目标函数的倒数，并取目标函数的相反数
- en: 1.10. c) Lower computational cost
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. c) 较低的计算成本
- en: 1.11. a) Reverses the gene value (1 to 0 or 0 to 1)
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11. a) 反转基因值（1到0或0到1）
- en: 1.12. d) All of the above
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12. d) 所有上述选项
- en: 1.13. d) Replacement strategies
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 1.13. d) 替换策略
- en: 1.14. c) Uniform crossover
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 1.14. c) 均匀交叉
- en: 1.15. c) Disruption of good solutions
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 1.15. c) 破坏好的解
- en: 1.16. b) The entire population is replaced.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 1.16. b) 替换整个种群
- en: 1.17. b) Optimality
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 1.17. b) 最优性
- en: 1.18. b) Selection, crossover, and mutation
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 1.18. b) 选择、交叉和变异
- en: 1.19. a) Improved diversity preservation
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 1.19. a) 改进的多样性保持
- en: 1.20. d) 9 bits
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 1.20. d) 9位
- en: Given 0.0 <= *x* <= 31.5 with a precision of 0.1
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 0.0 <= *x* <= 31.5，精度为0.1
- en: '•   Calculate the range size: (31.5 – 0) = 31.5'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: •   计算范围大小：31.5 – 0 = 31.5
- en: '•   Divide the range size by the desired precision: 31.5 / 0.1 = 315'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: •   将范围大小除以所需的精度：31.5 / 0.1 = 315
- en: '•   Round up to the nearest whole number: 315'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: •   向上取整到最接近的整数：315
- en: 'Now you have 315 steps (values) to represent the numbers from 0.0 to 31.5 with
    a precision of 0.1:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有315个步骤（值）来表示从0.0到31.5的数字，精度为0.1：
- en: number_of_bits = ceil(log[2](number_of_steps)) = ceil(log[2](315)) ≈ ceil(8.29)
    = 9
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: number_of_bits = ceil(log[2](number_of_steps)) = ceil(log[2](315)) ≈ ceil(8.29)
    = 9
- en: 'So you need 9 bits to represent the numbers from 0.0 to 31.5 with a precision
    of 0.1.2\. Listing C.8 shows a snippet of the code to solve the Ackley function
    using a genetic algorithm implemented from scratch or based on the pymoo open
    source library. We start by defining constants for the genetic algorithm and Ackley
    function as follows:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要9位来表示从0.0到31.5的数字，精度为0.1.2\. 列表C.8显示了使用从头开始实现或基于pymoo开源库实现的遗传算法解决Ackley函数的代码片段。我们首先定义遗传算法和Ackley函数的常量如下：
- en: Listing C.8 Solving the Ackley function using GA
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.8 使用GA解决Ackley函数
- en: '[PRE9]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then define the `decode` function to convert the binary genome to real values:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义`decode`函数，将二进制基因组转换为实数值：
- en: '[PRE10]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following function defines the fitness function (Ackley function):'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数定义了适应度函数（Ackley函数）：
- en: '[PRE11]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s now define the crossover function:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义交叉函数：
- en: '[PRE12]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The mutation function is defined as follows:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 变异函数定义如下：
- en: '[PRE13]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now it’s time to create an initial population:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建初始种群的时候了：
- en: '[PRE14]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s now run the genetic algorithm:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行遗传算法：
- en: '[PRE15]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Calculate the fitness score for each genome in the population.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: ① 计算种群中每个基因组的适应度分数。
- en: ② Print out the best fitness score for each generation.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: ② 打印出每一代的最佳适应度分数。
- en: ③ Select the best half of the population to act as parents for the next generation.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 选择种群中最佳的一半作为下一代的父母。
- en: ④ Generate the next generation by applying crossover and mutation.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 通过应用交叉和变异生成下一代。
- en: ⑤ Replace the current population with the new generation of children.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 用新的一代后代替换当前种群。
- en: 'You can print the best genome and its fitness as follows:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式打印出最佳基因组及其适应度：
- en: '[PRE16]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can print the best genome, decode the best genome, and then print the decision
    variables in real values as follows:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以打印出最佳基因组，解码最佳基因组，然后按照以下方式打印出决策变量的实数值：
- en: '[PRE17]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can solve this problem faster using GA implemented in pymoo as follows:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用pymoo中实现的遗传算法更快地解决这个问题：
- en: '[PRE18]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running this code produces the following output:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE19]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'C.7 Chapter 8: Genetic algorithm variants'
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.7 第8章：遗传算法变体
- en: C.7.1 Exercises
  id: totrans-789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.7.1 练习
- en: '1.   Assume that a company is trying to choose the optimal location for a new
    facility. The decision variables *x*[1] and *x*[2] represent the coordinates of
    the potential location for the new facility in a 2D plane. The company needs to
    minimize the distance squared between the new facility and an existing facility
    at the location (2, 1). This could represent the need to minimize transportation
    costs between the two facilities. Moreover, the company aims to maximize the distance
    squared between the new facility and a competitor’s facility at the location (3,
    4). This could represent the need to establish a competitive advantage by distancing
    the new facility from the competitor. The new facility must be located within
    a certain region due to zoning regulations or other restrictions. It also must
    adhere to environmental constraints or property boundaries. This multi-objective
    constrained optimization problem can be formulated as follows:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   假设一家公司正在尝试为新设施选择最佳位置。决策变量 *x*[1] 和 *x*[2] 代表新设施在二维平面上的潜在位置坐标。公司需要最小化新设施与位于(2,
    1)位置现有设施之间的距离平方，这可能代表了降低两个设施之间运输成本的需求。此外，公司旨在最大化新设施与位于(3, 4)位置的竞争对手设施之间的距离平方，这可能代表了通过将新设施与竞争对手保持距离来建立竞争优势的需求。由于分区法规或其他限制，新设施必须位于一定区域内。它还必须遵守环境限制或财产边界。这个多目标约束优化问题可以表述如下：
- en: Minimize *f*[1](*x*[1], *x*[2]) = √((*x*[1] – 2)² + (*x*[2] – 1)²) (distance
    between the company facilities)
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化 *f*[1](*x*[1], *x*[2]) = √((*x*[1] – 2)² + (*x*[2] – 1)²)（公司设施之间的距离）
- en: Maximize *f*[1](*x*[1], *x*[2]) = √((*x*[1] – 3)² + (*x*[2] – 4)²) (distance
    between the new facility and a competitor’s facility)
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化 *f*[1](*x*[1], *x*[2]) = √((*x*[1] – 3)² + (*x*[2] – 4)²)（新设施与竞争对手设施之间的距离）
- en: such that
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: such that
- en: '*g*[1](*x*[1], *x*[2]) = 2*x*[1] + *x*[2] – 6 ≤ 0 (zoning regulations)'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '*g*[1](*x*[1], *x*[2]) = 2*x*[1] + *x*[2] – 6 ≤ 0（分区法规）'
- en: '*g*[2](*x*[1], *x*[2]) = 2*x*[1] – *x*[2] – 2 ≤ 0 (environmental constraints
    or property boundaries)'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '*g*[2](*x*[1], *x*[2]) = 2*x*[1] – *x*[2] – 2 ≤ 0（环境约束或属性边界）'
- en: 0 ≤ *x*[1] ≤ 5 (boundary constraint)
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 0 ≤ *x*[1] ≤ 5（边界约束）
- en: 0 ≤ *x*[2] ≤ 5 (boundary constraint)
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 0 ≤ *x*[2] ≤ 5（边界约束）
- en: Write Python code to find the optimal location for the new facility.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Python代码以找到新设施的最佳位置。
- en: '2.   The All Ones problem, also known as the Max Ones problem, is a simple
    problem that aims to maximize the number of ones in a binary string of a fixed
    length. For a 10-bit All Ones problem, the optimal solution takes this form: [1111111111].
    The problem is described by K. Sutner in his article “Linear cellular automata
    and the Garden-of-Eden” [4] as follows: suppose each of the squares of an *n*
    × *n* chessboard is equipped with an indicator light and a button. If a square’s
    button is pressed, the light for that square will change from off to on or vice
    versa; the same happens to the lights of all the edge-adjacent squares. Initially
    all lights are off. The goal of the All Ones problem is to find a sequence of
    buttons that can be pressed in such a way that all lights are on at the end. This
    problem itself may not have direct applications, but it is used as a test problem
    to compare the performance of various algorithms. Write Python code to find a
    solution for the 10-bit All Ones problem using a genetic algorithm.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   全1问题，也称为最大1问题，是一个简单的目标是在固定长度的二进制字符串中最大化1的数量的问题。对于10位全1问题，最优解具有以下形式：[1111111111]。该问题由K.
    Sutner在他的文章“线性细胞自动机和伊甸园”中描述，如下：假设一个 *n* × *n* 国际象棋棋盘的每个方格都配备了一个指示灯和一个按钮。如果按下某个方格的按钮，该方格的灯将从关闭变为开启或反之亦然；相邻边界的所有灯也会发生同样的变化。最初所有灯都是关闭的。全1问题的目标是找到一个按钮按下的序列，使得最终所有灯都开启。这个问题本身可能没有直接的应用，但它被用作测试问题来比较各种算法的性能。编写Python代码以使用遗传算法找到10位全1问题的解决方案。
- en: 3.   Assume that there are 10 parcels to be loaded in the cargo bike in figure
    C.27.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   假设图C.27中有10个包裹需要装载到载货自行车上。
- en: '![](../Images/APPC_F27_Khamis.png)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F27_Khamis.png)'
- en: Figure C.27 Cargo bike loading problem for 10 items with given weight, profit,
    and efficiency (profit/weight)
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.27 10个物品的载货自行车装载问题，给定重量、利润和效率（利润/重量）
- en: Each parcel has its own weight, profit, and efficiency value (profit per kg).
    The goal is to select the parcels to be loaded in such a way that the utility
    function *f*[1] is maximized and the weight function *f*[2] is minimized.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包裹都有自己的重量、利润和效率值（每公斤利润）。目标是选择要装载的包裹，以便使效用函数 *f*[1] 最大化，而重量函数 *f*[2] 最小化。
- en: '*f*[1] = Σ*E[i]*, *i* = 0, 1, ..., *n*.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*[1] = Σ*E[i]*, *i* = 0, 1, ..., *n*.'
- en: '*f*[2] = |Σ*w[i]* – *C*|, 50 is added if and only if Σ*w[i]* > *C*.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*[2] = |Σ*w[i]* – *C*|，如果 Σ*w[i]* > *C*，则添加50。'
- en: where
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: where
- en: •   *n* is the total number of packages.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: •   *n* 是包裹的总数。
- en: •   *E[i]* is the efficiency of package *i*.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: •   *E[i]* 是包裹 *i* 的效率。
- en: •   *w[i]* is the weight of package *i*.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: •   *w[i]* 是包裹 *i* 的重量。
- en: •   *C* is the maximum capacity of the bike.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: •   *C* 是自行车的最大容量。
- en: A penalty of 50 is added if and only if the total weight of the added parcels
    exceeds the maximum capacity. Write Python code to determine which items should
    be loaded for maximum efficiency.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加的包裹总重量超过最大容量，则将添加50的惩罚。编写Python代码以确定哪些物品应装载以实现最大效率。
- en: '4.   In the opencast mining problem described by Guéret et al. in their book
    “Linear programming” [5], the opencast uranium mine is divided into blocks for
    exploitation. As illustrated in figure C.28, there are 18 blocks of 10,000 tons
    on three levels, identified based on the results of test drilling. The pit needs
    to be terraced to allow trucks to reach the bottom, and the pit is limited in
    the west by a village and in the east by a group of mountains. To extract a block,
    three blocks of the level above it need to be extracted due to constraints on
    the slope: the block immediately on top of it, and the blocks to the right and
    to the left. There are different costs associated with extracting blocks depending
    on their level. Level 1 blocks cost $100 per ton to extract, level 2 blocks cost
    $200 per ton, and level 3 blocks cost $300 per ton. However, the hatched blocks,
    which are formed of a very hard rock rich in quartz, cost $1,000 per ton to extract.
    The blocks that contain uranium are displayed in a gray shade: these are blocks
    0, 6, 9, 11, 16, and 17\. These blocks have different market values, with block
    17 being rich in ore but made of the same hard rock as the other hatched blocks.
    The market values of blocks 0, 6, 9, 11, 16, and 17 are $200, $300, $500, $200,
    $1,000, and $1,200 per ton, respectively.'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 在Guéret等人在其著作《线性规划》[5]中描述的开采式采矿问题中，露天铀矿被划分为用于开采的块。如图C.28所示，有18个10,000吨的块分布在三个层面上，这些块是基于测试钻探的结果进行识别的。为了使卡车能够到达底部，需要将坑道梯田化，并且坑道在西部被一个村庄限制，在东部被一群山脉限制。由于坡度限制，提取一个块需要提取其上方三个层面的三个块：直接在其上方的块，以及右侧和左侧的块。根据块的水平不同，提取块的成本也不同。第1层面的块每吨提取成本为100美元，第2层面的块每吨提取成本为200美元，第3层面的块每吨提取成本为300美元。然而，由非常坚硬且富含石英的岩石构成的网状块，每吨提取成本为1,000美元。含有铀的块以灰色阴影显示：这些是块0、6、9、11、16和17。这些块有不同的市场价值，其中块17富含矿石，但由与其他网状块相同的坚硬岩石制成。块0、6、9、11、16和17的市场价值分别为每吨200美元、300美元、500美元、200美元、1,000美元和1,200美元。
- en: '![](../Images/APPC_F28_Khamis.png)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F28_Khamis.png)'
- en: Figure C.28 Opencast mining problem
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.28 开采式采矿问题
- en: a.  Write a Python code to determine which blocks to extract to maximize the
    total profit, given by Σ(VALUE – COST) × *x[i]* for *x* = 0,1,…,17, where *x[i]*
    is an assignment binary variable.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: a. 编写一个Python代码，以确定提取哪些块以最大化总利润，总利润由Σ(VALUE – COST) × *x[i]*给出，其中*x* = 0,1,…,17，*x[i]*是一个分配的二进制变量。
- en: 'b.  Assume that the time duration required to process the blocks is [1, 1,
    1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 4, 4, 3, 4] depending on the block level and
    the hardness of the block. Write Python code to determine which blocks to extract
    to maximize the discounted profit and increased cost given by the following equations:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: b. 假设处理块所需的时间长度取决于块的水平以及块的硬度，为[1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 4,
    4, 3, 4]。编写Python代码以确定提取哪些块以最大化折扣利润和增加的成本，由以下方程给出：
- en: '![](../Images/APPC_F28_Khamis-EQ14a.png)'
  id: totrans-817
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F28_Khamis-EQ14a.png)'
- en: '5.   In the Chapter 8/Projects folder in the book’s GitHub repository, the
    following sample research projects are provided for review and experimentation:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 在书籍GitHub仓库的第八章/项目文件夹中，提供了以下样本研究项目以供审查和实验：
- en: •   *Routing*—Addresses using the genetic algorithm to find the shortest path
    between two points of interest in Vaughan, a municipality to the north of Toronto.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: •   *路由*——使用遗传算法在多伦多北部的市政区Vaughan中寻找两个感兴趣点之间的最短路径。
- en: •   *Bus routing*—Addresses the school bus routing problem, formulating the
    problem as a contained multi-objective optimization problem. The cluster-first
    route-second scheme, genetic algorithm, and adaptive genetic algorithm are applied
    to solve this problem. The performance of these algorithms is evaluated using
    real data from public schools in the city of Winchester, Virginia, USA.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: •   *公交车路线*——解决学校公交车路线问题，将问题表述为一个包含多目标优化问题的方案。应用聚类优先、路线优先方案、遗传算法和自适应遗传算法来解决这个问题。使用美国弗吉尼亚州温彻斯特市的公立学校真实数据评估这些算法的性能。
- en: '•   *Location allocation*—Tackles the placement of drone delivery stations
    using bio-inspired optimization algorithms. The solution framework consists of
    two stages: the first tackles the location planning problem of stations, while
    the second deals with the allocation of delivery demand to located stations.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: •   *位置分配*——使用生物启发式优化算法处理无人机配送站的放置问题。解决方案框架包括两个阶段：第一阶段解决站点的位置规划问题，而第二阶段处理分配给已定位站点的配送需求。
- en: C.7.2 Solutions
  id: totrans-822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.7.2 解决方案
- en: 1.   The next listing shows how to solve the facility allocation problem using
    NSGA-II.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 下一个列表显示了如何使用NSGA-II解决设施分配问题。
- en: Listing C.9 Solving the facility allocation problem using NSGA-II
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.9 使用NSGA-II解决设施分配问题
- en: '[PRE20]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Zooning constraint
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: ① 缩放约束
- en: ② Environment/property constraint
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: ② 环境/属性约束
- en: The complete listing, available in the book’s GitHub repository, also shows
    how to perform decision making to select the best solution.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍GitHub仓库中的完整列表还显示了如何执行决策以选择最佳解决方案。
- en: 2.   The All Ones problem solution is shown in the following listing.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 下一个列表显示了所有1问题的解决方案。
- en: Listing C.10 Solving the All Ones problem using GA
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.10 使用GA解决所有1的问题
- en: '[PRE21]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code defines an `AllOnes` class that extends the `Problem` class from pymoo.
    The `_evaluate` method of the `AllOnes` class calculates the fitness of an individual
    by counting the number of ones in the binary string and returning the negative
    of that count (because pymoo minimizes objective functions).
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了一个扩展pymoo中`Problem`类的`AllOnes`类。`AllOnes`类的`_evaluate`方法通过计算二进制字符串中1的数量并返回该计数的负值（因为pymoo最小化目标函数）来计算个体的适应度。
- en: 3.   The solution to the cargo bike loading problem is shown in the next listing.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 下一个列表显示了货物自行车装载问题的解决方案。
- en: Listing C.11 Solving the cargo bike loading problem using GA
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.11 使用GA解决货物自行车装载问题
- en: '[PRE22]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Define the problem.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义问题。
- en: ② Define the problem inputs.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义问题输入。
- en: ③ Create a problem instance.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建问题实例。
- en: ④ Define the genetic algorithm.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义遗传算法。
- en: ⑤ Run the optimization.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 运行优化。
- en: ⑥ Print the results.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印结果。
- en: ⑦ Visualize the solution.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 可视化解决方案。
- en: Running this code produces the solution shown in figure C.29.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生图C.29所示的解决方案。
- en: '![](../Images/APPC_F29_Khamis.png)'
  id: totrans-844
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F29_Khamis.png)'
- en: Figure C.29 Cargo bike loading solution
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.29 货物自行车装载解决方案
- en: 4.   The next listing shows the steps to solve the opencast mining problem.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 下一个列表显示了解决露天采矿问题的步骤。
- en: Listing C.12 Solving the opencast mining problem
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.12 解决露天采矿问题
- en: '[PRE23]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Blocks in the mine
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: ① 矿中的块
- en: ② Blocks in levels 2 and 3
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: ② 2级和3级中的块
- en: ③ Cost of blocks.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 块的成本。
- en: ④ Value of blocks
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 块的价值
- en: ⑤ Define the ARC for each block in LEVEL23.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义LEVEL23中每个块的成本。
- en: 'As a continuation, you can visualize the precedence of extraction of blocks
    in levels 2 and 3 as follows:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 作为延续，你可以如下可视化2级和3级中块提取的前置关系：
- en: '[PRE24]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① Create the directed graph.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建有向图。
- en: ② Add the nodes.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: ② 添加节点。
- en: ③ Add precedence edges.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 添加前置边。
- en: ④ Create a pos dictionary with a default position for all nodes.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建一个具有所有节点默认位置的pos字典。
- en: ⑤ Update the positions of nodes that have a specific position.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 更新具有特定位置的节点的位置。
- en: ⑥ Draw the graph.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 绘制图表。
- en: Figure C.30 shows the precedence graph for extracting blocks in levels 2 and
    3.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.30显示了在2级和3级中提取块的前置图。
- en: '![](../Images/APPC_F30_Khamis.png)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F30_Khamis.png)'
- en: Figure C.30 Precedence graph for extracting blocks in levels 2 and 3
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.30 2级和3级中提取块的前置图
- en: As a continuation of listing C.12, the following code snippet shows how to define
    the problem as a single objective constrained optimization problem.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表C.12的延续，以下代码片段显示了如何将问题定义为单目标约束优化问题。
- en: '[PRE25]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now define the GA solver and apply it to solve the problem as follows:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义GA求解器并将其应用于以下问题求解：
- en: '[PRE26]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running this code produces the following output:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE27]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The complete version of listing C.12 in the book’s GitHub repository includes
    the Pareto optimization implementation, which treats the problem as a multi-objective
    optimization problem.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍GitHub仓库中C.12列表的完整版本包括了帕累托优化实现，将问题视为一个多目标优化问题。
- en: 'C.8 Chapter 9: Particle swarm optimization'
  id: totrans-872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.8 第九章：粒子群优化
- en: C.8.1 Exercises
  id: totrans-873
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.8.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 多项选择题和判断题：为以下每个问题选择正确答案。
- en: 1.1.   Which of the following is a drawback of the star structure in PSO?
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1. 以下哪项是PSO中星型结构的缺点？
- en: a.  It may lead to premature convergence to a suboptimal solution.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: a. 可能会导致过早收敛到次优解。
- en: b.  It may cause the algorithm to converge too slowly.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: b. 可能会导致算法收敛速度过慢。
- en: c.  It may cause the algorithm to become stuck in local optima.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: c. 可能会导致算法陷入局部最优。
- en: d.  It does not allow the algorithm to explore the search space effectively.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: d. 不允许算法有效地探索搜索空间。
- en: 1.2.   Asynchronous PSO usually produces better results because it causes the
    particles to use more up-to-date information.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '1.2. 异步PSO通常会产生更好的结果，因为它使粒子使用更及时的信息。 '
- en: a.  True
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b.  False
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: 1.3.   What is the difference between the cognitive and social components in
    PSO?
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3. PSO中认知组件和社会组件之间的区别是什么？
- en: a.  The cognitive component is based on the particle’s own experience, while
    the social component is based on the experience of the swarm as a whole.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: a. 认知组件基于粒子的自身经验，而社会组件基于整个群体的经验。
- en: b.  The cognitive component is based on the experience of the particle’s neighbors,
    while the social component is based on the particle’s own experience.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: b. 认知组件基于粒子的邻居的经验，而社会组件基于粒子的自身经验。
- en: c.  The cognitive component is based on random perturbations, while the social
    component is based on gradient information.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: c. 认知组件基于随机扰动，而社会组件基于梯度信息。
- en: d.  The cognitive and social components are the same thing.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: d. 认知组件和社会组件是同一件事。
- en: 1.4.   Ring topology, or lbest PSO, has been shown to converge faster than other
    network structures, but with a susceptibility to be trapped in local minima.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4. 环形拓扑，或lbest PSO，已被证明比其他网络结构收敛得更快，但容易陷入局部最小值。
- en: a.  True
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b.  False
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: 1.5.   In binary PSO (BPSO), each bit in the binary strings is updated by considering
    its current state, the best state it has held so far, and the best state of its
    neighboring bits.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5. 在二进制PSO（BPSO）中，二进制字符串中的每个位都通过考虑其当前状态、迄今为止保持的最佳状态以及其相邻位的最优状态来更新。
- en: a.  True
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b.  False
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: 1.6.   In PSO, the velocity model that makes particles behave like independent
    hill climbers is
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6. 在PSO中，使粒子表现得像独立爬山者的速度模型是
- en: a.  Cognitive-only model
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: a. 仅认知模型
- en: b.  Social-only model
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: b. 仅社会模型
- en: 1.7.   PSO is guaranteed to find the global optimum of a function.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7. PSO保证找到函数的全局最优解。
- en: a.  True
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b.  False
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: 1.8.   What is the role of the acceleration coefficients in the PSO algorithm?
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8. 在PSO算法中，加速度系数的作用是什么？
- en: a.  To control the speed of the particles
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: a. 控制粒子的速度
- en: b.  To control the exploration/exploitation trade-off
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: b. 控制探索/利用权衡
- en: c.  To control the swarm size
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: c. 控制群体大小
- en: d.  To control the mutation rate
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: d. 控制突变率
- en: 1.9.   PSO is a local search algorithm that is only able to find local optima.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9. PSO是一种局部搜索算法，只能找到局部最优解。
- en: a.  True
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b.  False
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: 1.10. PSO was originally developed for continuous-valued spaces.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. PSO最初是为连续值空间开发的。
- en: a.  True
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b.  False
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '2.   In the restaurant game described by Martin et al. in their article “Local
    termination criteria for swarm intelligence: A comparison between local stochastic
    diffusion search and ant nest-site selection,” [6], a group of delegates attends
    a long conference in an unfamiliar town. Each night they have to find somewhere
    to dine. There is a large choice of restaurants, each of which offers a large
    variety of meals. The problem the group faces is to find the best restaurant,
    which is the restaurant where the maximum number of delegates would enjoy dining.
    Even a parallel exhaustive search through the restaurant and meal combinations
    would take too long to accomplish. If you were to solve this problem using PSO,
    how would you describe the three components of the velocity update in the context
    of this problem?'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在Martin等人在其文章“局部终止标准用于群体智能：局部随机扩散搜索与蚂蚁巢穴选择之间的比较”中描述的餐厅游戏中，一群代表在一个不熟悉的城镇参加长时间的会议。每晚他们都必须找到吃饭的地方。有大量的餐厅可供选择，每家餐厅都提供大量的餐点。该群体面临的问题是找到最好的餐厅，即大多数代表愿意就餐的餐厅。即使通过并行穷举搜索餐厅和餐点组合也会花费太长时间。如果你使用PSO来解决这个问题，你将如何描述在这个问题背景下速度更新的三个组件？
- en: 3.   Ridesharing is a successful implementation of the sharing economy business
    model where personal vehicles are shared by their owners or drivers with individual
    travelers who have similar itineraries and schedules. The ridesharing problem
    is a multi-objective constrained optimization problem. A non-comprehensive list
    of optimization goals for ridesharing includes
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 共享出行是共享经济商业模式的一种成功实施，其中个人车辆由车主或驾驶员与具有相似行程和日程的个别旅客共享。共享出行问题是一个多目标约束优化问题。共享出行优化目标的不完整列表包括
- en: •   Minimizing the total travel distance or time of drivers’ trips
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: • 最小化驾驶员行程的总旅行距离或时间
- en: •   Minimizing the total travel time of passengers’ trips
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: •   最小化乘客行程的总旅行时间
- en: •   Maximizing the number of matched (served) requests
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: •   最大化匹配（服务）请求的数量
- en: •   Minimizing the cost for the drivers’ trips
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: •   最小化驾驶员行程的成本
- en: •   Minimizing the cost for the passengers’ trips
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: •   最小化乘客行程的成本
- en: •   Maximizing the driver’s earnings
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: •   最大化驾驶员的收入
- en: •   Minimizing the passenger’s waiting time
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: •   最小化乘客的等待时间
- en: •   Minimizing the total number of drivers required
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: •   最小化所需驾驶员的总数
- en: 'Consider the ridesharing problem shown in figure C.31, where the objective
    is to come up with a schedule for drivers that minimizes the total distances of
    vehicles’ trips. The statement of this multi-objective optimization is as follows:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图C.31所示的拼车问题，其目标是制定驾驶员的行程，以最小化车辆行程的总距离。该多目标优化的表述如下：
- en: Find *s* that minimizes *f*
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最小化 *f* 的 *s*
- en: '![](../Images/APPC_F30_Khamis-EQ16.png)'
  id: totrans-923
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F30_Khamis-EQ16.png)'
- en: where
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *f* is the total distance of vehicles’ trips to serve all the passengers.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: •   *f* 是为服务所有乘客而进行的车辆行程的总距离。
- en: •   *s[i,j]* is 1 if location *j* is assigned within the schedule of the driver
    and 0 otherwise.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: •   *s[i,j]* 如果位置 *j* 被分配在驾驶员的行程中则为1，否则为0。
- en: •   *d[i,j]* is the distance between two points within the route, where
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: •   *d[i,j]* 是路线内两点之间的距离，其中
- en: '*d[i,j]* = √((*x[i]* – *x[j]*)² + (*y[i]* – *y[j]*)²'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '*d[i,j]* = √((*x[i]* – *x[j]*)² + (*y[i]* – *y[j]*)²'
- en: •   *P* is the passenger set, with known pickup and delivery points.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: •   *P* 是乘客集合，具有已知的接车和送车点。
- en: •   *V* is the vehicle set, with predefined initial and final locations.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: •   *V* 是车辆集合，具有预定义的起始和终止位置。
- en: '![](../Images/APPC_F31_Khamis.png)'
  id: totrans-931
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F31_Khamis.png)'
- en: Figure C.31 The ridesharing problem
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.31 拼车问题
- en: Given the pickup and drop-off locations of five passengers (table C.3) and the
    initial and final locations of the two drivers (table C.4), define a suitable
    representation for a particle (i.e., a candidate solution) that represents each
    driver’s schedule and evaluates its fitness.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 给定五位乘客的接车和送车位置（表C.3）以及两位驾驶员的起始和终止位置（表C.4），定义一个合适的粒子表示（即候选解决方案），以表示每位驾驶员的行程并评估其适应性。
- en: Table C.3 Pickup and drop-off locations of the passengers
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.3 乘客的接车和送车位置
- en: '| Passengers | Pickup x-coordinate | Pickup y-coordinate | Drop-off x-coordinate
    | Drop-off y-coordinate |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '| 乘客 | 接车x坐标 | 接车y坐标 | 送车x坐标 | 送车y坐标 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| P1 | 9 | 9 | 4 | 2 |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '| P1 | 9 | 9 | 4 | 2 |'
- en: '| P2 | 8 | 5 | 2 | 4 |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| P2 | 8 | 5 | 2 | 4 |'
- en: '| P3 | 6 | 1 | 8 | 6 |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '| P3 | 6 | 1 | 8 | 6 |'
- en: '| P4 | 7 | 6 | 9 | 8 |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '| P4 | 7 | 6 | 9 | 8 |'
- en: '| P5 | 3 | 5 | 10 | 3 |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '| P5 | 3 | 5 | 10 | 3 |'
- en: Table C.4 Initial and final locations of the drivers
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.4 驾驶员的起始和终止位置
- en: '| Drivers | Initial x-coordinate | Initial y-coordinate | Final x-coordinate
    | Final y-coordinate |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '| 驾驶员 | 起始x坐标 | 起始y坐标 | 终止x坐标 | 终止y坐标 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| A | 4 | 1 | 8 | 10 |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '| A | 4 | 1 | 8 | 10 |'
- en: '| B | 1 | 6 | 9 | 4 |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '| B | 1 | 6 | 9 | 4 |'
- en: '4.   Consider the trip itinerary planning problem where the objective is to
    provide an optimal travel itinerary for tourists visiting a new city, taking into
    consideration the quality of the places to be visited, the proximity of the attractions
    to one another, and how much of the day can be completely occupied with little
    idle time. The problem is stated as following:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   考虑旅行行程规划问题，其目标是提供为访问新城市的游客提供的最佳旅行行程，考虑到要访问地点的质量、景点之间的邻近性以及一天中可以完全占用且空闲时间最少的时间。问题表述如下：
- en: Find *X* which optimizes *f*
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 找到优化 *f* 的 *X*
- en: '![](../Images/APPC_F31_Khamis-EQ18.png)'
  id: totrans-949
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F31_Khamis-EQ18.png)'
- en: 'subject to the following constraints:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循以下约束条件：
- en: •   The duration of the itinerary must not exceed total time in a given day,
    which is set to 480 minutes. This is expressed as the summation of the duration
    of each venue and total commute time to be visited in an itinerary. This means
    that *Z[d]* + *Z[c]* <= 480 minutes.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: •   行程的持续时间不得超过给定一天的总时间，该时间为480分钟。这表示为行程中每个场所的持续时间与要访问的总通勤时间的总和。这意味着 *Z[d]*
    + *Z[c]* <= 480分钟。
- en: •   There should never be repetitions of the same venue in a solution.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: •   解决方案中不应重复相同的场所。
- en: where
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *X* = [*Z[d] Z[c] Z[r]*]*^T*
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: •   *X* = [*Z[d] Z[c] Z[r]*]*^T*
- en: •   *Z[d]* represents the duration of the itinerary (minutes).
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: •   *Z[d]* 表示行程的持续时间（分钟）。
- en: •   *Z[c]* represents the total commute time in the itinerary.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: •   *Z[c]* 表示行程中的总通勤时间。
- en: •   *Z[r]* represents the average rating of all the venues in an itinerary.
    The ratings are derived from Yelp, Google reviews, or others.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: •   *Z[r]* 代表行程中所有场所的平均评分。评分来自Yelp、Google评论或其他来源。
- en: Table C.5 lists the commute times between 10 attractions.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.5列出了10个景点之间的通勤时间。
- en: Table C.5 Commute time between attractions
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.5 景点之间的通勤时间
- en: '| Commute time (mins) | To |'
  id: totrans-960
  prefs: []
  type: TYPE_TB
  zh: '| Commute time (mins) | To |'
- en: '| --- | --- |'
  id: totrans-961
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
- en: '| From | 0 | 10 | 20 | 7 | 11 | 8 | 19 | 7 | 1 | 1 |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: '| From | 0 | 10 | 20 | 7 | 11 | 8 | 19 | 7 | 1 | 1 |'
- en: '|  | 1 | 0 | 12 | 14 | 1 | 7 | 12 | 10 | 22 | 22 |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 | 0 | 12 | 14 | 1 | 7 | 12 | 10 | 22 | 22 |'
- en: '| 2 | 12 | 0 | 25 | 21 | 28 | 1 | 22 | 12 | 12 |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 12 | 0 | 25 | 21 | 28 | 1 | 22 | 12 | 12 |'
- en: '| 3 | 14 | 25 | 0 | 15 | 15 | 25 | 4 | 6 | 6 |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 14 | 25 | 0 | 15 | 15 | 25 | 4 | 6 | 6 |'
- en: '| 4 | 1 | 21 | 15 | 0 | 25 | 22 | 11 | 10 | 10 |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 | 21 | 15 | 0 | 25 | 22 | 11 | 10 | 10 |'
- en: '| 5 | 7 | 28 | 15 | 25 | 0 | 28 | 14 | 28 | 29 |'
  id: totrans-968
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 7 | 28 | 15 | 25 | 0 | 28 | 14 | 28 | 29 |'
- en: '| 6 | 12 | 1 | 25 | 22 | 28 | 0 | 22 | 12 | 12 |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 12 | 1 | 25 | 22 | 28 | 0 | 22 | 12 | 12 |'
- en: '| 7 | 10 | 22 | 4 | 11 | 14 | 22 | 0 | 3 | 2 |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 10 | 22 | 4 | 11 | 14 | 22 | 0 | 3 | 2 |'
- en: '| 8 | 22 | 12 | 6 | 10 | 28 | 12 | 3 | 0 | 1 |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 22 | 12 | 6 | 10 | 28 | 12 | 3 | 0 | 1 |'
- en: '| 9 | 22 | 12 | 6 | 10 | 29 | 12 | 2 | 1 | 0 |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 22 | 12 | 6 | 10 | 29 | 12 | 2 | 1 | 0 |'
- en: The durations and ratings for the different attractions are listed in table
    C.6.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 不同景点的持续时间及评分列于表C.6中。
- en: Table C.6 Ratings and durations for attractions
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.6 景点评分和持续时间
- en: '| ID | Rating | Duration (mins) |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
  zh: '| ID | Rating | Duration (mins) |'
- en: '| --- | --- | --- |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Starting hotel |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Starting hotel |'
- en: '| 1 | 2 | 120 |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 120 |'
- en: '| 2 | 3 | 60 |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 60 |'
- en: '| 3 | 3 | 180 |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 180 |'
- en: '| 4 | 0 | 180 |'
  id: totrans-981
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0 | 180 |'
- en: '| 5 | 5 | 120 |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 120 |'
- en: '| 6 | 1 | 60 |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1 | 60 |'
- en: '| 7 | 4 | 60 |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 4 | 60 |'
- en: '| 8 | 0 | 60 |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 0 | 60 |'
- en: '| 9 | 2 | 120 |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 2 | 120 |'
- en: Define a suitable representation of a particle (i.e., a candidate solution),
    and carry out two hand iterations to show how to solve this problem using PSO,
    assuming a swarm size of 4.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个合适的粒子表示（即候选解），并进行两次手动迭代，以展示如何使用PSO算法（假设群体大小为4）来解决这个问题。
- en: 5.   *Trilateration* is used to identify the location of a moving object such
    as a connected vehicle or a cellphone. This process uses the distance between
    the vehicle and three or more known cell towers to determine the location of the
    vehicle. By measuring the signal strength of the device’s signal at each tower,
    the distance between the device and each tower can be calculated. The intersection
    of the three (or more) circles created by these distance measurements gives an
    estimate of the device’s location. As shown in figure C.32, three cell towers
    advertise their coordinates and transmit a reference signal.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   *三角测量法*用于确定移动对象（如连接车辆或手机）的位置。这个过程使用车辆与三个或更多已知基站的距离来确定车辆的位置。通过测量每个基站设备信号的信号强度，可以计算出设备与每个基站之间的距离。这些距离测量产生的三个（或更多）圆的交点给出了设备位置的估计。如图C.32所示，三个基站发布它们的坐标并传输参考信号。
- en: '![](../Images/APPC_F32_Khamis.png)'
  id: totrans-989
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F32_Khamis.png)'
- en: Figure C.32 Cell tower trilateration
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.32 基站三角测量
- en: 'The connected vehicle uses the reference signal to estimate distances to each
    of the cells *r[i]*. These distance measurements *r[i]* may be subject to noise.
    Assume that the associated error is given by the following equation:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 连接车辆使用参考信号来估计到每个单元格 *r[i]* 的距离。这些距离测量值 *r[i]* 可能会受到噪声的影响。假设相关的误差由以下方程给出：
- en: '![](../Images/APPC_F32_Khamis-EQ19.png)'
  id: totrans-992
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F32_Khamis-EQ19.png)'
- en: 'The vehicle position (*ϕ*[0], *λ*[0]) is the position that minimizes the following
    objective function:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆位置（*ϕ*[0]，*λ*[0]）是使以下目标函数最小化的位置：
- en: '![](../Images/APPC_F32_Khamis-EQ20.png)'
  id: totrans-994
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F32_Khamis-EQ20.png)'
- en: Write Python code to find the vehicle’s position using PSO.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PSO算法编写Python代码来查找车辆的位置。
- en: '6.   A coffee shop offers two sizes of coffee: small and large. The cost of
    making a small coffee is $1, and the cost of making a large coffee is $1.50\.
    The coffee shop sells small coffees for $2 each and large coffees for $3 each.
    The coffee shop wants to maximize its profit, but it also wants to ensure that
    it sells at least 50 small coffees and 75 large coffees and at most 300 and 450
    respectively per day. This problem can be formulated as an optimization problem
    as follows:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   咖啡店提供两种咖啡大小：小杯和大杯。制作一杯小咖啡的成本是1美元，制作一杯大咖啡的成本是1.50美元。咖啡店以每杯2美元的价格出售小杯咖啡，以每杯3美元的价格出售大杯咖啡。咖啡店希望最大化其利润，但同时也希望确保每天至少出售50杯小杯咖啡和75杯大杯咖啡，并且分别最多不超过300杯和450杯。这个问题可以表述为一个优化问题，如下所示：
- en: Maximize profit = 2*x*[1] + 3*x*[2] - (*x*[1] + 1.5*x*[2])
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化利润 = 2*x*[1] + 3*x*[2] - (*x*[1] + 1.5*x*[2])
- en: Subject to
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 约束条件：
- en: 50 ≤ *x*[1] ≤ 300
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 50 ≤ *x*[1] ≤ 300
- en: 75 ≤ *x*[2] ≤ 450
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 75 ≤ *x*[2] ≤ 450
- en: where
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *x*[1] is the number of small coffees to make.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x*[1] 是制作的小杯咖啡数量。
- en: •   *x*[2] is the number of large coffees to make.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x*[2] 是制作的大杯咖啡数量。
- en: Profit is the total profit, where the first term in the equation represents
    the revenue from selling the coffees, and the second term represents the cost
    of making the coffees. Write Python code to find the optimal number of small coffees
    and large coffees to make every day.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 利润是总利润，其中方程中的第一项代表咖啡销售收入，第二项代表制作咖啡的成本。编写Python代码以找到每天制作小杯咖啡和大杯咖啡的最佳数量。
- en: 7.   A hospital wants to optimize the scheduling of its doctors to minimize
    the overall cost of labor while ensuring that enough doctors are available to
    meet patient demand. Each doctor has a different hourly rate, and there are different
    levels of patient demand at different times of the day. The goal is to find the
    optimal schedule that minimizes the total cost of labor while meeting the minimum
    doctor requirements during both peak and non-peak hours.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 7.   一家医院希望优化其医生的工作安排，以最小化劳动力总成本，同时确保有足够的医生满足患者需求。每位医生的时薪不同，而且一天中不同时间段的病人需求水平也不同。目标是找到最优的排班方案，以最小化劳动力总成本，同时满足高峰时段和非高峰时段的最低医生需求。
- en: The hospital must schedule at least four doctors during peak hours and at least
    two doctors during non-peak hours. The hospital can hire part-time doctors at
    a lower hourly rate, but they can only work during non-peak hours. The hospital
    also has the option of paying overtime to full-time doctors to meet demand during
    peak hours, but at a higher hourly rate.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 医院必须在高峰时段安排至少四名医生，在非高峰时段至少安排两名医生。医院可以以较低的时薪聘请兼职医生，但他们只能在非高峰时段工作。医院还有选择在高峰时段支付全职医生加班费以满足需求的选项，但时薪较高。
- en: 'The problem can be mathematically described as follows:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题可以用以下数学公式描述：
- en: 'Minimize the total cost of labor: *f*(*x*) = Σ(*c[i]* × *x[i]*) + Σ(*c[i]^o*
    × *x[i]^o*) + Σ(*c[j]^p* × *x[j]^p*)'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化劳动力总成本：*f*(*x*) = Σ(*c[i]* × *x[i]*) + Σ(*c[i]^o* × *x[i]^o*) + Σ(*c[j]^p*
    × *x[j]^p*)
- en: 'subject to the following constraints:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 约束条件如下：
- en: '•   Σ*x[i]* + Σ*x[i]^o* ≥ 4: At least four doctors must be scheduled during
    peak hours.'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: •   Σ*x[i]* + Σ*x[i]^o* ≥ 4：高峰时段至少安排四名医生。
- en: '•   Σ*x[i]^p* ≥ 2: At least two doctors must be scheduled during non-peak hours.'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: •   Σ*x[i]^p* ≥ 2：非高峰时段至少安排两名医生。
- en: '•   *x[i]*, *x[i]^o*, *x[j]^p* ≥ 0: Non-negativity constraints'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x[i]*, *x[i]^o*, *x[j]^p* ≥ 0：非负约束
- en: where
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *i* is the index for full-time doctors, *i* = 1, 2, ..., *m*.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: •   *i* 是全职医生的索引，*i* = 1, 2, ..., *m*.
- en: •   *j* is the index for part-time doctors, *j* = 1, 2, ..., *n*.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: •   *j* 是兼职医生的索引，*j* = 1, 2, ..., *n*。
- en: 'Predefined parameters:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义参数：
- en: •   *c[i]* is the hourly rate for full-time doctor *i*.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: •   *c[i]* 是全职医生 *i* 的时薪。
- en: •   *c[i]^o* is the overtime hourly rate for full-time doctor *i*.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: •   *c[i]^o* 是全职医生 *i* 的加班时薪。
- en: •   *c[j]^p* is the hourly rate for part-time doctor *j*.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: •   *c[j]^p* 是兼职医生 *j* 的时薪。
- en: 'Decision variables:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 决策变量：
- en: •   *x[i]* is the number of hours worked by full-time doctor *i* during peak
    hours.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x[i]* 是全职医生 *i* 在高峰时段工作的小时数。
- en: •   *x[i]^o* is the number of overtime hours worked by full-time doctor *i*
    during peak hours.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x[i]^o* 是全职医生 *i* 在高峰时段加班工作的小时数。
- en: •   *x[j]^p* is the number of hours worked by part-time doctor *j* during non-peak
    hours.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x[j]^p* 是兼职医生 *j* 在非高峰时段工作的小时数。
- en: Assume the full-time rates of full-time doctors are [30, 35, 40, 45, 50], their
    overtime rates are 1.5 times the full-time rates, and the part-time doctors’ rates
    are [25, 27, 29, 31, 33]. Write Python code to solve this problem using PSO.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 假设全职医生的时薪为 [30, 35, 40, 45, 50]，他们的加班费是全职时薪的1.5倍，兼职医生的时薪为 [25, 27, 29, 31, 33]。编写Python代码使用PSO求解此问题。
- en: '8.   In neighborhood *Y* of city *X*, there are eight schools that collectively
    possess 100 microscopes for use in biology classes. These resources, however,
    are not uniformly distributed amongst the schools. With recent changes in student
    enrollment, four schools have more microscopes than needed, while the other four
    schools are in need of additional ones. To address this problem, Dr. Rachel Carson,
    who is in charge of the biology department at city *X*.''s school board, decides
    to use a mathematical model. She chooses to use the transportation problem model,
    a strategy aimed at efficiently allocating resources while minimizing transportation
    costs as per R. Lovelace in his article “Open source tools for geographic analysis
    in transport planning” [7]. The model represents supply *n* and demand *m* as
    unit weights of decision variables at various points in a network, with the cost
    of transporting a unit from a supply point to a demand point equivalent to the
    time or distance between nodes. This data is captured in an *n***m* cost matrix.
    The formal statement of this integer linear programming problem is described in
    Daskin’s book “Network and Discrete Location: Models, Algorithms, and Applications”
    [8] as follows:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 8.   在城市 *X* 的邻域 *Y* 中，有八所学校共同拥有100台显微镜用于生物课教学。然而，这些资源在学校之间并不是均匀分布的。随着学生入学人数的最近变化，四所学校拥有的显微镜多于所需，而其他四所学校则需要额外的显微镜。为了解决这个问题，负责城市
    *X* 学校委员会生物系的Rachel Carson博士决定使用数学模型。她选择使用运输问题模型，这是一种旨在高效分配资源并最小化运输成本的策略，正如R.
    Lovelace在其文章“地理分析中的开源工具”中所述 [7]。该模型将供应 *n* 和需求 *m* 表示为网络中各个点的决策变量的单位权重，从供应点到需求点的单位运输成本等同于节点之间的时间或距离。这些数据被捕获在一个
    *n***m* 成本矩阵中。该整数线性规划问题的正式陈述在Daskin的书籍“网络和离散定位：模型、算法和应用” [8] 中描述如下：
- en: '![](../Images/APPC_F32_Khamis-EQ28.png)'
  id: totrans-1026
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F32_Khamis-EQ28.png)'
- en: subject to the following constraints
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 满足以下约束条件
- en: •   Σ*[j]*[∈]*[J] x[ij]* ≤ *S[i]* ∀ *i* ∈ *I*
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: •   Σ*[j]*[∈]*[J] x[ij]* ≤ *S[i]* 对于所有 *i* ∈ *I*
- en: •   Σ*[j]*[∈]*[J] x[ij]* ≥ *D[i]* ∀ *j* ∈ *J*
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: •   Σ*[j]*[∈]*[J] x[ij]* ≥ *D[i]* 对于所有 *j* ∈ *J*
- en: •   *x[ij]* ≥ 0 ∀ *i* ∈ *I* and ∀ *j* ∈ *J*
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x[ij]* ≥ 0 对于所有 *i* ∈ *I* 和所有 *j* ∈ *J*
- en: where
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *i* is each potential origin node.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: •   *i* 是每个潜在的源节点。
- en: •   *I* is the complete set of potential origin nodes.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: •   *I* 是所有潜在源节点的完整集合。
- en: •   *j* is each potential destination node.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: •   *j* 是每个潜在的终点节点。
- en: •   *J* is the complete set of potential nodes.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: •   *J* 是所有潜在节点的完整集合。
- en: •   *x[ij]* is the amount to be shipped from ∀ *i* ∈ *I* to ∀ *j* ∈ *J*.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x[ij]* 是从所有 *i* ∈ *I* 到所有 *j* ∈ *J* 的运输量。
- en: •   *c[ij]* is per unit shipping costs between all *i*, *j* pairs.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: •   *c[ij]* 是所有 *i*, *j* 对之间的单位运输成本。
- en: •   *S[i]* is node *i* supply for ∀ *i* ∈ *I*.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: •   *S[i]* 是节点 *i* 的供应量，对于所有 *i* ∈ *I*。
- en: •   *D[j]* is node *i* demand for ∀ *j* ∈ *J*.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: •   *D[j]* 是节点 *i* 的需求量，对于所有 *j* ∈ *J*。
- en: Write Python code to solve this problem using PSO. Visualize the solution on
    a geospatial map.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Python代码使用PSO解决这个问题。在地理空间地图上可视化解决方案。
- en: 9.   In the Chapter 9/Projects folder in the book’s GitHub repository, the following
    sample research projects are provided for review and experimentation.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 9.   在书籍GitHub存储库的第九章/项目文件夹中，提供了以下样本研究项目以供审查和实验。
- en: •   Routing—Addresses using PSO to find the shortest path between two points
    of interest in Toronto
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: •   路由——探讨使用PSO在多伦多两个感兴趣点之间找到最短路径。
- en: •   Bus stops placement—Addresses how to use PSO to find the optimal placement
    of bus stops in the Waterloo/Kitchener area, Ontario, Canada
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: •   公交站点的放置——探讨如何使用粒子群优化算法（PSO）在加拿大安大略省滑铁卢/基奇纳地区找到公交站点的最佳位置。
- en: C.8.2 Solutions
  id: totrans-1044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.8.2 解决方案
- en: 1.   Multiple choice and true/false
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和真/假题
- en: 1.1.   c) It may cause the algorithm to become stuck in local optima.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   c) 可能会导致算法陷入局部最优。
- en: 1.2.   a) True
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   a) 正确
- en: 1.3.   a) The cognitive component is based on the particle’s own experience,
    while the social component is based on the experience of the swarm as a whole.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   a) 认知组件基于粒子的自身经验，而社交组件基于整个群体的经验。
- en: 1.4.   b) False
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   b) 错误
- en: 1.5.   a) True
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   a) 正确
- en: 1.6.   a) Cognitive-only model
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   a) 认知模型
- en: 1.7.   b) False
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   b) 错误
- en: 1.8.   b) To control the exploration/exploitation trade-off
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   b) 为了控制探索/利用权衡
- en: 1.9.   b) False (PSO is designed to explore the search space globally and has
    the potential to find the global optimum.)
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   b) 错误（PSO旨在全局探索搜索空间，并有可能找到全局最优解。）
- en: 1.10. a) True
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. a) 正确
- en: 2.   Imagine a group of delegates visiting an unfamiliar city for a conference.
    They are trying to find the best restaurant in town using PSO principles. The
    town is large, and each delegate starts at a different location. Each delegate
    has a preferred way of exploring restaurants, like walking along certain streets
    or visiting specific neighborhoods. This is similar to the inertia component in
    PSO, where particles maintain their current velocity and direction, ensuring they
    don’t change their exploration pattern too abruptly.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   想象一群代表访问一个不熟悉的城市参加会议。他们试图使用PSO原则在该镇找到最好的餐厅。这个城镇很大，每位代表从一个不同的位置开始。每位代表都有一种偏好的探索餐厅的方式，比如沿着某些街道散步或访问特定的社区。这类似于PSO中的惯性成分，其中粒子保持它们当前的速度和方向，确保它们不会太突然地改变它们的探索模式。
- en: As each delegate visits different restaurants, they remember the best one they’ve
    been to so far (their personal best). If they come across a less appealing restaurant,
    they’re more likely to return to their favorite one, knowing it was a good choice
    based on their own experience. This is the cognitive component, where particles
    in PSO are attracted to their personal best positions, following their past experiences
    and individual preferences.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每位代表访问不同的餐厅，他们会记住迄今为止他们去过最好的餐厅（他们的个人最佳）。如果他们遇到一个不那么吸引人的餐厅，他们更有可能回到他们最喜欢的餐厅，因为他们知道根据他们自己的经验，这是一个好的选择。这是认知成分，在PSO中，粒子被吸引到它们个人的最佳位置，遵循它们过去的经验和个人偏好。
- en: The delegates also communicate with each other via group chat, sharing their
    experiences and the locations of the best restaurants they’ve found. If someone
    discovers an outstanding restaurant, others might decide to visit that place and
    try it for themselves, even if it wasn’t their personal favorite. This is the
    social component, where particles in PSO are influenced by the global best position
    or the collective knowledge of the swarm.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 代表们还通过群聊相互交流，分享他们找到的最好餐厅的经历和位置。如果有人发现一家杰出的餐厅，其他人可能会决定去那个地方亲自尝试，即使它不是他们的个人最爱。这是社交成分，在PSO中，粒子受到全局最佳位置或群体集体知识的影响。
- en: '3.   Due to the discrete nature of the formulated problem, permutation-based
    PSO should be used. A particle in this algorithm represents an ordering of the
    passengers to be picked up and dropped off by each driver. In this problem, we
    have two vehicles, A and B, and five passenger requests to match (P1–P5). For
    example, a candidate solution for a problem with five passengers and two drivers
    would have the following format:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   由于公式的离散性质，应使用基于排列的PSO。在这个算法中，一个粒子代表每个司机要接车和下车的乘客的排序。在这个问题中，我们有两个车辆A和B，以及五个乘客请求（P1–P5）需要匹配。例如，一个有五个乘客和两个司机的候选解决方案将具有以下格式：
- en: '| A^+ | P3^+ | P4^+ | P3^– | P5^+ | P4^– | P5^– | A^– |'
  id: totrans-1060
  prefs: []
  type: TYPE_TB
  zh: '| A^+ | P3^+ | P4^+ | P3^– | P5^+ | P4^– | P5^– | A^– |'
- en: '| B^+ | P1^+ | P2^+ | P2^– | P1^– | B^– |  |  |'
  id: totrans-1061
  prefs: []
  type: TYPE_TB
  zh: '| B^+ | P1^+ | P2^+ | P2^– | P1^– | B^– |  |  |'
- en: where
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   + denotes the pickup points of passengers’ requests and the vehicles’ sources.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: •   + 表示乘客请求的接车点和车辆的起点。
- en: •   – denotes the delivery points of passengers’ requests and the vehicles’
    destinations
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: •   – 表示乘客请求的交货点和车辆的终点。
- en: 'This solution can be read as follows:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案可以读作如下：
- en: •   Vehicle A source point → passenger 3 pickup → passenger 4 pickup → passenger
    3 drop-off → passenger 5 pickup → passenger 4 drop-off → passenger 5 drop-off
    → vehicle A destination.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: •   车辆A的起点 → 乘客3接车 → 乘客4接车 → 乘客3下车 → 乘客5接车 → 乘客4下车 → 乘客5下车 → 车辆A的终点。
- en: •   Vehicle B source point → passenger 1 pickup → passenger 1 pickup → passenger
    2 drop-off → passenger 2 drop-off → vehicle B destination.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: •   车辆B的起点 → 乘客1接车 → 乘客1接车 → 乘客2下车 → 乘客2下车 → 车辆B的终点。
- en: 'These two schedules can be also concatenated as follows:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个时间表也可以按以下方式连接：
- en: '| A^+ | P3^+ | P4^+ | P3^- | P5^+ | P4^- | P5^- | A^- | B^+ | P1^+ | P2^+ |
    P2^- | P1^- | B^- |'
  id: totrans-1069
  prefs: []
  type: TYPE_TB
  zh: '| A^+ | P3^+ | P4^+ | P3^- | P5^+ | P4^- | P5^- | A^- | B^+ | P1^+ | P2^+ |
    P2^- | P1^- | B^- |'
- en: 'We use the objective function to evaluate this solution as follows:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用目标函数如下评估这个解决方案：
- en: '![](../Images/APPC_F32_Khamis-EQ32.png)'
  id: totrans-1071
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F32_Khamis-EQ32.png)'
- en: For a more comprehensive discussion of the ride-matching problem with time windows
    (RMPTW) and an extended version of this simplified problem, see Herbawi and Weber’s
    article “A genetic and insertion heuristic algorithm for solving the dynamic ridematching
    problem with time windows” [9].
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 关于具有时间窗口的拼车问题（RMPTW）的更全面讨论以及该简化问题的扩展版本，请参阅 Herbawi 和 Weber 的文章“用于解决具有时间窗口的动态拼车问题的遗传和插入启发式算法”
    [9]。
- en: '4.   Binary PSO (BPSO) is used to handle this problem. A binary string is used
    to describe the attractions to be visited. For example, [0 0 1 0 1 0 0 0 0] means
    visit attractions 3 and 5\. The velocity is calculated using the following equation:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   二进制粒子群优化（BPSO）用于处理此问题。使用二进制字符串来描述要访问的吸引子。例如，[0 0 1 0 1 0 0 0 0] 表示访问吸引子
    3 和 5。速度的计算使用以下公式：
- en: '![](../Images/APPC_F32_Khamis-EQ33.png)'
  id: totrans-1074
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F32_Khamis-EQ33.png)'
- en: where
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *i* is the particle number.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: •   *i* 是粒子编号。
- en: •   *d* is the dimension or the attraction.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: •   *d* 是维度或吸引子。
- en: •   *v[k]^(id)* is the velocity at iteration *k* for particle *i* and dimension
    *d*.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: •   *v[k]^(id)* 是第 *k* 次迭代中粒子 *i* 和维度 *d* 的速度。
- en: •   *pbest[k]^(id)* is the personal best at iteration *t* for particle *i* and
    dimension *d*.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: •   *pbest[k]^(id)* 是第 *t* 次迭代中粒子 *i* 和维度 *d* 的个人最佳值。
- en: •   *gbest[k]^d* is the global best at iteration *k* for dimension *d*.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: •   *gbest[k]^d* 是第 *k* 次迭代中维度 *d* 的全局最优值。
- en: •   *x[k]^(id)* is the current position at iteration *k* for particle *i* and
    dimension *d*.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: •   *x[k]^(id)* 是第 *k* 次迭代中粒子 *i* 和维度 *d* 的当前位置。
- en: •   *ϕ*[1], *ϕ*[2] are uniformly generated random numbers between 0 and 2.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: •   *ϕ*[1], *ϕ*[2] 是在 0 和 2 之间均匀生成的随机数。
- en: 'Once the velocity vector is updated, the sigmoid value of each of the velocities
    is updated as follows:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 更新速度向量后，每个速度的 sigmoid 值更新如下：
- en: '![](../Images/APPC_F32_Khamis-EQ34.png)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F32_Khamis-EQ34.png)'
- en: 'A new position with the sigmoid value of the velocity is created. Next the
    particle position is updated as follows:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 使用速度的 sigmoid 值创建一个新的位置。接下来，粒子位置更新如下：
- en: '![](../Images/APPC_F32_Khamis-EQ35.png)'
  id: totrans-1086
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F32_Khamis-EQ35.png)'
- en: where
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *r* is a uniformly generated random number between 0 and 1.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: •   *r* 是在 0 和 1 之间均匀生成的随机数。
- en: •   *sig*(*v[k]*[+1]*^(id)*) is the sigmoid value of the velocity at *v[k]*[+1]*^(id)*
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: •   *sig*(*v[k]*[+1]*^(id)*) 是速度 *v[k]*[+1]*^(id)* 的 sigmoid 值
- en: Table C.7 Initialization
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 表 C.7 初始化
- en: '|  | *ϕ*[1] | *ϕ*[2] | *v*[01] | *v*[02] | *v*[03] | *v*[04] | *v*[05] | *v*[06]
    | *v*[07] | *v*[08] | *v*[09] |'
  id: totrans-1091
  prefs: []
  type: TYPE_TB
  zh: '|  | *ϕ*[1] | *ϕ*[2] | *v*[01] | *v*[02] | *v*[03] | *v*[04] | *v*[05] | *v*[06]
    | *v*[07] | *v*[08] | *v*[09] |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1092
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1093
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| *x*[2] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1094
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| *x*[3] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1095
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| *x*[4] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1096
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
- en: Let *p[i]* be the current binary value for the position of attraction *i* for
    a particle as shown in table C.8.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 令 *p[i]* 为粒子在表 C.8 中所示的吸引子 *i* 的当前位置的二进制值。
- en: Table C.8 Binary value for the positions of the 9 attractions
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 表 C.8 9 个吸引子的位置二进制值
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] |'
  id: totrans-1099
  prefs: []
  type: TYPE_TB
  zh: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1101
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |'
  id: totrans-1102
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
  id: totrans-1103
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |'
  id: totrans-1104
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |'
- en: 'Table C.9 Initialization: Fitness evaluation'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 表 C.9 初始化：适应度评估
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] | Total commute time | Total places visited | Average rating | Total
    duration | *f*(*x[i]*) |'
  id: totrans-1106
  prefs: []
  type: TYPE_TB
  zh: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] | 总通勤时间 | 总访问地点 | 平均评分 | 总持续时间 | *f*(*x[i]*) |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
  id: totrans-1107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 34 | 2 | 2.000 | 180 | 0.700
    |'
  id: totrans-1108
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 34 | 2 | 2.000 | 180 | 0.700
    |'
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 19 | 2 | 5.000 | 240 | 2.405
    |'
  id: totrans-1109
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 19 | 2 | 5.000 | 240 | 2.405
    |'
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 76 | 2 | 2.500 | 180 | 0.809
    |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 76 | 2 | 2.500 | 180 | 0.809
    |'
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 30 | 2 | 3.000 | 180 | 1.059
    |'
  id: totrans-1111
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 30 | 2 | 3.000 | 180 | 1.059
    |'
- en: Table C.10 Particle’s current personal best at initialization
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.10 粒子初始化时的当前个人最佳
- en: '|  | pbest[01] | pbest [02] | pbest [03] | pbest [04] | pbest [05] | pbest
    [06] | pbest [07] | pbest [08] | pbest [09] | pbestVal |'
  id: totrans-1113
  prefs: []
  type: TYPE_TB
  zh: '|  | pbest[01] | pbest [02] | pbest [03] | pbest [04] | pbest [05] | pbest
    [06] | pbest [07] | pbest [08] | pbest [09] | pbestVal |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0.700 |'
  id: totrans-1115
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0.700 |'
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 2.405 |'
  id: totrans-1116
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 2.405 |'
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0.809 |'
  id: totrans-1117
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0.809 |'
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1.059 |'
  id: totrans-1118
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1.059 |'
- en: 'Table C.11 Iteration 1: Velocity update'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.11 迭代1：速度更新
- en: '|  | *ϕ*[1] | *ϕ*[2] | *v*[11] | *v*[12] | *v*[13] | *v*[14] | *v*[15] | *v*[16]
    | *v*[17] | *v*[18] | *v*[19] |'
  id: totrans-1120
  prefs: []
  type: TYPE_TB
  zh: '|  | *ϕ*[1] | *ϕ*[2] | *v*[11] | *v*[12] | *v*[13] | *v*[14] | *v*[15] | *v*[16]
    | *v*[17] | *v*[18] | *v*[19] |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| *x*[1] | 0.958 | 0.830 | -0.830 | -0.830 | 0.830 | 0.000 | 0.000 | 0.000
    | 0.000 | 0.830 | 0.000 |'
  id: totrans-1122
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | 0.958 | 0.830 | -0.830 | -0.830 | 0.830 | 0.000 | 0.000 | 0.000
    | 0.000 | 0.830 | 0.000 |'
- en: '| *x*[2] | 1.347 | 1.517 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 |
    0.000 | 0.000 | 0.000 |'
  id: totrans-1123
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] | 1.347 | 1.517 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 |
    0.000 | 0.000 | 0.000 |'
- en: '| *x*[3] | 1.320 | 1.649 | 0.000 | -1.649 | 1.649 | 0.000 | -1.649 | 0.000
    | 0.000 | 1.649 | 0.000 |'
  id: totrans-1124
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] | 1.320 | 1.649 | 0.000 | -1.649 | 1.649 | 0.000 | -1.649 | 0.000
    | 0.000 | 1.649 | 0.000 |'
- en: '| *x*[4] | 0.757 | 0.678 | -0.678 | 0.000 | 0.678 | 0.000 | 0.000 | 0.000 |
    -0.678 | 0.678 | 0.000 |'
  id: totrans-1125
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] | 0.757 | 0.678 | -0.678 | 0.000 | 0.678 | 0.000 | 0.000 | 0.000 |
    -0.678 | 0.678 | 0.000 |'
- en: Table C.12 Updated sigmoid velocity values of the particle after iteration 1
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.12 迭代1后粒子的更新sigmoid速度值
- en: '|  | sig(*v*[11]) | sig(*v*[12]) | sig(*v*[13]) | sig(*v*[14]) | sig(*v*[15])
    | sig(*v*[16]) | sig(*v*[17]) | sig(*v*[18]) | sig(*v*[19]) |'
  id: totrans-1127
  prefs: []
  type: TYPE_TB
  zh: '|  | sig(*v*[11]) | sig(*v*[12]) | sig(*v*[13]) | sig(*v*[14]) | sig(*v*[15])
    | sig(*v*[16]) | sig(*v*[17]) | sig(*v*[18]) | sig(*v*[19]) |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| *x*[1] | 0.304 | 0.304 | 0.696 | 0.500 | 0.500 | 0.500 | 0.500 | 0.696 |
    0.500 |'
  id: totrans-1129
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | 0.304 | 0.304 | 0.696 | 0.500 | 0.500 | 0.500 | 0.500 | 0.696 |
    0.500 |'
- en: '| *x*[2] | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 |
    0.500 |'
  id: totrans-1130
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 |
    0.500 |'
- en: '| *x*[3] | 0.500 | 0.161 | 0.839 | 0.500 | 0.161 | 0.500 | 0.500 | 0.839 |
    0.500 |'
  id: totrans-1131
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] | 0.500 | 0.161 | 0.839 | 0.500 | 0.161 | 0.500 | 0.500 | 0.839 |
    0.500 |'
- en: '| *x*[4] | 0.337 | 0.500 | 0.663 | 0.500 | 0.500 | 0.500 | 0.337 | 0.663 |
    0.500 |'
  id: totrans-1132
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] | 0.337 | 0.500 | 0.663 | 0.500 | 0.500 | 0.500 | 0.337 | 0.663 |
    0.500 |'
- en: Table C.13 Uniformly generated random numbers for deciding particle updated
    after iteration 1
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.13 迭代1后决定粒子更新的均匀生成随机数
- en: '|  | *r*[11] | *r*[12] | *r*[13] | *r*[14] | *r*[15] | *r*[16] | *r*[17] |
    *r*[18] | *r*[19] |'
  id: totrans-1134
  prefs: []
  type: TYPE_TB
  zh: '|  | *r*[11] | *r*[12] | *r*[13] | *r*[14] | *r*[15] | *r*[16] | *r*[17] |
    *r*[18] | *r*[19] |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 0.477 | 0.724 | 0.875 | 0.654 | 0.088 | 0.089 | 0.853 | 0.925 | 0.528
    |'
  id: totrans-1136
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0.477 | 0.724 | 0.875 | 0.654 | 0.088 | 0.089 | 0.853 | 0.925 | 0.528
    |'
- en: '| 2 | 0.673 | 0.530 | 0.438 | 0.785 | 0.218 | 0.763 | 0.838 | 0.749 | 0.590
    |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.673 | 0.530 | 0.438 | 0.785 | 0.218 | 0.763 | 0.838 | 0.749 | 0.590
    |'
- en: '| 3 | 0.534 | 0.086 | 0.301 | 0.763 | 0.653 | 0.754 | 0.809 | 0.974 | 0.763
    |'
  id: totrans-1138
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0.534 | 0.086 | 0.301 | 0.763 | 0.653 | 0.754 | 0.809 | 0.974 | 0.763
    |'
- en: '| 4 | 0.218 | 0.697 | 0.875 | 0.854 | 0.116 | 0.941 | 0.678 | 0.742 | 0.965
    |'
  id: totrans-1139
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0.218 | 0.697 | 0.875 | 0.854 | 0.116 | 0.941 | 0.678 | 0.742 | 0.965
    |'
- en: 'Iteration 1: Global best is 2.405, and the best particle is *x*[2] = [0 0 1
    0 0 0 0 0 0].'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代1：全局最优值为2.405，最佳粒子为*x*[2] = [0 0 1 0 0 0 0 0 0]。
- en: 'Iteration 2: Velocity update'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代2：速度更新
- en: Table C.14 Updated particle state and fitness function after iteration 2
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.14 迭代2后的粒子状态和适应度函数更新
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] | Total commute time | Total places visited | Average rating | Total
    duration | *f*(*x[i]*) |'
  id: totrans-1143
  prefs: []
  type: TYPE_TB
  zh: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] | 总通勤时间 | 总访问地点 | 平均评分 | 总持续时间 | *f*(*x[i]*) |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
  id: totrans-1144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- |'
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 64 | 2 | 3.500 | 180 | 1.158
    |'
  id: totrans-1145
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 64 | 2 | 3.500 | 180 | 1.158
    |'
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 37 | 2 | 5.000 | 300 | 2.901
    |'
  id: totrans-1146
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 37 | 2 | 5.000 | 300 | 2.901
    |'
- en: '| *x*[3] | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 70 | 2 | 2.500 | 240 | 1.091
    |'
  id: totrans-1147
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 70 | 2 | 2.500 | 240 | 1.091
    |'
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 24 | 2 | 4.500 | 240 | 2.143
    |'
  id: totrans-1148
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 24 | 2 | 4.500 | 240 | 2.143
    |'
- en: Table C.15 Updated personal best of the particle after iteration 2
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 表 C.15 迭代 2 后粒子的更新个人最佳
- en: '|  | pbest[11] | pbest [12] | pbest [13] | pbest [14] | pbest [15] | pbest
    [16] | pbest [17] | pbest [18] | pbest [19] | pbestVal |'
  id: totrans-1150
  prefs: []
  type: TYPE_TB
  zh: '|  | pbest[11] | pbest [12] | pbest [13] | pbest [14] | pbest [15] | pbest
    [16] | pbest [17] | pbest [18] | pbest [19] | pbestVal |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1.158 |'
  id: totrans-1152
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1.158 |'
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 2.901 |'
  id: totrans-1153
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 2.901 |'
- en: '| *x*[3] | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1.091 |'
  id: totrans-1154
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1.091 |'
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 2.143 |'
  id: totrans-1155
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 2.143 |'
- en: The global best is 2.901, and the best particle is *x*[2] = [0 0 1 0 1 0 0 0
    0]. Repeat until the stopping criteria is fulfilled.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 全局最佳值为 2.901，最佳粒子为 *x*[2] = [0 0 1 0 1 0 0 0 0]。重复执行，直到满足停止条件。
- en: 5.   The next listing shows the steps for solving the trilateration problem
    using PSO.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   下一个列表显示了使用 PSO 解决三角定位问题的步骤。
- en: Listing C.13 Solving the trilateration problem using PSO
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.13 使用 PSO 解决三角定位问题
- en: '[PRE28]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① Define the objective function.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义目标函数。
- en: ② Set up the PSO algorithm.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置 PSO 算法。
- en: ③ Initialize GlobalBestPSO, and minimize the objective function.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 初始化 GlobalBestPSO，并最小化目标函数。
- en: ④ Print the results.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 打印结果。
- en: 6.   The next listing shows the steps for solving the coffee shop problem.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   下一个列表显示了使用 PSO 解决咖啡店问题的步骤。
- en: Listing C.14 Solving the coffee shop problem using PSO
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.14 使用 PSO 解决咖啡店问题
- en: '[PRE29]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① Import the required libraries.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入所需的库。
- en: ② Define the fitness function.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义适应度函数。
- en: ③ Set the number of particles and iterations.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置粒子数量和迭代次数。
- en: ④ Set the lower and upper bounds of the variables.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置变量的上下限。
- en: ⑤ Set the optimizer options.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置优化器选项。
- en: ⑥ Initialize the optimizer.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 初始化优化器。
- en: ⑦ Perform the optimization.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 执行优化。
- en: 7.   The next listing shows the steps for solving the doctor scheduling problem.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 7.   下一个列表显示了使用 PSO 解决医生排班问题的步骤。
- en: Listing C.15 Solving the doctor scheduling problem using PSO
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.15 使用 PSO 解决医生排班问题
- en: '[PRE30]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① Set full-time hourly rates, overtime rates, and part-time doctor rates.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置全职小时费率、加班费率和兼职医生费率。
- en: ② Define the three decision variables.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义三个决策变量。
- en: ③ Define the total cost as an objective function.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将总成本定义为目标函数。
- en: ④ Define the constraints and add them as a penalty in the cost function.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义约束并将其作为惩罚添加到成本函数中。
- en: ⑤ Initialize the bounds.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 初始化边界。
- en: ⑥ Set the options for PSO.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 设置 PSO 的选项。
- en: ⑦ Create an instance of PSO.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建 PSO 的实例。
- en: ⑧ Perform the optimization.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 执行优化。
- en: ⑨ Extract optimal values of the decision variables x1, x2, and x3.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 提取决策变量 x1、x2 和 x3 的最优值。
- en: The complete version of listing C.15, available in the book’s GitHub repo, contains
    a function to print and visualize the results. Figure C.33 shows the hours worked
    for each doctor.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.15 的完整版本可在本书的 GitHub 仓库中找到，其中包含一个用于打印和可视化结果的函数。图 C.33 显示了每位医生的工作小时数。
- en: '![](../Images/APPC_F33_Khamis.png)'
  id: totrans-1187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F33_Khamis.png)'
- en: Figure C.33 Hours worked by each doctor
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.33 每位医生的工作小时数
- en: 8.   The next listing shows the steps for solving the supply chain optimization
    problem using PSO. We start by importing the required libraries.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 8.   下一个列表显示了使用 PSO 解决供应链优化问题的步骤。我们首先导入所需的库。
- en: Listing C.16 Solving the supply chain optimization problem using PSO
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.16 使用 PSO 解决供应链优化问题
- en: '[PRE31]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then define the problem data as follows:'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着定义如下问题数据：
- en: '[PRE32]'
  id: totrans-1193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① Schools with microscopes available
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: ① 可提供显微镜的学校
- en: ② Schools with microscopes requested
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: ② 请求显微镜的学校
- en: ③ Number of microscopes available at each school
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 每所学校可用的显微镜数量
- en: ④ Number of microscopes requested at each school
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 每所学校请求的显微镜数量
- en: ⑤ Number of variables
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 变量数量
- en: 'As a continuation of listing C.16, the following function generates random
    locations around a center point to represent the supply and demand schools in
    the selected city (using Toronto as an example). We calculate the distances between
    the schools using geopy:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为C.16列表的延续，以下函数生成中心点周围的随机位置，以表示所选城市中的供应和需求学校（以多伦多为例）。我们使用geopy计算学校之间的距离：
- en: '[PRE33]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ① For reproducibility
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为了可重复性
- en: ② Set the center of the map.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置地图的中心。
- en: ③ Generate random GPS coordinates (lat, long) for the supply schools.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为供应学校生成随机的GPS坐标（纬度，经度）。
- en: ④ Generate random GPS coordinates (lat, long) for the demand schools.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 为需求学校生成随机的GPS坐标（纬度，经度）。
- en: ⑤ Calculate geodesic distances between the schools in km.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 计算学校之间的测地线距离（公里）。
- en: 'The following class defines the transportation problem in a format compatible
    with pymoo. It defines the decision variables, constraints, and the objective
    function:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类定义了与pymoo兼容的运输问题。它定义了决策变量、约束条件和目标函数：
- en: '[PRE34]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can create a problem object and a PSO solver as follows:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个问题对象和一个PSO求解器，如下所示：
- en: '[PRE35]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following line is used to run 150 iterations of the PSO solver:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行用于运行150次迭代PSO求解器：
- en: '[PRE36]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following code snippet is used to print the solution obtained by the PSO
    solver:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段用于打印PSO求解器获得的解决方案：
- en: '[PRE37]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① Extract the solution.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: ① 提取解决方案。
- en: ② Number of supply points
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: ② 供应点的数量
- en: ③ Number of demand points
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 需求点的数量
- en: ④ Print each supply point.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 打印每个供应点。
- en: ⑤ Print each demand point.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 打印每个需求点。
- en: ⑥ Print the shipping cost.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印运输成本。
- en: 'Given the randomness included in the implementation, the code will produce
    output that is something like the following:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到实现中包含的随机性，代码将产生类似以下输出的结果：
- en: '[PRE38]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following code snippet can be used to visualize the solution of a spatial
    map using folium:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段可用于使用folium可视化空间地图的解决方案：
- en: '[PRE39]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Normalize function
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: ① 标准化函数
- en: ② Normalize soln array
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: ② 标准化解数组
- en: ③ Define a color list.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义颜色列表。
- en: ④ Create a map centered at downtown Toronto.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建以多伦多市中心为中心的地图。
- en: ⑤ Add markers for supply schools.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 为供应学校添加标记。
- en: ⑥ Add markers for demand schools.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 为需求学校添加标记。
- en: ⑦ Add lines (edges) between supply and demand schools.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在供应学校和需求学校之间添加线条（边）。
- en: ⑧ Show the map.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 显示地图。
- en: Figure C.34 shows a solution that may be produced by PSO.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.34显示了PSO可能产生的解决方案。
- en: '![](../Images/APPC_F34_Khamis.png)'
  id: totrans-1233
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F34_Khamis.png)'
- en: Figure C.34 School microscopes supply and demand
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.34 学校显微镜供应和需求
- en: The complete version of listing C.16, available in the book’s [GitHub repo](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20C/Chapter%209/Listing%20C.16_Supply_demand.ipynb),
    also shows how to solve this problem using the genetic algorithm.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 书中C.16列表的完整版本，可在GitHub仓库[GitHub repo](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20C/Chapter%209/Listing%20C.16_Supply_demand.ipynb)中找到，也展示了如何使用遗传算法解决这个问题。
- en: 'C.9 Chapter 10: Other swarm intelligence algorithms to explore'
  id: totrans-1236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.9 第10章：其他群智能算法探索
- en: C.9.1 Exercises
  id: totrans-1237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.9.1 练习
- en: 1.   Match the terms and descriptions shown in table C.16.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   匹配表C.16中显示的术语和描述。
- en: Table C.16
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.16
- en: '| Terms | Descriptions |'
  id: totrans-1240
  prefs: []
  type: TYPE_TB
  zh: '| 术语 | 描述 |'
- en: '| --- | --- |'
  id: totrans-1241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1\. Ant colony system (ACS) | a. Bees that search for new food sources after
    exhausting their current ones |'
  id: totrans-1242
  prefs: []
  type: TYPE_TB
  zh: '| 1. 蚁群系统（ACS） | a. 在耗尽当前食物源后寻找新食物源的蜜蜂 |'
- en: '| 2\. Stigmergy | b. Positive feedback about food path causes that path to
    be followed by more and more ants |'
  id: totrans-1243
  prefs: []
  type: TYPE_TB
  zh: '| 2. 蚁群算法 | b. 食物路径的正反馈导致越来越多的蚂蚁跟随该路径 |'
- en: '| 3\. Scout bees | c. A pheromone update method that doesn’t take the desirability
    of the solution into account |'
  id: totrans-1244
  prefs: []
  type: TYPE_TB
  zh: '| 3. 巡视蜂 | c. 一种不考虑解决方案可行性的信息素更新方法 |'
- en: '| 4\. Max-min ant system (MMAS) | d. The maximum number of unsuccessful attempts
    made by a scout bee to find a new food source |'
  id: totrans-1245
  prefs: []
  type: TYPE_TB
  zh: '| 4. 最大-最小蚁群系统（MMAS） | d. 巡视蜂尝试寻找新食物源的最大失败次数 |'
- en: '| 5\. Autocatalytic behavior | e. Bees that probabilistically choose food sources
    depending on the fitness of the solutions found by the employed bees |'
  id: totrans-1246
  prefs: []
  type: TYPE_TB
  zh: '| 5. 自催化行为 | e. 根据工蜂找到的解决方案的适应性概率选择食物源的蜜蜂 |'
- en: '| 6\. Ant density model | f. Indirect communication among social insects through
    environmental modifications that serve as external memory |'
  id: totrans-1247
  prefs: []
  type: TYPE_TB
  zh: '| 6. 蚁群密度模型 | f. 社会昆虫通过环境修改进行间接交流，这些修改作为外部记忆 |'
- en: '| 7\. Onlooker bees | g. A pheromone update method that uses local information
    to update the pheromone concentrations |'
  id: totrans-1248
  prefs: []
  type: TYPE_TB
  zh: '| 7\. 观察者蜜蜂 | g. 一种使用局部信息更新信息素浓度的信息素更新方法 |'
- en: '| 8\. Ant-cycle | h. An ACO variation that uses an elitist strategy called
    pseudo-random proportional action rule |'
  id: totrans-1249
  prefs: []
  type: TYPE_TB
  zh: '| 8\. 蚂蚁循环 | h. 一种使用被称为伪随机比例行动规则的精英策略的蚁群优化（ACO）变体 |'
- en: '| 9\. Ant System (AS) | i. An ACO variant that adds a memory capability by
    including a tabu list |'
  id: totrans-1250
  prefs: []
  type: TYPE_TB
  zh: '| 9\. 蚂蚁系统（AS） | i. 一种通过包括禁忌列表来增加记忆能力的蚁群优化（ACO）变体 |'
- en: '| 10\. Trial limit | k. An ACO variation that overcomes stagnation |'
  id: totrans-1251
  prefs: []
  type: TYPE_TB
  zh: '| 10\. 试验限制 | k. 一种克服停滞的蚁群优化（ACO）变体 |'
- en: 2.   Write Python code to find the shortest path between a source point and
    a destination point using the ant colony optimization algorithm. Assume that you’re
    currently standing at the King Edward VII equestrian statue in the city of Toronto
    with GPS coordinates (43.664527, –79.392442). Imagine you’re a student at the
    University of Toronto, and you’re already running late for your Optimization Algorithms
    lecture at the Bahen Centre for Information Technology with GPS coordinates (43.659659,
    –79.397669). Visualize the obtained route on a map centered on King’s College
    Circle with GPS coordinates (43.661667, –79.395) so you can reach your destination.
    Feel free to use the helping functions available in the optalgotools package,
    such as `Node`, `cost`, and `draw_route`. Use the code to experiment with different
    search spaces (different areas of interest, different origins, and destinations)
    and different algorithm parameter settings.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   编写Python代码，使用蚁群优化算法找到源点与目的地点之间的最短路径。假设你现在站在多伦多市的国王爱德华七世骑马雕像处，GPS坐标为（43.664527,
    –79.392442）。想象你是一名多伦多大学的学生，你正在赶往位于信息技术中心（Bahen Centre for Information Technology）的优化算法讲座，其GPS坐标为（43.659659,
    –79.397669）。在以国王学院圆环（GPS坐标为43.661667, –79.395）为中心的地图上可视化获得的路线，以便你能到达目的地。请随意使用optalgotools包中可用的帮助函数，例如`Node`、`cost`和`draw_route`。使用此代码来实验不同的搜索空间（不同的兴趣区域、不同的起点和目的地）以及不同的算法参数设置。
- en: '3.   Reverse osmosis (RO) is a very effective and important process for desalination
    and water waste reclamation. Assume that you need to maximize the RO high pressure
    pump power. This power depends of a number of parameters according to the following
    equation:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   反渗透（RO）是一种非常有效且重要的脱盐和废水回收过程。假设你需要最大化反渗透高压泵的功率。这个功率取决于以下方程式中的多个参数：
- en: '![](../Images/APPC_F34_Khamis-EQ36.png)'
  id: totrans-1254
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F34_Khamis-EQ36.png)'
- en: where
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: •   *HP* is the RO high pressure pump power in kW.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: •   *HP* 是反渗透高压泵的功率，单位为kW。
- en: •   *M[d]* is the RO productivity in m3/d and is in the range of 41.67 < M*[d]*
    <416.67 m³/d.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: •   *M[d]* 是反渗透的日产量，单位为m³/d，其范围是 41.67 < M*[d]* <416.67 m³/d。
- en: •   *N[v]* is number of pressure vessels and is ranged as 1 < N*[v]* < 200.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: •   *N[v]* 是压力容器的数量，其范围是 1 < N*[v]* < 200。
- en: •   ∆*π* is the net osmotic pressure across the membrane and is in the range
    1400 < ∆*π* < 2600 kPa.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: •   ∆*π* 是跨膜的净渗透压，其范围是 1400 < ∆*π* < 2600 kPa。
- en: •   *RR* is the recovery ratio and is ranged as 1 < RR < 50%.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: •   *RR* 是回收率，其范围是 1 < RR < 50%。
- en: •   *η* is the efficiency of the high pressure pump and is in the range of 0.70
    < *η* < 0.85.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: •   *η* 是高压泵的效率，其范围是 0.70 < *η* < 0.85。
- en: •   *ρ* is the density of water.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: •   *ρ* 是水的密度。
- en: Write Python code to find the optimal values of the decision variables (*Md,
    Nv*, ∆*π, RR, η*, and *ρ*) to maximize HP using the ant colony optimization (ACO)
    algorithm. Solve the same problem using the `optimize` solver in SciPy.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Python代码，使用蚁群优化（ACO）算法找到决策变量（*Md, Nv*, ∆*π, RR, η*, 和 *ρ*）的最优值以最大化HP。使用SciPy中的`optimize`求解器解决相同的问题。
- en: 4.   Solve the supply and demand problem introduced in exercise 8 of chapter
    9 using the ant colony optimization (ACO) algorithm. Use mixed integer distributed
    ant colony optimization (MIDACO) to solve this problem. MIDACO ([www.midaco-solver.com](http://www.midaco-solver.com))
    is a numerical high-performance software for solving single- and multi-objective
    optimization problems. It is based on ACO with an extension for mixed integer
    search domains.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   使用蚁群优化（ACO）算法解决第9章第8题中引入的供需问题。使用混合整数分布式蚁群优化（MIDACO）来解决这个问题。MIDACO ([www.midaco-solver.com](http://www.midaco-solver.com))
    是一种用于解决单目标和多目标优化问题的数值高性能软件。它基于蚁群优化，并扩展了混合整数搜索域。
- en: 'To install MIDACO, follow these steps:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装MIDACO，请按照以下步骤操作：
- en: 1\.  Download MIDACO Python Gateway ([midaco.py](http://www.midaco-solver.com/index.php/download/python)),
    and remove the .txt extension.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 下载MIDACO Python网关([midaco.py](http://www.midaco-solver.com/index.php/download/python))，并移除.txt扩展名。
- en: 2\.  Download the appropriate library file ([midacopy.dll](http://www.midaco-solver.com/index.php/download/python)
    or midacopy.so).
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 下载适当的库文件([midacopy.dll](http://www.midaco-solver.com/index.php/download/python)或midacopy.so)。
- en: 3\.  Store all the files in the same folder on your PC.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 在您的PC上的同一文件夹中存储所有文件。
- en: 4\.  Import `midaco` into your Jupyter notebook.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 将`midaco`导入您的Jupyter笔记本。
- en: MIDACO is licensed software with a limited free license that enables optimization
    with up to four variables (two supply schools and two demand schools).
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: MIDACO是许可软件，具有有限的免费许可证，允许使用最多四个变量（两个供应学校和两个需求学校）进行优化。
- en: 'Assume the following reduced problem data:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下简化问题数据：
- en: '[PRE40]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① Schools with microscopes available
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: ① 有显微镜的学校
- en: ② Schools with microscopes requested
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: ② 请求显微镜的学校
- en: ③ Number of microscopes available at each school
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 每所学校可用的显微镜数量
- en: ④ Number of microscopes requested at each school
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 每所学校请求的显微镜数量
- en: Write Python code to solve this problem using MIDACO. Visualize the solution
    on a geospatial map. For a larger number of schools, you can obtain an unlimited
    license or request a free academic trial of the unlimited version that can support
    up to 100,000 variables.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MIDACO编写Python代码来解决这个问题，并在地理空间地图上可视化解决方案。对于更多学校，您可以获得无限许可证或请求免费学术试用版，该版本可以支持多达100,000个变量。
- en: C.9.2 Solutions
  id: totrans-1278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.9.2 解决方案
- en: 1.   Answers
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 答案
- en: 1-h, 2-f, 3-a, 4-k, 5-b, 6-c, 7-e, 8-g, 9-i, 10-d
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 1-h，2-f，3-a，4-k，5-b，6-c，7-e，8-g，9-i，10-d
- en: 2.   Listing C.17 shows the steps to find and visualize the shortest path between
    two points of interest in the city of Toronto. The code uses helping functions
    from optalgotools such as Node, cost, and draw_route. We start by defining and
    visualizing the search space as follows.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 列表C.17显示了在多伦多市找到并可视化两个感兴趣点之间最短路径的步骤。代码使用了optalgotools中的帮助函数，如Node、cost和draw_route。我们首先定义并可视化搜索空间如下。
- en: Listing C.17 Solving a routing problem using ACO
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.17 使用ACO解决路由问题
- en: '[PRE41]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Set King’s College Circle, Toronto, ON as the center of the map.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将多伦多国王学院圆环，安大略省多伦多设为地图的中心。
- en: ② Create a graph.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个图。
- en: ③ Set the King Edward VII equestrian statue as the origin.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将爱德华七世骑马雕像设为原点。
- en: ④ Set the Bahen Centre for Information Technology at University of Toronto as
    the destination.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将多伦多大学的信息技术中心设为目标。
- en: ⑤ Get the osmid of the nearest nodes to the origin and destination points.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 获取起点和目标点最近节点的osmid。
- en: ⑥ Create the origin and destination nodes.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 创建起点和终点节点。
- en: ⑦ Mark both the source and destination nodes.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 标记源节点和目标节点。
- en: ⑧ Visualize the search space.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 可视化搜索空间。
- en: 'AS a continuation of listing C.17, we can initialize the parameters of the
    ACO algorithm as follows:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表C.17的延续，我们可以如下初始化ACO算法的参数：
- en: '[PRE42]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ① Set alpha, a parameter to control the influence of pheromones.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置alpha，一个控制信息素影响的参数。
- en: ② Set beta, a parameter to control the influence of desirability of the city
    transition.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置beta，一个控制城市转换吸引力的参数。
- en: ③ Set the number of iterations.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置迭代次数。
- en: ④ Randomize the pheromones.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 随机化信息素。
- en: ⑤ Randomize the pheromones.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 随机化信息素。
- en: ⑥ A function to calculate pheromone levels
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 一个计算信息素水平的函数
- en: 'We now implement the ACO procedure as follows:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在如下实现ACO过程：
- en: '[PRE43]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① Place the ant at the origin node.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将蚂蚁放置在原点节点。
- en: ② Probabilistically choose a child to explore.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: ② 以概率选择一个子节点进行探索。
- en: ③ Add all the non-explored children in case we need to explore them later.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 添加所有未探索的子节点，以防我们以后需要探索它们。
- en: ④ Set the chosen child to be the next node to explore.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将选定的子节点设为下一个要探索的节点。
- en: ⑤ Update the pheromones.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 更新信息素。
- en: ⑥ If the route is newly discovered, add it to the list.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果路线是新发现的，则将其添加到列表中。
- en: 'You can now print the best route and its cost and visualize the obtained route
    as follows:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以打印最佳路线及其成本，并如下可视化获得的路线：
- en: '[PRE44]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Figure C.35 shows the optimal route generated by ACO.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.35显示了ACO生成的最优路线。
- en: '![](../Images/APPC_F35_Khamis.png)'
  id: totrans-1311
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F35_Khamis.png)'
- en: Figure C.35 Optimal route generated by ACO
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.35 ACO生成的最优路线
- en: 3.   The next listing shows the steps for solving the reverse osmosis (RO) high
    pressure pump power maximization problem using ACO.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 下一个列表显示了使用ACO解决反渗透（RO）高压泵功率最大化问题的步骤。
- en: Listing C.18 Solving the RO high pressure pump power maximization problem with
    ACO
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.18 使用ACO解决RO高压泵功率最大化问题
- en: '[PRE45]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① Define the range for each decision variable.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义每个决策变量的范围。
- en: ② Density of water in kg/m^3
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: ② 水的密度为kg/m^3
- en: ③ Define the objective function.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义目标函数。
- en: ④ Define the ACO parameters.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义ACO参数。
- en: ⑤ Initialize the pheromone matrix.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 初始化信息素矩阵。
- en: ⑥ Initialize the best solution and its corresponding power.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 初始化最佳解决方案及其对应的功率。
- en: ⑦ Construct solutions for each ant.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 为每只蚂蚁构建解决方案。
- en: ⑧ Calculate the power for the current solution.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 计算当前解决方案的功率。
- en: ⑨ Store the solution and its power.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 存储解决方案及其功率。
- en: ⑩ Update the best solution if necessary.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 如有必要，更新最佳解决方案。
- en: ⑪ Update pheromone trails based on the power of each solution.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 根据每个解决方案的强度更新信息素路径。
- en: ⑫ Print the optimal values of the decision variables and the optimal HP.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 打印决策变量的最优值和最优HP。
- en: 'An example of the generated output is show here:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个生成的输出示例：
- en: '[PRE46]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As a continuation of listing C.18, the following code snippet shows the steps
    for solving this problem using the `optimize` solver in SciPy.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 作为C.18列表的延续，以下代码片段展示了使用SciPy中的`optimize`求解器解决此问题的步骤。
- en: '[PRE47]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ① Import the scipy optimizer.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入scipy优化器。
- en: ② Define the objective function with a negative sign for minimization, as per
    scipy's requirement.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: ② 根据scipy的要求，定义带有负号的优化目标函数。
- en: ③ Set the bounds for the decision variables.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置决策变量的界限。
- en: ④ Set an initial guess.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置初始猜测值。
- en: ⑤ Solve the optimization problem using sequential least squares programming
    (SLSQP).
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用顺序最小二乘编程（SLSQP）解决优化问题。
- en: ⑥ Print the optimal values of the decision variables and the optimal HP.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印决策变量的最优值和最优HP。
- en: 'The generated output is show here:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出如下：
- en: '[PRE48]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can fine-tune the ACO parameters to get results comparable to those of the
    SciPy optimizer.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以微调ACO参数以获得与SciPy优化器相当的结果。
- en: 4.   The next listing shows the steps for solving the supply and demand problem
    using the MIDACO solver. We start by importing the libraries and setting the problem
    data.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 下一个列表展示了使用MIDACO求解器解决供需问题的步骤。我们首先导入库并设置问题数据。
- en: Listing C.19 Solving the supply and demand problem using MIDACO
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.19 使用MIDACO解决供需问题
- en: '[PRE49]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ① Import the MIDACO solver.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入MIDACO求解器。
- en: ② Set the schools with microscopes available.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置有可用显微镜的学校。
- en: ③ Set the schools with microscopes requested.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置需要显微镜的学校。
- en: ④ Set the number of microscopes available at each school.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置每所学校可用的显微镜数量。
- en: ⑤ Set the number of microscopes requested at each school.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置每所学校请求的显微镜数量。
- en: 'As a continuation, we’ll generate random GPS coordinates for the supply and
    demand schools:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 作为延续，我们将为供应和需求学校生成随机的GPS坐标：
- en: '[PRE50]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ① Create a geolocator object.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个地理定位对象。
- en: ② Get the coordinates of Toronto.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取多伦多的坐标。
- en: ③ Function to generate random locations around a center point
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 生成围绕中心点的随机位置的功能。
- en: ④ Set the random seed to ensure reproducibility of random numbers generated.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置随机种子以确保生成的随机数的可重复性。
- en: ⑤ Generate random GPS coordinates (lat, long) for the supply schools.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 为供应学校生成随机的GPS坐标（纬度，经度）。
- en: ⑥ Generate random GPS coordinates (lat, long) for the demand schools.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 为需求学校生成随机的GPS坐标（纬度，经度）。
- en: ⑦ Calculate geodesic distances between the schools in km.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 计算学校之间的测地线距离（公里）。
- en: ⑧ Calculate the cost matrix.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 计算成本矩阵。
- en: The following function defines the main ingredients of the optimization problem,
    including the objective function and the constraints.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数定义了优化问题的主要成分，包括目标函数和约束。
- en: '[PRE51]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ① Initialize the array for objectives F(X).
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化目标函数F(X)的数组。
- en: ② Initialize the array for constraints G(X).
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: ② 初始化约束G(X)的数组。
- en: ③ Objective functions F(X)
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 目标函数F(X)
- en: ④ Candidate solution
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 候选解决方案
- en: ⑤ Inequality constraints G(X) >= 0 must come second in g[me:m-1]
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 在g[me:m-1]中，不等式约束G(X) >= 0必须排在第二位。
- en: ⑥ Return the objective function and constraint evaluation.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 返回目标函数和约束评估。
- en: 'The first step in using MIDACO is to define the problem as follows:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MIDACO的第一步是将问题定义为以下形式：
- en: '[PRE52]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ① Free limited license that supports up to 4 variables.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: ① 免费有限许可证，支持多达4个变量。
- en: ② Initialize the dictionary containing the problem specifications.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: ② 初始化包含问题规范的字典。
- en: ③ Initialize the dictionary containing the MIDACO options.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 初始化包含MIDACO选项的字典。
- en: ④ Handle for problem function name.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 处理问题函数名称。
- en: 'The problem dimensions are defined as follows:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 问题维度定义如下：
- en: '[PRE53]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ① Number of objectives
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: ① 目标数量
- en: ② Number of variables (in total)
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: ② 变量数量（总计）
- en: ③ Number of integer variables (0 <= ni <= n)
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 整数变量数量（0 <= ni <= n）
- en: ④ Number of constraints (in total)
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 约束数量（总计）
- en: ⑤ Number of equality constraints (0 <= me <= m)
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 等式约束数量（0 <= me <= m）
- en: 'The lower and upper bounds `xl` and `xu` are defined as follows:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 下界和上界`xl`和`xu`定义如下：
- en: '[PRE54]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The starting point `x` is set as the lower bound:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点`x`设置为下界：
- en: '[PRE55]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The stopping criteria are defined as follows:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 停止标准定义如下：
- en: '[PRE56]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ① Maximum number of function evaluation
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: ① 最大函数评估次数
- en: ② Maximum time limit in seconds (e.g., 1 day = 60*60*24)
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: ② 最大时间限制（以秒为单位，例如，1天 = 60*60*24）
- en: 'We set the printing options as follows:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置打印选项如下：
- en: '[PRE57]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ① Print-frequency for current best solution
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: ① 打印当前最佳解的打印频率
- en: ② Save screen and solution [0 for no and 1 for yes]
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: ② 保存屏幕和解决方案[0为否，1为是]
- en: 'MIDACO offers the option to evaluate multiple solution candidates in parallel
    (aka co-evaluation or fine-grained parallelization). According to the MIDACO user
    manual, for a parallelization factor of *P* = 10, the potential speed-up is around
    10 times, while for a parallelization factor of *P* = 100, the potential speed
    up is around 70 times. We can set the parallelization factor as follows:'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: MIDACO提供并行评估多个解候选人的选项（也称为协同评估或细粒度并行化）。根据MIDACO用户手册，对于并行化因子*P* = 10，潜在加速约为10倍，而对于并行化因子*P*
    = 100，潜在加速约为70倍。我们可以设置并行化因子如下：
- en: '[PRE58]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '① Serial: 0 or 1, Parallel: 2,3,4,5,6,7,8...'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: ① 序列：0或1，并行：2,3,4,5,6,7,8...
- en: 'We can now run `midaco` to solve the problem:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行`midaco`来解决问题：
- en: '[PRE59]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following code snippet is used to print the solution obtained by the PSO
    solver:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段用于打印PSO求解器获得的解：
- en: '[PRE60]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ① Number of supply points
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: ① 供应点数量
- en: ② Number of demand points
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: ② 需求点数量
- en: ③ Print each supply point.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 打印每个供应点。
- en: ④ Print each demand point.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 打印每个需求点。
- en: ⑤ Print the shipping cost.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 打印运输成本。
- en: 'The code will produce output like the following:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将产生如下输出：
- en: '[PRE61]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following code snippet can be used to visualize the solution of a spatial
    map using folium:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段可用于使用folium可视化空间地图的解决方案：
- en: '[PRE62]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ① Normalize function.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: ① 标准化函数。
- en: ② Normalize solution array.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: ② 标准化解数组。
- en: ③ Define a color list.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义颜色列表。
- en: ④ Create a map centered at downtown Toronto.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建以多伦多市中心为中心的地图。
- en: ⑤ Add markers for supply schools.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 为供应学校添加标记。
- en: ⑥ Add markers for demand schools.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 为需求学校添加标记。
- en: ⑦ Add lines (edges) between supply and demand schools.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在供应和需求学校之间添加线条（边）。
- en: ⑧ Show the map.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 显示地图。
- en: Figure C.36 shows the solution obtained using MIDACO.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.36显示了使用MIDACO获得的解决方案。
- en: '![](../Images/APPC_F36_Khamis.png)'
  id: totrans-1417
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F36_Khamis.png)'
- en: Figure C.36 Supply and demand problem solution obtained by MIDACO
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.36 MIDACO获得的供需问题解决方案
- en: For a higher number of schools, you can obtain an unlimited license or request
    a free academic trial of the unlimited version that can support up to 100,000
    variables.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多学校，您可以获得无限许可证或请求免费的无限制版本学术试用，该版本可以支持多达100,000个变量。
- en: 'C.10 Chapter 11: Supervised and unsupervised learning'
  id: totrans-1420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.10 第11章：监督学习和无监督学习
- en: C.10.1 Exercises
  id: totrans-1421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.10.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 多项选择和真/假：为以下每个问题选择正确答案。
- en: 1.1.   What are the traditional categories of machine learning algorithms?
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1. 机器学习算法的传统类别有哪些？
- en: b.  Supervised, unsupervised, unreinforced
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: b. 监督的，无监督的，非增强的
- en: b.  Supervised, hybrid, reinforcement
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: b. 监督的，混合的，增强的
- en: c.  Supervised, unsupervised, hybrid, reinforcement
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: c. 监督的，无监督的，混合的，增强的
- en: d.  Unsupervised, semi-supervised, hybrid
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: d. 无监督的，半监督的，混合的
- en: 1.2.   The Kohonen map is trained using supervised learning to produce a two-dimensional
    representation of the input space of the training samples.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2. Kohonen图使用监督学习进行训练，以产生训练样本输入空间的二维表示。
- en: a.  True
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b.  False
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: 1.3.   What kind of tasks are common in supervised learning?
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3. 监督学习中常见的任务有哪些？
- en: a.  Clustering and data reduction
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: a. 聚类和数据降维
- en: b.  Classification and regression
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: b. 分类和回归
- en: c.  Feature extraction and anomaly detection
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: c. 特征提取和异常检测
- en: d.  Dimensionality reduction and normalization
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: d. 维度约简和标准化
- en: 1.4.   What is the task of clustering in unsupervised learning?
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4. 无监督学习中的聚类任务是什么？
- en: a.  Group objects based on certain similarity measures
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: a. 根据某些相似性度量分组对象
- en: b.  Identify traffic signs in a self-driving car
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: b.  在自动驾驶汽车中识别交通标志
- en: c.  Map input features to known labels or classes
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: c.  将输入特征映射到已知标签或类别
- en: d.  Optimize a model’s performance by feedback loop
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: d.  通过反馈循环优化模型性能
- en: 1.5.   The pointer-network (Ptr-Net) model is designed to address specific limitations
    of conventional sequence-to-sequence (seq2seq) models, particularly in tasks involving
    variable-length output sequences.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   指针网络（Ptr-Net）模型旨在解决传统序列到序列（seq2seq）模型的特定局限性，尤其是在涉及可变长度输出序列的任务中。
- en: a.  True
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.6.   In reinforcement learning, how does a learning agent learn to make decisions?
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   在强化学习中，学习代理是如何学习做出决策的？
- en: a.  By minimizing the error between predicted and actual classes
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: a.  通过最小化预测类别与实际类别之间的误差
- en: b.  By identifying clusters within the input data
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: b.  通过在输入数据中识别聚类
- en: c.  By maximizing cumulative reward through actions in an environment
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: c.  通过在环境中通过行动最大化累积奖励
- en: d.  By mapping input features to known labels or classes
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: d.  通过将输入特征映射到已知标签或类别
- en: 1.7.   What does deep learning (DL) enable in machine learning?
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   深度学习（DL）在机器学习中能够实现什么？
- en: a.  Feature representation learning at different levels of abstractions
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: a.  在不同抽象层次上的特征表示学习
- en: b.  Classification of different objects based on labeled data
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: b.  基于标记数据对不同对象的分类
- en: c.  Grouping of similar data points based on certain measures
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: c.  基于某些度量将相似数据点分组
- en: d.  Reward-based decision-making in an interactive environment
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: d.  在交互环境中基于奖励的决策
- en: 1.8.   Graph embedding learns a mapping from a low-dimensional continuous domain
    to a discrete high-dimensional graph domain.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   图嵌入学习从低维连续域到离散高维图域的映射。
- en: a.  True
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.9.   How does DL reduce the need for extensive data preprocessing?
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   深度学习（DL）是如何减少对大量数据预处理的需求的？
- en: a.  By using a large amount of unlabeled data for training
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: a.  通过使用大量未标记数据进行训练
- en: b.  By learning through interactions in a feedback loop
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: b.  通过在反馈循环中的交互学习
- en: c.  By approximating mapping functions between data and known labels
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: c.  通过近似数据与已知标签之间的映射函数
- en: d.  By learning discriminative features from raw data automatically
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: d.  通过从原始数据中自动学习判别性特征
- en: 1.10. Why is graph-structured data important in the field of combinatorial optimization?
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. 为什么图结构数据在组合优化领域很重要？
- en: a.  It helps to maximize cumulative rewards
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: a.  它有助于最大化累积奖励
- en: b.  It assists in mapping functions between data and labels
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: b.  它有助于在数据与标签之间映射函数
- en: c.  It captures and represents the relationships and constraints between elements
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: c.  它捕捉并表示元素之间的关系和约束
- en: d.  It groups objects based on similarity measures
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: d.  它根据相似性度量将对象分组
- en: 2.   Match the terms and descriptions shown in table C.17.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   将表C.17中显示的术语与描述进行匹配。
- en: Table C.17
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.17
- en: '| Terms | Descriptions |'
  id: totrans-1469
  prefs: []
  type: TYPE_TB
  zh: '| 术语 | 描述 |'
- en: '| --- | --- |'
  id: totrans-1470
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1\. Self-organizing map (SOM) | a. A polygon that fully encompasses a given
    set of points with maximum area and minimum boundary or circumference of the shape.
    |'
  id: totrans-1471
  prefs: []
  type: TYPE_TB
  zh: '| 1\. 自组织映射（SOM） | a. 一个多边形，它完全包围给定的一组点，具有最大面积和最小边界或周长。|'
- en: '| 2\. Convex hull | b. A mechanism that allows the model to dynamically prioritize
    which parts of the input are most relevant for each output it''s trying to predict,
    making it more effective at understanding context and reducing confusion from
    long input sequences |'
  id: totrans-1472
  prefs: []
  type: TYPE_TB
  zh: '| 2\. 凸包 | b. 一种机制，允许模型动态地优先考虑输入中哪些部分对于它试图预测的每个输出是最相关的，使其在理解上下文和减少长输入序列的混淆方面更加有效。|'
- en: '| 3\. Pointer-network (Ptr-Net) | c. A type of artificial neural network that
    is trained using unsupervised learning to produce a low-dimensional (typically
    two-dimensional), discretized representation of the input space of the training
    samples |'
  id: totrans-1473
  prefs: []
  type: TYPE_TB
  zh: '| 3\. 指针网络（Ptr-Net） | c. 一种使用无监督学习训练的人工神经网络，它产生输入空间训练样本的低维（通常是二维）离散表示。|'
- en: '| K-hop neighborhood | d. A set of neighboring nodes at a distance less than
    or equal to K |'
  id: totrans-1474
  prefs: []
  type: TYPE_TB
  zh: '| K-hop 邻域 | d. 距离小于或等于K的一组相邻节点|'
- en: '| 5\. Attention mechanism | e. A type of neural network architecture designed
    to deal with variable-sized input data sequences |'
  id: totrans-1475
  prefs: []
  type: TYPE_TB
  zh: '| 5\. 注意力机制 | e. 一种用于处理可变大小输入数据序列的神经网络架构|'
- en: '3.   Find the shortest path to visit 20 major US cities starting from New York
    City using self-organizing maps. The cities are given by the names and GPS latitude
    and longitude coordinates as follows:'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   使用自组织映射（SOM）从纽约市出发访问20个主要美国城市的最短路径。城市名称和GPS纬度和经度坐标如下：
- en: •   New York City (40.72, –74.00)
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: •   纽约市（40.72, –74.00）
- en: •   Philadelphia (39.95, –75.17)
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: •   费城（39.95, –75.17）
- en: •   Baltimore (39.28, –76.62)
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: •   巴尔的摩（39.28, –76.62）
- en: •   Charlotte (35.23, –80.85)
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: •   夏洛特（35.23, –80.85）
- en: •   Memphis (35.12, –89.97)
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: •   孟菲斯（35.12, –89.97）
- en: •   Jacksonville (30.32, –81.70)
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: •   杰克逊维尔（30.32, –81.70）
- en: •   Houston (29.77, –95.38)
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: •   休斯顿（29.77, –95.38）
- en: •   Austin (30.27, –97.77)
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: •   奥斯汀（30.27, –97.77）
- en: •   San Antonio (29.53, –98.47)
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: •   圣安东尼奥（29.53, –98.47）
- en: •   Fort Worth (32.75, –97.33)
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: •   福特沃斯（32.75, –97.33）
- en: •   Dallas (32.78, –96.80)
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: •   达拉斯（32.78, –96.80）
- en: •   San Diego (32.78, –117.15)
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: •   圣地亚哥（32.78, –117.15）
- en: •   Los Angeles (34.05, –118.25)
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: •   洛杉矶（34.05, –118.25）
- en: •   San Jose (37.30, –121.87)
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: •   圣何塞（37.30, –121.87）
- en: •   San Francisco (37.78, –122.42)
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: •   旧金山（37.78, –122.42）
- en: '•   Indianapolis'': (39.78, –86.15)'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: •   印第安纳波利斯（39.78, –86.15）
- en: •   Phoenix (33.45, –112.07)
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: •   凤凰城（33.45, –112.07）
- en: •   Columbus (39.98, –82.98)
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: •   辛辛那提（39.98, –82.98）
- en: •   Chicago (41.88, –87.63)
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: •   芝加哥（41.88, –87.63）
- en: •   Detroit (42.33, –83.05)
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: •   底特律（42.33, –83.05）
- en: 4.   Optimizing the hyperparameters can significantly improve the performance
    of the ML model. Tune the hyperparameters in listing 11.6, and observe the effect
    on the ConvexNet model’s performance with different testing datasets. The hyperparameters
    to be tuned include
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   调优超参数可以显著提高机器学习模型的表现。在列表11.6中调整超参数，并观察不同测试数据集对ConvexNet模型性能的影响。需要调整的超参数包括
- en: •   The number of input features for the model
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: •   模型的输入特征数量
- en: •   The number of embedding dimensions
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: •   嵌入维度数量
- en: •   The number of hidden units in the model
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: •   模型中隐藏单元的数量
- en: •   The number of attention heads in the multi-head self-attention mechanism
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: •   多头自注意力机制中的注意力头数量
- en: •   The number of layers in the model
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: •   模型中的层数
- en: •   The dropout probability
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: •   Dropout概率
- en: •   The number of training epochs
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: •   训练的迭代次数
- en: •   The batch size used during training
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: •   训练过程中使用的批量大小
- en: •   The learning rate for the optimizer
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: •   优化器的学习率
- en: C.10.2 Solutions
  id: totrans-1507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.10.2 解决方案
- en: 1.   Multiple choice and true/false
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多选题和判断题
- en: 1.1.   c) Supervised, unsupervised, hybrid, reinforcement
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   c) 监督的、无监督的、混合的、强化学习
- en: 1.2.   b) False (The Kohonen map is trained using unsupervised learning to produce
    a low-dimensional representation of the input space of the training samples, not
    supervised learning.)
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   b) 错误（Kohonen图使用无监督学习进行训练，以产生训练样本输入空间的低维表示，而不是监督学习。）
- en: 1.3.   b) Classification and regression
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   b) 分类和回归
- en: 1.4.   a) Group objects based on certain similarity measures
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   a) 基于某些相似性度量分组对象
- en: 1.5.   a) True
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   a) 正确
- en: 1.6.   c) By maximizing cumulative reward through actions in an environment
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   c) 通过在环境中采取行动最大化累积奖励
- en: 1.7.   a) Feature representation learning at different levels of abstractions
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   a) 在不同抽象层次上的特征表示学习
- en: 1.8.   b) False (Graph embedding learns a mapping from a discrete high-dimensional
    graph domain to a low-dimensional continuous domain, not the other way around.)
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   b) 错误（图嵌入学习从离散的高维图域到低维连续域的映射，而不是相反。）
- en: 1.9.   d) By learning discriminative features from raw data automatically
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   d) 通过从原始数据中自动学习判别特征
- en: 1.10. c) It captures and represents the relationships and constraints between
    elements
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. c) 它捕捉并表示元素之间的关系和约束
- en: 2.   1-c, 2-a, 3-e, 4-d, and 5-b.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   1-c, 2-a, 3-e, 4-d, 和 5-b。
- en: 3.   MiniSom is used in this listing. MiniSom is a minimalistic and Numpy-based
    implementation of the SOM. You can install this library using !pip install minisom.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   本列表使用MiniSom。MiniSom是基于Numpy的最小化实现的自组织映射（SOM）。您可以使用以下命令安装此库：!pip install
    minisom。
- en: The next listing shows how to solve the 20-city TSP using self-organizing maps.
    We start by importing the libraries and modules, defining the cities of interest,
    and calculating the haversine distances between pairs of cities.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何使用自组织映射解决20个城市TSP问题。我们首先导入库和模块，定义感兴趣的城市，并计算城市对之间的哈夫曼距离。
- en: Listing C.20 Solving TSP using SOM
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.20 使用自组织映射（SOM）解决TSP问题
- en: '[PRE63]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ① Define latitude and longitude for twenty major US cities.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义20个主要美国城市的纬度和经度。
- en: ② Create a haversine distance matrix based on latitude-longitude coordinates.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: ② 基于纬度和经度坐标创建哈夫曼距离矩阵。
- en: ③ Convert the distance dictionary into a dataframe.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将距离字典转换为数据框。
- en: ④ Get the haversine distances between pairs of cities.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 获取城市对之间的哈弗辛距离。
- en: We then define a SOM to solve the TSP instance. This SOM is 1D with *N* neurons.
    The dimensionality of the input data is 2 (latitude and longitude coordinates).
    The sigma parameter is used for the Gaussian neighborhood function. This parameter
    controls the spread of the influence of neighboring neurons during training. The
    learning rate determines the step size of weight updates during training. The
    neighborhood function used during training is set to Gaussian, which means the
    influence of neighboring neurons decreases with distance. The seed for the random
    number generator is set to 50 to ensure reproducibility of the results.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个SOM来解决TSP实例。这个SOM是1D的，具有*N*个神经元。输入数据的维度是2（纬度和经度坐标）。sigma参数用于高斯邻域函数。此参数控制训练期间邻近神经元影响范围的扩散。学习率决定了训练期间权重更新的步长。训练期间使用的邻域函数设置为高斯，这意味着邻近神经元的影响随着距离的增加而减小。随机数生成器的种子设置为50，以确保结果的再现性。
- en: '[PRE64]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ① Set the number of neurons (nodes) for the 1D SOM.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置1D SOM的神经元（节点）数量。
- en: ② Create a self-organizing map with 1xN_neurons grid.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个具有1xN神经元网格的自组织图。
- en: ③ Initialize the weights.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 初始化权重。
- en: 'The following code snippet generates a set of visualizations to show the progress
    of the SOM training:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段生成一组可视化，以显示SOM训练的进度：
- en: '[PRE65]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Figure C.37 shows the visualized plots.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.37显示了可视化的图表。
- en: '![](../Images/APPC_F37_Khamis.png)'
  id: totrans-1536
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F37_Khamis.png)'
- en: Figure C.37 Progress of SOM training with increasing numbers of iterations
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.37 SOM训练进度随迭代次数增加
- en: 'C.11 Chapter 12: Reinforcement learning'
  id: totrans-1538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.11 第12章：强化学习
- en: C.11.1 Exercises
  id: totrans-1539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.11.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多选题和判断题：为以下每个问题选择正确的答案。
- en: 1.1.   In reinforcement learning, what does the term “reward” represent?
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   在强化学习中，“奖励”这个术语代表什么？
- en: a.  The penalty for performing an action
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: a.  执行动作的惩罚
- en: b.  The immediate feedback received from the environment
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: b.  从环境中获得的即时反馈
- en: c.  The probability of taking a particular action
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: c.  执行特定动作的概率
- en: d.  The number of steps taken by the agent
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: d.  代理采取的步数
- en: 1.2.   The goal of reinforcement learning is to
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   强化学习的目标是
- en: a.  Minimize the cumulative reward
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: a.  最小化累积奖励
- en: b.  Find the shortest path to the goal state
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: b.  找到到达目标状态的最短路径
- en: c.  Learn an optimal policy to maximize cumulative rewards
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: c.  学习最优策略以最大化累积奖励
- en: d.  Achieve a deterministic environment
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: d.  实现确定性环境
- en: 1.3.   Which of the following RL algorithms is considered model-free?
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   以下哪个强化学习算法被认为是无模型的？
- en: a.  Expert iteration
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: a.  专家迭代
- en: b.  Proximal policy optimization (PPO)
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: b.  近端策略优化（PPO）
- en: c.  Imagination-augmented agents (I2A)
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: c.  想象力增强代理（I2A）
- en: d.  None of the above
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: d.  以上皆非
- en: 1.4.   The concept of a “discount factor” in reinforcement learning is used
    to
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   强化学习中“折扣因子”的概念用于
- en: a.  Reduce the size of the state space
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: a.  减少状态空间的大小
- en: b.  Decrease the rewards obtained from the environment
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: b.  减少从环境中获得的奖励
- en: c.  Balance the importance of immediate rewards and future rewards
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: c.  平衡即时奖励和未来奖励的重要性
- en: d.  Encourage exploration over exploitation
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: d.  鼓励探索而非利用
- en: 1.5.   Which of the following RL algorithms is considered an on-policy RL method?
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   以下哪个强化学习算法被认为是离线策略RL方法？
- en: a.  Q-learning
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: a.  Q学习
- en: b.  Twin-delayed deep deterministic policy gradient (TD3)
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: b.  双延迟深度确定性策略梯度（TD3）
- en: c.  Deep deterministic policy gradient (DDPG)
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: c.  深度确定性策略梯度（DDPG）
- en: d.  Proximal policy optimization (PPO)
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: d.  近端策略优化（PPO）
- en: 1.6   PPO-clip and PPO-penalty are two variants of the policy gradient method
    designed to address potential instability during training.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6   PPO-clip和PPO-penalty是策略梯度方法的两种变体，旨在解决训练过程中可能出现的潜在不稳定性。
- en: a.  True
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.7.   Which multi-armed bandit strategy randomly selects a slot machine at
    each trial without considering past results?
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   以下哪种多臂老虎机策略在每次试验中随机选择一个老虎机，而不考虑过去的结果？
- en: a.  Exploit-only greedy strategy
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: a.  仅利用的贪婪策略
- en: b.  Epsilon-greedy strategy
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: b.  ε-贪婪策略
- en: c.  Upper confidence bound (UCB) strategy
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: c.  上界置信（UCB）策略
- en: d.  Explore-only strategy
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: d.  仅探索策略
- en: 1.8.   In the *ε*-greedy strategy, how does the agent balance exploration and
    exploitation?
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   在ε-贪婪策略中，代理如何平衡探索和利用？
- en: a.  It always selects the machine with the highest estimated mean reward.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: a. 它总是选择估计平均奖励最高的机器。
- en: b.  It randomly selects a machine with a certain probability (epsilon) and otherwise
    selects the machine with the highest estimated mean reward.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: b. 它以一定的概率（ε）随机选择一台机器，否则选择估计平均奖励最高的机器。
- en: c.  It explores all machines equally during each trial.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: c. 在每次试验中，它对所有机器进行平等探索。
- en: d.  It focuses on exploiting the current best machine only.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: d. 它只专注于利用当前最佳机器。
- en: 1.9.   What does “regret” measure in the multi-armed bandit problem?
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9. 在多臂老虎机问题中，“遗憾”衡量的是什么？
- en: a.  The difference between the maximum possible reward and the reward obtained
    from each selected machine
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: a. 最大可能奖励与从每个选定的机器获得的奖励之间的差异
- en: b.  The number of times the agent chooses to explore a new machine
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: b. 代理选择探索新机器的次数
- en: c.  The total time spent in the same single state
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: c. 在相同单一状态下所花费的总时间
- en: d.  The total number of arms or actions available to the agent
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: d. 代理可用的总臂或动作数量
- en: 1.10. What does the Markov decision process (MDP) represent in the context of
    reinforcement learning?
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. 在强化学习的背景下，马尔可夫决策过程（MDP）代表什么？
- en: a.  A process that involves making decisions without considering state transitions
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一种在决策时不考虑状态转换的过程
- en: b.  A method for supervised learning using labeled datasets
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: b. 使用标记数据集进行监督学习的方法
- en: c.  A mathematical framework for planning under uncertainty, in which actions
    influence future states with certain probabilities
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: c. 一种在不确定性下的规划数学框架，其中动作以一定的概率影响未来的状态
- en: d.  A type of optimization algorithm for clustering data
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: d. 一种用于聚类数据的优化算法
- en: 2.   Imagine you are a digital marketer running an online advertising campaign.
    You have several ad variations that you can display to users, each with its own
    click-through rate (CTR) or conversion rate. Click-through measures the rate at
    which users click on a link, while conversion measures the rate at which users
    complete a desired action after clicking on the link, such as making a purchase,
    signing up for a newsletter, or completing a form. Your goal is to maximize user
    engagement or conversions by selecting the most effective ad variation.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   假设你是一位数字营销人员，正在运行在线广告活动。你可以向用户展示几个广告变体，每个广告变体都有自己的点击率（CTR）或转化率。点击率衡量用户点击链接的频率，而转化率衡量用户在点击链接后完成预期动作的频率，例如进行购买、注册通讯录或完成表格。你的目标是通过对最有效的广告变体进行选择，最大化用户参与度或转化率。
- en: Let’s assume you have three ad variations, represented by arms A1, A2, and A3\.
    Each ad variation has an associated probability distribution of click-through
    or conversion rates, denoted as Q1, Q2, and Q3\. These probability distributions
    represent the likelihood of a user clicking on each ad variation. At each time
    step *t*, you need to choose an ad variation *A* to display to users. When ad
    variation *A* is displayed, users interact with it, and you observe the outcome,
    which can be a click or a conversion. The outcome is drawn from the probability
    distribution *Q*(*A*), representing the likelihood of a click or conversion for
    ad variation *A*. Assume that the three probability distributions Q1, Q2, and
    Q3 are normal distributions with means of {7, 10, 6} and standard deviations of
    {0.45, 0.65, 0.35} respectively. Your objective is to maximize the cumulative
    number of clicks over a series of ad displays (let’s say 10,000 ad displays).
    Write Python code to implement an *ε*-greedy strategy to determine which ad variation
    to display at each time step based on the estimated click-through rates.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有三种广告变体，分别用臂A1、A2和A3表示。每个广告变体都有一个与之相关的点击率或转化率的概率分布，分别表示为Q1、Q2和Q3。这些概率分布代表了用户点击每个广告变体的可能性。在每一个时间步t，你需要选择一个广告变体A来向用户展示。当广告变体A被展示时，用户会与之互动，你观察到结果，这可能是一个点击或转化。结果是从概率分布Q(A)中抽取的，表示广告变体A的点击或转化可能性。假设三个概率分布Q1、Q2和Q3是具有均值{7,
    10, 6}和标准差{0.45, 0.65, 0.35}的正态分布。你的目标是最大化一系列广告展示中的累积点击数（比如说10,000次广告展示）。请编写Python代码实现ε-贪婪策略，以确定在每一个时间步选择哪个广告变体进行展示，基于估计的点击率。
- en: '3.   The taxi environment is based on the taxicab, or ride-hailing, problem,
    where a taxi must pick up a passenger from one location and drop them off at another
    specified location. The goal of the agent is to learn a policy that navigates
    the taxi through the grid to pick up and drop off passengers while maximizing
    the cumulative reward. When the episode starts, the taxi is at a random square,
    and the passenger is at a random location. The taxi drives to the passenger’s
    location, picks them up, drives to the passenger’s destination (another one of
    the four specified locations), and drops off the passenger. Once the passenger
    is dropped off, the episode ends. The states, actions, and rewards are as follows:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   出租车环境基于出租车或叫车问题，其中出租车必须从某个位置接乘客，并在另一个指定位置放下乘客。代理的目标是学习一种策略，通过网格导航出租车来接送乘客，同时最大化累积奖励。当场景开始时，出租车位于一个随机方块，乘客位于一个随机位置。出租车驶向乘客的位置，接上乘客，然后驶向乘客的目的地（四个指定位置之一），并放下乘客。一旦乘客被放下，场景结束。状态、动作和奖励如下：
- en: '•   States (observation space includes 500 discrete states): 25 taxi positions
    (any location within the 5 × 5 grid world); 5 passenger locations (0: R(ed); 1:
    G(reen); 2: Y(ellow); 3: B(lue); 4: in taxi) and 4 destinations (0: R(ed); 1:
    G(reen); 2: Y(ellow); 3: B(lue)). Thus, this taxi environment has a total of 5
    × 5 × 5 × 4 = 500 possible states.'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: •   状态（观察空间包括500个离散状态）：25个出租车位置（5×5网格世界中的任何位置）；5个乘客位置（0：红；1：绿；2：黄；3：蓝；4：在出租车内）和4个目的地（0：红；1：绿；2：黄；3：蓝）。因此，此出租车环境共有5×5×5×4=500个可能的状态。
- en: '•   Actions (action space includes 6 discrete actions): 0 = move south; 1 =
    move north; 2 = move east; 3 = move west; 4 = pick up passenger, and 5 = drop
    off passenger.'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: •   动作（动作空间包括6个离散动作）：0 = 向南移动；1 = 向北移动；2 = 向东移动；3 = 向西移动；4 = 接乘客，5 = 放下乘客。
- en: '•   Rewards: +20 (a high positive reward for a successful drop off); –10 (a
    penalty for executing pickup and drop-off actions illegally, such as if the agent
    tries to drop off a passenger in a wrong location), and –1 (a slight negative
    reward for not making it to the destination after every time step, to mimic the
    delay).'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: •   奖励：+20（成功放下乘客的高正奖励）；–10（非法执行接送动作的惩罚，例如如果代理试图在错误的位置放下乘客），以及–1（每次时间步后未能到达目的地的小负奖励，以模拟延迟）。
- en: 'Write Python code to show how to use A2C to learn the optimal policy for this
    environment. Experiment with vectorized environments where multiple independent
    environments are stacked into a single environment. Vectorized environments enable
    you to run multiple instances of an environment in parallel. Instead of training
    an RL agent on one environment per step, it allows you to train it on *n* environments
    per step. For example, if you want to run four parallel environments, you can
    specify this number when you create the environment, as follows: `env = make_vec_env("Taxi-v3",
    n_envs=4, seed=0`.'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Python代码以展示如何使用A2C学习此环境的最佳策略。尝试使用向量化环境，其中多个独立环境堆叠成一个单一环境。向量化环境允许你并行运行多个环境实例。与每步在一个环境中训练RL代理相比，它允许你每步在*n*个环境中训练。例如，如果你想运行四个并行环境，你可以在创建环境时指定此数字，如下所示：`env
    = make_vec_env("Taxi-v3", n_envs=4, seed=0`。
- en: '4.   In preparing for a scheduled flight, an airline’s flight operations team
    is tasked with selecting the best flight route and service according to the shared
    context. The shared context represents the type of flight (domestic or international)
    and the type of passengers (business class, economy class, or a mix). The flight
    operations team must decide the best strategy for flight route, meal service,
    and in-flight entertainment. The options are represented as follows:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   在为计划中的航班做准备时，航空公司的航班运营团队负责根据共享上下文选择最佳飞行路线和服务。共享上下文代表飞行类型（国内或国际）和乘客类型（商务舱、经济舱或混合）。航班运营团队必须决定飞行路线、餐饮服务和机上娱乐的最佳策略。选项如下：
- en: •   *Flight route*—The most direct route, a fuel-efficient route that may be
    longer, or a route that avoids turbulence but may require more time
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: •   *飞行路线*—最直接路线、可能更长但更省油的路线，或避开湍流的路线，但可能需要更多时间
- en: •   *Meal service*—Full meal with multiple options, a simple meal with fewer
    options, or just snacks and beverages
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: •   *餐饮服务*—包含多个选项的完整餐点、选项较少的简单餐点，或仅提供小吃和饮料
- en: •   *In-flight entertainment*—Movies and music, in-flight Wi-Fi service, or
    a combination of both
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: •   *机上娱乐*—电影和音乐、机上Wi-Fi服务，或两者的组合
- en: The reward is how satisfactory the chosen options are for a given flight (shared
    context). The reward function receives as arguments the shared context (the type
    of flight and passenger class) and the selected actions for each option (the chosen
    flight route, meal service, and in-flight entertainment). To mirror real-world
    scenarios and complexities, we inject normal noise in the reward value. The objective
    is to select the best action from the available combinatorial actions in such
    a way that it maximizes the total reward. Write Python code to train and test
    a contextual bandit for this problem.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励是针对给定航班（共享上下文）所选选项的满意度。奖励函数接收共享上下文（航班类型和乘客等级）以及每个选项所选动作（所选航班路线、餐食服务和机上娱乐）作为参数。为了模拟现实世界的场景和复杂性，我们在奖励值中注入了正常噪声。目标是选择最佳动作，从可用的组合动作中选择，以最大化总奖励。编写Python代码以训练和测试此问题的上下文赌博机。
- en: 5.   Listing 11.4 shows how to solve TSP using an ML model pretrained with a
    supervised approach or a reinforcement learning approach. Replace the supervised
    learning model sl-ar-var-20pnn-gnn-max_20200308T172931 with the pretrained RL
    model rl-ar-var-20pnn-gnn-max_20200313T002243, and report your observations.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   列表11.4展示了如何使用预先训练有监督方法或强化学习方法的ML模型解决TSP问题。将预训练的监督学习模型sl-ar-var-20pnn-gnn-max_20200308T172931替换为预训练的RL模型rl-ar-var-20pnn-gnn-max_20200313T002243，并报告您的观察结果。
- en: 6.   The gym-electric-motor (GEM) package is a Python toolbox designed for simulating
    and controlling electric motors. It is built upon OpenAI Gym environments and
    is suitable for classical control simulations and reinforcement learning experiments.
    Use GEM to define a permanent magnet synchronous motor (PMSM) environment as shown
    in figure C.38\. For more information about PMSM and GEM, see Traue et al.’s article
    “Toward a reinforcement learning environment toolbox for intelligent electric
    motor control” [10].
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   gym-electric-motor（GEM）包是一个Python工具箱，用于模拟和控制电机。它是基于OpenAI Gym环境构建的，适用于经典控制模拟和强化学习实验。使用GEM定义一个永磁同步电机（PMSM）环境，如图C.38所示。有关PMSM和GEM的更多信息，请参阅Traue等人撰写的文章“向智能电机控制强化学习环境工具箱迈进”[10]。
- en: '![](../Images/APPC_F38_Khamis.png)'
  id: totrans-1603
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F38_Khamis.png)'
- en: Figure C.38 The gym-electric-motor (GEM) environment described in Traue et al
    's article [9]
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.38 Traue等人文章[9]中描述的gym-electric-motor（GEM）环境
- en: Listing C.24, provided in the book’s GitHub repo, provides a simplified implementation
    of PPO for electric motor control. This code is used to train a control model
    (a PPO RL agent) to control the current for a permanent magnet synchronous motor.
    This agent mainly controls the converter that converts the supply currents to
    the currents flowing into the motor. Experiment with different parameters in this
    algorithm and consider trying other RL models available in Stable-Baselines3 (SB3).
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.24，在本书的GitHub仓库中提供，是PPO在电机控制中的简化实现。此代码用于训练一个控制模型（PPO强化学习代理）以控制永磁同步电机的电流。此代理主要控制将供电电流转换为流入电机的电流的转换器。在此算法的不同参数上进行实验，并考虑尝试Stable-Baselines3（SB3）中可用的其他RL模型。
- en: C.11.2 Solutions
  id: totrans-1606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.11.2 解答
- en: 1.   Multiple choice and true/false
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和判断题
- en: 1.1.   b) The immediate feedback received from the environment
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   b) 从环境中获得的即时反馈
- en: 1.2.   c) Learn an optimal policy to maximize cumulative rewards.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   c) 学习一个最优策略以最大化累积奖励。
- en: 1.3.   b) Proximal policy optimization (PPO)
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   b) 近端策略优化（PPO）
- en: 1.4.   c) Balance the importance of immediate rewards and future rewards.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   c) 平衡即时奖励和未来奖励的重要性。
- en: 1.5.   d) Proximal policy optimization (PPO)
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   d) 近端策略优化（PPO）
- en: 1.6.   a) True
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   a) 正确
- en: 1.7.   d) Explore-only strategy
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   d) 探索性策略
- en: 1.8.   b) It randomly selects a machine with a certain probability (epsilon)
    and otherwise selects the machine with the highest estimated mean reward.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   b) 以一定的概率（epsilon）随机选择一台机器，否则选择估计平均奖励最高的机器。
- en: 1.9.   a) The difference between the maximum possible reward and the reward
    obtained from each selected machine
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   a) 最大可能奖励与从每个所选机器获得的奖励之间的差异
- en: 1.10. c) A mathematical framework for planning under uncertainty, in which actions
    influence future states with certain probabilities
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. c) 在不确定性下规划的一个数学框架，其中动作以一定的概率影响未来状态
- en: 2.   Listing C.21 shows an implementation of a *ε*-greedy strategy to determine
    which ad variation to display at each time step based on the estimated click-through
    rates. In this code snippet, 10,000 ad displays are simulated. The estimates of
    the click-through rates for each ad variation are updated after each display.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   列表C.21展示了一种ε-greedy策略的实现，该策略基于估计的点击率在每个时间步确定显示哪个广告变体。在此代码片段中，模拟了10,000次广告展示。每次展示后，每个广告变体的点击率估计都会更新。
- en: Listing C.21 Online advertising using MAB
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.21 使用MAB进行在线广告
- en: '[PRE66]'
  id: totrans-1620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ① Initialize the number of arms (actions).
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化臂的数量（动作）。
- en: ② Initialize the number of trials (ads).
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: ② 初始化试验次数（广告）。
- en: ③ Probability distribution of each arm
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 每个臂的概率分布
- en: ④ Counters for each arm
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 每个臂的计数器
- en: ⑤ Select an initial arm.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 选择一个初始臂。
- en: ⑥ Set the epsilon value of the epsilon-greedy algorithm.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 设置ε-greedy算法的ε值。
- en: ⑦ Exploitation
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 利用
- en: ⑧ Add a small constant to avoid division by zero.
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 添加一个小常数以避免除以零。
- en: ⑨ Exploration
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 探索
- en: ⑩ Calculate and print the estimated click-through rates.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 计算并打印估计的点击率。
- en: In this script, `counts` keeps track of the number of times each ad variation
    has been displayed, and `rewards` keeps track of the total number of clicks for
    each ad variation. At the end of the script, the estimated click-through rates
    for each ad variation are calculated and printed.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，`counts`跟踪每个广告变体显示的次数，而`rewards`跟踪每个广告变体的总点击次数。脚本结束时，计算并打印每个广告变体的估计点击率。
- en: 3.   Listing C.22 shows the steps of learning the optimal policy for the taxicab
    problem using A2C. This code uses Stable-Baselines3 (SB3), a library for reinforcement
    learning, to train an agent using A2C on the Taxi-v3 environment. The SB3 function
    make_vec_env is used to create a vectorized environment that can run multiple
    parallel environments in the same process. The SB3 function evaluate_policy is
    used to evaluate the learned policy of the agent.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   列表C.22展示了使用A2C学习出租车问题最优策略的步骤。此代码使用Stable-Baselines3（SB3），一个强化学习库，在Taxi-v3环境中使用A2C训练一个智能体。SB3函数make_vec_env用于创建一个向量化环境，可以在同一进程中运行多个并行环境。SB3函数evaluate_policy用于评估智能体的学习策略。
- en: Listing C.22 Dispatching a taxicab using A2C RL
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.22 使用A2C RL调度出租车
- en: '[PRE67]'
  id: totrans-1634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ① Create a vectorized environment with a single parallel environment (n_envs=1).
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个包含单个并行环境（n_envs=1）的向量化环境。
- en: ② Print the observation and action spaces of the environment.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: ② 打印环境的观察和动作空间。
- en: ③ Create an A2C agent with MlpPolicy as the policy network.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建一个以MlpPolicy作为策略网络的A2C智能体。
- en: ④ Train the A2C agent on the Taxi-v3 environment for 10,000 timesteps.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在Taxi-v3环境中训练A2C智能体10,000个时间步。
- en: After the training is complete, the agent will have learned an optimal policy
    for navigating the Taxi-v3 environment to efficiently pick up and drop off passengers
    at the correct locations. The following code snippet visualizes the learned policy
    by rendering the Taxi-v3 environment using the trained A2C agent.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，智能体将学会一个最优策略，用于在Taxi-v3环境中导航，以有效地在正确的位置接载和放下乘客。以下代码片段通过使用训练好的A2C智能体渲染Taxi-v3环境来可视化学习到的策略。
- en: '[PRE68]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ① Create an empty list to store the frames (images) of the rendered environment.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个空列表以存储渲染环境的帧（图像）。
- en: ② Retrieve the environment associated with the model.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取与模型关联的环境。
- en: ③ Reset the environment and obtain the initial observation after the reset.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 重置环境并在重置后获取初始观察。
- en: ④ Predict an action based on the current observation.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 根据当前观察预测一个动作。
- en: ⑤ Get a new observation and the reward.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 获取新的观察和奖励。
- en: ⑥ Render the environment as an RGB image.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将环境渲染为RGB图像。
- en: ⑦ Clear the output for the next image.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 清除下一张图像的输出。
- en: '4.   Listing C.23 shows the implementation of a contextual bandit for an airline’s
    flight operations using the Vowpal Wabbit Python library. The shared context is
    defined by two lists: flight_types and passenger_classes. The possible choices,
    or actions, for the bandit problem are defined by flight_routes, meal_services,
    and entertainment_options. The reward_function calculates the reward associated
    with a particular combination of flight route, meal service, and entertainment
    option. The rewards are generated using a normal distribution with different means
    for different choices. The standard deviation (scale) is set to 0.05, implying
    that the rewards are sampled from a normal distribution with a small amount of
    variance.'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   列表C.23展示了使用Vowpal Wabbit Python库实现航空公司航班运营上下文多臂老虎机的代码。共享上下文由两个列表定义：flight_types和passenger_classes。老虎机问题的可能选择或动作由flight_routes、meal_services和entertainment_options定义。reward_function计算与特定航班路线、餐食服务和娱乐选项组合相关的奖励。奖励使用具有不同均值的正态分布生成。标准差（尺度）设置为0.05，意味着奖励是从具有少量方差的正态分布中采样的。
- en: Listing C.23 Contextual bandit for an airline’s flight operations
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.23 航空公司航班运营的上下文多臂老虎机
- en: '[PRE69]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ① Set the shared context.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置共享上下文。
- en: ② Set possible choices/action options.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置可能的选择/动作选项。
- en: ③ Calculate the reward associated with a particular combination of options.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 计算特定选项组合的奖励。
- en: 'As a continuation, the following two utility functions are defined. `generate_combinations`
    generates combinations of flight routes, meal services, and entertainment options,
    along with their associated descriptions. `sample_truck_pmf` performs sampling
    based on a probability mass function (PMF):'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 作为延续，定义以下两个效用函数。`generate_combinations`生成航班路线、餐食服务和娱乐选项的组合及其相关描述。`sample_truck_pmf`根据概率质量函数（PMF）进行采样：
- en: '[PRE70]'
  id: totrans-1655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can now create a contextual bandit using the Vowpal Wabbit (VW) library
    and evaluate its performance over a specified number of iterations. This contextual
    bandit will make decisions (select actions) in the context of different flight
    types and passenger classes to maximize the expected reward:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Vowpal Wabbit（VW）库创建上下文多臂老虎机，并在指定的迭代次数上评估其性能。这个上下文多臂老虎机将在不同航班类型和乘客类别的情况下做出决策（选择动作），以最大化预期奖励：
- en: '[PRE71]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here are the key arguments to create contextual bandit:'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 创建上下文多臂老虎机的关键参数如下：
- en: •   `--cb_explore_adf`—Enables contextual bandit exploration with action-dependent
    features
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: •   `--cb_explore_adf`—启用基于动作相关特征的上下文多臂老虎机探索
- en: •   `--epsilon 0.2`—Sets the exploration rate to 0.2, meaning that the bandit
    will explore non-greedy actions with a probability of 0.2 (20% of the time)
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: •   `--epsilon 0.2`—将探索率设置为0.2，意味着老虎机将以0.2的概率（20%的时间）探索非贪婪动作
- en: •   `--interactions AA AU AAU`—Specifies three-way interactions between features
    AA, AU, and AAU
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: •   `--interactions AA AU AAU`—指定特征AA、AU和AAU之间的三重交互
- en: •   `-l 0.05`—Sets the learning rate to 0.05, which controls the step size in
    the learning process
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: •   `-l 0.05`—将学习率设置为0.05，这控制了学习过程中的步长大小
- en: •   `--power_t 0`—Specifies that the learning rate is constant (no learning
    rate decay)
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: •   `--power_t 0`—指定学习率是常数（没有学习率衰减）
- en: •   `num_iterations = 2500`
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: •   `num_iterations = 2500`
- en: 'The following code snippet allows us to run the created contextual bandit to
    make decisions:'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段允许我们运行创建的上下文多臂老虎机来做出决策：
- en: '[PRE72]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ① Set the number of iterations.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置迭代次数。
- en: ② Initialize an empty to store the rewards at each iteration.
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: ② 初始化一个空列表以存储每个迭代的奖励。
- en: ③ Select a random shared context in each iteration.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在每次迭代中随机选择一个共享上下文。
- en: ④ Generate all possible combinations of flight routes, meal services, and entertainment
    options based on the chosen shared context.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 根据所选共享上下文生成所有可能的航班路线、餐食服务和娱乐选项组合。
- en: ⑤ Predict the expected reward for each action (combination).
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 预测每个动作（组合）的预期奖励。
- en: ⑥ Sample an index from the predicted rewards.
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 从预测的奖励中采样一个索引。
- en: ⑦ Retrieve individual choices for flight route, meal service, and entertainment.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 获取航班路线、餐食服务和娱乐的个别选择。
- en: ⑧ Calculate the reward associated with the chosen action (combination) and shared
    context.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 计算与所选动作（组合）和共享上下文相关的奖励。
- en: ⑨ Append the reward information to the example.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将奖励信息附加到示例中。
- en: ⑩ Learn from the updated examples.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 从更新的示例中学习。
- en: ⑪ Close the workspace and finalize the learning process.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 关闭工作空间并最终化学习过程。
- en: 'We can print the average reward during training as follows:'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式打印训练过程中的平均奖励：
- en: '[PRE73]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Figure C.39 shows the progress of an average reward obtained in each iteration
    during the learning process.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.39展示了学习过程中每次迭代获得的平均奖励的进展情况。
- en: '![](../Images/APPC_F39_Khamis.png)'
  id: totrans-1681
  prefs: []
  type: TYPE_IMG
- en: Figure C.39 Average reward in each iteration during the learning process
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.39 学习过程中每次迭代的平均奖励
- en: 'The complete version of listing C.23 provided in the book’s GitHub repo defines
    a `test_model` function and then tests the contextual bandit model using a given
    shared context. The `test_model` function is defined to test the contextual bandit
    model by simulating a single decision-making instance for a given shared context.
    It takes four parameters—`shared_context`, `flight_routes`, `meal_services`, and
    `entertainment_options`:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 书中GitHub仓库提供的C.23完整列表定义了一个`test_model`函数，然后使用给定的共享上下文测试了上下文化多臂老虎机模型。`test_model`函数被定义为通过模拟给定共享上下文的一个决策实例来测试上下文化多臂老虎机模型。它接受四个参数——`shared_context`、`flight_routes`、`meal_services`和`entertainment_options`：
- en: '[PRE74]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ① Generate all possible combinations of flight routes, meal services, and entertainment
    options based on the given shared context.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: ① 根据给定的共享上下文，生成所有可能的航班路线、餐食服务和娱乐选项的组合。
- en: ② Predict the expected reward for each action (combination) based on the provided
    examples.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: ② 根据提供的示例预测每个动作（组合）的预期奖励。
- en: ③ Sample an index from the predicted rewards.
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: ④ Retrieve the chosen action (combination).
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Retrieve individual choices for flight route, meal service, and entertainment.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Calculate the expected reward associated with the chosen action and shared
    context.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 计算与所选动作和共享上下文相关的预期奖励。
- en: ⑦ Print the chosen action and the expected reward.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 打印选定的动作和预期奖励。
- en: ⑧ Set a specific shared context.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Test the contextual bandit model's decision-making process for this specific
    context.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 测试该特定情境下上下文老虎机模型的决策过程。
- en: 'This code will generate the output like the following for the given context:'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将为给定上下文生成如下输出：
- en: '[PRE75]'
  id: totrans-1695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '5.   Replacing the included supervised learning model, sl-ar-var-20pnn-gnn-max_20200308T172931,
    with the pretrained RL model, rl-ar-var-20pnn-gnn-max_20200313T002243, in listing
    11.4 is done as follows:'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-1697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 6.   Listing C.24, available in the book’s GitHub repo, provides a simplified
    implementation of PPO for electric motor control. Experiment with the different
    parameters of this algorithm and consider trying other RL models available in
    SB3, such as advantage actor-critic (A2C), soft actor-critic (SAC), deep deterministic
    policy gradient (DDPG), deep Q network (DQN), hindsight experience replay (HER),
    and twin delayed DDPG (TD3).
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   列表C.24，可在本书的GitHub仓库中找到，提供了用于电机控制的PPO算法的简化实现。尝试调整此算法的不同参数，并考虑尝试SB3中可用的其他强化学习模型，例如优势演员-评论家（A2C）、软演员-评论家（SAC）、深度确定性策略梯度（DDPG）、深度Q网络（DQN）、事后经验重放（HER）和双延迟DDPG（TD3）。
