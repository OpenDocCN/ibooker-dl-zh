- en: Appendix C. Exercises and solutions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. 练习和解答
- en: In this appendix, you will find a comprehensive set of exercises and their corresponding
    solutions, organized by chapter, to enhance your understanding and the application
    of the material presented in this book. These exercises are designed to reinforce
    the concepts, theories, and practical skills covered throughout the chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，您将找到一套全面的练习及其相应的解答，按章节组织，以增强您对本书中所呈现材料的概念、理论和实际技能的理解和应用。这些练习旨在加强全书各章节中涵盖的概念、理论和实践技能。
- en: 'C.1 Chapter 2: A deeper look at search and optimization'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 第2章：深入探讨搜索和优化
- en: C.1.1 Exercises
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1.1 练习
- en: '1.   Multiple choice: Choose the correct answer for each of the following questions.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题：为以下每个问题选择正确的答案。
- en: 1.1.   _________ is the class of decision problems that can be solved by nondeterministic
    polynomial algorithms and whose solutions are hard to find but easy to verify.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   _________ 是一类可以通过非确定性多项式算法解决的问题，其解决方案难以找到但易于验证。
- en: a.  P
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: a.  P
- en: b.  NP
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: b.  NP
- en: c.  co-NP
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: c.  co-NP
- en: d.  NP-complete
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: d.  NP-complete
- en: e.  NP-hard
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: e.  NP-hard
- en: 1.2.   Which of the following benchmark (toy) problems is not NP-complete?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   以下哪个基准（玩具）问题不是 NP-complete？
- en: a.  Bin packing
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: a.  二进制装箱
- en: b.  Knapsack problem
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: b.  背包问题
- en: c.  Minimum spanning tree
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: c.  最小生成树
- en: d.  Hamiltonian circuit
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: d.  汉密尔顿回路
- en: e.  Vertex cover problem
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: e.  顶点覆盖问题
- en: 1.3.   _________ is the class of decision problems whose “No” answer can be
    verified in polynomial time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   _________ 是一类决策问题，其“否”答案可以在多项式时间内验证。
- en: a.  P
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: a.  P
- en: b.  NP
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: b.  NP
- en: c.  co-NP
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: c.  co-NP
- en: d.  NP-complete
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: d.  NP-complete
- en: e.  NP-hard
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: e.  NP-hard
- en: 1.4.   Which of the following real-world problems is NP-hard?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   以下哪个现实世界问题是 NP-hard？
- en: a.  Image matching
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: a.  图像匹配
- en: b.  Single machine scheduling
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: b.  单机调度
- en: c.  Combinational equivalence checking
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: c.  组合等价性检查
- en: d.  Capacitated vehicle routing problem (CVRP)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: d.  容量车辆路径问题（CVRP）
- en: e.  Container/truck loading
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: e.  容器/卡车装载
- en: 1.5.   _________ is a theory that focuses on classifying computational problems
    according to their resource usage and relating these classes to each other.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   _________ 是一种理论，它专注于根据资源使用情况对计算问题进行分类，并将这些类别相互关联。
- en: a.  Optimization complexity
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: a.  优化复杂度
- en: b.  Time complexity
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: b.  时间复杂度
- en: c.  Computational complexity
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: c.  计算复杂度
- en: d.  Operation research
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: d.  运筹学
- en: e.  Decision complexity
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: e.  决策复杂度
- en: 2.   Describe the following search and optimization problems in terms of decision
    variable (univariate, bivariate, multivariate); objective functions (mono-objective,
    multi-objective, no objective function, or constraint-satisfaction problem); constraints;
    (hard constraints, soft constraints, both hard and soft constraints, unconstrained);
    and linearity (linear programming (LP), quadratic programming (QP), nonlinear
    programming (NLP)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   用决策变量（单变量，双变量，多变量）；目标函数（单目标，多目标，无目标函数，或约束满足问题）；约束；（硬约束，软约束，硬软约束，无约束）；以及线性（线性规划（LP），二次规划（QP），非线性规划（NLP））来描述以下搜索和优化问题。
- en: a.  Minimize *y* + cos(*x*²), sin(*x*) – *x × y*, and 1 / (*x* + *y*)²
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: a.  最小化 *y* + cos(*x*²), sin(*x*) – *x × y*，以及 1 / (*x* + *y*)²
- en: b.  Maximize 2 – e^((1 –) *^x*^) subject to –3 ≤ *x* *< 10*
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: b.  在 –3 ≤ *x* *< 10* 的约束下最大化 2 – e^((1 –) *^x*^)
- en: c.  Maximize 3 *× x* – *y* / 5 subject to –2 ≤ *x* < 3, 0 < *y* ≤ 3, and *x*
    + *y* = 4
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: c.  在 –2 ≤ *x* < 3, 0 < *y* ≤ 3, 和 *x* + *y* = 4 的约束下最大化 3 *× x* – *y* / 5
- en: d.  The school districting problem consists of determining the groups of students
    attending each school of a school board located over a given territory in a way
    that maximizes the contiguity of school sectors, taking into consideration a number
    of hard constraints such as school capacity for each grade and class capacity.
    Walkability and keeping students in the same school from year to year are considered
    soft constraints in this problem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: d.  学校区域划分问题包括确定在给定区域内学校委员会所属的每个学校的学生群体，以最大化学校区域连续性，同时考虑一系列硬约束，如每个年级的学校容量和班级容量。在这个问题中，步行可达性和保持学生每年在同一个学校被认为是软约束。
- en: e.  The knapsack problem is an example of a combinatorial problem whose solution
    takes the form of a combination where the order doesn’t matter. As illustrated
    in figure C.1, given a set of items, each with a utility and a weight, the task
    is to select a subset of items to maximize the total utility while ensuring that
    the total weight of the selected items does not exceed a predefined capacity.
    The decision to include or exclude each item is binary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: e. 背包问题是一个组合问题示例，其解决方案形式为组合，其中顺序不重要。如图C.1所示，给定一组物品，每个物品都有效用和重量，任务是选择物品的子集以最大化总效用，同时确保所选物品的总重量不超过预定义的容量。是否包含或排除每个物品的决定是二元的。
- en: '![](../Images/APPC_F01_Khamis.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F01_Khamis.png)'
- en: Figure C.1 Each item has a utility and a weight, and we want to maximize the
    utility of the contents of the knapsack. The problem is constrained by the capacity
    of the bag.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.1 每个物品都有效用和重量，我们希望最大化背包内容的效用。该问题受背包容量的限制。
- en: 3.   For the following optimization problems, state the type of the problem
    (design, planning, or control problem) based on the permissible time to solve
    the problem and the expected quality of the solutions. Suggest the appropriate
    algorithm required to handle the optimization problem (offline versus online).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 对于以下优化问题，根据解决问题的允许时间和预期解决方案的质量，基于问题类型（设计、规划或控制问题）提出适当的算法（离线或在线）来处理优化问题。
- en: a.  Find the optimal wind park design where the number and types of wind turbines
    need to be chosen and placed based on the wind conditions and wind park area.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: a. 找到最佳的风电场设计，其中需要根据风条件和风电场面积选择和放置风力涡轮机的数量和类型。
- en: b.  Find multiple vehicle routes starting and ending at different depots so
    that all customer demands are fulfilled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: b. 找到多个车辆路线，这些路线从不同的仓库开始和结束，以便满足所有客户需求。
- en: c.  Create a fitness assistant for runners and cyclists that seamlessly automates
    the multiple tasks involved in planning fitness activities. The planner will assess
    an athlete’s current fitness level and individual training goals in order to create
    a fitness plan. The planner will also generate and recommend geographical routes
    that are both popular and customized to the user’s goals, level, and scheduled
    time, thus reducing the challenges involved in the planning stage. The suggested
    fitness plans will continuously adapt based on each user’s progress toward their
    fitness goals, thus keeping the athlete challenged and motivated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: c. 为跑步者和骑自行车者创建一个健身助手，无缝自动化规划健身活动所涉及的多项任务。规划者将评估运动员当前的健身水平和个人训练目标，以便制定健身计划。规划者还将生成并推荐既受欢迎又符合用户目标、水平和预定时间的地理路线，从而减少规划阶段所涉及到的挑战。建议的健身计划将根据每个用户向健身目标进步的情况持续调整，从而保持运动员的挑战性和动力。
- en: d.  Find a set of flights with departure and arrival times and aircraft assignments
    that maximize profits, given demand and revenues for every flight, route information
    distances, times, operating restrictions, aircraft characteristics and operating
    costs, and operational and managerial constraints.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: d. 在给定每班航班的需求和收入、路线信息（距离、时间）、运营限制、飞机特性和运营成本以及运营和管理约束的情况下，找到一组航班，其出发和到达时间以及飞机分配最大化利润。
- en: e.  Find the optimal schedule for delivery cargo bikes, semi and fully autonomous
    last-mile delivery trucks, self-driving delivery robots or delivery drones to
    maximize customer satisfaction and minimize delivery costs, taking into consideration
    the capacity of the vehicle, type of delivery service (a couple of days delivery,
    next-day delivery, or same-day delivery with some extra surcharge), delivery time,
    drop-off locations, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: e. 找到交付货物的自行车、半自动和全自动最后一英里配送卡车、自动驾驶配送机器人或配送无人机最优调度方案，以最大化客户满意度并最小化配送成本，同时考虑车辆容量、配送服务类型（几天配送、次日配送或加额外费用的当日配送）、配送时间、投放地点等因素。
- en: f.  Plan on-demand responsive transit during pandemics to support the transportation
    of essential workers and essential trips to pharmacies and grocery stores for
    the general public, especially the elderly, taking into consideration store operating
    hours, capacity, and online delivery options.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: f. 在疫情期间，计划按需响应式公共交通，以支持必要工作人员的运输以及公众（尤其是老年人）前往药店和杂货店的必要行程，同时考虑商店营业时间、容量和在线配送选项。
- en: g.  Find a collision-free path for a vehicle from a start position to a given
    goal position, amid a collection of obstacles, in such a way that minimizes the
    estimated time of arrival and the consumed energy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: g. 在一组障碍物中，为车辆从起始位置到给定的目标位置找到一条无碰撞路径，以最小化估计的到达时间和消耗的能量。
- en: h.  Develop a trip planner that minimizes total commute time, maximizes the
    average ratings of attractions, maximizes the duration spent at each of these
    attractions, and effectively minimizes idle time when someone visits a city.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: h. 开发一个行程规划器，以最小化总通勤时间，最大化景点平均评分，最大化在每个景点停留的时间，并在有人访问城市时有效地最小化闲置时间。
- en: i.  Find school bus loading patterns and schedules such that the number of routes
    is minimized, the total distance traveled by all buses is kept to a minimum, no
    bus is overloaded, and the time required to traverse any route does not exceed
    a maximum time policy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: i. 找到校车装载模式和日程安排，使得路线数量最小化，所有校车行驶的总距离保持在最低，没有校车超载，并且穿越任何路线所需的时间不超过最大时间政策。
- en: j.  Minimize deadheading for shared mobility companies (minimize the miles driven
    with no passenger) or for delivery services providers (minimize the miles driven
    without cargo).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: j. 最小化共享移动公司（最小化无乘客驾驶的里程）或配送服务提供商（最小化无货物驾驶的里程）的空驶。
- en: k.  Plan or replan transport corridors and city streets to accommodate more
    pedestrians, cyclists, and riders in shared transportation and fewer cars.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: k. 规划或重新规划交通走廊和城市街道，以容纳更多的行人、自行车和共享交通的骑行者，以及更少的汽车。
- en: l.  Find the optimal placement for bus stops, traffic sensors, micro mobility
    stations, EV charging stations, air taxi takeoff and landing locations, walking
    routes, and cycling lanes for active mobility.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: l. 找到公交车站、交通传感器、微移动站、电动汽车充电站、空中出租车起飞和降落位置、步行路线和自行车道的最佳位置，以促进活跃的移动性。
- en: 4.   Modify listing 2.6 to define the animal feed mix problem data using Python
    dictionaries or to read the problem data from a CSV file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   修改列表2.6，使用Python字典定义动物饲料混合问题数据，或从CSV文件中读取问题数据。
- en: C.1.2 Solutions
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1.2 解决方案
- en: 1.   Multiple choice
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题
- en: 1.1\. b) NP
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1\. b) NP
- en: 1.2\. c) Minimum spanning tree
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2\. c) 最小生成树
- en: 1.3\. c) co-NP
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3\. c) co-NP
- en: 1.4\. d) Capacitated vehicle routing problem (CVRP)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4\. d) 容量车辆路径问题 (CVRP)
- en: 1.5\. c) Computational complexity
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5\. c) 计算复杂性
- en: 2.   Optimization problem description
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   优化问题描述
- en: a.  Bivariate, multi-objective, unconstrained, nonlinear programming
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: a. 二元，多目标，无约束，非线性规划
- en: b.  Univariate, mono-objective, hard constraints, nonlinear programming
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: b. 单变量，单目标，硬约束，非线性规划
- en: c.  Bivariate, mono-objective, hard constraints, linear programming
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: c. 二元，单目标，硬约束，线性规划
- en: d.  Multivariate, mono-objective, both hard and soft constraints, linear programming
    (see Jacques A. Ferland and Gilles Guénette, “Decision support system for the
    school districting problem” [1])
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: d. 多变量，单目标，既有硬约束又有软约束，线性规划（参见Jacques A. Ferland和Gilles Guénette，“学校划区问题的决策支持系统”
    [1]）
- en: e.  Bivariate, mono-objective, hard constraints, linear programming
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: e. 二元，单目标，硬约束，线性规划
- en: 3.   Optimization problem and process
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   优化问题和过程
- en: a.  Design problem. Offline optimization.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: a. 设计问题。离线优化。
- en: b.  Planning problem during the process of generating the route, and control
    problem during rerouting. Offline optimization during planning, and online optimization
    during rerouting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在生成路线过程中的规划问题，以及在重新路由过程中的控制问题。规划阶段的离线优化，以及重新路由阶段的在线优化。
- en: c.  Planning problem to generate the plans and control problem for adaptation.
    Offline optimization during the planning phase, and online during the adaptation
    phase.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: c. 生成计划的规划问题，以及适应的控制问题。规划阶段的离线优化，以及适应阶段的在线优化。
- en: d.  Design problem to generate the flight schedule, and planning problem if
    adaptation is required, such as in the case of faulty aircraft or cancellation
    due to weather conditions. Offline optimization, and online optimization if adaptation
    is required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: d. 生成飞行计划的工程设计问题，以及在需要适应的情况下（例如，飞机故障或因天气条件取消）的规划问题。离线优化，以及在需要适应的情况下进行在线优化。
- en: e.  Planning problem during path generation, and control problem during rerouting
    for adaptive motion planning. Online optimization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: e. 在路径生成过程中的规划问题，以及在自适应运动规划中的重新路由过程中的控制问题。在线优化。
- en: f.  Planning problem for scheduling, and control problem if rerouting is involved.
    Online optimization.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: f. 调度问题的规划问题，以及涉及重新路由的控制问题。规划阶段的在线优化。
- en: g.  Planning problem to generate the plans, and control problem for adaptation.
    Online optimization.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: g.  规划问题以生成计划，控制问题以适应。在线优化。
- en: h.  Planning problem. Offline optimization.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: h.  规划问题。离线优化。
- en: i.  Design problem. Offline optimization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: i.  设计问题。离线优化。
- en: j.  Planning problem. Online optimization.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: j.  规划问题。在线优化。
- en: k.  Design problem. Offline optimization.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: k.  设计问题。离线优化。
- en: l.  Design problem. Offline optimization.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: l.  设计问题。离线优化。
- en: 4\. The next listing shows the steps for defining the animal feed mix problem
    data using Python dictionaries or to read the problem data from a CSV file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 下一个列表显示了使用Python字典定义动物饲料混合问题数据或从CSV文件读取问题数据的步骤。
- en: Listing C.1 Animal feed mix problem—defining data using dictionaries
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.1 动物饲料混合问题——使用字典定义数据
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Create a list of ingredients.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个成分列表。
- en: ② Dictionary of unit cost (cents/kg).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ② 单位成本（美分/kg）词典。
- en: ③ Dictionary of calcium (kg/kg).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 钙（kg/kg）词典。
- en: ④ Dictionary of protein (kg/kg).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 蛋白质（kg/kg）词典。
- en: ⑤ Create a model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建模型。
- en: ⑥ Dictionary called 'ingredient_vars' is created to contain the referenced variables.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 创建名为'ingredient_vars'的字典以包含引用的变量。
- en: ⑦ Add the objective function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 添加目标函数。
- en: ⑧ Add the five constraints.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 添加五个约束条件。
- en: ⑨ Solve the problem using PuLP's choice of solver.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 使用PuLP的求解器选择解决问题。
- en: ⑩ Print the results.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 打印结果。
- en: We can also read the problem data from a CSV file as follows.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以如下从CSV文件中读取问题数据。
- en: Listing C.2 Animal feed mix problem—reading problem data from a CSV file
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.2 动物饲料混合问题——从CSV文件读取问题数据
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Read the CSV file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ① 读取CSV文件。
- en: ② Convert data frame to a dictionary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将数据帧转换为字典。
- en: ③ Create a model.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建模型。
- en: ④ A dictionary called 'ingredient_vars' is created to contain the referenced
    variables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建名为'ingredient_vars'的字典以包含引用的变量。
- en: ⑤ Add the objective function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 添加目标函数。
- en: ⑥ Add the five constraints.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 添加五个约束条件。
- en: ⑦ Solve the problem using PuLP's choice of solver.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用PuLP的求解器选择解决问题。
- en: ⑧ Print the results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 打印结果。
- en: 'Running listing C.2 produces the following results:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表C.2产生以下结果：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'C.2 Chapter 3: Blind search algorithms'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 第3章：盲搜索算法
- en: C.2.1 Exercises
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和真/假题：为以下每个问题选择正确的答案。
- en: '1.1.   Big *O* specifically describes the limiting behavior of a function (worst-case
    scenario) when the argument tends toward a particular value or infinity, usually
    in terms of simpler functions. What is the big *O* of this expression: nlog(*n*)
    + log(2*n*)?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   大O符号特别描述了当参数趋向于特定值或无穷大时函数的极限行为（最坏情况），通常用更简单的函数来表示。这个表达式的big O是什么：nlog(*n*)
    + log(2*n*)？
- en: a.  Linearithmic
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: a.  线性对数
- en: b.  Loglinear
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: b.  对数线性
- en: c.  Quasilinear
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: c.  准线性
- en: d.  All of the above
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: d.  所有上述选项
- en: 1.2.   Which blind search algorithm implements a stack operation for searching
    the states?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   哪个盲搜索算法实现了状态搜索的栈操作？
- en: a.  Breadth-first search (BFS)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: a.  广度优先搜索（BFS）
- en: b.  Uniform-cost search (UCS)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: b.  均匀代价搜索（UCS）
- en: c.  Bidirectional search (BS)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: c.  双向搜索（BS）
- en: d.  Depth-first search (DFS)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: d.  深度优先搜索（DFS）
- en: e.  None of the above
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上皆非
- en: 1.3.   A tree is a connected graph with no circuits and no self-loops.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   树是一个无环无自环的连通图。
- en: a.  True
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.4.   For a very large workspace where the goal is deep within the workspace,
    the number of nodes could expand exponentially, and a depth-first search will
    demand a very large memory requirement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   在一个非常大的工作空间中，目标位于工作空间的深处，节点数量可能会呈指数级增长，深度优先搜索将需要非常大的内存需求。
- en: a.  True
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.5.   Best-first is a mixed-depth and breadth-first search that uses heuristic
    values and expands the most desirable unexpanded node.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   最佳优先搜索是一种混合深度和广度优先搜索，它使用启发式值并扩展最期望的未扩展节点。
- en: a.  True
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.6.   In design problems or strategic functions, optimality is usually traded
    in for speed gains.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   在设计问题或战略函数中，通常为了速度的提升而牺牲最优性。
- en: a.  True
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.7.   Graph traversal algorithms outperform shortest path algorithms in applications
    where the weights of edges in a graph are all equal.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   在图中边的权重都相等的应用中，图遍历算法优于最短路径算法。
- en: a.  True
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.8.   In Dijkstra’s algorithm, the priority queue is implemented using which
    data structure?.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   在Dijkstra算法中，优先队列使用哪种数据结构实现？
- en: a.  Stack
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: a.  栈
- en: b.  Queue
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: b.  队列
- en: c.  Heap
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: c.  堆
- en: d.  Array
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: d.  数组
- en: 1.9.   When is breadth-first search optimal?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9. 广度优先搜索何时是最佳选择？
- en: a.  When there are fewer nodes
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: a. 当节点较少时
- en: b.  When all step costs are equal
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: b. 当所有步骤成本相等时
- en: c.  When all step costs are unequal
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: c. 当所有步骤成本不相等时
- en: d.  None of the above
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: 1.10. Which blind search algorithm combines DFS’s space-efficiency and BFS’s
    fast search by incrementing the depth limit until the goal is reached?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. 哪个盲搜索算法通过增加深度限制直到达到目标，结合了DFS的空间效率和 BFS的快速搜索？
- en: a.  Depth-limited search (DLS)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: a. 深度限制搜索（DLS）
- en: b.  Iterative deepening search (IDS)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: b. 迭代加深搜索（IDS）
- en: c.  Uniform-cost search (UCS)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: c. 均匀代价搜索（UCS）
- en: d.  Bidirectional search (BS)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: d. 双向搜索（BS）
- en: e.  None of the above
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: e. 以上都不是
- en: 1.11. Which term describes an algorithm with a computational complexity of *O*(*n*
    log*n*)?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11. 哪个术语描述了一个计算复杂度为 *O*(*n* log*n*) 的算法？
- en: a.  Logarithmic
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: a. 对数
- en: b.  Exponential
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: b. 指数
- en: c.  Quasilinear
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: c. 准线性
- en: d.  None of the above
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: 1.12. Which search algorithm is implemented with an empty first in, first out
    queue?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12. 哪个搜索算法使用一个空的前进先出队列实现？
- en: a.  Depth-first search
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: a. 深度优先搜索
- en: b.  Breadth-first search
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: b. 广度优先搜索
- en: c.  Bidirectional search
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: c. 双向搜索
- en: d.  None of the above
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: 2.   Consider the simplified map shown in figure C.2, where the edges are labeled
    with actual distances between the cities. State the path from city A to city M
    that would be produced by BFS and the path produced by DFS.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 考虑图C.2中显示的简化地图，其中边标有城市之间的实际距离。说明BFS和DFS产生的从城市A到城市M的路径。
- en: '![](../Images/APPC_F02_Khamis.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F02_Khamis.png)'
- en: Figure C.2 A simplified map
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.2 一个简化的地图
- en: '3.   Find the big *O* notation for the following functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 找出以下函数的大O表示法：
- en: a.  10*n* + nlog(*n*)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: a. 10*n* + nlog(*n*)
- en: b.  4 + *n*/5
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: b. 4 + *n*/5
- en: c.  *n*⁵ – 20*n*³ + 170*n* + 208
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: c. *n*⁵ – 20*n*³ + 170*n* + 208
- en: d.  *n* + 10log(*n*)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: d. *n* + 10log(*n*)
- en: 4.   Consider the search space in figure C.3, where S is the start node and
    G1 and G2 are the goal nodes. Edges are labeled with the value of a cost function;
    the number gives the cost of traversing the arc. Above each node is the value
    of a heuristic function; the number gives the estimate of the distance to the
    goal. Assume that uninformed search algorithms always choose the left branch first
    when there is a choice. For each of the depth-first search (DFS) and breadth-first
    search (BFS) strategies
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 考虑图C.3中的搜索空间，其中S是起始节点，G1和G2是目标节点。边标有成本函数的值；数字给出穿越弧的成本。每个节点上方是启发函数的值；数字给出到目标距离的估计。假设在存在选择时，无信息搜索算法总是首先选择左分支。对于深度优先搜索（DFS）和广度优先搜索（BFS）策略
- en: a.  Indicate which goal state is reached first (if any).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: a. 指出首先达到的目标状态（如果有）。
- en: b.  List, in order, all the states that are popped off the OPEN list.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: b. 按顺序列出从OPEN列表中弹出的所有状态。
- en: '![](../Images/APPC_F03_Khamis.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F03_Khamis.png)'
- en: Figure C.3 A graph search exercise
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.3 一个图搜索练习
- en: 5.   Solve the crossword puzzle in figure C.4.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 解决图C.4中的填字游戏。
- en: '![](../Images/APPC_F04_Khamis.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F04_Khamis.png)'
- en: Figure C.4 Blind search crossword puzzle
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.4 盲搜索填字游戏
- en: Across
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 横向
- en: 2.   A depth-first search with a predetermined depth limit
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 一个具有预定深度限制的深度优先搜索
- en: 7.   A blind search algorithm that solves the single-source shortest path problem
    for a weighted graph with non-negative edge costs
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 一个盲搜索算法，用于解决加权图的单源最短路径问题，其中边的成本为非负
- en: 8.   A search algorithm that combines forward and backward search
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 一个结合正向和反向搜索的搜索算法
- en: 10.   A graph traversal algorithm that first explores nodes going through one
    adjacent to the root, then the next adjacent, until it finds a solution or until
    it reaches a dead end
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 一个图遍历算法，首先探索通过根节点相邻的节点，然后是下一个相邻的节点，直到找到解决方案或达到死胡同
- en: 11.   A variant of Dijkstra’s algorithm that is appropriate for large graphs
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 一个适用于大型图的Dijkstra算法的变体
- en: 13.   A function that is slightly faster than linear complexity
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 13. 一个比线性复杂度略快的函数
- en: 14.   A graph in which multiple edges may connect the same pair of vertices
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 14. 一个图中可能有多条边连接相同的顶点对
- en: 15.   A last in, first out (LIFO) data structure
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 15. 后进先出（LIFO）数据结构
- en: Down
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 向下
- en: 1.   A search algorithm that combines DFS’s space-efficiency and BFS’s fast
    search by incrementing the depth limit until the goal is reached
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 一个搜索算法，通过增加深度限制直到达到目标，结合了DFS的空间效率和 BFS的快速搜索
- en: 2.   A graph used by Twitter to represent following
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 2. Twitter用来表示关注的图
- en: 3.   A graph traversal search algorithm that is preferred when the tree is deep
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   当树很深时，优先选择的图遍历搜索算法
- en: 4.   A generalization of a graph in which generalized edges can join any number
    of nodes
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   一种图的泛化，其中泛化边可以连接任意数量的节点
- en: 5.   The type of graph used in LinkedIn to represent users, groups, unregistered
    persons, posts, skills, and jobs
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   LinkedIn用于表示用户、群组、未注册人员、帖子、技能和工作的图形类型
- en: 6.   A notation used to describe the performance or complexity of an algorithm
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   用于描述算法性能或复杂性的符号
- en: 9.   The process of exploring the structure of a tree or a graph by visiting
    the nodes following a certain well-defined rule
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 9.   通过遵循某个定义良好的规则访问节点来探索树或图形结构的过程
- en: 12.   A first in, first out (FIFO) data structure
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 12.   一种先进先出（FIFO）数据结构
- en: '**Hint:** Spaces or dashes *must* be used if the answer consists of two or
    more words.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：如果答案由两个或多个单词组成，则必须使用空格或破折号。'
- en: C.2.2 Solutions
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.2 解决方案
- en: 1.   Multiple choice and true/false
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多选题和判断题
- en: 1.1.   d) All of the above
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.   d) 所有这些
- en: 1.2.   d) Depth-first search (DFS)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.   d) 深度优先搜索 (DFS)
- en: 1.3.   a) True
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.   a) 正确
- en: 1.4.   b) False
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.   b) 错误
- en: 1.5.   a) True
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5.   a) 正确
- en: 1.6.   b) False
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   b) 错误
- en: 1.7.   a) True
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   a) 正确
- en: 1.8.   c) Heap
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8.   c) 堆
- en: 1.9.   b) When all step costs are equal
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9.   b) 当所有步骤成本相等时
- en: 1.10. b) Iterative deepening search (IDS)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10. b) 迭代加深搜索（IDS）
- en: 1.11. c) Quasilinear
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11. c) 近线性
- en: 1.12. b) Breadth-first search
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12. b) 广度优先搜索
- en: 2.   The route obtained by BFS to go from A to M is
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   从A到M通过BFS得到的路径是
- en: 'A→B→H→C→E→I→L→D→F→J→K→M→H→G→J→K→M:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'A→B→H→C→E→I→L→D→F→J→K→M→H→G→J→K→M:'
- en: tracking back, the final route is A→H→L→M.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪回溯，最终路径是 A→H→L→M。
- en: The route obtained by DFS to go from A to M is A→B→H→C→E→F→G→J→K→I→M.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从A到M通过DFS得到的路径是 A→B→H→C→E→F→G→J→K→I→M。
- en: '3.   The solutions are the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   以下是一些解决方案：
- en: a.  *O*(nlogn)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: a.  *O*(nlogn)
- en: b.  *O*(*n*)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: b.  *O*(*n*)
- en: c.  *O*(*n*⁵)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: c.  *O*(*n*⁵)
- en: d.  *O*(logn)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: d.  *O*(logn)
- en: '4.   The solutions are the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   以下是一些解决方案：
- en: '| Search strategy | a | b |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 搜索策略 | a | b |'
- en: '| --- | --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Depth-first search** **(DFS)**Let’s assume that the nodes are expanded
    based on their lexicographical order (i.e., among the children of S, A is expanded
    first, since lexicographically, it is ordered before B and C). | G2 | S, A, D,
    H, J, G2 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **深度优先搜索** **(DFS)**假设节点根据它们的字典顺序扩展（即，在S的子节点中，A首先扩展，因为在字典上，它排在B和C之前）。 | G2
    | S, A, D, H, J, G2 |'
- en: '| **Breadth-first search** **(BFS)**The status of the queue evolves such that[S],
    [S,A,B,C], [S,A,B,C,D,H], [S,A,B,C,D,H,G1]Note: Since H is already visited by
    A, it is not pushed again to the queue when being visited by B. However, it is
    reached twice. | G1 | S, A, B, C, D, H, H, G1 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **广度优先搜索** **(BFS)**队列的状态演变如下[S]，[S,A,B,C]，[S,A,B,C,D,H]，[S,A,B,C,D,H,G1]注意：由于H已经被A访问过，当B访问它时，它不会被再次推入队列。然而，它被访问了两次。
    | G1 | S, A, B, C, D, H, H, G1 |'
- en: 5.   The crossword puzzle solutions are shown in figure C.5.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   跨字谜的解决方案显示在图C.5中。
- en: '![](../Images/APPC_F05_Khamis.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F05_Khamis.png)'
- en: Figure C.5 Blind search crossword puzzle solution
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.5 盲搜索字谜解决方案
- en: 'C.3 Chapter 4: Informed search algorithms'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.3 第4章：启发式搜索算法
- en: C.3.1 Exercises
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多选题和判断题：为以下每个问题选择正确的答案。
- en: 1.1   How many shortcuts will we have to add to the augmented graph if we decide
    to contract node E in figure C.6?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1   如果我们决定在图C.6中合并节点E，我们需要在增强图中添加多少条捷径？
- en: '![](../Images/APPC_F06_Khamis.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F06_Khamis.png)'
- en: Figure C.6 Contracting node E
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.6 合并节点E
- en: a.  0
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: a.  0
- en: b.  1
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: b.  1
- en: c.  2
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: c.  2
- en: d.  3
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: d.  3
- en: 1.2   The A* algorithm is a special version of
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2   A*算法是以下哪种算法的特殊版本？
- en: a.  Breadth-first search
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: a.  广度优先搜索
- en: b.  Depth-first search
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: b.  深度优先搜索
- en: c.  Hill climbing
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: c.  爬山法
- en: d.  Best-first search
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: d.  最佳优先搜索
- en: e.  Dijkstra’s algorithm
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: e.  Dijkstra算法
- en: 1.3   Which of the following is *not* a variant of the hill climbing algorithm?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3   以下哪项不是爬山算法的变体？
- en: a.  Complex hill climbing
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: a.  复杂的爬山法
- en: b.  Steepest-ascent hill climbing
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: b.  最陡上升爬山法
- en: c.  Random-restart hill climbing
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: c.  随机重启爬山法
- en: d.  Steepest-ascent hill climbing
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: d.  最陡上升爬山法
- en: e.  All of the above are variants of hill climbing.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: e.  所有这些都是爬山算法的变体。
- en: 1.4   If *f*(*n*) is the evaluation function (cost) of a path through *n* to
    the goal for each node, and *h*(*n*) is an estimated cost from *n* to the goal,
    such as the straight-line distance from *n* to the goal, what is the heuristic
    function of greedy best-first search?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4   如果*f*(*n*)是通过*n*到目标路径的评估函数（成本），而*h*(*n*)是从*n*到目标的估计成本，例如从*n*到目标的目标距离，那么贪婪最佳优先搜索的启发式函数是什么？
- en: a.  *f*(*n*) ≠ *h*(*n*)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: a.  *f*(*n*) ≠ *h*(*n*)
- en: b.  *f*(*n*) < *h*(*n*)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: b.  *f*(*n*) < *h*(*n*)
- en: c.  *f*(*n*) = *h*(*n*)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: c.  *f*(*n*) = *h*(*n*)
- en: d.  *f*(*n*) > *h*(*n*)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: d.  *f*(*n*) > *h*(*n*)
- en: 1.5   In the directed weighted graph in figure C.7, how many shortcuts are needed
    if we contract the white node?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5   在图C.7中的有向加权图中，如果我们收缩白色节点，需要多少条捷径？
- en: '![](../Images/APPC_F07_Khamis.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F07_Khamis.png)'
- en: Figure C.7 Directed graph
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.7 有向图
- en: a.  0
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: a.  0
- en: b.  1
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: b.  1
- en: c.  2
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: c.  2
- en: d.  3
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: d.  3
- en: e.  4
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: e.  4
- en: 1.6   The search strategy that uses problem-specific knowledge is known as
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6   使用特定问题知识的搜索策略被称为
- en: a.  Informed search
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: a.  启发式搜索
- en: b.  Best-first search
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: b.  最佳优先搜索
- en: c.  A* search
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: c.  A*搜索
- en: d.  Heuristic search
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: d.  启发式搜索
- en: e.  All of the above
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上所有
- en: 1.7   Which of the following is an algorithm used to solve the MST problem?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7   以下哪个算法用于解决最小生成树（MST）问题？
- en: a.  Kruskal
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: a.  克鲁斯卡尔
- en: b.  Borůvka
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: b.  博鲁夫卡
- en: c.  Jarník-Prim
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: c.  焦点-普里姆
- en: d.  Chazelle
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: d.  查泽勒
- en: e.  All of the above
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上所有
- en: 1.8   Hill climbing is an informed breadth-first search that demands little
    in terms of memory and computational overhead.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8   梯度上升是一种信息丰富的广度优先搜索，对内存和计算开销要求不高。
- en: a.  True
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.9   Node ordering methods for CH include
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 1.9   CH的节点排序方法包括
- en: a.  Edge difference
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: a.  边差异
- en: b.  Iterative updates
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: b.  迭代更新
- en: c.  Number of contracted neighbors
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: c.  收缩邻居的数量
- en: d.  Shortcut cover
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: d.  捷径覆盖
- en: e.  All of the above
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上所有
- en: 1.10 A* is optimal if *h*(*n*) is an admissible heuristic, i.e., *h*(*n*) never
    overestimates the cost to reach the goal.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 1.10 如果*h*(*n*)是可接受的启发式，即*h*(*n*)从不高估到达目标成本，那么A*是最佳的。
- en: a.  True
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.11 The edge difference is the number of shortcuts introduced when contracting
    a node minus the number of incoming edges onto the node.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 1.11 边差异是在收缩节点时引入的捷径数量减去进入节点的入边数量。
- en: a.  True
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.12 Best-first is a mixed depth- and breadth-first search that uses heuristic
    values and expands the most desirable unexpanded node.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 1.12 最佳优先搜索是一种混合深度和广度优先搜索，它使用启发式值并扩展最理想的未扩展节点。
- en: a.  True
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.13 What is the evaluation function in A* search?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 1.13 A*搜索中的评估函数是什么？
- en: a.  Estimated cost from the current node to the goal node
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: a.  从当前节点到目标节点的估计成本
- en: b.  Cost of the path through the current node to the goal node
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: b.  通过当前节点到目标节点的路径成本
- en: c.  Sum of the path cost through the current node to the goal node and the estimated
    cost from the current node to the goal node
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: c.  通过当前节点到目标节点的路径成本和从当前节点到目标节点的估计成本之和
- en: d.  Average of the path cost through the current node to the goal node and the
    estimated cost from the current node to the goal node
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: d.  通过当前节点到目标节点的路径成本和从当前节点到目标节点的估计成本的平均值
- en: e.  None of the above
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上都不是
- en: 1.14 Which search is complete and optimal when *h*(*n*) is consistent?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 1.14 当*h*(*n*)一致时，哪种搜索是完整的且最优的？
- en: a.  Best-first search
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: a.  最佳优先搜索
- en: b.  Depth-first search
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: b.  深度优先搜索
- en: c.  Both best-first and depth-first search
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: c.  最佳优先搜索和深度优先搜索
- en: d.  A* search
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: d.  A*搜索
- en: 1.15 In the contraction hierarchies (CH) algorithm, we contract nodes based
    on which of the following?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 1.15 在收缩层次（CH）算法中，我们根据以下哪个因素收缩节点？
- en: a.  Decreasing order of their importance
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: a.  重要性递减顺序
- en: b.  Increasing order of their importance
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: b.  重要性递增顺序
- en: 1.16 The A* search algorithm tries to reduce the total number of states explored
    by incorporating a heuristic estimate of the cost to get the goal from a given
    state.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 1.16 A*搜索算法通过结合从给定状态到达目标的启发式成本估计来尝试减少探索的总状态数。
- en: a.  True
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.17 The hill climbing algorithm is a local greedy search algorithm that tries
    to improve the efficiency of breadth-first search.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 1.17 梯度上升算法是一种局部贪婪搜索算法，它试图提高广度优先搜索的效率。
- en: a.  True
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.18 In CH, the importance of a node may change during the contraction process,
    necessitating the recomputation of its importance.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 1.18 在CH中，节点的重要性可能在收缩过程中发生变化，需要重新计算其重要性。
- en: a.  True
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.19 A beam search with a beam width equal to the number of nodes in each level
    is the same as
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: a.  Breadth-first search
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: b.  Depth-first search
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: c.  Hill climbing
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: d.  Best-first search
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: e.  Dijkstra’s algorithm
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 1.20 In CH, the order of contraction does not affect the query performance.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Consider the search space in figure C.8, where S is the start node and
    G1 and G2 are the goal nodes. The edges are labeled with the value of a cost function;
    the number gives the cost of traversing the arc. Above each node is the value
    of a heuristic function; the number gives the estimate of the distance to the
    goal. Using A* search strategy
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: a.  Indicate which goal state is reached first (if any)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: b.  List in order all the states that are popped off until one of the goal state
    is found
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F08_Khamis.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: Figure C.8 Search space
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 3.   In the word search puzzle shown in figure C.9, find the hidden terms used
    in this chapter. You can search horizontally (from left to right or from right
    to left), vertically (from top to bottom or from bottom to top), or diagonally.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F09_Khamis.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: Figure C.9 Informed search word-search puzzle
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: C.3.2 Solutions
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 1.1   a) 0 (no shortcut needed because a witness path exists between A and D)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 1.2   d) Best-first search
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 1.3   a) Complex hill climbing
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 1.4   c) *f*(*n*) = *h*(*n*)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 1.5   c) 2
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 1.6   e) All of the above
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 1.7   e) All of the above
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 1.8   b) False (It is a variant of depth-first search.)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 1.9   e) All of the above
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 a) True
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 b) False (Edge difference is the number of shortcuts introduced when contracting
    a node minus the total degree of the node; i.e., the sum of the number of incoming
    edges onto the node plus the number of outgoing edges emanating from the node.)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 1.12 a) True
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 1.13 b) Cost of the path through the current node to the goal node
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 1.14 d) A* search
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 1.15 b) Increasing order of their importance
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 1.16 a) True
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 1.17 b) False
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 1.18 a) True
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 1.19 a) Breadth-first search
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 1.20 b) False (The order of contraction does not affect the success of CH but
    will affect the preprocessing time and the query time. Some contraction ordering
    systems minimize the number of the shortcuts added in the augmented graph, and
    thus the overall running time.)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The order of expansion is based on the sum of edge weights *g*(*n*) and
    the heuristic estimation *h*(*n*); i.e., *f*(*n*) = *g*(*n*) + *h*(*n*). For example,
    starting from S, *f*(A) = 8, *f*(B) = 18, and *f*(C) = 9, so the queue would look
    like [A,B,C] because *f*(A) < *f*(C) < *f*(B).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: At the next step, when A is popped off the queue, nodes D and H are evaluated
    such that *f*(D) = *d*(S,A) + *d*(A,D) + *h*(D) = 1 + 5 + 4 = 10, and *f*(H) =
    *d*(S,A) + *d*(A,H) + *h*(H) = 19, and pushing them onto the queue in order will
    result in [A,C,D,B,H].
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the next node to be expanded would be C, which adds E and F to the
    queue with *f*(E) = 11 and *f*(F) = 19: [A,C,D,E,B,H,F]'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the next node is D, which causes an update on *f*(H) = *d*(S,A) + *d*(A,D)
    + *d*(D,H) + *h*(H) = 1 + 5 + 2 + 6 = 14 that subsequently repositions it in the
    queue: [A,C,D,E,H,B,F]. The same strategy should be followed until one of the
    goals is found.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一个节点是 D，这导致 *f*(H) = *d*(S,A) + *d*(A,D) + *d*(D,H) + *h*(H) = 1 + 5 + 2
    + 6 = 14 的更新，随后将其重新定位到队列中：[A,C,D,E,H,B,F]。应遵循相同的策略，直到找到其中一个目标。
- en: a.  G1
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: a.  G1
- en: b.  S, A, C, D, E, H, B, G1
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: b.  S, A, C, D, E, H, B, G1
- en: 3.   The solution to the word search puzzle is shown in figure C.10.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   单词搜索谜题的解决方案如图 C.10 所示。
- en: '![](../Images/APPC_F10_Khamis.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F10_Khamis.png)'
- en: Figure C.10 Informed search word-search puzzle solution
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.10 信息搜索单词搜索谜题解决方案
- en: The word directions and start points are formatted as (direction, *X, Y*).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 方向和起点以 (方向, *X, Y*) 的格式表示。
- en: A-START (E, 7, 10)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: A-START (E, 7, 10)
- en: BEAM SEARCH (E, 8, 6)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: BEAM SEARCH (E, 8, 6)
- en: BEST-FIRST (E, 8, 9)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: BEST-FIRST (E, 8, 9)
- en: DEPTH-FIRST (E, 7, 12)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: DEPTH-FIRST (E, 7, 12)
- en: DOWNWARD GRAPH
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: DOWNWARD GRAPH
- en: (E, 3, 11)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: (E, 3, 11)
- en: EDGE DIFFERENCE (E, 2, 4)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: EDGE DIFFERENCE (E, 2, 4)
- en: HAVERSINE (E, 2, 8)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: HAVERSINE (E, 2, 8)
- en: HILL CLIMBING (E, 5, 1)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: HILL CLIMBING (E, 5, 1)
- en: INFORMED SEARCH (E, 3, 3)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: INFORMED SEARCH (E, 3, 3)
- en: KRUSKAL ALGORITHM (E, 2, 7)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: KRUSKAL ALGORITHM (E, 2, 7)
- en: WITNESS PATH (S,1, 1)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: WITNESS PATH (S,1, 1)
- en: 'C.4 Chapter 5: Simulated annealing'
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.4 第 5 章：模拟退火
- en: C.4.1 Exercises
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.4.1 练习
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和判断题：为以下每个问题选择正确的答案。
- en: 1.1   Simulated Annealing, unlike hill climbing, incorporates a probabilistic
    mechanism that allows it to accept downward steps, influenced by the current temperature
    and the quality of the move being considered.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1   与爬山法不同，模拟退火结合了概率机制，允许它接受下降步骤，受当前温度和考虑的移动质量的影响。
- en: a.  True
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.2   Simulated annealing is an optimization technique that always guarantees
    finding the global optimum solution.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2   模拟退火是一种优化技术，它始终保证找到全局最优解。
- en: a.  True
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.3   Dual annealing is an implementation of generalized hill climbing.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3   双重退火是广义爬山法的实现。
- en: a.  True
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.4   In totally adaptive SA, a random combination of previously accepted steps
    and parameters are used to estimate new steps and parameters.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4   在完全自适应的模拟退火中，使用先前接受的一组步骤和参数的随机组合来估计新的步骤和参数。
- en: a.  True
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.5   The simulated annealing algorithm explores more of the search space when
    the temperature gets lower.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5   当温度降低时，模拟退火算法探索更多的搜索空间。
- en: a.  True
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 1.6.   Which cooling schedule asymptotically converges toward the global minimum
    but requires prohibitive computing time?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.   哪种冷却计划在渐近收敛到全局最小值时需要可观的计算时间？
- en: a.  Linear cooling schedule
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: a.  线性冷却计划
- en: b.  Geometric cooling schedule
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: b.  几何冷却计划
- en: c.  Logarithmic cooling schedule
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: c.  对数冷却计划
- en: d.  Exponential cooling schedule
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: d.  指数冷却计划
- en: e.  Nonmonotonic adaptive cooling schedule
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: e.  非单调自适应冷却计划
- en: 1.7.   SA uses a thermal jump to avoid getting trapped in local minima while
    quantum annealing relies on quantum tunneling.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7.   模拟退火使用热跃迁来避免陷入局部最小值，而量子退火则依赖于量子隧穿。
- en: a.  True
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: a.  正确
- en: b.  False
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: b.  错误
- en: 2.   The Rosenbrock function, often referred to as the “valley” or “banana”
    function, is a nonconvex function that is defined as *f*(*x*,*y*) = (1 – *x*)²
    + 100(*y* – *x*²)². This is a standard test function and quite tough for most
    conventional solvers.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   罗森布鲁克函数，通常被称为“山谷”或“香蕉”函数，是一个非凸函数，定义为 *f*(*x*,*y*) = (1 – *x*)² + 100(*y*
    – *x*²)²。这是一个标准的测试函数，对于大多数传统求解器来说相当困难。
- en: a.  Use listing 5.1 or 5.2 or implement your own version of the simulated annealing
    algorithm from scratch or using one the libraries mentioned in section A.4 of
    appendix A to find the global minimum of this function.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: a.  使用列表 5.1 或 5.2 或从头开始实现模拟退火算法的版本，或者使用附录 A 中 A.4 节提到的库来找到该函数的全局最小值。
- en: 'b.  This banana function is still relatively simple, as it has a curved narrow
    valley. Other functions, such as the egg crate function, are strongly multimodal
    and highly nonlinear. Solve this egg crate function as an example of a highly
    nonlinear multimodal function: *f*(*x*,*y*) = *x*² + *y*² + 25[sin²(*x*) + sin²(*y*)].
    Consider the domain (*x*,*y*) ∈ [–5,5] × [–5,5]. It would take about 2,500 evaluations
    to get an optimal solution accurate to the third decimal place.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: b.  这个香蕉函数仍然相对简单，因为它有一个弯曲的狭窄山谷。其他函数，如蛋格函数，具有强烈的多个峰值和高度非线性。以下是一个高度非线性多峰函数的例子：*f*(*x*,*y*)
    = *x*² + *y*² + 25[sin²(*x*) + sin²(*y*)]。考虑域(*x*,*y*) ∈ [–5,5] × [–5,5]。要得到一个精确到小数点后三位的最佳解，大约需要2,500次评估。
- en: c.  Investigate the rate of convergence of simulated annealing for different
    cooling schedules.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: c.  调查模拟退火对不同冷却计划的收敛速度。
- en: d.  For standard SA, the cooling schedule is a monotonically decreasing function.
    There is no reason why we should not use other forms of cooling. For example,
    we can use *T*(*i*) = *T*[o] cos²(*i*)*e*^–*^α^i*, *α* *> 0*. Modify the code
    implemented in the previous step to study the behavior of various functions as
    a cooling schedule.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: d.  对于标准SA，冷却计划是一个单调递减的函数。我们没有理由不使用其他形式的冷却。例如，我们可以使用 *T*(*i*) = *T*[o] cos²(*i*)*e*^–*^α^i*,
    *α* > 0。修改之前步骤中实现的代码，以研究各种函数作为冷却计划的行为。
- en: 3.   Modify listing 5.5, or use ASA-GS [2], or implement your own version of
    simulated annealing to conduct a comparative study between different TSP datasets
    (see listing B.2 in appendix B to see how to get access to TSP instances). Fill
    in table C.1 with the tour length obtained by simulated annealing.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   修改列表5.5，或使用ASA-GS [2]，或实现自己的模拟退火版本以对不同TSP数据集进行对比研究（参见附录B中的列表B.2以了解如何获取TSP实例）。用模拟退火得到的行程长度填写表C.1。
- en: Table C.1 SA solutions for different TSP datasets
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.1 不同TSP数据集的SA解
- en: '| Dataset | Best known solution | SA solution | CPU time (s) |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 数据集 | 已知最佳解 | SA解 | CPU时间（秒） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| burma14ulysses22oliver30att48eil51eil75kroA100d198 | 30.875875.665142033,52442653521,28215,780
    |  |  |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 缅甸14乌利塞斯22奥利弗30阿特48艾尔51艾尔75克罗A100d198 | 30.875875.665142033,52442653521,28215,780
    |  |  |'
- en: '4.   Solve TSP for 20 major US cities as shown in figure C.11\. In this TSP,
    a travelling salesman must visit a number US cities starting from a specific city.
    Assume the following cities, defined by their names and GPS latitude and longitude
    coordinates: New York City (40.72, –74.00); Philadelphia (39.95, –75.17); Baltimore
    (39.28, –76.62); Charlotte (35.23, –80.85); Memphis (35.12, –89.97); Jacksonville
    (30.32, –81.70); Houston (29.77, –95.38); Austin (30.27, –97.77); San Antonio
    (29.53, –98.47); Fort Worth (32.75, –97.33); Dallas (32.78, –96.80); San Diego
    (32.78, –117.15); Los Angeles (34.05, –118.25); San Jose (37.30, –121.87); San
    Francisco (37.78, –122.42); Indianapolis (39.78, –86.15); Phoenix (33.45, –112.07);
    Columbus (39.98, –82.98); Chicago (41.88, –87.63); and Detroit (42.33, –83.05).
    Visualize the cities and the generated solution as a NetworkX graph using the
    GPS coordinates of each city.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   解决图C.11所示的20个主要美国城市的TSP问题。在这个TSP中，旅行商必须从一个特定的城市开始访问多个美国城市。假设以下城市，由它们的名称和GPS纬度和经度坐标定义：纽约市（40.72,
    –74.00）；费城（39.95, –75.17）；巴尔的摩（39.28, –76.62）；夏洛特（35.23, –80.85）；孟菲斯（35.12, –89.97）；杰克逊维尔（30.32,
    –81.70）；休斯顿（29.77, –95.38）；奥斯汀（30.27, –97.77）；圣安东尼奥（29.53, –98.47）；沃斯堡（32.75,
    –97.33）；达拉斯（32.78, –96.80）；圣地亚哥（32.78, –117.15）；洛杉矶（34.05, –118.25）；圣何塞（37.30,
    –121.87）；旧金山（37.78, –122.42）；印第安纳波利斯（39.78, –86.15）；凤凰城（33.45, –112.07）；哥伦布（39.98,
    –82.98）；芝加哥（41.88, –87.63）；底特律（42.33, –83.05）。使用每个城市的GPS坐标将城市和生成的解决方案可视化为一个NetworkX图。
- en: '![](../Images/APPC_F11_Khamis.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F11_Khamis.png)'
- en: Figure C.11 Travelling salesman problem (TSP) for 20 largest US cities
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.11 20个最大美国城市的旅行商问题（TSP）
- en: 5.   Solve the crossword puzzle in figure C.12.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   解决图C.12中的填字游戏
- en: '![](../Images/APPC_F12_Khamis.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F12_Khamis.png)'
- en: Figure C.12 Simulated annealing crossword puzzle
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.12 模拟退火填字游戏
- en: Across
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 横向
- en: 6.   An optimization process that searches an energy landscape to find the optimal
    or near-optimal solution by applying quantum effects
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   通过应用量子效应在能量景观中搜索以找到最优或近似最优解的优化过程
- en: 7.   The probability of acceptance or rejection of neighboring solutions
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 7.   接受或拒绝邻近解的概率
- en: 10.   A cooling process by which the temperature is decreased very quickly during
    the first iterations but the speed of the exponential decay is slowed down later
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 10.   一种冷却过程，在最初的迭代中温度迅速降低，但随后指数衰减的速度减慢
- en: 11.   A cooling schedule in which the maximum number of iterations needs to
    be specified
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 11.   需要指定最大迭代次数的冷却计划
- en: 12.   Compared to this search algorithm, the main difference is that SA probabilistically
    allows downward steps controlled by current temperature and how bad a move is.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 12.   与此搜索算法相比，主要区别在于SA概率性地允许由当前温度和移动的好坏控制的向下步骤。
- en: 13.   A cooling schedule that requires a prohibitive computing time
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 13.   一种需要禁用计算时间的冷却计划
- en: Down
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 向下
- en: 1.   A stochastic or probabilistic model that describes a sequence of possible
    moves in which the probability of each move depends only on the state attained
    in the previous move
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   一种随机或概率模型，描述了一系列可能的移动，其中每个移动的概率仅取决于前一个移动达到的状态
- en: 2.   A cooling schedule that explicitly takes into consideration how the search
    is progressing
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   一种明确考虑搜索进展情况的冷却计划
- en: 3.   A cooling schedule that decreases the temperature by a cooling factor
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   一种通过冷却因子降低温度的冷却计划
- en: 4.   An optimization process based on the physical annealing process
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   基于物理退火过程的优化过程
- en: 5.   Probability distribution used in transition probability of simulated annealing
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   用于模拟退火转换概率的概率分布
- en: 8.   A quantum mechanical phenomenon whereby a wavefunction can propagate through
    a potential barrier
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 8.   一种量子力学现象，其中波函数可以通过势垒传播
- en: 9.   State of the system at which no better or worse moves are being accepted
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 9.   系统状态，其中不接受更好或更差的移动
- en: 'Hint: Spaces and dashes *must* be used if the answer consists of two words.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果答案由两个单词组成，则必须使用空格和破折号。
- en: C.4.2 Solutions
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.4.2 解决方案
- en: 1.   Multiple choice and true/false
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   多项选择题和真/假题
- en: 1.1   a) True
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1   a) 正确
- en: 1.2   b) False
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2   b) 错误
- en: 1.3   b) False (Dual annealing is an implementation of the generalized simulated
    annealing algorithm.)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3   b) 错误（双重退火是广义模拟退火算法的一种实现。）
- en: 1.4   a) True
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4   a) 正确
- en: 1.5   b) False (The simulated annealing algorithm exploits the search space
    when the temperature gets lower.)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5   b) 错误（模拟退火算法在温度降低时利用搜索空间。）
- en: 1.6   c) Logarithmic cooling schedule
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6   c) 对数冷却计划
- en: 1.7   a) True
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7   a) 正确
- en: 2.   The generic forms of __problem_base.py and _sa.py, provided in the book’s
    GitHub repo, can be used to solve this problem. You can also modify listing 5.1
    or 5.2 to solve this problem.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   书中GitHub仓库提供的__problem_base.py和_sa.py的通用形式可以用来解决这个问题。您还可以修改列表5.1或5.2来解决这个问题。
- en: 3.   You can use listing 5.5 or the ASA-GS implementation [1] to run simulated
    annealing with selected parameters on different TSP instances and report your
    results. In listing 5.5, replace the permanent link with the link corresponding
    to the TSP instance. For example, click on burma14.tsp, click on the button with
    three dots at the upper-right corner, and select Copy Permalink. Consider tuning
    the algorithm’s parameters to get close to the best tour length known (so far)
    for each dataset.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   您可以使用列表5.5或ASA-GS实现[1]在不同的TSP实例上运行具有选定参数的模拟退火，并报告您的结果。在列表5.5中，将永久链接替换为对应于TSP实例的链接。例如，点击burma14.tsp，点击右上角的三个点按钮，并选择复制永久链接。考虑调整算法的参数，以接近每个数据集已知的最佳行程长度（到目前为止）。
- en: 4.   The next listing shows how to use the generic solver implemented as part
    of the optalgo-tools package to solve this problem.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   以下列表显示了如何使用optalgo-tools包中实现的一般求解器来解决这个问题。
- en: Listing C.3 Solving TSP using SA
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.3 使用SA解决TSP问题
- en: '[PRE3]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a continuation of listing C.3, the following code shows how to solve this
    problem using the simanneal Python library:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表C.3的延续，以下代码展示了如何使用simanneal Python库来解决这个问题：
- en: '[PRE4]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Test the annealer with a TSP as per the simanneal module.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用simanneal模块中的TSP测试退火器。
- en: ② Swap two cities in the route.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在路线上交换两个城市。
- en: ③ Calculate the length of the route.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 计算路线的长度。
- en: ④ Initial state, a randomly ordered itinerary
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 初始状态，一个随机排序的行程
- en: ⑤ Set New York City as the home city.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将纽约市设为家乡城市。
- en: ⑥ Print the route and its cost.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印路线及其成本。
- en: 'As a continuation, the following code can be used to visualize the problem
    and its solution:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 作为延续，以下代码可以用来可视化问题和解决方案：
- en: '[PRE5]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Reverse the lat and long for a correct visualization.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ① 反转经纬度以正确可视化。
- en: ② Create an independent shallow copy of the graph and attributes.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个独立的浅拷贝的图和属性。
- en: ③ Draw the closest edges on each node only.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 仅在每个节点上绘制最近的边。
- en: ④ Draw the route.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 绘制路线。
- en: ⑤ Visualize.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 可视化。
- en: Running this code produces the visualization shown in figure C.13.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F13_Khamis.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
- en: Figure C.13 Solution for the 20 major US cities TSP using simanneal
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A shows examples of available Python libraries, such as scikit-opt,
    DEAP, OR-Tools and simanneal, that can solve this problem using simulated annealing
    and other metaheuristics.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 5.   The solution to the crossword puzzle is shown in figure C.14.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F14_Khamis.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
- en: Figure C.14 Simulated annealing crossword puzzle solution
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'C.5 Chapter 6: Tabu search'
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.5.1 Exercises
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   In TS, non-improving solutions are conditionally accepted in order to
    escape from a local optimum.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   A frequency-based memory maintains information about how recently a search
    point has been visited.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   In order to increase the efficiency for solving some problems, TS uses
    memory via a tabu list to avoid revisiting recently visited neighborhoods.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   The stopping criteria to terminate TS can be
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: a.  Neighborhood is empty
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: b.  Number of iterations is larger than a specified threshold
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: c.  Evidence shows that an optimum solution has been obtained
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: d.  All of the above (a, b, and c)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above (a, b, or c)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Tabu-active moves are stored in a long-term memory.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   For large and difficult problems (scheduling, quadratic assignment, and
    vehicle routing), tabu search obtains solutions that often represent a global
    optimum or near-optimum.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   Recency memory is used to increase intensification of the search by remembering
    neighbors with good solutions.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   Aspiration criteria are used to revoke tabu-active moves as a way to
    avoid search stagnation.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   TS can be considered a combination of random search and memory structures.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. When the length of the tabu list is too small, the algorithm can get trapped
    in cycles, and when it’s too long, many moves could be prevented at each iteration,
    leading to stagnation.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 2.   As shown in appendix B, the Schwefel function is complex, with many local
    minima. Figure C.15 shows the two-dimensional form of the function.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F15_Khamis.png)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
- en: Figure C.15 The Schwefel function
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Modify listing 6.1 to solve the Schwefel function using tabu search.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Apple filed US Patent 7790637 B2 for a composite laminate that includes
    seven sheets stacked one over another and a scrim layer. Seven planar sheets of
    fibers impregnated with a resin (e.g., a viscous liquid substance) are placed
    with different orientations to improve the strength of the composite laminate,
    as illustrated in figure C.16\. The scrim layer is the cosmetic layer, which is
    a different material and is bonded to the outside to improve the cosmetic exterior
    surface and consistent appearance.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F16_Khamis.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
- en: Figure C.16 Composite laminate design—Apple’s US patent 7790637 B2
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The way the seven layers are ordered results in different levels of strength
    in the composite laminate. Assume that the pairwise strength gain or loss is given
    by the empirical values in figure C.17\. Positive values represent a strength
    gain in the case of contact between the two layers (up or down), and negative
    values represent the strength loss.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F17_Khamis.png)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
- en: Figure C.17 Pairwise strength gain or loss
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we want to find the optimal ordered combination (i.e., permutation)
    of the seven fiber sheets to maximize the composite laminate strength. Perform
    four hand iterations of tabu search to show the steps of the algorithm to solve
    this problem. Write Python code to solve this problem.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Write Python code to use tabu search to solve the simple assembly line
    balancing problem, type 1 (SALBP-1), with the machine and worker constraints described
    in Kamarudin and Rashid’s paper “Modelling of Simple Assembly Line Balancing Problem
    Type 1 (SALBP-1) with Machine and Worker Constraints” [3].
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 5.   In the word search puzzle in figure C.18, find the hidden terms commonly
    used in tabu search. You can search horizontally (from left to right or right
    to left), vertically (from top to bottom or bottom to top), or diagonally.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F18_Khamis.png)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
- en: Figure C.18 TS word search puzzle
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: C.5.2 Solutions
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   a) True
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   b) False (Recency-based memory maintains information about how recently
    a search point has been visited.)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   a) True
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   d) All of the above (a, b, and c)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   b) False (Tabu-active moves are stored in a short-term memory.)
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   a) True
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   a) True
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   a) True
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   b) False (TS can be considered a combination of combination of local
    search and memory structures.)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. a) True
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Listing C.4 in the book’s GitHub repository shows how to solve the Schwefel
    function using tabu search.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Figure C.19 shows the TS initialization and first iteration for the composite
    laminate problem. The number of possible permutations without repetition is *n*!.
    The number of possible solutions for ordering the seven fiber sheets is 7! = 5,040.
    To generate a neighboring solution, fiber sheet swapping can be used. The neighborhood
    is defined as any other solution that is obtained by a pairwise exchange of any
    two sheets in the solution. If we let the number of nodes *n* = 7, pairwise exchange
    *k* = 2. The number of neighbors is the number of combinations without repetition
    *C*(*n*,*k*) or *n*-choose-*k*: *C*(*n*,*k*) = *n*! / (*k*!(*n* – *k*)!) = 21
    neighbors. Let’s assume that the tabu tenure is set at 3 iterations.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F19_Khamis.png)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
- en: Figure C.19 TS initialization for the composite laminate design
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Figures C.20 through C.22 show iterations 1, 2, and 3 respectively.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F20_Khamis.png)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
- en: Figure C.20 Composite laminate design—iteration 1
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F21_Khamis.png)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
- en: Figure C.21 Composite laminate design—iteration 2
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F22_Khamis.png)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
- en: Figure C.22 Composite laminate design—iteration 3
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration, we generate a number of candidate solution using layer swapping,
    and we select the move that results in the maximum delta value, which is the difference
    between the previous solution and the new solution in terms of strength gain.
    In the next iteration, shown in figure C.23, there is no move with a positive
    gain, so the best (non-tabu) move will be non-improving. The move (a,e) is selected,
    since it has a tabu tenure of only one iteration compared to the other tabu-active
    best move (a,b). This means that the tabu status of (a,e) can be overridden by
    applying the aspiration criteria.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F23_Khamis.png)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
- en: Figure C.23 Composite laminate design—TS iteration 4 and aspiration criterion
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: To show the diversification using frequency-based memory, assume that the solution
    reached after 26 iterations is [a c f b g e d], and the strength value is 23\.
    Assume that we will penalize the solution based on its frequency in usage (a highly
    repetitive solution gets more penalties). The tabu structure is updated based
    on both recency-based (upper triangle) and frequency-based (lower triangle) memories,
    as shown in figure C.24a. The five top candidates after swapping are shown in
    figure C.24b.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F24_Khamis.png)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
- en: Figure C.24 a) Recency- and frequency-based memory, b) five top candidates after
    swapping with their penalty values
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: We need to diversify when no admissible improving moves exist. Non-improving
    moves are penalized by assigning larger penalties to more frequent swaps. According
    to the penalized value, swap (a,f) is chosen. Listing C.5 shows the solution of
    the composite laminate problem using tabu search.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.5 Solving the composite laminate problem using tabu search
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Import the SHEETS problem instance, which contains the composite laminate
    design problem description.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: ② Import the tabu search solver.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create different sheets objects. For a complete list of the supported parameters,
    see the SHEETS class in the sheets.py file in the optalgotools.problems module.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a TS object to help in solving the composite laminate problem.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Get an initial random solution, and check its cost.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Run TS, and evaluate the best solution cost.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Listing C.6 shows a snippet of the code for solving the SALBP-1 problem
    using tabu search.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.6 Solving the SALBP-1 problem using tabu search
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Read the data from appendix B directly using the URL.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the cycle time.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: ③ Get an initial solution.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: ④ Ensure the feasibility of the solution considering the task precedence constraint.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Run the tabu search.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Calculate the smoothing index of the best solution.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Visualize the solution.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the complete code produces the following output:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Complete code is available in the book’s GitHub repo.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 5.   The solution to the word search puzzle is shown in figure C.25.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F25_Khamis.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
- en: Figure C.25 TS word search puzzle solution
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: The word directions and start points are formatted as (Direction, *X, Y*)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: ADAPTIVE MEMORY (W, 17, 13)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: ASPIRATION CRITERIA (W, 23, 15)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: DIVERSIFICATION (W, 23, 14)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: FREQUENCY-BASED MEMORY (W, 21, 7)
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: INTENSIFICATION (E, 8, 8)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: LOCAL SEARCH (W, 16, 6)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: LONG-TERM MEMORY (E, 1, 10)
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: RECENCY (E, 12, 1)
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: RESPONSIVE EXPLORATION (W, 23, 16)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: SENSORY MEMORY (W, 16, 3)
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: SHORT-TERM MEMORY (W, 16, 4)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: TABU LIST (E, 6, 12)
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: TABU SEARCH (E, 1, 5)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: TABU STRUCTURE (W, 23, 2)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: TABU TENURE (E, 12, 5)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: WORKING MEMORY (W, 20, 9)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'C.6 Chapter 7: Genetic algorithm'
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.6.1 Exercises
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   Given a binary string 1101001100101101 and another binary string yxyyxyxxyyyxyxxy
    in which the values 0 and 1 are denoted by x and y, what offspring result from
    applying 1-point crossover on the two strings at a randomly selected recombination
    point?
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: a.  yxxyyyxyxxy11010 and yxyyx01100101101
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: b.  11010yxxyyyxyxxy and yxyyx01100101101
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: c.  11010yxxyyyxyxxy and 01100101101yxyyx
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: d.  None of the above
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   In binary genetic algorithms, how does the bitwise mutation operator
    work?
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: a.  It swaps the positions of two randomly chosen bits.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: b.  It averages the values of two randomly chosen bits.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: c.  It flips a randomly chosen bit in the binary representation.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: d.  It reverses the order of a randomly chosen segment of bits.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   The name of the position on the chromosome every gene has is called
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: a.  Allele
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: b.  Locus
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: c.  Genotype
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: d.  Phenotype
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: e.  None of the above
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   In the steady-state model of genetic algorithms, how are new offspring
    introduced into the population?
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: a.  By replacing the entire population
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: b.  By replacing a small fraction of the population
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: c.  By adding them to the existing population
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: d.  By replacing the worst individuals in the population
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Suppose you have the population shown in table C.2.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Table C.2 Given population
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '| Individual | Individual 1 | Individual 2 | Individual 3 | Individual 4 |
    Individual 5 |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
- en: '| Fitness | 12 | 25 | 8 | 53 | 10 |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
- en: 'Rank-based selection attempts to remove problems of fitness-proportionate selection
    (FPS) by basing selection probabilities on relative rather than absolute fitness.
    Assume that the ranking process is linear ranking, as follows:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F25_Khamis-EQ01.png)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
- en: where *N* is the number of individuals in the population and *r* is the rank
    associated with each individual in this population (the least fit individual has
    *r* = 1, the fittest individual *r* = *N*). *SP* is the selection pressure (assume
    *SP* = 1.5). Which two individuals will be selected if we use this linear ranking-based
    selection?
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: a.  Individuals 1 and 2
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: b.  Individuals 1 and 3
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: c.  Individuals 2 and 3
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: d.  Individuals 2 and 4
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: e.  Individuals 3 and 4
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: f.  None of the above
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   Which selection method in genetic algorithms involves choosing a fixed
    number of individuals at random and selecting the best among them?
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: a.  Roulette wheel selection
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: b.  Rank selection
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: c.  Tournament selection
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: d.  Stochastic universal sampling (SUS)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   In P-metaheuristics, the computational cost of the Latin hypercube strategy
    is the same as the pseudo-random initialization strategy.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   In binary genetic algorithms, which type of chromosome encoding is used?
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: a.  Real value
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: b.  Permutation
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: c.  Binary
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: d.  Tree
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   Which of the following methods can be used to convert a minimization
    problem into a maximization problem in optimization?
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: a.  Adding a constant to the objective function
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: b.  Taking the reciprocal of the objective function
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: c.  Negating the objective function
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: d.  Scaling the objective function by a factor
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. Which of the following is an advantage of the steady-state model compared
    to the generational model in genetic algorithms?
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: a.  Faster convergence
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: b.  Better diversity preservation
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: c.  Lower computational cost
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: d.  More robust mutation operators
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 1.11. In a binary genetic algorithm, what does the mutation operator do to an
    individual’s genes?
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: a.  Reverses the gene value (1 to 0 or 0 to 1)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: b.  Randomly assigns a new gene value (0 or 1)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: c.  Swaps the positions of two genes
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: d.  Combines genes from different individuals
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 1.12. Which of the following is a commonly used crossover method in binary genetic
    algorithms?
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: a.  Single-point crossover
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: b.  Two-point crossover
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: c.  Uniform crossover
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: d.  All of the above
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 1.13. What is the primary difference between generational and steady-state models
    in genetic algorithms?
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: a.  Selection methods
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: b.  Crossover operators
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: c.  Mutation operators
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: d.  Replacement strategies
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 1.14. Which crossover method in binary genetic algorithms involves exchanging
    genetic material between parent chromosomes based on a predefined probability
    for each gene?
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: a.  Single-point crossover
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: b.  Two-point crossover
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: c.  Uniform crossover
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: d.  Arithmetic crossover
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 1.15. What is a potential disadvantage of using a high mutation rate in binary
    genetic algorithms?
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: a.  Loss of diversity in the population
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: b.  Premature convergence
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: c.  Disruption of good solutions
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: d.  Decreased selection pressure
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 1.16. In the generational model of genetic algorithms, what happens to the population
    in each generation?
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: a.  A small fraction of the population is replaced.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: b.  The entire population is replaced.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: c.  The population remains the same.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: d.  The population size is gradually reduced.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 1.17. When using a transformation to convert a minimization problem into a maximization
    problem, which property of the optimal solution must be preserved?
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: a.  Feasibility
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: b.  Optimality
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: c.  Dominance
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: d.  Convexity
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 1.18. What are the primary operators used in genetic algorithms?
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: a.  Initialization, pooling, and backpropagation
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: b.  Selection, crossover, and mutation
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: c.  Convolution, pooling, and activation
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: d.  Forward propagation, backward propagation, and optimization
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 1.19. Which of the following is an advantage of the generational model compared
    to the steady-state model in genetic algorithms?
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: b.  Improved diversity preservation
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: b.  Faster convergence
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: c.  Lower computational cost
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: d.  Better handling of constraints
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '1.20. Suppose you need to solve the following function maximization problem
    using a binary genetic algorithm:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F25_Khamis-EQ02.png)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
- en: where
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: •   *O[i]* is the objective function value of individual *i* and *O[i]* = –(*x*
    – 6.4)².
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: •   *N* is the population size.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: •   *V* is a large value to ensure non-negative fitness values.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: The value of *V* is the maximum value of the second term of the fitness function
    *f*(*x*) so that the fitness value corresponding to the maximum value of the objective
    function is 0\. How many bits are required to represent the solution with precision
    0.1?
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: a.   6 bits
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: b.   7 bits
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: c.   8 bits
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: d.   9 bits
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: e. 10 bits
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: f.  None of the above
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The Ackley function is a nonlinear, multimodal function with a large number
    of local minima, making it a challenging optimization problem. The general form
    of the Ackley function is
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F25_Khamis-EQ03.png)'
  id: totrans-716
  prefs: []
  type: TYPE_IMG
- en: where
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: •   *x* = (*x*[1], *x*[2], ..., *x[d]*) is the input vector.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: •   *a, b*, and *c* are positive constants (usually *a* = 20, *b* = 0.2, and
    *c* = 2 × *π*).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: •   d is the dimension of the input vector.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: The function has a global minimum at the origin (*x[i] =* 0), where *f(x) =*
    0, and it is surrounded by several local minimam, as shown in figure C.26.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F26_Khamis.png)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
- en: Figure C.26 The Ackley function
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: The presence of these local minima makes it difficult for optimization algorithms
    to find the global minimum, especially those that can get stuck in local minima.
    Write Python code to solve a 6D Ackley function.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: C.6.2 Solutions
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   b) 11010yxxyyyxyxxy and yxyyx01100101101
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   c) It flips a randomly chosen bit in the binary representation.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   b) Locus
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   b) By replacing a small fraction of the population
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Considering the following linear ranking
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F26_Khamis-EQ04.png)'
  id: totrans-732
  prefs: []
  type: TYPE_IMG
- en: '| Individual | Individual 1 | Individual 2 | Individual 3 | Individual 4 |
    Individual 5 |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
- en: '| Fitness | 12 | 25 | 8 | 53 | 10 |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
- en: '| Ranking r | 3 | 4 | 1 | 5 | 2 |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
- en: '| p(r) | 0.175 | **0**.**2** | 0.125 | **0**.**225** | 0.15 |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
- en: Individuals 4 and 2 will be selected, as they have the highest probability.
    So the correct answer is d.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   c) Tournament selection
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   a) True
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   c) Binary
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   b and c) Taking the reciprocal of the objective function, and negating
    the objective function
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. c) Lower computational cost
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: 1.11. a) Reverses the gene value (1 to 0 or 0 to 1)
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 1.12. d) All of the above
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: 1.13. d) Replacement strategies
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 1.14. c) Uniform crossover
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 1.15. c) Disruption of good solutions
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 1.16. b) The entire population is replaced.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: 1.17. b) Optimality
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 1.18. b) Selection, crossover, and mutation
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 1.19. a) Improved diversity preservation
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: 1.20. d) 9 bits
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: Given 0.0 <= *x* <= 31.5 with a precision of 0.1
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '•   Calculate the range size: (31.5 – 0) = 31.5'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '•   Divide the range size by the desired precision: 31.5 / 0.1 = 315'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '•   Round up to the nearest whole number: 315'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have 315 steps (values) to represent the numbers from 0.0 to 31.5 with
    a precision of 0.1:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: number_of_bits = ceil(log[2](number_of_steps)) = ceil(log[2](315)) ≈ ceil(8.29)
    = 9
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: 'So you need 9 bits to represent the numbers from 0.0 to 31.5 with a precision
    of 0.1.2\. Listing C.8 shows a snippet of the code to solve the Ackley function
    using a genetic algorithm implemented from scratch or based on the pymoo open
    source library. We start by defining constants for the genetic algorithm and Ackley
    function as follows:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.8 Solving the Ackley function using GA
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then define the `decode` function to convert the binary genome to real values:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following function defines the fitness function (Ackley function):'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s now define the crossover function:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The mutation function is defined as follows:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now it’s time to create an initial population:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s now run the genetic algorithm:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Calculate the fitness score for each genome in the population.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: ② Print out the best fitness score for each generation.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: ③ Select the best half of the population to act as parents for the next generation.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: ④ Generate the next generation by applying crossover and mutation.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Replace the current population with the new generation of children.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: 'You can print the best genome and its fitness as follows:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can print the best genome, decode the best genome, and then print the decision
    variables in real values as follows:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can solve this problem faster using GA implemented in pymoo as follows:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running this code produces the following output:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'C.7 Chapter 8: Genetic algorithm variants'
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.7.1 Exercises
  id: totrans-789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Assume that a company is trying to choose the optimal location for a new
    facility. The decision variables *x*[1] and *x*[2] represent the coordinates of
    the potential location for the new facility in a 2D plane. The company needs to
    minimize the distance squared between the new facility and an existing facility
    at the location (2, 1). This could represent the need to minimize transportation
    costs between the two facilities. Moreover, the company aims to maximize the distance
    squared between the new facility and a competitor’s facility at the location (3,
    4). This could represent the need to establish a competitive advantage by distancing
    the new facility from the competitor. The new facility must be located within
    a certain region due to zoning regulations or other restrictions. It also must
    adhere to environmental constraints or property boundaries. This multi-objective
    constrained optimization problem can be formulated as follows:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: Minimize *f*[1](*x*[1], *x*[2]) = √((*x*[1] – 2)² + (*x*[2] – 1)²) (distance
    between the company facilities)
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: Maximize *f*[1](*x*[1], *x*[2]) = √((*x*[1] – 3)² + (*x*[2] – 4)²) (distance
    between the new facility and a competitor’s facility)
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: such that
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '*g*[1](*x*[1], *x*[2]) = 2*x*[1] + *x*[2] – 6 ≤ 0 (zoning regulations)'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '*g*[2](*x*[1], *x*[2]) = 2*x*[1] – *x*[2] – 2 ≤ 0 (environmental constraints
    or property boundaries)'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: 0 ≤ *x*[1] ≤ 5 (boundary constraint)
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: 0 ≤ *x*[2] ≤ 5 (boundary constraint)
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code to find the optimal location for the new facility.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '2.   The All Ones problem, also known as the Max Ones problem, is a simple
    problem that aims to maximize the number of ones in a binary string of a fixed
    length. For a 10-bit All Ones problem, the optimal solution takes this form: [1111111111].
    The problem is described by K. Sutner in his article “Linear cellular automata
    and the Garden-of-Eden” [4] as follows: suppose each of the squares of an *n*
    × *n* chessboard is equipped with an indicator light and a button. If a square’s
    button is pressed, the light for that square will change from off to on or vice
    versa; the same happens to the lights of all the edge-adjacent squares. Initially
    all lights are off. The goal of the All Ones problem is to find a sequence of
    buttons that can be pressed in such a way that all lights are on at the end. This
    problem itself may not have direct applications, but it is used as a test problem
    to compare the performance of various algorithms. Write Python code to find a
    solution for the 10-bit All Ones problem using a genetic algorithm.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Assume that there are 10 parcels to be loaded in the cargo bike in figure
    C.27.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F27_Khamis.png)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
- en: Figure C.27 Cargo bike loading problem for 10 items with given weight, profit,
    and efficiency (profit/weight)
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: Each parcel has its own weight, profit, and efficiency value (profit per kg).
    The goal is to select the parcels to be loaded in such a way that the utility
    function *f*[1] is maximized and the weight function *f*[2] is minimized.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: '*f*[1] = Σ*E[i]*, *i* = 0, 1, ..., *n*.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '*f*[2] = |Σ*w[i]* – *C*|, 50 is added if and only if Σ*w[i]* > *C*.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: where
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: •   *n* is the total number of packages.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: •   *E[i]* is the efficiency of package *i*.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: •   *w[i]* is the weight of package *i*.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: •   *C* is the maximum capacity of the bike.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: A penalty of 50 is added if and only if the total weight of the added parcels
    exceeds the maximum capacity. Write Python code to determine which items should
    be loaded for maximum efficiency.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '4.   In the opencast mining problem described by Guéret et al. in their book
    “Linear programming” [5], the opencast uranium mine is divided into blocks for
    exploitation. As illustrated in figure C.28, there are 18 blocks of 10,000 tons
    on three levels, identified based on the results of test drilling. The pit needs
    to be terraced to allow trucks to reach the bottom, and the pit is limited in
    the west by a village and in the east by a group of mountains. To extract a block,
    three blocks of the level above it need to be extracted due to constraints on
    the slope: the block immediately on top of it, and the blocks to the right and
    to the left. There are different costs associated with extracting blocks depending
    on their level. Level 1 blocks cost $100 per ton to extract, level 2 blocks cost
    $200 per ton, and level 3 blocks cost $300 per ton. However, the hatched blocks,
    which are formed of a very hard rock rich in quartz, cost $1,000 per ton to extract.
    The blocks that contain uranium are displayed in a gray shade: these are blocks
    0, 6, 9, 11, 16, and 17\. These blocks have different market values, with block
    17 being rich in ore but made of the same hard rock as the other hatched blocks.
    The market values of blocks 0, 6, 9, 11, 16, and 17 are $200, $300, $500, $200,
    $1,000, and $1,200 per ton, respectively.'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F28_Khamis.png)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
- en: Figure C.28 Opencast mining problem
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: a.  Write a Python code to determine which blocks to extract to maximize the
    total profit, given by Σ(VALUE – COST) × *x[i]* for *x* = 0,1,…,17, where *x[i]*
    is an assignment binary variable.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: 'b.  Assume that the time duration required to process the blocks is [1, 1,
    1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 4, 4, 3, 4] depending on the block level and
    the hardness of the block. Write Python code to determine which blocks to extract
    to maximize the discounted profit and increased cost given by the following equations:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F28_Khamis-EQ14a.png)'
  id: totrans-817
  prefs: []
  type: TYPE_IMG
- en: '5.   In the Chapter 8/Projects folder in the book’s GitHub repository, the
    following sample research projects are provided for review and experimentation:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: •   *Routing*—Addresses using the genetic algorithm to find the shortest path
    between two points of interest in Vaughan, a municipality to the north of Toronto.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: •   *Bus routing*—Addresses the school bus routing problem, formulating the
    problem as a contained multi-objective optimization problem. The cluster-first
    route-second scheme, genetic algorithm, and adaptive genetic algorithm are applied
    to solve this problem. The performance of these algorithms is evaluated using
    real data from public schools in the city of Winchester, Virginia, USA.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '•   *Location allocation*—Tackles the placement of drone delivery stations
    using bio-inspired optimization algorithms. The solution framework consists of
    two stages: the first tackles the location planning problem of stations, while
    the second deals with the allocation of delivery demand to located stations.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: C.7.2 Solutions
  id: totrans-822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   The next listing shows how to solve the facility allocation problem using
    NSGA-II.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.9 Solving the facility allocation problem using NSGA-II
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Zooning constraint
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: ② Environment/property constraint
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: The complete listing, available in the book’s GitHub repository, also shows
    how to perform decision making to select the best solution.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: 2.   The All Ones problem solution is shown in the following listing.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.10 Solving the All Ones problem using GA
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code defines an `AllOnes` class that extends the `Problem` class from pymoo.
    The `_evaluate` method of the `AllOnes` class calculates the fitness of an individual
    by counting the number of ones in the binary string and returning the negative
    of that count (because pymoo minimizes objective functions).
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 3.   The solution to the cargo bike loading problem is shown in the next listing.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.11 Solving the cargo bike loading problem using GA
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Define the problem.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the problem inputs.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create a problem instance.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the genetic algorithm.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Run the optimization.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the results.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Visualize the solution.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: Running this code produces the solution shown in figure C.29.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F29_Khamis.png)'
  id: totrans-844
  prefs: []
  type: TYPE_IMG
- en: Figure C.29 Cargo bike loading solution
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: 4.   The next listing shows the steps to solve the opencast mining problem.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.12 Solving the opencast mining problem
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Blocks in the mine
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: ② Blocks in levels 2 and 3
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: ③ Cost of blocks.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: ④ Value of blocks
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Define the ARC for each block in LEVEL23.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation, you can visualize the precedence of extraction of blocks
    in levels 2 and 3 as follows:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① Create the directed graph.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: ② Add the nodes.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: ③ Add precedence edges.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a pos dictionary with a default position for all nodes.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Update the positions of nodes that have a specific position.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Draw the graph.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: Figure C.30 shows the precedence graph for extracting blocks in levels 2 and
    3.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F30_Khamis.png)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
- en: Figure C.30 Precedence graph for extracting blocks in levels 2 and 3
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: As a continuation of listing C.12, the following code snippet shows how to define
    the problem as a single objective constrained optimization problem.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now define the GA solver and apply it to solve the problem as follows:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running this code produces the following output:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The complete version of listing C.12 in the book’s GitHub repository includes
    the Pareto optimization implementation, which treats the problem as a multi-objective
    optimization problem.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'C.8 Chapter 9: Particle swarm optimization'
  id: totrans-872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.8.1 Exercises
  id: totrans-873
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   Which of the following is a drawback of the star structure in PSO?
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: a.  It may lead to premature convergence to a suboptimal solution.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: b.  It may cause the algorithm to converge too slowly.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: c.  It may cause the algorithm to become stuck in local optima.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: d.  It does not allow the algorithm to explore the search space effectively.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   Asynchronous PSO usually produces better results because it causes the
    particles to use more up-to-date information.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   What is the difference between the cognitive and social components in
    PSO?
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: a.  The cognitive component is based on the particle’s own experience, while
    the social component is based on the experience of the swarm as a whole.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: b.  The cognitive component is based on the experience of the particle’s neighbors,
    while the social component is based on the particle’s own experience.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: c.  The cognitive component is based on random perturbations, while the social
    component is based on gradient information.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: d.  The cognitive and social components are the same thing.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   Ring topology, or lbest PSO, has been shown to converge faster than other
    network structures, but with a susceptibility to be trapped in local minima.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   In binary PSO (BPSO), each bit in the binary strings is updated by considering
    its current state, the best state it has held so far, and the best state of its
    neighboring bits.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   In PSO, the velocity model that makes particles behave like independent
    hill climbers is
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: a.  Cognitive-only model
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: b.  Social-only model
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   PSO is guaranteed to find the global optimum of a function.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   What is the role of the acceleration coefficients in the PSO algorithm?
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: a.  To control the speed of the particles
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: b.  To control the exploration/exploitation trade-off
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: c.  To control the swarm size
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: d.  To control the mutation rate
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   PSO is a local search algorithm that is only able to find local optima.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. PSO was originally developed for continuous-valued spaces.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '2.   In the restaurant game described by Martin et al. in their article “Local
    termination criteria for swarm intelligence: A comparison between local stochastic
    diffusion search and ant nest-site selection,” [6], a group of delegates attends
    a long conference in an unfamiliar town. Each night they have to find somewhere
    to dine. There is a large choice of restaurants, each of which offers a large
    variety of meals. The problem the group faces is to find the best restaurant,
    which is the restaurant where the maximum number of delegates would enjoy dining.
    Even a parallel exhaustive search through the restaurant and meal combinations
    would take too long to accomplish. If you were to solve this problem using PSO,
    how would you describe the three components of the velocity update in the context
    of this problem?'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Ridesharing is a successful implementation of the sharing economy business
    model where personal vehicles are shared by their owners or drivers with individual
    travelers who have similar itineraries and schedules. The ridesharing problem
    is a multi-objective constrained optimization problem. A non-comprehensive list
    of optimization goals for ridesharing includes
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the total travel distance or time of drivers’ trips
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the total travel time of passengers’ trips
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: •   Maximizing the number of matched (served) requests
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the cost for the drivers’ trips
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the cost for the passengers’ trips
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: •   Maximizing the driver’s earnings
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the passenger’s waiting time
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: •   Minimizing the total number of drivers required
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the ridesharing problem shown in figure C.31, where the objective
    is to come up with a schedule for drivers that minimizes the total distances of
    vehicles’ trips. The statement of this multi-objective optimization is as follows:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: Find *s* that minimizes *f*
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F30_Khamis-EQ16.png)'
  id: totrans-923
  prefs: []
  type: TYPE_IMG
- en: where
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: •   *f* is the total distance of vehicles’ trips to serve all the passengers.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: •   *s[i,j]* is 1 if location *j* is assigned within the schedule of the driver
    and 0 otherwise.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: •   *d[i,j]* is the distance between two points within the route, where
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '*d[i,j]* = √((*x[i]* – *x[j]*)² + (*y[i]* – *y[j]*)²'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: •   *P* is the passenger set, with known pickup and delivery points.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: •   *V* is the vehicle set, with predefined initial and final locations.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F31_Khamis.png)'
  id: totrans-931
  prefs: []
  type: TYPE_IMG
- en: Figure C.31 The ridesharing problem
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Given the pickup and drop-off locations of five passengers (table C.3) and the
    initial and final locations of the two drivers (table C.4), define a suitable
    representation for a particle (i.e., a candidate solution) that represents each
    driver’s schedule and evaluates its fitness.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: Table C.3 Pickup and drop-off locations of the passengers
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '| Passengers | Pickup x-coordinate | Pickup y-coordinate | Drop-off x-coordinate
    | Drop-off y-coordinate |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
- en: '| P1 | 9 | 9 | 4 | 2 |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
- en: '| P2 | 8 | 5 | 2 | 4 |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
- en: '| P3 | 6 | 1 | 8 | 6 |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
- en: '| P4 | 7 | 6 | 9 | 8 |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
- en: '| P5 | 3 | 5 | 10 | 3 |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
- en: Table C.4 Initial and final locations of the drivers
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '| Drivers | Initial x-coordinate | Initial y-coordinate | Final x-coordinate
    | Final y-coordinate |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
- en: '| A | 4 | 1 | 8 | 10 |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
- en: '| B | 1 | 6 | 9 | 4 |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
- en: '4.   Consider the trip itinerary planning problem where the objective is to
    provide an optimal travel itinerary for tourists visiting a new city, taking into
    consideration the quality of the places to be visited, the proximity of the attractions
    to one another, and how much of the day can be completely occupied with little
    idle time. The problem is stated as following:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: Find *X* which optimizes *f*
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F31_Khamis-EQ18.png)'
  id: totrans-949
  prefs: []
  type: TYPE_IMG
- en: 'subject to the following constraints:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: •   The duration of the itinerary must not exceed total time in a given day,
    which is set to 480 minutes. This is expressed as the summation of the duration
    of each venue and total commute time to be visited in an itinerary. This means
    that *Z[d]* + *Z[c]* <= 480 minutes.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: •   There should never be repetitions of the same venue in a solution.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: where
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: •   *X* = [*Z[d] Z[c] Z[r]*]*^T*
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: •   *Z[d]* represents the duration of the itinerary (minutes).
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: •   *Z[c]* represents the total commute time in the itinerary.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: •   *Z[r]* represents the average rating of all the venues in an itinerary.
    The ratings are derived from Yelp, Google reviews, or others.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: Table C.5 lists the commute times between 10 attractions.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: Table C.5 Commute time between attractions
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '| Commute time (mins) | To |'
  id: totrans-960
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-961
  prefs: []
  type: TYPE_TB
- en: '|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
- en: '| From | 0 | 10 | 20 | 7 | 11 | 8 | 19 | 7 | 1 | 1 |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
- en: '|  | 1 | 0 | 12 | 14 | 1 | 7 | 12 | 10 | 22 | 22 |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
- en: '| 2 | 12 | 0 | 25 | 21 | 28 | 1 | 22 | 12 | 12 |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
- en: '| 3 | 14 | 25 | 0 | 15 | 15 | 25 | 4 | 6 | 6 |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | 21 | 15 | 0 | 25 | 22 | 11 | 10 | 10 |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
- en: '| 5 | 7 | 28 | 15 | 25 | 0 | 28 | 14 | 28 | 29 |'
  id: totrans-968
  prefs: []
  type: TYPE_TB
- en: '| 6 | 12 | 1 | 25 | 22 | 28 | 0 | 22 | 12 | 12 |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
- en: '| 7 | 10 | 22 | 4 | 11 | 14 | 22 | 0 | 3 | 2 |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
- en: '| 8 | 22 | 12 | 6 | 10 | 28 | 12 | 3 | 0 | 1 |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
- en: '| 9 | 22 | 12 | 6 | 10 | 29 | 12 | 2 | 1 | 0 |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
- en: The durations and ratings for the different attractions are listed in table
    C.6.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Table C.6 Ratings and durations for attractions
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '| ID | Rating | Duration (mins) |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
- en: '| 0 | Starting hotel |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | 120 |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 | 60 |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | 180 |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0 | 180 |'
  id: totrans-981
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | 120 |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1 | 60 |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
- en: '| 7 | 4 | 60 |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
- en: '| 8 | 0 | 60 |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
- en: '| 9 | 2 | 120 |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
- en: Define a suitable representation of a particle (i.e., a candidate solution),
    and carry out two hand iterations to show how to solve this problem using PSO,
    assuming a swarm size of 4.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: 5.   *Trilateration* is used to identify the location of a moving object such
    as a connected vehicle or a cellphone. This process uses the distance between
    the vehicle and three or more known cell towers to determine the location of the
    vehicle. By measuring the signal strength of the device’s signal at each tower,
    the distance between the device and each tower can be calculated. The intersection
    of the three (or more) circles created by these distance measurements gives an
    estimate of the device’s location. As shown in figure C.32, three cell towers
    advertise their coordinates and transmit a reference signal.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis.png)'
  id: totrans-989
  prefs: []
  type: TYPE_IMG
- en: Figure C.32 Cell tower trilateration
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: 'The connected vehicle uses the reference signal to estimate distances to each
    of the cells *r[i]*. These distance measurements *r[i]* may be subject to noise.
    Assume that the associated error is given by the following equation:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ19.png)'
  id: totrans-992
  prefs: []
  type: TYPE_IMG
- en: 'The vehicle position (*ϕ*[0], *λ*[0]) is the position that minimizes the following
    objective function:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ20.png)'
  id: totrans-994
  prefs: []
  type: TYPE_IMG
- en: Write Python code to find the vehicle’s position using PSO.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: '6.   A coffee shop offers two sizes of coffee: small and large. The cost of
    making a small coffee is $1, and the cost of making a large coffee is $1.50\.
    The coffee shop sells small coffees for $2 each and large coffees for $3 each.
    The coffee shop wants to maximize its profit, but it also wants to ensure that
    it sells at least 50 small coffees and 75 large coffees and at most 300 and 450
    respectively per day. This problem can be formulated as an optimization problem
    as follows:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: Maximize profit = 2*x*[1] + 3*x*[2] - (*x*[1] + 1.5*x*[2])
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: Subject to
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: 50 ≤ *x*[1] ≤ 300
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: 75 ≤ *x*[2] ≤ 450
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: where
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: •   *x*[1] is the number of small coffees to make.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: •   *x*[2] is the number of large coffees to make.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: Profit is the total profit, where the first term in the equation represents
    the revenue from selling the coffees, and the second term represents the cost
    of making the coffees. Write Python code to find the optimal number of small coffees
    and large coffees to make every day.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: 7.   A hospital wants to optimize the scheduling of its doctors to minimize
    the overall cost of labor while ensuring that enough doctors are available to
    meet patient demand. Each doctor has a different hourly rate, and there are different
    levels of patient demand at different times of the day. The goal is to find the
    optimal schedule that minimizes the total cost of labor while meeting the minimum
    doctor requirements during both peak and non-peak hours.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: The hospital must schedule at least four doctors during peak hours and at least
    two doctors during non-peak hours. The hospital can hire part-time doctors at
    a lower hourly rate, but they can only work during non-peak hours. The hospital
    also has the option of paying overtime to full-time doctors to meet demand during
    peak hours, but at a higher hourly rate.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem can be mathematically described as follows:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimize the total cost of labor: *f*(*x*) = Σ(*c[i]* × *x[i]*) + Σ(*c[i]^o*
    × *x[i]^o*) + Σ(*c[j]^p* × *x[j]^p*)'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: 'subject to the following constraints:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: '•   Σ*x[i]* + Σ*x[i]^o* ≥ 4: At least four doctors must be scheduled during
    peak hours.'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '•   Σ*x[i]^p* ≥ 2: At least two doctors must be scheduled during non-peak hours.'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '•   *x[i]*, *x[i]^o*, *x[j]^p* ≥ 0: Non-negativity constraints'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: where
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: •   *i* is the index for full-time doctors, *i* = 1, 2, ..., *m*.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: •   *j* is the index for part-time doctors, *j* = 1, 2, ..., *n*.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: 'Predefined parameters:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: •   *c[i]* is the hourly rate for full-time doctor *i*.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: •   *c[i]^o* is the overtime hourly rate for full-time doctor *i*.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: •   *c[j]^p* is the hourly rate for part-time doctor *j*.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: 'Decision variables:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[i]* is the number of hours worked by full-time doctor *i* during peak
    hours.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[i]^o* is the number of overtime hours worked by full-time doctor *i*
    during peak hours.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[j]^p* is the number of hours worked by part-time doctor *j* during non-peak
    hours.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: Assume the full-time rates of full-time doctors are [30, 35, 40, 45, 50], their
    overtime rates are 1.5 times the full-time rates, and the part-time doctors’ rates
    are [25, 27, 29, 31, 33]. Write Python code to solve this problem using PSO.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '8.   In neighborhood *Y* of city *X*, there are eight schools that collectively
    possess 100 microscopes for use in biology classes. These resources, however,
    are not uniformly distributed amongst the schools. With recent changes in student
    enrollment, four schools have more microscopes than needed, while the other four
    schools are in need of additional ones. To address this problem, Dr. Rachel Carson,
    who is in charge of the biology department at city *X*.''s school board, decides
    to use a mathematical model. She chooses to use the transportation problem model,
    a strategy aimed at efficiently allocating resources while minimizing transportation
    costs as per R. Lovelace in his article “Open source tools for geographic analysis
    in transport planning” [7]. The model represents supply *n* and demand *m* as
    unit weights of decision variables at various points in a network, with the cost
    of transporting a unit from a supply point to a demand point equivalent to the
    time or distance between nodes. This data is captured in an *n***m* cost matrix.
    The formal statement of this integer linear programming problem is described in
    Daskin’s book “Network and Discrete Location: Models, Algorithms, and Applications”
    [8] as follows:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ28.png)'
  id: totrans-1026
  prefs: []
  type: TYPE_IMG
- en: subject to the following constraints
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: •   Σ*[j]*[∈]*[J] x[ij]* ≤ *S[i]* ∀ *i* ∈ *I*
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: •   Σ*[j]*[∈]*[J] x[ij]* ≥ *D[i]* ∀ *j* ∈ *J*
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[ij]* ≥ 0 ∀ *i* ∈ *I* and ∀ *j* ∈ *J*
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: where
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: •   *i* is each potential origin node.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: •   *I* is the complete set of potential origin nodes.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: •   *j* is each potential destination node.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: •   *J* is the complete set of potential nodes.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[ij]* is the amount to be shipped from ∀ *i* ∈ *I* to ∀ *j* ∈ *J*.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: •   *c[ij]* is per unit shipping costs between all *i*, *j* pairs.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: •   *S[i]* is node *i* supply for ∀ *i* ∈ *I*.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: •   *D[j]* is node *i* demand for ∀ *j* ∈ *J*.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code to solve this problem using PSO. Visualize the solution on
    a geospatial map.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: 9.   In the Chapter 9/Projects folder in the book’s GitHub repository, the following
    sample research projects are provided for review and experimentation.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: •   Routing—Addresses using PSO to find the shortest path between two points
    of interest in Toronto
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: •   Bus stops placement—Addresses how to use PSO to find the optimal placement
    of bus stops in the Waterloo/Kitchener area, Ontario, Canada
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: C.8.2 Solutions
  id: totrans-1044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   c) It may cause the algorithm to become stuck in local optima.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   a) True
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   a) The cognitive component is based on the particle’s own experience,
    while the social component is based on the experience of the swarm as a whole.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   b) False
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   a) True
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   a) Cognitive-only model
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   b) False
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   b) To control the exploration/exploitation trade-off
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   b) False (PSO is designed to explore the search space globally and has
    the potential to find the global optimum.)
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. a) True
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Imagine a group of delegates visiting an unfamiliar city for a conference.
    They are trying to find the best restaurant in town using PSO principles. The
    town is large, and each delegate starts at a different location. Each delegate
    has a preferred way of exploring restaurants, like walking along certain streets
    or visiting specific neighborhoods. This is similar to the inertia component in
    PSO, where particles maintain their current velocity and direction, ensuring they
    don’t change their exploration pattern too abruptly.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: As each delegate visits different restaurants, they remember the best one they’ve
    been to so far (their personal best). If they come across a less appealing restaurant,
    they’re more likely to return to their favorite one, knowing it was a good choice
    based on their own experience. This is the cognitive component, where particles
    in PSO are attracted to their personal best positions, following their past experiences
    and individual preferences.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: The delegates also communicate with each other via group chat, sharing their
    experiences and the locations of the best restaurants they’ve found. If someone
    discovers an outstanding restaurant, others might decide to visit that place and
    try it for themselves, even if it wasn’t their personal favorite. This is the
    social component, where particles in PSO are influenced by the global best position
    or the collective knowledge of the swarm.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Due to the discrete nature of the formulated problem, permutation-based
    PSO should be used. A particle in this algorithm represents an ordering of the
    passengers to be picked up and dropped off by each driver. In this problem, we
    have two vehicles, A and B, and five passenger requests to match (P1–P5). For
    example, a candidate solution for a problem with five passengers and two drivers
    would have the following format:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '| A^+ | P3^+ | P4^+ | P3^– | P5^+ | P4^– | P5^– | A^– |'
  id: totrans-1060
  prefs: []
  type: TYPE_TB
- en: '| B^+ | P1^+ | P2^+ | P2^– | P1^– | B^– |  |  |'
  id: totrans-1061
  prefs: []
  type: TYPE_TB
- en: where
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: •   + denotes the pickup points of passengers’ requests and the vehicles’ sources.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: •   – denotes the delivery points of passengers’ requests and the vehicles’
    destinations
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution can be read as follows:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: •   Vehicle A source point → passenger 3 pickup → passenger 4 pickup → passenger
    3 drop-off → passenger 5 pickup → passenger 4 drop-off → passenger 5 drop-off
    → vehicle A destination.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: •   Vehicle B source point → passenger 1 pickup → passenger 1 pickup → passenger
    2 drop-off → passenger 2 drop-off → vehicle B destination.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: 'These two schedules can be also concatenated as follows:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '| A^+ | P3^+ | P4^+ | P3^- | P5^+ | P4^- | P5^- | A^- | B^+ | P1^+ | P2^+ |
    P2^- | P1^- | B^- |'
  id: totrans-1069
  prefs: []
  type: TYPE_TB
- en: 'We use the objective function to evaluate this solution as follows:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ32.png)'
  id: totrans-1071
  prefs: []
  type: TYPE_IMG
- en: For a more comprehensive discussion of the ride-matching problem with time windows
    (RMPTW) and an extended version of this simplified problem, see Herbawi and Weber’s
    article “A genetic and insertion heuristic algorithm for solving the dynamic ridematching
    problem with time windows” [9].
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '4.   Binary PSO (BPSO) is used to handle this problem. A binary string is used
    to describe the attractions to be visited. For example, [0 0 1 0 1 0 0 0 0] means
    visit attractions 3 and 5\. The velocity is calculated using the following equation:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ33.png)'
  id: totrans-1074
  prefs: []
  type: TYPE_IMG
- en: where
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: •   *i* is the particle number.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: •   *d* is the dimension or the attraction.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: •   *v[k]^(id)* is the velocity at iteration *k* for particle *i* and dimension
    *d*.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: •   *pbest[k]^(id)* is the personal best at iteration *t* for particle *i* and
    dimension *d*.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: •   *gbest[k]^d* is the global best at iteration *k* for dimension *d*.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: •   *x[k]^(id)* is the current position at iteration *k* for particle *i* and
    dimension *d*.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: •   *ϕ*[1], *ϕ*[2] are uniformly generated random numbers between 0 and 2.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the velocity vector is updated, the sigmoid value of each of the velocities
    is updated as follows:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ34.png)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
- en: 'A new position with the sigmoid value of the velocity is created. Next the
    particle position is updated as follows:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F32_Khamis-EQ35.png)'
  id: totrans-1086
  prefs: []
  type: TYPE_IMG
- en: where
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: •   *r* is a uniformly generated random number between 0 and 1.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: •   *sig*(*v[k]*[+1]*^(id)*) is the sigmoid value of the velocity at *v[k]*[+1]*^(id)*
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: Table C.7 Initialization
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *ϕ*[1] | *ϕ*[2] | *v*[01] | *v*[02] | *v*[03] | *v*[04] | *v*[05] | *v*[06]
    | *v*[07] | *v*[08] | *v*[09] |'
  id: totrans-1091
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1092
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1093
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1094
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1095
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1096
  prefs: []
  type: TYPE_TB
- en: Let *p[i]* be the current binary value for the position of attraction *i* for
    a particle as shown in table C.8.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: Table C.8 Binary value for the positions of the 9 attractions
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] |'
  id: totrans-1099
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1100
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-1101
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |'
  id: totrans-1102
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
  id: totrans-1103
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |'
  id: totrans-1104
  prefs: []
  type: TYPE_TB
- en: 'Table C.9 Initialization: Fitness evaluation'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] | Total commute time | Total places visited | Average rating | Total
    duration | *f*(*x[i]*) |'
  id: totrans-1106
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
  id: totrans-1107
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 34 | 2 | 2.000 | 180 | 0.700
    |'
  id: totrans-1108
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 19 | 2 | 5.000 | 240 | 2.405
    |'
  id: totrans-1109
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 76 | 2 | 2.500 | 180 | 0.809
    |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 30 | 2 | 3.000 | 180 | 1.059
    |'
  id: totrans-1111
  prefs: []
  type: TYPE_TB
- en: Table C.10 Particle’s current personal best at initialization
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '|  | pbest[01] | pbest [02] | pbest [03] | pbest [04] | pbest [05] | pbest
    [06] | pbest [07] | pbest [08] | pbest [09] | pbestVal |'
  id: totrans-1113
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1114
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0.700 |'
  id: totrans-1115
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 2.405 |'
  id: totrans-1116
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0.809 |'
  id: totrans-1117
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1.059 |'
  id: totrans-1118
  prefs: []
  type: TYPE_TB
- en: 'Table C.11 Iteration 1: Velocity update'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *ϕ*[1] | *ϕ*[2] | *v*[11] | *v*[12] | *v*[13] | *v*[14] | *v*[15] | *v*[16]
    | *v*[17] | *v*[18] | *v*[19] |'
  id: totrans-1120
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1121
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0.958 | 0.830 | -0.830 | -0.830 | 0.830 | 0.000 | 0.000 | 0.000
    | 0.000 | 0.830 | 0.000 |'
  id: totrans-1122
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 1.347 | 1.517 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 |
    0.000 | 0.000 | 0.000 |'
  id: totrans-1123
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 1.320 | 1.649 | 0.000 | -1.649 | 1.649 | 0.000 | -1.649 | 0.000
    | 0.000 | 1.649 | 0.000 |'
  id: totrans-1124
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 0.757 | 0.678 | -0.678 | 0.000 | 0.678 | 0.000 | 0.000 | 0.000 |
    -0.678 | 0.678 | 0.000 |'
  id: totrans-1125
  prefs: []
  type: TYPE_TB
- en: Table C.12 Updated sigmoid velocity values of the particle after iteration 1
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: '|  | sig(*v*[11]) | sig(*v*[12]) | sig(*v*[13]) | sig(*v*[14]) | sig(*v*[15])
    | sig(*v*[16]) | sig(*v*[17]) | sig(*v*[18]) | sig(*v*[19]) |'
  id: totrans-1127
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1128
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0.304 | 0.304 | 0.696 | 0.500 | 0.500 | 0.500 | 0.500 | 0.696 |
    0.500 |'
  id: totrans-1129
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 | 0.500 |
    0.500 |'
  id: totrans-1130
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0.500 | 0.161 | 0.839 | 0.500 | 0.161 | 0.500 | 0.500 | 0.839 |
    0.500 |'
  id: totrans-1131
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 0.337 | 0.500 | 0.663 | 0.500 | 0.500 | 0.500 | 0.337 | 0.663 |
    0.500 |'
  id: totrans-1132
  prefs: []
  type: TYPE_TB
- en: Table C.13 Uniformly generated random numbers for deciding particle updated
    after iteration 1
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *r*[11] | *r*[12] | *r*[13] | *r*[14] | *r*[15] | *r*[16] | *r*[17] |
    *r*[18] | *r*[19] |'
  id: totrans-1134
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1135
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.477 | 0.724 | 0.875 | 0.654 | 0.088 | 0.089 | 0.853 | 0.925 | 0.528
    |'
  id: totrans-1136
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.673 | 0.530 | 0.438 | 0.785 | 0.218 | 0.763 | 0.838 | 0.749 | 0.590
    |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0.534 | 0.086 | 0.301 | 0.763 | 0.653 | 0.754 | 0.809 | 0.974 | 0.763
    |'
  id: totrans-1138
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0.218 | 0.697 | 0.875 | 0.854 | 0.116 | 0.941 | 0.678 | 0.742 | 0.965
    |'
  id: totrans-1139
  prefs: []
  type: TYPE_TB
- en: 'Iteration 1: Global best is 2.405, and the best particle is *x*[2] = [0 0 1
    0 0 0 0 0 0].'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration 2: Velocity update'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: Table C.14 Updated particle state and fitness function after iteration 2
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *p*[1] | *p*[2] | *p*[3] | *p*[4] | *p*[5] | *p*[6] | *p*[7] | *p*[8]
    | *p*[9] | Total commute time | Total places visited | Average rating | Total
    duration | *f*(*x[i]*) |'
  id: totrans-1143
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
  id: totrans-1144
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 64 | 2 | 3.500 | 180 | 1.158
    |'
  id: totrans-1145
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 37 | 2 | 5.000 | 300 | 2.901
    |'
  id: totrans-1146
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 70 | 2 | 2.500 | 240 | 1.091
    |'
  id: totrans-1147
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 24 | 2 | 4.500 | 240 | 2.143
    |'
  id: totrans-1148
  prefs: []
  type: TYPE_TB
- en: Table C.15 Updated personal best of the particle after iteration 2
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: '|  | pbest[11] | pbest [12] | pbest [13] | pbest [14] | pbest [15] | pbest
    [16] | pbest [17] | pbest [18] | pbest [19] | pbestVal |'
  id: totrans-1150
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1151
  prefs: []
  type: TYPE_TB
- en: '| *x*[1] | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1.158 |'
  id: totrans-1152
  prefs: []
  type: TYPE_TB
- en: '| *x*[2] | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 2.901 |'
  id: totrans-1153
  prefs: []
  type: TYPE_TB
- en: '| *x*[3] | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1.091 |'
  id: totrans-1154
  prefs: []
  type: TYPE_TB
- en: '| *x*[4] | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 2.143 |'
  id: totrans-1155
  prefs: []
  type: TYPE_TB
- en: The global best is 2.901, and the best particle is *x*[2] = [0 0 1 0 1 0 0 0
    0]. Repeat until the stopping criteria is fulfilled.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: 5.   The next listing shows the steps for solving the trilateration problem
    using PSO.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.13 Solving the trilateration problem using PSO
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① Define the objective function.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: ② Set up the PSO algorithm.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: ③ Initialize GlobalBestPSO, and minimize the objective function.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: ④ Print the results.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: 6.   The next listing shows the steps for solving the coffee shop problem.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.14 Solving the coffee shop problem using PSO
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① Import the required libraries.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the fitness function.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the number of particles and iterations.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the lower and upper bounds of the variables.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set the optimizer options.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Initialize the optimizer.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Perform the optimization.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: 7.   The next listing shows the steps for solving the doctor scheduling problem.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.15 Solving the doctor scheduling problem using PSO
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① Set full-time hourly rates, overtime rates, and part-time doctor rates.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the three decision variables.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define the total cost as an objective function.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the constraints and add them as a penalty in the cost function.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Initialize the bounds.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Set the options for PSO.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Create an instance of PSO.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Perform the optimization.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Extract optimal values of the decision variables x1, x2, and x3.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of listing C.15, available in the book’s GitHub repo, contains
    a function to print and visualize the results. Figure C.33 shows the hours worked
    for each doctor.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F33_Khamis.png)'
  id: totrans-1187
  prefs: []
  type: TYPE_IMG
- en: Figure C.33 Hours worked by each doctor
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: 8.   The next listing shows the steps for solving the supply chain optimization
    problem using PSO. We start by importing the required libraries.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.16 Solving the supply chain optimization problem using PSO
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then define the problem data as follows:'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-1193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① Schools with microscopes available
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: ② Schools with microscopes requested
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: ③ Number of microscopes available at each school
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: ④ Number of microscopes requested at each school
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Number of variables
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation of listing C.16, the following function generates random
    locations around a center point to represent the supply and demand schools in
    the selected city (using Toronto as an example). We calculate the distances between
    the schools using geopy:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ① For reproducibility
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: ② Set the center of the map.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: ③ Generate random GPS coordinates (lat, long) for the supply schools.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: ④ Generate random GPS coordinates (lat, long) for the demand schools.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Calculate geodesic distances between the schools in km.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class defines the transportation problem in a format compatible
    with pymoo. It defines the decision variables, constraints, and the objective
    function:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can create a problem object and a PSO solver as follows:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following line is used to run 150 iterations of the PSO solver:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following code snippet is used to print the solution obtained by the PSO
    solver:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① Extract the solution.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: ② Number of supply points
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: ③ Number of demand points
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: ④ Print each supply point.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Print each demand point.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the shipping cost.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the randomness included in the implementation, the code will produce
    output that is something like the following:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following code snippet can be used to visualize the solution of a spatial
    map using folium:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Normalize function
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: ② Normalize soln array
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define a color list.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a map centered at downtown Toronto.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Add markers for supply schools.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Add markers for demand schools.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Add lines (edges) between supply and demand schools.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Show the map.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: Figure C.34 shows a solution that may be produced by PSO.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F34_Khamis.png)'
  id: totrans-1233
  prefs: []
  type: TYPE_IMG
- en: Figure C.34 School microscopes supply and demand
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of listing C.16, available in the book’s [GitHub repo](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20C/Chapter%209/Listing%20C.16_Supply_demand.ipynb),
    also shows how to solve this problem using the genetic algorithm.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: 'C.9 Chapter 10: Other swarm intelligence algorithms to explore'
  id: totrans-1236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.9.1 Exercises
  id: totrans-1237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Match the terms and descriptions shown in table C.16.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: Table C.16
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: '| Terms | Descriptions |'
  id: totrans-1240
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1241
  prefs: []
  type: TYPE_TB
- en: '| 1\. Ant colony system (ACS) | a. Bees that search for new food sources after
    exhausting their current ones |'
  id: totrans-1242
  prefs: []
  type: TYPE_TB
- en: '| 2\. Stigmergy | b. Positive feedback about food path causes that path to
    be followed by more and more ants |'
  id: totrans-1243
  prefs: []
  type: TYPE_TB
- en: '| 3\. Scout bees | c. A pheromone update method that doesn’t take the desirability
    of the solution into account |'
  id: totrans-1244
  prefs: []
  type: TYPE_TB
- en: '| 4\. Max-min ant system (MMAS) | d. The maximum number of unsuccessful attempts
    made by a scout bee to find a new food source |'
  id: totrans-1245
  prefs: []
  type: TYPE_TB
- en: '| 5\. Autocatalytic behavior | e. Bees that probabilistically choose food sources
    depending on the fitness of the solutions found by the employed bees |'
  id: totrans-1246
  prefs: []
  type: TYPE_TB
- en: '| 6\. Ant density model | f. Indirect communication among social insects through
    environmental modifications that serve as external memory |'
  id: totrans-1247
  prefs: []
  type: TYPE_TB
- en: '| 7\. Onlooker bees | g. A pheromone update method that uses local information
    to update the pheromone concentrations |'
  id: totrans-1248
  prefs: []
  type: TYPE_TB
- en: '| 8\. Ant-cycle | h. An ACO variation that uses an elitist strategy called
    pseudo-random proportional action rule |'
  id: totrans-1249
  prefs: []
  type: TYPE_TB
- en: '| 9\. Ant System (AS) | i. An ACO variant that adds a memory capability by
    including a tabu list |'
  id: totrans-1250
  prefs: []
  type: TYPE_TB
- en: '| 10\. Trial limit | k. An ACO variation that overcomes stagnation |'
  id: totrans-1251
  prefs: []
  type: TYPE_TB
- en: 2.   Write Python code to find the shortest path between a source point and
    a destination point using the ant colony optimization algorithm. Assume that you’re
    currently standing at the King Edward VII equestrian statue in the city of Toronto
    with GPS coordinates (43.664527, –79.392442). Imagine you’re a student at the
    University of Toronto, and you’re already running late for your Optimization Algorithms
    lecture at the Bahen Centre for Information Technology with GPS coordinates (43.659659,
    –79.397669). Visualize the obtained route on a map centered on King’s College
    Circle with GPS coordinates (43.661667, –79.395) so you can reach your destination.
    Feel free to use the helping functions available in the optalgotools package,
    such as `Node`, `cost`, and `draw_route`. Use the code to experiment with different
    search spaces (different areas of interest, different origins, and destinations)
    and different algorithm parameter settings.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Reverse osmosis (RO) is a very effective and important process for desalination
    and water waste reclamation. Assume that you need to maximize the RO high pressure
    pump power. This power depends of a number of parameters according to the following
    equation:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F34_Khamis-EQ36.png)'
  id: totrans-1254
  prefs: []
  type: TYPE_IMG
- en: where
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: •   *HP* is the RO high pressure pump power in kW.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: •   *M[d]* is the RO productivity in m3/d and is in the range of 41.67 < M*[d]*
    <416.67 m³/d.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: •   *N[v]* is number of pressure vessels and is ranged as 1 < N*[v]* < 200.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: •   ∆*π* is the net osmotic pressure across the membrane and is in the range
    1400 < ∆*π* < 2600 kPa.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: •   *RR* is the recovery ratio and is ranged as 1 < RR < 50%.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: •   *η* is the efficiency of the high pressure pump and is in the range of 0.70
    < *η* < 0.85.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: •   *ρ* is the density of water.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code to find the optimal values of the decision variables (*Md,
    Nv*, ∆*π, RR, η*, and *ρ*) to maximize HP using the ant colony optimization (ACO)
    algorithm. Solve the same problem using the `optimize` solver in SciPy.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Solve the supply and demand problem introduced in exercise 8 of chapter
    9 using the ant colony optimization (ACO) algorithm. Use mixed integer distributed
    ant colony optimization (MIDACO) to solve this problem. MIDACO ([www.midaco-solver.com](http://www.midaco-solver.com))
    is a numerical high-performance software for solving single- and multi-objective
    optimization problems. It is based on ACO with an extension for mixed integer
    search domains.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: 'To install MIDACO, follow these steps:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 1\.  Download MIDACO Python Gateway ([midaco.py](http://www.midaco-solver.com/index.php/download/python)),
    and remove the .txt extension.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 2\.  Download the appropriate library file ([midacopy.dll](http://www.midaco-solver.com/index.php/download/python)
    or midacopy.so).
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: 3\.  Store all the files in the same folder on your PC.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: 4\.  Import `midaco` into your Jupyter notebook.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: MIDACO is licensed software with a limited free license that enables optimization
    with up to four variables (two supply schools and two demand schools).
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the following reduced problem data:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① Schools with microscopes available
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: ② Schools with microscopes requested
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: ③ Number of microscopes available at each school
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: ④ Number of microscopes requested at each school
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code to solve this problem using MIDACO. Visualize the solution
    on a geospatial map. For a larger number of schools, you can obtain an unlimited
    license or request a free academic trial of the unlimited version that can support
    up to 100,000 variables.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: C.9.2 Solutions
  id: totrans-1278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Answers
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: 1-h, 2-f, 3-a, 4-k, 5-b, 6-c, 7-e, 8-g, 9-i, 10-d
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Listing C.17 shows the steps to find and visualize the shortest path between
    two points of interest in the city of Toronto. The code uses helping functions
    from optalgotools such as Node, cost, and draw_route. We start by defining and
    visualizing the search space as follows.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.17 Solving a routing problem using ACO
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Set King’s College Circle, Toronto, ON as the center of the map.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a graph.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the King Edward VII equestrian statue as the origin.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the Bahen Centre for Information Technology at University of Toronto as
    the destination.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Get the osmid of the nearest nodes to the origin and destination points.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Create the origin and destination nodes.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Mark both the source and destination nodes.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Visualize the search space.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: 'AS a continuation of listing C.17, we can initialize the parameters of the
    ACO algorithm as follows:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ① Set alpha, a parameter to control the influence of pheromones.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: ② Set beta, a parameter to control the influence of desirability of the city
    transition.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the number of iterations.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: ④ Randomize the pheromones.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Randomize the pheromones.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ A function to calculate pheromone levels
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: 'We now implement the ACO procedure as follows:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① Place the ant at the origin node.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: ② Probabilistically choose a child to explore.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: ③ Add all the non-explored children in case we need to explore them later.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the chosen child to be the next node to explore.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Update the pheromones.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ If the route is newly discovered, add it to the list.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now print the best route and its cost and visualize the obtained route
    as follows:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Figure C.35 shows the optimal route generated by ACO.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F35_Khamis.png)'
  id: totrans-1311
  prefs: []
  type: TYPE_IMG
- en: Figure C.35 Optimal route generated by ACO
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: 3.   The next listing shows the steps for solving the reverse osmosis (RO) high
    pressure pump power maximization problem using ACO.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.18 Solving the RO high pressure pump power maximization problem with
    ACO
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① Define the range for each decision variable.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: ② Density of water in kg/m^3
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define the objective function.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the ACO parameters.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Initialize the pheromone matrix.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Initialize the best solution and its corresponding power.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Construct solutions for each ant.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Calculate the power for the current solution.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Store the solution and its power.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Update the best solution if necessary.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: ⑪ Update pheromone trails based on the power of each solution.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: ⑫ Print the optimal values of the decision variables and the optimal HP.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the generated output is show here:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As a continuation of listing C.18, the following code snippet shows the steps
    for solving this problem using the `optimize` solver in SciPy.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ① Import the scipy optimizer.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the objective function with a negative sign for minimization, as per
    scipy's requirement.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the bounds for the decision variables.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set an initial guess.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Solve the optimization problem using sequential least squares programming
    (SLSQP).
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the optimal values of the decision variables and the optimal HP.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated output is show here:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can fine-tune the ACO parameters to get results comparable to those of the
    SciPy optimizer.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: 4.   The next listing shows the steps for solving the supply and demand problem
    using the MIDACO solver. We start by importing the libraries and setting the problem
    data.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.19 Solving the supply and demand problem using MIDACO
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ① Import the MIDACO solver.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: ② Set the schools with microscopes available.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the schools with microscopes requested.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the number of microscopes available at each school.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set the number of microscopes requested at each school.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation, we’ll generate random GPS coordinates for the supply and
    demand schools:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ① Create a geolocator object.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: ② Get the coordinates of Toronto.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: ③ Function to generate random locations around a center point
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the random seed to ensure reproducibility of random numbers generated.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Generate random GPS coordinates (lat, long) for the supply schools.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Generate random GPS coordinates (lat, long) for the demand schools.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Calculate geodesic distances between the schools in km.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Calculate the cost matrix.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: The following function defines the main ingredients of the optimization problem,
    including the objective function and the constraints.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ① Initialize the array for objectives F(X).
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize the array for constraints G(X).
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: ③ Objective functions F(X)
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: ④ Candidate solution
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Inequality constraints G(X) >= 0 must come second in g[me:m-1]
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Return the objective function and constraint evaluation.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in using MIDACO is to define the problem as follows:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ① Free limited license that supports up to 4 variables.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize the dictionary containing the problem specifications.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: ③ Initialize the dictionary containing the MIDACO options.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: ④ Handle for problem function name.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem dimensions are defined as follows:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ① Number of objectives
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: ② Number of variables (in total)
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: ③ Number of integer variables (0 <= ni <= n)
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: ④ Number of constraints (in total)
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Number of equality constraints (0 <= me <= m)
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: 'The lower and upper bounds `xl` and `xu` are defined as follows:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The starting point `x` is set as the lower bound:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The stopping criteria are defined as follows:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ① Maximum number of function evaluation
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: ② Maximum time limit in seconds (e.g., 1 day = 60*60*24)
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the printing options as follows:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ① Print-frequency for current best solution
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: ② Save screen and solution [0 for no and 1 for yes]
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: 'MIDACO offers the option to evaluate multiple solution candidates in parallel
    (aka co-evaluation or fine-grained parallelization). According to the MIDACO user
    manual, for a parallelization factor of *P* = 10, the potential speed-up is around
    10 times, while for a parallelization factor of *P* = 100, the potential speed
    up is around 70 times. We can set the parallelization factor as follows:'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '① Serial: 0 or 1, Parallel: 2,3,4,5,6,7,8...'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run `midaco` to solve the problem:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following code snippet is used to print the solution obtained by the PSO
    solver:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ① Number of supply points
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: ② Number of demand points
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: ③ Print each supply point.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: ④ Print each demand point.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Print the shipping cost.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will produce output like the following:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following code snippet can be used to visualize the solution of a spatial
    map using folium:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ① Normalize function.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: ② Normalize solution array.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define a color list.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a map centered at downtown Toronto.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Add markers for supply schools.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Add markers for demand schools.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Add lines (edges) between supply and demand schools.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Show the map.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: Figure C.36 shows the solution obtained using MIDACO.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F36_Khamis.png)'
  id: totrans-1417
  prefs: []
  type: TYPE_IMG
- en: Figure C.36 Supply and demand problem solution obtained by MIDACO
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: For a higher number of schools, you can obtain an unlimited license or request
    a free academic trial of the unlimited version that can support up to 100,000
    variables.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: 'C.10 Chapter 11: Supervised and unsupervised learning'
  id: totrans-1420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.10.1 Exercises
  id: totrans-1421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   What are the traditional categories of machine learning algorithms?
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: b.  Supervised, unsupervised, unreinforced
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: b.  Supervised, hybrid, reinforcement
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: c.  Supervised, unsupervised, hybrid, reinforcement
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: d.  Unsupervised, semi-supervised, hybrid
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   The Kohonen map is trained using supervised learning to produce a two-dimensional
    representation of the input space of the training samples.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   What kind of tasks are common in supervised learning?
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: a.  Clustering and data reduction
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: b.  Classification and regression
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: c.  Feature extraction and anomaly detection
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: d.  Dimensionality reduction and normalization
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   What is the task of clustering in unsupervised learning?
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: a.  Group objects based on certain similarity measures
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: b.  Identify traffic signs in a self-driving car
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: c.  Map input features to known labels or classes
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: d.  Optimize a model’s performance by feedback loop
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   The pointer-network (Ptr-Net) model is designed to address specific limitations
    of conventional sequence-to-sequence (seq2seq) models, particularly in tasks involving
    variable-length output sequences.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   In reinforcement learning, how does a learning agent learn to make decisions?
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: a.  By minimizing the error between predicted and actual classes
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: b.  By identifying clusters within the input data
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: c.  By maximizing cumulative reward through actions in an environment
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: d.  By mapping input features to known labels or classes
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   What does deep learning (DL) enable in machine learning?
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: a.  Feature representation learning at different levels of abstractions
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: b.  Classification of different objects based on labeled data
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: c.  Grouping of similar data points based on certain measures
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: d.  Reward-based decision-making in an interactive environment
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   Graph embedding learns a mapping from a low-dimensional continuous domain
    to a discrete high-dimensional graph domain.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   How does DL reduce the need for extensive data preprocessing?
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: a.  By using a large amount of unlabeled data for training
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: b.  By learning through interactions in a feedback loop
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: c.  By approximating mapping functions between data and known labels
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: d.  By learning discriminative features from raw data automatically
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. Why is graph-structured data important in the field of combinatorial optimization?
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: a.  It helps to maximize cumulative rewards
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: b.  It assists in mapping functions between data and labels
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: c.  It captures and represents the relationships and constraints between elements
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: d.  It groups objects based on similarity measures
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Match the terms and descriptions shown in table C.17.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: Table C.17
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: '| Terms | Descriptions |'
  id: totrans-1469
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1470
  prefs: []
  type: TYPE_TB
- en: '| 1\. Self-organizing map (SOM) | a. A polygon that fully encompasses a given
    set of points with maximum area and minimum boundary or circumference of the shape.
    |'
  id: totrans-1471
  prefs: []
  type: TYPE_TB
- en: '| 2\. Convex hull | b. A mechanism that allows the model to dynamically prioritize
    which parts of the input are most relevant for each output it''s trying to predict,
    making it more effective at understanding context and reducing confusion from
    long input sequences |'
  id: totrans-1472
  prefs: []
  type: TYPE_TB
- en: '| 3\. Pointer-network (Ptr-Net) | c. A type of artificial neural network that
    is trained using unsupervised learning to produce a low-dimensional (typically
    two-dimensional), discretized representation of the input space of the training
    samples |'
  id: totrans-1473
  prefs: []
  type: TYPE_TB
- en: '| K-hop neighborhood | d. A set of neighboring nodes at a distance less than
    or equal to K |'
  id: totrans-1474
  prefs: []
  type: TYPE_TB
- en: '| 5\. Attention mechanism | e. A type of neural network architecture designed
    to deal with variable-sized input data sequences |'
  id: totrans-1475
  prefs: []
  type: TYPE_TB
- en: '3.   Find the shortest path to visit 20 major US cities starting from New York
    City using self-organizing maps. The cities are given by the names and GPS latitude
    and longitude coordinates as follows:'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: •   New York City (40.72, –74.00)
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: •   Philadelphia (39.95, –75.17)
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: •   Baltimore (39.28, –76.62)
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: •   Charlotte (35.23, –80.85)
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: •   Memphis (35.12, –89.97)
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: •   Jacksonville (30.32, –81.70)
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: •   Houston (29.77, –95.38)
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: •   Austin (30.27, –97.77)
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: •   San Antonio (29.53, –98.47)
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: •   Fort Worth (32.75, –97.33)
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: •   Dallas (32.78, –96.80)
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: •   San Diego (32.78, –117.15)
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: •   Los Angeles (34.05, –118.25)
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: •   San Jose (37.30, –121.87)
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: •   San Francisco (37.78, –122.42)
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: '•   Indianapolis'': (39.78, –86.15)'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: •   Phoenix (33.45, –112.07)
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: •   Columbus (39.98, –82.98)
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: •   Chicago (41.88, –87.63)
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: •   Detroit (42.33, –83.05)
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Optimizing the hyperparameters can significantly improve the performance
    of the ML model. Tune the hyperparameters in listing 11.6, and observe the effect
    on the ConvexNet model’s performance with different testing datasets. The hyperparameters
    to be tuned include
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of input features for the model
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of embedding dimensions
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of hidden units in the model
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of attention heads in the multi-head self-attention mechanism
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of layers in the model
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: •   The dropout probability
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: •   The number of training epochs
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: •   The batch size used during training
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: •   The learning rate for the optimizer
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: C.10.2 Solutions
  id: totrans-1507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   c) Supervised, unsupervised, hybrid, reinforcement
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   b) False (The Kohonen map is trained using unsupervised learning to produce
    a low-dimensional representation of the input space of the training samples, not
    supervised learning.)
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   b) Classification and regression
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   a) Group objects based on certain similarity measures
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   a) True
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   c) By maximizing cumulative reward through actions in an environment
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   a) Feature representation learning at different levels of abstractions
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   b) False (Graph embedding learns a mapping from a discrete high-dimensional
    graph domain to a low-dimensional continuous domain, not the other way around.)
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   d) By learning discriminative features from raw data automatically
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. c) It captures and represents the relationships and constraints between
    elements
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: 2.   1-c, 2-a, 3-e, 4-d, and 5-b.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: 3.   MiniSom is used in this listing. MiniSom is a minimalistic and Numpy-based
    implementation of the SOM. You can install this library using !pip install minisom.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: The next listing shows how to solve the 20-city TSP using self-organizing maps.
    We start by importing the libraries and modules, defining the cities of interest,
    and calculating the haversine distances between pairs of cities.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.20 Solving TSP using SOM
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ① Define latitude and longitude for twenty major US cities.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a haversine distance matrix based on latitude-longitude coordinates.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: ③ Convert the distance dictionary into a dataframe.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: ④ Get the haversine distances between pairs of cities.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: We then define a SOM to solve the TSP instance. This SOM is 1D with *N* neurons.
    The dimensionality of the input data is 2 (latitude and longitude coordinates).
    The sigma parameter is used for the Gaussian neighborhood function. This parameter
    controls the spread of the influence of neighboring neurons during training. The
    learning rate determines the step size of weight updates during training. The
    neighborhood function used during training is set to Gaussian, which means the
    influence of neighboring neurons decreases with distance. The seed for the random
    number generator is set to 50 to ensure reproducibility of the results.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ① Set the number of neurons (nodes) for the 1D SOM.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a self-organizing map with 1xN_neurons grid.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: ③ Initialize the weights.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet generates a set of visualizations to show the progress
    of the SOM training:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Figure C.37 shows the visualized plots.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F37_Khamis.png)'
  id: totrans-1536
  prefs: []
  type: TYPE_IMG
- en: Figure C.37 Progress of SOM training with increasing numbers of iterations
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: 'C.11 Chapter 12: Reinforcement learning'
  id: totrans-1538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C.11.1 Exercises
  id: totrans-1539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Multiple choice and true/false: Choose the correct answer for each of
    the following questions.'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   In reinforcement learning, what does the term “reward” represent?
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: a.  The penalty for performing an action
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: b.  The immediate feedback received from the environment
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: c.  The probability of taking a particular action
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: d.  The number of steps taken by the agent
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   The goal of reinforcement learning is to
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: a.  Minimize the cumulative reward
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: b.  Find the shortest path to the goal state
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: c.  Learn an optimal policy to maximize cumulative rewards
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: d.  Achieve a deterministic environment
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   Which of the following RL algorithms is considered model-free?
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: a.  Expert iteration
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: b.  Proximal policy optimization (PPO)
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: c.  Imagination-augmented agents (I2A)
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: d.  None of the above
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   The concept of a “discount factor” in reinforcement learning is used
    to
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: a.  Reduce the size of the state space
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: b.  Decrease the rewards obtained from the environment
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: c.  Balance the importance of immediate rewards and future rewards
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: d.  Encourage exploration over exploitation
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   Which of the following RL algorithms is considered an on-policy RL method?
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: a.  Q-learning
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: b.  Twin-delayed deep deterministic policy gradient (TD3)
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: c.  Deep deterministic policy gradient (DDPG)
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: d.  Proximal policy optimization (PPO)
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: 1.6   PPO-clip and PPO-penalty are two variants of the policy gradient method
    designed to address potential instability during training.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   Which multi-armed bandit strategy randomly selects a slot machine at
    each trial without considering past results?
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: a.  Exploit-only greedy strategy
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: b.  Epsilon-greedy strategy
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: c.  Upper confidence bound (UCB) strategy
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: d.  Explore-only strategy
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   In the *ε*-greedy strategy, how does the agent balance exploration and
    exploitation?
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: a.  It always selects the machine with the highest estimated mean reward.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: b.  It randomly selects a machine with a certain probability (epsilon) and otherwise
    selects the machine with the highest estimated mean reward.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: c.  It explores all machines equally during each trial.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: d.  It focuses on exploiting the current best machine only.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   What does “regret” measure in the multi-armed bandit problem?
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: a.  The difference between the maximum possible reward and the reward obtained
    from each selected machine
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: b.  The number of times the agent chooses to explore a new machine
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: c.  The total time spent in the same single state
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: d.  The total number of arms or actions available to the agent
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. What does the Markov decision process (MDP) represent in the context of
    reinforcement learning?
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: a.  A process that involves making decisions without considering state transitions
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: b.  A method for supervised learning using labeled datasets
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: c.  A mathematical framework for planning under uncertainty, in which actions
    influence future states with certain probabilities
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: d.  A type of optimization algorithm for clustering data
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Imagine you are a digital marketer running an online advertising campaign.
    You have several ad variations that you can display to users, each with its own
    click-through rate (CTR) or conversion rate. Click-through measures the rate at
    which users click on a link, while conversion measures the rate at which users
    complete a desired action after clicking on the link, such as making a purchase,
    signing up for a newsletter, or completing a form. Your goal is to maximize user
    engagement or conversions by selecting the most effective ad variation.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume you have three ad variations, represented by arms A1, A2, and A3\.
    Each ad variation has an associated probability distribution of click-through
    or conversion rates, denoted as Q1, Q2, and Q3\. These probability distributions
    represent the likelihood of a user clicking on each ad variation. At each time
    step *t*, you need to choose an ad variation *A* to display to users. When ad
    variation *A* is displayed, users interact with it, and you observe the outcome,
    which can be a click or a conversion. The outcome is drawn from the probability
    distribution *Q*(*A*), representing the likelihood of a click or conversion for
    ad variation *A*. Assume that the three probability distributions Q1, Q2, and
    Q3 are normal distributions with means of {7, 10, 6} and standard deviations of
    {0.45, 0.65, 0.35} respectively. Your objective is to maximize the cumulative
    number of clicks over a series of ad displays (let’s say 10,000 ad displays).
    Write Python code to implement an *ε*-greedy strategy to determine which ad variation
    to display at each time step based on the estimated click-through rates.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: '3.   The taxi environment is based on the taxicab, or ride-hailing, problem,
    where a taxi must pick up a passenger from one location and drop them off at another
    specified location. The goal of the agent is to learn a policy that navigates
    the taxi through the grid to pick up and drop off passengers while maximizing
    the cumulative reward. When the episode starts, the taxi is at a random square,
    and the passenger is at a random location. The taxi drives to the passenger’s
    location, picks them up, drives to the passenger’s destination (another one of
    the four specified locations), and drops off the passenger. Once the passenger
    is dropped off, the episode ends. The states, actions, and rewards are as follows:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '•   States (observation space includes 500 discrete states): 25 taxi positions
    (any location within the 5 × 5 grid world); 5 passenger locations (0: R(ed); 1:
    G(reen); 2: Y(ellow); 3: B(lue); 4: in taxi) and 4 destinations (0: R(ed); 1:
    G(reen); 2: Y(ellow); 3: B(lue)). Thus, this taxi environment has a total of 5
    × 5 × 5 × 4 = 500 possible states.'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: '•   Actions (action space includes 6 discrete actions): 0 = move south; 1 =
    move north; 2 = move east; 3 = move west; 4 = pick up passenger, and 5 = drop
    off passenger.'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: '•   Rewards: +20 (a high positive reward for a successful drop off); –10 (a
    penalty for executing pickup and drop-off actions illegally, such as if the agent
    tries to drop off a passenger in a wrong location), and –1 (a slight negative
    reward for not making it to the destination after every time step, to mimic the
    delay).'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: 'Write Python code to show how to use A2C to learn the optimal policy for this
    environment. Experiment with vectorized environments where multiple independent
    environments are stacked into a single environment. Vectorized environments enable
    you to run multiple instances of an environment in parallel. Instead of training
    an RL agent on one environment per step, it allows you to train it on *n* environments
    per step. For example, if you want to run four parallel environments, you can
    specify this number when you create the environment, as follows: `env = make_vec_env("Taxi-v3",
    n_envs=4, seed=0`.'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: '4.   In preparing for a scheduled flight, an airline’s flight operations team
    is tasked with selecting the best flight route and service according to the shared
    context. The shared context represents the type of flight (domestic or international)
    and the type of passengers (business class, economy class, or a mix). The flight
    operations team must decide the best strategy for flight route, meal service,
    and in-flight entertainment. The options are represented as follows:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: •   *Flight route*—The most direct route, a fuel-efficient route that may be
    longer, or a route that avoids turbulence but may require more time
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: •   *Meal service*—Full meal with multiple options, a simple meal with fewer
    options, or just snacks and beverages
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: •   *In-flight entertainment*—Movies and music, in-flight Wi-Fi service, or
    a combination of both
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: The reward is how satisfactory the chosen options are for a given flight (shared
    context). The reward function receives as arguments the shared context (the type
    of flight and passenger class) and the selected actions for each option (the chosen
    flight route, meal service, and in-flight entertainment). To mirror real-world
    scenarios and complexities, we inject normal noise in the reward value. The objective
    is to select the best action from the available combinatorial actions in such
    a way that it maximizes the total reward. Write Python code to train and test
    a contextual bandit for this problem.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Listing 11.4 shows how to solve TSP using an ML model pretrained with a
    supervised approach or a reinforcement learning approach. Replace the supervised
    learning model sl-ar-var-20pnn-gnn-max_20200308T172931 with the pretrained RL
    model rl-ar-var-20pnn-gnn-max_20200313T002243, and report your observations.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: 6.   The gym-electric-motor (GEM) package is a Python toolbox designed for simulating
    and controlling electric motors. It is built upon OpenAI Gym environments and
    is suitable for classical control simulations and reinforcement learning experiments.
    Use GEM to define a permanent magnet synchronous motor (PMSM) environment as shown
    in figure C.38\. For more information about PMSM and GEM, see Traue et al.’s article
    “Toward a reinforcement learning environment toolbox for intelligent electric
    motor control” [10].
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F38_Khamis.png)'
  id: totrans-1603
  prefs: []
  type: TYPE_IMG
- en: Figure C.38 The gym-electric-motor (GEM) environment described in Traue et al
    's article [9]
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.24, provided in the book’s GitHub repo, provides a simplified implementation
    of PPO for electric motor control. This code is used to train a control model
    (a PPO RL agent) to control the current for a permanent magnet synchronous motor.
    This agent mainly controls the converter that converts the supply currents to
    the currents flowing into the motor. Experiment with different parameters in this
    algorithm and consider trying other RL models available in Stable-Baselines3 (SB3).
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: C.11.2 Solutions
  id: totrans-1606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Multiple choice and true/false
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.   b) The immediate feedback received from the environment
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.   c) Learn an optimal policy to maximize cumulative rewards.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.   b) Proximal policy optimization (PPO)
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.   c) Balance the importance of immediate rewards and future rewards.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.   d) Proximal policy optimization (PPO)
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.   a) True
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.   d) Explore-only strategy
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.   b) It randomly selects a machine with a certain probability (epsilon)
    and otherwise selects the machine with the highest estimated mean reward.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.   a) The difference between the maximum possible reward and the reward
    obtained from each selected machine
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: 1.10. c) A mathematical framework for planning under uncertainty, in which actions
    influence future states with certain probabilities
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Listing C.21 shows an implementation of a *ε*-greedy strategy to determine
    which ad variation to display at each time step based on the estimated click-through
    rates. In this code snippet, 10,000 ad displays are simulated. The estimates of
    the click-through rates for each ad variation are updated after each display.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.21 Online advertising using MAB
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-1620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ① Initialize the number of arms (actions).
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize the number of trials (ads).
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: ③ Probability distribution of each arm
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: ④ Counters for each arm
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Select an initial arm.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Set the epsilon value of the epsilon-greedy algorithm.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Exploitation
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Add a small constant to avoid division by zero.
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Exploration
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Calculate and print the estimated click-through rates.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: In this script, `counts` keeps track of the number of times each ad variation
    has been displayed, and `rewards` keeps track of the total number of clicks for
    each ad variation. At the end of the script, the estimated click-through rates
    for each ad variation are calculated and printed.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Listing C.22 shows the steps of learning the optimal policy for the taxicab
    problem using A2C. This code uses Stable-Baselines3 (SB3), a library for reinforcement
    learning, to train an agent using A2C on the Taxi-v3 environment. The SB3 function
    make_vec_env is used to create a vectorized environment that can run multiple
    parallel environments in the same process. The SB3 function evaluate_policy is
    used to evaluate the learned policy of the agent.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.22 Dispatching a taxicab using A2C RL
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-1634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ① Create a vectorized environment with a single parallel environment (n_envs=1).
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: ② Print the observation and action spaces of the environment.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create an A2C agent with MlpPolicy as the policy network.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: ④ Train the A2C agent on the Taxi-v3 environment for 10,000 timesteps.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: After the training is complete, the agent will have learned an optimal policy
    for navigating the Taxi-v3 environment to efficiently pick up and drop off passengers
    at the correct locations. The following code snippet visualizes the learned policy
    by rendering the Taxi-v3 environment using the trained A2C agent.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ① Create an empty list to store the frames (images) of the rendered environment.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: ② Retrieve the environment associated with the model.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: ③ Reset the environment and obtain the initial observation after the reset.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: ④ Predict an action based on the current observation.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Get a new observation and the reward.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Render the environment as an RGB image.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Clear the output for the next image.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: '4.   Listing C.23 shows the implementation of a contextual bandit for an airline’s
    flight operations using the Vowpal Wabbit Python library. The shared context is
    defined by two lists: flight_types and passenger_classes. The possible choices,
    or actions, for the bandit problem are defined by flight_routes, meal_services,
    and entertainment_options. The reward_function calculates the reward associated
    with a particular combination of flight route, meal service, and entertainment
    option. The rewards are generated using a normal distribution with different means
    for different choices. The standard deviation (scale) is set to 0.05, implying
    that the rewards are sampled from a normal distribution with a small amount of
    variance.'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: Listing C.23 Contextual bandit for an airline’s flight operations
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ① Set the shared context.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: ② Set possible choices/action options.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: ③ Calculate the reward associated with a particular combination of options.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation, the following two utility functions are defined. `generate_combinations`
    generates combinations of flight routes, meal services, and entertainment options,
    along with their associated descriptions. `sample_truck_pmf` performs sampling
    based on a probability mass function (PMF):'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-1655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can now create a contextual bandit using the Vowpal Wabbit (VW) library
    and evaluate its performance over a specified number of iterations. This contextual
    bandit will make decisions (select actions) in the context of different flight
    types and passenger classes to maximize the expected reward:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here are the key arguments to create contextual bandit:'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: •   `--cb_explore_adf`—Enables contextual bandit exploration with action-dependent
    features
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: •   `--epsilon 0.2`—Sets the exploration rate to 0.2, meaning that the bandit
    will explore non-greedy actions with a probability of 0.2 (20% of the time)
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: •   `--interactions AA AU AAU`—Specifies three-way interactions between features
    AA, AU, and AAU
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: •   `-l 0.05`—Sets the learning rate to 0.05, which controls the step size in
    the learning process
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: •   `--power_t 0`—Specifies that the learning rate is constant (no learning
    rate decay)
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: •   `num_iterations = 2500`
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet allows us to run the created contextual bandit to
    make decisions:'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ① Set the number of iterations.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize an empty to store the rewards at each iteration.
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: ③ Select a random shared context in each iteration.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: ④ Generate all possible combinations of flight routes, meal services, and entertainment
    options based on the chosen shared context.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Predict the expected reward for each action (combination).
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Sample an index from the predicted rewards.
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Retrieve individual choices for flight route, meal service, and entertainment.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Calculate the reward associated with the chosen action (combination) and shared
    context.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Append the reward information to the example.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Learn from the updated examples.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: ⑪ Close the workspace and finalize the learning process.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: 'We can print the average reward during training as follows:'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Figure C.39 shows the progress of an average reward obtained in each iteration
    during the learning process.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPC_F39_Khamis.png)'
  id: totrans-1681
  prefs: []
  type: TYPE_IMG
- en: Figure C.39 Average reward in each iteration during the learning process
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete version of listing C.23 provided in the book’s GitHub repo defines
    a `test_model` function and then tests the contextual bandit model using a given
    shared context. The `test_model` function is defined to test the contextual bandit
    model by simulating a single decision-making instance for a given shared context.
    It takes four parameters—`shared_context`, `flight_routes`, `meal_services`, and
    `entertainment_options`:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ① Generate all possible combinations of flight routes, meal services, and entertainment
    options based on the given shared context.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: ② Predict the expected reward for each action (combination) based on the provided
    examples.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: ③ Sample an index from the predicted rewards.
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: ④ Retrieve the chosen action (combination).
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Retrieve individual choices for flight route, meal service, and entertainment.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Calculate the expected reward associated with the chosen action and shared
    context.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Print the chosen action and the expected reward.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Set a specific shared context.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Test the contextual bandit model's decision-making process for this specific
    context.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will generate the output like the following for the given context:'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-1695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '5.   Replacing the included supervised learning model, sl-ar-var-20pnn-gnn-max_20200308T172931,
    with the pretrained RL model, rl-ar-var-20pnn-gnn-max_20200313T002243, in listing
    11.4 is done as follows:'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-1697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 6.   Listing C.24, available in the book’s GitHub repo, provides a simplified
    implementation of PPO for electric motor control. Experiment with the different
    parameters of this algorithm and consider trying other RL models available in
    SB3, such as advantage actor-critic (A2C), soft actor-critic (SAC), deep deterministic
    policy gradient (DDPG), deep Q network (DQN), hindsight experience replay (HER),
    and twin delayed DDPG (TD3).
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
