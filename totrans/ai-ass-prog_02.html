<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. New World for Developers" data-type="chapter" epub:type="chapter"><div class="chapter" id="new_world_for_developers">&#13;
<h1><span class="label">Chapter 1. </span>New World for Developers</h1>&#13;
&#13;
<p>While juggling dense neural network<a contenteditable="false" data-primary="AI-assisted programming" data-type="indexterm" id="xi_AIassistedprogramming.01.3.39"/> architectures and pixel-wrangling computer vision at Stanford from 2011 to 2016, <a href="https://oreil.ly/m4fFk">Andrej Karpathy</a> also moonlighted<a contenteditable="false" data-primary="Karpathy, Andrej" data-type="indexterm" id="id261"/> at Google. Over there, he tinkered around and whipped up a feature-learning system for YouTube videos. Then he decided to become a founding member of OpenAI and later the senior director of AI at Tesla, where he led a team to create the Autopilot system.</p>&#13;
&#13;
<p>It’s safe to say he’s one the world’s top coders. He is also a skilled wordsmith with a massive Twitter—or X—following of nearly 800,000 followers. When ChatGPT catapulted onto the scene, he <a href="https://oreil.ly/9kBmX">tweeted</a>:</p>&#13;
&#13;
<blockquote>&#13;
<p>The hottest new programming language is English.</p>&#13;
</blockquote>&#13;
&#13;
<p>He wasn’t kidding. This wasn’t just a poetic ode to coding but a nod to a future where typing out natural language prompts could conjure up computer code in seemingly any language. It’s like having a bilingual genie in your computer, ready to transcribe your English wishes into code commands.</p>&#13;
&#13;
<p>Then there came a <a href="https://oreil.ly/a_jg1">tweet</a> that echoed the sentiments of many developers:</p>&#13;
&#13;
<blockquote>&#13;
<p>Copilot<a contenteditable="false" data-primary="GitHub Copilot" data-type="indexterm" id="id262"/> has dramatically accelerated my coding, it’s hard to imagine going back to “manual coding”. Still learning to use it but it already writes ~80% of my code, ~80% accuracy. I don’t even really code, I prompt. &amp; edit.</p>&#13;
</blockquote>&#13;
&#13;
<p>Karpathy was tipping his hat to Microsoft’s GitHub Copilot, a fresh brew of AI-assisted programming. But it wouldn’t be long until many other tools sprouted up. The pace of innovation was breathtaking.</p>&#13;
&#13;
<p>Now, for all the coders out there, the landscape might look like a dense jungle. What’s this brave new world of AI tools? Where do they dazzle, and where do they fizzle? And how do you wade through all this to become a savvy AI-assisted programmer?</p>&#13;
&#13;
<p>Well, this book will be your guide to help answer these questions—and many more. The spotlight will be on harnessing these tools to code not just faster but smarter, and with a sprinkle of fun. So, let’s roll up our sleeves and jump into this AI-assisted programming journey.</p>&#13;
&#13;
<section data-pdf-bookmark="Evolution and Revolution" data-type="sect1"><div class="sect1" id="evolution_and_revolution">&#13;
<h1>Evolution and Revolution</h1>&#13;
&#13;
<p>A key theme of the evolution<a contenteditable="false" data-primary="AI-assisted programming" data-secondary="evolution and revolution" data-type="indexterm" id="xi_AIassistedprogrammingevolutionandrevolution.01.18.32"/> of programming languages is <em>abstraction</em>. This is a fancy way of describing how systems get easier for developers to use. When the tedious details are handled in the background, developers can focus on what matters most. This has been a driving force of innovation, allowing for breakthroughs like the internet, cloud computing, mobile, and AI.</p>&#13;
&#13;
<p><a data-type="xref" href="#the_abstraction_of_programming_languages">Figure 1-1</a> highlights the evolution of abstraction over the decades.</p>&#13;
&#13;
<figure><div class="figure" id="the_abstraction_of_programming_languages"><img alt="" src="assets/aiap_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>The abstraction of programming languages and tools has evolved over the <span class="keep-together">decades</span></h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Let’s go into more detail, starting from the 1940s<a contenteditable="false" data-primary="LLMs" data-see="large language models" data-type="indexterm" id="id263"/><a contenteditable="false" data-primary="AI-assisted programming" data-secondary="coding technology" data-see="coding technology" data-type="indexterm" id="id264"/><a contenteditable="false" data-primary="Copilot" data-see="GitHub Copilot" data-type="indexterm" id="id265"/><a contenteditable="false" data-primary="frontend development" data-see="web development" data-type="indexterm" id="id266"/><a contenteditable="false" data-primary="ChatGPT" data-secondary="coding techniques" data-see="coding techniques with AI" data-type="indexterm" id="id267"/><a contenteditable="false" data-primary="AI-assisted programming" data-secondary="coding techniques" data-see="coding techniques with AI" data-type="indexterm" id="id268"/><a contenteditable="false" data-primary="CLI" data-see="command line interface" data-type="indexterm" id="id269"/>:</p>&#13;
&#13;
<dl>&#13;
	<dt>Machine language to assembly language</dt>&#13;
	<dd>&#13;
	<p>At the dawn of the computer age, programmers had to wrestle with 0s and 1s to bend machines to their will. But then, assembly language came onto the scene. <span class="keep-together">It offered</span> alphanumeric instructions, which made coding easier and less <span class="keep-together">error-prone.</span></p>&#13;
	</dd>&#13;
	<dt>High-level languages</dt>&#13;
	<dd>&#13;
	<p>The 1950s brought us Fortran and COBOL, languages that let programmers code using somewhat plain English like DISPLAY, READ, WRITE, and IF/THEN/ELSE. A compiler would convert these into the 0s and 1s that a computer could understand. At the same time, people without a technical background could generally read the code well enough to understand the workflow. The emergence of high-level languages would be a huge catalyst for the computer revolution.</p>&#13;
	</dd>&#13;
	<dt>Procedural programming</dt>&#13;
	<dd>&#13;
	<p>Languages like C and Pascal introduced procedural programming<a contenteditable="false" data-primary="procedural programming" data-type="indexterm" id="id270"/>, essentially packing complex tasks into neat little boxes called functions. This abstraction allowed for reusability and maintainability, and it made managing colossal software projects less of a Herculean task.</p>&#13;
	</dd>&#13;
	<dt>Object-oriented programming (OOP)</dt>&#13;
	<dd>&#13;
	<p>Some of the stars of this type of computer language include C++ and Java. Object-oriented programming<a contenteditable="false" data-primary="object-oriented programming (OOP)" data-type="indexterm" id="id271"/> brought a whole new level of abstraction, allowing programmers to model real-world entities using classes and objects, encapsulating both data and behavior. This promoted modularity and allowed for more intuitive problem solving.</p>&#13;
	</dd>&#13;
	<dt>Scripting languages and web development</dt>&#13;
	<dd>&#13;
	<p>Python, Ruby, and JavaScript abstract<a contenteditable="false" data-primary="scripting languages" data-type="indexterm" id="id272"/><a contenteditable="false" data-primary="web development" data-type="indexterm" id="id273"/> many of the lower-level tasks associated with programming. They offer extensive libraries and built-in data structures, simplifying common programming tasks and reducing the amount of code needed to accomplish them.</p>&#13;
	</dd>&#13;
	<dt>Machine learning and AI</dt>&#13;
	<dd>&#13;
	<p>With the rise of AI and machine learning<a contenteditable="false" data-primary="machine learning (ML)" data-seealso="prompt engineering" data-type="indexterm" id="id274"/><a contenteditable="false" data-primary="ML (machine learning)" data-seealso="prompt engineering" data-type="indexterm" id="id275"/>, specialized libraries and frameworks like TensorFlow and PyTorch have abstracted away many intricate mathematical details of programming. This has enabled developers to focus on model architecture and training processes.</p>&#13;
	</dd>&#13;
	<dt class="pagebreak-before less_space">AI-assisted programming</dt>&#13;
	<dd>&#13;
	<p>Of course, the latest entrant to this abstraction narrative is AI-assisted programming, á la GPT-4 and other massive large language models (LLMs)<a contenteditable="false" data-primary="large language models (LLMs)" data-type="indexterm" id="id276"/>. These are like your backstage crew, ready to pitch in with code generation at your <span class="keep-together">command.</span></p>&#13;
	</dd>&#13;
</dl>&#13;
&#13;
<p>Let’s look at a simple example. For this, we’ll use ChatGPT<a contenteditable="false" data-primary="ChatGPT" data-secondary="code from prompt example" data-type="indexterm" id="id277"/>, which has a robust ability to gin up code. We will use a prompt to ask what we want the system to do. Suppose we give it the following prompt:</p>&#13;
&#13;
<blockquote>&#13;
<p><em>Prompt:</em> In Python, write a program that checks if a given integer is even or odd and print the result.</p>&#13;
</blockquote>&#13;
&#13;
<p><a data-type="xref" href="#when_asked_to_create_codecomma_chatgptap">Figure 1-2</a> shows the response from ChatGPT.</p>&#13;
&#13;
<figure><div class="figure" id="when_asked_to_create_codecomma_chatgptap"><img alt="" src="assets/aiap_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>When asked to create code, ChatGPT’s response will include not only a listing but an explanation</h6>&#13;
</div></figure>&#13;
&#13;
<p>We get the code listing, which even comes with helpful comments. Then there is also an explanation of how the program works. You can press the Copy code button at the top right to include the code in your IDE and run it<a contenteditable="false" data-primary="" data-startref="xi_AIassistedprogrammingevolutionandrevolution.01.18.32" data-type="indexterm" id="id278"/>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Generative AI" data-type="sect1"><div class="sect1" id="generative_ai">&#13;
<h1>Generative AI</h1>&#13;
&#13;
<p>Before we go deeper into how AI-assisted programming tools work, let’s get an overview of generative AI<a contenteditable="false" data-primary="AI-assisted programming" data-secondary="generative AI" data-type="indexterm" id="id279"/><a contenteditable="false" data-primary="generative AI" data-type="indexterm" id="id280"/>. This is the foundation of these systems.</p>&#13;
&#13;
<p>Generative AI is a branch of artificial intelligence (AI), which allows for the creation of new and unique content. <a data-type="xref" href="#there_are_different_types_of_aicomma_and">Figure 1-3</a> provides a visual of how the different parts relate to each other.</p>&#13;
&#13;
<figure><div class="figure" id="there_are_different_types_of_aicomma_and"><img alt="" src="assets/aiap_0103.png"/>&#13;
<h6><span class="label">Figure 1-3. </span>There are different types of AI, and they can be represented as nested subsets, with generative AI and finally large language models at the center</h6>&#13;
</div></figure>&#13;
&#13;
<p>AI is the big umbrella: it includes all systems that can pull off tasks with the flair of human intelligence. Tucked within AI is machine learning (ML). Instead of marching to the beat of explicit instructions, ML systems come up with insights based on heaps of data. ML is generally based on complex algorithms, which allow for making predictions or decisions without hardcoding.</p>&#13;
&#13;
<p>Take a step deeper, and you get deep learning (DL)<a contenteditable="false" data-primary="deep learning (DL)" data-type="indexterm" id="id281"/><a contenteditable="false" data-primary="DL (deep learning)" data-type="indexterm" id="id282"/>, a tighter slice of ML that rolls with neural networks<a contenteditable="false" data-primary="neural networks" data-secondary="deep learning" data-type="indexterm" id="id283"/> stacked with hidden layers—hence the <em>deep</em> tag. These stacked models have shown standout results in areas like image and speech recognition.</p>&#13;
&#13;
<p>Within the corridors of deep learning, you’ll find generative AI (or GenAI). GenAI models create new data that reflects their training data.</p>&#13;
&#13;
<p>In the innermost circle sits LLMs<a contenteditable="false" data-primary="large language models (LLMs)" data-type="indexterm" id="id284"/>, such as GPT-4, Gemini, Claude, and LLaMA 2. These powerful models—often called “foundation models”—churn out human-esque text based on cutting-edge algorithms and training on huge amounts of data.</p>&#13;
&#13;
<p>But generative AI is more than just LLMs. GenAI also has multimodal capabilities<a contenteditable="false" data-primary="multimodal capabilities" data-type="indexterm" id="id285"/>, meaning the ability to create images, audio, and video.</p>&#13;
&#13;
<p>In the next chapter, we’ll dive deeper into how generative AI works. But next, let’s now take a look at the pros and cons of AI-assisted programming tools.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="The Benefits" data-type="sect1"><div class="sect1" id="the_benefits">&#13;
<h1>The Benefits</h1>&#13;
&#13;
<p>AI-assisted programming<a contenteditable="false" data-primary="AI-assisted programming" data-secondary="benefits" data-type="indexterm" id="xi_AIassistedprogrammingbenefits.01.69.27"/> tools are crafted to enhance developers’ abilities, enabling them to zero in on advanced problem solving and innovations instead of being ensnared in monotonous tasks or complex code details. This is why GitHub’s use of the word <em>copilot</em> is spot on. It’s about having that reliable buddy in the cockpit, navigating through the intricate and often tedious aspects of coding, allowing you to focus on what matters.</p>&#13;
&#13;
<p>In the upcoming sections, we’ll spotlight the benefits and practical applications of these powerful systems.</p>&#13;
&#13;
<section data-pdf-bookmark="Minimizing Search" data-type="sect2"><div class="sect2" id="minimizing_search">&#13;
<h2>Minimizing Search</h2>&#13;
&#13;
<p>Developers<a contenteditable="false" data-primary="search, minimizing with AI" data-type="indexterm" id="xi_searchminimizingwithAI.01.73.14"/> often find themselves playing digital detectives, hunting down pesky bugs or wrapping their heads around cryptic codes. When they bump into a snag, their first instinct is to hit up Google or pay a visit to Stack Overflow. A quick search, a snippet of code, and voilá, they’re back to their IDE (integrated development <span class="keep-together">environment</span>).</p>&#13;
&#13;
<p>But sometimes this can turn into an ordeal. The discussion on Stack Overflow may wind up being a dead end. You search some more—but nothing seems to be on point. However, there’s one discussion that somewhat helps, and you do further research on some related topics. You even search YouTube for a video. After chewing on the problem for more than 30 minutes, you finally solve it.</p>&#13;
&#13;
<p>Yes, all developers have experienced this. Interestingly enough, the 2022 Developer Survey<a contenteditable="false" data-primary="Stack Overflow" data-type="indexterm" id="id286"/> from <a href="https://oreil.ly/WQ6De">Stack Overflow</a>, which included responses from more than 70,000 developers, highlights this frustration. It found that 62% of the respondents spent more than 30 minutes a day searching for answers, and 25% spent over an hour a day. According to the survey, “For a team of 50 developers, the amount of time spent searching for answers/solutions adds up to between 333–651 hours of <em>time lost per week</em> across the entire team.”</p>&#13;
&#13;
<p>Now, what if there was a way to slice through this thicket of time-consuming searches and get to the solution pronto? Enter AI-assisted programming, our knight in shining algorithm. Research from Microsoft supports this: it shows that more than 90% of developers who used GitHub Copilot managed to race through their tasks at a faster clip.</p>&#13;
&#13;
<p>Microsoft even put this to the test in a coder showdown. The company recruited 95 professional developers and split them into two groups. The task was to write an HTTP server in JavaScript. Those who used <a contenteditable="false" data-primary="GitHub Copilot" data-secondary="benefits" data-type="indexterm" id="id287"/>GitHub Copilot <a href="https://oreil.ly/TtsA0">completed the job 55% faster</a> than those who did not.</p>&#13;
&#13;
<p>And it’s not just Microsoft singing praises. McKinsey &amp; Company also conducted a <a href="https://oreil.ly/xOLj3">research study</a>. More than 40 developers from across the United States and Asia participated, with varying degrees of experience and backgrounds. Over several weeks, they completed three common software tasks: code generation, refactoring, and documentation.</p>&#13;
&#13;
<p>The results? When it came to documentation for keeping the code neat and tidy, AI-assisted tools were the standouts, cutting the time spent by half, and AI tools performed nearly the same on drafting new code and refactoring.</p>&#13;
&#13;
<p>However, for complex tasks, the AI tools didn’t hit the high notes. The time trimmed was <a href="https://oreil.ly/c_7sx">shy of 10%</a>.</p>&#13;
&#13;
<p>Interestingly, the research also showed that reducing the time spent did not negatively impact the overall quality of the code, as reflected in, for example, bugs, readability, and maintainability. In fact, the AI-assisted programming tools provided marginal improvements. But this often was due to the fact that developers iterated with the tools.</p>&#13;
&#13;
<p>The McKinsey study provides the following takeaways:</p>&#13;
&#13;
<dl>&#13;
	<dt>Easing routine chores</dt>&#13;
	<dd>&#13;
	<p>The tools are great at tackling mundane tasks like autofilling code functions, aiding in real-time code completion, and autodocumenting code. By handling these tasks, they free up developers to dive into complex business issues and speedily deploy software features.</p>&#13;
	</dd>&#13;
	<dt>Producing smoother code drafts</dt>&#13;
	<dd>&#13;
	<p>Staring at a blank canvas can be daunting, but with generative AI tools, developers can nudge the creative process along by fetching code suggestions with a simple prompt, right within their IDE or separately. Many developers found these AI-based suggestions invaluable, as they helped the humans overcome the “blank screen problem” and get into the coding “zone” with a quicker pace.</p>&#13;
	</dd>&#13;
	<dt>Accelerating tweaks to existing code</dt>&#13;
	<dd>&#13;
	<p>With effective prompts, developers can adapt and improve existing code more swiftly. For instance, they can snag code from online libraries, pop it into a prompt, and then make iterative requests for AI-finessed adjustments based on specified criteria.</p>&#13;
	</dd>&#13;
	<dt>Enhancing developers’ prep for new challenges</dt>&#13;
	<dd>&#13;
	<p>The technology acts like a fast-track introductory course and helps developers get acquainted with unfamiliar coding environments or languages. When tackling something new, these tools step in like a seasoned buddy, shedding light on fresh concepts, dissecting various code bases, and dishing out comprehensive guides on framework usage.</p>&#13;
	</dd>&#13;
	<dt>Harnessing multiple tools</dt>&#13;
	<dd>&#13;
	<p>The research indicates that bringing multiple tools into play is more effective. Picture this: a developer swings one tool for prompts or chats, and another tool jumps in as part of the codebase, dishing out autocomplete options and suggestions. Developers found the first tool to be a whiz at fielding queries during code refactoring, thanks to its conversational finesse. On the flip side, the second tool showed effectiveness in conjuring up new code that was integrated smoothly with the development environment. When these AI tools teamed up for a task, developers saw a time efficiency surge of 1.5 to 2.5 times<a contenteditable="false" data-primary="" data-startref="xi_searchminimizingwithAI.01.73.14" data-type="indexterm" id="id288"/>.</p>&#13;
	</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Your Advisor" data-type="sect2"><div class="sect2" id="your_advisor">&#13;
<h2>Your Advisor</h2>&#13;
&#13;
<p>With ChatGPT, you can ask for advice<a contenteditable="false" data-primary="ChatGPT" data-secondary="as code advisor" data-secondary-sortas="code advisor" data-type="indexterm" id="id289"/> on many types of development activities. Here’s a prompt:</p>&#13;
&#13;
<blockquote>&#13;
<p><em>Prompt:</em> Please provide detailed tips and best practices for minimizing search time and enhancing productivity when programming. Include strategies related to code organization, documentation, tools, and mindset.</p>&#13;
</blockquote>&#13;
&#13;
<p><a data-type="xref" href="#you_can_get_useful_advice_on_programming">Figure 1-4</a> shows the response.</p>&#13;
&#13;
<p>ChatGPT provides three main areas to consider. It recommends using a modular design, maintaining consistent naming, and organizing files logically. It also advises prioritizing clear documentation with comments, docstrings, and READMEs. ChatGPT then goes on to mention using the search functions of an IDE, using tools like Git, and bookmarking key resources.</p>&#13;
<figure><div class="figure" id="you_can_get_useful_advice_on_programming"><img alt="" src="assets/aiap_0104.png"/>&#13;
<h6><span class="label">Figure 1-4. </span>You can get useful advice on programming tasks from ChatGPT</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="IDE Integration" data-type="sect2"><div class="sect2" id="ide_integration">&#13;
<h2>IDE Integration</h2>&#13;
&#13;
<p>Seamless integration with the IDE<a contenteditable="false" data-primary="integrated development environments (IDEs)" data-type="indexterm" id="id290"/><a contenteditable="false" data-primary="operating system platforms" data-type="indexterm" id="id291"/> is crucial for AI-assisted programming. It keeps the momentum of the development process going strong, without the heavy lifting of mastering a new platform. This means less time scrambling up the learning curve and more time coding and—let’s not forget—less switching between different platforms or tools means less friction and makes for a smoother coding journey.</p>&#13;
&#13;
<p>Then there is the advantage of real-time feedback. As developers knit together or tweak code, integrated tools are right there to spotlight errors, offer up corrections, or suggest a better way to get things done. This instantaneous back-and-forth of writing, feedback, and tweaking is like having a friendly coach by your side. You’ll be guided toward cleaner, more efficient code without the hassle of manual reviews or external checks.</p>&#13;
&#13;
<p>AI-assisted systems can also amp up an IDE by tuning into the broader coding narrative. The AI gets the gist of variable types, method signatures, and even the project’s structural blueprint to churn out relevant code suggestions. It’s not just about spitting out code, though.</p>&#13;
&#13;
<p><a data-type="xref" href="#ides_supported_by_popular_aihyphenassist">Table 1-1</a> introduces some of the top AI-assisted programming tools and the IDEs they support<a contenteditable="false" data-primary="Tabnine" data-type="indexterm" id="id292"/><a contenteditable="false" data-primary="CodiumAI" data-type="indexterm" id="id293"/><a contenteditable="false" data-primary="Amazon CodeWhisperer" data-type="indexterm" id="id294"/><a contenteditable="false" data-primary="CodeWhisperer (Amazon)" data-type="indexterm" id="id295"/>.</p>&#13;
&#13;
<table class="border" id="ides_supported_by_popular_aihyphenassist">&#13;
	<caption><span class="label">Table 1-1. </span>IDEs supported by popular AI-assisted programming tools</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th>AI-assisted programming tool</th>&#13;
			<th>IDEs</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>GitHub Copilot</td>&#13;
			<td>Visual Studio Code, Visual Studio, Vim, Neovim, JetBrains suite, Azure Data Studio 1</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Tabnine</td>&#13;
			<td>Visual Studio Code, WebStorm, PyCharm, Eclipse, IntelliJ Platform, PhpStorm, CLion, Neovim, JupyterLab, Rider, DataGrip, AppCode, Visual Studio 2022, Android Studio, GoLand, RubyMine, Emacs, Vim, Sublime Text, Atom.AI, Jupyter Notebook 2</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>CodiumAI</td>&#13;
			<td>Visual Studio Code, JetBrains (IntelliJ, WebStorm, CLion, PyCharm)</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Amazon CodeWhisperer</td>&#13;
			<td>Visual Studio Code, IntelliJ IDEA, AWS Cloud9, AWS Lambda console, JupyterLab, Amazon SageMaker Studio, JetBrains (IntelliJ, PyCharm, CLion, GoLand, WebStorm, Rider, PhpStorm, RubyMine, DataGrip)</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A <a href="https://oreil.ly/3e2sI">research study from Microsoft</a> showed that 88% of users of GitHub Copilot<a contenteditable="false" data-primary="GitHub Copilot" data-secondary="benefits" data-type="indexterm" id="id296"/> felt less frustrated and more focused. A key reason was that staying within the IDE meant spending less time searching. This allowed for the developer to remain in the “flow state.”</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Reflecting Your Codebase" data-type="sect2"><div class="sect2" id="reflecting_your_codebase">&#13;
<h2>Reflecting Your Codebase</h2>&#13;
&#13;
<p>Certain AI-assisted programming<a contenteditable="false" data-primary="codebase, AI-assisted programming reflecting" data-type="indexterm" id="id297"/> tools are tailored to mesh well with specific development environments. Developers have the leeway to fine-tune them, allowing the tool to understand a project’s internal libraries, APIs, best practices, and architectural blueprints. This ensures that the suggestions thrown your way not only are technically solid but also dovetail with your project’s unique needs.</p>&#13;
&#13;
<p>This customization helps to align the generated code suggestions with your organization’s established coding standards, quality markers, and security protocols. The focus on fostering high-quality code means that teams can avoid stumbling into deprecated or undesirable code snippets.</p>&#13;
&#13;
<p>Moreover, this tailored approach is a big benefit for newcomers to a development team. Traditionally, getting them acclimated to a new codebase requires a hefty time investment as they may need months of exploring code, reviewing documentation, and learning the ropes of coding protocols. However, an AI-assisted programming tool can significantly shave time off this learning curve.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Code Integrity" data-type="sect2"><div class="sect2" id="code_integrity">&#13;
<h2>Code Integrity</h2>&#13;
&#13;
<p><em>Code integrity</em> is a hallmark of sound software development<a contenteditable="false" data-primary="code integrity" data-type="indexterm" id="id298"/>. It highlights the sturdiness and trustworthiness of the source code in executing its intended function. Think of it as a lens through which the completeness, accuracy, consistency, and fortification of the code are examined. A hiccup in code integrity lays out a welcome mat for bugs and potential security blind spots, which, in turn, could usher in system crashes and data breaches.</p>&#13;
&#13;
<p>The various factors that engender code integrity include its precision, thoroughness, uniformity, and security provisions as well as the ease with which it can be maintained. Developers can ramp up code integrity through a medley of approaches like unit and integration testing, peer code reviews, static code analysis, and stringent security assessments.</p>&#13;
&#13;
<p>It’s worth noting that a growing roster of AI-assisted programming tools are rolling out features aimed at bolstering code integrity. They delve into the finer points of the code, paving the way for the generation of pertinent and sharp unit tests and edge cases.</p>&#13;
&#13;
<p>Some of these tools come with “fix-it” recommendation features. These are vetted in advance to ensure they don’t lead to new problems before they land in front of developers. Then developers can review and assimilate these suggestions right within their IDE.</p>&#13;
&#13;
<p>An added perk of these tools is their ability to swiftly analyze pull requests and spin up succinct summaries of code alterations. They also have a knack for automating the chore of generating release notes, which comes in handy for documenting the evolution in software versions.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="AI-Powered Documentation Generator" data-type="sect2"><div class="sect2" id="aihyphenpowered_documentation_generator">&#13;
<h2>AI-Powered Documentation Generator</h2>&#13;
&#13;
<p>Documentation<a contenteditable="false" data-primary="documentation" data-type="indexterm" id="id299"/> is the unsung hero in the software development process. It helps to ensure that the codebase remains legible, maintainable, and scalable, especially as teams morph and projects bloat in complexity. But let’s face it, creating and refreshing this documentation often feels like a trek through a bureaucratic bog—it can be a time-guzzler and, occasionally, gets shoved to the backburner.</p>&#13;
&#13;
<p>Now, cue the entrance of AI-assisted programming tools. These digital scribes can whip up extensive documentation in a fraction of the time—and with a hefty dose of quality and clarity to boot. This is done by leveraging the power of LLMs, which are particularly strong at dealing with language.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Modernization" data-type="sect2"><div class="sect2" id="modernization">&#13;
<h2>Modernization</h2>&#13;
&#13;
<p>Marc Andreessen’s<a contenteditable="false" data-primary="Andreessen, Marc" data-type="indexterm" id="id300"/> 2011 bold statement in the <em>Wall Street Journal</em>, <a href="https://oreil.ly/RW8e8">“Software Is Eating the World”</a>, has aged like a fine wine. Andreessen, known for his knack for spotting tech trends from miles away and his stellar track record as a successful entrepreneur and venture capitalist, pointed out a ripe moment in tech <span class="keep-together">history</span>.</p>&#13;
&#13;
<p>He underlined how the infrastructure had come of age and primed global industries for a metamorphosis. The rise of cloud platforms like Amazon Web Services and the widespread growth of broadband internet were game changers. They had knocked down the traditional hurdles of server costs and network know-how. This had cleared the stage for disruptors like Uber, Netflix, and a slew of social media platforms to rewrite the rulebook of their respective industries.</p>&#13;
&#13;
<p>When we fast forward from Andreessen’s insightful piece, we see that the innovation express has only picked up steam. However, it has also brought along a threat of disruption, especially for large corporations. Many of these behemoths are anchored to legacy systems that are not only pricey but also a gamble to modernize. Their hierarchical setup can interpose speed bumps in decision making, and their expansive scale adds layers of complexity to embracing change. Plus, their workforce might not always be on the same page with the latest tech innovations.</p>&#13;
&#13;
<p>Enter IBM, eyeing this scenario as a goldmine of opportunity and channeling its hefty resources to craft AI-assisted programming tools for its customers. In October 2023, it unveiled the watsonx Code Assistant for Z. This system can translate COBOL to Java on mainframe systems, with the code output elegantly object oriented.</p>&#13;
&#13;
<p>IBM’s <a contenteditable="false" data-primary="Watsonx.ai model" data-type="indexterm" id="id301"/><a contenteditable="false" data-primary="IBM’s Watsonx.ai model" data-type="indexterm" id="id302"/><a contenteditable="false" data-primary="generative AI" data-secondary="IBM’s Watsonx.ai model to update code" data-type="indexterm" id="id303"/>Watsonx.ai model <a href="https://oreil.ly/cfJMO">understands 115 coding languages based on 1.5 trillion tokens</a>. The model has about 20 billion parameters. This is one of the largest AI systems for code development.</p>&#13;
&#13;
<p>The fact is that there are hundreds of billions of lines of COBOL<a contenteditable="false" data-primary="COBOL, using AI to modernize languages" data-type="indexterm" id="id304"/>. But migrating this language to modern ones is no easy feat. It’s common for the COBOL to be decades old and have little or no documentation. If the conversion is not handled properly, the consequences could be severe. Keep in mind that much of the world’s credit card processing is handled with mainframes. The same goes for Uncle Sam’s system for handling school loans.</p>&#13;
&#13;
<p>Unfortunately, there are many examples of failed migration projects. Consider the California Department of Motor Vehicles, which, despite pouring $208 million into the effort, had <a href="https://oreil.ly/_U1zG">to pull the plug</a> within a few years. Ouch.</p>&#13;
&#13;
<p>Given the high stakes, mainframe developers generally earn higher salaries. But companies still are challenged in recruiting talent. Younger developers are trained on modern languages and perceive mainframe development as a dead end. In the meantime, a growing number of seasoned mainframe developers are retiring.</p>&#13;
&#13;
<p>IBM realized that AI is essential to solve this massive problem. It’s true that code <span class="keep-together">transpilers</span> or translators<a contenteditable="false" data-primary="translation" data-secondary="programming language" data-type="indexterm" id="id305"/> have been around for decades. In fact, they have often been used for mainframe projects. However, what they have mostly been doing is taking COBOL’s spaghetti code, giving it a quick translation, and, well, you have Java spaghetti code. It’s a modest facelift with barely a hint of improvement or innovation. The Java code still needs a good amount of elbow grease, explaining why many projects stumbled or flat-out face-planted.</p>&#13;
&#13;
<p>But by using generative AI, IBM says that it has been able to improve the results of a project by as much as tenfold.</p>&#13;
&#13;
<p>Other companies are exploring this modernization opportunity. Thomas Dohmke, who is the CEO of GitHub, <a href="https://oreil.ly/a21Lt">posted</a>: “COBOL still running on main frames is a much bigger societal problem than we think.” In an <a href="https://oreil.ly/sqsti/">interview with <em>Fortune</em></a>, he noted that he had heard more about COBOL in 2023 than during the past three decades. He also said that companies have been asking how to use GitHub Copilot for their migration projects.</p>&#13;
&#13;
<p>Keep in mind that ChatGPT<a contenteditable="false" data-primary="ChatGPT" data-secondary="updating legacy programs" data-type="indexterm" id="xi_ChatGPTupdatinglegacyprograms.01.178.29"/> is also proficient with legacy programming languages. <a data-type="xref" href="#common_legacy_programming_languages">Table 1-2</a> shows which languages it supports.</p>&#13;
&#13;
<table class="border" id="common_legacy_programming_languages">&#13;
	<caption><span class="label">Table 1-2. </span>Common legacy programming languages</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th>Language</th>&#13;
			<th>Description</th>&#13;
			<th>Development era</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>COBOL</td>&#13;
			<td>Developed for business data processing</td>&#13;
			<td>Late 1950s to early 1960s</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Fortran</td>&#13;
			<td>Designed for scientific and engineering calculations</td>&#13;
			<td>1950s</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Pascal</td>&#13;
			<td>Developed to encourage good software engineering practices</td>&#13;
			<td>Late 1960s to early 1970s</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>BASIC</td>&#13;
			<td>Created as an easy-to-learn language for students and beginners</td>&#13;
			<td>Mid-1960s</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>ALGOL</td>&#13;
			<td>Influenced subsequent languages like Pascal, C, and Java</td>&#13;
			<td>Late 1950s to early 1960s</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Assembly language</td>&#13;
			<td>Corresponds to the architecture of the CPU it’s designed for, dating back to early programmable computers</td>&#13;
			<td>Early computing era</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>PL/I</td>&#13;
			<td>Used for scientific, engineering, business, and system programming</td>&#13;
			<td>Early 1960s</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>To see how AI-assisted programming can help with legacy languages, let’s suppose you need to work on the following code snippet:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
MODULE ComplexModule&#13;
  IMPLICIT NONE&#13;
  TYPE :: ComplexType&#13;
     REAL :: real, imag&#13;
  CONTAINS&#13;
     OPERATOR(+) (a, b) RESULT(c)&#13;
       TYPE(ComplexType), INTENT(IN) :: a, b&#13;
       TYPE(ComplexType) :: c&#13;
       c%real = a%real + b%real&#13;
       c%imag = a%imag + b%imag&#13;
     END OPERATOR&#13;
  END TYPE ComplexType&#13;
END MODULE ComplexModule</pre>&#13;
&#13;
<p>You do not know what language it is or how it works. The syntax does not lend itself to an intuitive understanding of the workflow.</p>&#13;
&#13;
<p>Now let’s say you go to ChatGPT and enter the following:</p>&#13;
&#13;
<blockquote>&#13;
<p><em>Prompt:</em> What language is this written in? What does this code snippet do? Also, explain how it works.</p>&#13;
</blockquote>&#13;
&#13;
<p><a data-type="xref" href="#chatgpt_responds_to_a_request_to_interpr">Figure 1-5</a> shows part of the response.</p>&#13;
&#13;
<figure><div class="figure" id="chatgpt_responds_to_a_request_to_interpr"><img alt="" src="assets/aiap_0105.png"/>&#13;
<h6><span class="label">Figure 1-5. </span>ChatGPT responds to a request to interpret legacy code</h6>&#13;
</div></figure>&#13;
&#13;
<p>ChatGPT accurately identifies this as Fortran code. It also explains that the code defines a module named <code>ComplexModule</code>, which contains a derived type <code>ComplexType</code> for representing complex numbers, along with an overloaded addition operator + for adding two complex numbers together. Then there is a step-by-step explanation of the code<a contenteditable="false" data-primary="" data-startref="xi_AIassistedprogrammingbenefits.01.69.27" data-type="indexterm" id="id306"/><a contenteditable="false" data-primary="" data-startref="xi_ChatGPTupdatinglegacyprograms.01.178.29" data-type="indexterm" id="id307"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Drawbacks" data-type="sect1"><div class="sect1" id="drawbacks">&#13;
<h1>Drawbacks</h1>&#13;
&#13;
<p>Now let’s take a look at the not-so-rosy aspects<a contenteditable="false" data-primary="AI-assisted programming" data-secondary="drawbacks" data-type="indexterm" id="xi_AIassistedprogrammingdrawbacks.01.255.52"/> of AI-assisted programming tools. Like any fledgling technology—hey, even the first iPhone was a bit clunky—AI comes with its share of hiccups, issues, and hurdles. The path of innovation is littered with room for polish and fine-tuning.</p>&#13;
&#13;
<p>Let’s take a look at some of the drawbacks.</p>&#13;
&#13;
<section data-pdf-bookmark="Hallucinations" data-type="sect2"><div class="sect2" id="hallucinations">&#13;
<h2>Hallucinations</h2>&#13;
&#13;
<p>For LLMs<a contenteditable="false" data-primary="hallucinations" data-type="indexterm" id="id308"/>, <em>hallucinations</em> are instances in which the model outputs data that appears accurate but is factually incorrect or not grounded in the input data on which the model was trained. This can pose a significant challenge for software development. Hallucinations can lead to inaccurate code suggestions, generate misleading documentation, and create erroneous testing scenarios. Additionally, they can render debugging inefficient, mislead beginners, and potentially erode trust in AI tools.</p>&#13;
&#13;
<p>On a positive note, there has been notable progress in reducing the occurrence of hallucinations. A substantial amount of academic research has been dedicated to this issue, and AI companies have been employing effective strategies like reinforcement learning from human feedback (RLHF)<a contenteditable="false" data-primary="reinforcement learning from human feedback (RLHF)" data-type="indexterm" id="id309"/><a contenteditable="false" data-primary="RLHF (reinforcement learning from human feedback)" data-type="indexterm" id="id310"/> to mitigate this problem.</p>&#13;
&#13;
<p>However, given the intrinsic complexity of LLMs and the enormous amount of data they are based on, completely eradicating hallucinations appears to be a tall order—if not impossible.</p>&#13;
&#13;
<p>Another aspect to consider is that certain programming languages exhibit higher accuracy rates when AI-assisted tools are used. Languages such as Python, JavaScript, TypeScript, and Go tend to have better performance in this regard. This is attributed to these languages being well represented in public repositories and thus providing a richer dataset for the AI to learn from. The better trained AI, in turn, offers more accurate and robust suggestions.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Intellectual Property" data-type="sect2"><div class="sect2" id="intellectual_property">&#13;
<h2>Intellectual Property</h2>&#13;
&#13;
<p>Matthew Butterick<a contenteditable="false" data-primary="Butterick, Matthew" data-type="indexterm" id="id311"/><a contenteditable="false" data-primary="intellectual property (IP) rights" data-type="indexterm" id="id312"/> boasts a diverse background, embodying roles as a programmer, designer, and lawyer, with a particular penchant for typography. His journey has seen him authoring books on typography, designing fonts, and crafting programs aimed at document editing and layout. However, his encounter with GitHub Copilot in June 2022 didn’t spark joy. Rather, it spurred him to pen a blog post titled <a href="https://oreil.ly/qjHL6">“This Copilot Is Stupid and Wants to Kill Me”</a>.</p>&#13;
&#13;
<p>His discontent didn’t end with blogging. It quickly escalated to launching a <a href="https://oreil.ly/MOqYc">class action lawsuit</a> against Microsoft, GitHub, and OpenAI. The bone of contention was an alleged breach of GitHub’s terms of service and privacy policies, with a potential extension to copyright infringement charges.</p>&#13;
&#13;
<p>This legal tangle underscores a broader gray area concerning intellectual property rights with respect to code engineered from AI-assisted programming tools. Given that the output is a cocktail of countless lines of preexisting code, the question of ownership is a big question mark.</p>&#13;
&#13;
<p>One argument is based on the idea of “fair use.” However, this legal doctrine is murky and does not extend a clear pathway for AI-generated content. To resolve this matter, there will likely need to be federal legislation or a Supreme Court ruling.</p>&#13;
&#13;
<p>In the meantime, Microsoft has maneuvered to build a <a href="https://oreil.ly/x_Ml4">legal firewall</a> for GitHub Copilot<a contenteditable="false" data-primary="GitHub Copilot" data-secondary="and intellectual property issue" data-secondary-sortas="intellectual property issue" data-type="indexterm" id="id313"/> customers. It has pledged to defend users against legal claims, granted certain prerequisites are satisfied.</p>&#13;
&#13;
<p>Adding another layer of the legal quagmire is the intersection of AI-assisted programming and open source software<a contenteditable="false" data-primary="open source AI software" data-type="indexterm" id="id314"/> methods. Copyleft licenses, like the General Public License (GPL) versions 2 and 3, require that any derivative work use the original code’s license terms. This helps to promote a stream of innovation. Yet, it could spell trouble for developers, because it could potentially strip them of the rights to shield their application’s intellectual property—or even require that they make their entire codebase open source.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Privacy" data-type="sect2"><div class="sect2" id="privacy">&#13;
<h2>Privacy</h2>&#13;
&#13;
<p>The use of AI-assisted programming tools<a contenteditable="false" data-primary="privacy" data-type="indexterm" id="id315"/>, often housed in the cloud, begs many data privacy and confidentiality questions. How is the data safeguarded within the company? Is there a chance it might be used as training data?</p>&#13;
&#13;
<p>The clarity of the answers might vary from one vendor to another. Thus, some developers may opt to steer clear of AI-assisted programming tools altogether.</p>&#13;
&#13;
<p>This has been the approach of Anthony Scodary<a contenteditable="false" data-primary="Scodary, Anthony" data-type="indexterm" id="id316"/>, the cofounder and cohead of engineering at Gridspace<a contenteditable="false" data-primary="Gridspace" data-type="indexterm" id="id317"/>. This enterprise, with roots tracing back to Stanford University, develops voice bots adept at navigating complex phone conversations. Their technological foundation rests on speech recognition, speech synthesis, LLMs, and dialog systems.</p>&#13;
&#13;
<p>Rather than hitching a ride on existing AI-assisted programming platforms, Gridspace chose the road less traveled. It engineered its own AI-assisted programming platform, which is based on Docker services within a Kubernetes cluster. Deployed as an IDE plugin, this bespoke system is fine-tuned for its own codebase. “This has allowed us to avoid sending our IP and data to other companies,” he said. “It has also meant that we have a model that is smaller, more efficient, and specialized to our style.”</p>&#13;
&#13;
<p>This is not to imply that this is the best approach. Each organization has its own views and preferred methods. But when it comes to evaluating AI-assisted programming, it’s important to understand the privacy implications.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Security" data-type="sect2"><div class="sect2" id="security">&#13;
<h2>Security</h2>&#13;
&#13;
<p>In a research paper entitled <a href="https://oreil.ly/ibD3D">“Security Weaknesses of Copilot Generated Code in GitHub”</a>, authors Yujia Fu et al. highlighted the security<a contenteditable="false" data-primary="security" data-type="indexterm" id="id318"/> issues with GitHub Copilot<a contenteditable="false" data-primary="GitHub Copilot" data-secondary="security" data-type="indexterm" id="id319"/>. They scrutinized 435 AI-generated code snippets from projects on GitHub, and 35.8% had Common Weakness Enumeration (CWE)<a contenteditable="false" data-primary="Common Weakness Enumeration (CWE)" data-type="indexterm" id="id320"/><a contenteditable="false" data-primary="CWE (Common Weakness Enumeration)" data-type="indexterm" id="id321"/> instances.</p>&#13;
&#13;
<p>These weren’t limited to just one programming language. They were multilingual missteps spanning 42 different CWE categories. Three of these categories were the usual suspects—OS Command Injection, Use of Insufficiently Random Values, and Improper Check or Handling of Exceptional Conditions. But here’s the kicker: 11 of these CWEs had the dubious honor of making it to the 2022 CWE Top 25 list.</p>&#13;
&#13;
<p>This is not to imply that AI-assisted programming tools are a huge security risk. Far from it. The fact is that vendors are continuing to work on ways to improve the guardrails. However, as with any code, a solid dose of security mindfulness is the name of the game.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Training Data" data-type="sect2"><div class="sect2" id="training_data">&#13;
<h2>Training Data</h2>&#13;
&#13;
<p>The training data for LLMs<a contenteditable="false" data-primary="training data gaps and quality issues" data-type="indexterm" id="id322"/><a contenteditable="false" data-primary="large language models (LLMs)" data-secondary="training data deficiencies" data-type="indexterm" id="id323"/> of AI-assisted programming tools may have notable gaps, which can affect the performance and usefulness of these tools in real-world scenarios. Let’s break down some of these:</p>&#13;
&#13;
<dl>&#13;
	<dt>Representation gaps<a contenteditable="false" data-primary="representation gaps, training data" data-type="indexterm" id="id324"/></dt>&#13;
	<dd>&#13;
	<p>If certain areas of a programming language or library are not well represented—or are nowhere to be seen—in open source projects, the AI may lack enough knowledge about them, leading to less accurate suggestions. The quality of the AI’s output depends heavily on the quality and scope of the training data.</p>&#13;
	</dd>&#13;
	<dt>Quality inconsistency<a contenteditable="false" data-primary="quality inconsistency, training data" data-type="indexterm" id="id325"/></dt>&#13;
	<dd>&#13;
	<p>To borrow a movie analogy, the open source code in an LLM is a bit like a box of chocolates—you never know what you’re gonna get. Some projects are the crème de la crème, while others are...let’s say, the burnt toast of the code world. This mishmash can lead to our AI-assisted programming being inconsistent in the quality of suggestions it throws your way.</p>&#13;
	</dd>&#13;
	<dt>Knowledge cutoff date<a contenteditable="false" data-primary="cutoff date, training data" data-type="indexterm" id="id326"/></dt>&#13;
	<dd>&#13;
	<p>LLMs have a cutoff date on their training, so in a way they are like a snapshot in time. This poses challenges when there are new releases, updates, or deprecations in programming languages or libraries.</p>&#13;
	</dd>&#13;
	<dt>Generalization gap<a contenteditable="false" data-primary="generalization gap, training data" data-type="indexterm" id="id327"/></dt>&#13;
	<dd>&#13;
	<p>The generalization gap, the difference between the AI’s performance on the training data and unseen data, can also pose challenges. Of course, the closer the performance of the two, the better. This is the conclusion of a research paper by Rie Johnson and Tong Zhang entitled <a href="https://oreil.ly/bdS-T">“Inconsistency, Instability, and Generalization Gap of Deep Neural Network Training”</a>.</p>&#13;
	</dd>&#13;
	<dt>Contextual understanding<a contenteditable="false" data-primary="context, prompt" data-type="indexterm" id="id328"/><a contenteditable="false" data-primary="context window" data-type="indexterm" id="id329"/></dt>&#13;
	<dd>&#13;
	<p>AI can give you suggestions based on what it has seen before. But if it hasn’t seen a scenario quite like yours, it might miss the mark. This is why it’s important not to make assumptions when creating prompts.</p>&#13;
	</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Bias" data-type="sect2"><div class="sect2" id="bias">&#13;
<h2>Bias</h2>&#13;
&#13;
<p>Developers often don’t have a solid grasp of AI ethics<a contenteditable="false" data-primary="ethics, AI" data-type="indexterm" id="id330"/><a contenteditable="false" data-primary="bias, training data" data-type="indexterm" id="id331"/>, likely because this topic isn’t usually part of computer science courses or intensive bootcamp programs. This gap in understanding can lead to algorithms unintentionally applying biases and the potential misuse of data.</p>&#13;
&#13;
<p>This issue carries over to AI-assisted programming tools as well. They can unintentionally perpetuate the biases present in the data they were trained on. For example, if asked to create a list of names, they might mainly suggest English names due to the heavy presence of English-centric datasets in their training datasets. This bias can sometimes lead to harmful or inappropriate outputs. There was an <a href="https://oreil.ly/p5w5o"><em>instance</em></a> where, when given the prompt “def race(x):”, the AI filled in a limited and fixed set of race categories. In another troubling case, when tasked with writing code comments for the prompt “Islam,” the AI was found to access words like <em>terrorist</em> and <em>violent</em> more frequently than when other religious groups were mentioned<a contenteditable="false" data-primary="" data-startref="xi_AIassistedprogrammingdrawbacks.01.255.52" data-type="indexterm" id="id332"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="A New Way for Developers" data-type="sect1"><div class="sect1" id="a_new_way_for_developers">&#13;
<h1>A New Way for Developers</h1>&#13;
&#13;
<p>The McKinsey<a contenteditable="false" data-primary="AI-assisted programming" data-secondary="software development impact" data-type="indexterm" id="xi_AIassistedprogrammingsoftwaredevelopmentimpact.01.306.16"/><a contenteditable="false" data-primary="software developers, AI impact on" data-type="indexterm" id="xi_softwaredevelopersAIimpacton.01.306.16"/> study suggests that the dawn of AI-assisted programming tools is likely to change how we approach software development<a contenteditable="false" data-primary="developers, AI impact on" data-type="indexterm" id="xi_developersAIimpacton.01.306.135"/>. According to the authors, success might hinge on good training, emphasizing best practices and diving into hands-on exercises on things like prompt engineering, coding standards, and quality. It’s also smart to shine a light on the risks associated with generative AI.</p>&#13;
&#13;
<p>For newbie developers, especially those with less than a year of experience under their belts, it’s a good idea to dive into extra coursework that covers the basic principles of programming to ramp up productivity.</p>&#13;
&#13;
<p>As developers fold these tools into their daily routine, it’s vital to keep the skill-building momentum going with some guidance from the seasoned pros on the team and engagement in community activities. This could mean hanging out in dedicated online forums or having regular team huddles to share practical examples. Such actions can foster a culture of continuous learning, spread the word on best practices across the board, and help spot issues early on.</p>&#13;
&#13;
<p>With the uptick in developer productivity, managers might want to stir the pot a bit when it comes to roles, zeroing in on tasks that pack more value. Upskilling will be on the menu, too, to fill in any existing gaps.</p>&#13;
&#13;
<p>Sure, these pointers aren’t gospel. The realm of AI-assisted programming is still pretty fresh and is changing at a brisk pace. Above all, being ready to roll with the punches is key.</p>&#13;
&#13;
<section data-pdf-bookmark="Career" data-type="sect2"><div class="sect2" id="career">&#13;
<h2>Career</h2>&#13;
&#13;
<p>While there’s no hard proof that using AI-assisted programming will boost your career outlook, a handful of signs suggest that this expertise might become a hot ticket in the job market:</p>&#13;
&#13;
<dl>&#13;
	<dt>Job listings</dt>&#13;
	<dd>&#13;
	<p>The job boards on sites like Indeed are starting to buzz with more listings seeking candidates with experience in AI-assisted programming tools. The call is out for all ranks, from junior developers to the senior hotshots.</p>&#13;
	</dd>&#13;
	<dt>Productivity boosts</dt>&#13;
	<dd>&#13;
	<p>AI-assisted programming tools are turning heads because they’re improving productivity without sacrificing quality. For a developer, this could be a way to move up the ranks in an organization.</p>&#13;
	</dd>&#13;
	<dt>Thumbs-ups from developers</dt>&#13;
	<dd>&#13;
	<p>The chatter among developers is that AI-assisted programming tools are catching on. For example, GitHub Copilot is boasting a strong rating of <a href="https://oreil.ly/khAln">4.5 out of 5 stars on G2.com</a>, an independent software review site.</p>&#13;
	</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="10x Developer?" data-type="sect2"><div class="sect2" id="tenx_developerquestion_mark">&#13;
<h2>10x Developer?</h2>&#13;
&#13;
<p>The <em>10x developer</em> has the power of 10 programmers<a contenteditable="false" data-primary="10x developer" data-primary-sortas="ten" data-type="indexterm" id="id333"/>. They’re the Usain Bolt of coding, zipping through problems and churning out solutions before you can say “bug fix.”</p>&#13;
&#13;
<p>So you might be thinking: Could I become a 10x developer with the help of AI-assisted programming tools? Well, sorry to say, but probably not. While these technologies can make a significant difference, improvements are usually not in orders of magnitude.</p>&#13;
&#13;
<p>Besides, the concept of a 10x developer can stir up stereotypes and biases, making the tech scene feel like an exclusive club. Not to mention, the pressure to be this super coder could lead you straight into the arms of burnout. So while being a 10x developer might sound great, remember it’s probably closer to a fantasy.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Skills of the Developer" data-type="sect2"><div class="sect2" id="skills_of_the_developer">&#13;
<h2>Skills of the Developer</h2>&#13;
&#13;
<p>According to the McKinsey study, the effectiveness of AI-assisted development tools often depends on the expertise of the developer. Here are some of the considerations:</p>&#13;
&#13;
<dl>&#13;
	<dt>Fixing errors</dt>&#13;
	<dd>&#13;
	<p>Even though generative AI can be your trusty sidekick, it can goof up too. It falls upon the developer’s shoulders to spot and fix these blunders. Some developers have found themselves playing a loop of corrections with the AI to get to a sweet spot of accuracy, while others have had to spoon-feed the tool to get it to debug<a contenteditable="false" data-primary="debugging" data-secondary="challenges of AI assistance with" data-type="indexterm" id="id334"/> accurately. This can certainly be time-consuming. But a veteran developer will know how to avoid going down the rabbit holes.</p>&#13;
	</dd>&#13;
	<dt>Getting the office vibes</dt>&#13;
	<dd>&#13;
	<p>AI-assisted programming tools are fairly solid when it comes to coding but might miss the beat when dealing with the unique flavor of individual projects or company quirks. Again, this is where veteran developers are key. They’ll know how to guide these tools to get the results that best align with organizational goals, performance targets, and security.</p>&#13;
	</dd>&#13;
	<dt>Tackling the tough stuff</dt>&#13;
	<dd>&#13;
	<p>Assisted AI-programming tools are great with tasks like polishing code, but toss in some complex challenges like blending different coding frameworks, and the AI might just trip over itself. In these moments, it’s the experienced developers who have to roll up their sleeves<a contenteditable="false" data-primary="" data-startref="xi_AIassistedprogrammingsoftwaredevelopmentimpact.01.306.16" data-type="indexterm" id="id335"/><a contenteditable="false" data-primary="" data-startref="xi_developersAIimpacton.01.306.135" data-type="indexterm" id="id336"/><a contenteditable="false" data-primary="" data-startref="xi_softwaredevelopersAIimpacton.01.306.16" data-type="indexterm" id="id337"/>.</p>&#13;
	</dd>&#13;
</dl>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="conclusion">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>AI-assisted programming tools are certainly the shiny toys in the software creation sandbox. As this technology keeps marching forward, these systems will crank up efficiency, handle boring tasks, and let developers dive into the areas that are most important, like high-level problem solving.</p>&#13;
&#13;
<p>But there are downsides—tangled intellectual property issues, maze of open source software licensing, potential for bias, and security risks to name a few<a contenteditable="false" data-primary="" data-startref="xi_AIassistedprogramming.01.3.39" data-type="indexterm" id="id338"/>.</p>&#13;
&#13;
<p>For the most part, these tools are your virtual assistants, not a replacement for your knowledge, skill, and experience. At the same time, while they might not be superheroes, they’re shaping up to be powerful additions to the developer’s toolkit.</p>&#13;
</div></section>&#13;
</div></section></body></html>