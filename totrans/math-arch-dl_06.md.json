["```py\ndef fully_connected_layer(X, w,  b):                         ①\n\n    X = torch.cat((X, torch.ones(\n             [X.shape[0], 1], dtype=torch.float32)), dim=1)  ②\n\n    W = torch.cat((W, b.unsqueeze(dim=1)), dim=1)            ③\n\n    y = torch.matmul(W, X.transpose(0, 1))                   ④\n\n    y = torch.heaviside(y, torch.tensor(1.0))                ⑤\n\n    return y.transpose(0, 1)\n\ndef Perceptron(X, W, b):                                     ⑥\n    return fully_connected_layer(X, W, b)\n```", "```py\n# Logical AND\nX = torch.tensor([[0., 0.],                               ①\n                 [0., 1.],\n                 [1., 0.],\n                 [1., 1.]], dtype=torch.float32) \nW = torch.tensor([[1.0, 1.0]], dtype=torch.float32)       ②\nb = torch.tensor([-1.5])                                  ③\nY = Perceptron(X=X, W=W, b=b, activation=torch.heaviside) ④\n\n# Logical OR\nX = torch.tensor([[0., 0.],\n                 [0., 1.],\n                 [1., 0.],\n                 [1., 1.]], dtype=torch.float32)\nW = torch.tensor([[1.0, 1.0]], dtype=torch.float32)\nb = torch.tensor([-1.5])\nY = Perceptron(X=X, W=W, b=b, activation=torch.heaviside)\n\n# Logical NOT\nX = torch.tensor([[0],\n                 [1.]\n                 ], dtype=torch.float32)\nW = torch.tensor([[-1.0]], dtype=torch.float32)\nb = torch.tensor([0.5])\nY = Perceptron(X=X, W=W, b=b, activation=torch.heaviside)\n```", "```py\ndef MLP(X, W0, W1, b0, b1): ①\n    y0 = fully_connected_layer(X=X, W=W0, b=b0)\n    return fully_connected_layer(X=y0, W=W1, b=b1)\n```", "```py\nx = torch.linspace(start=-10, end=10, steps=100) ①\n\n# 1D S curves - positive weight                  ②\nw = torch.tensor([1.0], dtype=torch.float32)\nb = torch.tensor([0.0])\ny = Perceptron(X=x.unsqueeze(dim=1), W=w.unsqueeze(dim=1), b=b) \n\n# 1D S curves - negative weight + shift\\quad     ③\nw = torch.tensor([-1.0], dtype=torch.float32)\nb = torch.tensor([5.0])\ny = Perceptron(X=x.unsqueeze(dim=1), W=w.unsqueeze(dim=1), b=b) \n\n# 1D towers (Cybenko) - various W0\\quad          ④\nW0 = torch.tensor([[1.0], [-1.0]], dtype=torch.float32)\nb0 = torch.tensor([5.0, 5.0])\nW1 = torch.tensor([[1.0, 1.0]], dtype=torch.float32)\nb1 = torch.tensor([0.0])\ny = MLP(X=x.unsqueeze(dim=1), W0=W0, W1=W1, b0=b0, b1=b1)\n```", "```py\nX = torch.linspace(start=-1, end=1, steps=100)      ①\nY = torch.linspace(start=-1, end=1, steps=100)      ①\n\ngridX, gridY = torch.meshgrid(X, Y)                 ②\nX = torch.tensor([(y, x) for y, x in\n         zip(gridY.reshape(-1), gridX.reshape(-1))) ③\n\n# 2D Step function in X-direction                   ④\nW = torch.tensor([[1.0, 0.0]], dtype=torch.float32)\nb = torch.tensor([0.0], dtype=torch.float32)\nZ = Perceptron(X=X, W=W, b=b)\n\n# 2D Flipped Step function along X-direction        ⑤\nW = torch.tensor([[-1.0, 0.0]], dtype=torch.float32)\nb = torch.tensor([0.0], dtype=torch.float32)\nZ = Perceptron(X=X, W=W, b=b)\n\n# 2D wave along X-direction                         ⑥\nW0 = torch.tensor([[1.0, 0.0],\n                   [-1.0, 0.0]], dtype=torch.float32)\nb0 = torch.tensor([0.5, 0.5], dtype=torch.float32)\nW1 = torch.tensor([[1.0, 1.0]], dtype=torch.float32)\nb1 = torch.tensor([-1.0])\nZ = MLP(X=X, W0=W0, W1=W1, b0=b0, b1=b1) \n\n# 2D wave along Y-direction                          ⑦\nW0 = torch.tensor([[0.0, 1.0],\n                   [0.0, -1.0]], dtype=torch.float32)\nb0 = torch.tensor([0.5, 0.5], dtype=torch.float32)\nW1 = torch.tensor([[1.0, 1.0]], dtype=torch.float32)\nb1 = torch.tensor([-1.0])\nZ = MLP(X=X, W0=W0, W1=W1, b0=b0, b1=b1)\n\n# 2D Tower                                           ⑧\nW0 = torch.tensor([[1.0, 0.0],\n                   [-1.0, 0.0],\n                   [0.0, 1.0],\n                   [0.0, -1.0]], dtype=torch.float32)\nb0 = torch.tensor([0.5, 0.5, 0.5, 0.5], dtype=torch.float32)\nW1 = torch.tensor([[1.0, 1.0, 1.0, 1.0]], dtype=torch.float32)\nb1 = torch.tensor([-3.5])\nZ = MLP(X=X, W0=W0, W1=W1, b0=b0, b1=b1)\n```"]