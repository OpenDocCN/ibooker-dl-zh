- en: 7 Genetic algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 遗传算法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing population-based optimization algorithms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍基于种群的优化算法
- en: Understanding evolutionary computation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解进化计算
- en: Understanding the different components of genetic algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解遗传算法的不同组成部分
- en: Implementing genetic algorithms in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中实现遗传算法
- en: Suppose you’re on a treasure-hunting mission and you don’t want the risk of
    searching alone and returning empty-handed. You might decide to collaborate with
    a group of friends and share information. This approach follows a population-based
    search strategy, where multiple agents are involved in the search process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在进行一次寻宝任务，你不想独自搜索并空手而归。你可能会决定与一群朋友合作并共享信息。这种方法遵循基于种群的搜索策略，其中多个代理参与搜索过程。
- en: During this collaborative effort, you may notice that some hunters perform better
    than others. In this case, you may choose to retain only the best-performing hunters
    and replace the less competent ones with new recruits. This process resembles
    the workings of evolutionary algorithms such as genetic algorithms, where the
    fittest individuals survive and pass on their traits to the next generation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次协作过程中，你可能会注意到一些猎人表现优于其他人。在这种情况下，你可能会选择只保留表现最好的猎人，并用新招募的成员替换表现不佳的猎人。这个过程类似于遗传算法等进化算法的工作原理，其中最适应的个体生存下来并将它们的特征传递给下一代。
- en: In this chapter, the binary-coded genetic algorithm is presented and discussed
    as an evolutionary computing algorithm. We’ll look at different elements of this
    algorithm and at the implementation details. Other variants of genetic algorithms,
    such as the gray-coded genetic algorithm, real-valued genetic algorithm, and permutation-based
    genetic algorithm will be discussed in the next chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍并讨论二进制编码的遗传算法作为一种进化计算算法。我们将探讨该算法的不同元素及其实现细节。下一章将讨论遗传算法的其他变体，如灰度编码遗传算法、实值遗传算法和基于排列的遗传算法。
- en: 7.1 Population-based metaheuristic algorithms
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 基于种群的元启发式算法
- en: Population-based metaheuristic algorithms (P-metaheuristics), such as genetic
    algorithms, particle swarm optimization, and ant colony optimization, utilize
    multiple agents to search for an optimal or near-optimal global solution. As these
    algorithms begin with a diverse set of initial populations, they are naturally
    more exploration-based, allowing for the possibility of finding better solutions
    that might be missed by trajectory-based (S-metaheuristic) algorithms, which are
    more exploitation-based.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基于种群的元启发式算法（P-元启发式），如遗传算法、粒子群优化和蚁群优化，利用多个代理来搜索最优或近似最优的全局解。由于这些算法从多样化的初始种群开始，它们自然更侧重于探索，从而有可能找到可能被基于轨迹（S-元启发式）算法遗漏的更好解决方案，后者更侧重于利用。
- en: 'Population-based metaheuristic algorithms can be classified into two main categories
    based on their source of inspiration: *evolutionary computation algorithms* and
    *swarm intelligence algorithms*, as shown in figure 7.1.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基于种群的元启发式算法可以根据其灵感来源分为两大类：*进化计算算法*和*群体智能算法*，如图7.1所示。
- en: '![](../Images/CH07_F01_Khamis.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F01_Khamis.png)'
- en: Figure 7.1 Metaheuristic algorithms
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 元启发式算法
- en: Evolutionary computation (EC) algorithms, as the name suggests, are inspired
    by the process of biological evolution. These algorithms use a population of potential
    solutions, which undergo genetic operations, such as mutation and crossover, to
    create new offspring that may have better fitness values. The process of selection
    determines which individuals in the population are selected to reproduce and create
    the next generation. Genetic algorithm (GA), differential evolution (DE), genetic
    programming (GP), evolutionary programming (EP), evolutionary strategies (ES),
    cultural algorithms (CA), and co-evolution (CoE) are examples of evolutionary
    computation algorithms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 进化计算（EC）算法，正如其名所示，是受生物进化过程的启发。这些算法使用一组潜在解的种群，这些种群通过遗传操作，如变异和交叉，来创造新的后代，这些后代可能具有更好的适应度值。选择过程决定了种群中哪些个体被选中进行繁殖并创造下一代。遗传算法（GA）、差分进化（DE）、遗传编程（GP）、进化编程（EP）、进化策略（ES）、文化算法（CA）和协同进化（CoE）是进化计算算法的例子。
- en: Swarm intelligence (SI) algorithms, on the other hand, are inspired by the collective
    behavior of social organisms such as ants, bees, and birds, and they’ll be discussed
    in part 4 of this book. These algorithms use a population of agents that interact
    with each other to find a solution. They use a variety of mechanisms, such as
    communication, cooperation, and self-organization, to optimize the search process.
    Examples of swarm intelligence algorithms include particle swarm optimization
    (PSO), ant colony optimization (ACO), artificial bee colony (ABC), the firefly
    algorithm (FA), the bat algorithm (BA), and the wolf search algorithm (WSA).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，群体智能（SI）算法受到蚂蚁、蜜蜂和鸟类等社会生物集体行为的启发，将在本书的第四章中讨论。这些算法使用一个相互作用的代理种群来寻找解决方案。它们使用各种机制，如通信、合作和自组织，来优化搜索过程。群体智能算法的例子包括粒子群优化（PSO）、蚁群优化（ACO）、人工蜂群（ABC）、萤火虫算法（FA）、蝙蝠算法（BA）和狼搜索算法（WSA）。
- en: Both evolutionary computation and swarm intelligence algorithms are population-based
    algorithms that begin their search for the optimal or near-optimal solution from
    an initial population of candidate solutions. The quality and diversity of the
    initial population significantly influences the performance and efficiency of
    the algorithm. A well-constructed initial population provides a good starting
    point for the search process and can help the algorithm quickly converge toward
    a promising region of the search space. In contrast, a poorly constructed initial
    population may result in a premature convergence to a suboptimal solution, may
    get the algorithm stuck in a suboptimal region, or may take longer to converge
    toward a solution. To ensure a good balance between exploration and exploitation,
    the initial population should be diverse and cover a wide range of potential solutions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是进化计算还是群体智能算法，它们都是基于种群的算法，从候选解的初始种群开始搜索最优或近似最优解。初始种群的质量和多样性显著影响算法的性能和效率。一个构建良好的初始种群为搜索过程提供了一个良好的起点，并有助于算法快速收敛到搜索空间的希望区域。相反，一个构建不良的初始种群可能导致过早收敛到次优解，可能使算法陷入次优区域，或者可能需要更长的时间收敛到解。为了确保探索和利用之间的良好平衡，初始种群应该是多样化的，并覆盖广泛的潜在解。
- en: 'A comparison between different initialization strategies for population-based
    metaheuristics is provided in El-Ghazali Talbi’s *Metaheuristics: From Design
    to Implementation* [1], based on three key aspects: diversity, computational cost,
    and the quality of initial solutions. Initial solutions can be generated using
    a pseudo-random process or a quasi-random search. Initial solutions can also be
    generated sequentially (sequential diversification) or concurrently (parallel
    diversification) to achieve very high diversity. Heuristics involve using local
    search or greedy methods to generate initial solutions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在El-Ghazali Talbi的《元启发式算法：从设计到实现》[1]中，提供了基于种群元启发式算法的不同初始化策略的比较，基于三个关键方面：多样性、计算成本和初始解的质量。初始解可以通过伪随机过程或准随机搜索生成。初始解也可以顺序生成（顺序多样性）或并发生成（并行多样性）以实现非常高的多样性。启发式方法涉及使用局部搜索或贪婪方法来生成初始解。
- en: As shown in table 7.1, a pseudo-random strategy provides moderate diversity,
    low computational cost, and low-quality initial solutions. A quasi-random strategy
    exhibits higher diversity with comparable computational cost and low-quality initial
    solutions. Sequential diversification and parallel diversification both stand
    out with very high diversity, but the former incurs moderate computational cost,
    while the latter has low computational cost; both methods result in low-quality
    initial solutions. In contrast, the use of heuristics, such as local search or
    a greedy heuristic, yields high-quality initial solutions but with low diversity
    and high computational cost.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如表7.1所示，伪随机策略提供了适中的多样性、低计算成本和低质量的初始解。准随机策略表现出更高的多样性，具有可比的计算成本和低质量的初始解。顺序多样性和并行多样性都表现出非常高的多样性，但前者产生适中的计算成本，而后者具有低计算成本；两种方法都导致低质量的初始解。相比之下，使用诸如局部搜索或贪婪启发式等启发式方法可以产生高质量的初始解，但多样性和计算成本较低。
- en: Table 7.1 Initialization strategies for population-based metaheuristics
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 基于种群的元启发式算法的初始化策略
- en: '| Initialization strategy | Diversity | Computational cost | Quality of initial
    solution |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 初始化策略 | 多样性 | 计算成本 | 初始解的质量 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Pseudo-random | Moderate | Low | Low |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 伪随机 | 中等 | 低 | 低 |'
- en: '| Quasi-random | High | Low | Low |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 近似随机 | 高 | 低 | 低 |'
- en: '| Sequential diversification | Very high | Moderate | Low |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 顺序多样化 | 非常高 | 中等 | 低 |'
- en: '| Parallel diversification | Very high | Low | Low |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 并行多样化 | 非常高 | 低 | 低 |'
- en: '| Heuristics (e.g., local search or greedy heuristic) | Low | High | High |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 启发式（例如，局部搜索或贪婪启发式） | 低 | 高 | 高 |'
- en: It is often beneficial to use a randomized approach to generate the initial
    population, where the candidates are samples from different regions of the search
    space to maximize the chances of finding the optimal solution. The next listing
    shows how we can sample initial solutions using Python. Let’s start by generating
    200 pseudo-random numbers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机化方法生成初始种群通常是有益的，其中候选者是从搜索空间的不同区域抽取的样本，以最大化找到最优解的机会。下面的列表展示了我们如何使用Python来采样初始解。让我们首先生成200个伪随机数。
- en: Listing 7.1 Generating initial populations in Python
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 在Python中生成初始种群
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Set a seed for the random number generator.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为随机数生成器设置种子。
- en: ② Number of samples
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ② 样本数量
- en: ③ Pseudo-random sampling
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 伪随机采样
- en: Note Random numbers are inherently unpredictable, pseudo-random numbers are
    deterministic but appear random, and quasi-random numbers are deterministic with
    evenly distributed patterns.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：随机数本质上不可预测，伪随机数是确定的但看起来是随机的，而近似随机数是具有均匀分布模式的确定数。
- en: 'The generalized Halton number generator in the ghalton library can be used
    to generate quasi-random numbers. This method is based on the Halton sequence,
    which uses coprime numbers as its bases. You can use the generalized Halton number
    generator as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ghalton库中的广义Halton数生成器可以用来生成近似随机数。这种方法基于Halton序列，它使用互质数作为其基数。你可以如下使用广义Halton数生成器：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Box-Muller transform is used to generate pairs of independent, standard,
    normally distributed random numbers from pairs of uniformly distributed random
    numbers. Box-Muller is a 2D Gaussian sampling method that can be used as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Box-Muller变换用于从均匀分布的随机数对生成独立的标准正态分布随机数对。Box-Muller是一种二维高斯采样方法，可以使用如下方式：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Generate uniformly distributed values between 0 and 1.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ① 生成0到1之间的均匀分布值。
- en: ② Calculate x and y values using Box-Muller.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用Box-Muller计算x和y值。
- en: One of the drawbacks of the Box-Muller transform is its tendency to cluster
    values around the mean due to its dependency on uniform distribution. Additionally,
    calculating the square root can be costly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Box-Muller变换的一个缺点是它倾向于将值聚集在平均值周围，因为它依赖于均匀分布。此外，计算平方根可能很昂贵。
- en: 'Central limit theorem (CLT) sampling is another sampling method where the distribution
    of the sample means approximates a normal distribution as the sample size gets
    larger, regardless of the population’s distribution. The following code snippet
    shows how to implement this method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 中心极限定理（CLT）采样是另一种采样方法，其中样本均值的分布随着样本量的增大而近似正态分布，而不管总体分布如何。以下代码片段展示了如何实现这种方法：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Sobol low-discrepancy sequence (LDS) is a quasi-random sampling method
    available in the sobol_seq package. This method generates a sequence of points
    that are evenly spaced and distributed throughout the sample space, such that
    the gaps between adjacent points are as small as possible. It can be used as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Sobol低偏差序列（LDS）是sobol_seq包中可用的一种近似随机采样方法。这种方法生成一系列点，这些点在样本空间中均匀分布，使得相邻点之间的间隔尽可能小。它可以如下使用：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Latin hypercube sampling is a parallel diversification method where the search
    space is decomposed into 25 blocks, and a solution is generated pseudo-randomly
    in each block. An example of using the Latin hybercube sampling method in the
    pyDOE (Design of Experiments) Python package is shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 拉丁超立方体采样是一种并行多样化方法，其中搜索空间被分解成25个块，每个块中伪随机地生成一个解。下面展示了在pyDOE（实验设计）Python包中使用拉丁超立方体采样方法的示例：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s visualize all of these sampling methods so we can get a good sense of
    the differences between them:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化所有这些采样方法，以便我们可以很好地了解它们之间的差异：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running this code generates the plots shown in figure 7.2\. In this figure,
    candidate solutions have been sampled from a feasible search space using various
    sampling methods, with each point representing a different solution. The level
    of diversity achieved by each sampling method can be evaluated by observing the
    gaps between the points and their dispersion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码生成图7.2所示的图表。在此图中，候选解已使用各种采样方法从可行搜索空间中采样，每个点代表一个不同的解。可以通过观察点之间的间隙及其分散程度来评估每种采样方法达到的多样性水平。
- en: '![](../Images/CH07_F02_Khamis.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F02_Khamis.png)'
- en: Figure 7.2 Sampling methods for generating an initial population
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 生成初始种群的各种采样方法
- en: 'As mentioned in appendix A (see liveBook), there are several Python packages
    for evolutionary computation. In this chapter, we will focus on using pymoo: multi-objective
    optimization in Python. Pymoo provides different sampling methods for creating
    an initial population or an initial search point. Examples include random sampling
    and Latin hypercube sampling. As a continuation of listing 7.1, the following
    code snippet shows random sampling in pymoo:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如附录A（见liveBook）所述，有几个Python包用于进化计算。在本章中，我们将重点介绍使用pymoo：Python中的多目标优化。Pymoo提供了不同的采样方法来创建初始种群或初始搜索点。例如，随机采样和拉丁超立方采样。作为列表7.1的延续，以下代码片段展示了pymoo中的随机采样：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Import an instance of the problem class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入问题类的实例。
- en: ② Import the random sampling method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入随机采样方法。
- en: ③ Import the visualization method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 导入可视化方法。
- en: ④ Create a problem with two variables, and specify the lower and upper bounds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建一个有两个变量的问题，并指定下限和上限。
- en: ⑤ Create an instance of the random sampler.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建随机采样器的实例。
- en: ⑥ Generate 200 random solutions/individuals.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 生成200个随机解/个体。
- en: ⑦ Visualize the generated individuals.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 可视化生成的个体。
- en: 'The following code generates and visualizes 200 initial solutions using Latin
    hypercube sampling:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用拉丁超立方采样生成并可视化200个初始解：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Import the Latin hypercube sampling module.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入拉丁超立方采样模块。
- en: 'If the solutions take the form of permutations, random permutations can be
    generated as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解的形式是排列，可以如下生成随机排列：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Randomly permute a sequence, or return a permuted range.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ① 随机排列一个序列，或返回一个排列的范围。
- en: ② Randomly shuffle a sequence.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ② 随机打乱一个序列。
- en: ③ Population of the initial solution as real-value permutations
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 初始解的种群作为实值排列
- en: ④ Population of the initial solution as binary permutations with the number
    of bits in the binary string and the number of ones in each binary string
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 初始解的种群以二进制排列的形式，其中二进制字符串的位数和每个二进制字符串中1的个数
- en: 'You can also generate a random route between two points using the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下代码在两点之间生成一个随机路径：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① This is a typical graph search with a shuffled frontier.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这是一个典型的带有打乱边界的图搜索。
- en: ② This is the randomization part.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这部分是随机化部分。
- en: ③ Generate random routes between two nodes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在两个节点之间生成随机路径。
- en: ④ Visualize the random routes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 可视化随机路径。
- en: The preceding code modifies a typical graph search algorithm by scrambling the
    frontier nodes. This means that candidates for expansion are “random,” which means
    different routes are yielded when it’s called repeatedly. Some generated random
    routes are shown in figure 7.3.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码通过打乱边界节点修改了一个典型的图搜索算法。这意味着扩展的候选者是“随机”的，这意味着在重复调用时会产生不同的路径。一些生成的随机路径如图7.3所示。
- en: '![](../Images/CH07_F03_Khamis.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F03_Khamis.png)'
- en: Figure 7.3 Generating random initial routes
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 生成随机初始路径
- en: In the next section, I’ll introduce evolutionary computation as population-based
    metaheuristics.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将介绍基于种群的元启发式算法——进化计算。
- en: 7.2 Introducing evolutionary computation
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 介绍进化计算
- en: Evolution can be considered an optimization process in the sense that it involves
    the gradual improvement of the characteristics of living organisms over time,
    resulting in adaptation to dynamically changing and competitive environments and
    an enhanced ability to survive in these environments. In this section, I’ll provide
    an overview of the fundamental concepts of biological evolution. Understanding
    these principles is important for gaining insight into evolutionary computation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 进化可以被视为一种优化过程，因为它涉及随着时间的推移逐渐改善生物体的特征，从而适应动态变化和竞争的环境，并增强在这些环境中生存的能力。在本节中，我将概述生物进化的基本概念。理解这些原理对于深入了解进化计算至关重要。
- en: 7.2.1 A brief recap of biology fundamentals
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 生物学基础简述
- en: The *nucleus* is the central part of any living cell that contains the genetic
    information. This genetic information is stored in the *chromosomes*, each of
    which is built of deoxyribonucleic acid (DNA), which carries the genetic information
    used in the growth, development, functioning, and reproduction of all living organisms.
    Humans have a total of 23 pairs of chromosomes, or 46 chromosomes in total, in
    each of their cells. Each chromosome is made up of many different sections called
    *genes*, which are responsible for coding specific properties of an individual.
    The variant form of a gene that determines these properties, found at a specific
    location on a chromosome, is called an allele. Every gene has a unique position
    on the chromosome called a *locus*. The entire combination of genes is called
    a *genotype*, and it’s the genotype that provides the genetic blueprint for an
    organism, determining the potential for an individual’s traits and characteristics.
    The term *phenotype* refers to the observable physical, behavioral, and physiological
    characteristics of an organism, which result from the interaction between its
    genotype and the environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*细胞核*是任何活细胞的核心部分，其中包含遗传信息。这种遗传信息存储在*染色体*中，每条染色体都是由脱氧核糖核酸（DNA）构成的，它携带用于所有生物体生长、发育、功能和繁殖的遗传信息。人类在其每个细胞中都有23对染色体，即总共46条染色体。每条染色体由许多不同的部分组成，称为*基因*，这些基因负责编码个体的特定属性。决定这些属性的基因的变异形式，位于染色体上的特定位置，称为等位基因。每个基因在染色体上都有一个独特的位置，称为*座位*。所有基因的组合称为*基因型*，它为生物体提供遗传蓝图，决定个体的特征和特性的潜力。*表型*一词指的是生物体的可观察的物理、行为和生理特征，这些特征是其基因型和环境的相互作用的结果。'
- en: 'To illustrate the concept of genes and their role in determining the characteristics
    of a living organism, let’s consider an example where a DNA molecule consists
    of four genes that are responsible for different traits: appetite, movement, feet,
    and skin type. The appetite gene may have different values that reflect the diet
    of the organism, such as herbivore (H), carnivore (C), or insectivore (I). The
    movement gene may determine the organism’s mode of movement, such as climbing
    (CL), flying (FL), running (R), or swimming (SW). The feet gene may determine
    the type of feet or limbs that the organism has, such as claws (CLW), flippers
    (FLP), hooves (HV), or wings (WNG). Finally, the skin gene may determine the skin
    covering of the organism, such as fur (F), scales (S), or feathers (FTH), as illustrated
    in figure 7.4.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明基因及其在决定生物体特征中的作用，让我们考虑一个例子，其中DNA分子由四个基因组成，这些基因负责不同的特征：食欲、运动、足部和皮肤类型。食欲基因可能具有不同的值，反映生物体的饮食，如草食性（H）、肉食性（C）或食虫性（I）。运动基因可能决定生物体的运动方式，如攀爬（CL）、飞行（FL）、奔跑（R）或游泳（SW）。足部基因可能决定生物体具有的足部或肢体类型，如爪子（CLW）、鳍（FLP）、蹄（HV）或翅膀（WNG）。最后，皮肤基因可能决定生物体的皮肤覆盖物，如毛皮（F）、鳞片（S）或羽毛（FTH），如图7.4所示。
- en: '![](../Images/CH07_F04_Khamis.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F04_Khamis.png)'
- en: Figure 7.4 Genotype, phenotype, and taxonomic classification
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 基因型、表型和分类学
- en: In this example, the *genotype* refers to the specific genetic makeup of an
    organism, which is determined by the specific combination of alleles that an individual
    inherits from its parents. The specific values of these genes will determine the
    *phenotype*, or observable characteristics, of the organism. For example, an organism
    with an insectivore appetite gene, a flying movement gene, a wings feet gene,
    and a feather skin gene would likely be a bird. On the other hand, an organism
    with an herbivorous appetite gene, a running movement gene, a hooves feet gene,
    and a fur skin gene would likely be a mammal, such as a white-tailed deer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，*基因型*指的是生物体的特定遗传构成，这是由个体从其父母那里继承的特定等位基因组合所决定的。这些基因的具体值将决定生物体的*表型*，或可观察的特征。例如，具有食虫食欲基因、飞行运动基因、翅膀脚基因和羽毛皮肤基因的生物体很可能是鸟类。另一方面，具有食草食欲基因、奔跑运动基因、蹄脚基因和毛皮皮肤基因的生物体很可能是哺乳动物，如白尾鹿。
- en: The class to which an organism belongs, such as the species, genus, or family,
    is determined by its taxonomic classification based on shared characteristics
    with other organisms.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 生物体所属的类别，如物种、属或科，是根据与其他生物体共享的特征进行的分类学分类所确定的。
- en: 7.2.2 The theory of evolution
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 进化理论
- en: The theory of evolution explains how species of living organisms have changed
    over time and diversified into the forms we see today. This theory, developed
    by Charles Darwin, offers an explanation of biological diversity and its underlying
    mechanisms.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 进化理论解释了生物物种是如何随着时间的推移而变化并多样化成我们今天所看到的形态的。这一理论由查尔斯·达尔文提出，为生物多样性和其潜在机制提供了解释。
- en: 'According to the theory, *natural selection* is a major mechanism that drives
    evolution. Over the course of numerous generations, adaptations arise from the
    cumulative effects of successive, minor, stochastic alterations in traits, and
    natural selection favors those variants that are best suited to their environment.
    This phenomenon is known as survival of the fittest: selected individuals reproduce,
    passing their properties to their offspring. Other individuals die without mating,
    and their properties are thus discarded. Over time, natural selection plays a
    significant role in shaping the characteristics and adaptations of populations,
    promoting the transmission of advantageous traits and eliminating less beneficial
    ones.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这一理论，*自然选择*是推动进化的主要机制。在无数代的过程中，适应性从连续的、微小的、随机的性状变化累积效应中产生，自然选择青睐那些最适合其环境的变体。这一现象被称为适者生存：被选中的个体繁殖，将它们的特性传递给后代。其他个体在没有交配的情况下死亡，因此它们的特性被丢弃。随着时间的推移，自然选择在塑造种群的特征和适应性方面发挥着重要作用，促进有利特性的传递，并消除不那么有利的特性。
- en: The theory of evolution
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 进化理论
- en: 'The theory of evolution by natural selection can be summarized as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自然选择进化理论可以概括如下：
- en: In a world with limited resources and stable populations, each individual competes
    with others for survival.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在资源有限和人口稳定的世界上，每个个体都与其他个体竞争生存。
- en: Those individuals with the “best” characteristics (traits) are more likely to
    survive and to reproduce, and those characteristics will be passed on to their
    offspring.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有最佳特征（性状）的个体更有可能生存和繁殖，这些特征将传递给其后代。
- en: These desirable characteristics are inherited by subsequent generations, and
    (over time) become dominant among the population.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些理想特性被后代继承，并且（随着时间的推移）在种群中变得占主导地位。
- en: During production of a child organism, random events cause random changes to
    the child organism’s characteristics.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产一个生物体后代的过程中，随机事件会导致后代特征发生随机变化。
- en: If these new characteristics are a benefit to the organism, the chances of survival
    for that organism are increased.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这些新特征对生物体有益，那么该生物体的生存机会就会增加。
- en: Evolutionary computation techniques mimic biological evolution and process a
    sequence of operations, such as creating an initial population (a collection of
    chromosomes), evaluating the population, and then evolving the population through
    multiple generations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 进化计算技术模拟生物进化过程，并执行一系列操作，例如创建初始种群（染色体集合）、评估种群，并通过多代进化种群。
- en: 7.2.3 Evolutionary computation
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 进化计算
- en: '*Computational intelligence* (CI) is a subfield of artificial intelligence
    (AI) that emphasizes the design, application, and development of algorithms that
    can learn and adapt to solve complex problems. It focuses on soft computing methods
    such as fuzzy logic, neural networks, evolutionary computation, and swarm intelligence.
    *Evolutionary computation* (EC), as a branch of CI, employs various computational
    methods inspired by biological evolution. These methods have computational mechanisms
    of natural selection, survival of the fittest, and reproduction as the core elements
    of their computational systems.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算智能*（CI）是人工智能（AI）的一个子领域，强调设计、应用和开发能够学习和适应以解决复杂问题的算法。它侧重于软计算方法，如模糊逻辑、神经网络、进化计算和群体智能。*进化计算*（EC）作为CI的一个分支，采用受生物进化启发的各种计算方法。这些方法以自然选择、适者生存和繁殖作为其计算系统的核心元素。'
- en: 'Generally speaking, EC algorithms consist of the following main components:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，EC算法主要由以下主要组件组成：
- en: '*Population of individuals*—This is a set of candidate solutions that are initially
    generated randomly or by some heuristic methods and are then improved over time.
    The population size is usually large in order to explore a wide range of possible
    solutions to the problem. However, the optimal population size depends on various
    factors, such as the complexity of the problem, the number of variables in the
    problem, the required accuracy of the solution, and the computational resources
    available. In practice, the optimal population size is often determined through
    experimentation, with the performance of the algorithm being evaluated for different
    population sizes and the best performing size being selected.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*个体种群*—这是一组初始通过随机生成或某些启发式方法生成的候选解，然后随着时间的推移进行改进。种群的大小通常很大，以便探索问题可能的广泛解决方案。然而，最佳种群大小取决于各种因素，如问题的复杂性、问题中的变量数量、所需解的精度以及可用的计算资源。在实践中，最佳种群大小通常通过实验确定，通过评估不同种群大小的算法性能，并选择表现最佳的大小。'
- en: '*Fitness function*—This function evaluates the quality of candidate solutions.
    It determines how well each solution solves the given problem by assigning a fitness
    value to each individual in the population. The higher the fitness value, the
    better the solution.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*适应度函数*—这个函数评估候选解的质量。它通过为种群中的每个个体分配一个适应度值来确定每个解解决给定问题的程度。适应度值越高，解越好。'
- en: '*Parent selection method*—This method is used to select the most promising
    individuals from the population in order to create new offspring for the next
    generation.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*父代选择方法*—这种方法用于从种群中选择最有潜力的个体，以便为下一代创造新的后代。'
- en: '*Genetic operators*—These operators include *crossover* and *mutation*, and
    they are used to create new offspring from selected parents. The crossover operator
    exchanges genetic material between two selected individuals to create new offspring
    with a combination of traits from both parents. The mutation operator introduces
    random changes to the offspring’s genetic makeup to add diversity to the population
    and prevent stagnation.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遗传算子*—这些算子包括*交叉*和*变异*，它们用于从选定的父母中创建新的后代。交叉算子通过在两个选定的个体之间交换遗传物质来创建具有父母双方特征组合的新后代。变异算子通过在后代遗传组成中引入随机变化来增加种群多样性并防止停滞。'
- en: '*Survival methods*—These methods determine which individuals in a population
    will survive to the next generation.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生存方法*—这些方法确定种群中哪些个体将幸存到下一代。'
- en: Together, these five components form the basis of EC algorithms, which can effectively
    solve various optimization problems. As illustrated in figure 7.5, there are several
    EC paradigms.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些五个组件共同构成了EC算法的基础，可以有效地解决各种优化问题。如图7.5所示，存在几种EC范式。
- en: '![](../Images/CH07_F05_Khamis.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F05_Khamis.png)'
- en: Figure 7.5 EC paradigms
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 EC范式
- en: 'These paradigms mainly vary in their approaches to representing individuals,
    parents, survival selection methods, and genetic operators:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些范式主要在表示个体、父母、生存选择方法和遗传算子的方法上有所不同：
- en: '*Genetic algorithm (GA)*—This search algorithm mimics natural evolution, where
    each individual is a candidate solution encoded as a binary, real-valued, or permutation
    vector. We will discuss genetic algorithms in detail in this part of the book.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遗传算法 (GA)*—这种搜索算法模仿自然进化，其中每个个体都是一个作为二进制、实值或排列向量编码的候选解决方案。我们将在本书的这一部分详细讨论遗传算法。'
- en: '*Differential evolution (DE)*—This algorithm uses real-valued vectors as individuals
    and generates new solutions by adding weighted differences between pairs of existing
    solutions. It is similar to GA, differing in the reproduction mechanism used.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*微分进化 (DE)*—该算法使用实值向量作为个体，通过添加现有解决方案对之间的加权差异来生成新的解决方案。它与遗传算法 (GA) 类似，但在繁殖机制上有所不同。'
- en: '*Genetic programming (GP)*—This is a special case of GA, where each individual
    is a computer program encoded as a variable-length tree. This tree structure is
    used to represent functions and operators, such as `if`-`else` statements and
    mathematical operations.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遗传编程 (GP)*—这是遗传算法 (GA) 的一个特例，其中每个个体都是一个作为变长树编码的计算机程序。这种树结构用于表示函数和运算符，例如 `if`-`else`
    语句和数学运算。'
- en: '*Evolutionary programming (EP)*—This is similar to GP, but it focuses on evolving
    behavioral traits rather than program structure. It is an open framework where
    any representation and mutation operation can be applied, but there is no recombination.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进化编程 (EP)*—这与遗传规划 (GP) 类似，但它侧重于进化行为特征而不是程序结构。这是一个开放的框架，其中可以应用任何表示和变异操作，但没有重组操作。'
- en: '*Evolutionary strategies (ES)*—This algorithm uses real-valued vectors as individuals
    and adapts mutation and recombination parameters during evolution. Plus-selection,
    comma-selection, greedy selection, and distance-based selection are used as selection
    methods.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进化策略 (ES)*—该算法使用实值向量作为个体，并在进化过程中调整变异和重组参数。选择方法包括加法选择、逗号选择、贪婪选择和基于距离的选择。'
- en: '*Cultural algorithm (CA)*—This approach incorporates social learning from a
    shared belief space into the traditional population-based evolution process. CA
    models the evolution of a population’s culture and how it influences the genetic
    and phenotypic evolution of individuals.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文化算法 (CA)*—这种方法将来自共享信念空间的社会学习纳入传统的基于种群的进化过程。CA 模拟了种群文化的进化及其对个体遗传和表型进化的影响。'
- en: '*Co-evolution (CoE)*—This is based on the reciprocal evolutionary change that
    occurs between interacting populations, where each represents a given species,
    together optimizing coupled objectives.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*协同进化 (CoE)*—这是基于相互作用种群之间发生的相互进化变化，其中每个种群代表一个给定的物种，共同优化耦合目标。'
- en: 'EC is a powerful approach to optimization that has several advantages, as well
    as a few drawbacks. The advantages include the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: EC 是一种强大的优化方法，具有多个优点以及一些缺点。优点包括以下方面：
- en: EC algorithms do not make any presumptions about the problem space, making them
    applicable to a wide range of problems.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC 算法不对问题空间做出任何假设，这使得它们适用于广泛的领域。
- en: They are widely applicable across different domains and can be used to solve
    continuous and discrete problems in various fields.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在不同的领域中被广泛适用，可以用于解决各种领域的连续和离散问题。
- en: The solutions produced by EC algorithms are more interpretable than those of
    neural networks or other black-box optimization techniques. This is mainly because
    EC algorithms use a more transparent process of selection, mutation, and recombination
    that can be tracked and understood step by step, whereas neural networks are often
    considered “black boxes” due to their complex, layered structures and nonlinear
    operations.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC 算法产生的解决方案比神经网络或其他黑盒优化技术更易于解释。这主要是因为 EC 算法使用了一个更透明的选择、变异和重组过程，可以逐步跟踪和理解，而神经网络由于其复杂、分层结构和非线性操作，通常被视为“黑盒”。
- en: EC algorithms provide multiple alternative solutions, which can be useful in
    cases where there is no single best solution.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC 算法提供多个替代解决方案，这在没有单一最佳解决方案的情况下非常有用。
- en: EC algorithms exhibit inherent parallelism, making them well-suited for simple
    parallel implementations on modern hardware.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC 算法表现出固有的并行性，这使得它们非常适合在现代硬件上的简单并行实现。
- en: 'The disadvantages of EC include the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: EC 的缺点包括以下方面：
- en: EC algorithms can be computationally expensive, meaning that they may be slow
    to converge or require a significant amount of computational resources to run.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC算法可能计算成本高昂，这意味着它们可能收敛缓慢或需要大量的计算资源来运行。
- en: While EC algorithms, like many metaheuristic algorithms, cannot guarantee finding
    an optimal solution, they often converge to a near-optimal solution within a finite
    time frame.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管EC算法，如许多元启发式算法一样，不能保证找到最优解，但它们通常在有限的时间内收敛到近似最优解。
- en: EC algorithms often require parameter tuning to achieve good performance, which
    can be time-consuming and challenging.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC算法通常需要参数调整以达到良好的性能，这可能既耗时又具有挑战性。
- en: This chapter primarily focuses on genetic algorithms. The following section
    will look at the various components of genetic algorithms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注遗传算法。下一节将探讨遗传算法的各个组成部分。
- en: 7.3 Genetic algorithm building blocks
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 遗传算法构建模块
- en: Genetic algorithms are the most widely used form of EC. They are adaptive heuristic
    search algorithms that are designed to simulate processes in natural systems necessary
    for evolution, as proposed by Charles Darwin in his theory of evolution. These
    algorithms represent an intelligent exploitation of a random search within a defined
    search space.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法是EC最广泛使用的形式。它们是自适应启发式搜索算法，旨在模拟自然系统中的进化过程，这是查尔斯·达尔文在其进化论中提出的。这些算法代表了在定义的搜索空间内对随机搜索的智能利用。
- en: The first genetic algorithm, named simple genetic algorithm (SGA) and also known
    as the classical or canonical GA, was developed by John Holland in 1975\. Through
    his research, Holland provided insights into the design of artificial systems
    that are robust, adaptive, and capable of evolving to meet new challenges. By
    studying the processes of natural systems, he sought to create algorithms and
    computational models that could solve complex problems much like natural systems
    can. Holland defined GA as a computer program that evolves in ways that resemble
    natural selection and that can solve complex problems that even their creators
    do not fully understand. GA is based on the principles of evolution via natural
    selection, employing a population of individuals that undergo selection in the
    presence of variation-inducing operators such as mutation and crossover (recombination).
    A fitness function is used to evaluate individuals, and their reproductive success
    varies with their fitness. Figure 7.6 shows an analogy between GA and natural
    evolution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个遗传算法，称为简单遗传算法（SGA），也称为经典或标准GA，由约翰·霍兰德在1975年开发。通过他的研究，霍兰德为设计鲁棒、自适应并能适应新挑战的人工系统提供了见解。通过研究自然系统的过程，他试图创建算法和计算模型，这些模型可以像自然系统一样解决复杂问题。霍兰德将GA定义为一种计算机程序，其进化方式类似于自然选择，并且可以解决即使其创造者也不完全理解的复杂问题。GA基于自然选择的进化原理，使用个体种群，这些个体在变异诱导操作（如变异和交叉）的存在下进行选择。适应度函数用于评估个体，它们的繁殖成功率与它们的适应度成正比。图7.6显示了GA与自然进化的类比。
- en: '![](../Images/CH07_F06_Khamis.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F06_Khamis.png)'
- en: Figure 7.6 GA versus natural evolution
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 GA与自然进化的对比
- en: GA starts by initializing a population of individuals or candidate solutions.
    The fitness of all the individuals in the population is evaluated based on a defined
    fitness function, and then a new population is created by performing crossover
    and mutation, which generate children or new solutions. In constrained optimization
    problems, a feasibility check and repair should be applied after the offspring
    are produced.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法（GA）首先初始化一个个体或候选解的种群。根据定义的适应度函数评估种群中所有个体的适应度，然后通过执行交叉和变异操作来创建新种群，这些操作生成子代或新解。在约束优化问题中，应在产生后代后进行可行性检查和修复。
- en: The population keeps evolving until certain stopping criteria are met, as illustrated
    in figure 7.7\. These termination criteria could be
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 种群会持续进化，直到满足某些停止标准，如图7.7所示。这些终止标准可能是
- en: A specified number of generations or fitness evaluations (100 or 150 generations)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定数量的代数或适应度评估（100或150代）
- en: An adequate solution that reaches a minimum threshold
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个达到最小阈值的充分解
- en: When there is no improvement in the best individual for a specified number of
    generations
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在指定数量的代数内最佳个体没有改进时
- en: When memory or time constraints are reached
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当达到内存或时间限制时
- en: Any combination of the preceding points
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前述任何组合点
- en: '![](../Images/CH07_F07_Khamis.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F07_Khamis.png)'
- en: Figure 7.7 GA steps
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 遗传算法步骤
- en: Algorithm 7.1 summarizes the main steps of genetic algorithms.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 算法7.1总结了遗传算法的主要步骤。
- en: Algorithm 7.1 Genetic algorithm
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 算法7.1 遗传算法
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The concept of GA is straightforward and easy to understand, as it emulates
    the process of natural evolution. It is a modular algorithm that can operate in
    parallel and can be easily distributed. GA is versatile and can handle multi-objective
    optimization problems effectively. It is particularly effective in noisy environments.
    GA is widely employed for tackling complex continuous and discrete optimization
    problems, and it excels in scenarios featuring numerous combinatorial parameters
    and nonlinear interdependencies among variables. Notably, as of the publication
    of this book in 2024, a search for “genetic algorithm” as a composite keyword
    returns approximately 100,000 results on Google Patent Search, while Google Scholar
    presents a staggering 1,940,000 results. This volume reflects the substantial
    interest in and diverse applications of genetic algorithms across academic and
    industrial domains.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: GA（遗传算法）的概念简单易懂，因为它模拟了自然进化的过程。它是一个模块化算法，可以并行操作，并且易于分布式执行。GA功能多样，能够有效地处理多目标优化问题。在噪声环境中尤其有效。GA被广泛应用于解决复杂的连续和离散优化问题，并且在具有众多组合参数和变量之间非线性相互依赖的场景中表现出色。值得注意的是，截至本书2024年出版时，在谷歌专利搜索中搜索“遗传算法”作为复合关键词，大约有100,000个结果，而谷歌学术搜索则呈现惊人的1,940,000个结果。本卷反映了遗传算法在学术和工业领域内受到的广泛关注及其多样化的应用。
- en: 7.3.1 Fitness function
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 适应度函数
- en: 'As mentioned earlier, GA mimics nature’s survival-of-the-fittest principle
    in a search process. Therefore, genetic algorithms are naturally suitable for
    solving maximization problems. However, various mathematical transformations can
    be used to convert minimization problems into maximization problems, such as these:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GA在搜索过程中模仿了自然界的适者生存原则。因此，遗传算法自然适用于解决最大化问题。然而，可以使用各种数学变换将最小化问题转换为最大化问题，例如以下这些：
- en: '*Negation transformation*—The simplest transformation is to negate the objective
    function. For example, maximizing a fitness function *f*(*x*) = –*O*(*x*) is the
    same as minimizing the original objective function *O*(*x*).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*否定变换*——最简单的变换是对目标函数取反。例如，最大化适应度函数 *f*(*x*) = –*O*(*x*) 等同于最小化原始目标函数 *O*(*x*)。'
- en: '*Reciprocal transformation*—Another way to convert a minimization problem into
    a maximization problem is to take the reciprocal of the objective function. This
    works only if the objective function is always non-negative. Equation 7.1 shows
    an example:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*倒数变换*——将最小化问题转换为最大化问题的另一种方法是取目标函数的倒数。这仅当目标函数始终非负时才有效。方程7.1展示了示例：'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH07_F07_Khamis-EQ01.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F07_Khamis-EQ01.png)'
- en: '| 7.1 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 7.1 |'
- en: '*Other mathematical transformations*—Equation 7.2 shows another transformation
    that converts an objective function in a minimization problem *O*(*x*) into a
    fitness function in a maximization problem *f*(*x*). In this equation, *O[i]*
    is the objective function value of individual *i*, *N* is the population size,
    and *V* is a large value to ensure non-negative fitness values. The value of *V*
    can be the maximum value of the second term of the equation, so that the fitness
    value corresponding to the maximum value of the objective function is zero:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他数学变换*——方程7.2展示了另一种变换，将最小化问题中的目标函数 *O*(*x*) 转换为最大化问题中的适应度函数 *f*(*x*)。在这个方程中，*O[i]*
    是个体 *i* 的目标函数值，*N* 是种群大小，*V* 是一个很大的值，以确保适应度值非负。*V* 的值可以是方程第二项的最大值，这样对应于目标函数最大值的适应度值为零：'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH07_F07_Khamis-EQ02.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F07_Khamis-EQ02.png)'
- en: '| 7.2 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 7.2 |'
- en: According to the duality principal introduced in section 1.3.2, these transformations
    do not alter the location of the minima but convert a minimization problem to
    an equivalent maximization problem.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第1.3.2节中引入的对偶原理，这些变换不会改变最小值的位置，但将最小化问题转换为等价的最大化问题。
- en: 7.3.2 Representation schemes
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 表示方案
- en: An *encoding* is a data structure for representing candidate solutions, and
    a good encoding is probably the most important factor for the performance of GA.
    In GA, the parameters of a candidate solution (the genes) are concatenated to
    form a string (a chromosome). Binary encoding, real-value encoding, and permutation
    encoding can be used to encode the solution. Binary encoding is used in binary-coded
    GA (BGA) where the solution is represented as a binary string, as illustrated
    in figure 7.8.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F08_Khamis.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 Binary encoding
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look again at the ticket pricing example introduced in section 1.3.1,
    where an event organizer is planning a conference and wants to determine the optimal
    ticket price to maximize the profit. The expected profit is given by the following
    equation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F08_Khamis-EQ03.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: '| 7.3 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: where *x* is the ticket price. The binary genetic algorithm (BGA) can be used
    to find the optimal ticket price to maximize the profit, subject to the boundary
    constraint 75.0 ≤ *x* ≤ 235.0, which will make sure that profit is positive. BGA
    features a simple binary encoding. The boundary constraint on the preceding function
    requires us to use an 8-bit binary encoding, as explained in the following sidebar.
    Hence, the chromosomes are represented by bit strings of length 8.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the minimum number of bits for a solution
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the number of bits required to represent a range between the lower
    bound (LB) and upper bound (UB) with a desired precision *p*, follow these steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the range size: *R* = (*UB* – *LB*).'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Divide the range size by the desired precision: *R* / *P.*'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Round up to the nearest whole number: *number_of_steps* = ceil(*R* / *P*),
    where ceil is the ceiling function that rounds up to the nearest integer.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Calculate the number of bits: *number_of_bits* = ceil(log[2](*number_of_steps*)),
    where log[2] is the logarithm to the base 2.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s calculate the number of bits we’ll need for the ticket pricing problem:
    75.0 ≤ *x* ≤ 235.0, assuming a precision of 0.1:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the range size: (235.0 – 75.0) = 160'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Divide the range size by the desired precision: 160 / 0.1 = 1600'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Round up to the nearest whole number: 1600. Now you have 1600 steps (values)
    to represent the numbers from 75.0 to 235.0 with a precision of 0.1.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find the minimum number of bits required, you can use the formula *number_of_bits*
    = ceil(log[2](*number_of_steps*)):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*number_of_bits* = ceil(log[2](1600)) ≈ ceil(10.64) = 11'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So you’ll need 11 bits to represent the numbers from 75.0 to 235.0 with a precision
    of 0.1\. If you want to consider integer values only (i.e., a precision of 1),
    you would need ceil(logs(160)) = ceil(7.32) = 8 bits.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, GA starts with an initial population of candidate solutions.
    Population size has to be carefully selected, as very big population size usually
    does not improve performance of GA. Some research also shows that the best population
    size depends on the size of encoded string (chromosomes). It means that if you
    have chromosomes with 32 bits, the population should be higher than for chromosomes
    with 16 bits.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，遗传算法从候选解的初始种群开始。种群大小必须仔细选择，因为非常大的种群大小通常不会提高遗传算法的性能。一些研究也表明，最佳种群大小取决于编码字符串（染色体）的大小。这意味着如果你有32位的染色体，种群应该比16位的染色体大。 '
- en: In the ticket pricing problem, assume that we start with a population of size
    5\. Table 7.2 shows examples of random solutions that can be generated to form
    the initial population.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在票价定价问题中，假设我们从大小为5的种群开始。表7.2显示了可以生成以形成初始种群的随机解的示例。
- en: Table 7.2 Initial population
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2初始种群
- en: '| Candidate solutions *x* | Values of *x* in the solution space | Candidate
    solutions in the binary coding space | Objective function *f*(*x*) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 候选解 *x* | 解空间中*x*的值 | 二进制编码空间中的候选解 | 目标函数 *f*(*x*) |'
- en: '| --- | --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| x[1] | 77 | 01001101 | 8,820 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| x[1] | 77 | 01001101 | 8,820 |'
- en: '| x[2] | 203 | 11001011 | 84,420 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| x[2] | 203 | 11001011 | 84,420 |'
- en: '| x[3] | 110 | 01101110 | 90,000 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| x[3] | 110 | 01101110 | 90,000 |'
- en: '| x[4] | 145 | 10010001 | 128,500 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| x[4] | 145 | 10010001 | 128,500 |'
- en: '| x[5] | 230 | 11100110 | 18,000 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| x[5] | 230 | 11100110 | 18,000 |'
- en: Once we have an initial population, we can proceed to select the parents that
    will be subjected to genetic operators (crossover and mutation). We’ll look at
    the selection operators next.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了初始种群，我们就可以继续选择将受到遗传算子（交叉和变异）处理的父母。我们将接下来查看选择算子。
- en: 7.3.3 Selection operators
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 选择算子
- en: There are different methods (operators) for parent selection, and they have
    different levels of selective pressure. *Selective pressure* refers to the probability
    of the best individual being selected compared to the average probability of selection
    for all individuals. When using an operator with a high selective pressure in
    a genetic algorithm, the diversity within the population decreases at a faster
    rate than it would using operators with a lower selective pressure. This may sound
    good, but it can result in the population converging prematurely towards suboptimal
    solutions, thus limiting the exploration abilities of the population and eliminating
    individuals that do not fit the specific criteria determined by the selective
    pressure. This can lead to a lack of diversity in the population, which reduces
    the chances of finding better solutions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着不同的父母选择方法（算子），它们具有不同的选择压力水平。*选择压力*指的是最佳个体被选中的概率与所有个体平均选择概率相比。当在遗传算法中使用具有高选择压力的算子时，种群内的多样性比使用具有较低选择压力的算子时下降得更快。这听起来可能很好，但它可能导致种群过早地收敛到次优解，从而限制种群的探索能力并消除不符合由选择压力确定的特定标准的个体。这可能导致种群缺乏多样性，从而降低找到更好解的机会。
- en: It is important to balance selective pressure with the exploration capabilities
    of the population to avoid premature convergence and to encourage the discovery
    of a diverse range of optimal solutions. Figure 7.9 illustrates some selection
    methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡选择压力与种群探索能力对于避免过早收敛并鼓励发现多样化的最优解至关重要。图7.9展示了某些选择方法。
- en: '![](../Images/CH07_F09_Khamis.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F09_Khamis.png)'
- en: Figure 7.9 Selection methods with their selective pressure
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 选择方法及其选择压力
- en: Elitism
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 精英主义
- en: '*Elitism* in genetic algorithms involves selecting the fittest individuals
    for crossover and mutation and preserving the top-performing individuals of the
    current population to propagate into the next generation. The greater the number
    of individuals that are preserved, the lower the diversity of the succeeding population.
    This selection method has the highest selective pressure, as illustrated in figure
    7.9\.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*精英主义*在遗传算法中涉及选择最适应的个体进行交叉和变异，并保留当前种群中表现最好的个体以传播到下一代。保留的个体数量越多，后续种群中的多样性就越低。这种选择方法具有最高的选择压力，如图7.9所示。'
- en: In the ticket pricing example, the best solutions (*x[4]* and *x[3]*) will be
    selected parents to generate offspring, as shown in table 7.3.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在票价定价示例中，最佳解（*x[4]*和*x[3]*）将被选为父母以生成后代，如表7.3所示。
- en: Table 7.3 Solution ranking
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3解排名
- en: '| Candidate solutions *x* | Values of *x* in the solution space | Candidate
    solutions in the binary coding space | Objective function *f*(*x*) | Ranking |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| x[1] | 77 | 01001101 | 8,820 | 5 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| x[2] | 203 | 11001011 | 84,420 | 3 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| x[3] | 110 | 01101110 | 90,000 | **2** **(second-best individual)** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| x[4] | 145 | 10010001 | **128**,**500** | **1** **(best individual)** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| x[5] | 230 | 11100110 | 18,000 | 4 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: Fitness-proportionate selection
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '*Fitness-proportionate selection* (FPS) is a selection method that favors the
    selection of the fittest individuals in a population. This method creates a probability
    distribution where the probability of an individual being selected is directly
    proportional to its fitness value. Individuals are chosen from this distribution
    by sampling it randomly. The individual fitness assignment relative to the whole
    population can be calculated as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F09_Khamis-EQ04.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: '| 7.4 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: where *f* is the solution represented by an individual chromosome and N is the
    population size. Roulette wheel selection is an example of an FPS operator.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'In our ticket pricing example, the roulette wheel can be constructed by implementing
    the following steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '1\.  Calculate the total fitness for the population: *F* = 8,820 + 84,420 +
    90,000 + 128,500 + 18,000 = 329,740.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 2\.  Calculate the selection probability *p[k]* for each chromosome *x[k]* where
    *p[k]* = *f*(*x[k]*) / *F*. Table 7.4 shows the calculated selection probabilities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.4 Selection probabilities
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '| Candidate solutions *x* | Values of *x* in the solution space | Candidate
    solutions in the binary coding space | Objective function *f*(*x*) | Selection
    probability *p[k]* |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| x[1] | 77 | 01001101 | 8,820 | 0.03 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| x[2] | 203 | 11001011 | 84,420 | 0.26 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| x[3] | 110 | 01101110 | 90,000 | 0.27 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| x[4] | 145 | 10010001 | 128,500 | 0.39 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| x[5] | 230 | 11100110 | 18,000 | 0.05 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: 3\.  Calculate the cumulative probability *q[k]* for each chromosome *x[k]*
    where *q[k]* = sum(*p[j]*), *j* *= {1,k}*. Table 7.5 shows the calculated cumulative
    probabilities.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.5 Cumulative probabilities
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '| Candidate solutions *x* | Values of *x* in the solution space | Candidate
    solutions in the binary coding space | Objective function *f*(*x*) | Selection
    probability *p[k]* | Cumulative probability *q[k]* |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| x[1] | 77 | 01001101 | 8,820 | 0.03 | 0.03 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| x[2] | 203 | 11001011 | 84,420 | 0.26 | 0.28 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| x[3] | 110 | 01101110 | 90,000 | 0.27 | 0.56 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| x[4] | 145 | 10010001 | 128,500 | 0.39 | 0.95 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| x[5] | 230 | 11100110 | 18,000 | 0.05 | 1.00 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: 4\.  Generate a random number *r* from the range [0,1].
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 5\.  If *q*[1] >= *r*, then select the first chromosome *x*[1]; otherwise, select
    the *k^(th)* chromosome *x[k]* (2 ≤ k ≤ *N*) such that *q[k]*[-1] < *r* ≤ *q[k]*.
    If we assume that the randomly generated number *r* = 0.25, then *x*[2] with *q*[2]
    = 0.28 is selected because *q*[2] > 0.25, and if *r* = 0.58, *x*[4] will be selected
    because *q[4]* > 0.58. Figure 7.10 illustrates the roulette wheel for the ticket
    pricing example.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F10_Khamis.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 Roulette wheel for the ticket pricing example
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the fittest individual occupies the largest segment of the roulette
    wheel, and the weakest individual occupies the smallest segment of the wheel.
    Due to the direct correlation between fitness and selection in proportional selection,
    there is a potential for dominant individuals to disproportionately contribute
    to the next generation’s offspring, leading to a reduction in the diversity of
    the population. This implies that proportional selection results in a high selective
    pressure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Rank-based selection
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: One way to address the limitations of FPS in genetic algorithms is to use relative
    fitness instead of absolute fitness to determine selection probabilities—individuals
    are selected based on their fitness relative to the fitness of other individuals
    in the population. This approach ensures that the selection process is not dominated
    by the best individual in the population.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Linear ranking and nonlinear ranking can be used. In *linear ranking*, the
    rank-based probability of an individual *i* being selected is calculated using
    the following equation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F10_Khamis-EQ05.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: '| 7.5 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: where *N* is the size of the population, *SP* is the selection pressure (1.0
    < *SP* ≤ 2.0), and *r*(*i*) is the rank associated with individual *i* (a higher
    rank is better). In the ticket pricing example, where *N* = 5, and assuming that
    *SP* = 1.5, the rank-based selection probability of each individual in the population
    is shown in table 7.6.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.6 Rank-based selection probabilities
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '| Candidate solutions *x* | Values of *x* in the solution space | Candidate
    solutions in the binary coding space | Objective function *f*(*x*) | Rank *r[i]*
    | FPS cumulative probability *q[k]* | Rank-based selection probability |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| x[1] | 77 | 01001101 | 8,820 | 1 | 0.03 | 0.50 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| x[2] | 203 | 11001011 | 84,420 | 3 | 0.28 | 0.75 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| x[3] | 110 | 01101110 | 90,000 | 4 | 0.56 | 0.88 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| x[4] | 145 | 10010001 | 128,500 | 5 | 0.95 | 1.00 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| x[5] | 230 | 11100110 | 18,000 | 2 | 1.00 | 0.63 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: As you can see, rank-based selection reduces the bias of FPS by assigning greater
    probabilities of selection to less-fit individuals.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '*Nonlinear ranking* permits higher selective pressures than linear ranking
    does. The selection probability is calculated using the following equation:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F10_Khamis-EQ06.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: '| 7.6 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: where *X* is computed as the root of the polynomial (SP–N).X*^(N–)*¹)+SP.X*^(N–)*²+…+SP.X+SP=0.
    This nonlinear ranking allows values of selective pressure in the interval [1,
    N – 2].
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Stochastic universal sampling
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '*Stochastic universal sampling* (SUS) is another approach to mitigating the
    potential bias in the roulette-wheel selection approach. This method involves
    placing an outer roulette wheel around the pie with *m* evenly spaced pointers.
    With SUS, a single spin of the roulette wheel is used to simultaneously select
    all *m* individuals for reproduction. Figure 7.11 shows SUS for the ticket pricing
    problem using four selection points.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F11_Khamis.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 Stochastic universal sampling (SUS) strategy
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Tournament selection
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '*Tournament selection* involves randomly selecting a group of *k* individuals
    from the current population, where *k* is the size of the tournament group. Once
    the group is formed, a tournament is held among its members to identify the best-performing
    individual based on their fitness values. The individual with the highest fitness
    score is the winner and advances to the next stage of the genetic algorithm. Figure
    7.12 shows the tournament selection process.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F12_Khamis.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 Tournament selection
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: To select *m* individuals for reproduction, the tournament procedure is carried
    out *m* times. In each iteration, a new tournament group is randomly chosen from
    the population, and the individuals in the group compete against each other until
    the best-performing individual is identified. The winners from each tournament
    are then selected for reproduction, which involves applying genetic operators
    such as crossover and mutation to create new offspring.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Random selection
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '*Random selection* is the simplest selection operator, where each individual
    has the same selection probability of 1/*N* (where *N* is the population size).
    No fitness information is used, which means that the best and the worst individuals
    have exactly the same probability of being selected. Random selection has the
    lowest selective pressure among the selection operators, as all individuals within
    the population have the same chance of being selected.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Other selection methods
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Other selection methods include, but are not limited to, Boltzmann Selection,
    (*μ, λ*)- and (*μ* + *λ*)-selection, and hall of fame. The random selection and
    tournament selection methods are implemented as part of the `pymoo.operators.selection`
    class in pymoo.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: After we select the parents, we need to produce offspring by applying reproduction
    operators.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.4 Reproduction operators
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Genetic algorithms employ two primary genetic operators, namely crossover and
    mutation, to generate offspring. Let’s look at these two reproduction operators
    in detail.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Crossover
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '*Crossover* is inspired by the biological process of recombination, where a
    portion of the genetic information is exchanged between two chromosomes. This
    exchange of genetic material results in the production of offspring, so two parents
    can thus give rise to two offspring. In order to ensure that the best individuals
    are able to contribute their genetic material, superior individuals are typically
    given more opportunities to reproduce through crossover. This mechanism promotes
    the effective combination of schemata, which are subsolutions located on different
    chromosomes. 1-point crossover, *n*-point crossover, and uniform crossover are
    commonly used crossover methods.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In *1-point crossover*, we start by choosing a random point on the two parents
    and splitting parents at this crossover point. Two children are then created by
    exchanging tails, as illustrated in figure 7.13\. This crossover operation produces
    two new children (candidate solutions), which in the figure are 01010001 and 01001101
    (or 81 and 77 in decimal, respectively) as potential ticket prices. These solutions
    result in total profits of $20,980 and $8,820 respectively, based on equation
    7.3.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F13_Khamis.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 1-point crossover
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In *n-point crossover*, which is a generalization of 1-point crossover, we choose
    *n* random crossover points and split along those points. The children are generated
    by gluing parts together and alternating between parents, as illustrated in figure
    7.14\. Following the 2-point crossover illustrated in figure 7.14, two candidate
    solutions are generated, which are 141 and 81 with fitness values of $126,580
    and $20,980 respectively.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F14_Khamis.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 *n*-point crossover
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In *uniform crossover*, random bit positions from two parents are swapped to
    create two offspring. One parent is assigned the label “heads” and the other “tails.”
    For the first child, a coin is flipped for each gene to determine whether it should
    come from the “heads” or “tails” parent. The second child is created by taking
    the inverse of each gene in the first child, as shown in figure 7.15\. In this
    example, applying uniform crossover results in 217 and 5 with fitness values of
    $53,620 and $–319,500\. As you can see, 5 is not a feasible solution because it
    is not within the boundary constraints of {75.0,235.0}. This solution is rejected.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F15_Khamis.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 Uniform crossover
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In pymoo, the repair operator can be used make sure the algorithm only searches
    in the feasible space. It is applied after the offspring have been produced.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Mutation
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '*Mutation* is a process that introduces new genetic material into an individual,
    which helps to increase the diversity of the population. This diversity is important
    because it allows the population to explore a wider range of possible solutions
    to the problem at hand. Mutation is often used in combination with crossover to
    ensure that the full range of alleles is accessible for each gene. In the case
    of mutation, selection mechanisms could focus on “weak” individuals in the hope
    that mutation will introduce better traits to those individuals, increasing their
    chances of survival.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In binary genetic algorithms, mutation is performed by altering each gene independently
    with a probability *p[m]*. For each gene, we generate a random number *r* between
    0 and 1\. If *p[m]* > *r*, we alter the gene. Figure 7.16 illustrates mutating
    one of the individuals of the ticket pricing problem.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F16_Khamis.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 Mutation
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: New population
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: After applying crossover and mutation, we will have new offspring that represent
    new candidate solutions. To start a new generation, we need to create a new population
    by selecting individuals from the old population and from the newly generated
    offspring. The size of the new population will remain the same as the old population.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Generational GA and steady-state GA are two models used in genetic algorithms.
    As shown in figure 7.17, in *generational GA* models, the whole population is
    replaced by its offspring to start a “next generation.” In *steady-state GA*,
    the number of generated offspring is less than the population size. Old individuals
    may be replaced by new ones. The process of selecting individuals for the new
    population is known as *survivor selection*. We’ll look at survivor selection
    methods next.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH07_F17_Khamis.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 GA generational and steady-state models
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.5 Survivor selection
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Random selection, age-based selection, fitness-proportionate selection, and
    tournament selection are examples of survivor selection methods that can preserve
    the best individuals while also introducing diversity to a population by making
    use of the newly generated offspring:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In *random selection*, the new population is formed by random selection of *N*
    individuals.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With *age-based selection* (or first in, first out), the oldest individuals
    will be deleted.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fitness-proportionate selection* (FPS) takes into consideration the fitness
    of each individual—we can delete or replace individuals based on the inverse of
    fitness, always keeping the best individuals or deleting the worst individuals.
    For example, *elitist selection* involves simply selecting the best individuals
    from both the old population and the new offspring to create the new population.
    This method ensures that the best solutions are preserved from generation to generation.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tournament selection involves selecting individuals from both the old population
    and the new offspring at random and then selecting the best individuals from each
    group to create the new population. This method can be more effective at preserving
    diversity in the population.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the ticket pricing example, if we apply elitist selection, the new population
    will be formed by the selected solutions shown in table 7.7.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.7 Elitist selection
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '| Source | Candidate solutions x in the solution space | Candidate solutions
    in the binary coding space | Objective function f(x) | Ranking | Selected |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| Old individuals | 77 | 01001101 | 8,820 | 7 | No |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| 203 | 11001011 | 84,420 | 3 | Yes |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| 110 | 01101110 | 90,000 | 2 | Yes |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| 145 | 10010001 | 128,500 | 1 | Yes |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| 230 | 11100110 | 18,000 | 6 | No |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| New individuals generated by 1-point crossover | 81 | 01010001 | 20,980 |
    5 | Yes |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| 77 | 01001101 | 8,820 | 7 | No |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| New individuals generated by mutating individual 77 | 103 | 01100111 | 76,420
    | 4 | Yes |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: You may have noticed that 1-point crossover generated a solution that already
    exists in the initial population. This phenomenon is not necessarily a problem,
    as it is an expected outcome when applying genetic operators in a search process.
    Crossover and mutation can result in both explorative and exploitative behaviors.
    For example, in 1-point or *n*-point crossover and based on the random split point
    position, a new solution can be the same as or close to the parents or can generate
    more diverse offspring.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Implementing genetic algorithms in Python
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A genetic algorithm is an easy algorithm to implement. Let’s see how we can
    solve the ticket pricing problem using GA in Python.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by importing the necessary packages and defining the problem.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.2 Solving the ticket pricing problem using binary GA
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because we’re solving this problem using a binary GA, we need to generate an
    initial random population. As a continuation of listing 7.2, the following `init_pop`
    function takes two arguments as input—`pop_size`, which represents the population
    size, and `chromosome_length`, which represents the length of each chromosome:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Generate a list of random integers.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: ② Convert the integers to binary strings.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: ③ Convert the binary strings to lists of binary digits.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: ④ Return the final list of binary chromosomes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The `init_pop` function starts by generating a list of random integers from
    75 to 235 (inclusive) with a length equal to `pop_size`. This list will later
    be converted to binary representations. The integers in the `ints` list are then
    converted to binary strings using the `bin()` function, which returns a binary
    string representation of a given number with the prefix `0b`. To remove this prefix,
    we use slicing with `[2:]`. Then we use the `zfill()` method to pad the binary
    string with leading zeros to ensure it has the same length as `chromosome_length`.
    The binary strings in the `strs` list are converted to lists of binary digits
    (0 or 1). This is done using a nested list comprehension that iterates through
    each character in the binary strings and converts it to an integer. The function
    finally returns a list of binary chromosomes, where each chromosome is a list
    of binary digits.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'For a given population, we can calculate the fitness of each element in the
    population using the following `fitness_score` function. This fitness function
    essentially determines how “good” a particular offspring is. It converts each
    unit in the population to a binary number (the genotype), evaluates the function
    to optimize profit, and then returns the “best” offspring. The function mainly
    takes a population as input and returns a tuple containing two lists, one of the
    sorted fitness values and another of the sorted population:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Convert binary to decimal.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: ② Evaluate the fitness of each chromosome and append the fitness value to the
    fitness_values list.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create tuples of fitness values and their corresponding chromosomes, and then
    sort them in descending order based on fitness values.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: ④ Unzip the sorted tuples back into separate lists for fitness values and the
    population.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Return the sorted fitness values and population.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now select two parents using the random selection method implemented
    in the following `select_parent` function. This function takes two arguments as
    input: `population`, which is a list of individuals in the population, and `num_parents`,
    which represents the number of parents to select. It returns a list of selected
    parents:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Randomly select a specified number of unique parents from the given population.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: ② Return the list of selected parents.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The `select_parent` function implements a simple random sampling selection method,
    which gives each individual in the population an equal chance of being selected
    as a parent. Other selection methods, such as FPS or roulette wheel selection,
    can also be used to give higher chances to individuals with better fitness values.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `roulette_wheel_selection` function shows the steps of roulette
    wheel selection. The function takes two arguments as input—`population`, which
    is a list of individuals in the population, and `num_parents`, which represents
    the number of parents to select:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Calculate total fitness.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: ② Calculate selection probabilities for each individual.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: ③ Select only two parents.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: ④ Generate a random number r between 0 and 1.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Find the individual whose cumulative probability includes r.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting the parents, it’s time to apply genetic operators to produce
    the offspring. The following `crossover` function implements 1-point crossover.
    The function takes two arguments as input: `parents`, which is a list of two parent
    chromosomes, and `crossover_prob`, which represents the probability of crossover
    occurring between the parents. It returns a list of parents and offspring. The
    first offspring is generated by taking the first part (up to and including the
    crossover point) of the first parent and the second part (from the crossover point
    + 1 to the end of the chromosome) of the second parent. Similarly, the second
    offspring is generated by taking the first part (up to and including the crossover
    point) of the second parent and the second part (from the crossover point + 1
    to the end of the chromosome) of the first parent:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Apply crossover if, and only if, crossover probability is greater than a randomly
    generated number.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: ② Choose a random crossover point within the range of chromosome indices.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create the first offspring.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create the second offspring.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Return the original parents and the new offspring generated by the crossover
    operation.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now apply the mutation process. The following `mutation` function performs
    mutation operations on a given population of chromosomes. It takes two arguments
    as input: `population`, which is a list of binary chromosomes, and `mutation_prob`,
    which represents the probability of mutation occurring at each gene in the chromosomes.
    It returns the mutated population:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Iterate through each chromosome in the population.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: ② Iterate through each gene in the chromosome, except the last one.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: ③ Apply mutation if, and only if, the mutation probability is greater than a
    randomly generated number
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: ④ Flip the value of the gene.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Return the mutated population.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now put everything together and define the binary genetic algorithm (`BGA`)
    function. This function takes the following arguments as input:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '`population`—The initial population of binary chromosomes'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_gen`—The number of generations the algorithm will run for'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_parents`—The number of parents to select for crossover'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crossover_prob`—The probability of crossover occurring between parents'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutation_prob`—The probability of mutation occurring at each gene'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_tqdm` (optional, default=`False`)—A Boolean flag to enable or disable
    a progress bar using the tqdm library'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the BGA function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Initialization
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: ② Run the genetic algorithm for num_gen generations using a for loop.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: ③ Calculate the fitness scores and sort the population based on the fitness
    values by calling the fitness_score function.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: ④ Update the best solution and best score.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Parent selection using the select_parent random method. You can replace this
    method with roulette_wheel_selection(population, num_parents).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Perform crossover on the selected parents.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Perform mutation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Return the best solution.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: This function returns the best solution, the best score, and the list of best
    scores at each generation.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can solve the ticket pricing problem, starting with generating an initial
    population with the following parameters:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running this code produced the following initial population:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now run the binary GA solver to get the solutions, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running this code produces the same solution obtained by the SciPy optimizer
    (see listing 2.4):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Rather than writing your own genetic algorithm code from scratch, you can take
    advantage of existing Python packages that offer GA implementations. Numerous
    open source Python libraries can help streamline the development process and save
    time. These libraries often include genetic operators, selection methods, and
    other features that make it easier to adapt a genetic algorithm to different optimization
    problems. Examples of these libraries include, but are not limited to, the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '*Pymoo* (Multi-objective Optimization in Python; [https://pymoo.org/algorithms/moo/nsga2.html](https://pymoo.org/algorithms/moo/nsga2.html))—A
    Python library for multi-objective optimization using evolutionary algorithms
    and other metaheuristic techniques. Pymoo offers a variety of algorithms such
    as GA, differential evolution, evolutionary strategy, non-dominated sorting genetic
    algorithm (NSGA-II), NSGA-III, and particle swarm optimization (PSO).'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DEAP* (Distributed Evolutionary Algorithms in Python; [https://deap.readthedocs.io/en/master/](https://deap.readthedocs.io/en/master/)—A
    Python library for implementing genetic algorithms in Python. It provides tools
    for defining, training, and evaluating genetic algorithm models, as well as for
    visualizing the optimization process. DEAP provides a variety of built-in genetic
    operators, including mutation, crossover, and selection, as well as support for
    custom operators tailored to specific optimization problems.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PyGAD* (Python Genetic Algorithm; [https://pygad.readthedocs.io/en/latest/](https://pygad.readthedocs.io/en/latest/))—A
    Python library for implementing genetic algorithms and differential evolution
    (DE) algorithms. PyGAD is suitable for both single-objective and multi-objective
    optimization tasks and can be used in a wide range of applications, including
    machine learning, and other problem domains.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*jMetalPy* ([https://github.com/jMetal/jMetalPy](https://github.com/jMetal/jMetalPy))—A
    Python library designed for developing and experimenting with metaheuristic algorithms
    for solving multi-objective optimization problems. It provides support for a variety
    of metaheuristic algorithms, including popular evolutionary algorithms like non-dominated
    sorting genetic algorithm (NSGA-II), NSGA-III, strength Pareto evolutionary algorithm
    (SPEA2), and multi-objective evolutionary algorithm based on decomposition (MOEA/D),
    as well as other optimization techniques such as simulated annealing and particle
    swarm optimization.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PyGMO* (Python Parallel Global Multi-objective Optimizer; [https://esa.github.io/pygmo/](https://esa.github.io/pygmo/))—A
    scientific library providing a large number of optimization problems and algorithms
    such as NSGA-II, SPEA2, non-dominated sorting particle swarm optimization (NS-PSO),
    and parameter adaptive differential evolution (PaDE). It uses the generalized
    island-model paradigm for the coarse grained parallelization of optimization algorithms
    and, therefore, allows users to develop asynchronous and distributed algorithms.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inspyred* (Bio-inspired Algorithms in Python; [https://pythonhosted.org/inspyred/](https://pythonhosted.org/inspyred/))—A
    library for creating and working with bio-inspired computational intelligence
    algorithms. It supports a variety of bio-inspired optimization algorithms, such
    as GA, evolution strategy, simulated annealing, differential evolution algorithm,
    estimation of distribution algorithm, Pareto archived evolution strategy (PAES),
    nondominated sorting genetic algorithm (NSGA-II), particle swarm optimization
    (PSO), and ant colony optimization (ACO).'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Platypus* ([https://platypus.readthedocs.io/en/latest/](https://platypus.readthedocs.io/en/latest/))—A
    framework for evolutionary computing in Python with a focus on multi-objective
    evolutionary algorithms (MOEAs). It provides tools for analyzing and visualizing
    algorithm performance and solution sets.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MEALPY* ([https://mealpy.readthedocs.io/en/latest/index.html](https://mealpy.readthedocs.io/en/latest/index.html))—A
    Python library that provides implementations for population-based meta-heuristic
    algorithms such as evolutionary computing algorithms, swarm inspired computing,
    physics inspired computing, human inspired computing, and biology inspired computing.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mlrose* (Machine Learning, Randomized Optimization and Search; [https://mlrose.readthedocs.io/en/stable/index.html](https://mlrose.readthedocs.io/en/stable/index.html))—An
    open source Python library that provides an implementation of standard GA to find
    the optimum for a given optimization problem.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pyevolve* ([https://pyevolve.sourceforge.net/](https://pyevolve.sourceforge.net/))—An
    open source Python library designed for working with genetic algorithms and other
    EC techniques'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*EasyGA* ([https://github.com/danielwilczak101/EasyGA](https://github.com/danielwilczak101/EasyGA))—A
    Python package designed to provide an easy-to-use GA. It’s worth noting that EasyGA
    and Pyevolve are simple libraries with less functionality and predefined problems
    than other libraries such as DEAP and Pymoo.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing A.3, available in the book’s GitHub repo, shows how to use some of these
    libraries.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will focus on utilizing the pymoo library, as it is a comprehensive
    framework that offers several optimization algorithms, visualization tools, and
    decision-making capabilities. This library is particularly well-suited for multi-objective
    optimization, which we’ll explore in more detail in the next chapter. Pymoo’s
    extensive features make it an excellent choice for implementing and analyzing
    genetic algorithms in various problem domains. Table 7.8 summarizes a comparative
    study of selected evolutionary computing frameworks, including pymoo [2].
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.8 Comparing selected evolutionary computing frameworks in Python
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '| Library | License | Pure Python | Visualization | Focus on multi-objective
    | Decision making |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| jMetalPy | MIT | Yes | Yes | Yes | No |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| PyGMO | GPL-3.0 | No (C++ with Python wrappers) | No | Yes | No |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| Platypus | GPL-3.0 | Yes | No | Yes | No |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| DEAP | LGPL-3.0 | Yes | No | No | No |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| inspyred | MIT | Yes | No | No | No |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| pymoo | Apache 2.0 | Yes | Yes | Yes | Yes |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: The following listing shows the steps for solving the ticket pricing problem
    using GA implemented in pymoo. We’ll start by importing various classes and functions
    from the pymoo library.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.3 Solving the ticket pricing problem using GA in pymoo
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `GA` class represents a single-objective genetic algorithm in the pymoo
    library. The `PointCrossover`, `SinglePointCrossover`, and `TwoPointCrossover`
    classes represent different crossover operators for combining the genetic material
    of parent chromosomes to create offspring. The `PolynomialMutation` class represents
    a mutation operator that introduces small, random changes in the chromosomes’
    genes. The `RoundingRepair` class represents a repair operator that rounds the
    variable values of the chromosomes, ensuring that they stay within a specific
    range or meet certain constraints. The `FloatRandomSampling` class represents
    a random sampling operator that generates an initial population of chromosomes
    with random float values. The `Problem` class is used to define optimization problems
    by specifying objectives, constraints, and variable bounds. Finally, the `minimize`
    function is used to perform the optimization process. It is worth noting that
    pymoo can only handle minimization problems, so if you need to use it with a maximization
    problem, you’ll have to convert the problem into a minimization problem, as discussed
    in section 7.3.1.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing the necessary classes and functions from the pymoo library,
    we can define the `TicketPrice` problem by subclassing the `Problem` class from
    the pymoo library as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Define the constructor for the TicketPrice class.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: ② Call the constructor of the parent Problem class.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define the evaluation function for the TicketPrice class.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: ④ Evaluate the value of the objective function using the given formula.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen, the constructor of the parent `Problem` class contains the
    following components with customized values applied to the ticket pricing problem:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '`n_var=1`—The number of decision variables in the problem, which is set to
    1, indicating a single decision variable for the ticket price.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_obj=1`—The number of objectives in the problem, which is set to 1, indicating
    a single-objective optimization problem.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_constr=0`—The number of constraints in the problem, which is set to 0, indicating
    that there are no constraints in this optimization problem.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xl=75.0`—The lower bound for the decision variable, which is set to 75.0.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xu=235.0`—The upper bound for the decision variable, which is set to 235.0.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vtype=float`—The variable type for the decision variables, which is set to
    float. Other types include `int` and `bool`.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can apply GA to solve the problem as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① Create an instance of the TicketPrice problem.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: ② Instantiate a GA object.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: ③ Run the solver.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: ④ Print the optimal ticket price.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Print the profit. Negate the objective value when printing the result.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'GA parameters include the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '`pop_size=100`—Set the population size to 100 individuals.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sampling=FloatRandomSampling()`—Use the `FloatRandomSampling` class to generate
    an initial population of chromosomes with random float values.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crossover=PointCrossover(prob=0.8, n_points=2)`—Use the `PointCrossover` class
    as the crossover operator with a probability of 0.8 and two crossover points.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutation=PolynomialMutation(prob=0.3, repair=RoundingRepair())`—Use the `PolynomialMutation`
    class as the mutation operator with a probability of 0.3, and apply the `RoundingRepair`
    class to repair mutated solutions if needed. The repair makes sure every solution
    that is evaluated is, in fact, feasible.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eliminate_duplicates=True`—Set the flag to eliminate duplicate individuals
    in the population.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res = minimize(...)`—Call the minimize function from pymoo to run the optimization
    process.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running listing 7.3 produces the following output:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So far, we’ve only scratched the surface of genetic algorithms. We’ll dive into
    the details, study different variants of genetic algorithms, and address more
    practical use cases in the next chapter.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Metaheuristic algorithms that are population-based, often referred to as P-metaheuristics,
    employ multiple agents to find an optimal or near-optimal global solution. These
    algorithms can be divided into two main categories, depending on their source
    of inspiration: evolutionary computation (EC) algorithms and swarm intelligence
    (SI) algorithms.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EC algorithms draw inspiration from the process of biological evolution. Examples
    of EC algorithms include the genetic algorithm (GA), differential evolution (DE),
    genetic programming (GP), evolutionary programming (EP), evolutionary strategies
    (ES), cultural algorithms (CA), and co-evolution (CoE).
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The genetic algorithm is the most widely used form of EC. It is an adaptive
    heuristic search method designed to mimic the natural system’s processes required
    for evolution, as outlined in Charles Darwin’s theory of evolution.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pseudo-random strategies, quasi-random strategies, sequential diversification,
    parallel diversification, and heuristics represent various initialization strategies
    for P-metaheuristics like genetic algorithms. Each strategy offers distinct levels
    of diversity, computational cost, and initial solution quality.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In genetic algorithms, the crossover and mutation operators play essential roles
    in searching the solution space and maintaining diversity within the population.
    The primary purpose of these operators is to handle the search dilemma by balancing
    exploration (searching new areas of the solution space) and exploitation (refining
    the existing solutions).
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A high crossover rate and a low mutation rate are recommended to balance exploration
    and exploitation. The high crossover rate facilitates the sharing of good traits
    between individuals, while the low mutation rate introduces small, random changes
    to maintain diversity and prevent premature convergence. This combination allows
    the algorithm to efficiently search the solution space and find high-quality solutions.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the generational model of genetic algorithms, the entire population is replaced,
    whereas in the steady-state model of genetic algorithms, a small fraction of the
    population is replaced. The steady-state model has lower computation costs than
    the generational model in genetic algorithms, but the generational model improves
    diversity preservation compared to the steady-state models.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wide range of open source Python libraries exist for working with genetic
    algorithms. One such library, pymoo (Multi-objective Optimization in Python),
    includes popular algorithms such as genetic algorithms, differential evolution,
    evolutionary strategies, the non-dominated sorting genetic algorithm (NSGA-II),
    NSGA-III, and particle swarm optimization (PSO).
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
