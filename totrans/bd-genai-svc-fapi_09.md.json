["```py\nGET ws://localhost:8000/generate/text/stream HTTP/1.1 ![1](assets/1.png) Origin: http://localhost:3000\nConnection: Upgrade ![2](assets/2.png) Host: http://localhost:8000\nUpgrade: websocket ![2](assets/2.png) Sec-WebSocket-Key: 8WnhvZTK66EVvhDG++RD0w== ![3](assets/3.png) Sec-WebSocket-Protocol: html-chat, text-chat ![4](assets/4.png) Sec-WebSocket-Version: 13\n```", "```py\n# stream.py\n\nimport asyncio\nimport os\nfrom typing import AsyncGenerator\nfrom openai import AsyncAzureOpenAI\n\nclass AzureOpenAIChatClient: ![1](assets/1.png)\n    def __init__(self):\n        self.aclient = AsyncAzureOpenAI(\n            api_key=os.environ[\"OPENAI_API_KEY\"],\n            api_version=os.environ[\"OPENAI_API_VERSION\"],\n            azure_endpoint=os.environ[\"OPENAI_API_ENDPOINT\"],\n            azure_deployment=os.environ[\"OPENAI_API_DEPLOYMENT\"],\n        )\n\n    async def chat_stream(\n        self, prompt: str, model: str = \"gpt-3.5-turbo\"\n    ) -> AsyncGenerator[str, None]: ![2](assets/2.png)\n        stream = await self.aclient.chat.completions.create(\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": prompt,\n                }\n            ],\n            model=model,\n            stream=True, ![3](assets/3.png)\n        )\n\n        async for chunk in stream:\n            yield f\"data: {chunk.choices[0].delta.content or ''}\\n\\n\" ![4](assets/4.png)\n            await asyncio.sleep(0.05) ![5](assets/5.png)\n\n        yield f\"data: [DONE]\\n\\n\"\n\nazure_chat_client = AzureOpenAIChatClient()\n```", "```py\n# main.py\n\nfrom fastapi.responses import StreamingResponse\nfrom stream import azure_chat_client\n\n...\n\n@app.get(\"/generate/text/stream\") ![1](assets/1.png)\nasync def serve_text_to_text_stream_controller(\n    prompt: str,\n) -> StreamingResponse:\n    return StreamingResponse( ![2](assets/2.png)\n        azure_chat_client.chat_stream(prompt), media_type=\"text/event-stream\"\n    )\n```", "```py\n{# pages/client-sse.html #} <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>SSE with EventSource API</title>\n</head>\n<body>\n<button id=\"streambtn\">Start Streaming</button>\n<label for=\"messageInput\">Enter your prompt:</label>\n<input type=\"text\" id=\"messageInput\" placeholder=\"Enter your prompt\"> ![1](assets/1.png)\n<div style=\"padding-top: 10px\" id=\"responseContainer\"></div> ![2](assets/2.png)\n\n<script>\n    let source;\n    const button = document.getElementById('streambtn');\n    const container = document.getElementById('container');\n    const input = document.getElementById('messageInput');\n\n    function resetForm(){\n        input.value = '';\n        container.textContent = '';\n    }\n\n    function handleOpen() {\n        console.log('Connection was opened');\n    }\n    function handleMessage(e){\n        if (e.data === '[DONE]') {\n            source.close();\n            console.log('Connection was closed');\n            return;\n        }\n\n        container.textContent += e.data;\n    }\n    function handleClose(e){\n        console.error(e);\n        source.close()\n    }\n\n    button.addEventListener('click', function() { ![3](assets/3.png)\n        const message = input.value;\n        const url = 'http://localhost:8000/generate/text/stream?prompt=' +\n            encodeURIComponent(message);\n        resetForm() ![4](assets/4.png)\n\n        source = new EventSource(url); ![5](assets/5.png)\n        source.addEventListener('open', handleOpen, false);\n        source.addEventListener('message', handleMessage, false);\n        source.addEventListener('error', handleClose, false); ![6](assets/6.png)\n    });\n\n</script>\n</body>\n</html>\n```", "```py\n# main.py\n\nfrom fastapi.staticfiles import StaticFiles\n\napp.mount(\"/pages\", StaticFiles(directory=\"pages\"), name=\"pages\") ![1](assets/1.png)\n```", "```py\n# main.py\n\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"], ![1](assets/1.png)\n)\n```", "```py\n$ docker run --runtime nvidia --gpus all \\ ![1](assets/1.png)\n    -v ~/.cache/huggingface:/root/.cache/huggingface \\ ![2](assets/2.png)\n    --env \"HUGGING_FACE_HUB_TOKEN=<secret>\" \\ ![3](assets/3.png)\n    -p 8080:8000 \\ ![4](assets/4.png)\n    --ipc=host \\ ![5](assets/5.png)\n    vllm/vllm-openai:latest \\ ![1](assets/1.png) ![6](assets/6.png)\n    --model mistralai/Mistral-7B-v0.1 ![7](assets/7.png)\n```", "```py\nimport asyncio\nfrom typing import AsyncGenerator\nfrom huggingface_hub import AsyncInferenceClient\n\nclient = AsyncInferenceClient(\"http://localhost:8080\")\n\nasync def chat_stream(prompt: str) -> AsyncGenerator[str, None]:\n    stream = await client.text_generation(prompt, stream=True)\n    async for token in stream:\n        yield token\n        await asyncio.sleep(0.05)\n```", "```py\n# main.py\n\nfrom typing import Annotated\nfrom fastapi import Body, FastAPI\nfrom fastapi.responses import StreamingResponse\nfrom stream import azure_chat_client\n\n@app.post(\"/generate/text/stream\")\nasync def serve_text_to_text_stream_controller(\n    prompt: Annotated[str, Body()]\n) -> StreamingResponse:\n    return StreamingResponse(\n        azure_chat_client.chat_stream(prompt), media_type=\"text/event-stream\"\n    )\n```", "```py\n{# pages/client-sse-post.html #} <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<title>SSE With Post Request</title>\n</head>\n<body>\n<button id=\"streambtn\">Start Streaming</button>\n<label for=\"messageInput\">Enter your prompt:</label>\n<input type=\"text\" id=\"messageInput\" placeholder=\"Enter message\">\n<div style=\"padding-top: 10px\" id=\"container\"></div>\n\n<script>\n    const button = document.getElementById('streambtn');\n    const container = document.getElementById('container');\n    const input = document.getElementById('messageInput');\n\n    function resetForm(){\n        input.value = '';\n        container.textContent = '';\n    }\n\n    async function stream(message){\n        const response = await fetch('http://localhost:8000/generate/text/stream', {\n            method: \"POST\",\n            cache: \"no-cache\",\n            keepalive: true,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"text/event-stream\",\n            },\n            body: JSON.stringify({\n                prompt: message, ![1](assets/1.png)\n            }),\n        });\n\n        const reader = response.body.getReader(); ![2](assets/2.png)\n        const decoder = new TextDecoder(); ![3](assets/3.png)\n\n        while (true) { ![4](assets/4.png)\n            const {value, done} = await reader.read();\n            if (done) break;\n            container.textContent += decoder.decode(value);\n        }\n    }\n\n    button.addEventListener('click', async function() { ![5](assets/5.png)\n        resetForm()\n        await stream(input.value)\n\n    });\n\n</script>\n</body>\n</html>\n```", "```py\n// pages/client-sse-post.html within <script> tag \nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function stream(\n    message,\n    maxRetries = 3,\n    initialDelay = 1000,\n    backoffFactor = 2,\n) {\n    let delay = initialDelay;\n    for (let attempt = 0; attempt < maxRetries; attempt++) { ![1](assets/1.png)\n        try { ![2](assets/2.png)\n            ... // Establish SSE connection here\n            return ![3](assets/3.png)\n        } catch (error) {\n            console.warn(`Failed to establish SSE connection: ${error}`);\n            console.log(\n                `Re-establishing connection - attempt number ${attempt + 1}`,\n            );\n            if (attempt < maxRetries - 1) {\n                await sleep(delay); ![4](assets/4.png)\n                delay *= backoffFactor; ![5](assets/5.png)\n            } else {\n                throw error ![6](assets/6.png)\n            }\n        }\n    }\n}\n```", "```py\n# stream.py\n\nfrom fastapi.websockets import WebSocket\n\nclass WSConnectionManager: ![1](assets/1.png)\n    def __init__(self) -> None:\n        self.active_connections: list[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket) -> None: ![2](assets/2.png)\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    async def disconnect(self, websocket: WebSocket) -> None: ![3](assets/3.png)\n        self.active_connections.remove(websocket)\n        await websocket.close()\n\n    @staticmethod\n    async def receive(websocket: WebSocket) -> str: ![4](assets/4.png)\n        return await websocket.receive_text()\n\n    @staticmethod\n    async def send(\n        message: str | bytes | list | dict, websocket: WebSocket\n    ) -> None: ![5](assets/5.png)\n        if isinstance(message, str):\n            await websocket.send_text(message)\n        elif isinstance(message, bytes):\n            await websocket.send_bytes(message)\n        else:\n            await websocket.send_json(message)\n\nws_manager = WSConnectionManager() ![6](assets/6.png)\n```", "```py\n# stream.py\n\nfrom fastapi.websockets import WebSocket\n\nclass WSConnectionManager:\n    ...\n    async def broadcast(self, message: str | bytes | list | dict) -> None:\n        for connection in self.active_connections:\n            await self.send(message, connection)\n```", "```py\n# stream.py\n\nimport asyncio\nfrom typing import AsyncGenerator\n\nclass AzureOpenAIChatClient:\n    def __init__(self):\n        self.aclient = ...\n\n    async def chat_stream(\n        self, prompt: str, mode: str = \"sse\", model: str = \"gpt-4o\"\n    ) -> AsyncGenerator[str, None]:\n        stream = ...  # OpenAI chat completion stream\n\n        async for chunk in stream:\n            if chunk.choices[0].delta.content is not None: ![1](assets/1.png)\n                yield (\n                    f\"data: {chunk.choices[0].delta.content}\\n\\n\"\n                    if mode == \"sse\"\n                    else chunk.choices[0].delta.content ![2](assets/2.png)\n                )\n                await asyncio.sleep(0.05)\n        if mode == \"sse\": ![2](assets/2.png)\n            yield f\"data: [DONE]\\n\\n\"\n```", "```py\n# main.py\n\nimport asyncio\nfrom loguru import logger\nfrom fastapi.websockets import WebSocket, WebSocketDisconnect\nfrom stream import ws_manager, azure_chat_client\n\n@app.websocket(\"/generate/text/streams\") ![1](assets/1.png)\nasync def websocket_endpoint(websocket: WebSocket) -> None:\n    logger.info(\"Connecting to client....\")\n    await ws_manager.connect(websocket) ![2](assets/2.png)\n    try: ![3](assets/3.png)\n        while True: ![4](assets/4.png)\n            prompt = await ws_manager.receive(websocket) ![5](assets/5.png)\n            async for chunk in azure_chat_client.chat_stream(prompt, \"ws\"):\n                await ws_manager.send(chunk, websocket) ![6](assets/6.png)\n                await asyncio.sleep(0.05) ![7](assets/7.png)\n    except WebSocketDisconnect: ![8](assets/8.png)\n        logger.info(\"Client disconnected\")\n    except Exception as e: ![9](assets/9.png)\n        logger.error(f\"Error with the WebSocket connection: {e}\")\n        await ws_manager.send(\"An internal server error has occurred\")\n    finally:\n        await ws_manager.disconnect(websocket) ![10](assets/10.png)\n```", "```py\n{# pages/client-ws.html #} <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>Stream with WebSocket</title>\n</head>\n<body>\n<button id=\"streambtn\">Start Streaming</button>\n<button id=\"closebtn\">Close Connection</button>\n<label for=\"messageInput\">Enter your prompt:</label>\n<input type=\"text\" id=\"messageInput\" placeholder=\"Enter message\">\n<div style=\"padding-top: 10px\" id=\"container\"></div>\n\n<script>\n    const streamButton = document.getElementById('streambtn');\n    const closeButton = document.getElementById('closebtn');\n    const container = document.getElementById('container');\n    const input = document.getElementById('messageInput');\n\n    let ws;\n    let retryCount = 0;\n    const maxRetries = 5;\n    let isError = false;\n\n    function sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    function connectWebSocket() {\n        ws = new WebSocket(\"ws://localhost:8000/generate/text/streams\"); ![1](assets/1.png)\n\n        ws.onopen = handleOpen;\n        ws.onmessage = handleMessage;\n        ws.onclose = handleClose;\n        ws.onerror = handleError; ![2](assets/2.png)\n    }\n\n    function handleOpen(){\n        console.log(\"WebSocket connection opened\");\n        retryCount = 0;\n        isError = false;\n    }\n\n    function handleMessage(event) {\n        container.textContent += event.data;\n    }\n\n    async function handleClose(){ ![3](assets/3.png)\n        console.log(\"WebSocket connection closed\");\n        if (isError && retryCount < maxRetries) {\n            console.warn(\"Retrying connection...\");\n            await sleep(Math.pow(2, retryCount) * 1000);\n            retryCount++;\n            connectWebSocket();\n        }\n        else if (isError) {\n            console.error(\"Max retries reached. Could not reconnect.\");\n        }\n    }\n\n    function handleError(error) {\n        console.error(\"WebSocket error:\", error);\n        isError = true;\n        ws.close();\n    }\n\n    function resetForm(){\n        input.value = '';\n        container.textContent = '';\n    }\n\n    streamButton.addEventListener('click', function() { ![4](assets/4.png)\n        const prompt = document.getElementById(\"messageInput\").value;\n        if (prompt && ws && ws.readyState === WebSocket.OPEN) {\n            ws.send(prompt); ![5](assets/5.png)\n        }\n        resetForm(); ![6](assets/6.png)\n    });\n\n    closeButton.addEventListener('click', function() { ![7](assets/7.png)\n        isError = false;\n        if (ws) {\n            ws.close();\n        }\n    });\n\n    connectWebSocket(); ![1](assets/1.png)\n</script>\n</body>\n</html>\n```"]