<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">4</span> </span><span class="chapter-title-text">APIs: The piping between our components</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header"><span class="CharOverride-1">This chapter covers</span></h3>
<ul>
<li class="readable-text" id="p2"><span class="CharOverride-2">An introduction to the FastAPI framework</span></li>
<li class="readable-text" id="p3"><span class="CharOverride-2">Documenting APIs using the OpenAPI standard</span></li>
<li class="readable-text" id="p4"><span class="CharOverride-2">Testing our APIs using Postman and Locust</span></li>
<li class="readable-text" id="p5"><span class="CharOverride-2">API management with WSO2</span></li>
</ul>
</div>
<div class="readable-text" id="p6">
<p>In this sprint, we work on another research spike where we explore designing and testing application program interfaces (APIs). An API is simply a way to interact with a software component. Regardless of whether we are dealing with microservices and distributed systems or using packages from <code>npm</code>/<code>pip</code>, we utilize APIs. </p>
</div>
<div class="readable-text" id="p7">
<h2 class="readable-text-h2"><span class="num-string">4.1</span> API-driven design</h2>
</div>
<div class="readable-text" id="p8">
<p>Generally, when we mention APIs in this book, we are talking about the REST (Representational State Transfer) API standard. However, there are other standards as well, such as GraphQL and the older SOAP (Simple Object Access Protocol). We may also come across message queuing, such as IBM Websphere MQ and RabbitMQ. Table 4.1 shows some pros and cons of the more common approaches to implementing APIs.</p>
</div>
<div class="browsable-container browsable-table-container" id="p9">
<h5 class="browsable-container-h5">Table 4.1 Pros and cons of different APIs</h5>
<table class="No-Table-Style _idGenTablePara-1" id="table001">
<colgroup>
<col class="_idGenTableRowColumn-1"/>
<col class="_idGenTableRowColumn-2"/>
<col class="_idGenTableRowColumn-2"/>
<col class="_idGenTableRowColumn-2"/>
</colgroup>
<tbody>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-1"/>
<td class="No-Table-Style CellOverride-2"><p class="_TableHead"><span class="CharOverride-3">REST</span></p></td>
<td class="No-Table-Style CellOverride-2"><p class="_TableHead"><span class="CharOverride-3">SOAP</span></p></td>
<td class="No-Table-Style CellOverride-3"><p class="_TableHead"><span class="CharOverride-3">GraphQL</span></p></td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-4">
<td class="No-Table-Style CellOverride-4"><p class="_TableBody">Pros</p></td>
<td class="No-Table-Style CellOverride-5"><p class="_TableBody">Simple; builds on standard HTTP methods</p><p class="_TableBody">Multiple data formats can be supported, although JSON is the most common.</p></td>
<td class="No-Table-Style CellOverride-5"><p class="_TableBody">Relies on XML-based messaging</p><p class="_TableBody">Enterprise-level security</p></td>
<td class="No-Table-Style CellOverride-6"><p class="_TableBody">Efficient</p><p class="_TableBody">Single endpoint</p><p class="_TableBody">Strongly typed</p></td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-4">
<td class="No-Table-Style CellOverride-4"><p class="_TableBody">Cons</p></td>
<td class="No-Table-Style CellOverride-5"><p class="_TableBody">Versioning and breaking changes can be complex to manage.</p><p class="_TableBody">The number of endpoints may become inconvenient.</p></td>
<td class="No-Table-Style CellOverride-5"><p class="_TableBody">Complex to implement</p><p class="_TableBody">Wordy XML-based messages</p></td>
<td class="No-Table-Style CellOverride-6"><p class="_TableBody">Steeper learning curve</p></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p10">
<p>APIs act as a contract parties agree to abide by. The consumer of the API agrees to abide by any terms of use and licensing agreements and follow any documentation and standards established by the provider. In turn, the API provider provides a stable and scalable endpoint to access. Subscriptions to APIs also provide tools to make costs, usage, and a Service Level Agreement (SLA) transparent.</p>
</div>
<div class="readable-text" id="p11">
<p>With the adoption of distributed computing, many developers and architects have become interested in API-driven design. Often, we can expect our software to be deployed in the cloud or in a containerized environment. In these cases, we want to make sure we consider APIs. As with most design objectives, we want to keep some of the following things in mind:</p>
</div>
<ul>
<li class="readable-text" id="p12"><em>Clear use case</em><em>s</em>—An API should not serve as a Swiss Army knife that can deal with customers, accounts, and transactions. Instead, the design should be kept simple, straightforward, and consistent.</li>
<li class="readable-text" id="p13"><em>Versionin</em><em>g</em>—Anticipate versioning and having to deprecate older API versions. Having to maintain multiple versions of an API can lead to increased technical debt with each change. Tools such as WSO2 API Manager and the Anypoint Platform by Mulesoft can help with versioning, governance, and many other tasks regarding APIs.</li>
<li class="readable-text" id="p14"><em>Documentatio</em><em>n</em>—Comprehensive up-to-date documentation ensures easy consumption of our API. Standards such as OpenAPI allow our APIs to produce documentation that can be made available online with tools such as Swagger and Redoc.</li>
<li class="readable-text" id="p15"><em>Performance and scalin</em><em>g</em>—Our APIs should be able to scale to larger datasets, which means that we may need to introduce paging for very large datasets. We also need to determine acceptable wait times for API requests and how to handle longer-running requests.</li>
<li class="readable-text" id="p16"><em>Security and validatio</em><em>n</em>—Remember that a UI that validates user input is only half the battle. We need to ensure that the server is validating input, as well to prevent hackers and bad actors from exploiting our APIs. </li>
<li class="readable-text" id="p17"><em>Monitoring and analytic</em><em>s</em>—Ensuring our APIs are functioning when accessed by end-users and have sufficient capacity can only be done with appropriate monitoring and logging. We may want to consider OpenTelemetry and tools such as Prometheus and Grafana to support the observability and monitoring of our APIs.</li>
</ul>
<div class="readable-text" id="p18">
<p>There are other considerations as well, and APIs is a topic whole books have been written about. At this point, we just want to provide you with enough knowledge to make you more proficient in your software development role. If you are interested in additional information on RESTful APIs, visit <a href="https://restfulapi.net/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/restfulapi.net/</span></a>. If you are looking for a deeper understanding of APIs and additional hands-on exercise, <em>The Design of Web APIs</em> (2019, Manning) by Arnaud Lauret is an excellent resource.</p>
</div>
<div class="readable-text" id="p19">
<h2 class="readable-text-h2"><span class="num-string">4.2</span> Our APIs</h2>
</div>
<div class="readable-text" id="p20">
<p>Before developing the endpoints for our APIs, we think about the tasks we need to perform. At this point, we won’t be dealing with many complicated tasks, but only upload files, view files, and view records. Table 4.2 shows what our APIs may look like. Note that <code>:fileId</code> and <code>:recordId</code> are placeholders for identifiers that will be returned by other queries.</p>
</div>
<div class="browsable-container browsable-table-container" id="p21">
<h5 class="browsable-container-h5">Table 4.2 API overview</h5>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col class="_idGenTableRowColumn-5"/>
<col class="_idGenTableRowColumn-6"/>
<col class="_idGenTableRowColumn-7"/>
</colgroup>
<tbody>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-1"> <p class="_TableHead"><span class="CharOverride-3">HTTP method</span></p> </td>
<td class="No-Table-Style CellOverride-2"> <p class="_TableHead"><span class="CharOverride-3">Uniform resource identifier</span></p> </td>
<td class="No-Table-Style CellOverride-3"> <p class="_TableHead"><span class="CharOverride-3">Description</span></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-8">
<td class="No-Table-Style CellOverride-7"> <p class="_TableBody"><code>POST</code></p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody"><code>/files</code></p> </td>
<td class="No-Table-Style CellOverride-9"> <p class="_TableBody">Uploads a file to the system</p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-8">
<td class="No-Table-Style CellOverride-10"> <p class="_TableBody"><code>GET</code></p> </td>
<td class="No-Table-Style CellOverride-11"> <p class="_TableBody"><code>/files</code></p> </td>
<td class="No-Table-Style CellOverride-12"> <p class="_TableBody">Returns a list of uploaded files</p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-8">
<td class="No-Table-Style CellOverride-10"> <p class="_TableBody"><code>GET</code></p> </td>
<td class="No-Table-Style CellOverride-11"> <p class="_TableBody"><code>/files/:fileId</code></p> </td>
<td class="No-Table-Style CellOverride-12"> <p class="_TableBody">Returns details on a specific file</p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-8">
<td class="No-Table-Style CellOverride-10"> <p class="_TableBody"><code>GET</code></p> </td>
<td class="No-Table-Style CellOverride-11"> <p class="_TableBody"><code>/files/:fileId/records</code></p> </td>
<td class="No-Table-Style CellOverride-12"> <p class="_TableBody">Returns records for a specific file</p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-8">
<td class="No-Table-Style CellOverride-13"> <p class="_TableBody"><code>GET</code></p> </td>
<td class="No-Table-Style CellOverride-14"> <p class="_TableBody"><code>/files/:fileId/records/:recordId</code></p> </td>
<td class="No-Table-Style CellOverride-15"> <p class="_TableBody">Returns details for a specific record</p> </td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p22">
<p>While the table provides a good overview of our APIs, it may be helpful to think in terms of the flow of these APIs and how to obtain these identifiers. Figure 4.1 shows the interaction between a user and the API.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p23">
<h5 class="callout-container-h5 readable-text-h5">PlantUML</h5>
</div>
<div class="readable-text" id="p24">
<p>PlantUML (<a href="https://plantuml.com/"><span class="Hyperlink">https://plantuml.com/</span></a>) is a fantastic tool for creating many kinds of UML diagrams such as sequence, use case, state diagrams, and more, as well as other diagrams for UI mockups, Gantt diagrams, and WBS diagrams.</p>
</div>
<div class="readable-text" id="p25">
<p>PlantUML is a great tool to use for many of these diagrams because it is a text-based interface. We can produce diagrams just by entering text into an editor! That means they are easy to update, easy to store in version control, and can be compared against previous versions. There are plugins available for our IDE as well, and we often use this tool from within VS Code. </p>
</div>
<div class="readable-text" id="p26">
<p>Throughout the book, we use diagrams produced with PlantUML.</p>
</div>
</div>
<div class="browsable-container figure-container" id="p27">
<img alt="A screenshot of a computer program  Description automatically generated" height="413" src="../Images/CH04_F01_Kardell.png" style="width: 100%; max-width: max-content;" width="631"/>
<h5 class="figure-container-h5"><span class="">Figure 4.1</span><span class=""> </span><span class="">Sequence diagram produced by PlantUML</span></h5>
</div>
<div class="readable-text" id="p28">
<p>Hopefully, you can better understand now how a user may employ these initial APIs. These APIs should provide us with a good starting point for the project as they meet the requirements regarding uploading and viewing data. We can expand on these APIs by including query parameters to help retrieve specific data. For example, we may want to select files by date/time or select all batch header records from a specific file.</p>
</div>
<div class="readable-text" id="p29">
<h2 class="readable-text-h2"><span class="num-string">4.3</span> Building our APIs with FastAPI</h2>
</div>
<div class="readable-text" id="p30">
<p>Previously, we built a simple health check API using FastAPI, but now we will examine FastAPI in more depth and start building our APIs to deal with ACH processing. Let’s take a look at building of our <code>GET</code> APIs first as they should be relatively simple to provide stubs for. In other words, we do not need to have a database yet. We can simply return a hardcoded value for now to make sure everything is working as expected. </p>
</div>
<div class="readable-text intended-text" id="p31">
<p>While this approach will give you some basic understanding of how FastAPI works, it does not mean that we won’t worry about topics such as pagination and asynchronous processing, which are required in a full-fledged production system to have a functional API. For now, keep in mind that returning large results such as thousands of ACH records not only takes time (resulting in the user waiting for the data), but presenting data on a UI becomes difficult. That is where the concept of allowing paging becomes useful. While UI components can do this with a large dataset, it will also become necessary to allow the API to handle requesting portions of the data. Likewise, uploading large ACH files may take time to process, and the user will be unsure whether the process was successful; furthermore, chances are the request will timeout from the user side. Using asynchronous processing, where a response is sent to let the user know the file was successfully uploaded and where further processing is done to load the file, becomes paramount. We will touch on this again in chapter 12.</p>
</div>
<div class="readable-text intended-text" id="p32">
<p>For now, we start with a simple project that has the following folder structure:</p>
</div>
<div class="browsable-container listing-container" id="p33">
<div class="code-area-container">
<pre class="code-area">ApiSample/
├─ docs/
├─ app/
│  ├─ routers/
│  │  ├─ files.py
│  ├─ __init__.py
│  ├─ main.py
├─ tests/</pre>
</div>
</div>
<div class="readable-text" id="p34">
<p>We make sure to install the following requirements for our IDE, which should be maintained in a requirements.txt like when using Docker. However, if we have simply dived in and started installing Python packages, then IDEs such as JetBrains Pycharm allow us to create a requirements.txt file based on the requirements for our project. In this sprint, we focus on gaining experience with APIs and FastAPI, so installing packages into the IDE works well for now:</p>
</div>
<ul>
<li class="readable-text" id="p35"><code>pip</code><code> </code><code>install</code><code> </code><code>fastapi</code></li>
<li class="readable-text" id="p36"><code>pip</code><code> </code><code>install</code><code> </code><code>pytest</code></li>
<li class="readable-text" id="p37"><code>pip</code><code> </code><code>install</code><code> </code><code>httpx</code></li>
</ul>
<div class="readable-text" id="p38">
<p>We keep the routers in a separate folder, which makes it easier to manage our application as it grows. We could also refer to the YAGNI principle and keep things simple by not using a router yet, but for time and space constraints, we are going to jump ahead slightly. The routers/files.py holds the API endpoints we will build in the upcoming sections. For now, we only focus on the basics, as shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p39">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.1<span class="CharOverride-7"> </span>Basic FastAPI router</h5>
<div class="code-area-container">
<pre class="code-area">from fastapi import APIRouter  #1

router = APIRouter()  #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Imports APIRouter from fastapi, needed to define URIs for the application</span>
<br/>#2 
     <span class="CharOverride-8">Creates a router that will be used to define specific URIs</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p40">
<p>We then have the main.py that will pull in the router. The next listing shows how the router is incorporated into the application.</p>
</div>
<div class="browsable-container listing-container" id="p41">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.2<span class="CharOverride-7"> </span>FastAPI entry point</h5>
<div class="code-area-container">
<pre class="code-area">from fastapi import FastAPI  #1
from .routers import files  

app = FastAPI() #2

app.include_router(files.router) #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Imports the fastapi class needed to create the application and our previously defined routes </span>
<br/>#2 
     <span class="CharOverride-8">Defines the application and assigns it to the app</span>
<br/>#3 
     <span class="CharOverride-8">Includes our routes </span>
<span class="CharOverride-8">in the application</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p42">
<p>With this basic structure, we can now look at adding some routes!</p>
</div>
<div class="readable-text" id="p43">
<h3 class="readable-text-h3"><span class="num-string">4.3.1</span> Retrieving files with GET /files</h3>
</div>
<div class="readable-text" id="p44">
<p>Our first route should return a list of files (and eventually some information from the file header record). For now, we are going to hardcode a response. Because we have already defined the router, we just need to add the following code.</p>
</div>
<div class="browsable-container listing-container" id="p45">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.3<span class="CharOverride-7"> </span>Our first API route</h5>
<div class="code-area-container">
<pre class="code-area">@router.get("/files/")  #1
async def read_files():  #2
    return [{"file": "File_1"}, {"file": "File_2"}] </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">A decorator that defines the route /files/</span>
<br/>#2 
     <span class="CharOverride-8">An asynchronous function that returns a hardcoded response for testing</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p46">
<p>Here we defined the route with <code>@router.get("/files")</code> and an asynchronous function called <code>read_files</code> that returns a hardcoded JSON array of files.</p>
</div>
<div class="readable-text intended-text" id="p47">
<p>To check whether this code works, let’s write a <code>pytest</code>,<code> </code>as shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p48">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.4<span class="CharOverride-7"> </span>Testing our first endpoint</h5>
<div class="code-area-container">
<pre class="code-area">from fastapi import FastAPI     #1
from fastapi.testclient import TestClient #1
from app.main import app  

client = TestClient(app)  #2

def test_read_files(): #3
    <span>response = client.get("/files") </span>#4
<span>    assert response.status_code == 200 </span>#5
<span>    assert response.json() == </span> #6
<span class="CharOverride-9">➥</span>[{"file": "File_1"}, {"file": "File_2"}] </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Necessary imports for our test</span>
<br/>#2 
     <span class="CharOverride-8">Defines the TestClient</span>
<br/>#3 
     <span class="CharOverride-8">Defines a test to validate the /files endpoint</span>
<br/>#4 
     <span class="CharOverride-8">Makes a request to </span>
<span class="CharOverride-8">the /files endpoint</span>
<br/>#5 
     <span class="CharOverride-8">Asserts the response code is 200 and that the response is as expected</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p49">
<p>Here we import <code>TestClient</code> and our app. Next, we define a client we can use to make requests. By calling the <code>get("/files"),</code> we make a <code>GET</code> request to the URL <code>/files</code>, and that should be a valid endpoint. We assert that we received the HTTP status of <code>200</code><span class="CharOverride-2">. Then we have our hardcoded JSON string. This should match whatever we were returning from the endpoint in main.py. Even if running this test worked flawlessly, we still might have doubts whether it is running or validating our data properly. This can sometimes be a common concern when we first start using unit tests. We can play around with changing the status code we are checking (make it a value other than </span><code>200</code><span class="CharOverride-2">), the JSON string, the endpoint from </span><code>"files"</code><span class="CharOverride-2">, or the request type from </span><code>get</code><span class="CharOverride-2">. Changing those values should cause the test to fail and verify that the test is validating our logic.</span><span class="CharOverride-2"/></p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p50">
<h5 class="callout-container-h5 readable-text-h5"><span class="CharOverride-2">Types of tests</span></h5>
</div>
<div class="readable-text" id="p51">
<p>Being able to run unit tests can be of great benefit to our development cycle. Unit tests give us a starting point to execute the code and go through the entire process—from start to finish. But what type of test is this: Is it a unit test, integration test, or something else?</p>
</div>
<div class="readable-text" id="p52">
<p>We hope that you agree with the statement that developers should be testing their code. Different systems, conditions, and code bases can make testing difficult, but they should be released without some sort of testing on our end only in extremely rare circumstances.</p>
</div>
<div class="readable-text" id="p53">
<p>In most cases, developers will be primarily concerned with <em>unit tests</em><span class="CharOverride-11">.</span> The following figure shows that unit testing makes up the base of the testing pyramid, and this is where we will spend a lot of time creating tests, especially if we are following a test-driven development approach.</p>
</div>
<div class="browsable-container figure-container" id="p54">
<img alt="" height="248" src="../Images/CH04_UN01_Kardell.png" style="width: 100%; max-width: max-content;" width="313"/>
<h5 class="figure-container-h5"><span class="CharOverride-10">A typical testing pyramid</span></h5>
</div>
<div class="readable-text" id="p55">
<p><em>Component testing</em> may be where the previous test fits. It typically isolates a component such as an API so that we can evaluate it in isolation, which may help us catch more of the edge cases with malformed requests or other exception conditions.</p>
</div>
<div class="readable-text" id="p56">
<p><em>Integration tests</em> typically test multiple components and involve more dependencies than unit or component testing. As such, they are primarily concerned with ensuring the components can work together.</p>
</div>
<div class="readable-text" id="p57">
<p><em>UI testing </em>is the next layer. It shouldn’t be surprising that validating the UI using automated tools to crawl our UI validating functionality is similar to a user working through various tasks within the application. </p>
</div>
<div class="readable-text" id="p58">
<p>At the top of the pyramid, we have <em>manual and exploratory testing</em>. This is where we (or the QA team) are trying to find ways to break the software or look for inconsistencies in the interface and behavior.</p>
</div>
<div class="readable-text" id="p59">
<p>We have just briefly touched on a few of the major testing categories here. There are additional types of testing and other ways to break it down, which we will cover later.</p>
</div>
<div class="readable-text" id="p60">
<p>One final thing to note is that the tests become less isolated, slower, and more fragile as we move up the pyramid. We use the term “fragile” to indicate that the test gets harder to automate and is more likely to break because of its continually changing nature.</p>
</div>
<div class="readable-text" id="p61">
<p>The test category is important only when it comes to the amount of setup and time it may take to get the test to work. Tests near the bottom of the pyramid are usually isolated and run quickly. So, at the moment, it is easy to run this test as a unit test because the API is returning a hardcoded value. Once we are further along and need to retrieve data from the database or other APIs, and components start coming into play, this test may not be appropriate to run as part of our development test suite but rather as part of a continuous integration and delivery (CI/CD) pipeline.</p>
</div>
<div class="readable-text" id="p62">
<p>While we believe it is useful to have these tests function as unit tests, the reality is we may want to work this as a BDD-style test since they could be considered higher-level tests. </p>
</div>
</div>
<div class="readable-text" id="p63">
<p>After ensuring that <code>pytest-bdd</code> is installed (<code>pip</code> <code>install</code> <code>pytest-bdd</code>), we create a <code>features</code> folder and a <code>step_defs</code> folder underneath our tests directory. Our folder structure for the tests folder should now look something like</p>
</div>
<div class="browsable-container listing-container" id="p64">
<div class="code-area-container">
<pre class="code-area">tests/
├─ features/
│  ├─ files.feature
├─ step_defs/
│  ├─ test_files_feature.py</pre>
</div>
</div>
<div class="readable-text" id="p65">
<p>The <code>files.feature</code> will store our scenarios so we can work with the <code>/files</code> endpoint. Remember that we are defining the feature and various scenarios in this file using a <code>Given/When/Then</code> format. The following listing is a simple example of ensuring the status code.</p>
</div>
<div class="browsable-container listing-container" id="p66">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.5<span class="CharOverride-7"> </span>Feature file for our BDD test</h5>
<div class="code-area-container">
<pre class="code-area">Feature: API /files

  Scenario: I get a 200 status code when we call /files
    When I make a GET request to the endpoint /files
    Then the status code should be 200</pre>
</div>
</div>
<div class="readable-text" id="p67">
<p>Next, to power the feature file, we create corresponding step definitions in our test_files_feature.py.</p>
</div>
<div class="browsable-container listing-container" id="p68">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.6<span class="CharOverride-7"> </span>Step definitions for our BDD test</h5>
<div class="code-area-container">
<pre class="code-area">import pytest    #1
from pytest_bdd import scenarios, when, then, parsers #1
from fastapi.testclient import TestClient #1
from app.main import app #1

client = TestClient(app)

scenarios("../features/files.feature") #2

@pytest.fixture #3
def api_response():  #3
    return {}  #3

@when(parsers.parse('I {http_request_type} the endpoint {endpoint}')) #4
def when_http_request_to_endpoint( #5
    <span>api_response, </span> #5
<span>    http_request_type, </span> #5
<span>    </span>endpoint #5
):  #5
    if http_request_type == "GET":  #5
        response = client.get(endpoint)  #5
    else:  #5
        raise NotImplementedError #5
    api_response["data"] = response #5


@then(parsers.parse("the status code should be {status_code:d}")) #6
def then_the_status_code_is(api_response, status_code): #7
    assert (  #8
        api_response["data"].status_code == status_code #8
    ), f"Expected {status_code}, but got  <br/>{when_http_request_to_endpoint.status_code}"  #8</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Imports what is needed for testing</span>
<br/>#2 
     <span class="CharOverride-8">Loads the feature we defined in listing 4.5</span>
<br/>#3 
     <span class="CharOverride-8">Creates a fixture to store responses from the API; the hash will be empty.</span>
<br/>#4 
     <span class="CharOverride-8">Decorates the function with “when” to handle the condition from our feature file. Note that the endpoint is pulled from the feature file and will be /files.</span>
<br/>#5 
     <span class="CharOverride-8">At the moment, we are only handling GET requests and will raise an exception for anything else. We will revist this line to add more functionality as needed. Notice how the response from the API is stored in our api_response fixture.</span>
<br/>#6 
     <span class="CharOverride-8">Decorates the function with “then” to handle the “then” phrase from our feature file. Note that the status_code which we specified in the feature file is substituted for status_code.</span>
<br/>#7 
     <span class="CharOverride-8">Checks whether the status code was what we expected, which the feature file specified should be 200</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p69">
<p>Here we loaded the <code>files.feature</code> and defined functions to handle the <code>when</code> and <code>then</code> of our feature file. In addition, we have a fixture to store the API response for use between the calls. Notice, that although we coded the <code>when</code> to accept multiple types of HTTP requests, we only support a <code>GET</code> request at this point. As we create a more robust API that incorporates <code>POST</code>, <code>PUT</code>, and <code>DELETE</code> requests, we will need to expand it, or we will receive a <code>NotImplementedError</code>.</p>
</div>
<div class="readable-text intended-text" id="p70">
<p>Again, we may want to experiment with the scenario of changing the <code>GET</code> to another request just to see the <code>NotImplementedError</code>, and then change the status code or endpoint to get a feeling for different scenarios we may run into when coding.</p>
</div>
<div class="readable-text" id="p71">
<h3 class="readable-text-h3"><span class="num-string">4.3.2</span> Adding a file with POST /files</h3>
</div>
<div class="readable-text" id="p72">
<p>We now expand our example with a <code>POST</code> request to the same <code>/files</code> endpoint. This approach could potentially be used to upload our ACH file. Since we have an existing endpoint and tests established, let’s look at how we might work on this task from a more behavior-driven development approach. When working with a <code>POST</code> request we usually see a <code>201</code> <code>status</code> code, which means “created.” Since we are uploading a file and expecting it to be stored on the server, a <code>201</code> <code>CREATED</code> response should work for us. Thus, we can update our feature file with the scenario shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p73">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.7<span class="CharOverride-7"> </span>BDD test for our <code>POST</code> request</h5>
<div class="code-area-container">
<pre class="code-area">  Scenario: I get a 201 status code when we post to /files #1
    When I make a POST request to the endpoint /files #2
    Then the status code should be 201 #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">We are reusing the same feature file here, so we do not need to adjust any of the “when” or “then” decorators.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p74">
<p>When we run this test, we should first receive the <code>NotImplementedError</code> since we have not handled our client making a <code>POST</code> request, which we address now with the following code.</p>
</div>
<div class="browsable-container listing-container" id="p75">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.8<span class="CharOverride-7"> </span>Updating our steps to support the <code>POST</code> request</h5>
<div class="code-area-container">
<pre class="code-area">    if http_request_type == "GET": #1
        response = client.get(endpoint) 
    elif http_request_type == "POST": #2
        response = client.post(endpoint, json={"file": "File_4"}) 
    else: #3
        raise NotImplementedError
    api_response["data"] = response</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Handling of the previous request remains the same.</span>
<br/>#2 
     <span class="CharOverride-8">We now add a way to </span>
<span class="CharOverride-8">handle POST requests.</span>
<br/>#3 
     <span class="CharOverride-8">Continues to alert developers when they try to do something we have not yet coded for</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p76">
<p>Now that we are making a <code>POST</code> request, we should see an error returned from our server because we have not actually handled a <code>POST</code> request. Note that in the previous code, we have a hardcoded post value being used for the request. Eventually, we will update the test to make this dynamic, but for now, we just want to get the basic setup. Running our test again results in the test failing because we receive a <code>405</code> <code>METHOD</code> <code>NOT ALLOWED</code> status: </p>
</div>
<div class="browsable-container listing-container" id="p77">
<div class="code-area-container">
<pre class="code-area">Expected :201
Actual   :405</pre>
</div>
</div>
<div class="readable-text" id="p78">
<p>This makes perfect sense because we have not actually coded the server to handle our <code>POST</code> request. Let’s jump over to the <code>app/routers/files.py</code> and implement it (feel free to give it a shot before moving on).</p>
</div>
<div class="browsable-container listing-container" id="p79">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.9<span class="CharOverride-7"> </span>Defining our <code>POST</code> endpoint</h5>
<div class="code-area-container">
<pre class="code-area">from fastapi import APIRouter, Request #1
... #2
@router.post("/files/") #3
async def create_file(request: Request):  #3
    return {"file": "File_3"}  #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Updates the import to include the Request object</span>
<br/>#2 
     <span class="CharOverride-8">Previous endpoint implementation</span>
<br/>#3 
     <span class="CharOverride-8">Creates a function decorated with the POST verb and the URI, which is going to return a hardcoded value for now</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p80">
<p>Rerunning the test still fails, but this time because we are returning a <code>200</code> code.</p>
</div>
<div class="browsable-container listing-container" id="p81">
<div class="code-area-container">
<pre class="code-area">Expected :201
Actual   :200</pre>
</div>
</div>
<div class="readable-text" id="p82">
<p>This is technically fine since we have not created anything. However, let’s look at how we can update the status code because we will be creating data in the future. We update our files.py to include an import of status and update the <code>@router.post</code> as shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p83">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.10<span class="CharOverride-7"> </span>Supporting the <code>201</code> <code>status</code></h5>
<div class="code-area-container">
<pre class="code-area">from fastapi import APIRouter, Request, status #1
… #2
@router.post("/files/", status_code=status.HTTP_201_CREATED) #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">We import that status object from fastapi.</span>
<br/>#2 
     <span class="CharOverride-8">Previous code</span>
<br/>#3 
     <span class="CharOverride-8">We update the decorator to specify status_code along with a 20</span>
<span class="CharOverride-14">1</span>
<span class="CharOverride-8">.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p84">
<p>Setting the <code>status_code</code> will return the <code>201</code> for all cases, and we can now rerun our test and see that it passes. Note that setting the status code this way will cause this endpoint to always return a <code>201</code>. Later, as we expand our APIs, we will explore other ways of setting that status code so that it allows us to have finer control over them. This finer control will allow us to specify additional status codes when errors are encountered in our APIs.</p>
</div>
<div class="readable-text" id="p85">
<h3 class="readable-text-h3"><span class="num-string">4.3.3</span> Finishing the rest of the APIs</h3>
</div>
<div class="readable-text" id="p86">
<p>In the previous section, we created two APIs to support getting a hardcoded list of files and posting a file. You should have enough knowledge of the basics to create the remaining endpoints and unit tests on your own. Take a few minutes to create some unit tests for the remaining endpoints and then code up the remaining APIs to get those tests to pass.</p>
</div>
<div class="readable-text" id="p87">
<h2 class="readable-text-h2"><span class="num-string">4.4</span> Adding our API to Docker</h2>
</div>
<div class="readable-text" id="p88">
<p>Fantastic! Now that we have built our endpoints, we can run these APIs in a Docker container. We gained a lot of experience with Docker in chapter 2, so we can use that here. Essentially, we just need the API container from the previous chapter updated with the code we did here. Let’s see how we can get this code up and running in Docker.</p>
</div>
<div class="readable-text" id="p89">
<h3 class="readable-text-h3"><span class="num-string">4.4.1</span> Preparing the project</h3>
</div>
<div class="readable-text" id="p90">
<p>We have tested our code and should feel comfortable deploying it. Having faith in our suite of tests is needed for continuous integration and delivery. If you are not comfortable with deploying code after it passes all your tests, ask yourself why. Then figure out what additional steps and safeguards you need. We may need additional tests to cover edge cases, load testing, better coverage, static code analysis, and similar. The idea of automated tests is to help improve software delivery time and quality. </p>
</div>
<div class="readable-text intended-text" id="p91">
<p>So, we should be ready to deploy the code. However, we were previously using Uvicorn to run the FastAPI application. Remember that Uvicorn is ASGI (Asynchronous Server Gateway Interface) compliant and goes hand in hand with FastAPI. We need to include it in our current project for completeness’ sake. By installing it in our project, we will be able to generate a list of requirements for the project. So, ensure it is installed by using <code>pip</code> <code>install</code> <code>uvicorn</code>.</p>
</div>
<div class="readable-text intended-text" id="p92">
<p>After adding that additional dependency, we want to create a list of requirements that will be installed on the container. Remember that we had previously tried to keep the size of our Docker images to a minimum; furthermore, we should never only assume that a required package for our project exists on the server. Some IDEs will provide options to generate and manage the requirements.txt (the standard naming convention for Python requirements). However, if our IDE does not, we can always generate it from the command line with <code>pip</code> <code>freeze</code> <code>&gt;</code> <code>requirements.txt</code>. Once we do that, we can review the requirements to ensure we have our desired packages. For instance, we may want to ensure that <code>uvicorn</code> and <code>fastapi</code> are present. Note that we may see additional requirements because of other dependencies we have installed.</p>
</div>
<div class="readable-text intended-text" id="p93">
<p>With the requirements.txt and application folder in hand, we should have everything we need to run this in Docker.</p>
</div>
<div class="readable-text" id="p94">
<h3 class="readable-text-h3"><span class="num-string">4.4.2</span> Docker setup</h3>
</div>
<div class="readable-text" id="p95">
<p>Using our previous Docker experience (we could just copy a previous setup we have or start from scratch), we end up with a folder structure similar to</p>
</div>
<div class="browsable-container listing-container" id="p96">
<div class="code-area-container">
<pre class="code-area">api/
├─ app/
├─ Dockerfile
├─ requirements.txt
docker-compose.yml</pre>
</div>
</div>
<div class="readable-text" id="p97">
<p>where the app folder will contain our application code. At the moment, we only need a few source files: main.py, files.py, and the associated __init__.py. Although it is quite possible there may be additional files present specific to the IDE, there is no need to copy those over.</p>
</div>
<div class="readable-text intended-text" id="p98">
<p>The Dockerfile is where all the heavy lifting comes into play, but since our structure is the same, we do not need to change anything.</p>
</div>
<div class="browsable-container listing-container" id="p99">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.11<span class="CharOverride-7"> </span>Our Dockerfile</h5>
<div class="code-area-container">
<pre class="code-area">FROM python:alpine #1

WORKDIR /code #2

COPY ./requirements.txt /code/requirements.txt #3

RUN apk -U upgrade   #4
RUN apk add --no-cache libpq-dev python3-dev gcc musl-dev
RUN pip install --upgrade pip #5#6
RUN pip install --no-cache-dir --upgrade -r requirements.txt

COPY ./app /code/app #7

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"] #8</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Uses the alpine version of our Python image, so the size of the image is reduced</span>
<br/>#2 
     <span class="CharOverride-8">Ensures that we set the working directory for the container</span>
<br/>#3 
     <span class="CharOverride-8">Copies the requirements to the image</span>
<br/>#4 
     <span class="CharOverride-8">Updates the image and adds our additional dependencies</span>
<br/>#5 
     <span class="CharOverride-8"> </span>
<span class="CharOverride-8">Updates pip and installs the requirements</span>
<br/>#6 
     <span class="CharOverride-8"> </span>
<br/>#7 
     <span class="CharOverride-8">Copies the application code over to the image</span>
<br/>#8 
     <span class="CharOverride-8">Starts uvicorn using our application and binding it to port 8000</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p100">
<p>Next, we want the docker-compose.yml file to manage the building of the service for us. We will only have a single service at this point:</p>
</div>
<div class="browsable-container listing-container" id="p101">
<div class="code-area-container">
<pre class="code-area">services:
  api:
    build: 
      context: ./api
      dockerfile: Dockerfile  
    ports:
      - 8000:8000</pre>
</div>
</div>
<div class="readable-text" id="p102">
<p>Once these are in place, we should be able to run the usual <code>docker-compose</code> <code>build</code> and <code>docker-compose up</code> commands to start our container. After navigating our browser over to http://localhost:8000/files/, we should see the hardcoded value returned. In our case, it is <code>[{"file":"File_1"},{"file":"File_2"}]</code>.</p>
</div>
<div class="readable-text" id="p103">
<h2 class="readable-text-h2"><span class="num-string">4.5</span> Documenting our API</h2>
</div>
<div class="readable-text" id="p104">
<p>Great! We are moving right along. While most of our API is hardcoded, we will continue to refine it as we move forward. However, the hardcoded values are only a part of what makes our API unusable. Our main problem is that nobody knows about it, and if they knew about it, how would they use it? We need documentation, and OpenAPI (<a href="https://www.openapis.org/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/www.openapis.org/</span></a>) comes to our rescue. This is a standard that allows us to create interactive documentation, and others to discover how the API works and how it generates client code and server code, among other things. </p>
</div>
<div class="readable-text intended-text" id="p105">
<p>Remember API-driven design from the beginning of the chapter? Well, it is possible to give an OpenAPI specification to generate not only client code that would consume that API, but also the beginnings of the server-side code that will process those requests. With our Docker container up and running, we should have support out of the box for two flavors of documentation based on the OpenAPI specification. We will cover both documentation frameworks in the following sections.</p>
</div>
<div class="readable-text" id="p106">
<h3 class="readable-text-h3"><span class="num-string">4.5.1</span> Swagger</h3>
</div>
<div class="readable-text" id="p107">
<p>Swagger is a set of tools for implementing the OpenAPI definition, but for historical reasons, many people may still refer to the OpenAPI definition as a Swagger specification, Swagger definition, or just Swagger. One of the most useful tools that you will likely find yourself using is Swagger Editor (<a href="https://editor.swagger.io/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/editor.swagger.io/</span></a>), which provides a side-by-side view of the OpenAPI definition and the resulting output. We can browse the Swagger documentation generated by FastAPI by navigating over to http://localhost:8000/docs. From there, we can view the documentation and experiment with the API. In this case, though, we want to click the link that should take us to http://localhost:8000/openapi.json and display the OpenAPI JSON. We can save or just copy and paste it into the online Swagger Editor. Figure 4.2 is a sample screenshot of what we see.</p>
</div>
<div class="browsable-container figure-container" id="p108">
<img alt="A screenshot of a computer  Description automatically generated" height="461" src="../Images/CH04_F02_Kardell.png" style="width: 100%; max-width: max-content;" width="676"/>
<h5 class="figure-container-h5"><span class="">Figure 4.2</span><span class=""> </span><span class="">Online Swagger Editor</span></h5>
</div>
<div class="readable-text" id="p109">
<p>You can play around with editing the API to gain a better understanding. Note that the online editor will prompt us to convert the JSON to YAML. We do not have to do this, but it does make it a little easier to edit in place.</p>
</div>
<div class="readable-text intended-text" id="p110">
<p>The FastAPI framework supports several ways to help customize this documentation further, and we will be looking at that later on.</p>
</div>
<div class="readable-text" id="p111">
<h3 class="readable-text-h3"><span class="num-string">4.5.2</span> Redoc</h3>
</div>
<div class="readable-text" id="p112">
<p>FastAPI also supports Redoc, a free and open source tool for creating documentation. It provides a responsive three-panel view that has become popular, especially when working with larger APIs. Again, FastAPI provides this documentation out of the box, and we can see it by going to http://localhost:8000/redoc. Figure 4.3 shows our sample API documentation.</p>
</div>
<div class="browsable-container figure-container" id="p113">
<img alt="A screenshot of a computer  Description automatically generated" height="463" src="../Images/CH04_F03_Kardell.png" style="width: 100%; max-width: max-content;" width="775"/>
<h5 class="figure-container-h5"><span class="">Figure 4.3</span><span class=""> </span><span class="">FastAPI documentation with Redoc</span></h5>
</div>
<div class="readable-text" id="p114">
<p>Stripe, a popular payment service uses a similar three-panel view for their APIs. However, they created a tool called Markdoc (<a href="https://markdoc.dev/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/markdoc.dev/</span></a>) that helps generate their documentation. There are more tools for handling API documentation and documentation in general. Futuristic FinTech likely already provides multiple tools for this purpose, so we want to follow our company’s current standards and suggest new tools as needed.</p>
</div>
<div class="readable-text" id="p115">
<h3 class="readable-text-h3"><span class="num-string">4.5.3</span> What is so great about API documentation?</h3>
</div>
<div class="readable-text" id="p116">
<p>Documentation is one of those things that can be a struggle to get right, which is why the ability of FastAPI to provide us with OpenAPI documentation is so fantastic. Why? Because we can address one of the main documentation pain points, which is that it becomes stale quickly. With FastAPI, we can decorate our functions so that they generate the documentation, meaning we are less likely to be out of sync between what the documentation shows and what the code is doing.</p>
</div>
<div class="readable-text intended-text" id="p117">
<p>That is not all though. We really only touched on the basics of what is available. In addition to being able to interactively see the APIs and try them out, here are some of the other cool features available:</p>
</div>
<ul>
<li class="readable-text" id="p118">Providing contact information in the form of URL or email addresses that end users can use</li>
<li class="readable-text" id="p119">Licensing information about your APIs</li>
<li class="readable-text" id="p120">Pointing to different servers (e.g., a test server, sandbox, or production)</li>
<li class="readable-text" id="p121">Providing examples of requests/responses</li>
<li class="readable-text" id="p122">Generating server-side code to handle requests to the APIs</li>
<li class="readable-text" id="p123">Generating client-side code to interact with the APIs</li>
</ul>
<div class="readable-text" id="p124">
<p>Those are just some interesting features of designing APIs that conform to the OpenAPI specification. To learn more, check out <em>Designing APIs with Swagger and OpenAPI</em> (2022, Manning) by Joshua S. Ponelat and Lukas L. Rosenstock.</p>
</div>
<div class="readable-text" id="p125">
<h2 class="readable-text-h2"><span class="num-string">4.6</span> Managing our APIs</h2>
</div>
<div class="readable-text" id="p126">
<p>At this point, our API is small, consisting of a single <code>POST</code> and four <code>GET</code> statements. As our API grows, we need to have a strategy in place to manage it. This is best determined early as once APIs are in production and used by clients, it becomes more difficult to get a handle on the situation. Earlier, we mentioned the challenges of managing APIs such as versioning, documentation, monitoring, and so forth. We introduce the use of API management software so that you have some knowledge of its capabilities. We use API management as an umbrella term to cover the components that are found in the tool.</p>
</div>
<div class="readable-text intended-text" id="p127">
<p>We will incorporate an API Manager by WSO2 (<a href="https://wso2.com/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/wso2.com/</span></a>) into our solution just to highlight some of the benefits of using an API manager. There are many API management solutions, but we have worked directly with WSO2 and Mulesoft Anypoint (<a href="https://mng.bz/4a2V"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/mng.bz/4a2V</span></a>) in the FinTech industry. </p>
</div>
<div class="readable-text intended-text" id="p128">
<p>The WSO2 solution was easy to integrate into our solution. In addition, the documentation and tutorials for WSO2 are highly informative. As mentioned before, the use of Docker makes switching out components easy. Feel free to work on integrating other API managers into your solution that may better match your environment. The underlying mechanics and benefits from working with an API manager should be the same across the board.</p>
</div>
<div class="readable-text" id="p129">
<h3 class="readable-text-h3"><span class="num-string">4.6.1</span> Benefits of API management</h3>
</div>
<div class="readable-text" id="p130">
<p>API managers can provide a more centralized approach to managing your APIs. If your business has multiple applications, they are likely to run on different servers, require different authentication, and expose multiple points to the outside world from a networking perspective. API managers provide a way to centralize your API management. They offer features that help monetize APIs, protect against potential attacks with rate limiting (which can also be used for monetization by supplying different tiers), and provide authentication/authorization. </p>
</div>
<div class="readable-text intended-text" id="p131">
<p>Another aspect of managing APIs in larger corporations is providing a central place for our users to access. If we have distinct services and business units in our company, they more than likely have different servers handling their APIs, yet want to provide a single experience to their users. We can have all the APIs sent to a single endpoint, and then the API manager can direct the request to the appropriate server in your network. </p>
</div>
<div class="readable-text intended-text" id="p132">
<p>Once our requests are flowing through a centralized location, we can provide additional benefits to our users. One of them is a common interface to view and manage APIs as an end-user. If you have experience with APIs such as Google APIs, you should be aware that they offer a console to subscribe to various APIs. Sometimes, as companies grow and acquire other companies or merge, multiple products can be listed under the same company but provide a disjointed experience. By using an API manager, customers can view all your API offerings in one location.</p>
</div>
<div class="readable-text intended-text" id="p133">
<p>In addition to a better user experience, API managers offer increased analytics for our APIs. We can find out the number of calls, which API versions are in use, and a plethora of other insights. These analytics can lead to additional benefits such as rate limiting, load balancing, and monetization. Many APIs offer a pay-as-we-play model, where we are charged by API usage. API managers help facilitate that monetization process.</p>
</div>
<div class="readable-text intended-text" id="p134">
<p>Finally, lifecycle management is another benefit of using a third-party tool such as WSO2. Having a tool that helps enforce good lifecycle management practices provides a better experience for your customers and developers. We can see the distinct phases of an API and move APIs between different states. As shown in figure 4.4, we have an API that is currently in a published state, with options to bring it back to a created or deprecated state.</p>
</div>
<div class="readable-text" id="p135">
<h3 class="readable-text-h3"><span class="num-string">4.6.2</span> Adding WSO2 API manager to our project</h3>
</div>
<div class="readable-text" id="p136">
<p>First, we add WSO2 to our Docker setup, create a new folder named wso2, and place the following Dockerfile there:</p>
</div>
<div class="browsable-container listing-container" id="p137">
<div class="code-area-container">
<pre class="code-area">FROM wso2/wso2am:latest</pre>
</div>
</div>
<div class="readable-text" id="p138">
<p>There is not much to our Dockerfile, but for consistency, we are sticking with the same layout as for previous setups. The real work happens in our docker-compose.yml file where we added the WSO2 service:</p>
</div>
<div class="browsable-container listing-container" id="p139">
<div class="code-area-container">
<pre class="code-area">  wso2:
    build: 
      context: ./wso2
      dockerfile: Dockerfile  
    ports:
      - 9443:9443 # Management Console
      - 8243:8243 # HTTPS Requests
      - 8280:8280 # HTTP Requests</pre>
</div>
</div>
<div class="readable-text" id="p140">
<p><code>port</code> <code>9443</code> is the management console where we will be doing most of our work, and the other ports (8243/8280) are the default ports that we ensure are exposed for their respective request types. Once we complete the usual <code>docker-compose</code> <code>build</code> and <code>docker-compose</code> <code>up</code> commands, we should be able to log in with the default username and password of <code>admin/admin</code>.</p>
</div>
<div class="browsable-container figure-container" id="p141">
<img alt="A screenshot of a computer  Description automatically generated" height="438" src="../Images/CH04_F04_Kardell.png" style="width: 100%; max-width: max-content;" width="858"/>
<h5 class="figure-container-h5"><span class="">Figure 4.4</span><span class=""> </span><span class="">Lifecycle management by WSO2</span></h5>
</div>
<div class="readable-text" id="p142">
<h3 class="readable-text-h3"><span class="num-string">4.6.3</span> OpenAPI Version</h3>
</div>
<div class="readable-text" id="p143">
<p>One problem that we encountered while defining our API to WSO2 was <code>OpenAPI</code> <code>content</code> <code>validation</code> <code>failed!</code> We loaded our OpenAPI specification into the online Swagger Editor and received the error <code>Structural</code> <code>error</code> <code>at</code> <code>openapi</code> <code>should</code> <code>match pattern "^3\.0\.\d(-.+)?$"</code> <code>pattern:</code> <code>^3\.0\.\d(-.+)?$</code>.</p>
</div>
<div class="readable-text intended-text" id="p144">
<p>The online Swagger Editor provided more information, and while it may be a little cryptic for those having no experience with regular expressions, it pointed to the version number being incorrect. It seems that both our Docker image for WSO2 and the Swagger Editor do not currently support the latest version, but our FastAPI container does. To be sure we are using the correct version, we can double-check the OpenAPI site.</p>
</div>
<div class="readable-text intended-text" id="p145">
<p>ChatGPT was aware of the latest version, and when we posted the specification and asked it “Is this a valid OpenAPI specification?” we received the following response:</p>
</div>
<div class="callout-container sidebar-container prompt-response-sidebar">
<div class="readable-text" id="p146">
<p><strong class="response-head-image"><img alt="image" height="undefined" src="../Images/Response-Chatgpt.png" width="undefined"/></strong> The OpenAPI specification you have posted is quite extensive, and at a glance, it seems to be structured correctly according to the OpenAPI 3.1.0 specifications. However, there are several nuances and small details in such a spec that need to be right for it to be valid. Here are some key points and common issues to check in a detailed spec like this.</p>
</div>
</div>
<div class="readable-text" id="p147">
<p>Out of curiosity, we also tried to type in an invalid OpenAPI version (a much higher number), and ChatGPT said that it was not valid.</p>
</div>
<div class="readable-text intended-text" id="p148">
<p>We could go about tackling this problem in a few ways. It might be that there is an updated version of WSO2 that supports version 3.1.0. However, this may not always be practical or quick in a production environment. We could look to downgrade FastAPI back to a previous version, but let’s assume there is functionality or bug fixes we need in the current version. In this case, we can update our API to report back the version of 3.0.0. We could also just manually update the generated document before uploading it to WSO2. However, there is also an option from within WSO2 to go directly to a URL, and we want to be able to employ that.</p>
</div>
<div class="readable-text intended-text" id="p149">
<p>We update our main.py, adding the following.</p>
</div>
<div class="browsable-container listing-container" id="p150">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.12<span class="CharOverride-7"> </span>Adjusting the OpenAPI version</h5>
<div class="code-area-container">
<pre class="code-area">from fastapi.openapi.utils import get_openapi #1
… 
def custom_openapi(): #2
    if app.openapi_schema: 
        return app.openapi_schema
    openapi_schema = get_openapi(  #3
        title="File API",  #3
        version="0.0.1",  #3
        routes=app.routes,  #3
        openapi_version="3.0.0" #4
    <span>)</span>
<span>    app.openapi_schema = openapi_schema</span>
<span>    return app.openapi_schema</span>

app.openapi = custom_openapi</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Imports the get_openapi to allow us to customize the OpenAPI documentation; our previous code remains the same.</span>
<br/>#2 
     <span class="CharOverride-8">Defines a custom method</span>
<br/>#3 
     <span class="CharOverride-8">These fields are required when calling get_openapi.</span>
<br/>#4 
     <span class="CharOverride-8">This is how we updated the OpenAPI version, and we had to fix a problem with WSO2 API manager.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p151">
<p>With that in place, if we rebuild and restart Docker, we should see <code>"openapi":"3.0.0"</code> instead of <code>"openapi":"3.1.0"</code> when viewing the JSON. We should also see the error resolved when viewed in the online Swagger Editor. Now, we can move on to creating the API in WSO2.</p>
</div>
<div class="readable-text" id="p152">
<h3 class="readable-text-h3"><span class="num-string">4.6.4</span> Create an API in WSO2</h3>
</div>
<div class="readable-text" id="p153">
<p>We can create an API by going through the following steps:</p>
</div>
<ol>
<li class="readable-text" id="p154">Click the Create API button.</li>
<li class="readable-text" id="p155">Under REST API, click Import Open API. </li>
<li class="readable-text" id="p156">For the OpenAPI URL, enter http://api:8000/openapi.json. We should see that the URL is validated by the system.</li>
<li class="readable-text buletless-item" id="p157">Enter a name (this is what the API will be known as in WSO2): 
    <ol style="list-style: lower-alpha">
<li>The context is a way to distinguish the API URL in WSO2.</li>
<li>The version of the API. </li>
<li>The endpoint should be http://api:8000.</li>
</ol></li>
<li class="readable-text" id="p158">Click Create.</li>
<li class="readable-text" id="p159">On the left pane, under Deploy, click Deployments.</li>
<li class="readable-text" id="p160">Click Deploy.</li>
<li class="readable-text buletless-item" id="p161">On the left pane, under Test, click Try Out: 
    <ol style="list-style: lower-alpha">
<li>We will be directed to a similar Swagger Doc screen we saw earlier.</li>
<li>Click Generate Key.</li>
</ol></li>
<li class="readable-text" id="p162">Try out your APIs.</li>
</ol>
<div class="readable-text" id="p163">
<p>With this API in place, the thing to notice is that we no longer make a request directly to our backend of http://api:8000. Instead, we are going to make requests to https://localhost:8243/sample/0.0.1/files, which is the API manager, the context we chose, version, and our API. If we were to keep the API manager in place, we would stop exposing <code>port</code> <code>8000</code> in Docker so that we would force anyone interested in using the APIs through the single-entry point.</p>
</div>
<div class="readable-text intended-text" id="p164">
<p>Note that as we currently have things set up, we won’t be saving the APIs permanently in the manager. So, remember that if we spend a lot of time setting up and configuring the APIs, anything we do is not permanent. We just wanted to set up this sandbox because we believe it is beneficial for you to have some experience with API management tools as you are likely to encounter them, especially in larger companies.</p>
</div>
<div class="readable-text" id="p165">
<h3 class="readable-text-h3"><span class="num-string">4.6.5</span> Troubleshooting</h3>
</div>
<div class="readable-text" id="p166">
<p>When working with an API manager and trying an API out, the most common error is</p>
</div>
<div class="browsable-container listing-container" id="p167">
<div class="code-area-container">
<pre class="code-area">  "code": "900902",
  "message": "Missing Credentials",
  "description": "Invalid Credentials. Make sure your API invocation call <br/>has a header: 'Authorization : Bearer ACCESS_TOKEN' or 'Authorization : <br/>Basic ACCESS_TOKEN' or 'apikey: API_KEY'"
}</pre>
</div>
</div>
<div class="readable-text" id="p168">
<p>The <code>Missing</code> <code>Credentials</code> error is caused by not selecting Generate Key before testing the API. When working with APIs in a production environment, we have to generate keys to use with the API either through a dashboard or through another API. In trying out our APIs, we are simply generating a temporary token to use for a brief time.</p>
</div>
<div class="readable-text intended-text" id="p169">
<p>Working with an API manager or through the OpenAPI documentation pages is a helpful way of doing some initial evaluation and exploratory testing. However, once we settle on the APIs that we are going to use, we will need to start using additional tools that are more specialized and offer more robust functionality. The following sections illustrate some of the additional tools that we will be using.</p>
</div>
<div class="readable-text" id="p170">
<h2 class="readable-text-h2"><span class="num-string">4.7</span> Testing with Postman</h2>
</div>
<div class="readable-text" id="p171">
<p>The Postman API platform is a popular tool to assist with the API lifecycle, collaboration between developers and other teams, as well as with API governance. We have primarily used it in testing capacity, although the platform offers many more capabilities.</p>
</div>
<div class="readable-text intended-text" id="p172">
<p>One of our favorite features is the ability to <code>import</code>/<code>export</code> <code>curl</code> versions of the command. <code>curl</code> is a ubiquitous command line utility that lets us get or send data using a variety of protocols. Many systems administrators will ask you for a <code>curl</code> equivalent of your <code>RESTful API</code> call when troubleshooting network/routing problems, so having the ability to produce one quickly and easily can be helpful for your entire team. </p>
</div>
<div class="readable-text intended-text" id="p173">
<p>Collaboration between team members is also easy with Postman, and we have worked closely with our QA department to help develop test scripts that can be used for component and integration tests. Let’s look at how we can use Postman to validate data that is returned from our API. This is similar to what we might be doing with our unit tests while developing. However, the perspective is different because these may be run as part of a larger CI/CD pipeline or as part of QA testing process.</p>
</div>
<div class="readable-text intended-text" id="p174">
<p>We will continue to use the http://localhost:8000/files as our example. Of course, we could also take on the challenge of building a Postman test using an API manager layer. In Postman, we can create a collection that is used to group various requests. Then we can create a new <code>GET</code> request that points to the http://localhost:8000/files and click Send. We should see a nicely formatted JSON response that we have condensed here: <code>[{"file":"File_1"},{"file":"File_2"}]</code>.</p>
</div>
<div class="readable-text intended-text" id="p175">
<p>Once we have confirmed we are successfully connecting and receiving responses from the endpoint, we can add a few tests as well: click the Tests tab, and you can add some straightforward tests to get an idea of how the syntax works. First, let’s test that we have a valid <code>200</code> response code using the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p176">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.13<span class="CharOverride-7"> </span>Sample Postman test</h5>
<div class="code-area-container">
<pre class="code-area">pm.test("Response should be JSON and have a 200 status code", function () {
    pm.response.to.be.json; #1
    pm.response.to.have.status(200); #2
});</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Check if response format is json</span>
<br/>#2 
     <span class="CharOverride-8">Check if response status is 200</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p177">
<p>When sending our request, we should see that the Test Results tab is populated, and we have a passing test. We add a few more tests, as shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p178">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.14<span class="CharOverride-7"> </span>More Postman tests</h5>
<div class="code-area-container">
<pre class="code-area">pm.test("Response should have a file attribute", function () {
    pm.expect(jsonData[0]).to.have.property('file');
});

pm.test("file attribute should be 'File_1'", function () {
    pm.expect(jsonData[0].file).to.eql('File_1');
});

pm.test("Response has at least 2 items", function () {
    pm.expect(jsonData).to.be.an('array').that.has.lengthOf(2);
});</pre>
</div>
</div>
<div class="readable-text" id="p179">
<p>Some of these tests are fragile—meaning they may be easily broken by the data or ordering—so we would expect this code to run against known data. Let’s use the test that looks for <code>File_1</code> to make it a little more robust. Because our data is in an array, we should be guaranteed when parsing that we will always parse them in that order, as opposed to an object where the <code>key</code>/<code>value</code> pairs may not always be returned in the way we see it. Still, the ordering of the JSON depends on factors outside of our control. We may be guaranteed that there is a <code>File_1</code>, but maybe it is not always returned first. How can we write a more robust test? What if we iterated through the array using a <code>for-each</code> loop?</p>
</div>
<div class="browsable-container listing-container" id="p180">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.15<span class="CharOverride-7"> </span>Using a <code>for-each</code> loop in Postman</h5>
<div class="code-area-container">
<pre class="code-area">pm.test("There should be one instance of File_1", () =&gt; {
    let found = false;
    jsonData.forEach(function(item, index) {
        pm.expect(item).to.have.property("file");
        if ( item.file === 'File_1' ) {
            found = true;
        }
    })
    pm.expect(found).to.be.true;
})</pre>
</div>
</div>
<div class="readable-text" id="p181">
<p>Now we define a variable to indicate whether we found our desired item, so no matter where it appears in the array, we will find it. That is a more flexible test, and depending on your familiarity with the language, it might be your first attempt, and since it works, that may be enough. However, we can clarify the test a bit using the <code>some</code> method.</p>
</div>
<div class="browsable-container listing-container" id="p182">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.16<span class="CharOverride-7"> </span>Cleaning up our test</h5>
<div class="code-area-container">
<pre class="code-area">pm.test("There should be one instance of File_1 using some", function () {
    const expectedValue = 'File_1';
    const result = jsonData.some(function (item) {
        return item.file === expectedValue;
    });
    pm.expect(result).to.be.true;
})</pre>
</div>
</div>
<div class="readable-text" id="p183">
<p>Note that the <code>some</code> method is part of ECMAScript 5+ and is available outside of Postman. We have found that using Postman and these test scripts is a fantastic way to introduce newer QA resources to some type of automation. We just scratched the surface of what Postman has to offer; it is a great tool that we have seen used at various FinTech companies, as well as in other industries.</p>
</div>
<div class="readable-text" id="p184">
<h2 class="readable-text-h2"><span class="num-string">4.8</span> Load testing with Locust</h2>
</div>
<div class="readable-text" id="p185">
<p>Earlier, we introduced the testing pyramid that primarily included testing types we would consider functional. Here, we introduce load testing, which falls into the nonfunctional testing category. Figure 4.5 outlines some types of testing.</p>
</div>
<div class="browsable-container figure-container" id="p186">
<img alt="A screenshot of a computer  Description automatically generated" height="381" src="../Images/CH04_F05_Kardell.png" style="width: 100%; max-width: max-content;" width="447"/>
<h5 class="figure-container-h5">Figure 4.5 Software testing categories</h5>
</div>
<div class="readable-text" id="p187">
<p>We want to ensure our APIs will be responsive, see where performance bottlenecks might be, and determine the capacity of the system for future planning. To prepare for all of that, we can look to a framework called Locust. Locust lets us use our budding Python skills to script tests used for load testing.</p>
</div>
<div class="readable-text intended-text" id="p188">
<p>We can easily get started by telling ChatGPT to “create a sample locust test for the http://localhost:8000/files endpoint,” and that provides some easy-to-follow steps. First, we want to install Locust with <code>pip</code> <code>install</code> <code>locust</code>. Also, we create a locustfile.py as follows.</p>
</div>
<div class="browsable-container listing-container" id="p189">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.17<span class="CharOverride-7"> </span>Simple Locust file</h5>
<div class="code-area-container">
<pre class="code-area">from locust import HttpUser, task, between

class FileUser(HttpUser):
    wait_time = between(1, 2.5)

    host = "http://localhost:8000"

    @task
    def get_files(self):
        self.client.get("/files")</pre>
</div>
</div>
<div class="readable-text" id="p190">
<p>From the directory with locustfile.py, run the command <code>locust</code>. This will prompt you to open your browser to the default location http://localhost:8089. Here, we will enter the number of users, spawn rate, the host, and how long it should run for (we clicked the Advanced options) to get that (see figure 4.6).</p>
</div>
<div class="browsable-container figure-container" id="p191">
<img alt="A screenshot of a computer  Description automatically generated" height="333" src="../Images/CH04_F06_Kardell.png" style="width: 100%; max-width: max-content;" width="758"/>
<h5 class="figure-container-h5"><span class="">Figure 4.6</span><span class=""> </span><span class="">Starting a new test with Locust</span></h5>
</div>
<div class="readable-text" id="p192">
<p>From there, we can see the test run and get metrics around how our API is performing. Obviously, in this case, we are dealing with hardcoded values, so we will have a better opportunity later to come back and explore load testing our APIs. However, we can go ahead and get some experience with Locust and load testing now. Can we add tests for the other endpoints? If we need a reminder of what they were or what they should be returning, do not forget our living documentation at http://localhost:8000/docs. With additional tests, our code should look like the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p193">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.18<span class="CharOverride-7"> </span>Locust test</h5>
<div class="code-area-container">
<pre class="code-area">from locust import HttpUser, task, between

class FileUser(HttpUser): #1
    wait_time = between(1, 2.5) #2

    host = "http://localhost:8000" #3

    @task #4
    def get_files(self): #5
        self.client.get("/files")  #6

    @task
    def get_file(self):
        self.client.get("/files/1")

    @task
    def post_file(self):
        self.client.post("/files", json={"file_id": 5})

    @task
    def get_records(self):
        self.client.get("/files/1/records")

    @task
    def get_record(self):
        self.client.get("/files/1/records/1")</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Creates a FileUser class that inherits from HttpUser</span>
<br/>#2 
     <span class="CharOverride-8">Sets a random wait time ranging from </span>
<span class="CharOverride-14">1</span>
<span class="CharOverride-8"> to 2.5 seconds between requests to simulate a user pausing between actions</span>
<br/>#3 
     <span class="CharOverride-8">Defines the host where the API requests will be sent</span>
<br/>#4 
     <span class="CharOverride-8">The task decorator defines a user-simulated action.</span>
<br/>#5 
     <span class="CharOverride-8">Issues a GET against <br/>the /files URI</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p194">
<p>Now, we can rerun Locust to see it hitting the various endpoints. Although our endpoints are currently hardcoded, they will return the path parameters used. So, to make things more interesting, let’s add some code to each of these tests so that the parameters are unique, and that will show us hitting more endpoints in the Locust dashboard. Take a few minutes to see whether you can replace the hardcoded <code>file_ids</code> and <code>record_ids</code> with a random number, and then rerun the tests. The next listing shows the sample we came up with.</p>
</div>
<div class="browsable-container listing-container" id="p195">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.19<span class="CharOverride-7"> </span>Locust </h5>
<div class="code-area-container">
<pre class="code-area">import random
from locust import HttpUser, task, between

class FileUser(HttpUser):
    wait_time = between(1, 2.5)
    host = "http://localhost:8000"

    @task
    def get_files(self):
        self.client.get("/files")

    @task
    def get_file(self):
        file_id = random.randrange(1, 10) #1
        self.client.get(f"/files/{file_id}")

    @task
    def post_file(self):
        file_id = random.randrange(1, 10)
        # Sending POST request to the "/files" endpoint
        self.client.post("/files", json={"file_id": file_id})

    @task
    def get_records(self):
        file_id = random.randrange(1, 10)
        self.client.get(f"/files/{file_id}/records")

    @task
    def get_record(self):
        <span>file_id = random.randrange(1, 10)</span>
<span>        record_id = random.randrange(1, 20)</span>
<span>        </span>self.client.get(f"/files/{file_id}/records/{record_id}")</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Generates a random file_id in the range from </span>
<span class="CharOverride-14">1</span>
<span class="CharOverride-8"> to 9</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p196">
<p>After rerunning our tests, we can see a lot more variety in the endpoints being accessed. At this point, we may have noticed a problem when executing the tests in Locust on the dashboard. If not, take a look at the Failures tab in Locust. You should see a number of failures for the <code>POST</code> method on <code>/files</code> with the error <code>HTTPError('405</code> <code>Client</code> <code>Error: Method</code> <code>Not</code> <code>Allowed</code> <code>for</code> <code>url:</code> <code>/files')</code>. It looks like we missed something in our API code. But before checking it, let’s take a look at another big problem with our Locust tests—no <code>assert</code> statements.</p>
</div>
<div class="readable-text intended-text" id="p197">
<p>Similarly to all our other tests, we want to make sure we are doing some sort of the <code>assert</code> statement. Let’s start by ensuring a valid response each time. Feel free to give that a try before reading further.</p>
</div>
<div class="browsable-container listing-container" id="p198">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.20<span class="CharOverride-7"> </span>Locust test</h5>
<div class="code-area-container">
<pre class="code-area">…  #1
@task #2
def get_files(self): #3
   response = self.client.get("/files")  #3
   assert response.status_code == 200,  #3
      f"Unexpected status code: {response.status_code}"  #3

@task
def get_file(self):
   response = self.client.get(f"/files/{file_id}")
   assert response.status_code == 200, 
      f"Unexpected status code: {response.status_code}"

@task
def post_file(self):
   response = self.client.post("/files", json={"file_id": file_id})
   assert response.status_code == 200, 
      f"Unexpected status code: {response.status_code}"

@task
def get_records(self):
   file_id = random.randrange(1, 10) #4
   response = self.client.get(f"/files/{file_id}/records")
   assert response.status_code == 200, 
      f"Unexpected status code: {response.status_code}"

@task
def get_record(self):
   <span>file_id = random.randrange(1, 10) </span>#5
<span>   record_id = random.randrange(1, 20) </span>
<span>   response = self.client.get(f"/files/{file_id}/records/{record_id}")</span>
<span>   assert response.status_code == 200, </span>
      f"Unexpected status code: {response.status_code}"</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Previous code setup </span>
<span class="CharOverride-8">from listing 4.</span>
<span class="CharOverride-14">1</span>
<span class="CharOverride-8">9</span>
<br/>#2 
     <span class="CharOverride-8">Uses the Locust task decorator to define what Locust should be executing</span>
<br/>#3 
     <span class="CharOverride-8">Defines a get_files method that executes a GET against the /files URI and checks the HTTP status was 200</span>
<br/>#4 
     <span class="CharOverride-8">Makes requests using </span>
<span class="CharOverride-8">a random file_id in the range from 1 to 9</span>
<br/>#5 
     <span class="CharOverride-8">Makes requests using </span>
<span class="CharOverride-8">a random file_id in the range from </span>
<span class="CharOverride-14">1</span>
<span class="CharOverride-8"> to 9 and </span>
<span class="CharOverride-8">a random record_id in the range from 1 to </span>
<span class="CharOverride-14">1</span>
<span class="CharOverride-8">9</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p199">
<p>Now that we have some assert statements, we can see an <code>Unexpected</code> <code>status</code> <code>code:</code> <code>405</code> in the Exceptions tab in addition to the Failures tab. Let’s check out the logs for the API container and see what’s there. The logs show two interesting problems:</p>
</div>
<div class="browsable-container listing-container" id="p200">
<div class="code-area-container">
<pre class="code-area">"GET /files/3 HTTP/1.1" 200 OK
"POST /files HTTP/1.1" 405 Method Not Allowed
"POST /files HTTP/1.1" 405 Method Not Allowed
"GET /files/6/records HTTP/1.1" 307 Temporary Redirect
"GET /files HTTP/1.1" 200 OK</pre>
</div>
</div>
<div class="readable-text" id="p201">
<p>As we saw, the <code>POST</code> is getting a <code>405</code> <code>Method</code> <code>Not</code> <code>Allowed</code>, and we also see a <code>307</code> <code>Temporary</code> <code>Redirect</code>. When we review our code that defines the endpoints, we see that there was a trailing slash for some endpoints but not for others:</p>
</div>
<div class="browsable-container listing-container" id="p202">
<div class="code-area-container">
<pre class="code-area">@router.get("/files")
@router.get("/files/{file_id}")
@router.post("/files/", status_code=status.HTTP_201_CREATED)
@router.get("/files/{file_id}/records/")
@router.get("/files/{file_id}/records/{record_id}")</pre>
</div>
</div>
<div class="readable-text" id="p203">
<p>All the Locust requests left the trailing slash off the requests, so let’s make sure we are consistent in both the server and the client. In our example, we are going to remove the trailing slashes from the server portion. Rebuilding our containers and rerunning our tests give us a more consistent experience without errors in the logs or failures in Locust. We do see that we still have exceptions in Locust. This is because we coded all our assert statements to be expecting a <code>200</code> return code. However, when we refer to the documentation (or by looking at the code), we are reminded that our <code>POST</code> request responds with a <code>201</code> not <code>200</code>. With that taken care of, we see our tests running normally, with review failures, exceptions, and the associated analytics as shown in figure 4.7.</p>
</div>
<div class="browsable-container figure-container" id="p204">
<img alt="A screenshot of a graph  Description automatically generated" height="356" src="../Images/CH04_F07_Kardell.png" style="width: 100%; max-width: max-content;" width="733"/>
<h5 class="figure-container-h5"><span class="">Figure 4.7</span><span class=""> </span><span class="">View of successive Locust runs</span></h5>
</div>
<div class="readable-text" id="p205">
<h2 class="readable-text-h2"><span class="num-string">4.9</span> Improving our code</h2>
</div>
<div class="readable-text" id="p206">
<p>Now that we have both unit and load tests, you should feel comfortable working within your code to make improvements. Even though the code is straightforward, we can still take advantage of some benefits of FastAPI. This section shows the benefits of versioning, using prefixes, documentation, and validation.</p>
</div>
<div class="readable-text" id="p207">
<h3 class="readable-text-h3"><span class="num-string">4.9.1</span> Using a prefix and versioning</h3>
</div>
<div class="readable-text" id="p208">
<p>You may have noticed that each of our endpoints in the router includes<code>/files</code>. While this works fine, we would also like to include a version number, as well as put the endpoint under an <code>api</code> endpoint in the URL. We want to end up with something like <code>/api/v1/files</code> as our initial standard. Using <code>/api</code> helps with organizing our APIs in one area. This can help with web server configuration, firewall rules, monitoring, and similar. The <code>v1</code> indicates the API version, and we can use it to support multiple API versions. Remember that once end-users start consuming the API, it is unwise to make breaking changes to your API that would force them to upgrade their applications. In these cases, you should provide the new API under <code>/v2</code> and eventually phase out prior versions when possible. Remember, the <code>/api/v1</code> is just a suggestion. You could name the endpoint anything you choose and use any versioning scheme based on your needs.</p>
</div>
<div class="readable-text intended-text" id="p209">
<p>We refactor our code to add the additional <code>/api/v1</code> to our endpoints by using the <code>prefix</code> parameter available in <code>APIRouter</code>. We update our files.py:</p>
</div>
<div class="browsable-container listing-container" id="p210">
<div class="code-area-container">
<pre class="code-area">router = APIRouter(prefix="/api/v1/files")</pre>
</div>
</div>
<div class="readable-text" id="p211">
<p>Then, we remove the <code>/files</code> from each of our defined endpoints. Table 4.3 shows the differences.</p>
</div>
<div class="browsable-container browsable-table-container" id="p212">
<h5 class="browsable-container-h5">Table 4.3 Effects of using a <code>prefix</code> parameter on the router</h5>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col class="_idGenTableRowColumn-9"/>
<col class="_idGenTableRowColumn-9"/>
</colgroup>
<tbody>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-1"> <p class="_TableHead"><span class="CharOverride-3">Before</span></p> </td>
<td class="No-Table-Style CellOverride-3"> <p class="_TableHead"><span class="CharOverride-3">After</span></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-4"> <p class="_TableBody"><code>@router.get("/files")</code></p> </td>
<td class="No-Table-Style CellOverride-6"> <p class="_TableBody"><code>@router.get("")</code></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-4"> <p class="_TableBody"><code>@router.get("/files /{file_id}")</code></p> </td>
<td class="No-Table-Style CellOverride-6"> <p class="_TableBody"><code>@router.get("/{file_id}")</code></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-10">
<td class="No-Table-Style CellOverride-4"> <p class="_TableBody"><code>@router.post("/files ", status_code=status.HTTP_201_CREATED)</code></p> </td>
<td class="No-Table-Style CellOverride-6"> <p class="_TableBody"><code>@router.post("", status_code=<br/>status.HTTP_201_CREATED)</code></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-10">
<td class="No-Table-Style CellOverride-4"> <p class="_TableBody"><code>@router.get("/files /{file_id}/records")</code></p> </td>
<td class="No-Table-Style CellOverride-6"> <p class="_TableBody"><code>@router.get("/{file_id}/records")</code></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-10">
<td class="No-Table-Style CellOverride-4"> <p class="_TableBody"><code>@router.get("/files /{file_id}/records/{record_id}")</code></p> </td>
<td class="No-Table-Style CellOverride-6"> <p class="_TableBody"><code>@router.get("/{file_id}/records/{record_id}")</code></p> </td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p213">
<p>We can see that by using the prefix, we now have a little less typing to do in each endpoint. We also need to rerun our unit tests to see whether things still work, and as we may have suspected, our tests are all failing with <code>404</code> <code>errors </code>because they are no longer going to the correct URL. We need to go ahead and update our unit tests to include the <code>/api/v1</code> and rerun them.</p>
</div>
<div class="readable-text" id="p214">
<h3 class="readable-text-h3"><span class="num-string">4.9.2</span> Adding Pydantic</h3>
</div>
<div class="readable-text" id="p215">
<p>Pydantic is a widely used data validation library that comes bundled with FastAPI. We will incorporate it here to move away from our hardcoded strings (although we will still be returning hardcoded values). By adding Pydantic, we position our code to be more easily expanded in the future and are able to take advantage of some of its features for validation and documentation.</p>
</div>
<div class="readable-text intended-text" id="p216">
<p>Later, we will look to build objects that model actual ACH files and records. For now, let’s take a look at how Pydantic will enhance our current APIs. Our first endpoint performs a <code>GET</code> on <code>/api/v1/files/{file_id}</code> where we previously returned a JSON string. It looks something like this (with the new prefix defined).</p>
</div>
<div class="browsable-container listing-container" id="p217">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.21<span class="CharOverride-7"> </span>Our previous hardcoded function</h5>
<div class="code-area-container">
<pre class="code-area">@router.get("/{file_id}")
async def read_file(file_id: str):
    return {"file_id": file_id}</pre>
</div>
</div>
<div class="readable-text" id="p218">
<p>Now, we create an <code>AchFile</code> class that will model the hardcoded value we were returning in the previous listing.</p>
</div>
<div class="browsable-container listing-container" id="p219">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.22<span class="CharOverride-7"> </span>Our first <code>Pydantic</code> class</h5>
<div class="code-area-container">
<pre class="code-area">from pydantic import BaseModel, Field

class AchFile(BaseModel):
    file_id: str</pre>
</div>
</div>
<div class="readable-text" id="p220">
<p>With that simple class in place, we can update the router to return an instance of that class.</p>
</div>
<div class="browsable-container listing-container" id="p221">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.23<span class="CharOverride-7"> </span>Updating our route to use our newly created <code>Pydantic</code> class</h5>
<div class="code-area-container">
<pre class="code-area">…
from ach.AchFile import AchFile
…
@router.get("/{file_id}")
async def read_file(file_id: str) -&gt; AchFile:
    return AchFile(file_id=file_id)</pre>
</div>
</div>
<div class="readable-text" id="p222">
<p>Our unit tests should still pass, so we have not broken anything. If we were to start this up in Docker, we would run into an error of <code>ModuleNotFoundError:</code> <code>No</code> <code>module named</code> <code>'ach'</code>. This is because Python does not know where to find our class, and there is a possibility that we even forgot to copy it over! Before starting, add another <code>COPY</code> statement to your Dockerfile and set the <code>PYTHONPATH</code>. This should get our code up and running.</p>
</div>
<div class="browsable-container listing-container" id="p223">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.24<span class="CharOverride-10"> </span>Updating our Dockerfile</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">COPY ./app /code/app
<strong>COPY ./ach /code/ach</strong>

<strong>ENV PYTHONPATH /code</strong></pre>
</div>
</div>
<div class="readable-text" id="p224">
<p>Now we should be able to bring down Docker, build, and bring our containers up again. If we take a look at the documentation, we will see an <code>AchFile</code> in the schema section. Let’s continue to expand on the documentation by adding a <code>Field</code> method to provide additional documentation.</p>
</div>
<div class="browsable-container listing-container" id="p225">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.25<span class="CharOverride-7"> </span>Expanding the documentation of our <code>AchFile</code> class</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">from pydantic import BaseModel, <strong>Field </strong>#1
…
    file_id: str = <strong>Field(examples=["1", "2"], title="ACH File ID", </strong>#2
<strong>description="The ACH file ID used to identify the file in the system") </strong></pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Imports the Field function</span>
<br/>#2 
     <span class="CharOverride-8">Adds parameters that will help with the OpenAPI documentation</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p226">
<p>By adding some examples, title, and description, the schema becomes more meaningful. Figure 4.8 shows how the OpenAPI documentation was updated.</p>
</div>
<div class="browsable-container figure-container" id="p227">
<img alt="A computer screen shot of a computer code  Description automatically generated" height="203" src="../Images/CH04_F08_Kardell.png" style="width: 100%; max-width: max-content;" width="739"/>
<h5 class="figure-container-h5"><span class="">Figure 4.8</span><span class=""> </span><span class="">Our updated </span><span class=""><code>AchFile</code></span><span class=""> schema</span></h5>
</div>
<div class="readable-text" id="p228">
<p>This is just the beginning of making our API user-friendly. We will expand on the concept as we build more APIs.</p>
</div>
<div class="readable-text" id="p229">
<h3 class="readable-text-h3"><span class="num-string">4.9.3</span> Validation with Pydantic</h3>
</div>
<div class="readable-text" id="p230">
<p>Another benefit of Pydantic is its built-in validation capabilities. Validation of data entering the environment is a must in any production system (unless we are looking to test the resilience of our system). We should not rely on the UI or another system to validate data. If end-users are given free rein to enter any type of data in a field, they will do so, and it does not matter whether it makes sense. By combining Pydantic with FastAPI we can get a lot of validation for free where we may have once needed a lot of boilerplate code. </p>
</div>
<div class="readable-text intended-text" id="p231">
<p>For example, we could enforce our <code>file_id</code> to be at least one character and contain only lowercase letters, underscores, and numbers. There are multiple approaches to enforcing such validations. In Pydantic, for instance, we can use a regular expression. By simply adding a pattern parameter to the field, we can enforce this constraint:</p>
</div>
<div class="browsable-container listing-container" id="p232">
<div class="code-area-container">
<pre class="code-area">pattern=r"^[a-z0-9_]+$"</pre>
</div>
</div>
<div class="readable-text" id="p233">
<p>Now that we are enforcing validation, let us jump back to <code>main.py</code> and add an exception handler when a validation error occurs. In this case, we will return a <code>400</code> <code>status</code> along with some detailed error information. We need to be careful that our exception messages do not leak sensitive information. In this case, it is a validation error triggered by missing or malformed fields. Still, this may be more appropriate for a development environment; in production, we may want to have a more robust method of translating the error into a known message to reduce the risk of exposing any sensitive data. Our exception handler should look like the following.</p>
</div>
<div class="browsable-container listing-container" id="p234">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.26<span class="CharOverride-7"> </span>Validation in Pydantic</h5>
<div class="code-area-container">
<pre class="code-area">from fastapi import FastAPI, Request, status, HTTPException
from fastapi.responses import JSONResponse
…
@app.exception_handler(ValidationError)  #1
async def validation_exception_handler(request: Request, exc: ValidationError): #2
    return JSONResponse(  #2
        status_code=status.HTTP_400_BAD_REQUEST,  #2
        content={"detail": exc.errors()}  #2
    ) </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">Decorator that registers a custom exception handler for ValidationError exceptions</span>
<br/>#2 
     <span class="CharOverride-8">Ensures the HTTP status of 400 is returned along with error details</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p235">
<p>From here, we can add additional unit tests that confirm our validation behavior.</p>
</div>
<div class="browsable-container listing-container" id="p236">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.27<span class="CharOverride-7"> </span>Validating our exception behavior</h5>
<div class="code-area-container">
<pre class="code-area">def test_read_file_lower_case(): #1
    response = client.get("/api/v1/files/lower_case_file_id")   #1
    assert response.status_code == 200 #1
    assert response.json() == {"file_id": "lower_case_file_id"}  #1

def test_read_file_validation_error(): #2
    response = client.get("/api/v1/files/this_IS_invalid")  #3
    assert response.status_code == 400 #3
    assert response.json()["detail"][0]["msg"] ==  #3
<span class="CharOverride-9">➥</span>"String should match pattern '^[a-z0-9_]+$'"  #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">A test that passes validation</span>
<br/>#2 
     <span class="CharOverride-8">Testing when we receive an exception condition. Notice the status code of 400 and also a detailed message explaining what the pattern is.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p237">
<p>We add the positive case to show that we accept a lowercase <code>file_id</code>, and when uppercase values are used, we see the error telling us what the pattern should be.</p>
</div>
<div class="readable-text intended-text" id="p238">
<p>In fact, we get a lot of useful information returned by default. Whether it is appropriate to show all this to your end-user may be another matter. API usage is in most cases fine to return detailed information, but we want to caution against revealing too much. For instance, you may notice that most sites do not tell you whether you have typed your username or password incorrectly. They simply say that one or the other is incorrect. This is a conscious design decision made to prevent malicious users from attempting to determine a list of valid users. Therefore, we sometimes return more generic information to the user and log the details in a system log. In this case, we are fine since it is acting as an interactive guide to the API.</p>
</div>
<div class="browsable-container listing-container" id="p239">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.28<span class="CharOverride-7"> </span>Detailed error that we receive from Pydantic</h5>
<div class="code-area-container">
<pre class="code-area">{
  "detail": [
    {
      "type": "string_pattern_mismatch",
      "loc": [
        "file_id"
      ],
      "msg": "String should match pattern '^[a-z0-9_]+$'",
      "input": "DFSDF",
      "ctx": {
        "pattern": "^[a-z0-9_]+$"
      <span>},</span>
<span>      "url": "https://errors.pydantic.dev/2.4/v/string_pattern_mismatch"</span>
<span>    </span>}
  ]
}</pre>
</div>
</div>
<div class="readable-text" id="p240">
<p>We just touched on the basics of validation in Pydantic and FastAPI. A broad range of validation options in addition to regular expressions, as well as the ability to create custom validators, are available. We will explore this in later chapters.</p>
</div>
<div class="readable-text" id="p241">
<h3 class="readable-text-h3"><span class="num-string">4.9.4</span> Troubleshooting Pydantic</h3>
</div>
<div class="readable-text" id="p242">
<p>We may see a <code>500</code> <code>Internal</code> <code>Server</code> <code>Error</code> if we failed to copy over our updated API code. In our custom handler, we are intercepting the validation error thrown and returning a <code>400</code> <code>error</code> code. If we see something similar to error shown in the following listing, we have likely made that oversight or our handler is not working.</p>
</div>
<div class="browsable-container listing-container" id="p243">
<h5 class="listing-container-h5 browsable-container-h5">Listing 4.29<span class="CharOverride-7"> </span>Docker error in FastAPI</h5>
<div class="code-area-container">
<pre class="code-area">docker-api-1   | INFO:     192.168.0.1:37630 
 <span class="CharOverride-9">➥</span>- "GET /api/v1/files/DFSDF HTTP/1.1" 500 Internal Server Error
docker-api-1   | ERROR:    Exception in ASGI application
docker-api-1   | Traceback (most recent call last):
docker-api-1   |   File "/usr/local/lib/python3.12/
<span class="CharOverride-9">➥</span>site-packages/uvicorn/protocols/http/h11_impl.py",
<span class="CharOverride-9">➥</span>line 408, in run_asgi
docker-api-1   |     result = 
<span class="CharOverride-9">➥</span>await app(  # type: ignore[func-returns-value]</pre>
</div>
</div>
<div class="readable-text" id="p244">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p245">API-driven design promotes an API-first approach to development and ensures your software meets today’s distributed nature.</li>
<li class="readable-text" id="p246">Exploring the design and testing of APIs is crucial for interaction with software components in microservices, distributed systems, and packages.</li>
<li class="readable-text" id="p247">REST is the primary API standard discussed, but GraphQL and SOAP are other important standards with unique pros and cons.</li>
<li class="readable-text" id="p248">APIs act as contracts requiring adherence to usage terms and providing stable, scalable endpoints with SLAs for consumers.</li>
<li class="readable-text" id="p249">API-driven design emphasizes clear use cases, versioning, comprehensive documentation, and robust security and validation.</li>
<li class="readable-text" id="p250">Effective API monitoring and analytics are essential for capacity assessment, using tools such as OpenTelemetry, Prometheus, and Grafana.</li>
<li class="readable-text" id="p251">Initial API tasks are simple, focusing on uploading and viewing files and records with a clear interaction flow.</li>
<li class="readable-text" id="p252">FastAPI is used for building APIs, starting with basic <code>GET</code> endpoints, and supporting pagination and asynchronous processing for performance.</li>
<li class="readable-text" id="p253">Unit tests validate API endpoints during development, while additional tests such as BDD can assess API behavior and performance.</li>
<li class="readable-text" id="p254">API documentation via OpenAPI standards ensures alignment between implementation and user understanding, offering tools such as Swagger and Redoc.</li>
<li class="readable-text" id="p255">API management tools such as WSO2 centralize management, provide lifecycle control, and facilitate API monitoring, monetization, and user experience.</li>
</ul>
</div></body></html>