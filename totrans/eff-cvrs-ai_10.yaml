- en: 8 Streamlining complex flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The effect of complexity for end users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The effect of complexity for the business and support teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to trade off conversational feel versus complex implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to simplify the user’s journey
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unnecessary complexity is painful for chatbot users and builders alike, and
    it often leads to bad business outcomes or delays in the deployment timeline.
    Building a conversation that feels simple and natural requires thoughtful design
    and empathy for the user’s situation. As designers and builders of these solutions,
    we aim to create an experience that helps a user reach their goal with the least
    amount of hassle or difficulty. Why should we be so accommodating? Because we
    need users to adopt or accept the solution in order to justify the cost of maintaining
    the technology.
  prefs: []
  type: TYPE_NORMAL
- en: Users will associate a “natural” conversational experience with “simple” or
    “easy to use.” An interface that is easy to use tends to result in the most successful
    outcomes. Conversely, an experience that has not properly considered the user’s
    perspective often feels disorienting, unnatural, and perhaps overly complicated.
    This can cause users to escalate, abandon the conversation, or fail to reach an
    optimal outcome.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss complexity from the perspectives of the user
    and the business. Sometimes there are unavoidable tradeoffs involved in reducing
    complexity for the user. We will discuss the tradeoffs you may encounter when
    trying to solve user pain points and how to prioritize or implement next-best
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 The pain of complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complexity is a double-edged sword: it can add friction or failure points to
    a task-oriented conversation, but without it, we often can’t accomplish the more
    useful transactions. Simple FAQ-style bots are rarely complex, but they can be
    limited in their usefulness. Users who need to accomplish a task often require
    a bot that can do more than tell them *how* to do something—they need it to perform
    some sort of action for them (or on their behalf). Take, for example, a user who
    needs to know how much money they have in their checking account. An FAQ bot may
    simply tell a user how to check their account balance, but the user’s goal is
    not yet satisfied. A self-service bot would provide the user’s actual account
    balance, which does satisfy their goal.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the differences in complexity between these two solutions are stark.
    An FAQ bot simply needs to identify the user’s goal and produce a relevant answer.
    A process-oriented bot will typically require integrations to external backend
    systems. It may need to authenticate the user and be able to access privileged
    information from one or more sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there is often an inherent degree of complexity involved in
    delivering a solution that can accomplish the more useful tasks offered by virtual
    assistants. A virtual agent must serve two masters: the end user and the business
    or organization that created and maintains the solution. Deciding who will absorb
    the burden or effect of complexity is a balancing act.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Complexity’s effect on the end user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complex transactional conversations can feel intimidating or confusing to a
    user. Poorly designed flows introduce a proportional amount of friction to the
    experience. A major liability of unnecessary complexity is that it introduces
    additional potential failure points. Failures in the conversation will either
    block the user from progressing or subject them to retries. As a result, users
    often end up asking for an agent or simply abandoning the chat.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the effect of unnecessary complexity while working with an insurance
    company. They had a voice solution for medical providers. Providers could call
    to obtain status and payment details about submitted claims, but the claim search
    flow only had a 40% success rate. The flow required five pieces of information
    from a user before it would search for a claim. Figure 8.1 shows the steps in
    the claim search.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F01_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 The process to deliver a claim status involved seven steps. The caller
    must provide five pieces of information before the solution performs a search
    and (if the search is successful) delivers the claim status.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The lookup process was a bit grueling for a user, requiring several long strings
    of numeric input at multiple steps. The following listing shows the experience
    from a user’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.1 Claim search flow where caller must provide five pieces of information
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We looked for ways to reduce the complexity in this flow. Our research revealed
    that a majority of callers only had one claim for any particular member and date
    combination. In other words, a search on that information alone would often produce
    a single result. This meant that collecting a claim number was unnecessary for
    most users.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 shows the updated claim search flow, which collects the minimal amount
    of information to perform a claim search. If only one claim is found, the claim
    status is delivered immediately. If the logic detects more than one claim, the
    bot will disambiguate by collecting the claim number from the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F02_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 The updated process to deliver a claim status requires only four
    pieces of information for most callers. The caller is asked for a fifth piece
    of information only when necessary.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By eliminating the claim number collection step for accounts with only one claim,
    we made the experience simpler for the user. This, in turn, improved the task
    completion rate and cut the incidence of claim number search failures by half.
    The following listing shows the improved experience.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.2 Most callers only need four pieces of information in improved experience
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.2 Complexity’s effect on business metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An overly complex user experience can hurt your business metrics across multiple
    dimensions: user opt-out rates may increase, escalations to support staff could
    go up, self-serve task completions may decrease, and NPS or user survey scores
    may go down.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of business impact, again with our insurance company, was an inexplicable,
    disproportionate number of opt-outs (request for an agent) occurring after a successful
    claim lookup. After the caller navigated the search process (which involved answering
    three or four questions), they were presented with a final question: Would they
    like the claim information read or faxed to them? Figure 8.3 shows a breakdown
    of the user responses to this question.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F03_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 Callers asked for a representative almost two-thirds of the time.
    The most logical option—having the information read to the caller (i.e., delivered
    via the same channel over which they were currently engaged)—was the second most
    popular choice. Just 1% of users chose the option to receive a fax of the information
    they sought.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At this point in the flow, the solution had successfully identified the user
    and retrieved the information they were seeking. Unfortunately, users were opting
    out, not knowing they were *so close* to successfully completing their goal. This
    was clearly a problem for the business, as the loss of containment meant that
    human agents were handling tasks that should have been (and in fact, nearly were)
    successfully completed by the virtual assistant. The following listing shows the
    user experience before improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.3 Caller asks for agent even though claim search was successful
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The original design choice for offering two options at this juncture may have
    seemed sound in theory (the subject matter experts said, “We regularly get requests
    for faxes”), but the evidence suggested that the caller’s tolerance for complexity
    had been exceeded. One hypothesis was that the question itself was falsely signaling
    a complex situation; otherwise, why wouldn’t the bot just read the information?
    It could also be that the user was frustrated by answering so many questions without
    getting anything of value in return.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the business was affected across multiple dimensions: opt-out
    rates and escalations increased while self-service task completions correspondingly
    decreased. The logical solution was to remove this question and simply read the
    claim details. The offer to also receive a fax was moved to later in the flow—after
    the claim details were given. Figure 8.4 shows the updated experience and possible
    outcomes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F04_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 The updated experience immediately reads claim details and then provides
    a fax option for the small percentage of users who require a fax.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Eliminating one conversational turn guaranteed that all callers who provided
    the required claim lookup credentials successfully completed the task flow, as
    shown in listing 8.4\. Once the details are given, the caller can simply hang
    up if they have everything they need, resulting in full containment of a call.
    Callers may also choose to receive a fax, in which case, a flow is invoked to
    complete that task. Some users may still request an agent, but the reasons for
    requesting an agent at this point are likely different from their reasons for
    requesting an agent *before* the claim details were read. (In that case, a *new*
    pain point may need to be addressed.)
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.4 Claim details are provided immediately if search was successful
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you design your bot—or work to improve an existing one—keep in mind that
    simple interactions (from the user’s perspective) make it easier to reach a successful
    outcome. The definition of a “successful” outcome will vary according to the use
    case and business objectives. With proper planning, however, a solution’s business
    metrics can be tracked to the strategies used to build or improve a solution.
    Good metrics will provide guidance for understanding the success rate, usefulness
    of, and weaknesses in your conversational design.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.3 The incremental cost and benefit of reducing complexity for the user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reducing complexity for the user can sometimes increase the complexity of the
    dialogue design. Transactional conversations—those that interact with a user over
    multiple turns to reach a goal—have multiple failure points and add complexity
    with each feature or capability that is supported. To ease the pain of complexity
    for users, conversations must be designed with a maximally natural and thoughtful
    flow. In other words, the harder your process is, the more effort you should put
    into reducing complexity for the user to ensure the best chance of a successful
    outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Some strategies for reducing complexity for the user are simple and inexpensive
    to implement, yet deliver high value. Other strategies, especially those requiring
    integration with backend systems, are more technically complex and/or costly to
    implement. Each business and use case must assess the value gained versus cost
    and other tradeoffs when adding robust capabilities like natural language understanding,
    personalization, and automation to a conversational experience.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, good metrics—a common theme throughout this book—are key to good
    planning and prioritization. Is it worth designing for every possibility the bot
    could encounter? Most certainly not! But there are things you can do to optimize
    the experience for a majority of users and scenarios. The 80/20 rule is a good
    starting point for deciding where to invest in improvements or expansion of bot
    capability. If 80% of users will benefit, it’s probably worth implementing.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity for the user can be a barrier to success. Designing an effective,
    simplified conversational exchange requires a thorough understanding of the user,
    including who they are, what brought them to your virtual assistant, and what
    they expect to get out of the experience. User research should inform your design.
    It may not be feasible or cost effective to implement every accommodation. What
    is worth pursuing, however, is meeting the user where they are and knocking down
    barriers that impede their path to success wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Review a process flow in a bot you’ve built or encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: List all the steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the steps that are the most difficult for a user to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine if there are opportunities to reorder or remove steps to make the
    process easier for the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 8.2 Simplifying and streamlining the user journey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple strategies and techniques can be used to design a natural, simplified
    conversational experience. In this section, we’ll discuss ways to streamline the
    user’s journey.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Spotting complex dialogue flows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a complex flow, each turn, or user response, may take the user down a particular
    path. Ideally, that path would be the most efficient route to reach an end goal.
    If the user’s journey is overly complicated or inefficient, there is room for
    improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can you know if your solution is overly complicated or inefficient? We
    have observed several antipatterns of dialogue design that unnecessarily increase
    the complexity of a conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: Asking the user for information they are unlikely to have, or need time to retrieve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rigid, inflexible input requirements for the user response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asking ambiguous questions—causing uncertainty regarding how to provide a “correct”
    response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treating all users and scenarios the same way, especially if this results in
    asking questions that may not be necessary in all situations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choice overload and choices that do not map to a user’s mental model of how
    to progress toward their goal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asking for information in a disjointed order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asking for information that is not optimal for the interface or channel (e.g.,
    asking for an email address over a voice channel)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating information that is not optimal for the interface or channel (e.g.,
    reading a long or complex URL over a voice channel)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying complexity in your dialogue flows is the first step toward simplifying
    the user’s journey. Your performance metrics may indicate problem areas. Scrutinizing
    the solution from a user’s perspective will also uncover complex interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 Using what is known about the user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An optimal experience will make good use of what the solution knows about each
    user at the start of the conversation as well as what it learns about the user
    along the way. This information is typically stored as context for the conversation.
    It may come from a backend system or directly from the user over the course of
    the interaction. By using what you know or have learned about the user, you can
    personalize the conversation or dynamically route a user along the most efficient
    path to completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'One company we worked with offered a user three options to look up their account:
    the (13 digit) account number, a social security number, or a phone number. After
    the user selected *how* to look up their account, they had to provide that number.
    Each of these steps not only burdened the user with effort, but they were also
    potential failure points. Figure 8.5 shows the steps involved in this flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F05_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 The caller must provide two pieces of information before they can
    proceed in the flow.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The following listing shows the conversational experience from the caller’s
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.5 Caller is asked for two pieces of information in order to look up
    an account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since the experience was a phone-based solution, we could usually detect the
    number a customer was calling from. Using this information allowed us to simplify
    the journey for a majority of users. Instead of asking two questions before performing
    a search, we performed a background search against the caller ID. If an account
    was found, we offered the phone number as a lookup option. The user simply had
    to confirm that this was what they wanted. Figure 8.6 shows the updated search
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F06_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 Using what we know about a user (their caller ID), we are able to
    reduce pain points and eliminate the potential failures that can occur while collecting
    information from the user.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The following listing shows the updated conversational experience from the caller’s
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.6 Callers recognized by phone number bypass unnecessary steps
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 8.2.3 Aligning with the user’s mental model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow of information should match what the user expects from a conversational
    exchange. Make every effort to provide or request information in the order that
    a user would naturally expect to receive or convey information. In other words,
    align to their mental model for storing and retrieving information.
  prefs: []
  type: TYPE_NORMAL
- en: This applies to your wording choices as well. When your chatbot offers choices,
    be sure that your terminology maps to what the user understands. Does the user
    have enough information to choose the best option for their situation?
  prefs: []
  type: TYPE_NORMAL
- en: Another way to align with the user’s mental model is to allow them to provide
    multiple pieces of information in a single turn. This technique is known as *slot
    filling*. It allows the user to communicate their need in their own words, which
    may include important details or specifications. When the dialogue can recognize
    and store key information, it may allow a user to advance further in a flow, bypassing
    redundant or unnecessary steps.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a user makes a dinner reservation, a system may require the
    date, the time, the number of people in the dinner party, a name for the reservation,
    and a contact number. In a conversational solution, a user may say, “I’d like
    to make a reservation for two this Saturday at 8:00 p.m.” A robust solution will
    recognize the user’s intent (make a reservation) and detect three of the five
    required details (aka *entities*). The solution may skip the steps that ask for
    date, time, and party size, allowing the user to advance directly to collecting
    a name and contact number. Figure 8.7 shows how various utterances might fill
    slots in a dinner reservation dialogue flow.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F07_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 As the user provides more information, each mention (the underlined
    words) fills the corresponding slot, eliminating the need to ask for this information
    in downstream steps.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 8.2.4 Allowing flexibility in the expected user responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Process-oriented bots need to solicit information from a user in order to proceed
    along the best path. Sometimes the user does not understand exactly what the bot
    is asking. For the user, failing to provide the right information, or information
    in the right format, can result in retries or failures. A flexible design allows
    for multiple “correct” responses. This allows you to dynamically streamline the
    conversation for some users while patiently guiding those who need more direction.
  prefs: []
  type: TYPE_NORMAL
- en: Question-type confusion is a frequent culprit in retries or failures that occur
    while soliciting information from a user. This happens most often when a multiple-choice
    question is interpreted as yes/no, and vice versa. The channel often drives your
    approach to solving this problem. Figure 8.8 demonstrates ways to reduce question-type
    confusion by using the capabilities available for different channels.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F08_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 Output responses can be tailored for the channel to ensure the best
    chance of success.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you cannot eliminate the ambiguity (particularly on a voice channel, where
    input selectors such as buttons or dropdown options are not possible), make sure
    your bot gracefully handles a good faith attempt to provide the response they
    think the bot is asking for. Rather than retry (which is treated as an error,
    and may result in escalation), disambiguate to clarify the user’s response. The
    following listing shows a retry experience, which implies that the user is stuck
    on a step.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.7 A step retry indicating there is a problem with how the user responded
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The difference, from the user’s perspective, is that a retry signals to the
    user that they are stuck or something has gone wrong, whereas a disambiguation
    question, as shown in the next listing, implies they are progressing through the
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.8 Disambiguation providing reassurance that the user is moving forward
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Another way to streamline a conversation is by handling correctional information
    when it is provided in response to a confirmation question (typically a question
    that is asked with the intention of getting a “yes” or “no” response). Let’s say
    we ask a caller if they want to use the phone number they are calling from (the
    caller ID) to receive text message updates. The obvious valid responses we would
    plan for are affirmative (“Yes, use that number”) or negative (“No, don’t use
    that number”).
  prefs: []
  type: TYPE_NORMAL
- en: In a process-oriented flow such as this, an affirmative response will proceed
    to the next step. A negative response might trigger a flow to collect an alternate
    number for receiving texts. Anything else would digress and/or retry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a third type of information that our bot might receive at this
    step: users sometimes provide an update or correction to information during a
    confirmation step instead of “yes” or “no” (“Use this other number instead: 555-867-5309”).
    The following listing shows how an unexpected response causes a failure, which
    triggers a retry followed by a data collection step.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.9 Rigid expectations for a confirmation step resulting in unnecessary
    steps
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If our bot only expects “yes” or “no” as a response, the logic will fail and
    trigger a retry. Additionally, the user will have to repeat information that was
    provided in their initial response. Those two extra steps (the retry, followed
    by data collection) penalize a user who values efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The next listing shows how a flexible design treats a detected phone number
    entity as equivalent to “no” and additionally saves the phone number, which allows
    the user to bypass the subsequent data collection step.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.10 A flexible design capturing information and streamlining the flow
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 8.2.5 Supporting self-service task flows with API/backend processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Designing a simplified experience for the end user may require integrations
    that personalize or expedite a self-service experience. Can you make use of API
    connections into a customer information database to retrieve information that
    could shortcut the process or help ensure the successful completion of a task?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to our insurance company to demonstrate how backend processes can
    simplify the user’s journey. Member IDs in this system could be nine or eleven
    digits. Additionally, a nine-digit ID number has a letter at the beginning. Being
    a phone channel experience, several layers of complexity are involved, including
    soliciting alphanumeric information over a voice channel, detecting alphanumeric
    information over a voice channel, and performing a database lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Soliciting alphanumeric information over a voice channel means the user has
    to be told to speak their response or instructed to use the dial pad in a complicated
    way. Detecting alphanumeric information over a voice channel can be error-prone
    due to the similarity in sounds of several alphabetic characters (“B,” “C,” “D,”
    “Z,” etc.) as well as the similarity in sounds between numbers and letters (such
    as “8” and “H”). Figure 8.9 shows the original flow, which had a fairly high failure
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F09_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 The original flow asked a complicated question. Inputs were prone
    to high failure rates.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To reduce complexity for the user, we added a backend process that could detect
    whether the system had received a sufficient number of digits, with or without
    the preceding alpha character. If just the nine digits were detected, we would
    add the alpha character for the user (it is the same for all members). More detailed
    instructions could be provided on a retry. Figure 8.10 shows how the updated backend
    process allowed for a simpler user question.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH08_F10_Freed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 By adding a backend step to perform work for the user, we are able
    to ask a less complex question.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This capability may be expensive to implement, so decisions are often based
    on the cost/benefit analysis of implementing a given capability. (Do you have
    metrics that will help measure this?) Adding this type of complexity can provide
    substantial value, but it also introduces more potential failure points.
  prefs: []
  type: TYPE_NORMAL
- en: For each potential failure point, design the conversation to gracefully handle
    it by providing a next-best alternative or a way to route the user back on track.
    This might include retries (repeating a previous step), allowing the user to try
    a different path to reach their goal, and escalating to an agent.
  prefs: []
  type: TYPE_NORMAL
- en: The type of failure may dictate what happens next. For example, if an input
    requires a ten-digit input but the user only entered nine digits, a retry is appropriate.
    If a backend system is down (causing API failures), retries will be unproductive.
    In such scenarios, it might be best to hand off to a human for manual processing.
    If an account lookup fails when a caller inputs an account number, offer the option
    to look up by a different method, such as by phone number.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Examine your current solution for opportunities to simplify and streamline
    the user journey:'
  prefs: []
  type: TYPE_NORMAL
- en: Does your solution exhibit any of the antipatterns that burden the user with
    unnecessary complexity (see section 8.2.1 for a list)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you make good use of the information that you already know about the user
    and their situation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the conversation follow a logical flow that accommodates a variety of reasonable
    user responses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the solution make use of APIs or backend processes that could facilitate
    or expedite the user or reduce opportunities for user input errors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The less natural a conversation feels, the harder it is for users to successfully
    navigate a complex process using a chatbot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing complexity for the user wherever possible will result in the highest
    containment and task completion rates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rigid or robotic interaction can be disorienting and even sound rude—this
    can be particularly frustrating when the user is engaged in a complex interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Research about your intended user base should inform the design of your conversational
    solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing complexity for the user may mean expanding the functional capabilities
    of your solution, which adds complexity to the chatbot ecosystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
