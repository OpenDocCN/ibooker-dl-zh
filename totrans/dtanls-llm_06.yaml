- en: 5 Analyzing structured data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 分析结构化数据
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Translating questions to queries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问题翻译成查询
- en: Building natural language interfaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自然语言界面
- en: Analyzing data tables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析数据表
- en: Analyzing graph data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析图数据
- en: A significant percentage of the world’s information is stored as structured
    data. Structured data essentially means data stored in a standardized format.
    For example, data tables (e.g., think of the data you would find in an Excel spreadsheet)
    and data describing entities and their relationships as graphs (such as a data
    set describing a social network) are popular types of structured data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上很大一部分信息以结构化数据的形式存储。结构化数据基本上意味着以标准化格式存储的数据。例如，数据表（例如，想想你会在Excel电子表格中找到的数据）和描述实体及其关系的图（例如，描述社交网络的数据集）是流行的结构化数据类型。
- en: Tools for processing structured data have been available for many decades. After
    all, structured data has a standardized format optimized to make it easy for computers
    to process. So why do we need large language models for that? The problem with
    existing tools for processing structured data is their interface. Typically, each
    tool (or, at the very least, each category of tools for specific types of structured
    data) supports its own formal query language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 处理结构化数据的工具已经存在了几十年。毕竟，结构化数据具有标准化的格式，优化了计算机处理它的便捷性。那么，为什么我们需要大型语言模型来处理它呢？现有处理结构化数据工具的问题在于它们的界面。通常，每个工具（或者至少是针对特定类型结构化数据的工具类别）支持自己的正式查询语言。
- en: Using this language, users can often perform a wide range of analysis operations
    on structured data. But learning such query languages takes time! Wouldn’t it
    be nice if all those systems could be queried using a single language, ideally
    in natural language (e.g., plain English)?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语言，用户可以经常对结构化数据进行广泛的操作分析。但学习这种查询语言需要时间！如果所有这些系统都可以使用单一语言进行查询，那该多好啊，最好是自然语言（例如，普通的英语）？
- en: This is where language models come into play. Large language models can translate
    questions in natural language into a wide range of formal languages. So we can
    use them as a universal interface to various data-analysis tools supporting a
    wide range of structured data types. In this chapter, we will build natural language
    query interfaces for different types of structured data. Such interfaces enable
    us (or others) to analyze data by typing questions in natural language. The system
    then translates our questions into formal queries, executes them, and presents
    us with results.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是语言模型发挥作用的地方。大型语言模型可以将自然语言中的问题翻译成各种正式语言。因此，我们可以将它们用作支持广泛结构化数据类型的各种数据分析工具的通用接口。在本章中，我们将为不同类型的结构化数据构建自然语言查询界面。这些界面使我们（或其他人）能够通过在自然语言中键入问题来分析数据。然后，系统将我们的问题翻译成正式查询，执行它们，并展示结果。
- en: 5.1 Chapter outline
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 章节概要
- en: In this chapter, we will be creating several natural language query interfaces.
    In general, a natural language query interface answers questions about data formulated
    in natural language. This chapter considers different types of structured data.
    First, we will create natural language interfaces that answer questions about
    tabular data. After that, we will create one that answers questions about graphs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建几个自然语言查询界面。一般来说，自然语言查询界面可以回答以自然语言形式提出的数据问题。本章考虑了不同类型的结构化数据。首先，我们将创建可以回答关于表格数据问题的自然语言界面。之后，我们将创建一个可以回答关于图的问题的界面。
- en: The principle is the same in both cases. We assume that data is processed using
    a data type–specific tool for data processing. For instance, for tabular data,
    we will use a relational database management system (RDBMS). To analyze graphs,
    we will use a system for managing graph data. Then we will use the large language
    model to translate questions in natural language into the query language supported
    by the specific tool. For instance, for an RDBMS, this is typically the Structured
    Query Language (SQL). Graph database management systems support a variety of graph
    data–specific query languages. We will use the Cypher query language (a language
    describing analysis operations on graph data). We will discuss both languages
    in more detail in the following sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况下的原理是相同的。我们假设数据是通过使用特定数据类型的数据处理工具来处理的。例如，对于表格数据，我们将使用关系数据库管理系统（RDBMS）。要分析图，我们将使用图数据管理系统。然后，我们将使用大型语言模型将自然语言中的问题转换为特定工具支持的查询语言。例如，对于RDBMS，这通常是结构化查询语言（SQL）。图数据库管理系统支持多种图数据特定的查询语言。我们将使用Cypher查询语言（一种描述图数据分析操作的编程语言）。我们将在接下来的章节中更详细地讨论这两种语言。
- en: To translate questions into formal queries, the language model needs access
    to the question (of course), some information about the target language (e.g.,
    do we want to write SQL or Cypher queries?), and some information about the structure
    of the data we are trying to query. For instance, the structure of tabular data
    is characterized by the names of tables, the headers of the columns that appear
    in those tables (hopefully providing some hints on the semantics of data stored
    within them), and the data types of each column (are we storing integer values
    or strings?), among other things. By providing the language model with all of
    these pieces of information, including them in the prompt, the model should be
    able to produce a formal query that captures the semantics of our question.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将问题转换为形式化查询，语言模型需要访问问题（当然），一些关于目标语言的信息（例如，我们是要编写SQL还是Cypher查询？），以及一些关于我们试图查询的数据结构的信息。例如，表格数据的结构由表名、出现在这些表中的列标题（希望提供一些关于存储在其中的数据的语义的提示）以及每列的数据类型（我们是存储整数还是字符串？）等因素来表征。通过向语言模型提供所有这些信息，包括它们在提示中，模型应该能够生成一个形式化查询，捕捉我们问题的语义。
- en: We can process that query using a specialized tool to produce a query result.
    Assuming the query translation was correct, this result will represent an answer
    to the original question. Figure [5.1](#fig__NLQIoverview) illustrates the whole
    process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用专门的工具来处理该查询，生成查询结果。假设查询翻译是正确的，这个结果将代表对原始问题的答案。图[5.1](#fig__NLQIoverview)展示了整个过程。
- en: '![figure](../Images/CH05_F01_Trummer.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH05_F01_Trummer.png)'
- en: Figure 5.1 A natural language query interface translates questions in natural
    language into formal queries, taking into account the data structure. Formal queries
    are then processed on data by a specia- lized tool, generating a query result.
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1 自然语言查询界面将自然语言中的问题转换为形式化查询，考虑到数据结构。然后，通过一个专门的工具在数据上处理形式化查询，生成查询结果。
- en: Why do we need external tools?
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们为什么需要外部工具？
- en: We have seen that language models can solve a variety of tasks. So why not simply
    use language models to analyze structured data directly? Why do we rely on external
    tools to do so and use the language model merely as a translator?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到语言模型可以解决各种任务。那么，为什么不直接使用语言模型来分析结构化数据呢？为什么我们依赖外部工具来完成这项任务，而仅仅将语言模型作为翻译器使用呢？
- en: The primary reason is efficiency. Using large language models is expensive,
    and, at least for large data sets, the size of the data can easily exceed the
    maximum input size of the language model. Hence, relying on existing tools that
    can deal with large structured data sets seems like a better idea.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是效率。使用大型语言模型成本高昂，至少对于大型数据集来说，数据的大小很容易超过语言模型的最大输入大小。因此，依赖能够处理大型结构化数据集的现有工具似乎是一个更好的主意。
- en: Warning In the following sections, we use language models to write commands
    for data processing. Although language models work astonishingly well in many
    cases, never rely on them to generate correct results in every single scenario.
    In some cases, language models may write incorrect queries. Other times, they
    may write commands to change or delete your data or alter your system setup. Always
    keep a backup of important data before enabling data access via language models.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在以下章节中，我们使用语言模型来编写数据处理命令。尽管语言模型在很多情况下工作得非常出色，但永远不要依赖它们在所有单一场景中生成正确的结果。在某些情况下，语言模型可能会编写错误的查询。其他时候，它们可能会编写更改或删除你的数据或更改你的系统设置的命令。在通过语言模型启用数据访问之前，始终备份重要数据。
- en: 5.2 A natural language query interface for analyzing game sales
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 为分析游戏销售的自然语言查询界面
- en: We’re back at Banana, where you realize that your boss happens to be a computer
    games enthusiast. Your boss not only likes to spend the evenings playing but also
    loves analyzing data about computer games. Having recently obtained a data set
    about computer game sales, your boss is seeking to extract interesting statistics.
    SQL is the language of choice for analyzing tabular data, but your boss does not
    feel comfortable writing SQL queries. Knowing about your expertise with regard
    to language models and data analysis, your boss asks whether it would be possible
    to build an interface that translates questions about computer games into corresponding
    SQL queries. After thinking about it, you realize that this could be a fun project
    that can be realized easily with language models. Let’s get started!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了香蕉公司，在这里你意识到你的老板竟然是个电脑游戏爱好者。你的老板不仅喜欢在晚上玩游戏，而且还热衷于分析电脑游戏的数据。最近，你的老板获得了一份数据集，关于电脑游戏的销售情况，他正寻求提取有趣的统计数据。SQL是分析表格数据的语言，但你的老板并不觉得写SQL查询很自在。了解到你在语言模型和数据分析方面的专业知识，你的老板询问是否有可能构建一个将关于电脑游戏的问题翻译成相应的SQL查询的界面。经过思考，你意识到这可能是一个有趣的项目，而且可以用语言模型轻松实现。让我们开始吧！
- en: 5.2.1 Setting up an SQLite database
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 设置SQLite数据库
- en: Before we can analyze tabular data using SQL queries, we first must load that
    data into an RDBMS, a tool for processing data tables efficiently. In this subsection,
    we’ll see how to load data about computer games into SQLite, a popular RDBMS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用SQL查询分析表格数据之前，我们首先必须将数据加载到RDBMS中，这是一个用于高效处理数据表的工具。在本小节中，我们将了解如何将关于电脑游戏的数据加载到SQLite中，这是一个流行的RDBMS。
- en: 'As a first step, make sure SQLite is installed. We will be using SQLite version
    3 in this section. You can check whether SQLite 3 is installed by typing the following
    in your terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，确保SQLite已安装。在本节中，我们将使用SQLite版本3。你可以在终端中输入以下内容来检查SQLite 3是否已安装：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you receive a message like this one, no further installation is necessary:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到这样的消息，则不需要进一步安装：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you see an error message, go to [www.sqlite.org/download.html](http://www.sqlite.org/download.html).
    Select the version that is consistent with your operating system, download all
    the relevant files, and follow the instructions to install SQLite. In case of
    problems, click the SQLite Installation item in the chapter 5 section of the book’s
    companion website. You will find detailed instructions for how to install SQLite
    on different platforms. Afterward, run the previous command to ensure that SQLite
    is installed properly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到错误消息，请访问[www.sqlite.org/download.html](http://www.sqlite.org/download.html)。选择与你的操作系统一致的版本，下载所有相关文件，并按照说明安装SQLite。如果遇到问题，请点击书中配套网站第5章部分的“SQLite安装”项目。你将找到如何在不同平台上安装SQLite的详细说明。之后，运行之前的命令以确保SQLite已正确安装。
- en: 'Next, we want to create a relational database using SQLite. A relational database
    is essentially a collection of data tables. You can think of each data table as
    a simple spreadsheet. We have named table columns associated with a data type
    and (possibly many) table rows that contain values for each of the columns. For
    instance, table [5.1](#tab__videogames) contains information about video games,
    and each row represents one game. The table has four columns: `Name`, `Platform`,
    `Year`, and `Genre`. Three of the columns (`Name`, `Platform`, and `Genre`) contain
    strings (i.e., text). The column `Year` contains numbers (representing the year
    in which a game was released).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要使用 SQLite 创建一个关系型数据库。关系型数据库本质上是一组数据表。你可以将每个数据表想象成一个简单的电子表格。我们已命名与数据类型关联的表列，以及（可能很多）包含每列值的表行。例如，表
    [5.1](#tab__videogames) 包含有关视频游戏的信息，每一行代表一个游戏。该表有四个列：`名称`、`平台`、`年份`和`类型`。其中三个列（`名称`、`平台`和`类型`）包含字符串（即文本）。`年份`列包含数字（表示游戏发布的年份）。
- en: Table 5.1 Sample of data table. Each table row describes one video game.
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1 数据表样本。每一行表描述一个视频游戏。
- en: '| **Name** | **Platform** | **Year** | **Genre** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **平台** | **年份** | **类型** |'
- en: '| Wii Sports | Wii | 2006 | Sports |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Wii Sports | Wii | 2006 | 体育 |'
- en: '| Super Mario Bros. | NES | 1985 | Platform |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 超级马里奥兄弟 | NES | 1985 | 平台 |'
- en: '| Mario Kart Wii | Wii | 2008 | Racing |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 马里奥赛车 WII | WII | 2008 | 赛车 |'
- en: '| Wii Sports Resort | Wii | 2009 | Sports |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Wii Sports Resort | Wii | 2009 | 体育 |'
- en: '| Pokemon Red/Pokemon Blue | GB | 1996 | Role-Playing |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 宝可梦红/宝可梦蓝 | GB | 1996 | 角色扮演 |'
- en: Table [5.1](#tab__videogames) shows a small sample of a data set you can find
    on the book’s companion website (look for the Games item in the chapter 5 section).
    We will use that data set in the following sections to create a natural language
    query interface, enabling users to analyze it with natural language commands.
    But first, we need to load that data into the SQLite database system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 [5.1](#tab__videogames) 展示了可以在本书配套网站上找到的数据集的小样本（在第五章部分查找“游戏”项）。我们将在以下部分使用该数据集来创建一个自然语言查询界面，使用户能够使用自然语言命令进行分析。但首先，我们需要将那些数据加载到
    SQLite 数据库系统中。
- en: Tip We’ll go over all the steps required to load tabular data into SQLite. This
    is useful if you want to load data other than that discussed here. If you don’t
    want to create your own database, you can skip this section and download games.db
    from the book’s companion website instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们将介绍将表格数据加载到 SQLite 所需的所有步骤。如果你想要加载这里未讨论的数据，这很有用。如果你不想创建自己的数据库，你可以跳过这一部分，而是从本书的配套网站上下载
    games.db。
- en: 'Let’s start the SQLite command-line interface. Enter the following command
    in the terminal, and press Enter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始 SQLite 命令行界面。在终端中输入以下命令，然后按 Enter 键：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command creates a new database stored in the file games.db. At the same
    time, it opens the SQLite command-line interface. Now we can instruct the SQLite
    tool to load the data set we will use in the following sections. First we have
    to tell SQLite a little about the structure of the data. We want to load an extended
    version of table [5.1](#tab__videogames) containing additional columns. Run the
    following command to describe the structure of the data:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个存储在文件 games.db 中的新数据库，并同时打开 SQLite 命令行界面。现在我们可以指示 SQLite 工具加载我们将在以下部分使用的数据集。首先，我们必须告诉
    SQLite 有关数据结构的一些信息。我们想要加载包含额外列的表 [5.1](#tab__videogames) 的扩展版本。运行以下命令来描述数据的结构：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Table name'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 表名'
- en: '#2 List of table columns'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 表列列表'
- en: This command describes the structure of a single table named `games` (**1**)
    (because it will store information about video games); in parentheses, we specify
    the full list of columns in the table (separated by commas) (**2**). Each column
    is defined by the column name (e.g., `rank`, `name`, or `genre`) followed by the
    column type. For example, `int` means the column stores integer numbers, whereas
    `text` means the column stores text data. All table rows must provide values for
    each column of the appropriate data type.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令描述了一个名为 `games` 的单个表的结构（**1**）（因为它将存储有关视频游戏的信息）；在括号中，我们指定了表中列的完整列表（用逗号分隔）(**2**）。每个列由列名（例如，`rank`、`name`
    或 `genre`）后跟列类型定义。例如，`int` 表示该列存储整数，而 `text` 表示该列存储文本数据。所有表行必须为每个列提供适当数据类型的值。
- en: 'After defining the table structure, we can load data into the table from the
    .csv file under Games on the book’s website. Download the file if you haven’t
    already. We will assume that the file is stored in the folder /Downloads/videogames.csv
    for the following commands. Simply replace that path with the file path on your
    system. Load the data using the following command (still in the SQLite interface):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义表结构后，我们可以从书籍网站上的 Games 下的 .csv 文件加载数据到表中。如果你还没有下载，请下载该文件。以下命令将假设文件存储在文件夹
    /Downloads/videogames.csv 中。只需将此路径替换为你的系统上的文件路径。使用以下命令加载数据（仍在 SQLite 接口内）：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Sets CSV mode'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 设置 CSV 模式'
- en: '#2 Imports the data'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 导入数据'
- en: 'The first command prepares SQLite to load data from a .csv file (which applies
    to the file we want to load) (**1**). The next command (**2**) imports the data:
    the first parameter is the path to the file we want to load data from, and the
    second parameter is the name of the data table we want to load the file into.
    In this case, we reference the table whose structure we defined before (`games`).
    To test whether the data was loaded successfully (which should be the case if
    you don’t see an error message), run the following command in SQLite:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令使 SQLite 准备从 .csv 文件加载数据（这适用于我们想要加载的文件）(**1**)。下一个命令(**2**)导入数据：第一个参数是我们想要从其加载数据的文件路径，第二个参数是我们想要将文件加载到其中的数据表名称。在这种情况下，我们引用的是我们之前定义的结构表（`games`）。为了测试数据是否成功加载（如果没有错误信息，应该就是这种情况），请在
    SQLite 中运行以下命令：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should see the result `16599` if all the data was loaded. If you see a lower
    number, check for error messages in the SQLite output. You can quit the SQLite
    console via the command `.quit` (don’t forget to prefix your command with a dot
    to make it work). For the following sections, we will assume that the data has
    been loaded and is stored in an SQLite file called games.db.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有数据都已加载，你应该看到结果 `16599`。如果你看到一个更小的数字，请检查 SQLite 输出中的错误信息。你可以通过命令 `.quit`
    退出 SQLite 控制台（别忘了在命令前加上点以使其生效）。对于以下部分，我们将假设数据已经加载并存储在一个名为 games.db 的 SQLite 文件中。
- en: 5.2.2 SQL basics
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 SQL 基础知识
- en: Sure, we can use the language model to translate questions to SQL queries (which
    are understood by SQLite). But can we trust its translations? Thinking more about
    it, you realize that it wouldn’t hurt to have at least some SQL basics to verify
    the output of the language model before presenting the interface to your boss.
    That’s what we’ll do in this section. A full introduction to SQL is, of course,
    beyond the scope of this book. Have a look at the website [www.databaselecture.com](http://www.databaselecture.com)
    to get a more detailed introduction by this book’s author. We’ll discuss a few
    SQL basics in this section that help implement our natural language query interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用语言模型将问题翻译成 SQL 查询（SQLite 可以理解这些查询）。但我们能信任它的翻译吗？再深入思考一下，你会意识到在向老板展示界面之前，至少有一些
    SQL 基础知识来验证语言模型的输出是有益的。这就是我们将在本节中做的事情。当然，本节不会全面介绍 SQL。你可以查看网站 [www.databaselecture.com](http://www.databaselecture.com)，以获取本书作者的更详细介绍。在本节中，我们将讨论一些有助于实现我们的自然语言查询界面的
    SQL 基础知识。
- en: SQL queries are used to analyze data tables. Query results may be derived from
    a single table or by combining data from multiple tables. In our example database,
    created in the last section, we have a single table. Using SQL queries, we can,
    for instance, count rows with certain properties (e.g., all games by the same
    publisher), filter data (e.g., only show games that were released in 2017), or
    perform various aggregate operations (e.g., for each publisher, calculate the
    average earnings per game).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 查询用于分析数据表。查询结果可能来自单个表，或者通过组合多个表的数据得出。在我们的示例数据库中，如上一节创建的，我们只有一个表。使用 SQL 查询，我们可以，例如，计算具有特定属性（例如，同一发行商的所有游戏）的行数，过滤数据（例如，仅显示
    2017 年发布的游戏），或执行各种聚合操作（例如，对于每个发行商，计算每款游戏的平均收入）。
- en: 'An SQL query generally describes a table to generate (using data that is already
    available in the database). Most example queries in this section have the following
    structure:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 查询通常描述一个要生成的表（使用数据库中已存在的数据）。本节中的大多数示例查询具有以下结构：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 SELECT clause'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 SELECT 子句'
- en: '#2 FROM clause'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 FROM 子句'
- en: '#3 WHERE clause'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 WHERE 子句'
- en: 'The `FROM` clause (**2**) (the code following the `FROM` keyword and before
    the `WHERE` keyword) describes the source data used for analysis. For instance,
    the `FROM` clause can contain a list of table names separated by commas. In our
    example database, we have only a single table to process (for advanced queries,
    the same table name may appear multiple times in the `FROM` clause, creating different
    copies of the same table). The queries we will encounter in the following sections
    will contain a single entry in the `FROM` clause: the `games` table.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`子句（**2**）（在`FROM`关键字之后和`WHERE`关键字之前的代码）描述了用于分析的源数据。例如，`FROM`子句可以包含一个由逗号分隔的表名列表。在我们的示例数据库中，我们只有一个要处理的表（对于高级查询，相同的表名可能在`FROM`子句中多次出现，创建相同表的多个副本）。我们将在以下章节中遇到的查询将在`FROM`子句中包含一个条目：`games`表。'
- en: The `WHERE` clause (**3**) defines predicates on the tables that appear in the
    `FROM` clause. For instance, it may contain a condition restricting the scope
    to games from a certain publisher. The `WHERE` clause can contain simple conditions
    (i.e., conditions that can be expressed by an equality or inequality on a table
    column) as well as complex conditions (connecting multiple simple conditions by
    `AND` or `OR` operators). Those conditions are used to filter rows from the tables
    in the `FROM` clause. Rows that do not satisfy the condition in the `WHERE` clause
    are discarded and do not appear in the query result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`子句（**3**）定义了`FROM`子句中出现的表上的谓词。例如，它可能包含一个条件，将范围限制为来自某个出版商的游戏。`WHERE`子句可以包含简单条件（即可以通过表列上的等式或不等式表示的条件）以及复杂条件（通过`AND`或`OR`运算符连接多个简单条件）。这些条件用于从`FROM`子句中的表中过滤行。不满足`WHERE`子句中条件的行将被丢弃，不会出现在查询结果中。'
- en: 'Finally, we specify the columns of the desired result table in the `SELECT`
    clause (**1**). More precisely, we specify a list of column definitions separated
    by commas. Columns may be defined by a column name (a column that appears in one
    of the tables in the `FROM` clause) or by a more complex expression: for example,
    an arithmetic expression connecting multiple columns. Alternatively, we can specify
    aggregates such as `count(*)` in the `SELECT` clause (the latter aggregate counts
    the number of rows). The query result contains a table with the specified columns,
    filling them with content corresponding to the column definition.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`SELECT`子句中指定所需结果表的列（**1**）。更确切地说，我们指定一个由逗号分隔的列定义列表。列可以通过列名（出现在`FROM`子句中的一个表中）或更复杂的表达式来定义：例如，连接多个列的算术表达式。或者，我们可以在`SELECT`子句中指定聚合，如`count(*)`（后者聚合计算行数）。查询结果包含一个具有指定列的表，并用与列定义相对应的内容填充这些列。
- en: 'For instance, let’s say we want to count all games published in 2017\. In this
    case, our query result should contain a single column with a count aggregate.
    Also, our `WHERE` clause should contain a filter condition restricting our scope
    to games from 2017\. Our `FROM` clause contains, of course, the name of the only
    table in our database (`games`). The following query generates the desired result:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要计算2017年发布的所有游戏。在这种情况下，我们的查询结果应包含一个包含计数聚合的单列。此外，我们的`WHERE`子句应包含一个过滤条件，将我们的范围限制为2017年的游戏。当然，我们的`FROM`子句包含我们数据库中唯一的表名（`games`）。以下查询生成了所需的结果：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To make things a little more complex, let’s assume that we want to calculate
    the combined number of sales in Europe and Japan for all games released in 2017
    by a specific publisher (Activision). Our desired query result contains two columns:
    the name of the game and the sales count. As our data table features two columns
    with sales in Europe and sales in Japan (`eusales` and `japansales`, as per our
    table definition in the previous section), we can describe the desired result
    column by adding them (`eusales + japansales`). Because we want to restrict our
    scope to games from 2017 and from Activision, we can use a complex predicate in
    the `WHERE` clause: `year = 2017 AND publisher = Activision`. Note the use of
    apostrophes around the name Activision—we need to use apostrophes to delimit strings
    in query conditions instead of numbers. The following query generates the desired
    result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情变得稍微复杂一些，假设我们想要计算 2017 年由特定发行商（Activision）发布的所有游戏的欧洲和日本的销售额总和。我们期望的查询结果包含两个列：游戏名称和销售额。由于我们的数据表有两个包含欧洲和日本销售额的列（`eusales`
    和 `japansales`，如前节中我们的表定义所示），我们可以通过将它们相加来描述期望的结果列（`eusales + japansales`）。因为我们想将范围限制在
    2017 年和 Activision 的游戏上，我们可以在 `WHERE` 子句中使用一个复杂的谓词：`year = 2017 AND publisher
    = Activision`。注意在 Activision 名称周围使用引号——我们需要使用引号来限定查询条件中的字符串而不是数字。以下查询生成了期望的结果：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Optionally, when specifying aggregates, we can calculate those aggregates for
    different groups of rows defined by shared values in certain columns. To do so,
    we add a final `GROUP BY` clause to the previous query template, followed by a
    comma-separated list of columns used to form groups. For instance, let’s assume
    that we want to calculate game sales for each genre (such as strategy or action)
    separately. We can use the following query to return one row with aggregates for
    each category of games (note that we add the `genre` column in the `SELECT` clause
    as well to ensure that we can associate numbers with the correct genre):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，当指定聚合时，我们可以根据某些列中共享的值计算不同行组的聚合。为此，我们在之前的查询模板中添加一个最终的 `GROUP BY` 子句，后面跟着一个用逗号分隔的列列表，这些列用于形成组。例如，假设我们想要分别计算每个游戏类型（如策略或动作）的游戏销售额。我们可以使用以下查询来返回每个游戏类别的聚合行（注意，我们在
    `SELECT` 子句中也添加了 `genre` 列，以确保我们可以将数字与正确的游戏类型关联起来）：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The SQL primer in this section is clearly insufficient to write your own SQL
    queries, except for a few simple cases. However, we don’t really want to write
    our own SQL queries—we want to rely on the language model instead! This introduction
    should enable you to understand queries generated by the language model at a high
    level of abstraction. And observing how the language model maps questions to queries
    may be a good way to get started with learning SQL yourself. In the next section,
    we will start by creating a simple translator, translating questions into SQL
    queries on the `games` database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的 SQL 入门知识显然不足以让你编写自己的 SQL 查询，除非是少数简单的情况。然而，我们实际上并不想编写自己的 SQL 查询——我们更希望依赖语言模型！本介绍应该能让你从高层次抽象上理解语言模型生成的查询。观察语言模型如何将问题映射到查询上，可能是自学
    SQL 的一个好方法。在下一节中，我们将从创建一个简单的翻译器开始，将问题翻译成对 `games` 数据库的 SQL 查询。
- en: 5.2.3 Overview
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 概述
- en: Having acquired a few SQL basics to check the output of the language model,
    we will now work on our text-to-SQL translator. We will use our translator via
    the command line. We specify a question as input and ideally want an SQL query,
    translating our question as output. If we run the output query in SQLite, we should
    get the answer to our original question. Of course, this interface is manual and
    not very convenient to use. Ideally, we would like it to execute queries automatically
    and show the corresponding results directly in our query interface. We will create
    such an interface in the following section. For now, we just focus on the core
    problem of translating questions into queries. Also, for the moment, our only
    goal is to translate questions about computer games. Therefore, we will hardcode
    the structure of the target database. Again, we will generalize that in our next
    project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了一些SQL基础知识以检查语言模型的输出后，我们现在将致力于我们的文本到SQL翻译器。我们将通过命令行使用我们的翻译器。我们指定一个问题作为输入，理想情况下我们希望得到一个SQL查询，将我们的问题作为输出进行翻译。如果我们运行输出查询在SQLite中，我们应该得到我们原始问题的答案。当然，这个接口是手动的，并不非常方便使用。理想情况下，我们希望它能自动执行查询并直接在我们的查询界面中显示相应的结果。我们将在下一节创建这样的接口。现在，我们只关注将问题翻译成查询的核心问题。此外，目前我们的唯一目标是翻译关于电脑游戏的问题。因此，我们将硬编码目标数据库的结构。我们将在下一个项目中将其通用化。
- en: Internally, to translate the input question, we will first create a prompt.
    This prompt describes the translation task and contains all relevant details for
    translation (e.g., the structure of our target database). Sending this prompt
    to the language model should result, in most cases, in a correctly translated
    SQL query. We may still need to do a little work to extract this query from potentially
    overly verbose output generated by the language model. Let’s discuss these steps
    in more detail, starting with the prompts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 内部来说，为了翻译输入的问题，我们首先创建一个提示。这个提示描述了翻译任务，并包含翻译所需的所有相关细节（例如，我们目标数据库的结构）。将这个提示发送给语言模型，在大多数情况下，应该会得到一个正确翻译的SQL查询。我们可能还需要做一些工作来从语言模型生成的可能过于冗长的输出中提取这个查询。让我们更详细地讨论这些步骤，从提示开始。
- en: 5.2.4 Generating prompts for text-to-SQL translation
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 生成文本到SQL翻译的提示
- en: What information do we need to convey to the language model for a successful
    translation? Clearly, we need to specify the question we want to translate. Also,
    we need to specify the target system (SQLite) and describe the structure of the
    target database. For the moment, we hardcode the database structure. We can simply
    provide the language model with the table definition (`create table...`) that
    we used in section [5.2.1](#sec__createsqlitedb). The language model will understand
    how this command maps to a table structure. By sending a prompt with instructions
    for translation to the model containing all of the previously mentioned types
    of information, the language model should be able to produce a corresponding SQL
    query.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向语言模型传达哪些信息才能实现成功的翻译？显然，我们需要指定我们想要翻译的问题。此外，我们还需要指定目标系统（SQLite）并描述目标数据库的结构。目前，我们硬编码数据库结构。我们可以简单地向语言模型提供我们在第
    [5.2.1](#sec__createsqlitedb) 节中使用的表定义（`create table...`）。语言模型将理解这个命令如何映射到表结构。通过向模型发送包含所有之前提到的信息类型的提示，语言模型应该能够生成相应的SQL查询。
- en: 'Let’s use the following prompt template:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下提示模板：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 Database description'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 数据库描述'
- en: '#2 Task description'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 任务描述'
- en: '#3 Question to translate'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 要翻译的问题'
- en: 'This prompt template contains all the pieces of information described earlier.
    First, it describes the target database (**1**) by providing the SQL commands
    used to create the associated tables (in this case, a single table). Note that
    this is not a placeholder because, for the moment, our query interface only needs
    to work for one database (whose structure we hardcode in the template). Next,
    the prompt template contains a task description (**2**): the goal is to translate
    questions into SQL queries. Finally, the template contains the question to translate
    (**3**). Here, we use a placeholder (indicated by square brackets). This enables
    us to use the same prompt template for various questions our boss may ask about
    the data.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此提示模板包含之前描述的所有信息片段。首先，它通过提供创建相关表（在这种情况下，一个单独的表）所使用的 SQL 命令来描述目标数据库（**1**）。请注意，这不仅仅是一个占位符，因为目前我们的查询接口只需要为一个数据库（我们在模板中硬编码其结构）工作。接下来，提示模板包含一个任务描述（**2**）：目标是把问题转换为
    SQL 查询。最后，模板包含要转换的问题（**3**）。在这里，我们使用一个占位符（由方括号表示）。这使得我们可以使用相同的提示模板来处理老板可能提出的关于数据的各种问题。
- en: 'The following code generates prompts according to the previous template:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码根据之前的模板生成提示：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Adds the database description'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 添加数据库描述'
- en: '#2 Adds the task description'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 添加任务描述'
- en: '#3 Adds the question to translate'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 添加要转换的问题'
- en: '#4 Returns the concatenation'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 返回连接结果'
- en: Given the question to translate as input, the code adds the description of the
    database (**1**), then instructions for translation (**2**), and finally the question
    to translate (**3**). The result is the concatenation of all the prompt parts
    (**4**).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 给定要转换的问题作为输入，代码添加数据库描述（**1**），然后是翻译说明（**2**），最后是转换的问题（**3**）。结果是所有提示部分的连接（**4**）。
- en: 5.2.5 Complete code
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 完整代码
- en: The next listing contains the full code for our natural language query interface.
    It uses the prompt-generation function discussed earlier (**1**), as well as the
    function invoking the language model (**2**) that we already know from prior chapters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表包含我们自然语言查询接口的完整代码。它使用之前讨论的提示生成函数（**1**），以及我们在前几章中已经了解的调用语言模型的函数（**2**）。
- en: Listing 5.1 Translating questions about video games into SQL queries
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1 将关于视频游戏的问题转换为 SQL 查询
- en: '[PRE12]|sql(.*)\verb|[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]|sql(.*)\verb|[PRE13]'
- en: '#1 Generates a prompt for translation'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 生成翻译提示'
- en: '#2 Invokes the language model'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 调用语言模型'
- en: '#3 Reads a query and translates it to SQL'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 读取查询并将其转换为 SQL'
- en: '#4 Generates a prompt'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 生成提示'
- en: '#5 Generates an answer'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 生成答案'
- en: '#6 Extracts an SQL query from the answer'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 从答案中提取 SQL 查询'
- en: This listing reads a question about computer games from the command line (**3**).
    Using the input question, it generates a prompt (**4**) that instructs the language
    model to translate the question into an SQL query. It sends the prompt to the
    language model and receives its answer (**5**).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表从命令行读取关于计算机游戏的问题（**3**）。使用输入问题，它生成一个提示（**4**），指示语言模型将问题转换为 SQL 查询。它将提示发送到语言模型并接收其答案（**5**）。
- en: The raw answer from GPT-4o typically contains explanations interleaved with
    the SQL query we are ultimately interested in. To get the query alone, we have
    to extract it from the raw answer (**6**). Here, we exploit the fact that GPT-4o
    encloses SQL queries between the markers [PRE14]sql [PRE15]` [PRE16]` (when interacting
    with GPT models via the ChatGPT web interface, the content between those markers
    is rendered as a code box). The regular expression [PRE17]sql(.*)[PRE18]` matches
    the SQL query between the markers, using the Python function `re.findall` to return
    a list of matches for this regular expression (the `re.DOTALL` flag is required
    to ensure that the dot matches all characters, including newlines, which may appear
    in SQL queries). We use the first of those matches as our query (i.e., we implicitly
    assume that at least one match is returned and that the first match is suitable).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GPT-4o 的原始答案通常包含与我们所感兴趣的 SQL 查询交织的解释。为了得到查询本身，我们必须从原始答案中提取它（**6**）。在这里，我们利用
    GPT-4o 在 [PRE14]sql [PRE15]` [PRE16]` 标记之间包围 SQL 查询的事实（当通过 ChatGPT 网页界面与 GPT 模型交互时，那些标记之间的内容会显示为代码框）。正则表达式
    [PRE17]sql(.*)[PRE18]` 匹配标记之间的 SQL 查询，使用 Python 函数 `re.findall` 返回该正则表达式的匹配列表（需要
    `re.DOTALL` 标志以确保点匹配所有字符，包括可能出现在 SQL 查询中的换行符）。我们使用这些匹配中的第一个作为我们的查询（即，我们隐含地假设至少返回一个匹配项，并且第一个匹配项是合适的）。
- en: 5.2.6 Trying it out
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.6 尝试运行
- en: 'Okay! Time to try our text-to-SQL translator! In the terminal, switch to the
    directory containing the Python code. We will assume that the code is stored in
    a file called listing1.py (which you can download from the companion website).
    Run the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在是时候尝试我们的文本到SQL翻译器了！在终端中，切换到包含Python代码的目录。我们将假设代码存储在一个名为`listing1.py`的文件中（你可以从配套网站上下载）。运行以下命令：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As a result, you should obtain the following SQL query:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该获得以下SQL查询：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Is that query correct? Let’s find out: in the terminal, switch to the repository
    containing the SQLite database file (games.db). Then, open the database via the
    SQLite command-line interface:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询正确吗？让我们来看看：在终端中，切换到包含SQLite数据库文件（games.db）的仓库。然后，通过SQLite命令行界面打开数据库：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can finally try the query generated by our text-to-SQL translator. Enter
    the query, and press Enter. You should see the number of games stored in the database:
    16,599.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以最终尝试由我们的文本到SQL翻译器生成的查询。输入查询，然后按Enter键。你应该看到数据库中存储的游戏数量：16,599。
- en: You may want to try a few other questions. For example, see whether you can
    count the number of games by specific publishers or games of a specific genre!
    Chances are, for most questions referring to this simple database, GPT-4o should
    be capable enough to provide an accurate translation. Your boss will be happy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想尝试其他几个问题。例如，看看你是否能按特定出版商或特定类型的游戏来计算游戏数量！对于大多数涉及这个简单数据库的问题，GPT-4o应该足够强大，能够提供准确的翻译。你的老板会很高兴的。
- en: The interface we created in this section is still limited in various ways. First,
    you have to reexecute the program for each new question. Second, you have to manually
    copy and execute each translated query into the database system interface. Third,
    and most importantly, if you ever want to switch to a different data set, you
    will have to manually change your prompt template. In the next section, we’ll
    see how to overcome these restrictions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们创建的界面在多个方面仍然有限。首先，你必须为每个新问题重新执行程序。其次，你必须手动复制并执行每个翻译后的查询到数据库系统界面中。第三，也是最重要的一点，如果你想要切换到不同的数据集，你必须手动更改你的提示模板。在下一节中，我们将看到如何克服这些限制。
- en: 5.3 A general natural language query interface
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 通用自然语言查询界面
- en: Your boss is happy with the new natural language interface and regularly shares
    interesting insights about computer game sales with you. However, you can’t help
    but wonder whether this use case alone exploits the full potential of your approach.
    For instance, the human resources unit at Banana regularly deals with complex
    questions on tables storing employee information. Couldn’t we generalize our natural
    language interface to help them as well? In this section, we’ll generalize the
    natural language query interface to work with arbitrary databases without requiring
    any changes to the code itself. Furthermore, we will make the interface more convenient
    by executing the translated queries directly and avoiding restarts between different
    questions on the same data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你的老板对新的自然语言界面很满意，并经常与你分享关于电脑游戏销售的有趣见解。然而，你忍不住想知道，仅此用例是否充分利用了你的方法。例如，Banana的人力资源部门经常处理存储员工信息的表上的复杂问题。我们能否将我们的自然语言界面推广到帮助他们？在本节中，我们将推广自然语言查询界面以与任意数据库一起工作，而无需对代码本身进行任何更改。此外，我们将通过直接执行翻译后的查询并避免在同一数据的不同问题之间重启来使界面更加方便。
- en: 5.3.1 Executing queries
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 执行查询
- en: As a first step, let’s see how we can execute translated queries directly from
    Python. This will avoid tediously copying queries from one interface to another.
    In Python, we can execute queries on an SQLite database using the `sqlite3` library.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们看看我们如何可以直接从Python执行翻译后的查询。这将避免从一种界面到另一种界面的繁琐查询复制。在Python中，我们可以使用`sqlite3`库在SQLite数据库上执行查询。
- en: 'Let’s assume that the variable `data_path` stores the path to the database
    file. To execute queries on that database, we must first create a connection:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设变量`data_path`存储了数据库文件的路径。要在此数据库上执行查询，我们必须首先创建一个连接：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now execute SQL queries on the database via the `connection` object.
    Let’s assume that the SQL query we want to execute is stored in the variable `query`.
    After connecting to the database, we first create a cursor object (enabling querying
    and result retrieval) and then use it to execute the query:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过`connection`对象在数据库上执行SQL查询。假设我们想要执行的SQL查询存储在变量`query`中。连接到数据库后，我们首先创建一个游标对象（启用查询和结果检索），然后使用它来执行查询：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After execution, we can get a list of result rows by calling `cursor.fetchall()`.
    We’ll put everything together in a function that takes two parameters—the path
    to the database and a query to execute on it—as input, returning the query result
    in a string representation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们可以通过调用 `cursor.fetchall()` 获取结果行的列表。我们将所有内容组合在一个函数中，该函数接受两个参数——数据库的路径和要执行的查询——作为输入，并以字符串形式返回查询结果：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Connects to the database'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 连接到数据库'
- en: '#2 Creates the cursor'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建光标'
- en: '#3 Executes a query'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 执行一个查询'
- en: '#4 Retrieves the query result'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 获取查询结果'
- en: '#5 Transforms to a list of strings'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 转换为字符串列表'
- en: '#6 Concatenates result rows'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 连接结果行'
- en: After connecting to the target database (**1**), the function creates a cursor
    (**2**), executes the input query (**3**), and retrieves the query result (**4**).
    After casting the result tuples into a string representation (**5**), we concatenate
    the result rows, separated by newline symbols (**6**).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到目标数据库（**1**）后，函数创建一个光标（**2**），执行输入查询（**3**），并检索查询结果（**4**）。在将结果元组转换为字符串表示（**5**）后，我们连接结果行，用换行符分隔（**6**）。
- en: 5.3.2 Extracting the database structure
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 提取数据库结构
- en: We want an interface that works for arbitrary SQLite databases without having
    to change the code. This means we need to extract the structure of the current
    database (information about its tables and columns) automatically.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个适用于任意 SQLite 数据库的接口，而无需更改代码。这意味着我们需要自动提取当前数据库的结构（关于其表和列的信息）。
- en: 'For SQLite, we can extract the structure of a database by executing SQL queries.
    These queries access a special table: the *schema table*. This table is created
    automatically (i.e., we do not need to create it by hand). Among other things,
    this table contains the SQL commands used to create other tables in a database.
    We can use them as a concise description of the database structure, suitable as
    input to the language model.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQLite，我们可以通过执行 SQL 查询来提取数据库的结构。这些查询访问一个特殊表：模式表。这个表是自动创建的（即，我们不需要手动创建它）。这个表包含创建数据库中其他表的
    SQL 命令。我们可以使用它们作为数据库结构的简洁描述，适合作为语言模型的输入。
- en: 'We can access the schema table via the table name `sqlite_master`. This table
    contains a column named `sql` with information about queries used to create objects
    inside the database. Specifically, we are interested in SQL commands used to create
    tables. Those queries contain crucial information for query translation, including
    the names and types of the columns that belong to the table created by the query.
    The following query retrieves all SQL statements used to create tables in the
    current database:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过表名 `sqlite_master` 访问模式表。这个表包含一个名为 `sql` 的列，其中包含有关在数据库内部创建对象所使用的查询的信息。具体来说，我们感兴趣的是用于创建表的
    SQL 命令。这些查询包含查询翻译的关键信息，包括属于由查询创建的表的列的名称和类型。以下查询检索了当前数据库中用于创建表的全部 SQL 语句：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So all we need to do is execute this query from Python. Fortunately, we already
    know how to do that from the previous section. Given the path to a database, the
    following function returns a text describing the queries used to create all the
    tables in the database:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们所需做的就是从 Python 中执行此查询。幸运的是，我们已经从上一节中知道了如何执行。给定数据库的路径，以下函数返回一个描述用于创建数据库中所有表的查询的文本：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Connects to the database'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 连接到数据库'
- en: '#2 Creates a cursor'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建一个光标'
- en: '#3 Accesses schema table'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 访问模式表'
- en: '#4 Retrieves results'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 获取结果'
- en: '#5 Retrieves SQL strings'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 获取 SQL 字符串'
- en: '#6 Concatenates SQL strings'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 连接 SQL 字符串'
- en: Again, we create a connection (**1**) and a corresponding cursor object (**2**).
    Next, we issue a query to the schema table to retrieve all SQL queries used to
    create tables in the current database (**3**). We fetch the results (**4**) and
    extract the SQL strings from the query result (**5**). Note that this part of
    the function differs slightly from the generic function for executing queries,
    discussed in the previous section. By extracting the values for the first (and,
    for this specific query, only) field of each row, we get rid of unnecessary delimiters
    between rows that would otherwise show up in our output (and, later, in our prompts).
    The result is the concatenation of all the result rows (**6**).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们创建一个连接（**1**）和一个相应的游标对象（**2**）。接下来，我们向模式表发出查询，以检索当前数据库中用于创建表的全部SQL查询（**3**）。我们获取结果（**4**）并从查询结果中提取SQL字符串（**5**）。请注意，此部分函数与上一节中讨论的执行查询的通用函数略有不同。通过提取每行第一个（对于这个特定查询，只有）字段的值，我们消除了行之间不必要的分隔符，否则这些分隔符将出现在我们的输出中（以及后来的提示中）。结果是所有结果行的连接（**6**）。
- en: 5.3.3 Complete code
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 完整代码
- en: Listing [5.2](#code__nlqi) shows the complete code for our generic natural language
    query interface (you can download it from the book’s companion website as listing
    2 in the chapter 5 section). The code uses the function for extracting the database
    structure (**1**), discussed earlier. The function for generating prompts (**2**)
    is a slight variant of the one used for our previous database-specific query interface.
    Instead of a hardcoded description of the database structure, it takes a description
    of the database as input and inserts it into the prompt. The function for invoking
    the language model (**3**) has not changed compared to the prior interface version.
    The function `process_query` (**4**) was discussed in section [5.3.1](#sub__ExecutingQueries).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 [5.2](#code__nlqi) 显示了我们通用自然语言查询接口的完整代码（您可以从本书的配套网站上下载，作为第5章部分的列表2）。该代码使用之前讨论的提取数据库结构的函数（**1**）。生成提示的函数（**2**）是我们之前数据库特定查询接口的一个轻微变体。它不是使用硬编码的数据库结构描述，而是接受数据库描述作为输入并将其插入到提示中。与先前接口版本相比，调用语言模型的函数（**3**）没有变化。`process_query`
    函数（**4**）在[5.3.1](#sub__ExecutingQueries)节中已讨论。
- en: Listing 5.2 Generic text-to-SQL query interface
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2 通用文本到SQL查询接口
- en: '[PRE27]sql(.*)[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]sql(.*)[PRE28]'
- en: '#1 Extracts the database structure'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 提取数据库结构'
- en: '#2 Creates a prompt for translation'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建翻译提示'
- en: '#3 Invokes the language model'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 调用语言模型'
- en: '#4 Processes a query on a database'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 在数据库上处理查询'
- en: '#5 Reads data structure'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 读取数据结构'
- en: '#6 Answers questions until the user quits'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 回答问题直到用户退出'
- en: '#7 Processes the query on the database'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 在数据库上处理查询'
- en: After reading the command-line arguments, the natural language query interface
    extracts the structure of the database (**5**). Next, we loop (**6**) until the
    user terminates the interface. In each iteration, we first read input from the
    keyboard (leaving the loop if the user enters `quit`) and then create a prompt
    and invoke the language model.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取命令行参数后，自然语言查询接口提取数据库的结构（**5**）。接下来，我们循环（**6**）直到用户终止接口。在每次迭代中，我们首先从键盘读取输入（如果用户输入`quit`则退出循环），然后创建提示并调用语言模型。
- en: After translating the input question to a query, we execute that query directly
    (**7**). Of course, the translation may be incorrect and result in a query that
    does not execute on the target database. In that case, SQLite may throw an error,
    and we must ensure that our program does not terminate. This is why we surround
    the call to the query-processing function with a try-catch block.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在将输入问题翻译成查询后，我们直接执行该查询（**7**）。当然，翻译可能是不正确的，并导致在目标数据库上无法执行的查询。在这种情况下，SQLite可能会抛出一个错误，我们必须确保我们的程序不会终止。这就是为什么我们将对查询处理函数的调用放在try-catch块中的原因。
- en: 5.3.4 Trying it out
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 尝试运行
- en: 'Time to try our natural language query interface! Our interface now works for
    arbitrary databases. But we don’t have another database, so we’ll use it again
    on the games database. In the terminal, switch to the directory containing the
    games.db file, and run the following command (let’s assume the code is stored
    in a file named listing3.py):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试我们的自然语言查询接口了！我们的接口现在适用于任意数据库。但我们没有另一个数据库，所以我们将再次在游戏数据库上使用它。在终端中，切换到包含games.db文件的目录，并运行以下命令（假设代码存储在一个名为listing3.py的文件中）：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The command will open an input box in which we can enter questions about the
    data. Following is an example of interaction with the natural language query interface:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在一个输入框中打开，我们可以输入关于数据的问题。以下是与自然语言查询接口交互的示例：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you see, we can ask a wide range of questions and obtain reasonable answers.
    Besides the answer, the system also prints out the query. Knowing a little about
    SQL enables us to verify whether the query accurately translates the question.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们可以提出广泛的问题并获得合理的答案。除了答案之外，系统还会打印出查询。了解一点SQL使我们能够验证查询是否准确地翻译了问题。
- en: 5.4 A natural language query interface for graph data
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 图数据自然语言查询接口
- en: Word spreads at Banana about your text-to-SQL interface, and multiple colleagues
    use it to analyze their tabular data sets. A new colleague of yours is working
    with large graphs, modeling connections between colleagues in Banana’s internal
    social network. This data is represented not as a table but as a graph, a data
    format particularly suitable for modeling connections between entities (in this
    case, people). The colleague reaches out to ask whether it would be possible to
    expand your interface to query such data too. Knowing that language models should,
    in principle, be able to handle a variety of formal query languages, you are optimistic
    and agree to look into it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在香蕉公司，关于你的文本到SQL接口的消息传开了，多位同事用它来分析他们的表格数据集。你的一位新同事正在处理大型图，在香蕉公司内部社交网络中建模同事之间的联系。这些数据不是以表格的形式表示，而是以图的形式表示，这种数据格式特别适合于建模实体之间的联系（在这种情况下，是人）。这位同事向你伸出援手，询问是否有可能扩展你的接口以查询此类数据。了解到语言模型原则上应该能够处理各种正式查询语言，你感到乐观，并同意调查此事。
- en: 5.4.1 What is graph data?
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 什么是图数据？
- en: Like relational data, graphs are a particularly popular type of structured data.
    A graph generally consists of a collection of nodes connected by edges. Nodes
    can be associated with properties, and edges are labeled. For instance, social
    networks are often represented as graphs. Here, nodes represent people, and edges
    represent friendships and relationships. Graphs are also a natural representation
    of road or subway networks. In this case, nodes represent cities or subway stations,
    whereas edges represent roads or rails connecting them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系数据一样，图是一种特别受欢迎的结构化数据类型。图通常由节点集合组成，这些节点通过边连接。节点可以与属性相关联，边有标签。例如，社交网络通常表示为图。在这里，节点代表人，边代表友谊和关系。图也是道路或地铁网络的天然表示。在这种情况下，节点代表城市或地铁站，而边代表连接它们的道路或轨道。
- en: Figure [5.2](#fig__examplegraph) shows an example graph representing a subway
    network. It represents stations of the New York City subway as nodes (hence, nodes
    are labeled `Station`). Edges represent direct connections and are labeled with
    the associated subway line. Nodes are associated with a `name` property, assigning
    nodes to the name of the corresponding station.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [5.2](#fig__examplegraph) 展示了一个表示地铁网络的示例图。它将纽约市地铁的车站表示为节点（因此，节点被标记为“Station”）。边代表直接连接，并标记有相关的地铁线路。节点与一个
    `name` 属性相关联，将节点分配给相应的车站名称。
- en: '![figure](../Images/CH05_F02_Trummer.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH05_F02_Trummer.png)'
- en: Figure 5.2 An example graph representing a small part of the subway network
    in New York City. Nodes, drawn as circles, represent subway stations and are associated
    with a property, assigning them to the name of the represented subway station.
    Edges, drawn as arrows, represent direct connections via specific subway lines.
    Edges are labeled by the subway line connecting the stations.
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2 表示纽约市地铁网络一小部分的示例图。节点以圆形绘制，代表地铁站，并关联一个属性，将它们分配给表示的地铁站名称。边以箭头绘制，代表通过特定地铁线路的直接连接。边由连接车站的地铁线路标记。
- en: The fact that graphs can be used to model various types of data has motivated
    a variety of specialized systems called *graph database systems* for graph data
    processing. These systems support graph-specific query languages (not SQL), enabling
    users to formulate complex questions about the underlying data. Graph database
    systems are optimized for processing large graphs efficiently.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以用来建模各种类型的数据这一事实激发了各种专门系统，称为*图数据库系统*，用于图数据处理。这些系统支持图特定的查询语言（不是SQL），使用户能够对底层数据提出复杂的问题。图数据库系统针对高效处理大型图进行了优化。
- en: Next, we will use language models to translate questions in natural language
    into queries formulated in the graph database management system. We will see that
    this scenario requires only small modifications compared to our approach for translating
    questions into SQL queries.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用语言模型将自然语言中的问题翻译成图数据库管理系统中的查询。我们会看到，与将问题翻译成SQL查询的方法相比，这种场景只需要进行小的修改。
- en: 5.4.2 Setting up a Neo4j database
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 设置Neo4j数据库
- en: We will use the Neo4j system, a database system specialized for graph data.
    You don’t even have to install anything on your local machine. Neo4j comes with
    an online demo that we will use next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Neo4j系统，这是一个专门针对图数据的数据库系统。你甚至不需要在你的本地机器上安装任何东西。Neo4j附带一个在线演示，我们将在下一步中使用。
- en: First, go to [https://neo4j.com/sandbox/](https://neo4j.com/sandbox/) in your
    web browser. Click the Launch the Free Sandbox button. This should open a login
    form, in which you can decide to create a new account or use existing accounts
    (e.g., a Google account). Figure [5.3](#fig__movies) shows the screen you should
    see next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的网络浏览器中转到[https://neo4j.com/sandbox/](https://neo4j.com/sandbox/)。点击启动免费沙盒按钮。这应该会打开一个登录表单，在那里你可以选择创建新账户或使用现有账户（例如，一个Google账户）。图[5.3](#fig__movies)显示了你应该看到的屏幕。
- en: '![figure](../Images/CH05_F03_Trummer.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH05_F03_Trummer.png)'
- en: Figure 5.3 Select the movies database, and click Create to create a corresponding
    instance.
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3 选择电影数据库，然后点击创建以创建相应的实例。
- en: Here, we can select one of several example databases to try Neo4j. We will be
    using the `Movies` database. This database contains information about movies and
    the actors who played in them (representing movies and actors as nodes). Click
    the `Movies` database and then the Create button to create an instance of the
    database and prepare it for querying. Creating the database may take a few minutes.
    Afterward, you can open the `Movies` database and access the query interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以选择几个示例数据库之一来尝试Neo4j。我们将使用`Movies`数据库。这个数据库包含有关电影及其演员的信息（将电影和演员表示为节点）。点击`Movies`数据库，然后点击创建按钮来创建数据库实例并为其查询做准备。创建数据库可能需要几分钟。之后，你可以打开`Movies`数据库并访问查询界面。
- en: Figure [5.4](#fig__neo4jinterface) shows the Neo4j query interface. Click the
    database icon in the upper-left corner to see an overview of the database. The
    database contains multiple types of labels (i.e., node types), including `People`
    and `Movies`. It also contains relationship types such as `ACTED_IN` and `DIRECTED`,
    labeling the edges in our graph. For instance, these two relationship types allow
    us to keep track of who played in which movie (`ACTED_IN`) and who directed which
    movie (`DIRECTED`). Properties are associated with nodes and assign keys to values.
    The database overview reports on property keys such as `name` (assigning an actor
    to a name) and `title` (assigning movies to titles). You can enter queries in
    the text box at the top of the screen and submit them by clicking the button to
    the right of the text box.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图[5.4](#fig__neo4jinterface)显示了Neo4j查询界面。点击左上角的数据库图标以查看数据库概览。数据库包含多种类型的标签（即节点类型），包括`People`和`Movies`。它还包含关系类型，如`ACTED_IN`和`DIRECTED`，标记我们的图中的边。例如，这两种关系类型使我们能够跟踪谁在哪些电影中出演（`ACTED_IN`）以及谁导演了哪些电影（`DIRECTED`）。属性与节点相关联，并为值分配键。数据库概览报告了属性键，如`name`（将演员分配给名字）和`title`（将电影分配给标题）。你可以在屏幕顶部的文本框中输入查询，并通过点击文本框右侧的按钮提交它们。
- en: '![figure](../Images/CH05_F04_Trummer.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH05_F04_Trummer.png)'
- en: Figure 5.4 Click the database icon (upper-left corner) to access information
    about the current graph database, including the types of nodes and edges.
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4 点击数据库图标（左上角）以访问有关当前图数据库的信息，包括节点和边的类型。
- en: 5.4.3 The Cypher query language
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 Cypher查询语言
- en: Neo4j supports the Cypher query language. Although a full introduction to Cypher
    is beyond the scope of this book (instead, have a look at the Neo4j documentation,
    available at [https://neo4j.com/docs/cypher-manual/current/introduction/](https://neo4j.com/docs/cypher-manual/current/introduction/)),
    we will quickly go over the basics. The purpose of this introduction is to enable
    you to understand, at least in simple cases, the semantics of the queries generated
    by the language model.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j支持Cypher查询语言。尽管Cypher的全面介绍超出了本书的范围（相反，请参阅Neo4j文档，可在[https://neo4j.com/docs/cypher-manual/current/introduction/](https://neo4j.com/docs/cypher-manual/current/introduction/)找到），但我们将快速浏览基础知识。本介绍的目的是使你至少在简单情况下能够理解由语言模型生成的查询的语义。
- en: 'A simple type of Cypher query uses a `MATCH` statement describing a subgraph
    to find. For instance, we may simply want to find all nodes of a certain type.
    The query for finding the names of all the people in our Movies database is the
    following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 简单类型的 Cypher 查询使用一个描述子图的 `MATCH` 语句来查找。例如，我们可能只想找到特定类型的所有节点。在 Movies 数据库中查找所有人的名字的查询如下：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '#1 Pattern to match'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 匹配模式'
- en: '#2 Result to return'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 返回结果'
- en: The `MATCH` statement describes a pattern to match (**1**). In this case, that
    pattern consists of single nodes of type `Person`. The `MATCH` statement assigns
    nodes or edges that appear within the pattern to variables. In this case, we introduce
    the variable `p` and assign it to nodes matching the pattern. The `RETURN` statement
    (**2**) describes the query result based on matched patterns. Here, we instruct
    the system to return the `name` property for each node matching the pattern.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`MATCH` 语句描述了一个匹配模式（**1**）。在这种情况下，该模式由类型为 `Person` 的单个节点组成。`MATCH` 语句将出现在模式中的节点或边分配给变量。在这种情况下，我们引入变量
    `p` 并将其分配给匹配该模式的节点。`RETURN` 语句（**2**）根据匹配的模式描述查询结果。在这里，我们指示系统返回匹配模式的每个节点的 `name`
    属性。'
- en: 'Patterns can extend beyond a single node. For instance, we may want to find
    the titles of all movies starring the actor Tom Cruise. In this case, the pattern
    we are looking for consists not of a single node but rather of two connected nodes.
    We are searching for a node of type `Movie` connected via an edge of type `ACTED_IN`
    to a node of type `Person` whose `name` property is set to “Tom Cruise.” This
    can be accomplished by the following Cypher query:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以扩展到单个节点之外。例如，我们可能想找到所有由演员汤姆·克鲁斯主演的电影的标题。在这种情况下，我们寻找的模式不是单个节点，而是两个连接的节点。我们正在寻找一个类型为
    `Movie` 的节点，通过类型为 `ACTED_IN` 的边连接到一个类型为 `Person` 的节点，其 `name` 属性设置为“Tom Cruise”。这可以通过以下
    Cypher 查询实现：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#1 Matches movies starring Tom Cruise'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 匹配汤姆·克鲁斯主演的电影'
- en: '#2 Returns the movie title'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 返回电影标题'
- en: 'The expression `(p:Person` `name: Tom Cruise``)` (**1**) matches all nodes
    of type `Person` whose `name` property is set to “Tom Cruise.” The expression
    `(m:Movie)` matches all nodes of type `Movie`. Finally, we connect those two with
    the expression `-[:ACTED_IN]->`. This expression represents a directed connection
    (hence the arrow shape) between the first node (representing Tom Cruise) and the
    second node (representing an arbitrary movie). The type of the connection is restricted
    to `ACTED_IN` (excluding, for instance, movies directed by Tom Cruise in which
    he did not act). Finally, note that the `MATCH` expression assigns parts of this
    pattern to variables again. Tom Cruise will be represented by variable `p`, and
    the movies he played in will be represented by variable `m`. The `RETURN` expression
    (**2**) retrieves the `title` property of the movie node.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '表达式 `(p:Person name: "Tom Cruise")`（**1**）匹配所有 `name` 属性设置为“Tom Cruise”的类型为
    `Person` 的节点。表达式 `(m:Movie)` 匹配所有类型为 `Movie` 的节点。最后，我们使用表达式 `-[:ACTED_IN]->` 将这两个节点连接起来。这个表达式代表第一个节点（代表汤姆·克鲁斯）和第二个节点（代表任意电影）之间的有向连接（因此箭头形状）。连接的类型限制为
    `ACTED_IN`（例如，不包括汤姆·克鲁斯执导但未出演的电影）。最后，请注意，`MATCH` 表达式再次将此模式的某些部分分配给变量。汤姆·克鲁斯将由变量
    `p` 表示，而他出演的电影将由变量 `m` 表示。`RETURN` 表达式（**2**）检索电影节点的 `title` 属性。'
- en: 'Finally, let’s see how Neo4j can calculate aggregates (similar to SQL):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看 Neo4j 如何计算聚合（类似于 SQL）：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 Matches movies starring Tom Cruise'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 匹配汤姆·克鲁斯主演的电影'
- en: '#2 Returns the number of movies'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 返回电影数量'
- en: This query is similar to the one before and simply counts the number of movies
    featuring Tom Cruise as an actor (**1**). The `RETURN` statement (**2**) contains
    a corresponding aggregate. If you enter the query, you should obtain “3” as the
    query result (so, clearly, the example database is incomplete).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询与之前的查询类似，只是简单地计算出演员汤姆·克鲁斯出演的电影数量（**1**）。`RETURN` 语句（**2**）包含相应的聚合。如果您输入此查询，您应该获得“3”作为查询结果（因此，显然示例数据库是不完整的）。
- en: 5.4.4 Translating questions to Cypher queries
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.4 将问题转换为 Cypher 查询
- en: We will use a similar approach to the one we used for translating questions
    to SQL queries. Primarily, we need to change the prompt to our language model.
    Instead of instructing the language model to translate to SQL, we will instruct
    it to translate to Cypher. Fortunately, language models like GPT-4o have been
    pretrained with a large and diverse set of training data. As we will see in the
    remainder of this section, this pretraining data must have included Cypher queries
    as well, and that’s why we can use language models for translation. As always,
    there are no absolute guarantees, and Cypher queries generated by the language
    model may not accurately translate our questions. However, at least for simple
    queries, the translation is typically correct.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与将问题翻译成SQL查询相同的方法。主要的是，我们需要将提示更改为我们语言模型。我们不会指示语言模型翻译成SQL，而是指示它翻译成Cypher。幸运的是，像GPT-4o这样的语言模型已经在大规模和多样化的训练数据上进行了预训练。正如我们将在本节剩余部分看到的那样，这些预训练数据必须包括Cypher查询，这就是为什么我们可以使用语言模型进行翻译。当然，没有绝对的保证，由语言模型生成的Cypher查询可能无法准确翻译我们的问题。然而，至少对于简单的查询，翻译通常是正确的。
- en: 5.4.5 Generating prompts
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.5 生成提示
- en: To translate questions into Cypher queries, we need to include several pieces
    of information in the prompt. First, this includes the question we want to translate.
    Second, this must include a description of the database structure. In the case
    of SQL, the database structure is defined, for instance, by table and column names.
    In the case of a Neo4j database, we want to include information about node and
    edge types, as well as the names of the most relevant properties. This is essentially
    the information shown on the left side of figure [5.4](#fig__neo4jinterface).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将问题翻译成Cypher查询，我们需要在提示中包含几个信息。首先，这包括我们想要翻译的问题。其次，这必须包括数据库结构的描述。在SQL的情况下，数据库结构由表和列名定义。在Neo4j数据库的情况下，我们想要包含有关节点和边类型以及最相关属性名称的信息。这基本上是图[5.4](#fig__neo4jinterface)左侧显示的信息。
- en: To keep things simple, we’ll focus on the example database introduced previously,
    containing information about movies. This means we hardcode the database structure.
    Of course, similar to our text-to-SQL interface, it is possible to extend the
    interface to handle arbitrary graph databases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将关注之前介绍过的示例数据库，其中包含有关电影的信息。这意味着我们将硬编码数据库结构。当然，类似于我们的文本到SQL接口，我们可以扩展接口以处理任意图数据库。
- en: 'We will use the following prompt template:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下提示模板：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Database description'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 数据库描述'
- en: '#2 Question to translate'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 要翻译的问题'
- en: '#3 Specification of the target language'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 目标语言规范'
- en: This prompt template contains a description of the database (**1**). This description
    includes a specification of the database type (a Neo4j database), as well as a
    list of node labels, relationship types, and properties. Note that we hardcode
    the database structure in this prompt template. If using the interface on a different
    database, this part of the prompt must be replaced. Next, the prompt template
    specifies the question to translate (**2**). This is a placeholder, as we want
    to enable users to ask various questions about the data. The prompt ends with
    a specification of the target language for query translation (**3**). This implicitly
    instructs the language model to translate the question to a Cypher query.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此提示模板包含数据库的描述（**1**）。此描述包括数据库类型（Neo4j数据库）的规范，以及节点标签、关系类型和属性的列表。请注意，我们在提示模板中硬编码了数据库结构。如果在不同数据库上使用接口，此部分的提示必须替换。接下来，提示模板指定了要翻译的问题（**2**）。这是一个占位符，因为我们希望用户能够就数据提出各种问题。提示以查询翻译的目标语言规范结束（**3**）。这隐含地指示语言模型将问题翻译成Cypher查询。
- en: 'The following piece of code instantiates this prompt template for an input
    question:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实例化了用于输入问题的提示模板：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 5.4.6 Complete code
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.6 完整代码
- en: The following listing uses the function for generating prompts (**1**), discussed
    previously, and reuses the function for calling GPT-4o (**2**) (with repeated
    retries, if necessary).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表使用了之前讨论的生成提示的函数（**1**），并重新使用了调用GPT-4o的函数（**2**）（如果需要，可以进行重复尝试）。
- en: Listing 5.3 Translating text questions into Cypher queries for Neo4j
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3 将文本问题翻译成Neo4j的Cypher查询
- en: '[PRE36]cypher(.*)[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE36]cypher(.*)[PRE37]'
- en: '#1 Generates prompts for translation'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 生成翻译提示'
- en: '#2 Calls the LLM'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 调用LLM'
- en: '#3 Creates a prompt'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建提示'
- en: '#4 Generates an answer'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 生成答案'
- en: '#5 Extracts Cypher queries'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 提取 Cypher 查询'
- en: Given a question about the database as input, the code generates a corresponding
    prompt (**3**), obtains an answer from the language model (**4**), and finally
    extracts the Cypher query from that answer (**5**). The regular expression used
    for extraction differs slightly because GPT includes Cypher queries using the
    pattern `‘‘‘cypher ... ‘‘‘`. We finally print out the extracted query.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个关于数据库的问题作为输入，代码生成相应的提示（**3**），从语言模型中获取答案（**4**），最后从该答案中提取 Cypher 查询（**5**）。用于提取的正则表达式略有不同，因为
    GPT 使用模式 `‘‘‘cypher ... ‘‘‘` 包含 Cypher 查询。我们最终打印出提取的查询。
- en: 5.4.7 Trying it out
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.7 尝试一下
- en: 'You can find listing [5.3](#code__neo4jnlqi) on the book’s companion website.
    Download it, and use it from the command line like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的配套网站上找到列表 [5.3](#code__neo4jnlqi)。下载它，并像这样从命令行使用它：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should obtain a query such as the following as output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到如下查询作为输出：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can now enter this query into the Neo4j interface to get the corresponding
    result (which is 38). Try a few more queries to get a better sense of the capabilities
    of the language model. As you see, with just a few changes to the prompt template,
    we transformed our text-to-SQL interface into a text-to-Cypher interface that
    works well in most cases.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将此查询输入到 Neo4j 界面以获取相应的结果（结果是 38）。尝试更多查询以更好地了解语言模型的能力。正如你所见，只需对提示模板进行少量更改，我们就将我们的文本到
    SQL 界面转换成了在大多数情况下都能很好地工作的文本到 Cypher 界面。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Structured data follows a standard format, making it easier to parse. Examples
    of structured data include tabular data and graphs.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化数据遵循标准格式，这使得解析更加容易。结构化数据的例子包括表格数据和图表。
- en: Structured data is often processed via specialized tools.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化数据通常通过专用工具进行处理。
- en: Relational database management systems process tabular data and typically support
    SQL queries.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统处理表格数据，通常支持 SQL 查询。
- en: Graph data management systems process data representing graphs.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据管理系统处理表示图的数据库。
- en: Language models translate natural language to many formal query languages.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言模型将自然语言翻译成多种正式查询语言。
- en: Besides a question, prompts for query translation specify the database structure.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了问题之外，查询翻译的提示还指定了数据库结构。
- en: Copy your database before executing queries generated by language models.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行由语言模型生成的查询之前，请复制你的数据库。
- en: Do not blindly trust your language model to generate accurate queries.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要盲目相信你的语言模型生成准确的查询。
