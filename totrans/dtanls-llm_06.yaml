- en: 5 Analyzing structured data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Translating questions to queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building natural language interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing data tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing graph data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A significant percentage of the world’s information is stored as structured
    data. Structured data essentially means data stored in a standardized format.
    For example, data tables (e.g., think of the data you would find in an Excel spreadsheet)
    and data describing entities and their relationships as graphs (such as a data
    set describing a social network) are popular types of structured data.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for processing structured data have been available for many decades. After
    all, structured data has a standardized format optimized to make it easy for computers
    to process. So why do we need large language models for that? The problem with
    existing tools for processing structured data is their interface. Typically, each
    tool (or, at the very least, each category of tools for specific types of structured
    data) supports its own formal query language.
  prefs: []
  type: TYPE_NORMAL
- en: Using this language, users can often perform a wide range of analysis operations
    on structured data. But learning such query languages takes time! Wouldn’t it
    be nice if all those systems could be queried using a single language, ideally
    in natural language (e.g., plain English)?
  prefs: []
  type: TYPE_NORMAL
- en: This is where language models come into play. Large language models can translate
    questions in natural language into a wide range of formal languages. So we can
    use them as a universal interface to various data-analysis tools supporting a
    wide range of structured data types. In this chapter, we will build natural language
    query interfaces for different types of structured data. Such interfaces enable
    us (or others) to analyze data by typing questions in natural language. The system
    then translates our questions into formal queries, executes them, and presents
    us with results.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Chapter outline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will be creating several natural language query interfaces.
    In general, a natural language query interface answers questions about data formulated
    in natural language. This chapter considers different types of structured data.
    First, we will create natural language interfaces that answer questions about
    tabular data. After that, we will create one that answers questions about graphs.
  prefs: []
  type: TYPE_NORMAL
- en: The principle is the same in both cases. We assume that data is processed using
    a data type–specific tool for data processing. For instance, for tabular data,
    we will use a relational database management system (RDBMS). To analyze graphs,
    we will use a system for managing graph data. Then we will use the large language
    model to translate questions in natural language into the query language supported
    by the specific tool. For instance, for an RDBMS, this is typically the Structured
    Query Language (SQL). Graph database management systems support a variety of graph
    data–specific query languages. We will use the Cypher query language (a language
    describing analysis operations on graph data). We will discuss both languages
    in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: To translate questions into formal queries, the language model needs access
    to the question (of course), some information about the target language (e.g.,
    do we want to write SQL or Cypher queries?), and some information about the structure
    of the data we are trying to query. For instance, the structure of tabular data
    is characterized by the names of tables, the headers of the columns that appear
    in those tables (hopefully providing some hints on the semantics of data stored
    within them), and the data types of each column (are we storing integer values
    or strings?), among other things. By providing the language model with all of
    these pieces of information, including them in the prompt, the model should be
    able to produce a formal query that captures the semantics of our question.
  prefs: []
  type: TYPE_NORMAL
- en: We can process that query using a specialized tool to produce a query result.
    Assuming the query translation was correct, this result will represent an answer
    to the original question. Figure [5.1](#fig__NLQIoverview) illustrates the whole
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH05_F01_Trummer.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 A natural language query interface translates questions in natural
    language into formal queries, taking into account the data structure. Formal queries
    are then processed on data by a specia- lized tool, generating a query result.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Why do we need external tools?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We have seen that language models can solve a variety of tasks. So why not simply
    use language models to analyze structured data directly? Why do we rely on external
    tools to do so and use the language model merely as a translator?
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason is efficiency. Using large language models is expensive,
    and, at least for large data sets, the size of the data can easily exceed the
    maximum input size of the language model. Hence, relying on existing tools that
    can deal with large structured data sets seems like a better idea.
  prefs: []
  type: TYPE_NORMAL
- en: Warning In the following sections, we use language models to write commands
    for data processing. Although language models work astonishingly well in many
    cases, never rely on them to generate correct results in every single scenario.
    In some cases, language models may write incorrect queries. Other times, they
    may write commands to change or delete your data or alter your system setup. Always
    keep a backup of important data before enabling data access via language models.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 A natural language query interface for analyzing game sales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re back at Banana, where you realize that your boss happens to be a computer
    games enthusiast. Your boss not only likes to spend the evenings playing but also
    loves analyzing data about computer games. Having recently obtained a data set
    about computer game sales, your boss is seeking to extract interesting statistics.
    SQL is the language of choice for analyzing tabular data, but your boss does not
    feel comfortable writing SQL queries. Knowing about your expertise with regard
    to language models and data analysis, your boss asks whether it would be possible
    to build an interface that translates questions about computer games into corresponding
    SQL queries. After thinking about it, you realize that this could be a fun project
    that can be realized easily with language models. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1 Setting up an SQLite database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can analyze tabular data using SQL queries, we first must load that
    data into an RDBMS, a tool for processing data tables efficiently. In this subsection,
    we’ll see how to load data about computer games into SQLite, a popular RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, make sure SQLite is installed. We will be using SQLite version
    3 in this section. You can check whether SQLite 3 is installed by typing the following
    in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you receive a message like this one, no further installation is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you see an error message, go to [www.sqlite.org/download.html](http://www.sqlite.org/download.html).
    Select the version that is consistent with your operating system, download all
    the relevant files, and follow the instructions to install SQLite. In case of
    problems, click the SQLite Installation item in the chapter 5 section of the book’s
    companion website. You will find detailed instructions for how to install SQLite
    on different platforms. Afterward, run the previous command to ensure that SQLite
    is installed properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to create a relational database using SQLite. A relational database
    is essentially a collection of data tables. You can think of each data table as
    a simple spreadsheet. We have named table columns associated with a data type
    and (possibly many) table rows that contain values for each of the columns. For
    instance, table [5.1](#tab__videogames) contains information about video games,
    and each row represents one game. The table has four columns: `Name`, `Platform`,
    `Year`, and `Genre`. Three of the columns (`Name`, `Platform`, and `Genre`) contain
    strings (i.e., text). The column `Year` contains numbers (representing the year
    in which a game was released).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1 Sample of data table. Each table row describes one video game.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Name** | **Platform** | **Year** | **Genre** |'
  prefs: []
  type: TYPE_TB
- en: '| Wii Sports | Wii | 2006 | Sports |'
  prefs: []
  type: TYPE_TB
- en: '| Super Mario Bros. | NES | 1985 | Platform |'
  prefs: []
  type: TYPE_TB
- en: '| Mario Kart Wii | Wii | 2008 | Racing |'
  prefs: []
  type: TYPE_TB
- en: '| Wii Sports Resort | Wii | 2009 | Sports |'
  prefs: []
  type: TYPE_TB
- en: '| Pokemon Red/Pokemon Blue | GB | 1996 | Role-Playing |'
  prefs: []
  type: TYPE_TB
- en: Table [5.1](#tab__videogames) shows a small sample of a data set you can find
    on the book’s companion website (look for the Games item in the chapter 5 section).
    We will use that data set in the following sections to create a natural language
    query interface, enabling users to analyze it with natural language commands.
    But first, we need to load that data into the SQLite database system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip We’ll go over all the steps required to load tabular data into SQLite. This
    is useful if you want to load data other than that discussed here. If you don’t
    want to create your own database, you can skip this section and download games.db
    from the book’s companion website instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start the SQLite command-line interface. Enter the following command
    in the terminal, and press Enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new database stored in the file games.db. At the same
    time, it opens the SQLite command-line interface. Now we can instruct the SQLite
    tool to load the data set we will use in the following sections. First we have
    to tell SQLite a little about the structure of the data. We want to load an extended
    version of table [5.1](#tab__videogames) containing additional columns. Run the
    following command to describe the structure of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Table name'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 List of table columns'
  prefs: []
  type: TYPE_NORMAL
- en: This command describes the structure of a single table named `games` (**1**)
    (because it will store information about video games); in parentheses, we specify
    the full list of columns in the table (separated by commas) (**2**). Each column
    is defined by the column name (e.g., `rank`, `name`, or `genre`) followed by the
    column type. For example, `int` means the column stores integer numbers, whereas
    `text` means the column stores text data. All table rows must provide values for
    each column of the appropriate data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the table structure, we can load data into the table from the
    .csv file under Games on the book’s website. Download the file if you haven’t
    already. We will assume that the file is stored in the folder /Downloads/videogames.csv
    for the following commands. Simply replace that path with the file path on your
    system. Load the data using the following command (still in the SQLite interface):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets CSV mode'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Imports the data'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command prepares SQLite to load data from a .csv file (which applies
    to the file we want to load) (**1**). The next command (**2**) imports the data:
    the first parameter is the path to the file we want to load data from, and the
    second parameter is the name of the data table we want to load the file into.
    In this case, we reference the table whose structure we defined before (`games`).
    To test whether the data was loaded successfully (which should be the case if
    you don’t see an error message), run the following command in SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should see the result `16599` if all the data was loaded. If you see a lower
    number, check for error messages in the SQLite output. You can quit the SQLite
    console via the command `.quit` (don’t forget to prefix your command with a dot
    to make it work). For the following sections, we will assume that the data has
    been loaded and is stored in an SQLite file called games.db.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2 SQL basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sure, we can use the language model to translate questions to SQL queries (which
    are understood by SQLite). But can we trust its translations? Thinking more about
    it, you realize that it wouldn’t hurt to have at least some SQL basics to verify
    the output of the language model before presenting the interface to your boss.
    That’s what we’ll do in this section. A full introduction to SQL is, of course,
    beyond the scope of this book. Have a look at the website [www.databaselecture.com](http://www.databaselecture.com)
    to get a more detailed introduction by this book’s author. We’ll discuss a few
    SQL basics in this section that help implement our natural language query interface.
  prefs: []
  type: TYPE_NORMAL
- en: SQL queries are used to analyze data tables. Query results may be derived from
    a single table or by combining data from multiple tables. In our example database,
    created in the last section, we have a single table. Using SQL queries, we can,
    for instance, count rows with certain properties (e.g., all games by the same
    publisher), filter data (e.g., only show games that were released in 2017), or
    perform various aggregate operations (e.g., for each publisher, calculate the
    average earnings per game).
  prefs: []
  type: TYPE_NORMAL
- en: 'An SQL query generally describes a table to generate (using data that is already
    available in the database). Most example queries in this section have the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#1 SELECT clause'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 FROM clause'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 WHERE clause'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FROM` clause (**2**) (the code following the `FROM` keyword and before
    the `WHERE` keyword) describes the source data used for analysis. For instance,
    the `FROM` clause can contain a list of table names separated by commas. In our
    example database, we have only a single table to process (for advanced queries,
    the same table name may appear multiple times in the `FROM` clause, creating different
    copies of the same table). The queries we will encounter in the following sections
    will contain a single entry in the `FROM` clause: the `games` table.'
  prefs: []
  type: TYPE_NORMAL
- en: The `WHERE` clause (**3**) defines predicates on the tables that appear in the
    `FROM` clause. For instance, it may contain a condition restricting the scope
    to games from a certain publisher. The `WHERE` clause can contain simple conditions
    (i.e., conditions that can be expressed by an equality or inequality on a table
    column) as well as complex conditions (connecting multiple simple conditions by
    `AND` or `OR` operators). Those conditions are used to filter rows from the tables
    in the `FROM` clause. Rows that do not satisfy the condition in the `WHERE` clause
    are discarded and do not appear in the query result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we specify the columns of the desired result table in the `SELECT`
    clause (**1**). More precisely, we specify a list of column definitions separated
    by commas. Columns may be defined by a column name (a column that appears in one
    of the tables in the `FROM` clause) or by a more complex expression: for example,
    an arithmetic expression connecting multiple columns. Alternatively, we can specify
    aggregates such as `count(*)` in the `SELECT` clause (the latter aggregate counts
    the number of rows). The query result contains a table with the specified columns,
    filling them with content corresponding to the column definition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s say we want to count all games published in 2017\. In this
    case, our query result should contain a single column with a count aggregate.
    Also, our `WHERE` clause should contain a filter condition restricting our scope
    to games from 2017\. Our `FROM` clause contains, of course, the name of the only
    table in our database (`games`). The following query generates the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things a little more complex, let’s assume that we want to calculate
    the combined number of sales in Europe and Japan for all games released in 2017
    by a specific publisher (Activision). Our desired query result contains two columns:
    the name of the game and the sales count. As our data table features two columns
    with sales in Europe and sales in Japan (`eusales` and `japansales`, as per our
    table definition in the previous section), we can describe the desired result
    column by adding them (`eusales + japansales`). Because we want to restrict our
    scope to games from 2017 and from Activision, we can use a complex predicate in
    the `WHERE` clause: `year = 2017 AND publisher = Activision`. Note the use of
    apostrophes around the name Activision—we need to use apostrophes to delimit strings
    in query conditions instead of numbers. The following query generates the desired
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, when specifying aggregates, we can calculate those aggregates for
    different groups of rows defined by shared values in certain columns. To do so,
    we add a final `GROUP BY` clause to the previous query template, followed by a
    comma-separated list of columns used to form groups. For instance, let’s assume
    that we want to calculate game sales for each genre (such as strategy or action)
    separately. We can use the following query to return one row with aggregates for
    each category of games (note that we add the `genre` column in the `SELECT` clause
    as well to ensure that we can associate numbers with the correct genre):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The SQL primer in this section is clearly insufficient to write your own SQL
    queries, except for a few simple cases. However, we don’t really want to write
    our own SQL queries—we want to rely on the language model instead! This introduction
    should enable you to understand queries generated by the language model at a high
    level of abstraction. And observing how the language model maps questions to queries
    may be a good way to get started with learning SQL yourself. In the next section,
    we will start by creating a simple translator, translating questions into SQL
    queries on the `games` database.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3 Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having acquired a few SQL basics to check the output of the language model,
    we will now work on our text-to-SQL translator. We will use our translator via
    the command line. We specify a question as input and ideally want an SQL query,
    translating our question as output. If we run the output query in SQLite, we should
    get the answer to our original question. Of course, this interface is manual and
    not very convenient to use. Ideally, we would like it to execute queries automatically
    and show the corresponding results directly in our query interface. We will create
    such an interface in the following section. For now, we just focus on the core
    problem of translating questions into queries. Also, for the moment, our only
    goal is to translate questions about computer games. Therefore, we will hardcode
    the structure of the target database. Again, we will generalize that in our next
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, to translate the input question, we will first create a prompt.
    This prompt describes the translation task and contains all relevant details for
    translation (e.g., the structure of our target database). Sending this prompt
    to the language model should result, in most cases, in a correctly translated
    SQL query. We may still need to do a little work to extract this query from potentially
    overly verbose output generated by the language model. Let’s discuss these steps
    in more detail, starting with the prompts.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.4 Generating prompts for text-to-SQL translation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What information do we need to convey to the language model for a successful
    translation? Clearly, we need to specify the question we want to translate. Also,
    we need to specify the target system (SQLite) and describe the structure of the
    target database. For the moment, we hardcode the database structure. We can simply
    provide the language model with the table definition (`create table...`) that
    we used in section [5.2.1](#sec__createsqlitedb). The language model will understand
    how this command maps to a table structure. By sending a prompt with instructions
    for translation to the model containing all of the previously mentioned types
    of information, the language model should be able to produce a corresponding SQL
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the following prompt template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Database description'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Task description'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Question to translate'
  prefs: []
  type: TYPE_NORMAL
- en: 'This prompt template contains all the pieces of information described earlier.
    First, it describes the target database (**1**) by providing the SQL commands
    used to create the associated tables (in this case, a single table). Note that
    this is not a placeholder because, for the moment, our query interface only needs
    to work for one database (whose structure we hardcode in the template). Next,
    the prompt template contains a task description (**2**): the goal is to translate
    questions into SQL queries. Finally, the template contains the question to translate
    (**3**). Here, we use a placeholder (indicated by square brackets). This enables
    us to use the same prompt template for various questions our boss may ask about
    the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code generates prompts according to the previous template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Adds the database description'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Adds the task description'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Adds the question to translate'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Returns the concatenation'
  prefs: []
  type: TYPE_NORMAL
- en: Given the question to translate as input, the code adds the description of the
    database (**1**), then instructions for translation (**2**), and finally the question
    to translate (**3**). The result is the concatenation of all the prompt parts
    (**4**).
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.5 Complete code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next listing contains the full code for our natural language query interface.
    It uses the prompt-generation function discussed earlier (**1**), as well as the
    function invoking the language model (**2**) that we already know from prior chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.1 Translating questions about video games into SQL queries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]|sql(.*)\verb|[PRE13]'
  prefs: []
  type: TYPE_NORMAL
- en: '#1 Generates a prompt for translation'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Invokes the language model'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Reads a query and translates it to SQL'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Generates a prompt'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Generates an answer'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Extracts an SQL query from the answer'
  prefs: []
  type: TYPE_NORMAL
- en: This listing reads a question about computer games from the command line (**3**).
    Using the input question, it generates a prompt (**4**) that instructs the language
    model to translate the question into an SQL query. It sends the prompt to the
    language model and receives its answer (**5**).
  prefs: []
  type: TYPE_NORMAL
- en: The raw answer from GPT-4o typically contains explanations interleaved with
    the SQL query we are ultimately interested in. To get the query alone, we have
    to extract it from the raw answer (**6**). Here, we exploit the fact that GPT-4o
    encloses SQL queries between the markers [PRE14]sql [PRE15]` [PRE16]` (when interacting
    with GPT models via the ChatGPT web interface, the content between those markers
    is rendered as a code box). The regular expression [PRE17]sql(.*)[PRE18]` matches
    the SQL query between the markers, using the Python function `re.findall` to return
    a list of matches for this regular expression (the `re.DOTALL` flag is required
    to ensure that the dot matches all characters, including newlines, which may appear
    in SQL queries). We use the first of those matches as our query (i.e., we implicitly
    assume that at least one match is returned and that the first match is suitable).
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.6 Trying it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Okay! Time to try our text-to-SQL translator! In the terminal, switch to the
    directory containing the Python code. We will assume that the code is stored in
    a file called listing1.py (which you can download from the companion website).
    Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you should obtain the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Is that query correct? Let’s find out: in the terminal, switch to the repository
    containing the SQLite database file (games.db). Then, open the database via the
    SQLite command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can finally try the query generated by our text-to-SQL translator. Enter
    the query, and press Enter. You should see the number of games stored in the database:
    16,599.'
  prefs: []
  type: TYPE_NORMAL
- en: You may want to try a few other questions. For example, see whether you can
    count the number of games by specific publishers or games of a specific genre!
    Chances are, for most questions referring to this simple database, GPT-4o should
    be capable enough to provide an accurate translation. Your boss will be happy.
  prefs: []
  type: TYPE_NORMAL
- en: The interface we created in this section is still limited in various ways. First,
    you have to reexecute the program for each new question. Second, you have to manually
    copy and execute each translated query into the database system interface. Third,
    and most importantly, if you ever want to switch to a different data set, you
    will have to manually change your prompt template. In the next section, we’ll
    see how to overcome these restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 A general natural language query interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your boss is happy with the new natural language interface and regularly shares
    interesting insights about computer game sales with you. However, you can’t help
    but wonder whether this use case alone exploits the full potential of your approach.
    For instance, the human resources unit at Banana regularly deals with complex
    questions on tables storing employee information. Couldn’t we generalize our natural
    language interface to help them as well? In this section, we’ll generalize the
    natural language query interface to work with arbitrary databases without requiring
    any changes to the code itself. Furthermore, we will make the interface more convenient
    by executing the translated queries directly and avoiding restarts between different
    questions on the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1 Executing queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a first step, let’s see how we can execute translated queries directly from
    Python. This will avoid tediously copying queries from one interface to another.
    In Python, we can execute queries on an SQLite database using the `sqlite3` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that the variable `data_path` stores the path to the database
    file. To execute queries on that database, we must first create a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute SQL queries on the database via the `connection` object.
    Let’s assume that the SQL query we want to execute is stored in the variable `query`.
    After connecting to the database, we first create a cursor object (enabling querying
    and result retrieval) and then use it to execute the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, we can get a list of result rows by calling `cursor.fetchall()`.
    We’ll put everything together in a function that takes two parameters—the path
    to the database and a query to execute on it—as input, returning the query result
    in a string representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Connects to the database'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates the cursor'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Executes a query'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Retrieves the query result'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Transforms to a list of strings'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Concatenates result rows'
  prefs: []
  type: TYPE_NORMAL
- en: After connecting to the target database (**1**), the function creates a cursor
    (**2**), executes the input query (**3**), and retrieves the query result (**4**).
    After casting the result tuples into a string representation (**5**), we concatenate
    the result rows, separated by newline symbols (**6**).
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 Extracting the database structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want an interface that works for arbitrary SQLite databases without having
    to change the code. This means we need to extract the structure of the current
    database (information about its tables and columns) automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For SQLite, we can extract the structure of a database by executing SQL queries.
    These queries access a special table: the *schema table*. This table is created
    automatically (i.e., we do not need to create it by hand). Among other things,
    this table contains the SQL commands used to create other tables in a database.
    We can use them as a concise description of the database structure, suitable as
    input to the language model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the schema table via the table name `sqlite_master`. This table
    contains a column named `sql` with information about queries used to create objects
    inside the database. Specifically, we are interested in SQL commands used to create
    tables. Those queries contain crucial information for query translation, including
    the names and types of the columns that belong to the table created by the query.
    The following query retrieves all SQL statements used to create tables in the
    current database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So all we need to do is execute this query from Python. Fortunately, we already
    know how to do that from the previous section. Given the path to a database, the
    following function returns a text describing the queries used to create all the
    tables in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Connects to the database'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates a cursor'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Accesses schema table'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Retrieves results'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Retrieves SQL strings'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Concatenates SQL strings'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we create a connection (**1**) and a corresponding cursor object (**2**).
    Next, we issue a query to the schema table to retrieve all SQL queries used to
    create tables in the current database (**3**). We fetch the results (**4**) and
    extract the SQL strings from the query result (**5**). Note that this part of
    the function differs slightly from the generic function for executing queries,
    discussed in the previous section. By extracting the values for the first (and,
    for this specific query, only) field of each row, we get rid of unnecessary delimiters
    between rows that would otherwise show up in our output (and, later, in our prompts).
    The result is the concatenation of all the result rows (**6**).
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3 Complete code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Listing [5.2](#code__nlqi) shows the complete code for our generic natural language
    query interface (you can download it from the book’s companion website as listing
    2 in the chapter 5 section). The code uses the function for extracting the database
    structure (**1**), discussed earlier. The function for generating prompts (**2**)
    is a slight variant of the one used for our previous database-specific query interface.
    Instead of a hardcoded description of the database structure, it takes a description
    of the database as input and inserts it into the prompt. The function for invoking
    the language model (**3**) has not changed compared to the prior interface version.
    The function `process_query` (**4**) was discussed in section [5.3.1](#sub__ExecutingQueries).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.2 Generic text-to-SQL query interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]sql(.*)[PRE28]'
  prefs: []
  type: TYPE_NORMAL
- en: '#1 Extracts the database structure'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates a prompt for translation'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Invokes the language model'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Processes a query on a database'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Reads data structure'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Answers questions until the user quits'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Processes the query on the database'
  prefs: []
  type: TYPE_NORMAL
- en: After reading the command-line arguments, the natural language query interface
    extracts the structure of the database (**5**). Next, we loop (**6**) until the
    user terminates the interface. In each iteration, we first read input from the
    keyboard (leaving the loop if the user enters `quit`) and then create a prompt
    and invoke the language model.
  prefs: []
  type: TYPE_NORMAL
- en: After translating the input question to a query, we execute that query directly
    (**7**). Of course, the translation may be incorrect and result in a query that
    does not execute on the target database. In that case, SQLite may throw an error,
    and we must ensure that our program does not terminate. This is why we surround
    the call to the query-processing function with a try-catch block.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4 Trying it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Time to try our natural language query interface! Our interface now works for
    arbitrary databases. But we don’t have another database, so we’ll use it again
    on the games database. In the terminal, switch to the directory containing the
    games.db file, and run the following command (let’s assume the code is stored
    in a file named listing3.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will open an input box in which we can enter questions about the
    data. Following is an example of interaction with the natural language query interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you see, we can ask a wide range of questions and obtain reasonable answers.
    Besides the answer, the system also prints out the query. Knowing a little about
    SQL enables us to verify whether the query accurately translates the question.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 A natural language query interface for graph data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Word spreads at Banana about your text-to-SQL interface, and multiple colleagues
    use it to analyze their tabular data sets. A new colleague of yours is working
    with large graphs, modeling connections between colleagues in Banana’s internal
    social network. This data is represented not as a table but as a graph, a data
    format particularly suitable for modeling connections between entities (in this
    case, people). The colleague reaches out to ask whether it would be possible to
    expand your interface to query such data too. Knowing that language models should,
    in principle, be able to handle a variety of formal query languages, you are optimistic
    and agree to look into it.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1 What is graph data?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like relational data, graphs are a particularly popular type of structured data.
    A graph generally consists of a collection of nodes connected by edges. Nodes
    can be associated with properties, and edges are labeled. For instance, social
    networks are often represented as graphs. Here, nodes represent people, and edges
    represent friendships and relationships. Graphs are also a natural representation
    of road or subway networks. In this case, nodes represent cities or subway stations,
    whereas edges represent roads or rails connecting them.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [5.2](#fig__examplegraph) shows an example graph representing a subway
    network. It represents stations of the New York City subway as nodes (hence, nodes
    are labeled `Station`). Edges represent direct connections and are labeled with
    the associated subway line. Nodes are associated with a `name` property, assigning
    nodes to the name of the corresponding station.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH05_F02_Trummer.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 An example graph representing a small part of the subway network
    in New York City. Nodes, drawn as circles, represent subway stations and are associated
    with a property, assigning them to the name of the represented subway station.
    Edges, drawn as arrows, represent direct connections via specific subway lines.
    Edges are labeled by the subway line connecting the stations.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The fact that graphs can be used to model various types of data has motivated
    a variety of specialized systems called *graph database systems* for graph data
    processing. These systems support graph-specific query languages (not SQL), enabling
    users to formulate complex questions about the underlying data. Graph database
    systems are optimized for processing large graphs efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will use language models to translate questions in natural language
    into queries formulated in the graph database management system. We will see that
    this scenario requires only small modifications compared to our approach for translating
    questions into SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 Setting up a Neo4j database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use the Neo4j system, a database system specialized for graph data.
    You don’t even have to install anything on your local machine. Neo4j comes with
    an online demo that we will use next.
  prefs: []
  type: TYPE_NORMAL
- en: First, go to [https://neo4j.com/sandbox/](https://neo4j.com/sandbox/) in your
    web browser. Click the Launch the Free Sandbox button. This should open a login
    form, in which you can decide to create a new account or use existing accounts
    (e.g., a Google account). Figure [5.3](#fig__movies) shows the screen you should
    see next.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH05_F03_Trummer.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 Select the movies database, and click Create to create a corresponding
    instance.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here, we can select one of several example databases to try Neo4j. We will be
    using the `Movies` database. This database contains information about movies and
    the actors who played in them (representing movies and actors as nodes). Click
    the `Movies` database and then the Create button to create an instance of the
    database and prepare it for querying. Creating the database may take a few minutes.
    Afterward, you can open the `Movies` database and access the query interface.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [5.4](#fig__neo4jinterface) shows the Neo4j query interface. Click the
    database icon in the upper-left corner to see an overview of the database. The
    database contains multiple types of labels (i.e., node types), including `People`
    and `Movies`. It also contains relationship types such as `ACTED_IN` and `DIRECTED`,
    labeling the edges in our graph. For instance, these two relationship types allow
    us to keep track of who played in which movie (`ACTED_IN`) and who directed which
    movie (`DIRECTED`). Properties are associated with nodes and assign keys to values.
    The database overview reports on property keys such as `name` (assigning an actor
    to a name) and `title` (assigning movies to titles). You can enter queries in
    the text box at the top of the screen and submit them by clicking the button to
    the right of the text box.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH05_F04_Trummer.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 Click the database icon (upper-left corner) to access information
    about the current graph database, including the types of nodes and edges.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 5.4.3 The Cypher query language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Neo4j supports the Cypher query language. Although a full introduction to Cypher
    is beyond the scope of this book (instead, have a look at the Neo4j documentation,
    available at [https://neo4j.com/docs/cypher-manual/current/introduction/](https://neo4j.com/docs/cypher-manual/current/introduction/)),
    we will quickly go over the basics. The purpose of this introduction is to enable
    you to understand, at least in simple cases, the semantics of the queries generated
    by the language model.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple type of Cypher query uses a `MATCH` statement describing a subgraph
    to find. For instance, we may simply want to find all nodes of a certain type.
    The query for finding the names of all the people in our Movies database is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Pattern to match'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Result to return'
  prefs: []
  type: TYPE_NORMAL
- en: The `MATCH` statement describes a pattern to match (**1**). In this case, that
    pattern consists of single nodes of type `Person`. The `MATCH` statement assigns
    nodes or edges that appear within the pattern to variables. In this case, we introduce
    the variable `p` and assign it to nodes matching the pattern. The `RETURN` statement
    (**2**) describes the query result based on matched patterns. Here, we instruct
    the system to return the `name` property for each node matching the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns can extend beyond a single node. For instance, we may want to find
    the titles of all movies starring the actor Tom Cruise. In this case, the pattern
    we are looking for consists not of a single node but rather of two connected nodes.
    We are searching for a node of type `Movie` connected via an edge of type `ACTED_IN`
    to a node of type `Person` whose `name` property is set to “Tom Cruise.” This
    can be accomplished by the following Cypher query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Matches movies starring Tom Cruise'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Returns the movie title'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression `(p:Person` `name: Tom Cruise``)` (**1**) matches all nodes
    of type `Person` whose `name` property is set to “Tom Cruise.” The expression
    `(m:Movie)` matches all nodes of type `Movie`. Finally, we connect those two with
    the expression `-[:ACTED_IN]->`. This expression represents a directed connection
    (hence the arrow shape) between the first node (representing Tom Cruise) and the
    second node (representing an arbitrary movie). The type of the connection is restricted
    to `ACTED_IN` (excluding, for instance, movies directed by Tom Cruise in which
    he did not act). Finally, note that the `MATCH` expression assigns parts of this
    pattern to variables again. Tom Cruise will be represented by variable `p`, and
    the movies he played in will be represented by variable `m`. The `RETURN` expression
    (**2**) retrieves the `title` property of the movie node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s see how Neo4j can calculate aggregates (similar to SQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Matches movies starring Tom Cruise'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Returns the number of movies'
  prefs: []
  type: TYPE_NORMAL
- en: This query is similar to the one before and simply counts the number of movies
    featuring Tom Cruise as an actor (**1**). The `RETURN` statement (**2**) contains
    a corresponding aggregate. If you enter the query, you should obtain “3” as the
    query result (so, clearly, the example database is incomplete).
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.4 Translating questions to Cypher queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use a similar approach to the one we used for translating questions
    to SQL queries. Primarily, we need to change the prompt to our language model.
    Instead of instructing the language model to translate to SQL, we will instruct
    it to translate to Cypher. Fortunately, language models like GPT-4o have been
    pretrained with a large and diverse set of training data. As we will see in the
    remainder of this section, this pretraining data must have included Cypher queries
    as well, and that’s why we can use language models for translation. As always,
    there are no absolute guarantees, and Cypher queries generated by the language
    model may not accurately translate our questions. However, at least for simple
    queries, the translation is typically correct.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5 Generating prompts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To translate questions into Cypher queries, we need to include several pieces
    of information in the prompt. First, this includes the question we want to translate.
    Second, this must include a description of the database structure. In the case
    of SQL, the database structure is defined, for instance, by table and column names.
    In the case of a Neo4j database, we want to include information about node and
    edge types, as well as the names of the most relevant properties. This is essentially
    the information shown on the left side of figure [5.4](#fig__neo4jinterface).
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, we’ll focus on the example database introduced previously,
    containing information about movies. This means we hardcode the database structure.
    Of course, similar to our text-to-SQL interface, it is possible to extend the
    interface to handle arbitrary graph databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following prompt template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Database description'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Question to translate'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Specification of the target language'
  prefs: []
  type: TYPE_NORMAL
- en: This prompt template contains a description of the database (**1**). This description
    includes a specification of the database type (a Neo4j database), as well as a
    list of node labels, relationship types, and properties. Note that we hardcode
    the database structure in this prompt template. If using the interface on a different
    database, this part of the prompt must be replaced. Next, the prompt template
    specifies the question to translate (**2**). This is a placeholder, as we want
    to enable users to ask various questions about the data. The prompt ends with
    a specification of the target language for query translation (**3**). This implicitly
    instructs the language model to translate the question to a Cypher query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code instantiates this prompt template for an input
    question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 5.4.6 Complete code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following listing uses the function for generating prompts (**1**), discussed
    previously, and reuses the function for calling GPT-4o (**2**) (with repeated
    retries, if necessary).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.3 Translating text questions into Cypher queries for Neo4j
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]cypher(.*)[PRE37]'
  prefs: []
  type: TYPE_NORMAL
- en: '#1 Generates prompts for translation'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Calls the LLM'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a prompt'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Generates an answer'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Extracts Cypher queries'
  prefs: []
  type: TYPE_NORMAL
- en: Given a question about the database as input, the code generates a corresponding
    prompt (**3**), obtains an answer from the language model (**4**), and finally
    extracts the Cypher query from that answer (**5**). The regular expression used
    for extraction differs slightly because GPT includes Cypher queries using the
    pattern `‘‘‘cypher ... ‘‘‘`. We finally print out the extracted query.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.7 Trying it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find listing [5.3](#code__neo4jnlqi) on the book’s companion website.
    Download it, and use it from the command line like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should obtain a query such as the following as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can now enter this query into the Neo4j interface to get the corresponding
    result (which is 38). Try a few more queries to get a better sense of the capabilities
    of the language model. As you see, with just a few changes to the prompt template,
    we transformed our text-to-SQL interface into a text-to-Cypher interface that
    works well in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Structured data follows a standard format, making it easier to parse. Examples
    of structured data include tabular data and graphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured data is often processed via specialized tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational database management systems process tabular data and typically support
    SQL queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph data management systems process data representing graphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language models translate natural language to many formal query languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides a question, prompts for query translation specify the database structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy your database before executing queries generated by language models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not blindly trust your language model to generate accurate queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
