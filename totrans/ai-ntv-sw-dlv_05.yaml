- en: Chapter 5\. Securing Applications and the Software Supply Chain
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve touched on security tools and practices throughout this book as we’ve
    navigated the delivery process from SCM to continuous integration and delivery.
    We discussed how RBAC and Policy-as-Code (PaC) governance in modern tools help
    secure your code repositories and pipelines, and we mentioned the role of early
    security testing in continuous integration. We looked at dynamic testing to uncover
    runtime vulnerabilities in your applications. This has been a light touch on security.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll bring security to the forefront and give it the attention
    it deserves in a world where cyberattacks are growing in both frequency and sophistication.
    High-profile breaches regularly make headlines, regulations are tightening globally,
    and customers increasingly evaluate vendors based on security posture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: With release cycles measured in days rather than months, the traditional model
    of security as a final gate before production has become untenable. Instead, we
    have shifted the burden “left” toward developers, who must now integrate security
    practices into their daily workflows. Developers who are not security experts
    now bear an unprecedented burden of security responsibility.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence promises some relief for this tension. AI-powered security
    tools are improving detection accuracy, dramatically reducing false positives
    that waste developer time, and even automatically generating remediation code.
    Rather than simply shifting the security burden left, AI helps share that burden,
    providing developers with expert-level security guidance without requiring them
    to become security experts themselves.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover how the evolution toward AI-native software delivery
    has transformed how we approach security—not by simply adding more tools or processes,
    but by fundamentally changing how we identify, prioritize, and remediate security
    issues. We’ll look at the importance of software supply chain security that is
    protecting the tools, processes, and people involved with how software is built
    and delivered, from the initial code to the final product. It’s a critical concern
    as modern software relies heavily on interconnected components, each presenting
    potential vulnerabilities that could be exploited by malicious actors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Understanding supply chain concerns and learning to evaluate your SDLC with
    a security lens will equip you to put strong security measures in place and better
    protect your applications, data, and your organization’s reputation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Modern Applications and the Cyberthreat Landscape
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and deploying modern software applications relies heavily on distributed
    and complex software supply chains. These supply chains often encompass a vast
    network of code repositories, open source dependencies, third-party components,
    artifact repositories, and CI/CD pipelines. While this interconnectedness fosters
    innovation and accelerates our development cycles, it also introduces security
    risks throughout. The expanding attack surface and the potential for vulnerabilities
    to propagate throughout the supply chain have made our software supply chains
    a prime target for malicious actors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll look at these threats and learn how regulatory compliance
    frameworks that govern software supply chains are evolving to address them. Finally
    we’ll look at how new compliance requirements impact your organization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The Growing Threat of Software Supply Chain Attacks
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The software supply chain encompasses all of the people, processes, and tools
    involved in creating and delivering software. It spans the complete lifecycle
    of software development, from the initial code creation to its deployment and
    maintenance. It’s a complex ecosystem where each element plays a crucial role
    in the final product.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The software supply chain is made up of two primary concerns: applications
    and the DevOps toolchain, as shown in [Figure 5-1](#chapter_5_figure_1_1749354010722636).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ansd_0501.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. The software supply chain
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Applications risks in the software supply chain
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “Applications” here refers to all of the elements of your software, including
    your proprietary source code; open source dependencies like libraries, frameworks,
    and modules; and the software artifacts produced during the development process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: According to the 2024 Open Source Security and Risk Analysis report by Synopsys,
    96% of codebases contain open source components. It’s important to remember that
    our organizations are responsible for securing the open source components we use,
    just as they are with internally developed code. Because open source usage is
    so widespread, we shouldn’t be surprised that over 80% of vulnerabilities found
    in applications are from OSS dependencies. A vulnerability discovered in 2021
    in a widely used Java logging library called Log4j is an example of an open source–introduced
    threat. This vulnerability allowed attackers to remotely execute code on affected
    systems simply by sending a specially crafted string to the application’s log.
    The exploit was exceptionally dangerous due to the widespread use of Log4j in
    applications and services, leading to a massive scramble to patch and mitigate
    the vulnerability.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The discovery of a backdoor in the widely used XZ Utils data compression tool
    provides another example. XZ Utils, like many OSS projects, is maintained by volunteers
    with limited resources for addressing security issues. One trusted contributor
    was found to have implemented a backdoor that would have allowed an attacker to
    gain administrator privileges to systems running software built with the tool.
    This utility is present in most Linux distributions, and was fortunately discovered
    before the tool had been widely deployed in production systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Another emerging threat in the application supply chain exploits the hallucinations
    of AI coding assistants. When AI models hallucinate package names, recommending
    nonexistent libraries or incorrect package identifiers, they create an opportunity
    for attackers. Malicious actors can monitor popular AI coding assistants for such
    hallucinations, and then register these hallucinated package names in public repositories.
    When developers attempt to use these nonexistent but AI-recommended packages,
    they unknowingly install malicious code. This “hallucination squatting” attack
    vector has already been observed in the wild, with researchers finding that common
    coding assistants frequently suggest nonexistent packages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: DevOps risks in the software supply chain
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DevOps toolchain includes the suite of tools and processes used to automate
    the building, testing, and deployment of your software. This encompasses code
    repositories, CI/CD tools and pipelines, artifact registries, and other tools
    that streamline the development process such as GitOps and IaCM tools.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The SolarWinds hack stands as a stark example of how a compromised DevOps toolchain
    can be exploited to propagate malicious code. In this sophisticated attack, threat
    actors infiltrated the SolarWinds Orion software build system, injecting malicious
    code into legitimate software updates. These tainted updates were then distributed
    to eighteen thousand SolarWinds customers, granting the attackers widespread access
    to their networks. This incident highlighted the potential for attackers to leverage
    the trust and automation inherent in DevOps pipelines to distribute malware at
    scale, turning a routine software update into a devastating cyberattack.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The Codecov supply chain hack in 2021 is another example of a toolchain security
    breach, one that impacted thousands of organizations. Malicious actors modified
    a Codecov Bash Uploader script (a tool customers use to upload code coverage data).
    This modification allowed the attackers to exfiltrate sensitive information, such
    as tokens, keys, and credentials from the continuous integration environments
    of Codecov’s customers. The breach went undetected for over two months, potentially
    exposing sensitive data stored in customers’ continuous integration environments.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: A threat that is growing
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Software supply chain attacks are not going away. [Gartner Research](https://oreil.ly/Uwphu)
    predicts that by 2025, 45% of organizations worldwide will have experienced attacks
    on their software supply chains. A security flaw in a line of code, a third-party
    library, or a tool in your pipeline can have a ripple effect, compromising the
    entire software product. Securing the software supply chain is about not just
    protecting individual components but also ensuring the integrity and security
    of the entire development and delivery process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Regulatory Compliance Frameworks That Apply to Software Supply Chains
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the increasing threat, governments and regulating authorities have responded
    with regulations that aim to address these challenges by establishing best practices,
    promoting transparency, and requiring organizations to take proactive measures
    to secure their software supply chains. Some of the most important compliance
    and regulatory frameworks that have emerged include the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: United States Executive Order 14028, Improving the Nation’s Cybersecurity
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: This executive order, issued in 2021, mandates that federal agencies and their
    software providers enhance their software supply chain security practices. It
    emphasizes the use of secure software development practices, vulnerability disclosure,
    and incident response.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The European Union’s Network and Information Security 2 Directive (NIS2 Directive)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: This directive aims to establish a high common level of cybersecurity across
    the EU. It includes provisions on software supply chain security, requiring organizations
    to assess and manage risks associated with software components and third-party
    dependencies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: NIST SP 800-218, Secure Software Development Framework (SSDF)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: This National Institute of Standards and Technology publication offers guidance
    for integrating security into the SDLC, including supply chain risk management.
    It provides a comprehensive framework for secure software development practices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: ISO/IEC 27036-2:2023
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: This standard offers guidelines for managing information security risks related
    to suppliers and the supply chain. It covers various aspects, including supplier
    selection, contract management, and performance monitoring.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Payment Card Industry Data Security Standard (PCI DSS)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: While not solely focused on the software supply chain, PCI DSS requires organizations
    handling payment card data to implement secure software development practices,
    which include managing supply chain risks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Cyber Resilience Act (CRA)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This proposed EU regulation aims to enhance the cybersecurity of digital products
    and services. It includes requirements for vulnerability handling, security updates,
    software bill of materials (SBOM), and reporting actively exploited vulnerabilities
    within 24 hours of awareness.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Quality System Regulation (QSR) (21 CFR Part 820) and General Data
    Protection Regulation (GDPR) are frameworks that regulate software practices that
    indirectly impact software supply chain concerns. The QSR mandates rigorous controls
    and processes to ensure the safety and effectiveness of medical devices, encompassing
    software components. This includes requiring manufacturers to validate and control
    the software integrated into their devices. Similarly, GDPR’s stringent requirements
    for protecting personal data necessitate that organizations implement robust technical
    and organizational measures, potentially extending to the security of software
    and its supply chain, especially if it processes personal data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: These frameworks and regulations contribute to a more secure and resilient software
    ecosystem, benefiting both businesses and consumers. However, the increased complexity
    can impact development teams. Understanding these requirements and integrating
    them into your processes is critical for successful compliance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Securing Modern Applications with Shift Left
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Against highly motivated hackers, our traditional wait-until-the-end security
    methods are not enough. Not only do these measures not provide the protection
    we require, but traditional security testing also slows the delivery of our software.
    To protect modern applications, organizations must use tools and practices designed
    for modern DevOps workflows. In this section we’ll look at the challenges organizations
    face in implementing security practices. In [Chapter 3](ch03.html#chapter_3_the_build_and_pre_deployment_testing_steps_of_cont_1749354010266208)
    we touched on shift-left security, the practice of implementing security practices
    in the earliest stages of development. We’ll look at how to use this approach
    to mitigate risks, as well as best practices for implementing shift-left security
    and managing vulnerabilities in a developer-friendly way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The Need for Developer-Friendly Shift-Left Security
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than waiting until the end of the software development cycle to test
    the security of your application, you must actively address and test security
    concerns at every possible stage. This approach not only saves time and effort
    by avoiding extensive reworking of the software code later on but also enhances
    the overall security and efficiency of the final product. [Figure 5-2](#chapter_5_figure_2_1749354010722665)
    contrasts a shift-left security approach with a traditional application security
    approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that effective shift-left security means more than performing
    security testing earlier in your delivery process. While this may help save developers
    from the cost of context switches that come when returning to code after days
    or weeks, it’s ultimately not saving work. A truly effective implementation requires
    choosing security tools that seamlessly integrate with your CI/CD pipelines. These
    tools should not only identify vulnerabilities but also prioritize them based
    on severity and provide actionable insights. The tools you choose should normalize
    and de-duplicate findings, to help developers avoid alert fatigue and concentrate
    on the most critical risks. This integrated approach ensures that security is
    absolutely central to the development process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ansd_0502.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Shift-left approach contrasted with a traditional testing approach
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Application Security Scanners
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are numerous scanners and tools available to do security testing and
    analysis, and many are now enhanced with AI capabilities. Let’s look at the most
    common categories of these scanners and tools:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Software composition analysis (SCA)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: This type of scanner identifies vulnerabilities in third-party components and
    dependencies by analyzing software bills of materials (SBOMs) to detect known
    vulnerabilities in libraries and frameworks. We’ll look at SBOMs later in this
    chapter. SCA tools feature significant ML capabilities around the likelihood a
    vulnerability can be reached or exploited. Snyk is one popular example of an SCA
    scanner.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Static application security testing (SAST)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: SAST tools analyze source code for potential vulnerabilities without executing
    the application by scanning code for patterns indicative of vulnerabilities, such
    as SQL injection, XSS, and buffer overflows. AI is enhancing SAST to reduce the
    incidence of false positives, wasting less engineer time. SonarQube, Checkmarx,
    and Fortify are examples of SAST tools.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Container scanning
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: This type of scanning identifies vulnerabilities in container images and their
    dependencies by analyzing the contents of container images for known vulnerabilities
    and configuration errors.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Secret detection scanning
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: This type of scanning detects sensitive information, such as API keys, passwords,
    and tokens, within code repositories and configuration files. With AI, secret
    detection tools are getting better at detecting obfuscated secrets and distinguishing
    between actual credentials and test data, reducing false positives and the associated
    toil.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic application security testing
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Thistesting method analyzes a running application to identify vulnerabilities
    by simulating external attacks. It interacts with the application like a real
    user to detect issues such as injection flaws, authentication problems, and configuration
    errors without needing access to the source code. AI-enhanced DAST tools generate
    test cases based on application behavior rather than using fixed patterns. They
    attempt to automatically validate their findings to tackle the false-positive
    problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure-as-Code scanning
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: This type of scan analyzes IaC files to identify security vulnerabilities, misconfigurations,
    and compliance issues before deployment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: These types of scanners are integrated early in software development pipelines,
    in line with the shift-left approach. Secret scanning is a recommended security
    practice that automatically identifies and alerts users to sensitive information
    in code repositories and other data sources.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: This prevents sensitive information from being incorporated into a codebase
    to begin with. SCA tools are also typically integrated early in the pipeline,
    after code is committed and before building. SAST scans can be part of a build
    phase. Container scanning is typically integrated after container images are built
    and before deployment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: By incorporating SCA, SAST, container scanning, secret scanning, DAST, and IaC
    scanning throughout your development pipelines, you can effectively implement
    shift-left security and proactively protect your applications from vulnerabilities.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Every issue that your test tools identify must be triaged. There is cost in
    reviewing the issue, determining if it is real or not, and then remediating it.
    False positives, issues that are reported but are not real, are a significant
    problem. They waste the time of the reviewer, draining resources from other security
    efforts and innovation. Further, by “crying wolf” they diminish the trust engineers
    place in security findings, and can slow response times to other, real problems.
    With this in mind, it’s no surprise that reducing the number of false positives
    is a key priority for AI in many scanning tools.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The triage problem is exacerbated by the number of scanners involved, which
    may find the same issues in different ways. In some organizations, there may even
    be multiple SAST tools used on the same codebase. In these environments, security
    test orchestration layers may be used to de-duplicate and normalize the findings
    into a single, manageable list. In an AI-native environment, AI/ML has a role
    to play here in pattern-matching as well as reducing developer toil.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Issues will be detected across all these types of scanners and need to be remediated.
    Security tools are increasingly offering automated or semi-automated remediation
    through specialized AI coding assistants to streamline this process for developers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Securing the Software Supply Chain
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we’ll examine common security risks inherent to today’s software
    supply chains. We’ll look at risks associated with code repositories, CI/CD pipelines,
    artifact repositories, open source dependencies, and the infrastructure underpinning
    your software development process. AI is transforming how organizations detect
    and respond to these risks by identifying patterns and anomalies across complex
    supply chains that would be impossible to monitor manually at scale. We’ll look
    at various frameworks and benchmarks you can use to assess the security of your
    toolchain. By the end of this section, you’ll have a better understanding of the
    potential threats and how to mitigate them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of modern software supply chains creates an ideal use case for
    artificial intelligence. AI systems can continuously monitor for suspicious patterns
    across repositories, build systems, and deployments. For example, ML models can
    detect unusual commit patterns that might indicate a compromised developer account,
    identify suspicious package behavior that signals a potential supply chain attack,
    or spot configuration drifts that could create security vulnerabilities. These
    AI capabilities provide unprecedented visibility and protection across interconnected
    components.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Top CI/CD Security Risks
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Open Worldwide Application Security Project (OWASP), a leading organization
    focused on improving software security, has identified the top 10 CI/CD security
    risks. As the following list illustrates, the range of threats are diverse. Understanding
    these risks and implementing the recommended mitigation strategies will help you
    secure and strengthen your CI/CD ecosystem:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient flow control mechanisms
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient flow control mechanisms in CI/CD pipelines can be exploited by
    attackers who can gain access to your pipeline. By bypassing necessary reviews
    and approvals, malicious code or artifacts can be pushed through the pipeline,
    potentially reaching production environments with severe consequences.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Inadequate identity and access management
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of managing numerous identities across various systems, combined
    with the tendency for overly permissive accounts, can lead to compromise. If any
    user account is compromised, attackers could gain extensive access, potentially
    reaching the production environment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Dependency chain abuse
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Dependency chain abuse refers to the exploitation of vulnerabilities in how
    your development and build systems fetch code dependencies. This can happen when
    these systems are tricked into fetching and executing malicious packages instead
    of legitimate ones. Attackers exploit it by publishing malicious packages with
    the same name as internal packages (dependency confusion), hijacking maintainer
    accounts (dependency hijacking), or relying on typos (typosquatting) to trick
    developers into downloading their packages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Poisoned pipeline execution
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: This is a cyberattack where malicious code is injected into a CI/CD pipeline,
    often through compromised source control systems. The poisoned code can then be
    executed within the pipeline, potentially granting attackers the same access and
    privileges as the build job. The attacker can manipulate build configuration files
    or other files the pipeline relies on, leading to actions such as credential theft,
    data exfiltration, or deployment of malicious artifacts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient pipeline-based access controls
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The risk arises when pipeline execution nodes have excessive access to resources
    and systems. This can be exploited by attackers to run malicious code within a
    pipeline, abusing the permissions granted to the pipeline to move laterally within
    or outside the CI/CD system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient credential hygiene
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient credential hygiene is a significant risk in environments where
    credentials are widely used across different systems and contexts. Examples include
    accidental code pushes containing credentials, insecure usage in build and deployment
    processes, unrotated credentials, and credentials being printed to console outputs
    or stored within container images.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Insecure system configuration
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Insecure system configuration is a common vulnerability due to the numerous
    systems and vendors in a typical toolchain. Misconfigurations, such as outdated
    software, overly permissive access controls, or insecure default settings, can
    easily be exploited by attackers to gain unauthorized access, manipulate CI/CD
    flows, or even compromise production environments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Ungoverned usage of third-party services
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Third-party services in CI/CD pipelines, while convenient and valuable for development,
    can easily be granted excessive access to sensitive resources, effectively expanding
    the attack surface of an organization. This lack of governance and visibility
    makes it difficult to maintain proper access controls, leaving organizations vulnerable
    to attacks if any of these third-party services are compromised.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Improper artifact integrity validation
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Due to the multiple stages and sources involved in software delivery, malicious
    actors can potentially tamper with artifacts without raising alarms. If not detected,
    these compromised artifacts can flow through the pipeline and eventually be deployed
    into production, executing malicious code and compromising systems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient logging and visibility
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Without robust logging, you’re essentially blind to malicious activities happening
    within your development pipeline, making it difficult to detect and respond to
    attacks in a timely manner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these risks and implementing the recommended mitigation strategies
    is key to building a secure and resilient CI/CD ecosystem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Top OSS Risks
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OSS dependency usage is ubiquitous, and so organizations must contend with the
    security and compliance risks that it brings. We previously mentioned two examples.
    In the first, the Log4j threat, thousands of systems were impacted. The second,
    the XZ Utils example, while caught early, illustrated how a malicious actor could
    wreak havoc by compromising an OSS component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Common vulnerabilities and exposures (CVEs) are one mechanism that organizations
    can use to identify known security problems in order to take steps to mitigate
    them. CVE monitoring tools automate the process of scanning your software and
    alerting you to the potential risks. While diligent monitoring can help you eliminate
    known threats from the OSS you use, it does not guarantee that your OSS components
    are truly safe. Unmaintained components or outdated dependencies also create risks,
    and because OSS packages bring in dozens of dependencies, these can be very complex
    to manage.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'While CVE management can help fight known threats, there are other classes
    of threats to contend with. The OWASP Foundation has created the following top
    10 list to capture a fuller spectrum of OSS risks that your organization needs
    to guard against:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Known vulnerabilities
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: An open source component can contain security flaws that are publicly disclosed,
    often through CVEs or other channels. These vulnerabilities, if exploitable in
    your software, can compromise your system’s confidentiality, integrity, or availability.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Compromise of legitimate package
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Attackers may inject malicious code into existing projects or distribution infrastructure
    by hijacking accounts or exploiting vulnerabilities. This can lead to code execution
    on end user or organizational systems, putting confidentiality, integrity, and
    availability at risk.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Name confusion attacks
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Name confusion attacks involve malicious actors creating components with names
    that closely resemble legitimate ones, aiming to trick users into installing them.
    These attacks can lead to the execution of harmful code on both user and organizational
    systems, compromising confidentiality, integrity, and availability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Unmaintained software
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Because unmaintained OSS components are no longer actively developed or supported,
    patches for new vulnerabilities might not be available. This situation can result
    in increased effort and longer resolution times for downstream developers who
    need to create their own patches.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Outdated software
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Using outdated software components in your projects can create significant challenges.
    It can make emergency updates difficult, especially if vulnerabilities are discovered
    in the version you’re using. Older releases also may not be as thoroughly tested
    for security issues as newer versions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Untracked dependencies
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Untracked dependencies can introduce vulnerabilities without the developers’
    knowledge. These dependencies may be missed due to incomplete SBOMs, limited SCA
    tool capabilities, or manual installation methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: License risk
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Open source components may have licenses that are incompatible with the intended
    use, violate legal requirements, or lack a license altogether. Using components
    without a license or failing to comply with license terms can lead to legal repercussions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Immature software
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Immature open source projects, lacking best practices like standard versioning,
    testing, or documentation, can introduce operational risks to your software. This
    lack of maturity may lead to unexpected behavior and increased development effort
    along with vulnerabilities.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Unapproved change
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Unapproved changes to software components can lead to compromised integrity
    and reproducibility of software builds.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Under-/oversized dependency
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Open source components can vary significantly in size and functionality, leading
    to security risks. Small components offer minimal functionality but can still
    introduce significant risk due to their reliance on upstream projects. Large components,
    while potentially offering more features, may have a larger attack surface due
    to unused capabilities and dependencies.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we’ll look at a framework—SLSA—that can help address these
    risks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring Integrity with Supply Chain Levels for Software Artifacts
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clearly, the risks of OSS are numerous. Before we leverage OSS or any third-party
    components in our own software, we must ask: Who wrote this software? Was it built
    and released with tools and on platforms that we can trust? What dependencies
    does it bring in? Does it conform to the regulatory requirements that are important
    to us?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Supply Chain Levels for Software Artifacts (SLSA, pronounced “salsa”) is a framework
    that provides a structured approach to answering these questions. SLSA is designed
    to bolster the integrity of software artifacts throughout the software supply
    chain. It enhances the security of software supply chains and can help address
    the OSS threats we’ve looked at.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the chain of custody for physical evidence, SLSA emphasizes the importance
    of tracking and verifying the integrity of software artifacts throughout their
    lifecycle. In this section, we’ll dig into SLSA and provide guidance on how to
    comply with its requirements to safeguard your software from potential threats.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: SLSA Overview
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SLSA is an open source project driven by the Open Source Security Foundation.
    With its focus on practical implementation and measurable security improvements,
    SLSA has gained significant traction.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: SLSA offers benefits to providers and consumers of OSS and vendor-provided software.
    Within your organization you can use SLSA to help secure your software development
    process from internal tampering. This ensures that the code that you deploy to
    production is the code you’ve built, tested, and signed off on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: For consumers of software, SLSA provides mechanisms to verify the authenticity
    and integrity of OSS. Package registries are able to use SLSA to guarantee that
    an uploaded OSS package is built from a source in a legitimate repository. As
    an OSS consumer, sourcing from trusted registries ensures the packages you download
    are valid. In addition, you can require that your vendors adhere to SLSA principles.
    Verifying vendor SLSA certifications from reputable third-party auditors can provide
    an extra layer of confidence.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[SLSA defines a tiered framework](https://oreil.ly/i7qar), allowing organizations
    to progressively enhance their software supply chain security. Levels represent
    increasing degrees of assurance and protection against tampering. An organization
    with no protections in place is considered at Level 0\.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: SLSA Level 1 is the foundation. Level 1 requires that basic provenance information
    be produced. This information should detail the build processes, describe dependencies,
    and give the source code location. Level 1 is the starting point for organizations
    embarking on their software supply chain security journey. Consumers can use this
    information to make decisions about the risks associated with the software.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Level 2 builds upon Level 1 by introducing stronger build requirements. Your
    build environment must be isolated and controlled. This level also mandates artifact
    signing for integrity verification, preventing tampering.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Level 3 requires source code provenance and build reproducibility.
    Provenance must be auditable and its integrity must be ensured.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-1](#chapter_5_table_1_1749354010727546) summarizes requirements at
    each of the three levels SLSA 1.0 defines.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. SLSA levels
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '| Implementer | Requirement | Degree | L1 | L2 | L3 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| Producer | Choose an appropriate build platform |  | ✓ | ✓ | ✓ |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '|  | Follow a consistent build process |  | ✓ | ✓ | ✓ |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '|  | Distribute provenance |  | ✓ | ✓ | ✓ |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| Build platform | Provence generation exists | Exists | ✓ | ✓ | ✓ |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '|  | Provence generation is ensured to be authentic | Authentic |  | ✓ | ✓
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '|  | Provence generation is unforgeable | Unforgeable |  |  | ✓ |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '|  | Isolation strength | Hosted |  | ✓ | ✓ |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '|  | Isolation strength | Isolated |  |  | ✓ |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: Using SLSA to Ensure Integrity
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following principles have guided the design decisions of the SLSA framework:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Trust a small number of platforms; focus on artifacts
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Extend trust to a few core platforms, such as build and packaging tools, and
    then automate the verification of artifacts produced by those platforms. For example,
    your trusted build platform produces and signs provenance attestations for each
    artifact it’s used to build. Downstream platforms then verify the provenance signed
    by the public key to automatically determine that an artifact meets the SLSA level.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Trace software back to source code, not individuals
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Establish a direct and verifiable link between the final software artifact and
    its original source code. This approach is in contrast with trusting individuals
    with write access to package registries and trusting the immutable and analyzable
    nature of code itself. By establishing a direct link, organizations can significantly
    reduce the risk of malicious code injection or unauthorized modifications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Prefer attestations over inferences
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Rely on direct evidence of an artifact’s origin over inferring the trustworthiness
    of the artifact based on knowledge of intermediary build systems or other systems.
    Instead of inferring the integrity, SLSA mandates explicit attestations about
    an artifact’s provenance. This requires concrete proof of an artifact’s build
    process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In SLSA 1.0, the build platform is central to ensuring artifact integrity. *Build
    platform* is used to refer to the systems responsible for compiling, packaging,
    and preparing your software for distribution. A robust build platform is essential
    for achieving higher SLSA levels. The system you select should support isolated
    builds, meaning for each build, new infrastructure is created, and after the build
    runs, the infrastructure is deleted. In addition, the system should enforce nonprivileged,
    containerized continuous integration steps that do not use volume mounts. This
    prevents access to the provenance key information in compliance with SLSA specifications.
    With a fortified build system, you are assured that malicious actors can’t tamper
    with your build.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In addition to choosing a build platform that can guarantee artifact integrity,
    your system should produce and distribute attestations (digitally signed records)
    that demonstrate that your software meets your desired SLSA build level. SLSA
    provenance attestations are cryptographic signatures that provide verifiable evidence
    about the origin and build process of a software artifact. They act as a digital
    passport, ensuring the integrity and authenticity of the artifact.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a container image built using a CI/CD pipeline. An SLSA provenance
    attestation for this image might include the following information:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The CI/CD platform used to build the image (e.g., GitHub Actions, GitLab CI/CD)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Invocation
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The specific build configuration or script used to create the image
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Materials
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The source code repositories, dependencies, and other inputs used in the build
    process
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Subject
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The artifact itself, identified by its unique digest (hash)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: A cryptographic signature generated by a trusted entity, verifying the authenticity
    and integrity of the attestation
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: To validate SLSA provenance attestations, organizations can use tools like the
    SLSA Verifier Service. This service verifies the authenticity of the attestation,
    checks the signature against the public key of the trusted signer, and ensures
    the attestation adheres to the SLSA specification.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: To achieve maximum security, SLSA recommends that build platforms, rather than
    individual developers, generate provenance. If your organization doesn’t use a
    build platform, consider adopting one with SLSA support. For third-party platforms,
    check their compatibility and request SLSA support if needed. If you maintain
    your own build platform, add SLSA provenance generation capabilities.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, package ecosystems should distribute SLSA provenance alongside software
    packages, embedding attestations within packages or providing them as separate
    metadata files. If your organization uses a third-party ecosystem, inquire about
    SLSA support and follow their guidelines. For direct distribution, include SLSA
    provenance within your package artifacts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging SLSA provenance attestations, your organization can gain confidence
    in the authenticity and integrity of software artifacts and reduce the risk of
    supply chain attacks.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing supply chain security beyond SLSA
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While SLSA provides an excellent framework for build integrity, it primarily
    focuses on artifact provenance and build system integrity. To address the full
    spectrum of supply chain risks identified in the OWASP Top Ten CI/CD risks, organizations
    need additional security measures.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'A comprehensive supply chain security strategy should include:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Continuous behavioral monitoring
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Modern delivery and security platforms, powered by AI and ML, are improving
    to detect anomalous activities across repositories, build systems, and deployment
    pipelines. These systems establish baselines of normal behavior and flag deviations
    that might indicate compromise. Monitoring and security tools such as Datadog
    CI and GitGuardian are popular choices today.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Advanced dependency analysis
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Beyond basic vulnerability scanning, intelligent analysis tools can evaluate
    package behavior, code patterns, and maintainer activity trends to identify potentially
    malicious dependencies before they’re publicly reported. AI-powered systems can
    detect subtle indicators of compromise by analyzing code semantics and behavior
    in ways that traditional scanners cannot, helping to protect against sophisticated
    supply chain attacks like dependency confusion or typosquatting.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Automated policy enforcement
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Implement automated policy guardrails throughout your pipelines that enforce
    security requirements beyond build integrity. These systems prevent overly permissive
    access, block dangerous configurations, and ensure proper secrets management—addressing
    risks like insufficient RBAC and credential hygiene that SLSA doesn’t fully cover.
    Today, implementing policy widely across a delivery platform is still unevenly
    done. Looking forward, it is a strong approach and one that will benefit from
    AI both in becoming more adaptable to changing threats and in rapid creation of
    policy through AI code generation assistance in PaC scenarios.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Supply chain risk prediction
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Predictive analytics and AI models analyze historical vulnerability trends and
    emerging threat intelligence to highlight components in your supply chain that
    pose higher potential risk, helping teams proactively address vulnerabilities
    before they become critical issues. By analyzing patterns across thousands of
    projects and dependencies, these systems identify risk factors in your environment
    before they lead to security incidents, enabling proactive hardening of vulnerable
    areas.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: By combining these AI-enhanced capabilities with SLSA’s build integrity focus,
    organizations can create a defense-in-depth approach that addresses the full range
    of supply chain risks. This comprehensive strategy protects not just the build
    process but also the entire software delivery pipeline, from development through
    deployment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Addressing AI-generated dependency risks
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As organizations increasingly adopt AI coding assistants, a new supply chain
    risk has emerged: AI hallucination squatting. This occurs when attackers register
    package names that AI tools incorrectly suggest through hallucinations, creating
    a vector for malicious code injection.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'While the core SLSA framework provides significant protection against traditional
    supply chain attacks, organizations using AI coding tools should implement additional
    safeguards:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Verified registry policies
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Configure package managers to only pull from officially vetted registries and
    private repositories with known-good packages. This prevents developers from inadvertently
    installing packages from untrusted sources, even if an AI assistant suggests them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Package age and popularity checks
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Implement tooling that automatically verifies recommended packages against minimum
    download counts and established history metrics. New packages with minimal usage
    should trigger additional review.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: AI confidence verification
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: When using AI coding assistants that provide confidence scores for their recommendations,
    implement processes to flag low-confidence package suggestions for manual verification
    against authoritative sources.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Preinstallation validation
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Add automated checks to your development environment that validate package existence
    and provenance in trusted repositories before allowing dependencies to be added
    to project files.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: These additional controls, when combined with SLSA practices and comprehensive
    SBOMs, create a defense-in-depth approach that protects against both traditional
    supply chain attacks and emerging AI-facilitated threats. By addressing the specific
    risks that AI introduces to the dependency selection process, organizations can
    safely leverage AI coding assistants while maintaining supply chain integrity.
    With the exception of AI confidence verification, each of these practices is helpful
    against other package-based attacks, such as typosquatting.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Addressing Zero-Day Vulnerabilities with Software Bill of Materials
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first section, we looked at the Log4j exploit that allowed attackers
    to execute arbitrary code remotely by exploiting a specific pattern in log messages,
    leading to widespread data breaches, ransomware attacks, and disruptions to critical
    services. This was an example of a zero-day exploit, one of the most insidious
    types of threats because it exploits vulnerabilities that are unknown to the software
    vendor, giving attackers a significant advantage before any defenses can be put
    in place. In this section, we’ll look at how an SBOM serves as an essential tool
    in the battle against this type of vulnerability. An SBOM provides a detailed
    inventory of all components and dependencies used in a software artifact. We’ll
    look at the composition and characteristics of SBOMs, and how they are managed
    throughout the SDLC.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: While dependency management tools and package managers have existed for years
    to track and manage software components, SBOM has witnessed significant advancements
    since 2018\. Collaborative efforts, including the National Telecommunications
    and Information Administration (NTIA) Multistakeholder Process, have developed
    best practices and recommendations for SBOMs. This collaborative effort brought
    together industry experts, government agencies, and academics to define standards
    and guidelines for SBOM generation, sharing, and consumption.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: As a result, SBOM has emerged as a key building block. In fact, [recent Linux
    Foundation research](https://oreil.ly/aIlVL) found that 78% of organizations were
    producing or consuming SBOMs in 2022, up 66% from the prior year.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two standards to choose from when creating SBOMs for your software:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: CycloneDX
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The CycloneDX project emerged as a leading standard for SBOMs, providing a machine-readable
    format for representing software components, dependencies, and their relationships.
    CycloneDX has gained widespread adoption and support from various organizations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: SPDX
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Software Package Data Exchange (SPDX) is another popular standard for SBOMs,
    sponsored by the Linux Foundation and codified in the ISO/IEC 5962 international
    standard. It offers a flexible and extensible format for representing software
    components. SPDX has been widely used in the open source community for many years.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: SPDX is a more established format with a broader scope, encompassing not only
    component information but also metadata about the SBOM itself, such as its creator
    and creation date. It’s particularly well-suited for managing OSS licenses and
    sharing information about packages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: CycloneDX is a newer format that offers a more structured and machine-readable
    approach, with a focus on providing detailed information about software components
    and their relationships. CycloneDX is often preferred for its flexibility and
    adaptability, making it suitable for a wide range of use cases. Your specific
    use case may determine which standard you adopt; the tools and processes you select
    for software supply chain security management should be able to support both standards.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the specific format you choose, the factors you use to assess
    the quality of the SBOM are the same. The NTIA has developed a set of minimum
    elements that SBOMs should contain to provide essential information about software
    components and their dependencies. Ensuring the presence of these elements will
    facilitate effective analysis of SBOMs across various tools and platforms, as
    well as adherence to the underlying SPDX or CycloneDX specification.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: By providing a comprehensive inventory of components, SBOMs offer transparency
    and traceability that can help ensure compliance with your organization’s security
    policies and legal requirements. PaC frameworks can leverage SBOMs to automate
    this compliance. With PaC you define security policies using code, which can be
    managed and version-controlled like code. These policies can then be applied to
    SBOMs, ensuring that software components adhere to the organization’s security
    standards for OSS. Automated compliance reduces the risk of human error and improves
    efficiency.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: For example, your organization might define a policy that only allows OSS components
    with permissive licenses (e.g., MIT, Apache License 2.0) to be used to ensure
    compatibility with the organization’s existing software portfolio and avoid potential
    legal issues.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: You might define apolicy to automatically reject OSS components with known vulnerabilities
    above a certain severity threshold. Or you could establish criteria for evaluating
    the reputation and trustworthiness of OSS vendors. This can include factors like
    vendor size, security practices, and community involvement.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Combining SBOMs with PaC creates a powerful framework for governing OSS usage,
    ensuring compliance, and mitigating security risks. Automating enforcement of
    security policies reduces the burden on security teams and improves overall efficiency.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Using SBOMs to Remediate Dependency Issues
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In complex codebases with countless dependencies, pinpointing and fixing affected
    artifacts can be a daunting task. Adhering to the following best practices can
    help your organization be ready to react quickly to zero-day exploits and other
    threats:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Keep SBOMs up-to-date
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that SBOMs are generated automatically as part of your CI/CD processes.
    This ensures that you always have up-to-date information about your software’s
    dependencies for every artifact your organization supports.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Utilize automated vulnerability scanning tools
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Employ automated tools to scan your SBOMs against vulnerability databases. These
    tools can identify known vulnerabilities in your dependencies in a timely way,
    allowing you to prioritize remediation efforts and address potential security
    threats.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Establish a robust patch management process
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Develop a well-defined process for patching vulnerabilities identified in your
    SBOMs. This includes setting priorities for patching, coordinating with vendors,
    and testing patches before deployment. By maintaining an up-to-date and secure
    software supply chain, you can significantly reduce the risk of zero-day exploits
    being used.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'AI significantly enhances these best practices. Intelligent SBOM analysis systems
    can:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Predict vulnerability impact
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: AI models can analyze your application architecture to determine if a vulnerable
    component is in an exploitable position, distinguishing between theoretical vulnerabilities
    and those that pose immediate risk. This contextual analysis helps teams focus
    on the most critical issues first.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Automate dependency updates
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: When vulnerabilities are identified, AI systems can automatically generate pull
    requests with appropriate dependency updates, test compatibility with your codebase,
    and manage the update process across multiple repositories. This automation dramatically
    reduces the time from vulnerability disclosure to remediation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Identify hidden dependencies
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: ML algorithms can detect undocumented or transitive dependencies that might
    not be explicitly captured in package manifests, providing a more complete view
    of your actual attack surface.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Adopting DevSecOps Principles
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen in this chapter how vulnerable the software supply chain is. Consistently
    delivering software in a secure manner requires more than careful vetting of the
    tools and third-party components that you use. It requires more than choosing
    CI/CD tools and technologies that support SLSA and the generation of SBOMs and
    attestations. To ensure consistent secure delivery, your team must maintain a
    secure platform, conduct thorough vulnerability testing, prioritize and fix issues
    promptly, prevent insecure code releases, comply with regulations, and guarantee
    the integrity of your software and all of its components.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: This cannot be the work of a single role on your team or a single team within
    your organization. It requires a collaborative approach that integrates security
    into the entire SDLC. This is what a DevSecOps approach speaks to. Unlike traditional
    approaches where security is added on in a few places, DevSecOps promotes continual
    collaboration between development, security, and operations teams, ensuring that
    security is considered from the beginning.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explain DevSecOps principles and show how adopting these
    principles will help you to more quickly identify and remediate vulnerabilities,
    reduce the risk of breaches, and improve the overall security of your software.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Establish a Collaborative Culture and Break Down Functional Silos
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and most vital step to successfully implementing DevSecOps is to establish
    a collaborative culture with a security-first mindset. Naturally, this can be
    the most difficult step and requires the full support of your organization’s leadership
    team. Security must be an organizational priority and become a responsibility
    shared by developers, operations, security teams, and others.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: A simple way to break down silos and establish a shared sense of ownership is
    to create cross-functional DevSecOps teams. Siloed teams can limit communication
    and knowledge sharing, which can lead to duplicated efforts and inconsistent processes.
    In contrast, cross-functional DevSecOps teams foster collaboration and open communication.
    By including the perspective of development, operations, and security roles when,
    for example, establishing a new security practice or selecting a new security-related
    tool, you can more easily get the buy-in and alignment needed to be successful.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In addition, cross-functional teams can help prevent selections or recommendations
    that create bottlenecks and strain productivity. An example of this would be a
    unilateral mandate to impose some new application security checks without considering
    their impact on the development process. The impact of this would be increased
    workload for developers, which strains not only productivity but also the trust
    and goodwill within your organization.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: In addition to creating cross-functional teams, you should identify and support
    a few key security champions across your organization to help promote security
    initiatives and raise awareness among their peers. Use your cross-functional teams
    and security champions to share ideas and communicate your progress by establishing
    open and transparent communication channels to facilitate the exchange of information
    and ideas. This can include regular meetings, team chats, and knowledge-sharing
    sessions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: AI tools serve as collaborative bridges between security and development teams
    by providing shared context and translating between security and development concerns.
    For example, when an AI-powered security tool identifies a vulnerability, it can
    explain the issue in developer-friendly terms while also providing the security
    context that security teams need. This shared understanding reduces friction between
    teams and helps establish a security culture where everyone speaks the same language.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, invest in security training. Identify skills gaps and provide ongoing
    security training to all team members, equipping them with the knowledge and skills
    to identify and mitigate security risks. This not only raises the bar of the entire
    team, but also demonstrates your organizational commitment to security as a priority.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Adopt and Enforce Secure Coding Methodologies and Shift-Left
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Secure coding practices are essential for preventing vulnerabilities. The OWASP
    Top 10 and Common Weakness Enumeration (CWE) provide helpful guidance for identifying
    and addressing common security vulnerabilities. In addition, ensure your methodologies
    address the following common threats:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Input validation
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Always validate user input to prevent malicious data from being injected into
    your application. This can help prevent SQL injection, XSS, and other injection
    attacks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Output encoding
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Properly encode output to prevent XSS attacks. This ensures that user-generated
    content is displayed safely on the page without allowing malicious code to be
    executed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Implement robust error handling to prevent information leakage and potential
    vulnerabilities. Avoid displaying sensitive error messages that could provide
    attackers with valuable information.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Session management
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Use secure session management techniques to protect user data and prevent unauthorized
    access. This includes using strong session identifiers and implementing timeouts.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Implement strong authentication mechanisms and enforce proper authorization
    controls to restrict access to sensitive resources.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Use secure cryptographic algorithms and practices to protect sensitive data.
    Avoid weak encryption methods and ensure proper key management.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Keep dependencies up-to-date and manage them securely to avoid vulnerabilities.
    Use tools like dependency scanners to identify and address known vulnerabilities
    in third-party libraries.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: While staying informed about the latest threats and secure coding can prevent
    many vulnerabilities, your organization’s best efforts won’t be infallible. Static
    and dynamic analysis tools, along with early-stage security testing, act as a
    backstop, catching issues that might be overlooked in code reviews. This is where
    shift-left comes in. We’ve covered how shift-left enables you to identify and
    address vulnerability at an early stage. Early remediation reduces the risk of
    vulnerabilities getting released into production code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security cannot be an afterthought in modern software development. It must
    be an integral part of the entire development process. As we’ve seen throughout
    this chapter, an AI-native approach to security transforms:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: How vulnerabilities are discovered, using intelligent analysis rather than just
    static rules
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How findings are prioritized, based on actual risk rather than generic severity
    ratings
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How remediations are implemented, with automated guidance and code generation
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How supply chains are secured, through continuous monitoring and anomaly detection
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How teams collaborate, with shared context and understanding across security
    and development
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By embedding security into every phase, from design to deployment, and by fostering
    a culture of shared responsibility augmented by AI, organizations can build and
    deliver applications that are fortified against modern threats.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html#chapter_6_chaos_engineering_and_service_reliability_1749354010916149),
    we’ll turn our attention to making our apps more resilient by using chaos testing
    to uncover weaknesses that might otherwise go undetected.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html#chapter_6_chaos_engineering_and_service_reliability_1749354010916149)，我们将关注如何通过混沌测试来提高我们应用程序的弹性，以揭示可能被忽视的弱点。
