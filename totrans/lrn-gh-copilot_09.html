<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Other Ways to Leverage Copilot"><div class="chapter" id="ch08">
<h1><span class="label">Chapter 8. </span>Other Ways to Leverage Copilot</h1>

<p>As we’ve seen, Copilot provides a lot of value for working with traditional coding flows as well as traditional tasks like testing and documentation. Copilot can also help in many less common use cases encountered by programmers.</p>

<p>We can’t cover all those use cases in this chapter or even in this book, but we can cover some representative examples. As a heads-up, the structure of this chapter is different from that of the other chapters. We’ll be covering multiple, diverse use cases rather than focusing on one overall feature or functional area. The examples we’ll look at are outlined in the next few paragraphs.</p>

<p>You may primarily think of using GitHub Copilot for coding in popular languages like JavaScript and Python. However, Copilot has access to all the languages that the model you’re using was trained on. So, you can also use it on ones that we don’t think of as traditional programming languages. An example is one we’ve touched on before—SQL<a contenteditable="false" data-primary="SQL (Structured Query Language)" data-type="indexterm" id="id831"/>—commonly used to work with relational databases. Copilot can simplify a surprising number of database-related tasks when you’re working with queries, schemas, and stored procedures.</p>

<p>Frameworks, such as Kubernetes<a contenteditable="false" data-primary="Kubernetes" data-type="indexterm" id="id832"/>, also make use of an ordered format (most commonly expressed in YAML). While these frameworks are declarative rather than imperative, their syntax and structure are understood by Copilot. It can provide completion suggestions and answers about how to work with them, just as for any programming language.</p>

<p>Then there are regular expressions—those often complex and cryptic strings of characters. When you need one, they are important to get correct but usually frustrating to try to create. Copilot can make easy work of these.</p>

<p>For testing a regular expression or unit-testing a function, you may also need structured test data. With specific prompting, Copilot can generate nearly any simple data structures needed, although there are a few nuances to be aware of.</p>

<p>Finally, it’s worth noting that some Copilot functionality is embedded in the GitHub CLI application. While this is currently limited, it’s reasonable to expect more functionality to be added over time.</p>

<p>We’ll cover all of these in this chapter, starting with how Copilot can be used when you’re working with SQL.</p>

<section data-type="sect1" data-pdf-bookmark="Using Copilot with SQL"><div class="sect1" id="id128">
<h1>Using Copilot with SQL</h1>

<p><a contenteditable="false" data-primary="GitHub Copilot" data-secondary="using with SQL" data-type="indexterm" id="xi_GitHubCopilotusingwithSQL8234"/><a contenteditable="false" data-primary="SQL (Structured Query Language)" data-secondary="using Copilot with" data-type="indexterm" id="xi_SQLStructuredQueryLanguageusingCopilotwith8234"/>While technically a programming language, SQL brings its own unique constructs to data management. These include the standard queries used with the data and schema in the database, indices for efficiencies, and stored procedures for more complex tasks.</p>

<p>In this section, we’ll look at three areas where Copilot can help:</p>

<ul>
	<li>Using Copilot to help with queries</li>
	<li>Working with stored procedures</li>
	<li>Performing optimization</li>
</ul>

<p>Let’s start by looking at the basic ways that Copilot can assist with generating SQL-related queries.</p>

<section data-type="sect2" data-pdf-bookmark="Queries"><div class="sect2" id="id90">
<h2>Queries</h2>

<p><a contenteditable="false" data-primary="queries and querying" data-secondary="SQL" data-type="indexterm" id="xi_queriesandqueryingSQL8384"/><a contenteditable="false" data-primary="SQL (Structured Query Language)" data-secondary="queries" data-type="indexterm" id="xi_SQLStructuredQueryLanguagequeries8384"/>As you know, Copilot draws from local content to get context. So if you are working in your editor and open a file with an extension of <em>.sql</em> or that contains SQL statements, Copilot can pick up on that to know that it needs to generate SQL. You can also use comments to help clue Copilot in further on what you want.</p>

<p><a data-type="xref" href="ch07.html#ch07">Chapter 7</a> showed an example of how to add context to make code generation and suggestions more relevant. There we used the technique of opening up an SQL file that had all the database schema definitions for a university student and course registration system to give Copilot more context for generating queries.</p>

<p>You can refer back to <a data-type="xref" href="ch07.html#addingContextCh7">“Adding Context to Make Code More Relevant”</a> if you need a reminder, but we’ll assume the same setup here. Here is a partial schema definition underlying the registration system:</p>

<pre data-type="programlisting" translate="no" class="pagebreak-before">
-- create tables
...

CREATE TABLE courses.students (
    student_id INT IDENTITY (1, 1) PRIMARY KEY,
    first_name VARCHAR (255) NOT NULL,
    last_name VARCHAR (255) NOT NULL,
    phone VARCHAR(25),
    email VARCHAR (255) NOT NULL,
    city VARCHAR (50),
    state VARCHAR (25),
    zip_code VARCHAR (5)
);

...

CREATE TABLE courses.registrations (
    registration_id INT IDENTITY (1, 1) PRIMARY KEY,
    student_id INT,
    registration_status tinyint NOT NULL,
    -- Registration status: 1 = Pending; 2 = Enrolled; 3 = Rejected;
 4 = Completed
    registration_date DATE NOT NULL,
    required_date DATE NOT NULL,
    completion_date DATE,
    location_id INT NOT NULL,
    staff_id INT NOT NULL,
    FOREIGN KEY (student_id) REFERENCES courses.students 
(student_id)
 ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (location_id) REFERENCES courses.locations 
(location_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (staff_id) REFERENCES courses.staffs (staff_id) ON 
DELETE NO ACTION ON UPDATE NO ACTION

...

CREATE TABLE courses.registration_items (
    registration_id INT,
    item_id INT,
    course_id INT NOT NULL,
    quantity INT NOT NULL,
    class_hours DECIMAL (10, 2) NOT NULL,
    lab_hours DECIMAL (4, 2) NOT NULL DEFAULT 0,
    PRIMARY KEY (registration_id, item_id),
    FOREIGN KEY (registration_id) REFERENCES courses.registrations 
(registrations_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (course_id) REFERENCES curriculum.subjects 
(course_id) ON DELETE CASCADE ON UPDATE CASCADE
);

</pre>

<p>If we open this up in the editor where we are working on our queries and then prompt Copilot via a comment to generate an SQL query to get all students enrolled in a course, we get a detailed result with table names, field names, etc. that match the schema:</p>

<pre data-type="programlisting" translate="no">
-- define a select statement to get all students enrolled in a 
course


SELECT students.first_name, students.last_name, students.email,
 students.phone, students.city, students.state, students.zip_code
FROM courses.students
JOIN courses.registrations
ON students.student_id = registrations.student_id
JOIN courses.registration_items
ON registrations.registration_id = 
registration_items.registration_id
WHERE registration_items.course_id = 1;
</pre>

<p>By simply having the other file open in the workspace, Copilot was able to draw on that content to create a better query for us.</p>

<div data-type="note" epub:type="note">
<h1>Save Your Work</h1>

<p>Remember to first save any new files as part of the project that you want Copilot to be able to use in context.</p>
</div>

<p>As another example, we could ask Copilot to create a table for student attendance to capture attendance by class. Given the same context of the larger schema table, Copilot should respond with a complete table definition:</p>

<pre data-type="programlisting" translate="no">
-- define a table for student attendance to capture attendance by
 class
CREATE TABLE courses.attendance (
    attendance_id INT IDENTITY (1, 1) PRIMARY KEY,
    registration_id INT NOT NULL,
    attendance_date DATE NOT NULL,
    attendance_status tinyint NOT NULL,
    -- Attendance status: 1 = Present; 2 = Absent; 3 = Late; 
4 = Excused
    FOREIGN KEY (registration_id) REFERENCES courses.registrations 
(registration_id) ON DELETE CASCADE ON UPDATE CASCADE
);
</pre>

<p>The format of this table is similar to the format used in the schema file for the <em>courses.registration</em> table, as shown next. Notice that both table definitions use status values of 1–4:</p>

<pre data-type="programlisting" translate="no">
CREATE TABLE courses.registrations (
    registration_id INT IDENTITY (1, 1) PRIMARY KEY,
    student_id INT,
    registration_status tinyint NOT NULL,
    -- Registration status: 1 = Pending; 2 = Enrolled; 3 = Rejected;
 4 = Completed
    registration_date DATE NOT NULL,
    required_date DATE NOT NULL,
    completion_date DATE,
    location_id INT NOT NULL,
    staff_id INT NOT NULL,
    FOREIGN KEY (student_id) REFERENCES courses.students 
(student_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (location_id) REFERENCES courses.locations 
(location_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (staff_id) REFERENCES courses.staffs (staff_id)
 ON DELETE NO ACTION ON UPDATE NO ACTION
</pre>

<p>We can also have Copilot generate more complex types of SQL data like stored <span class="keep-together">procedures</span><a contenteditable="false" data-primary="" data-startref="xi_queriesandqueryingSQL8384" data-type="indexterm" id="id833"/><a contenteditable="false" data-primary="" data-startref="xi_SQLStructuredQueryLanguagequeries8384" data-type="indexterm" id="id834"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Stored Procedures"><div class="sect2" id="id91">
<h2>Stored Procedures</h2>

<p><a contenteditable="false" data-primary="SQL (Structured Query Language)" data-secondary="stored procedures" data-type="indexterm" id="xi_SQLStructuredQueryLanguagestoredprocedures81714"/><a contenteditable="false" data-primary="stored procedures, SQL" data-type="indexterm" id="xi_storedproceduresSQL81714"/>A <em>stored procedure</em> is prepared SQL code that is saved and can be reused easily. Copilot can help us generate these as well. Continuing with our university registration example, let’s ask Copilot to create a new stored procedure for getting a list of enrolled students at a particular location. We can use a simple prompt in chat (similar to the comment form we used earlier) to tell Copilot what we want. The prompt is “define a stored procedure to get course enrollment by location.”</p>

<p>With this prompt and the additional context of the schemas, Copilot produces a reasonable result:</p>

<pre data-type="programlisting" translate="no">
CREATE PROCEDURE GetCourseEnrollmentByLocation
    @CourseID INT
AS
BEGIN
    SELECT students.city, students.state, COUNT(*) AS 
enrollment_count
    FROM courses.students
    JOIN courses.registrations
    ON students.student_id = registrations.student_id
    JOIN courses.registration_items
    ON registrations.registration_id = 
registration_items.registration_id
    WHERE registration_items.course_id = @CourseID
    GROUP BY students.city, students.state;
END</pre>

<p>We can also be more directive. The more prescriptive we are with the prompt, the more likely that Copilot will generate better results. For example, consider the following very specific prompt in the chat interface:</p>

<pre data-type="programlisting" translate="no">
define a stored procedure to get instructor details associated with 
a location include instructor details, location details, and courses
associated with the instructor use instructor_id as the input 
parameter
</pre>

<p>Copilot first explained its thinking in terms of a plan and then generated the detailed code to match the prompt:</p>

<pre data-type="programlisting" translate="no">
<strong>Plan</strong>
1. Define a new stored procedure named 
`GetInstructorDetailsByLocation`.
2. Accept `@InstructorID` as an input parameter.
3. Select instructor details, location details, and courses 
associated with the instructor.
4. Use appropriate joins to fetch data from the `instructors`, 
`locations`, and [`courses`]
5. Group the results by instructor and location details.

<strong>SQL Code</strong>
CREATE PROCEDURE GetInstructorDetailsByLocation
    @InstructorID INT
AS
BEGIN
    SELECT
        instructors.instructor_id,
        instructors.first_name,
        instructors.last_name,
        instructors.email,
        locations.city,
        locations.state,
        courses.course_id,
        courses.course_name
    FROM
        courses.instructors
    JOIN
        courses.locations
    ON
        instructors.location_id = locations.location_id
    JOIN
        courses.course_instructors
    ON
        instructors.instructor_id = 
course_instructors.instructor_id
    JOIN
        courses.courses
    ON
        course_instructors.course_id = courses.course_id
    WHERE
        instructors.instructor_id = @InstructorID;
END;
</pre>

<p>While it’s helpful to have Copilot generating queries and stored procedures for us, that’s not its only SQL skill. The AI can also help optimize what we create<a contenteditable="false" data-primary="" data-startref="xi_SQLStructuredQueryLanguagestoredprocedures81714" data-type="indexterm" id="id835"/><a contenteditable="false" data-primary="" data-startref="xi_storedproceduresSQL81714" data-type="indexterm" id="id836"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Optimizations"><div class="sect2" id="id92">
<h2>Optimizations</h2>

<p><a contenteditable="false" data-primary="SQL (Structured Query Language)" data-secondary="optimizations" data-type="indexterm" id="xi_SQLStructuredQueryLanguageoptimizations82544"/><a contenteditable="false" data-primary="optimizations, SQL" data-type="indexterm" id="xi_optimizationsSQL82544"/>Copilot can make the code we have more efficient and can do so in two main ways. The first is by writing code leveraging built-in constructs that the language or framework provides for optimization. The second is by optimizing existing code.</p>

<p>As an example of the first case, SQL provides indexes to speed up operations. Refer back to the query we worked with earlier in this chapter to get all students enrolled in a course. The complete query is listed here:</p>

<pre data-type="programlisting" translate="no">
-- define a select statement to get all students enrolled in a
course


SELECT students.first_name, students.last_name, students.email,
students.phone, students.city, students.state, students.zip_code
FROM courses.students
JOIN courses.registrations
ON students.student_id = registrations.student_id
JOIN courses.registration_items
ON registrations.registration_id =
registration_items.registration_id
WHERE registration_items.course_id = 1;
</pre>

<p>For this query, we can use a separate index to speed up operations. We ask Copilot to create a new index based on this query with the prompt “-- write an index to improve the performance of the query.” From this prompt, Copilot might suggest SQL like the following:</p>

<pre data-type="programlisting" translate="no">
-- write an index to improve the performance of the query

create index idx_registration_status_date on courses.registrations
(registration_status, registration_date);
</pre>

<p>As with the original query, Copilot was able to draw on the context of available code to create an index that uses the existing field names, table names, etc.</p>

<p>In addition to creating code to help optimize execution, Copilot can optimize static code. This is the second use case mentioned at the start of this section. Suppose we have a query to get all the course registrations for September 2024. It might look like this:</p>

<pre data-type="programlisting" translate="no">
select * from courses.registrations where year(registration_date) 
= 2024 and month(registration_date) = 9;</pre>

<p>We can select this query and then prompt Copilot to optimize it via the prompt “optimize this query.”</p>

<p class="pagebreak-before">The AI then suggests an optimization that uses direct starting and ending dates instead:</p>

<pre data-type="programlisting" translate="no">
SELECT * FROM courses.registrations WHERE registration_date &gt;= 
'2023-09-01' AND registration_date &lt; '2023-10-01'
</pre>

<p>In the same output, Copilot also provides additional background on <em>why </em>this is an improvement:</p>

<pre data-type="programlisting" translate="no">
...using functions or columns in the WHERE clause can prevent the
use of indexes and slow down the query. If registration_date is 
indexed, you can optimize the query by avoiding the use of the
YEAR() and MONTH() functions and instead comparing against a range 
of dates... 
</pre>

<p>Copilot not only suggested an optimization but also told us why and under what conditions this would actually be an optimization. Nice.</p>

<p>Now that you’ve seen how Copilot works with managing coding for databases, let’s look at how it handles a framework by using declarative specifications<a contenteditable="false" data-primary="" data-startref="xi_GitHubCopilotusingwithSQL8234" data-type="indexterm" id="id837"/><a contenteditable="false" data-primary="" data-startref="xi_SQLStructuredQueryLanguageusingCopilotwith8234" data-type="indexterm" id="id838"/><a contenteditable="false" data-primary="" data-startref="xi_SQLStructuredQueryLanguageoptimizations82544" data-type="indexterm" id="id839"/><a contenteditable="false" data-primary="" data-startref="xi_optimizationsSQL82544" data-type="indexterm" id="id840"/>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Working with YAML and Kubernetes"><div class="sect1" id="id93">
<h1>Working with YAML and Kubernetes</h1>

<p><a contenteditable="false" data-primary="YAML, working with" data-type="indexterm" id="xi_YAMLworkingwith83204"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="working with" data-type="indexterm" id="xi_Kubernetesworkingwith83204"/>YAML is a critical formatting language for many applications today. It can also be painful to work with because of its syntax and strict formatting requirements. But the ability to create specifications and configurations is key for applications like <span class="keep-together">Kubernetes</span>.</p>

<p>Kubernetes itself can also be challenging to work with for multiple reasons. These include learning and remembering how to define objects you want in YAML files. Each native object has a common set of attributes, but then each also has its own specification (spec). The challenges can multiply when trying to scale objects for a service or product. Since any error or incorrect formatting can cause your app not to function, we can leverage AI to good effect here.</p>

<p>Suppose we want to code up a new deployment in Kubernetes. A <em>deployment<a contenteditable="false" data-primary="deployment" data-type="indexterm" id="id841"/></em> is a type of object in Kubernetes that instantiates and manages multiple instances of a Kubernete<a contenteditable="false" data-primary="Kubernetes" data-secondary="pods" data-type="indexterm" id="id842"/>s <em>pod<a contenteditable="false" data-primary="pod, Kubernetes" data-type="indexterm" id="id843"/>. </em>The pod, in turn, wraps one or more containers. The containers are based on images and provide a self-contained environment for an app to execute in.</p>

<p class="pagebreak-before">Armed with basic knowledge of the parts, we can prompt Copilot to produce a YAML spec for a deployment via the chat interface:</p>

<pre data-type="programlisting" translate="no">
write spec for deployment in Kubernetes with 2 replicas and image
from busybox
add command to run in containers: sleep 3600
add label app: myapp
add label type: front-end</pre>

<p>After a few moments, Copilot will suggest something like this:</p>

<pre data-type="programlisting" translate="no">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
  labels:
    app: myapp
    type: front-end
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
        type: front-end
    spec:
      containers:
      - name: busybox-container
        image: busybox
        command: ["sleep", "3600"]</pre>

<p>If you don’t know Kubernetes, this is valid syntax and mirrors what we would expect to have as a deployment spec. Notice that no personal knowledge of the Kubernetes syntax was needed to generate this other than the type of objects that should be in the spec. We can save this file as <em>deployment.yaml</em> and move on.</p>

<p class="pagebreak-before">Now that we have this spec, we will want to execute it at some point. If we’re not clear on the process for that, we can ping Copilot about it. We simply go to the chat interface and ask, “How do I execute this?” As shown in <a data-type="xref" href="#copilot-explains-how">Figure 8-1</a>, Copilot references the <em>deployment.yaml</em> file we created and then provides instructions to get it into the Kubernetes cluster (a system of machines for running Kubernetes) and verify that the deployment is running. It does this using the Kubernetes CLI called <code translate="no">kubectl</code>.</p>

<figure><div id="copilot-explains-how" class="figure"><img alt="" src="assets/lghc_0801.png" width="1252" height="706"/>
<h6><span class="label">Figure 8-1. </span>Copilot explains how to apply the spec to Kubernetes for execution</h6>
</div></figure>

<p>This is very helpful, but what if at some point we need to move to managing this Kubernetes deployment via the Kubernetes API instead of the CLI? And we’d also like to do it using Python and be able to change (scale) the number of instances of the container it’s running.</p>

<p>We can query Copilot about this through another simple natural language prompt in chat:</p>

<pre data-type="programlisting" translate="no">
How do I call the K8s API for scaling a deployment to 5 replicas
 with Python?</pre>

<p>Copilot first tells us that we can do this using the Kubernetes Python client library and then dumps out the Python code for the task (<a data-type="xref" href="#copilots-response-to">Figure 8-2</a>).</p>

<figure><div id="copilots-response-to" class="figure"><img alt="" src="assets/lghc_0802.png" width="1266" height="669"/>
<h6><span class="label">Figure 8-2. </span>Copilot’s response to manage Kubernetes in Python</h6>
</div></figure>

<p>Beyond this, Copilot provides a helpful explanation of the steps needed to run the code (<a data-type="xref" href="#steps-for-execution">Figure 8-3</a>).</p>

<figure><div id="steps-for-execution" class="figure"><img alt="" src="assets/lghc_0803.png" width="1142" height="644"/>
<h6><span class="label">Figure 8-3. </span>Steps for execution</h6>
</div></figure>

<p>We can then save the suggested code as a new file in the editor and proceed with any edits we want to make, testing the code, etc.</p>

<p>Let’s throw one more challenge at Copilot. The more common programming language for Kubernetes is Go<a contenteditable="false" data-primary="Go code" data-type="indexterm" id="id844"/>. So, if we want to migrate this Python code to Go, can Copilot help? As it turns out, it can! And it’s very simple to do. With the Python code selected (and therefore referenced), all we need to do is tell Copilot to “Convert to Go.” Copilot then produces the equivalent pieces for Go code in the chat interface (<a data-type="xref" href="#code-for-kubernetes-d">Figure 8-4</a>).</p>

<figure><div id="code-for-kubernetes-d" class="figure"><img alt="" src="assets/lghc_0804.png" width="1106" height="706"/>
<h6><span class="label">Figure 8-4. </span>Code for Kubernetes deployment in Go</h6>
</div></figure>

<p>Copilot also provides a corresponding explanation and instructions on execution as it did for the Python version (<a data-type="xref" href="#steps-to-execute-go-c">Figure 8-5</a>).</p>

<figure><div id="steps-to-execute-go-c" class="figure"><img alt="" src="assets/lghc_0805.png" width="1159" height="706"/>
<h6><span class="label">Figure 8-5. </span>Steps to execute Go code</h6>
</div></figure>

<p>Yet again, we see an example of how Copilot can automate and simplify creating processing for complex tasks.</p>

<p>Another often complex task that Copilot can greatly simplify is creating regular expressions. That’s the topic of our next section<a contenteditable="false" data-primary="" data-startref="xi_YAMLworkingwith83204" data-type="indexterm" id="id845"/><a contenteditable="false" data-primary="" data-startref="xi_Kubernetesworkingwith83204" data-type="indexterm" id="id846"/>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Generating Regular Expressions"><div class="sect1" id="id94">
<h1>Generating Regular Expressions</h1>

<p><a contenteditable="false" data-primary="regular expressions, generating" data-type="indexterm" id="xi_regularexpressionsgenerating84114"/>Most developers are not a fan of having to come up with the syntax for regular expressions. The process of trying to find a combination of letters, numbers, and symbols to effectively match a set of strings can be time consuming and frustrating. Add to that the need to devise tests that comprehensively test out the expression, and it becomes preferable to try to find something that matches closely from other code or from a resource like Stack Overflow.</p>

<p>However, this is yet another area where Copilot shines. Given a suitable prompt, Copilot can easily create a corresponding regular expression. For example, suppose we tell Copilot to “Create a regular expression to validate a SSN” (where <em>SSN</em> stands for a <em>US Social Security number</em>). Copilot responds with the following implementation suggestion and explanation:</p>

<pre data-type="programlisting" translate="no">
Here is a regular expression to validate a U.S. Social Security
 Number (SSN):

^\d{3}-\d{2}-\d{4}$

Explanation:

 • ^ asserts the start of the string.
 • \d{3} matches exactly 3 digits.
 • - matches a literal hyphen.
 • \d{2} matches exactly 2 digits.
 • - matches another literal hyphen.
 • \d{4} matches exactly 4 digits.
 • $ asserts the end of the string.

Example Usage in Python:

python
import re

def validate_ssn(ssn):
    pattern = r"^\d{3}-\d{2}-\d{4}$"
    return bool(re.match(pattern, ssn))

# Test the function
print(validate_ssn("123-45-6789"))  # True
print(validate_ssn("123-456-789"))  # False

This ensures the SSN is in the format `XXX-XX-XXXX` where `X`
 is a digit.
</pre>

<p>We may also want to generate a function that uses a regular expression for whatever language we’re coding in. Assume that we have a JavaScript file (<em>phone.js</em>), and we want a function in it to validate any global phone number.</p>

<p>We can prompt Copilot with “create a function to validate any global phone number using a regular expression.” Copilot, in turn will produce JavaScript code like this:</p>

<pre data-type="programlisting" translate="no">
function validatePhoneNumber(phoneNumber) {
    const phoneRegex = /^\+(?:[0-9] ?){6,14}[0-9]$/;
    return phoneRegex.test(phoneNumber);
}

// Example usage:
console.log(validatePhoneNumber("+1234567890")); // true
console.log(validatePhoneNumber("1234567890")); // false</pre>

<p>Notice that while the code is short, the regular expression is not simple. And Copilot also provided example calls to use to validate the function. If the use cases in the examples don’t match what you were intending, you could reject the suggestion and use a more detailed prompt to get what you need.</p>

<p>After generating a regular expression, you may want some simple data to use for testing it, or you might need some data to do basic testing on some other part of your code. Rather than having to find or create this kind of data yourself, you can create it automatically with Copilot<a contenteditable="false" data-primary="" data-startref="xi_regularexpressionsgenerating84114" data-type="indexterm" id="id847"/>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Automatic Data Generation"><div class="sect1" id="id95">
<h1>Automatic Data Generation</h1>

<p><a contenteditable="false" data-primary="automatic data generation" data-type="indexterm" id="xi_automaticdatageneration84704"/><a contenteditable="false" data-primary="data generation, automatic" data-type="indexterm" id="xi_datagenerationautomatic84704"/>Another area where Copilot can come to the rescue for helping with boilerplate tasks is generating data and data mappings for validating coding approaches and testing after the coding.</p>

<p>The approach here is the same: to use a well-defined prompt to achieve the desired results. Suppose we want some test data to verify a function that looks up area codes for a given state. We can direct Copilot to “Create a mapping of all 50 states to area codes where the key is the state abbreviation and the value is an array of codes with max 10.”</p>

<p>Notice that we were specific about what the keys and corresponding values should be for the mapping. Copilot responds with the requested data (<a data-type="xref" href="#generated-data">Figure 8-6</a>).</p>

<figure><div id="generated-data" class="figure"><img alt="" src="assets/lghc_0806.png" width="1122" height="719"/>
<h6><span class="label">Figure 8-6. </span>Generated data</h6>
</div></figure>

<p>Sometimes Copilot may include a disclaimer about the accuracy of the generated data. A disclaimer for this data would note that the area codes are placeholders and not guaranteed to be the actual area codes for each state. Repeating a point we made in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>, Copilot is working only from the data it was trained on. It is not going out and checking to ensure that the data it returns is correct or up-to-date. You must always remember to cross-check results if you need accurate, timely data. You cannot assume that the values provided through Copilot are current and correct.</p>

<p>When you ask Copilot to generate data in this way, you may occasionally encounter two other types of issues.</p>

<p>First, depending on the prompt and amount of data you request, Copilot might return only a portion of the data. This will usually be enough to get you started but not a complete set. For example, if the query left out the <em>all 50</em> part and was just “Create a mapping of states to area codes where the key is the state abbreviation and the value is an array of codes with max 10,” Copilot might return only a few records:</p>

<pre data-type="programlisting" translate="no">
state_area_codes = {
    "CA": [213, 310, 415, 510, 530, 559, 619, 626, 650, 661],
    "NY": [212, 315, 347, 516, 518, 585, 607, 631, 646, 716],
    "TX": [210, 214, 254, 281, 325, 346, 361, 409, 430, 432],
    "FL": [305, 321, 352, 386, 407, 561, 727, 754, 772, 786],
    "IL": [217, 224, 309, 312, 331, 618, 630, 708, 773, 815],
    "PA": [215, 267, 412, 484, 570, 610, 717, 724, 814, 878],
    "OH": [216, 234, 330, 380, 419, 440, 513, 567, 614, 740],
    "GA": [229, 404, 470, 478, 678, 706, 762, 770, 912, 943],
    "NC": [252, 336, 704, 743, 828, 910, 919, 980, 984, 336],
    "MI": [231, 248, 269, 313, 517, 586, 616, 734, 810, 906]
}
</pre>

<p>If you encounter a situation like this, you can prompt Copilot to generate the rest of the data via a prompt like “Create a mapping of the remaining states to area codes where the key is the state abbreviation and the value is an array of area codes with max 10.” We added the term <em>remaining </em>to tell Copilot to pick up where it left off.</p>

<p>Second, when having Copilot generate data, you may be notified that the generated data matches data in a public repository. If you have the setting enabled to block generated code that matches public code, Copilot’s complete response to your prompt will be blocked.</p>

<p>In general, data such as this is less likely to be proprietary. If there is not a concern about license violations, you can usually tweak your prompt to have the AI generate the data with a different dimension. It may be as easy as changing the amount of data requested, as in “create a mapping of the states to area codes where the key is the state abbreviation and the value is an array of area codes with max 5.” Note the change in the max value from 10 to 5.</p>

<p>Finally, let’s look at one other way you can interact with Copilot. While not as common as the other interfaces we’ve discussed, the GitHub command line can also leverage Copilot to help you understand and generate answers<a contenteditable="false" data-startref="xi_automaticdatageneration84704" data-type="indexterm" id="id848"/><a contenteditable="false" data-primary="" data-startref="xi_datagenerationautomatic84704" data-type="indexterm" id="id849"/>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="GitHub CLI and Copilot"><div class="sect1" id="id96">
<h1>GitHub CLI and Copilot</h1>

<p>If you use the<a contenteditable="false" data-primary="CLI (command-line interface)" data-type="indexterm" id="CLICLI"/> <a contenteditable="false" data-primary="GitHub Copilot" data-secondary="command-line interface (CLI)" data-type="indexterm" id="GHCCLI"/>GitHub CLI, you can use a couple of subcommands with Copilot. At the time of this writing, there are four.</p>

<p>Before being able to use Copilot with the GitHub CLI, some basic prerequisites have to be met:</p>

<ul>
	<li>The GitHub CLI has to be installed.</li>
	<li>You must have authenticated to GitHub, such as through the <code translate="no">gh auth<a contenteditable="false" data-primary="gh auth command" data-type="indexterm" id="id850"/></code> command.</li>
	<li>The Copilot extension must be installed in the GitHub CLI via the <code translate="no">gh extension install github/gh-copilot</code> command.</li>
</ul>

<p>After going through the prerequisites, the CLI commands listed in <a data-type="xref" href="#copilot-commands-thro">Table 8-1</a> will be available to you. The table also shows the purpose of each command.</p>

<table class="border" id="copilot-commands-thro">
	<caption><span class="label">Table 8-1. </span>Copilot commands through the GitHub CLI</caption>
	<thead>
		<tr>
			<th scope="col">Command</th>
			<th scope="col">Function</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>alias</code></td>
			<td>Generate shell-specific aliases for convenience</td>
		</tr>
		<tr>
			<td><code>config</code></td>
			<td>Configure options</td>
		</tr>
		<tr>
			<td><code>explain</code></td>
			<td>Explain a command</td>
		</tr>
		<tr>
			<td><code>suggest</code></td>
			<td>Suggest a command</td>
		</tr>
	</tbody>
</table>

<p>As an example of using the CLI with Copilot, we can ask it to explain a Unix command via a simple invocation of the GitHub CLI like <code translate="no">gh copilot explain "ps -aux"</code>. The output is shown here:</p>

<pre data-type="programlisting" translate="no">
Welcome to GitHub Copilot in the CLI!
version 1.1.0 (2025-02-10)

I'm powered by AI, so surprises and mistakes are possible. Make sure
 to verify any generated code or suggestions, and share feedback so
 that we can learn and improve. For more information, see 
 https://gh.io/gh-copilot-transparency

Explanation:

  • ps is used to display information about running processes.
    • -aux is a combination of flags:
      • -a displays information about all processes.
      • -u displays detailed information about the processes.
      • -x includes processes that do not have a controlling terminal.
</pre>

<p>In some cases, you may be asked to select additional options as a follow-up. For example, if you ask Copilot via the CLI to suggest a command to install Python, there can be additional queries from the AI to make sure it provides you with the best response. Here’s the output and interactions based on an initial command of <code translate="no">gh copilot suggest "install python"</code>:</p>

<pre data-type="programlisting" translate="no">
Welcome to GitHub Copilot in the CLI!
version 1.1.0 (2025-02-10)

...

? What kind of command can I help you with?  [Use arrows to move,
 type to filter]
&gt; generic shell command
  gh command
  git command

Suggestion:

  sudo apt-get install python3

? Select an option  [Use arrows to move, type to filter]
  Copy command to clipboard
&gt; Explain command
  Execute command
  Revise command
  Rate response
  Exit

Explanation: 
  
  • sudo is used to run a command with elevated rights, allowing 
changes to system files.
  • apt-get is the package management command for Debian-based 
systems.
    • install is the sub-command that specifies you want to install
a package.
      • python3 is the specific package you want to install, which 
provides the Python 3 interpreter. 
</pre>

<p>Notice after the original command, there were several follow-up interactions with Copilot. We were given the option to select the context for the command (generic shell, CLI, or Git). Once we selected the shell command, Copilot provided the suggestion. We were then given the option to copy the command, have Copilot explain it, execute it, etc. <a contenteditable="false" data-startref="GHCCLI" data-type="indexterm" id="id851"/>Selecting<a contenteditable="false" data-primary="" data-startref="CLICLI" data-type="indexterm" id="id852"/> the <code>explain</code> option provides an explanation like the one in the previous example.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="id379">
<h1>Conclusion</h1>

<p>In this chapter, we looked at a set of areas where AI assistance may not be the first option that comes to mind but can prove helpful. Copilot’s capabilities can be put to good use in each of these areas.</p>

<p>When you need to interact with databases, Copilot can provide code-completion suggestions and generate full sets of code for SQL just as for more typical programming languages. Copilot can be especially helpful for creating stored procedures and optimizing programming.</p>

<p>Besides generating traditional code that tells the system how to do something, Copilot can also be used to generate declarative specifications that outline the desired end result. A good example of this is using Copilot to help declare Kubernetes specifications. Given a suitable prompt, Copilot can generate the YAML definition for any of the standard Kubernetes objects. In addition, Copilot can tell the user how to use the specification with Kubernetes and even turn it into code with API calls. This kind of help greatly simplifies working with the complexities of different frameworks and their representations in YAML.</p>

<p>Copilot’s capabilities can also automate another task that frequently frustrates developers: creating regular expressions. Given a suitable prompt, Copilot will generate the necessary combination of characters for whatever type of matching syntax you need and produce examples of how to validate.</p>

<p>In support of basic testing or demoing, Copilot can create a set of data for the code to operate against. This can be mapped data with keys and values as defined through a prompt or defined from context. The data is not guaranteed to be correct or timely and may be more susceptible to matching public examples, so additional diligence is needed when working with the results.</p>

<p>Finally, in this chapter, we looked at the capabilities that have been added to the GitHub CLI to work with Copilot. Through the CLI application <code translate="no">gh</code>, Copilot can help by suggesting commands to do tasks like install applications, as well as by explaining what commands and arguments do. This functionality is limited but will likely expand to other capabilities in the future.</p>

<p>In the next chapter, we’ll look further into how Copilot’s capabilities are integrated into another core application that users rely on—GitHub itself.</p>
</div></section>
</div></section></div></div></body></html>