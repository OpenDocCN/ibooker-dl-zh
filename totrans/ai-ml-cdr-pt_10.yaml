- en: Chapter 9\. Understanding Sequence and Time Series Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章\. 理解序列和时间序列数据
- en: Time series are everywhere. You’ve probably seen them in things like weather
    forecasts, stock prices, and historic trends like Moore’s law. If you’re not familiar
    with *Moore’s law*, it predicts that the number of transistors on a microchip
    will roughly double every two years—and for almost 50 years, it has proven to
    be an accurate predictor of the future of computing power and cost (see [Figure 9-1](#ch09_figure_1_1748549698128120)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列无处不在。你可能已经在天气预报、股价和像摩尔定律这样的历史趋势中看到过它们。如果你不熟悉**摩尔定律**，它预测每两年晶体管数量将大致翻倍——并且近50年来，它一直是计算能力和成本未来趋势的一个准确预测者（参见[图9-1](#ch09_figure_1_1748549698128120)）。
- en: '![Moore’s law](assets/aiml_0901.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![摩尔定律](assets/aiml_0901.png)'
- en: Figure 9-1\. Moore’s law
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-1\. 摩尔定律
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The gaps in [Figure 9-1](#ch09_figure_1_1748549698128120) are missing data for
    that period of time, but the general trend still holds.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](#ch09_figure_1_1748549698128120)中的缺口是该时间段缺失的数据，但总体趋势仍然存在。'
- en: '*Time series data* is a set of values that are spaced over time, usually in
    a particular order or denoting values of a thing at a timestamped point in time.
    When a time series is plotted on a graph, the *x*-axis is usually temporal in
    nature. Often, there are a number of values plotted on the time axis, such as
    in the example shown in [Figure 9-1](#ch09_figure_1_1748549698128120), where the
    number of transistors is one plot and the predicted value from Moore’s law is
    the other. This is called a *multivariate* time series. If there’s just a single
    value—for example, the volume of rainfall over time—then it’s called a *univariate*
    time series.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间序列数据*是一组随时间间隔排列的值，通常按特定顺序或表示事物在时间戳点上的值。当时间序列在图表上绘制时，*x*轴通常是时间性的。通常，时间轴上会绘制许多值，例如在[图9-1](#ch09_figure_1_1748549698128120)所示的示例中，晶体管的数量是一个绘图，而摩尔定律的预测值是另一个。这被称为*多元时间序列*。如果只有一个值——例如，随时间变化的降雨量——那么它被称为*单变量时间序列*。'
- en: With Moore’s law, predictions are simple because there’s a fixed and simple
    rule that allows us to roughly predict the future—a rule that has held for about
    50 years.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**摩尔定律**，预测很简单，因为有一个固定且简单的规则可以让我们大致预测未来——这个规则已经持续了大约50年。
- en: But what about a time series like the one shown in [Figure 9-2](#ch09_figure_2_1748549698128170)?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于[图9-2](#ch09_figure_2_1748549698128170)中所示的时间序列呢？
- en: '![](assets/aiml_0902.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aiml_0902.png)'
- en: Figure 9-2\. A real-world time series
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-2\. 实际世界中的时间序列
- en: While this time series was artificially created (and you’ll see how to do that
    later in this chapter), it has all the attributes of a complex real-world time
    series, like a stock chart or a chart depicting seasonal rainfall. Despite their
    seeming randomness, time series have some common attributes that are helpful in
    designing ML models that can predict them, as described in the next section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个时间序列是人为创建的（你将在本章后面看到如何做到这一点），但它具有复杂真实世界时间序列的所有属性，如股票图表或描绘季节性降雨的图表。尽管它们看似随机，但时间序列有一些共同属性，有助于设计可以预测它们的机器学习模型，如下一节所述。
- en: Common Attributes of Time Series
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列的共同属性
- en: While time series might appear random and noisy, they often have common attributes
    that are predictable. In this section, we’ll explore some of them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管时间序列可能看起来是随机的和嘈杂的，但它们通常具有可预测的共同属性。在本节中，我们将探讨其中的一些。
- en: Trend
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 趋势
- en: 'Time series typically move in a specific direction. In the case of Moore’s
    law, it’s easy to see that over time, the values on the *y*-axis increase and
    there’s an upward trend. There’s also an upward trend in the time series in [Figure 9-2](#ch09_figure_2_1748549698128170).
    Of course, this won’t always be the case: some time series may be roughly level
    over time, despite seasonal changes, and others may have a downward trend. For
    example, this is the case in the inverse version of Moore’s law that predicts
    the price per transistor.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列通常向特定方向移动。在摩尔定律的情况下，很容易看出随着时间的推移，*y*轴上的值增加，存在上升趋势。在[图9-2](#ch09_figure_2_1748549698128170)中的时间序列也存在上升趋势。当然，这并不总是如此：一些时间序列可能随着时间的推移大致保持水平，尽管有季节性变化，而其他时间序列可能存在下降趋势。例如，这是摩尔定律的逆版本，它预测了晶体管的价格。
- en: Seasonality
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 季节性
- en: Many time series have a repeating pattern over time, with the repeats happening
    at regular intervals called *seasons*. Consider, for example, temperature in weather.
    We typically have four seasons per year, with the temperature being highest in
    summer. So, if you plotted weather over several years, you’d see peaks happening
    every four seasons, giving us the concept of seasonality. But this phenomenon
    isn’t limited to weather—consider, for example, [Figure 9-3](#ch09_figure_3_1748549698128196),
    which is a plot of traffic to a website.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时间序列在时间上都有重复的模式，这些重复以固定间隔发生，称为*季节*。例如，考虑一下天气中的温度。我们通常每年有四个季节，夏季温度最高。因此，如果你在几年内绘制天气图，你会看到每四个季节出现一个峰值，这就是季节性的概念。但这种现象并不仅限于天气——考虑一下[图9-3](#ch09_figure_3_1748549698128196)，这是一张网站流量的图表。
- en: '![](assets/aiml_0903.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aiml_0903.png)'
- en: Figure 9-3\. Website traffic
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-3\. 网站流量
- en: It’s plotted week by week, and you can see regular dips. Can you guess what
    they are? The site in this case is one that provides information for software
    developers, and as you would expect, it gets less traffic on weekends! Thus, the
    time series has a seasonality of five high days and two low days. The data is
    plotted over several months, with the Christmas and New Year’s holidays roughly
    in the middle, so you can see an additional seasonality there. If I had plotted
    it over some years, you’d clearly see the additional end-of-year dip.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它按周绘制，你可以看到定期的低谷。你能猜到它们是什么吗？这个网站是一个为软件开发者提供信息的网站，正如你所预期的那样，周末的流量较少！因此，时间序列有五个高峰日和两个低谷日。数据在几个月内绘制，圣诞节和新年假期大致位于中间，因此你可以看到额外的季节性。如果我把它绘制在几年内，你会清楚地看到额外的年末低谷。
- en: There are many ways that seasonality can manifest in a time series. Traffic
    to a retail website, for instance, might peak on the weekends.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性可以在时间序列中表现出多种方式。例如，零售网站的流量可能在周末达到峰值。
- en: Autocorrelation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自相关
- en: Another feature that you may see in time series is predictable behavior after
    an event. You can see this in [Figure 9-4](#ch09_figure_4_1748549698128218), in
    which there are clear spikes, but after each spike, there’s a deterministic decay.
    This is called *autocorrelation*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列中可能看到的另一个特征是事件后的可预测行为。你可以在[图9-4](#ch09_figure_4_1748549698128218)中看到这一点，其中存在明显的峰值，但在每个峰值之后，都有一个确定的衰减。这被称为*自相关*。
- en: In this case, we can see a particular set of behavior that is repeated. Autocorrelations
    may be hidden in a time series pattern, but they have inherent predictability,
    so a time series containing many autocorrelations may be predictable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到一组重复出现的特定行为。自相关可能隐藏在时间序列模式中，但它们具有内在的可预测性，因此包含许多自相关的时间序列可能是可预测的。
- en: '![](assets/aiml_0904.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aiml_0904.png)'
- en: Figure 9-4\. Autocorrelation
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-4\. 自相关
- en: Noise
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 噪声
- en: As its name suggests, *noise* is a set of seemingly random perturbations in
    a time series. These perturbations lead to a high level of unpredictability and
    can mask trends, seasonal behavior, and autocorrelation. For example, [Figure 9-5](#ch09_figure_5_1748549698128240)
    shows the same autocorrelation from [Figure 9-4](#ch09_figure_4_1748549698128218)
    but with a little noise added. Suddenly, it’s much harder to see the autocorrelation
    and predict values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，*噪声*是一组似乎随机的扰动，出现在时间序列中。这些扰动导致高度的不确定性，并可能掩盖趋势、季节性行为和自相关。例如，[图9-5](#ch09_figure_5_1748549698128240)显示了与[图9-4](#ch09_figure_4_1748549698128218)相同的自相关，但添加了一点点噪声。突然之间，很难看到自相关并预测值。
- en: '![](assets/aiml_0905.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aiml_0905.png)'
- en: Figure 9-5\. Autocorrelated series with added noise
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-5\. 添加噪声的自相关序列
- en: Given all of these factors, let’s explore how you can make predictions on time
    series that contain these attributes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些因素，让我们探讨如何对包含这些属性的时间序列进行预测。
- en: Techniques for Predicting Time Series
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测时间序列的技术
- en: Before we get into ML-based prediction—which is the topic of the next few chapters—we’ll
    explore some more naive prediction methods. These will enable you to establish
    a baseline that you can use to measure the accuracy of your ML predictions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨基于机器学习的预测——这是接下来几章的主题之前——我们将探索一些更简单的预测方法。这些方法将使你能够建立一个基准，你可以用它来衡量你的机器学习预测的准确性。
- en: Naive Prediction to Create a Baseline
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基准的简单预测
- en: The most basic method to predict a time series is to say that the predicted
    value at time *t* + 1 is the same as the value from time *t*, effectively shifting
    the time series by a single period.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 预测时间序列的最基本方法是说，在时间 *t* + 1 的预测值与时间 *t* 的值相同，实际上是将时间序列向前移动了一个周期。
- en: 'Let’s begin by creating a time series that has trend, seasonality, and noise:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个具有趋势、季节性和噪声的时间序列：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After plotting this, you’ll see something like [Figure 9-6](#ch09_figure_6_1748549698128263).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制这个图表后，你会看到类似 [图9-6](#ch09_figure_6_1748549698128263) 的内容。
- en: '![A time series showing trend, seasonality, and noise](assets/aiml_0906.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![显示趋势、季节性和噪声的时间序列](assets/aiml_0906.png)'
- en: Figure 9-6\. A time series showing trend, seasonality, and noise
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-6\. 显示趋势、季节性和噪声的时间序列
- en: Now that you have the data, you can split it like any data source into a training
    set, a validation set, and a test set. When there’s some seasonality in the data,
    as you can see in this case, it’s a good idea when splitting the series to ensure
    that there are whole seasons in each split. So, for example, if you wanted to
    split the data in [Figure 9-6](#ch09_figure_6_1748549698128263) into training
    and validation sets, a good place to do this might be at time step 1,000, which
    would give you training data up to step 1,000 and validation data after step 1,000.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了数据，你可以像任何数据源一样将其分割成训练集、验证集和测试集。当数据中存在季节性，就像在这个例子中看到的那样，在分割序列时确保每个分割中都有完整的季节是个好主意。例如，如果你想将
    [图9-6](#ch09_figure_6_1748549698128263) 中的数据分割成训练集和验证集，一个好的分割点可能是时间步长1,000，这将给你到步骤1,000的训练数据和步骤1,000之后的验证数据。
- en: However, you don’t actually need to do the split here because you’re just doing
    a naive forecast where each value *t* is simply the value at step *t* – 1, but
    for the purposes of illustration in the next few figures, we’ll zoom in on the
    data from time step 1,000 onward.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你实际上不需要在这里进行分割，因为你只是在做一个简单预测，其中每个值 *t* 只是步骤 *t* – 1 的值，但为了在接下来的几个图表中的说明目的，我们将聚焦于时间步长1,000及以后的数据。
- en: 'To predict the series from a split time period onward, where the period that
    you want to split from is in the variable `split_time`, you can use code like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要预测从分割时间周期开始的时间序列，其中你想要分割的周期在变量 `split_time` 中，你可以使用如下代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Figure 9-7](#ch09_figure_7_1748549698128284) shows the validation set (from
    time step 1,000 onward, which you get by setting `split_time` to `1000`) with
    the naive prediction overlaid.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-7](#ch09_figure_7_1748549698128284) 展示了验证集（从时间步长1,000开始，通过将 `split_time`
    设置为 `1000` 获取）以及叠加的简单预测。'
- en: '![](assets/aiml_0907.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aiml_0907.png)'
- en: Figure 9-7\. Naive forecast on time series
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-7\. 时间序列上的简单预测
- en: It looks pretty good—there is a relationship between the values—and, when charted
    over time, the predictions appear to closely match the original values. But how
    would you measure the accuracy?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来相当不错——值之间存在关系——当它们随时间绘制时，预测似乎与原始值非常接近。但你是如何衡量准确性的呢？
- en: Measuring Prediction Accuracy
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量预测精度
- en: 'There are a number of ways to measure prediction accuracy, but we’ll concentrate
    on two of them: the *mean squared error* (MSE) and *mean absolute error* (MAE).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测量预测精度的方法有很多，但我们将集中讨论两种：*均方误差*（MSE）和*平均绝对误差*（MAE）。
- en: With MSE, you simply take the difference between the predicted value and the
    actual value at time *t*, square it (to remove negatives), and then find the average
    of all of them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用均方误差（MSE），你只需计算在时间 *t* 的预测值与实际值之间的差异，将其平方（以消除负数），然后计算所有这些差异的平均值。
- en: With MAE, you calculate the difference between the predicted value and the actual
    value at time *t*, take its absolute value to remove negatives (instead of squaring),
    and find the average of all of them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MAE，你计算在时间 *t* 的预测值与实际值之间的差异，取其绝对值以消除负数（而不是平方），然后计算所有这些差异的平均值。
- en: 'For the naive forecast you just created based on our synthetic time series,
    you can get the MSE and MAE like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你根据我们的合成时间序列创建的简单预测，你可以这样获取MSE和MAE：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I got an MSE of 76.47 and an MAE of 6.89\. As with any prediction, if you can
    reduce the error, you can increase the accuracy of your predictions. We’ll look
    at how to do that next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了MSE为76.47和MAE为6.89。与任何预测一样，如果你能减少误差，你就可以提高预测的准确性。我们将在下一部分看看如何做到这一点。
- en: 'Less Naive Predictions: Using a Moving Average for Prediction'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更不简单的预测：使用移动平均进行预测
- en: 'The previous naive prediction took the value at time *t* – 1 to be the forecasted
    value at time *t*. Using a *moving average* is similar, but instead of just taking
    the value from *t* – 1, it takes a group of values (say, 30), averages them out,
    and sets that average value to be the predicted value at time *t*. Here’s the
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的简单预测将时间*t* – 1的值视为时间*t*的预测值。使用*移动平均*类似，但不是只取*t* – 1的值，而是取一组值（例如，30个），计算它们的平均值，并将该平均值设置为时间*t*的预测值。以下是代码：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Figure 9-8](#ch09_figure_8_1748549698128303) shows the plot of the moving
    average against the data.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-8](#ch09_figure_8_1748549698128303)显示了移动平均与数据的对比图。'
- en: '![](assets/aiml_0908.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/aiml_0908.png)'
- en: Figure 9-8\. Plotting the moving average
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-8. 绘制移动平均
- en: When I plotted this time series, I got an MSE and MAE of 49 and 5.5, respectively,
    so it definitely improved the prediction a little. But this approach doesn’t take
    into account the trend or the seasonality, so we may be able to improve it further
    with a little analysis.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我绘制这个时间序列时，我得到了49和5.5的均方误差（MSE）和平均绝对误差（MAE），所以它确实略微提高了预测。但这种方法没有考虑到趋势或季节性，所以我们可能可以通过一点分析进一步改进它。
- en: Improving the Moving-Average Analysis
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进移动平均分析
- en: 'Given that the seasonality in this time series is 365 days, you can smooth
    out the trend and seasonality by using a technique called *differencing*, which
    just subtracts the value at *t* – 365 from the value at *t*. This will flatten
    out the diagram. Here’s the code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个时间序列的季节性为365天，您可以通过使用称为*差分*的技术来平滑趋势和季节性，该技术只是从*t*处的值中减去365天的值。这将使图表变得平坦。以下是代码：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can now calculate a moving average of *these* values and add back in the
    past values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以计算这些值的移动平均，并将过去值加回：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you plot this (see [Figure 9-9](#ch09_figure_9_1748549698128324)), you
    can already see an improvement in the predicted values: the trend line is very
    close to the actual values, albeit with the noise smoothed out. Seasonality seems
    to work, as does the trend.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当您绘制这个（见图[图9-9](#ch09_figure_9_1748549698128324)）时，您已经可以看到预测值的改进：趋势线非常接近实际值，尽管噪声被平滑了。季节性似乎有效，趋势也是如此。
- en: '![](assets/aiml_0909.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/aiml_0909.png)'
- en: Figure 9-9\. Improved moving average
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-9. 改进的移动平均
- en: This impression is confirmed when you calculate the MSE and MAE—in this case,
    I got 40.9 and 5.13, respectively, showing a clear improvement in the predictions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您计算均方误差（MSE）和平均绝对误差（MAE）时，这种印象得到了证实——在这种情况下，我得到了40.9和5.13，分别显示了预测的明显改进。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced time series data and some of the common attributes of
    time series. You created a synthetic time series and saw how you can start making
    naive predictions on it, and from these predictions, you established baseline
    measurements using MSE and MAE. Synthetic data is also a really cool area for
    exploration—and hopefully, some of the techniques you explored in this chapter
    will be useful on your learning journey.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了时间序列数据及其一些常见属性。您创建了一个合成时间序列，并看到了如何开始对其做出天真预测，并从这些预测中，您使用均方误差（MSE）和平均绝对误差（MAE）建立了基线测量。合成数据也是一个真正酷炫的探索领域——希望，本章中您探索的一些技术将对您的学习之旅有所帮助。
- en: This chapter was a nice break from PyTorch and ML, but in the next chapter,
    you’ll go back to using ML to see if you can improve on your predictions!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从PyTorch和机器学习（ML）中得到了一个很好的休息，但在下一章中，您将回到使用机器学习来查看是否可以提高您的预测！
