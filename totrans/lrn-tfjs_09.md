# 第八章：训练模型

> “不要求负担更轻，而要求更宽广的肩膀。”
> 
> —犹太谚语

尽管令人印象深刻的模型和数据的供应将继续增长并溢出，但你可能希望做的不仅仅是消费 TensorFlow.js 模型。你将想出以前从未做过的想法，那天不会有现成的选择。现在是时候训练你自己的模型了。

是的，这是世界上最优秀的头脑竞争的任务。虽然关于训练模型的数学、策略和方法论可以写成一本书，但核心理解将至关重要。你必须熟悉使用 TensorFlow.js 训练模型的基本概念和好处，以充分利用这个框架。

我们将：

+   用 JavaScript 代码训练你的第一个模型

+   提升对模型架构的理解

+   回顾如何在训练过程中跟踪状态

+   涵盖一些训练的基本概念

当你完成这一章时，你将掌握几种训练模型的方法，并更好地理解使用数据制定机器学习解决方案的过程。

# 训练 101

现在是时候揭开魔法，用 JavaScript 训练一个模型了。虽然 Teachable Machine 是一个很好的工具，但它有限。要真正赋予机器学习力量，你需要确定你想要解决的问题，然后教会机器找到解决方案的模式。为了做到这一点，我们将通过数据的眼睛看问题。

在写任何代码之前，看看这个信息的例子，看看你能否确定这些数字之间的相关性。你有一个函数`f`，它接受一个数字并返回一个数字。以下是数据：

+   给定-1，结果为-4。

+   给定 0，结果为-2。

+   给定 1，结果为 0。

+   给定 2，结果为 2。

+   给定 3，结果为 4。

+   给定 4，结果为 6。

你能确定 5 的答案是什么吗？你能推断出 10 的解决方案吗？在继续之前花点时间评估数据。你们中的一些人可能已经找到了解决方案：答案 = 2x - 2。

函数`f`是一条简单的线，如图 8-1 所示。知道这一点后，你可以快速解出输入为 10 时的结果为 18。

![显示线性方程](img/ltjs_0801.png)

###### 图 8-1。X = 10 意味着 Y = 18

从给定数据解决这个问题正是机器学习可以做到的。让我们准备并训练一个 TensorFlow.js 模型来解决这个简单的问题。

要应用监督学习，你需要做以下事情：

1.  收集你的数据（输入和期望解决方案）。

1.  创建和设计模型架构。

1.  确定模型应该如何学习和衡量错误。

1.  训练模型并确定训练时间。

## 数据准备

为了准备一台机器，你将编写代码来提供输入张量，即值`[-1, 0, 1, 2, 3, 4]`及其对应的答案`[-4, -2, 0, 2, 4, 6]`。问题的索引必须与预期答案的索引匹配，这在思考时是有意义的。因为我们给模型所有值的答案，这就是为什么这是一个监督学习问题。

在这种情况下，训练集有六个例子。机器学习很少会用在这么少的数据上，但问题相对较小且简单。正如你所看到的，没有任何训练数据被保留用于测试模型。幸运的是，你可以尝试这个模型，因为你知道最初用来创建数据的公式。如果你对训练和测试数据集的定义不熟悉，请查看第一章中的“常见 AI/ML 术语”。

## 设计模型

设计模型的想法可能听起来很繁琐，但诚实的答案是，这是理论、试验和错误的混合。在设计师了解架构的性能之前，模型可能需要经过数小时甚至数周的训练。整个研究领域可能致力于模型设计。您将为本书创建的 Layers 模型将为您提供良好的基础。

设计模型的最简单方法是使用 TensorFlow.js 的 Layers API，这是一个高级 API，允许您按顺序定义每个层。实际上，要启动您的模型，您将从代码`tf.sequential();`开始。您可能会听到这被称为“Keras API”，因为这种模型定义风格的起源。

您将创建的模型来解决您正在尝试解决的简单问题将只有一个层和一个神经元。当您考虑到一条线的公式时，这是有道理的；这不是一个非常复杂的方程。

###### 注意

当你熟悉密集网络的基本方程时，就会惊讶地发现为什么在这种情况下单个神经元会起作用，因为一条线的公式是 y = mx + b，而人工神经元的公式是 y = Wx + b。

要向模型添加一层，您将使用`model.add`，然后定义您的层。使用 Layers API，每个添加的层都会自行定义并根据`model.add`调用的顺序自动连接，就像推送到数组一样。您将在第一层中定义模型的预期输入，并且您添加的最后一层将定义模型的输出（参见示例 8-1）。

##### 示例 8-1。构建一个假设模型

```py
model.add(ALayer)
model.add(BLayer)
model.add(CLayer)

// Currently, model is [ALayer, BLayer, CLayer]
```

示例 8-1 中的模型将有三层。`ALayer`将负责识别预期的模型输入和自身。`BLayer`不需要识别其输入，因为可以推断输入将是`ALayer`。因此，`BLayer`只需要定义自身。`CLayer`将识别自身，并且因为它是最后一个，这将确定模型的输出。

让我们回到您试图编码的模型。当前问题的架构模型目标只有一个具有一个神经元的层。当您编写该单个层时，您将定义您的输入和输出。

```py
// The entire inner workings of the model
model.add(
  tf.layers.dense({
    inputShape: 1, // one value 1D tensor
    units: 1 // one neuron - output tensor
  })
);
```

结果是一个简单的神经网络。在绘制图时，网络有两个节点（参见图 8-2）。

![2 nodes 1 edge nn](img/ltjs_0802.png)

###### 图 8-2。一个输入和一个输出

通常，层具有更多的人工神经元（图节点），但也更复杂，并具有其他要配置的属性。

## 识别学习指标

接下来，您需要告诉您的模型如何识别进展以及如何变得更好。这些概念并不陌生；它们在软件中只是看起来有点奇怪。

每当我试图将激光指示器对准某物时，我通常会错过。但是，我可以看到我稍微偏左或偏右，然后进行调整。机器学习也是如此。它可能会随机开始，但算法会自我纠正，并且需要知道您希望它如何做到这一点。最符合我的激光指示器示例的方法将是*梯度下降*。优化激光指示器的最平滑迭代方法称为*随机梯度下降*。这就是我们将在这种情况下使用的方法，因为它效果很好，并且对于您下次晚宴听起来相当酷。

至于测量错误，您可能认为简单的“对”和“错”会起作用，但是差几个小数点和错上千有很大的区别。因此，通常依赖损失函数来帮助您确定 AI 预测猜测的错误程度。有很多衡量错误的方法，但在这种情况下，均方误差（MSE）是一个很好的衡量标准。对于那些需要了解数学的人，MSE 是估计值（y）和实际值（带有小帽的 y）之间的平均平方差。如果您熟悉常见的数学符号，可以将其表示如下：

<math><mrow><mo form="prefix">MSE</mo> <mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup> <msup><mrow><mo>(</mo><msub><mi>Y</mi> <mi>i</mi></msub> <mo>-</mo><mover accent="true"><msub><mi>Y</mi> <mi>i</mi></msub> <mo>^</mo></mover><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>

为什么您喜欢这个公式而不是简单的原始答案距离？MSE 中蕴含了一些数学优势，有助于将方差和偏差作为正误差分数进行整合。不深入统计学，它是解决拟合数据线的最常见损失函数之一。

###### 提示

随机梯度下降和均方误差散发着数学起源的气息，对于一个实用的开发人员来说，这些都无法告诉他们的目的。在这种情况下，最好吸收这些术语的含义，如果您感到有冒险精神，可以观看大量视频，详细解释它们。

当您准备告诉模型使用特定的学习指标并且添加完所有层到模型后，这一切都包含在 `.compile` 调用中。TensorFlow.js 足够聪明，了解梯度下降和均方误差。您可以通过它们的批准字符串等效项来识别它们，而不是编写这些函数：

```py
model.compile({
  optimizer: "sgd",
  loss: "meanSquaredError"
});
```

使用框架的一个巨大好处是，随着机器学习世界发明新的优化器如“Adagrad”和“Adamax”，只需在模型架构中简单更改一个字符串¹，就可以尝试并调用它们。将“sgd”切换为[“adamax”](https://arxiv.org/abs/1412.6980)对于开发人员来说几乎不需要时间，可能会显著提高模型训练时间，而无需阅读有关随机优化的已发表论文。

在不了解函数的具体情况下识别函数，提供了一种苦乐参半的好处，类似于更改文件类型而无需了解每种类型的完整结构。对于每种的优缺点有一点了解是很有帮助的，但您不需要记住规范。在架构时花点时间阅读可用内容是值得的。

不用担心。您会看到相同的名称一遍又一遍地使用，所以很容易掌握它们。

此时，模型已创建。如果要求它预测任何内容，它将失败，因为它没有进行任何训练。架构中的权重完全是随机的，但您可以通过调用 `model.summary()` 来查看层。输出直接显示在控制台上，看起来有点像 示例 8-2。

##### 示例 8-2\. 在 Layers 模型上调用 `model.summary()` 打印层

```py
_________________________________________________________________
Layer (type)                 Output shape              Param #
=================================================================
dense_Dense6 (Dense)         [null,1]                  2
=================================================================
Total params: 2
Trainable params: 2
Non-trainable params: 0
_________________________________________________________________
```

层`dense_Dense6`是在 TensorFlow.js 后端中引用此层的自动 ID。您的 ID 可能会有所不同。这个模型有两个可训练参数，因为一条线是 y = mx + b，对吧？从视觉上看，这个模型的参数是可训练的。我们将在后面介绍不可训练的参数。这个单层模型已经准备就绪。

## 训练模型的任务

训练模型的最后一步是将输入组合到架构中，并指定训练的持续时间。如前所述，这通常以 epochs 来衡量，即模型将多少次查看带有正确答案的闪卡，然后完成后停止训练。您应该使用的 epochs 数量取决于问题的规模、模型以及“足够好”的正确性。在某些模型中，再获得半个百分点值得几小时的训练，而在我们的情况下，模型足够准确，可以在几秒内得到正确答案。

训练集是一个具有六个值的 1D 张量。如果 epochs 设置为 1,000，那么模型将有效地训练 6,000 次迭代，这将在任何现代计算机上最多花费几秒钟。将一条线拟合到点的微不足道的问题对于计算机来说非常简单。

## 将所有内容整合在一起

现在您已经熟悉了高级概念，您可能迫不及待地想用代码解决这个问题。以下是用数据训练模型的代码，然后立即要求模型为值`10`提供答案，如前所述。

```py
// Inputs
const xs = tf.tensor([-1, 0, 1, 2, 3, 4]); // ①
// Answers we want from inputs
const ys = tf.tensor([-4, -2, 0, 2, 4, 6]);

// Create a model
const model = tf.sequential(); // ②

model.add( // ③
  tf.layers.dense({
    inputShape: 1,
    units: 1
  })
);

model.compile({ // ④
  optimizer: "sgd",
  loss: "meanSquaredError"
});

// Print out the model structure
model.summary();

// Train
model.fit(xs, ys, { epochs: 300 }).then(history => { // ⑤
  const inputTensor = tf.tensor([10]);
  const answer = model.predict(inputTensor); // ⑥
  console.log(`10 results in ${Math.round(answer.dataSync())}`);
  // cleanup
  tf.dispose([xs, ys, model, answer, inputTensor]); // ⑦
});
```

①

数据准备在具有输入和期望输出的张量中完成。

②

开始一个顺序模型。

③

添加唯一的具有一个输入和一个输出的层，如前所述。

④

使用给定的优化器和损失函数完成顺序模型。

⑤

模型被告知用`fit`进行 300 个 epochs 的训练。这是一个微不足道的时间量，当`fit`完成时，它返回的承诺会被解决。

⑥

要求训练模型为输入张量`10`提供答案。您需要四舍五入答案以获得整数结果。

⑦

在获得答案后立即处理所有内容。

恭喜！您已经用代码从头开始训练了一个模型。您刚刚解决的问题被称为*线性回归*问题。它有各种用途，是预测房价、消费者行为、销售预测等的常用工具。一般来说，在现实世界中，点并不完全落在一条直线上，但现在您有能力将分散的线性数据转化为预测模型。因此，当您的数据看起来像图 8-3 时，您可以像图 8-4 中所示解决问题。

![图上的分散线性数据](img/ltjs_0803.png)

###### 图 8-3\. 分散的线性数据

![预测最佳拟合线的图表](img/ltjs_0804.png)

###### 图 8-4\. 使用 TensorFlow.js 预测最佳拟合线

现在您已经熟悉了训练的基础知识，您可以扩展您的流程，了解解决更复杂模型所需的步骤。训练模型在很大程度上取决于架构以及数据的质量和数量。

# 非线性训练 101

如果每个问题都基于线性，那么就不需要机器学习了。统计学家从 19 世纪初就开始解决线性回归问题。不幸的是，一旦您的数据是非线性的，这种方法就会失败。如果您让 AI 解决 Y = X²会发生什么？

![平方函数](img/ltjs_0805.png)

###### 图 8-5\. 简单的 Y = X²

更复杂的问题需要更复杂的模型架构。在本节中，您将学习基于层的模型的新属性和特性，以及处理数据的非线性分组。

您可以向神经网络添加更多节点，但它们仍然存在于线性函数的分组中。为了打破线性，现在是时候添加*激活函数*了。

激活函数类似于大脑中的神经元。是的，这个比喻又来了。当一个神经元在电化学上接收到信号时，并不总是激活。在神经元发射动作电位之前，需要一个阈值。同样地，神经网络具有一定程度的偏见和类似于开关的动作电位，当它们达到由于传入信号而引起的阈值时发生（类似于去极化电流）。简而言之，激活函数使神经网络能够进行非线性预测。²

###### 注意

如果您知道您的解决方案需要是二次的，那么有更聪明的方法来解决二次函数。在本节中，您将为 X²解决问题，这是专门为了更多地了解 TensorFlow.js 而编排的，而不是为了解决简单的数学函数。

是的，这个练习可以很容易地在不使用 AI 的情况下解决，但那样有什么乐趣呢？

## 收集数据

指数函数可能返回一些非常大的数字，加快模型训练速度的一个技巧是保持数字及其之间的距离较小。您会一次又一次地看到这一点。对于我们的目的，模型的训练数据将是 0 到 10 之间的数字。

```py
const jsxs = [];
const jsys = [];

const dataSize = 10;
const stepSize = 0.001;
for (let i = 0; i < dataSize; i = i + stepSize) {
  jsxs.push(i);
  jsys.push(i * i);
}
// Inputs
const xs = tf.tensor(jsxs);
// Answers we want from inputs
const ys = tf.tensor(jsys);
```

这段代码准备了两个张量。`xs`张量是 10,000 个值的分组，`ys`是这些值的平方。

## 向神经元添加激活

为给定层中的神经元选择激活函数以及您的模型大小本身就是一门科学。这取决于您的目标、您的数据和您的知识。就像编码一样，您可以提出几种几乎同样有效的解决方案。经验和实践将帮助您找到适合的解决方案。

在添加激活时，重要的是要注意 TensorFlow.js 中内置了许多激活函数。其中最流行的激活函数之一被称为 ReLU，代表修正线性单元。正如您可能从名称中推断出的那样，它来自科学术语的核心，而不是机智的 NPM 软件包名称。有各种文献讨论了在某些模型中使用 ReLU 相对于其他激活函数的好处。您必须知道 ReLU 是激活函数的一个流行选择，开始使用它应该没问题。随着您对模型架构的了解越来越多，您应该随意尝试其他激活函数。与许多其他选择相比，ReLU 有助于模型更快地训练。

在上一个模型中，您只有一个节点和一个输出。现在增加网络的大小变得重要。没有一个固定的大小公式可供使用，因此每个问题的第一阶段通常需要一些试验。为了我们的目的，我们将增加一个包含 20 个神经元的密集层。密集层意味着该层中的每个节点都连接到其之前和之后的每个节点。生成的模型看起来像图 8-6。

![当前神经网络形状和层](img/ltjs_0806.png)

###### 图 8-6. 神经网络架构（20 个神经元）

从左到右浏览图 8-6 中显示的架构，一个数字进入网络，20 个神经元的层被称为*隐藏*层，最终值输出在最后一层。隐藏层是输入和输出之间的层。这些隐藏层添加了可训练的神经元，并使模型能够处理更复杂的模式。

要添加这一层并为其提供激活函数，您将在序列中指定一个新的密集层：

```py
model.add(
  tf.layers.dense({
    inputShape: 1, // ①
    units: 20, // ②
    activation: "relu" // ③
  })
);

model.add(
  tf.layers.dense({
    units: 1 // ④
  })
);
```

①

第一层将输入张量定义为一个单一数字。

②

指定层应该有 20 个节点。

③

为您的层指定一个花哨的激活函数。

④

添加最终的单单元层以获取输出值。

如果您编译模型并打印摘要，您将看到类似于示例 8-3 的输出。

##### 示例 8-3。调用`model.summary()`以获取当前结构

```py
_________________________________________________________________
Layer (type)                 Output shape              Param #
=================================================================
dense_Dense1 (Dense)         [null,20]                 40
_________________________________________________________________
dense_Dense2 (Dense)         [null,1]                  21
=================================================================
Total params: 61
Trainable params: 61
Non-trainable params: 0
_________________________________________________________________
```

此模型架构有两个与先前层创建代码匹配的层。`null`部分代表批量大小，由于它可以是任何数字，因此留空。例如，第一层表示为`[null,20]`，因此四个值的批次将为模型提供输入`[4, 20]`。

您会注意到模型共有 61 个可调参数。如果您查看图 8-6 中的图表，您可以绘制线条和节点以获取参数。第一层有 20 个节点和 20 条线连接到它们，这就是为什么它有 40 个参数。第二层有 20 条线都连接到一个单个节点，这就是为什么只有 21 个参数。您的模型已准备好训练，但这次要大得多。

如果您进行这些更改并开始训练，您可能会听到您的 CPU/GPU 风扇启动并看到一堆无用的东西。听起来计算机可能正在训练，但肯定很好看到某种进展。

## 观看训练

TensorFlow.js 拥有各种令人惊奇的工具，可帮助您识别训练进度。特别是，`fit`配置的一个属性称为`callbacks`。在`callbacks`对象内部，您可以连接到训练模型的某些生命周期，并运行任何您想要的代码。

由于您已经熟悉一个 epoch（对训练数据的完整运行），这是您在本例中将使用的时刻。这是一个简洁但有效的获取某种控制台消息的方法。

```py
const printCallback = { // ①
  onEpochEnd: (epoch, log) => { // ②
    console.log(epoch, log); // ③
  }
};
```

①

创建包含您想要连接的所有生命周期方法的回调对象。

②

`onEpochEnd`是训练支持的许多已识别的生命周期回调之一。其他枚举在框架的[`fit`部分](https://oreil.ly/NoVqS)文档中。

③

打印审查的值。通常，您会对这些信息进行更深入的处理。

###### 注意

通过在`fit`配置中设置`stepsPerEpoch`数字，可以重新定义一个 epoch。使用此变量，一个 epoch 可以成为任何数量的训练数据。默认情况下，这设置为`null`，因此一个 epoch 设置为您的训练集中唯一样本的数量除以批量大小。

剩下要做的就是将您的对象传递给模型的`fit`配置，同时传递您的 epochs，您应该在模型训练时看到日志。

```py
await model.fit(xs, ys, {
  epochs: 100,
  callbacks: printCallback
});
```

`onEpochEnd`回调会打印到您的控制台，显示训练正在进行。在图 8-7 中，您可以看到您的 epoch 和日志对象。

![训练进度日志](img/ltjs_0807.png)

###### 图 8-7。epochs 19 到 26 的`onEpochEnd`日志

能够看到模型实际上正在训练，甚至能够知道它所处的 epoch，这真是一种清新的感觉。但是，日志值是怎么回事？

### 模型日志

模型通过损失函数告知如何定义损失。您希望在每个 epoch 中看到的是损失下降。损失不仅仅是“对还是错？”它是关于模型有多错，以便它可以学习。每个 epoch 之后，模型都会报告损失，在一个良好的模型架构中，这个数字会迅速下降。

您可能对查看准确性感兴趣。大多数情况下，准确性是一个很好的指标，我们可以在日志中启用准确性。但是，对于这样的模型，准确性并不是一个很好的指标。例如，如果您问模型预测`[7]`的输出应该是多少，而模型回答`49.0676842`而不是`49`，那么它的准确性为零，因为它是错误的。虽然接近的结果在四舍五入后会有较低的损失并且准确，但从技术上讲，它是错误的，模型的准确性评分会很差。让我们在它更有效时再启用准确性。

## 改进训练

损失值相当高。什么是高损失值？具体而言，这取决于问题。但是，当您看到错误值为 800+时，通常可以说训练尚未完成。

### Adam 优化器

幸运的是，您不必让计算机训练几周。目前，优化器设置为随机梯度下降（`sgd`）的默认值。您可以修改`sgd`预设，甚至选择不同的优化器。最受欢迎的优化器之一称为 Adam。如果您有兴趣尝试 Adam，您不必阅读[2015 年发表的 Adam 论文](https://arxiv.org/pdf/1412.6980.pdf)；您只需将`sgd`的值更改为`adam`，然后您就可以开始了。这是您可以享受框架优势的地方。只需更改一个小字符串，整个模型架构就已更改。Adam 对解决某些类型的问题具有显著的好处。

更新后的编译代码如下：

```py
model.compile({
  optimizer: "adam",
  loss: "meanSquaredError"
});
```

使用新的优化器，损失在几个时期内降至 800 以下，甚至降至 1 以下，如您在图 8-8 中所见。

![训练进度日志](img/ltjs_0808.png)

###### 图 8-8。时期 19 到 26 的`onEpochEnd`日志

经过 100 个时期，模型对我来说仍在取得进展，但在损失值为`0.03833026438951492`时停止。每次运行都会有所不同，但只要损失很小，模型就会正常工作。

###### 提示

修改和调整模型架构以便为特定问题更快地训练或收敛是经验和实验的结合。

情况看起来不错，但还有一个功能我们应该添加，有时可以显著缩短训练时间。在一台相当不错的机器上，这 100 个时期大约需要 100 秒才能运行。您可以通过一行批处理数据来加快训练速度。当您将`batchSize`属性分配给`fit`配置时，训练速度会大大加快。尝试在 fit 调用中添加批处理大小：

```py
await model.fit(xs, ys, {
  epochs: 100,
  callbacks: printCallback,
  batchSize: 64  // ①
});
```

①

对于我的机器，64 的`batchSize`将训练时间从 100 秒减少到 50 秒。

###### 注意

批处理大小是效率和内存之间的权衡。如果批处理太大，这将限制能够运行训练的机器。

您有一个在合理时间内训练的模型，几乎没有额外的成本。但是，增加批处理大小是一个您可以并且应该审查的选项。

### 更多节点和层

整个时间内，模型的形状和大小一直是相同的：一个包含 20 个节点的“隐藏”层。不要忘记，您可以随时添加更多层。作为一个实验，添加另一个包含 20 个节点的层，这样您的模型架构看起来像图 8-9。

![当前神经网络形状和层](img/ltjs_0809.png)

###### 图 8-9。神经网络架构（20×20 隐藏节点）

使用 Layers 模型架构，您可以通过添加一个新层来构建这个模型。请参阅以下代码：

```py
model.add(
  tf.layers.dense({
    inputShape: 1,
    units: 20,
    activation: "relu"
  })
);

model.add(
  tf.layers.dense({
    units: 20,
    activation: "relu"
  })
);

model.add(
  tf.layers.dense({
    units: 1
  })
);
```

结果模型训练速度较慢，这是有道理的，但也收敛速度更快，这也是有道理的。这个更大的模型在 20 秒的训练时间内只需 30 个时期就为输入`[7]`生成了正确的值。

将所有内容放在一起，您的结果代码执行以下操作：

+   创建一个重要的数据集

+   创建几个深度连接的层，使用 ReLU 激活

+   将模型设置为使用先进的 Adam 优化

+   使用 64 块数据训练模型，并在途中打印进度

从头到尾的整个源代码如下：

```py
const jsxs = [];((("improving training", "adding more neurons and layers")))
const jsys = [];

// Create the dataset
const dataSize = 10;
const stepSize = 0.001;
for (let i = 0; i < dataSize; i = i + stepSize) {
  jsxs.push(i);
  jsys.push(i * i);
}
// Inputs
const xs = tf.tensor(jsxs);
// Answers we want from inputs
const ys = tf.tensor(jsys);

// Print the progress on each epoch
const printCallback = {
  onEpochEnd: (epoch, log) => {
    console.log(epoch, log);
  }
};

// Create the model
const model = tf.sequential();
model.add(
  tf.layers.dense({
    inputShape: 1,
    units: 20,
    activation: "relu"
  })
);
model.add(
  tf.layers.dense({
    units: 20,
    activation: "relu"
  })
);
model.add(
  tf.layers.dense({
    units: 1
  })
);

// Compile for training
model.compile({
  optimizer: "adam",
  loss: "meanSquaredError"
});

// Train and print timing
console.time("Training");
await model.fit(xs, ys, {
  epochs: 30,
  callbacks: printCallback,
  batchSize: 64
});
console.timeEnd("Training");

// evaluate the model
const next = tf.tensor([7]);
const answer = model.predict(next);
answer.print();

// Cleanup!
answer.dispose();
xs.dispose();
ys.dispose();
model.dispose();
```

打印的结果张量与`49`非常接近。训练成功。虽然这是一次有点奇怪的冒险，但它突出了模型创建和验证过程的一部分。构建模型是你随着时间实验各种数据及其相关解决方案而获得的技能之一。

在接下来的章节中，你将解决更复杂但有益的问题，比如分类。你在这里学到的一切将成为你工作台上的一种工具。

# 章节回顾

你已经进入了训练模型的世界。层模型结构不仅是一个可理解的视觉，现在它是你可以理解和按需构建的东西。机器学习与普通软件开发非常不同，但你正在逐渐理解 TensorFlow.js 所提供的差异和好处。

## 章节挑战：模型架构师

现在轮到你通过规范构建一个 Layers 模型了。这个模型做什么？没人知道！它不会用任何数据进行训练。在这个挑战中，你将被要求构建一个具有各种你可能不理解的属性的模型，但你应该足够熟悉以至少设置好模型。这个模型将是你迄今为止创建的最大模型。你的模型将有五个输入和四个输出，它们之间有两层。它看起来像图 8-10。

![你的章节挑战](img/ltjs_0810.png)

###### 图 8-10\. 章节挑战模型

在你的模型中做以下操作：

+   输入层应该有 5 个单元。

+   下一层应该有 10 个单元并使用*sigmoid*激活。

+   下一层应该有 7 个单元并使用 ReLU 激活。

+   最后一层应该有 4 个单元并使用*softmax*激活。

+   模型应该使用 Adam 优化。

+   模型应该使用损失函数`categoricalCrossentropy`。

在构建这个模型并查看摘要之前，你能计算出最终模型将有多少可训练参数吗？这是从图 8-10 中的总行数和圆圈数，不包括输入。

你可以在附录 B 中找到这个挑战的答案。

## 回顾问题

让我们回顾一下你在本章编写的代码中学到的经验。花点时间回答以下问题：

1.  为什么章节挑战模型*不*适用于本章的训练数据？

1.  你可以调用哪个方法来记录和审查模型的结构？

1.  为什么要向层添加激活函数？

1.  你如何为 Layers 模型指定输入形状？

1.  `sgd`代表什么？

1.  什么是一个 epoch？

1.  如果一个模型有一个输入，然后是两个节点的一层，和两个节点的输出，那么有多少隐藏层？

这些练习的解决方案可以在附录 A 中找到。

¹ 支持的优化器列在 tfjs-core 的[optimizers 文件夹](https://oreil.ly/vnmcI)中。

² 从 Andrew Ng 了解更多关于[激活函数](https://youtu.be/Xvg00QnyaIY)的知识。
