["```py\ndef plot_series(time, series, format=\"-\", start=0, end=None):\n    plt.plot(time[start:end], series[start:end], format)\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Value\")\n    plt.grid(True)\n\ndef trend(time, slope=0):\n    return slope * time\n\ndef seasonal_pattern(season_time):\n    \"\"\"Just an arbitrary pattern, you can change it if you wish\"\"\"\n    return np.where(season_time < 0.4,\n                    np.cos(season_time * 2 * np.pi),\n                    1 / np.exp(3 * season_time))\n\ndef seasonality(time, period, amplitude=1, phase=0):\n    \"\"\"Repeats the same pattern at each period\"\"\"\n    season_time = ((time + phase) % period) / period\n    return amplitude * seasonal_pattern(season_time)\n\ndef noise(time, noise_level=1, seed=None):\n    rnd = np.random.RandomState(seed)\n    return rnd.randn(len(time)) * noise_level\n\ntime = np.arange(4 * 365 + 1, dtype=\"float32\")\nbaseline = 10\nseries = trend(time, .05)  \nbaseline = 10\namplitude = 15\nslope = 0.09\nnoise_level = 6\n\n# Create the series\nseries = baseline + trend(time, slope) \n                  + seasonality(time, period=365, amplitude=amplitude)\n# Update with noise\nseries += noise(time, noise_level, seed=42)\n```", "```py\nnaive_forecast = series[split_time – 1:–1]\n\n```", "```py\nimport torch\nimport torch.nn.functional as F\n\n# Mean Squared Error\nmse = F.mse_loss(torch.tensor(x_valid), torch.tensor(naive_forecast)).item()\nprint(mse)\n\n# Mean Absolute Error\nmae = F.l1_loss(torch.tensor(x_valid), torch.tensor(naive_forecast)).item()\nprint(mae)\n\n```", "```py\ndef moving_average_forecast(series, window_size):\n  \"\"\"Forecasts the mean of the last few values.\n If window_size=1, then this is equivalent to naive forecast\"\"\"\n  forecast = []\n  for time in range(len(series) – window_size):\n    forecast.append(series[time:time + window_size].mean())\n  return np.array(forecast)\n\nmoving_avg = moving_average_forecast(series, 30)[split_time - 30:]\n\nplt.figure(figsize=(10, 6))\nplot_series(time_valid, x_valid)\nplot_series(time_valid, moving_avg)\n\n```", "```py\ndiff_series = (series[365:] – series[:-365])\ndiff_time = time[365:]\n\n```", "```py\ndiff_moving_avg = \n    moving_average_forecast(diff_series, 50)[split_time – 365 – 50:]\n\ndiff_moving_avg_plus_smooth_past = \n    moving_average_forecast(series[split_time – 370:–360], 10) + \n    diff_moving_avg\n\n```"]