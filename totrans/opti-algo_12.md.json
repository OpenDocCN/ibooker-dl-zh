["```py\nInitialize parameters\nInitialize swarm\nWhile (stopping criteria not met) loop over all individuals\n    Find best so far\n    Find best neighbor\n    Update individual\n```", "```py\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\n\ndef michalewicz_function(position):\n    m = 10\n    position = np.array(position)\n    if len(position.shape) == 1:            ①\n        position = position.reshape(1, -1)  ①\n    n = position.shape[1]\n    j = np.arange(1, n + 1)\n    s = np.sin(position) * np.power(np.sin((j * np.square(position)) /\n➥ np.pi), 2 * m)                           ②\n    return -np.sum(s, axis=1)               ②\n```", "```py\nclass Particle:\n    def __init__(self, position, velocity, pbest_position, pbest_value):\n        self.position = position\n        self.velocity = velocity\n        self.pbest_position = pbest_position\n        self.pbest_value = pbest_value\n```", "```py\ndef fitness_function(position):\n    return michalewicz_function(position)\n```", "```py\ndef update_velocity(particle, gbest_position, options):    \n    w = options['w']\n    c1 = options['c1']\n    c2 = options['c2']\n    inertia = w * particle.velocity\n    cognitive = c1 * np.random.rand() * (particle.pbest_position –\n➥ particle.position)\n    social = c2 * np.random.rand() * (gbest_position - particle.position)\n    new_velocity = inertia + cognitive + social\n    return new_velocity\n```", "```py\ndef pso(swarm_size, iterations, bounds, options):                            ①\n    swarm = []                                                               ①\n    for _ in range(swarm_size):                                              ①\n        position = np.array([np.random.uniform(low=low, high=high) for low,  ①\n➥ high in bounds])                                                          ①\n        velocity = np.array([np.random.uniform(low=-abs(high-low),           ①\n➥  high=abs(high-low)) for low, high in bounds])                            ①\n        pbest_position = position                                            ①\n        pbest_value = fitness_function(position)                             ①\n        particle = Particle(position, velocity, pbest_position, pbest_value) ①\n        swarm.append(particle)                                               ①\n\n    gbest_position = swarm[np.argmin([particle.pbest_value for particle in   ②\n➥ swarm])].pbest_position                                                   ②\n    gbest_value = np.min([particle.pbest_value for particle in swarm])       ②\n\n    for _ in range(iterations):\n        for _, particle in enumerate(swarm):\n            particle.velocity = update_velocity(particle, gbest_position,    ③\noptions)                                                                     ③\n            particle.position += particle.velocity                           ③\n\n            particle.position = np.clip(particle.position, [low for low, high \n  ➥ in bounds], [high for low, high in bounds])                             ④\n\n            current_value = fitness_function(particle.position)              ⑤\n            if current_value < particle.pbest_value:                         ⑤\n                particle.pbest_position = particle.position                  ⑤\n                particle.pbest_value = current_value                         ⑤\n\n            if current_value < gbest_value:                                  ⑥\n                gbest_position = particle.position                           ⑥\n                gbest_value = current_value                                  ⑥\n\n            particle.position += particle.velocity                           ⑦\n\n    return gbest_position, gbest_value                                       ⑧\n```", "```py\nswarm_size = 50                                                            ①\niterations = 1000                                                          ①\noptions = {'w': 0.9, 'c1': 0.5, 'c2': 0.3}                                 ①\n\ndimension = 2                                                              ②\nbounds = [(0, math.pi)] * dimension                                        ②\n\nbest_position, best_value = pso(swarm_size, iterations, bounds, options)   ③\n```", "```py\nprint(f\"Optimal solution: {np.round(best_position,3)}\")\nprint(f\"Minimum value: {np.round(best_value,4)}\")\nprint()\n```", "```py\nOptimal solution: [2.183 1.57]\nMinimum value: [-1.8013]\n```", "```py\nfrom pymoo.algorithms.soo.nonconvex.pso import PSO\nfrom pymoo.core.problem import Problem\nfrom pymoo.optimize import minimize\n\nclass MichalewiczFunction(Problem):                       ①\n    def __init__(self):\n        super().__init__(n_var=2,                         ②\n                         n_obj=1,\n                         n_constr=0,\n                         xl=0,                            ③\n                         xu=math.pi,                      ③\n                         vtype=float)\n\n    def _evaluate(self, x, out, *args, **kwargs):\n        out[\"F\"]= michalewicz_function(x)                 ④\n\nproblem = MichalewiczFunction()                           ⑤\n\nalgorithm = PSO(w=0.9, c1=2.0, c2=2.0)                    ⑥\n\nres = minimize(problem,\n               algorithm,\n               seed=1,\n               verbose=False)                             ⑦\n\nprint(f\"Optimal solution: {np.round(res.X,3)}\")           ⑧\nprint(f\"Minimum value: {np.round(res.F,4)}\")              ⑧\n```", "```py\nOptimal solution: [2.203 1.571]\nMinimum value: [-1.8013]\n```", "```py\n!pip install pyswarms\nimport pyswarms as ps                                                      ①\n\ndimension = 2                                                              ②\nbounds = (np.zeros(dimension), np.pi * np.ones(dimension))                 ③\n\noptions = {'w': 0.9, 'c1': 0.5, 'c2': 0.3}                                 ④\n\noptimizer = ps.single.GlobalBestPSO(n_particles=100, dimensions=dimension,\n➥ options=options, bounds=bounds)                                         ⑤\n\ncost, pos = optimizer.optimize(michalewicz_function, iters=1000)           ⑥\n\nprint(f\"Optimal solution: {np.round(pos,3)}\")                              ⑦\nprint(f\"Minimum value: {np.round(cost,4)}\")                                ⑦\n```", "```py\nOptimal solution: [2.203 1.571]\nMinimum value: -1.8013\n```", "```py\nimport numpy as np\nimport pandas as pd\nfrom collections import defaultdict\nfrom haversine import haversine\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport pyswarms as ps\n\ncities = {\n    'New York City': (40.72, -74.00),\n    'Philadelphia': (39.95, -75.17),       \n    'Baltimore': (39.28, -76.62),\n    'Charlotte': (35.23, -80.85),\n    'Memphis': (35.12, -89.97),\n    'Jacksonville': (30.32, -81.70),\n    'Houston': (29.77, -95.38),\n    'Austin': (30.27, -97.77),\n    'San Antonio': (29.53, -98.47),\n    'Fort Worth': (32.75, -97.33),\n    'Dallas': (32.78, -96.80),\n    'San Diego': (32.78, -117.15),\n    'Los Angeles': (34.05, -118.25),\n    'San Jose': (37.30, -121.87),\n    'San Francisco': (37.78, -122.42),    \n    'Indianapolis': (39.78, -86.15),\n    'Phoenix': (33.45, -112.07),       \n    'Columbus': (39.98, -82.98), \n    'Chicago': (41.88, -87.63),\n    'Detroit': (42.33, -83.05)\n}                                                    ①\n\ndistance_matrix = defaultdict(dict)                  ②\nfor ka, va in cities.items():                        ②\n    for kb, vb in cities.items():                    ②\n        distance_matrix[ka][kb] = 0.0 if kb == ka    ②\n➥ else haversine((va[0],va[1]), (vb[0], vb[1]))     ②\n\ndistances = pd.DataFrame(distance_matrix)            ③\ndistance=distances.values                            ③\ncity_names=list(distances.columns)                   ③\n```", "```py\nn_cities = len(city_names)                                            ①\nbounds = (np.zeros(n_cities), np.ones(n_cities)*(n_cities-1))         ①\n\ndef tsp_distance(position, distance):                                 ②\n    tour = np.argsort(position)                                       ③\n    total_distance = distance[0, tour[0]]                             ④\n    for i in range(n_cities-1):                                       ④\n        total_distance += distance[tour[i], tour[i+1]]                ④\n    total_distance += distance[tour[-1], 0]                           ④\n    return total_distance\n\ndef tsp_cost(x, distance):                                            ⑤\n    n_particles = x.shape[0]                                          ⑤\n    cost=0                                                            ⑤\n    cost = [tsp_distance(x[i], distance) for i in range(n_particles)] ⑤\n    return cost                                                       ⑤\n```", "```py\noptions = {'w': 0.79, 'c1': 2.05, 'c2': 2.05, 'k': 10, 'p': 2}            ①\noptimizer = ps.discrete.BinaryPSO(n_particles=100, dimensions=n_cities,\n➥ options=options)                                                       ②\n\ncost, solution = optimizer.optimize(tsp_cost, iters=150, verbose=True,\n➥ distance=distance)                                                     ③\n\ntour = np.argsort(solution)                                               ④\ncity_names_tour = [city_names[i] for i in tour]                           ④\n\nRoute = \" → \".join(city_names_tour)                                       ⑤\nprint(\"Route:\", Route)                                                    ⑤\nprint(\"Route length:\", np.round(cost, 3))                                 ⑤\n```", "```py\nRoute: New York City → Columbus → Indianapolis → Memphis → San Francisco → San Jose → Los Angeles → San Diego → Phoenix → Dallas → Fort Worth → San Antonio → Austin → Houston → Jacksonville → Charlotte → Baltimore → Philadelphia → Chicago → Detroit\nRoute length: 12781.892\n```", "```py\nimport seaborn as sns                             ①\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import LabelEncoder    ②\nfrom sklearn.decomposition import PCA             ②\nimport pyswarms as ps                             ③\n\npenguins = sns.load_dataset('penguins')           ④\npenguins.head()                                   ⑤\n```", "```py\nplt.figure(figsize=(8, 6))\nsns.scatterplot(data=penguins, x='bill_length_mm', y='body_mass_g', \n➥ hue='species', style=\"species\")\nplt.title('Bill Length vs. Body Mass by Species')\nplt.show()\n```", "```py\ndef logits_function(p):\n\n    W1 = p[0: n_inputs * n_hidden].reshape((n_inputs, n_hidden)) \n    b1 = p[n_inputs * n_hidden: (n_inputs + 1) * n_hidden].reshape((n_hidden,))  ①\n    W2 = p[(n_inputs +1) * n_hidden: -n_classes].reshape((n_hidden, n_classes))  ②\n    b2 = p[-n_classes:].reshape((n_classes,))                                    ③\n\n    z1 = X.dot(W1) + b1                                                          ④\n    a1 = np.tanh(z1)                                                             ④\n    logits = a1.dot(W2) + b2                                                     ⑤\n    return logits                                                                ⑤\n```", "```py\ndef forward_prop(params):\n\n    logits = logits_function(params)                                  ①\n\n    exp_scores = np.exp(logits)                                       ②\n    probs = exp_scores / np.sum(exp_scores, axis=1, keepdims=True)    ②\n\n    correct_logprobs = -np.log(probs[range(num_samples), y])          ③\n    loss = np.sum(correct_logprobs) / num_samples                     ④\n\n    return loss                                                       ④\n```", "```py\ndimension = (n_inputs * n_hidden) + (n_hidden * n_classes) + n_hidden + n_classes = 4 * 10 + 10 * 3 + 10 * 3 + 1 * 10 + 1 * 3 = 83.\n```", "```py\n[ 3.65105185e-01 -9.57472869e-02  4.99475198e-01  2.33703047e-01\n  5.56295931e-01  6.95323783e-01  8.76045204e-02  5.52892675e-01\n  3.33363337e-01  5.60680304e-01  3.24233602e-01  3.40402243e-01\n  2.28940991e-01  6.47396295e-01  2.49476898e-01 -2.15041386e-01\n  6.61749764e-01  4.50805880e-01  7.31521923e-01  4.55724886e-01\n  5.81614992e-01  4.21303249e-01  3.10417945e-01  2.80091464e-01\n  3.63352355e-01  7.21593713e-01  4.11009136e-01  3.50489680e-01\n  6.82325768e-01  3.60945155e-01  3.34258781e-01  5.53845122e-01\n  5.39748679e-01  8.45310205e-01  7.38728229e-01  5.44408893e-01\n  4.22464042e-01  4.45099192e-01  4.36914661e-01 -2.40298612e-02\n  4.68795601e-01  4.58388074e-01  2.29566792e-01  5.18783606e-01\n  1.21226363e-01  2.80730816e-01  4.13249634e-01  1.91229505e-01\n  6.30829496e-01 -4.52777424e-01  1.62066215e-01  3.07603861e-01\n  1.54565454e-01  5.39974173e-01  4.48241886e-01 -2.81999490e-04\n  2.93907050e-01  2.58571312e-01  7.87784363e-01  5.06092352e-01\n  1.85010537e-01  8.06641243e-01  8.30985197e-01  4.06314407e-01\n  2.20795704e-01  3.25405213e-01  6.02993839e-01  4.21051295e-01\n  5.24352428e-01  2.49710316e-01  4.99212007e-01  4.48000964e-01\n  4.90888329e-01  3.94908331e-01  6.35997377e-01  5.91192453e-01\n  6.16639300e-01  6.85748919e-01  5.40805197e-01 -1.51195135e+00\n  3.21751027e-01  3.93555680e-01  5.23679003e-01]\n```", "```py\ndef particle_loss(x):\n    n_particles = x.shape[0]                               ①\n    j = [forward_prop(x[i]) for i in range(n_particles)]   ②\n    return np.array(j)                                     ②\n```", "```py\ndef predict(pos):\n    logits = logits_function(pos)         ①\n    y_pred = np.argmax(logits, axis=1)    ②\n    return y_pred                         ②\n```", "```py\nX = penguins[['bill_length_mm', 'bill_depth_mm', 'flipper_length_mm',\n➥ 'body_mass_g']].to_numpy()                                            ①\nnum_samples = X.shape[0]                                                 ②\nn_inputs = X.shape[1]                                                    ②\nn_hidden = 10                                                            ②\nn_classes = len(np.unique(y))                                            ②\n\ndimensions = (n_inputs * n_hidden) + (n_hidden * n_classes) + n_hidden + n_\nclasses                                                                  ③\n\nPSO_varaints = ['globalBest', 'localBest', 'binaryPSO']                  ④\n\noptions = {'w':0.79, 'c1': 0.9, 'c2': 0.5, 'k': 8, 'p': 2}               ⑤\n\nfor algorithm in PSO_varaints:                                           ⑥\n    if algorithm == 'globalBest':\n\n        optimizer = ps.single.GlobalBestPSO(n_particles=150, \n➥ dimensions=dimensions, options=options)\n        cost, pos = optimizer.optimize(particle_loss, iters=2000)\n        print(\"#\"*30)\n        print(f\"PSO varaints: {algorithm}\")\n        print(f\"Best average accuracy: {100*round((predict(pos) == y).mean(),3)} %\")\n        print()\n    elif algorithm == 'localBest':\n        optimizer = ps.single.LocalBestPSO(n_particles=150, \n➥ dimensions=dimensions, options=options)\n        cost, pos = optimizer.optimize(particle_loss, iters=2000)\n        print(\"#\"*30)\n        print(f\"PSO varaints: {algorithm}\")\n        print(f\"Best average accuracy: {100*round((predict(pos) == y).mean(),3)} %\")\n        print()\n    elif algorithm == 'binaryPSO':\n        optimizer = ps.discrete.BinaryPSO(n_particles=150, \n➥ dimensions=dimensions, options=options)\n        cost, pos = optimizer.optimize(particle_loss, iters=2000)\n        print(\"#\"*30)\n        print(f\"PSO varaints: {algorithm}\")\n        print(f\"Best average accuracy: {100*round((predict(pos) == y).mean(),3)} %\")\n        print()\n```", "```py\n##############################\nPSO variant: globalBest\nBest average accuracy: 99.1 %\n##############################\nPSO variant: localBest\nBest average accuracy: 69.1 %\n##############################\nPSO variant: binaryPSO\nBest average accuracy: 43.8 %\n```"]