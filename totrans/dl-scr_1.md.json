["```py\nprint(\"Python list operations:\")\na = [1,2,3]\nb = [4,5,6]\nprint(\"a+b:\", a+b)\ntry:\n    print(a*b)\nexcept TypeError:\n    print(\"a*b has no meaning for Python lists\")\nprint()\nprint(\"numpy array operations:\")\na = np.array([1,2,3])\nb = np.array([4,5,6])\nprint(\"a+b:\", a+b)\nprint(\"a*b:\", a*b)\n```", "```py\nPython list operations:\na+b: [1, 2, 3, 4, 5, 6]\na*b has no meaning for Python lists\n\nnumpy array operations:\na+b: [5 7 9]\na*b: [ 4 10 18]\n```", "```py\nprint('a:')\nprint(a)\nprint('a.sum(axis=0):', a.sum(axis=0))\nprint('a.sum(axis=1):', a.sum(axis=1))\n```", "```py\na:\n[[1 2]\n [3 4]]\na.sum(axis=0): [4 6]\na.sum(axis=1): [3 7]\n```", "```py\na = np.array([[1,2,3],\n              [4,5,6]])\n\nb = np.array([10,20,30])\n\nprint(\"a+b:\\n\", a+b)\n```", "```py\na+b:\n[[11 22 33]\n [14 25 36]]\n```", "```py\ndef __init__(self,\n             layers: List[Layer],\n             loss: Loss,\n             learning_rate: float = 0.01) -> None:\n```", "```py\ndef operation(x1, x2):\n```", "```py\ndef operation(x1: ndarray, x2: ndarray) -> ndarray:\n```", "```py\ndef square(x: ndarray) -> ndarray:\n    '''\n Square each element in the input ndarray.\n '''\n    return np.power(x, 2)\n\ndef leaky_relu(x: ndarray) -> ndarray:\n    '''\n Apply \"Leaky ReLU\" function to each element in ndarray.\n '''\n    return np.maximum(0.2 * x, x)\n```", "```py\nfrom typing import Callable\n\ndef deriv(func: Callable[[ndarray], ndarray],\n          input_: ndarray,\n          delta: float = 0.001) -> ndarray:\n    '''\n Evaluates the derivative of a function \"func\" at every element in the\n \"input_\" array.\n '''\n    return (func(input_ + delta) - func(input_ - delta)) / (2 * delta)\n```", "```py\ndef f(input_: ndarray) -> ndarray:\n    # Some transformation(s)\n    return output\n\nP = f(E)\n```", "```py\nfrom typing import List\n\n# A Function takes in an ndarray as an argument and produces an ndarray\nArray_Function = Callable[[ndarray], ndarray]\n\n# A Chain is a list of functions\nChain = List[Array_Function]\n```", "```py\ndef chain_length_2(chain: Chain,\n                   a: ndarray) -> ndarray:\n    '''\n Evaluates two functions in a row, in a \"Chain\".\n '''\n    assert len(chain) == 2, \\\n    \"Length of input 'chain' should be 2\"\n\n    f1 = chain[0]\n    f2 = chain[1]\n\n    return f2(f1(x))\n```", "```py\ndef sigmoid(x: ndarray) -> ndarray:\n    '''\n Apply the sigmoid function to each element in the input ndarray.\n '''\n    return 1 / (1 + np.exp(-x))\n```", "```py\ndef chain_deriv_2(chain: Chain,\n                  input_range: ndarray) -> ndarray:\n    '''\n Uses the chain rule to compute the derivative of two nested functions:\n (f2(f1(x))' = f2'(f1(x)) * f1'(x)\n '''\n\n    assert len(chain) == 2, \\\n    \"This function requires 'Chain' objects of length 2\"\n\n    assert input_range.ndim == 1, \\\n    \"Function requires a 1 dimensional ndarray as input_range\"\n\n    f1 = chain[0]\n    f2 = chain[1]\n\n    # df1/dx\n    f1_of_x = f1(input_range)\n\n    # df1/du\n    df1dx = deriv(f1, input_range)\n\n    # df2/du(f1(x))\n    df2du = deriv(f2, f1(input_range))\n\n    # Multiplying these quantities together at each point\n    return df1dx * df2du\n```", "```py\nPLOT_RANGE = np.arange(-3, 3, 0.01)\n\nchain_1 = [square, sigmoid]\nchain_2 = [sigmoid, square]\n\nplot_chain(chain_1, PLOT_RANGE)\nplot_chain_deriv(chain_1, PLOT_RANGE)\n\nplot_chain(chain_2, PLOT_RANGE)\nplot_chain_deriv(chain_2, PLOT_RANGE)\n```", "```py\ndef chain_deriv_3(chain: Chain,\n                  input_range: ndarray) -> ndarray:\n    '''\n Uses the chain rule to compute the derivative of three nested functions:\n (f3(f2(f1)))' = f3'(f2(f1(x))) * f2'(f1(x)) * f1'(x)\n '''\n\n    assert len(chain) == 3, \\\n    \"This function requires 'Chain' objects to have length 3\"\n\n    f1 = chain[0]\n    f2 = chain[1]\n    f3 = chain[2]\n\n    # f1(x)\n    f1_of_x = f1(input_range)\n\n    # f2(f1(x))\n    f2_of_x = f2(f1_of_x)\n\n    # df3du\n    df3du = deriv(f3, f2_of_x)\n\n    # df2du\n    df2du = deriv(f2, f1_of_x)\n\n    # df1dx\n    df1dx = deriv(f1, input_range)\n\n    # Multiplying these quantities together at each point\n    return df1dx * df2du * df3du\n```", "```py\nPLOT_RANGE = np.range(-3, 3, 0.01)\nplot_chain([leaky_relu, sigmoid, square], PLOT_RANGE)\nplot_chain_deriv([leaky_relu, sigmoid, square], PLOT_RANGE)\n```", "```py\ndef multiple_inputs_add(x: ndarray,\n                        y: ndarray,\n                        sigma: Array_Function) -> float:\n    '''\n Function with multiple inputs and addition, forward pass.\n '''\n    assert x.shape == y.shape\n\n    a = x + y\n    return sigma(a)\n```", "```py\ndef multiple_inputs_add_backward(x: ndarray,\n                                 y: ndarray,\n                                 sigma: Array_Function) -> float:\n    '''\n Computes the derivative of this simple function with respect to\n both inputs.\n '''\n    # Compute \"forward pass\"\n    a = x + y\n\n    # Compute derivatives\n    dsda = deriv(sigma, a)\n\n    dadx, dady = 1, 1\n\n    return dsda * dadx, dsda * dady\n```", "```py\ndef matmul_forward(X: ndarray,\n                   W: ndarray) -> ndarray:\n    '''\n Computes the forward pass of a matrix multiplication.\n '''\n\n    assert X.shape[1] == W.shape[0], \\\n    '''\n For matrix multiplication, the number of columns in the first array should\n match the number of rows in the second; instead the number of columns in the\n first array is {0} and the number of rows in the second array is {1}.\n '''.format(X.shape[1], W.shape[0])\n\n    # matrix multiplication\n    N = np.dot(X, W)\n\n    return N\n```", "```py\ndef matmul_backward_first(X: ndarray,\n                          W: ndarray) -> ndarray:\n    '''\n Computes the backward pass of a matrix multiplication with respect to the\n first argument.\n '''\n\n    # backward pass\n    dNdX = np.transpose(W, (1, 0))\n\n    return dNdX\n```", "```py\ndef matrix_forward_extra(X: ndarray,\n                         W: ndarray,\n                         sigma: Array_Function) -> ndarray:\n    '''\n Computes the forward pass of a function involving matrix multiplication,\n one extra function.\n '''\n    assert X.shape[1] == W.shape[0]\n\n    # matrix multiplication\n    N = np.dot(X, W)\n\n    # feeding the output of the matrix multiplication through sigma\n    S = sigma(N)\n\n    return S\n```", "```py\ndef matrix_function_backward_1(X: ndarray,\n                               W: ndarray,\n                               sigma: Array_Function) -> ndarray:\n    '''\n Computes the derivative of our matrix function with respect to\n the first element.\n '''\n    assert X.shape[1] == W.shape[0]\n\n    # matrix multiplication\n    N = np.dot(X, W)\n\n    # feeding the output of the matrix multiplication through sigma\n    S = sigma(N)\n\n    # backward calculation\n    dSdN = deriv(sigma, N)\n\n    # dNdX\n    dNdX = np.transpose(W, (1, 0))\n\n    # multiply them together; since dNdX is 1x1 here, order doesn't matter\n    return np.dot(dSdN, dNdX)\n```", "```py\nprint(X)\n```", "```py\n[[ 0.4723  0.6151 -1.7262]]\n```", "```py\nprint(matrix_function_backward_1(X, W, sigmoid))\n```", "```py\n[[ 0.0852 -0.0557 -0.1121]]\n```", "```py\ndef matrix_function_forward_sum(X: ndarray,\n                                W: ndarray,\n                                sigma: Array_Function) -> float:\n    '''\n Computing the result of the forward pass of this function with\n input ndarrays X and W and function sigma.\n '''\n    assert X.shape[1] == W.shape[0]\n\n    # matrix multiplication\n    N = np.dot(X, W)\n\n    # feeding the output of the matrix multiplication through sigma\n    S = sigma(N)\n\n    # sum all the elements\n    L = np.sum(S)\n\n    return L\n```", "```py\ndef matrix_function_backward_sum_1(X: ndarray,\n                                   W: ndarray,\n                                   sigma: Array_Function) -> ndarray:\n    '''\n Compute derivative of matrix function with a sum with respect to the\n first matrix input.\n '''\n    assert X.shape[1] == W.shape[0]\n\n    # matrix multiplication\n    N = np.dot(X, W)\n\n    # feeding the output of the matrix multiplication through sigma\n    S = sigma(N)\n\n    # sum all the elements\n    L = np.sum(S)\n\n    # note: I'll refer to the derivatives by their quantities here,\n    # unlike the math, where we referred to their function names\n\n    # dLdS - just 1s\n    dLdS = np.ones_like(S)\n\n    # dSdN\n    dSdN = deriv(sigma, N)\n\n    # dLdN\n    dLdN = dLdS * dSdN\n\n    # dNdX\n    dNdX = np.transpose(W, (1, 0))\n\n    # dLdX\n    dLdX = np.dot(dSdN, dNdX)\n\n    return dLdX\n```", "```py\nnp.random.seed(190204)\nX = np.random.randn(3, 3)\nW = np.random.randn(3, 2)\n\nprint(\"X:\")\nprint(X)\n\nprint(\"L:\")\nprint(round(matrix_function_forward_sum(X, W, sigmoid), 4))\nprint()\nprint(\"dLdX:\")\nprint(matrix_function_backward_sum_1(X, W , sigmoid))\n```", "```py\nX:\n[[-1.5775 -0.6664  0.6391]\n [-0.5615  0.7373 -1.4231]\n [-1.4435 -0.3913  0.1539]]\nL:\n2.3755\n\ndLdX:\n[[ 0.2489 -0.3748  0.0112]\n [ 0.126  -0.2781 -0.1395]\n [ 0.2299 -0.3662 -0.0225]]\n```", "```py\nX1 = X.copy()\nX1[0, 0] += 0.001\n\nprint(round(\n        (matrix_function_forward_sum(X1, W, sigmoid) - \\\n         matrix_function_forward_sum(X, W, sigmoid)) / 0.001, 4))\n```", "```py\n0.2489\n```", "```py\nprint(\"X:\")\nprint(X)\n```", "```py\nX:\n[[-1.5775 -0.6664  0.6391]\n [-0.5615  0.7373 -1.4231]\n [-1.4435 -0.3913  0.1539]]\n```", "```py\ndLdW = np.dot(dNdW, dSdN)\n```"]