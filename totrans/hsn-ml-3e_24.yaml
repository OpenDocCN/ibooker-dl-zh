- en: Appendix C. Special Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix we will take a very quick look at the data structures supported
    by TensorFlow, beyond regular float or integer tensors. This includes strings,
    ragged tensors, sparse tensors, tensor arrays, sets, and queues.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tensors can hold byte strings, which is useful in particular for natural language
    processing (see [Chapter 16](ch16.html#nlp_chapter)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to build a tensor with a Unicode string, TensorFlow automatically
    encodes it to UTF-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to create tensors representing Unicode strings. Just create
    an array of 32-bit integers, each representing a single Unicode code point:⁠^([1](app03.html#idm45720157174848))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In tensors of type `tf.string`, the string length is not part of the tensor’s
    shape. In other words, strings are considered as atomic values. However, in a
    Unicode string tensor (i.e., an int32 tensor), the length of the string *is* part
    of the tensor’s shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tf.strings` package contains several functions to manipulate string tensors,
    such as `length()` to count the number of bytes in a byte string (or the number
    of code points if you set `unit="UTF8_CHAR"`), `unicode_encode()` to convert a
    Unicode string tensor (i.e., int32 tensor) to a byte string tensor, and `unicode_decode()`
    to do the reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also manipulate tensors containing multiple strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the decoded strings are stored in a `RaggedTensor`. What is that?
  prefs: []
  type: TYPE_NORMAL
- en: Ragged Tensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *ragged tensor* is a special kind of tensor that represents a list of arrays
    of different sizes. More generally, it is a tensor with one or more *ragged dimensions*,
    meaning dimensions whose slices may have different lengths. In the ragged tensor
    `r`, the second dimension is a ragged dimension. In all ragged tensors, the first
    dimension is always a regular dimension (also called a *uniform dimension*).
  prefs: []
  type: TYPE_NORMAL
- en: 'All the elements of the ragged tensor `r` are regular tensors. For example,
    let’s look at the second element of the ragged tensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tf.ragged` package contains several functions to create and manipulate
    ragged tensors. Let’s create a second ragged tensor using `tf.ragged.constant()`
    and concatenate it with the first ragged tensor, along axis 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is not too surprising: the tensors in `r2` were appended after the
    tensors in `r` along axis 0\. But what if we concatenate `r` and another ragged
    tensor along axis 1?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time, notice that the *i*^(th) tensor in `r` and the *i*^(th) tensor in
    `r3` were concatenated. Now that’s more unusual, since all of these tensors can
    have different lengths.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you call the `to_tensor()` method, the ragged tensor gets converted to a
    regular tensor, padding shorter tensors with zeros to get tensors of equal lengths
    (you can change the default value by setting the `default_value` argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Many TF operations support ragged tensors. For the full list, see the documentation
    of the `tf.RaggedTensor` class.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse Tensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TensorFlow can also efficiently represent *sparse tensors* (i.e., tensors containing
    mostly zeros). Just create a `tf.SparseTensor`, specifying the indices and values
    of the nonzero elements and the tensor’s shape. The indices must be listed in
    “reading order” (from left to right, and top to bottom). If you are unsure, just
    use `tf.sparse.reorder()`. You can convert a sparse tensor to a dense tensor (i.e.,
    a regular tensor) using `tf.sparse.to_dense()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that sparse tensors do not support as many operations as dense tensors.
    For example, you can multiply a sparse tensor by any scalar value, and you get
    a new sparse tensor, but you cannot add a scalar value to a sparse tensor, as
    this would not return a sparse tensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tensor Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `tf.TensorArray` represents a list of tensors. This can be handy in dynamic
    models containing loops, to accumulate results and later compute some statistics.
    You can read or write tensors at any location in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By default, reading an item also replaces it with a tensor of the same shape
    but full of zeros. You can set `clear_after_read` to `False` if you don’t want
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you write to the array, you must assign the output back to the array, as
    shown in this code example. If you don’t, although your code will work fine in
    eager mode, it will break in graph mode (these modes are discussed in [Chapter 12](ch12.html#tensorflow_chapter)).
  prefs: []
  type: TYPE_NORMAL
- en: By default, a `TensorArray` has a fixed size that is set upon creation. Alternatively,
    you can set `size=0` and `dynamic_size=True` to let the array grow automatically
    when needed. However, this will hinder performance, so if you know the `size`
    in advance, it’s better to use a fixed-size array. You must also specify the `dtype`,
    and all elements must have the same shape as the first one written to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can stack all the items into a regular tensor by calling the `stack()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TensorFlow supports sets of integers or strings (but not floats). It represents
    sets using regular tensors. For example, the set `{1, 5, 9}` is just represented
    as the tensor `[[1, 5, 9]]`. Note that the tensor must have at least two dimensions,
    and the sets must be in the last dimension. For example, `[[1, 5, 9], [2, 5, 11]]`
    is a tensor holding two independent sets: `{1, 5, 9}` and `{2, 5, 11}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tf.sets` package contains several functions to manipulate sets. For example,
    let’s create two sets and compute their union (the result is a sparse tensor,
    so we call `to_dense()` to display it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also compute the union of multiple pairs of sets simultaneously. If
    some sets are shorter than others, you must pad them with a padding value, such
    as 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer to use a different padding value, such as –1, then you must set
    `default_value=-1` (or your preferred value) when calling `to_dense()`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default `default_value` is 0, so when dealing with string sets, you must
    set this parameter (e.g., to an empty string).
  prefs: []
  type: TYPE_NORMAL
- en: Other functions available in `tf.sets` include `difference()`, `intersection()`,
    and `size()`, which are self-explanatory. If you want to check whether or not
    a set contains some given values, you can compute the intersection of that set
    and the values. If you want to add some values to a set, you can compute the union
    of the set and the values.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A queue is a data structure to which you can push data records, and later pull
    them out. TensorFlow implements several types of queues in the `tf.queue` package.
    They used to be very important when implementing efficient data loading and preprocessing
    pipelines, but the tf.data API has essentially rendered them useless (except perhaps
    in some rare cases) because it is much simpler to use and provides all the tools
    you need to build efficient pipelines. For the sake of completeness, though, let’s
    take a quick look at them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest kind of queue is the first-in, first-out (FIFO) queue. To build
    it, you need to specify the maximum number of records it can contain. Moreover,
    each record is a tuple of tensors, so you must specify the type of each tensor,
    and optionally their shapes. For example, the following code example creates a
    FIFO queue with a maximum of three records, each containing a tuple with a 32-bit
    integer and a string. Then it pushes two records to it, looks at the size (which
    is 2 at this point), and pulls a record out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to enqueue and dequeue multiple records at once using `enqueue_many()`
    and `dequeue_many()` (to use `dequeue_many()`, you must specify the `shapes` argument
    when you create the queue, as we did previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Other queue types include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PaddingFIFOQueue`'
  prefs: []
  type: TYPE_NORMAL
- en: Same as `FIFOQueue`, but its `dequeue_many()` method supports dequeueing multiple
    records of different shapes. It automatically pads the shortest records to ensure
    all the records in the batch have the same shape.
  prefs: []
  type: TYPE_NORMAL
- en: '`PriorityQueue`'
  prefs: []
  type: TYPE_NORMAL
- en: A queue that dequeues records in a prioritized order. The priority must be a
    64-bit integer included as the first element of each record. Surprisingly, records
    with a lower priority will be dequeued first. Records with the same priority will
    be dequeued in FIFO order.
  prefs: []
  type: TYPE_NORMAL
- en: '`RandomShuffleQueue`'
  prefs: []
  type: TYPE_NORMAL
- en: A queue whose records are dequeued in random order. This was useful to implement
    a shuffle buffer before tf.data existed.
  prefs: []
  type: TYPE_NORMAL
- en: If a queue is already full and you try to enqueue another record, the `enqueue*()`
    method will freeze until a record is dequeued by another thread. Similarly, if
    a queue is empty and you try to dequeue a record, the `dequeue*()` method will
    freeze until records are pushed to the queue by another thread.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](app03.html#idm45720157174848-marker)) If you are not familiar with Unicode
    code points, please check out [*https://homl.info/unicode*](https://homl.info/unicode).
  prefs: []
  type: TYPE_NORMAL
