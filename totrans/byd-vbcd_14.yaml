- en: 'Chapter 11\. Beyond Code Generation: The Future of AI-Augmented Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vibe coding may have started with AI generating code from our prompts, but its
    implications reach far beyond just writing code. As AI technologies advance, they
    are poised to transform *every* aspect of the software development lifecycle.
    In this chapter, I take a speculative yet informed look at how AI’s role in software
    might expand in the future. I will explore AI-driven testing, debugging, and maintenance;
    how AI could influence software design and user experience personalization; the
    evolution of project management with AI assistance; and even the future of programming
    languages themselves. The aim is to imagine a future where AI isn’t just a code
    generator but a holistic participant in software engineering—all while grounding
    the discussion in fundamental principles, so it remains relevant even as specific
    technologies come and go.
  prefs: []
  type: TYPE_NORMAL
- en: AI in Testing, Debugging, and Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a future development environment where as soon as you write a function
    (whether by hand or via vibe coding), an AI tool immediately writes a suite of
    unit tests for it, finds potential bugs, and maybe even fixes them—all in a matter
    of seconds. This scenario is quickly becoming plausible. Let’s break down AI’s
    potential (and already emerging) contributions in quality assurance and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Test Generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing thorough tests is time-consuming and often neglected due to deadlines.
    As you saw in [Chapter 7](ch07.html#ch07_building_web_applications_with_ai_1752630044184850),
    current AI assistants can alleviate this by generating tests automatically. For
    example, given a piece of code, an AI can suggest a set of unit tests covering
    typical cases, edge cases, and error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the future, this could go further: the AI could examine your entire codebase,
    identify functions or modules with insufficient test coverage, and generate additional
    tests. It might even simulate inputs that a human tester wouldn’t think of (like
    fuzz testing), potentially catching corner-case bugs. The benefit is a more robust
    codebase with minimal manual test writing.'
  prefs: []
  type: TYPE_NORMAL
- en: The caveat is that tests are only as good as the AI’s understanding of the specification.
    Thus, a human should review AI-generated tests to ensure they align with the intended
    behavior of the software. For instance, the AI might assert a certain output that
    is *technically* what the code does, but perhaps the requirement was different—which,
    as long as a human is in the loop, can actually help to catch a misunderstanding
    in either the code or the test.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging often involves tedious searching through logs or stepping through
    code to locate the source of an error. [Chapter 5](ch05.html#ch05_understanding_generated_code_review_refine_own_1752630043592278)
    showed you how AI can act like a smart debugging companion. Some current AI tools
    can take an error message and problematic code as input and return an explanation
    and a code change to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a glimpse of how AI-assisted debugging workflows may evolve, consider an
    AI system that monitors your program’s execution, and when a crash or exception
    happens, it analyzes the stack trace and variable states to pinpoint the likely
    cause. Instead of just giving you an error message, it might say:'
  prefs: []
  type: TYPE_NORMAL
- en: The application crashed because userProfiles was null when calling getEmail().
    This suggests a missing null-check when loading user profiles.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Further, the AI could suggest a fix:'
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is to initialize userProfiles if it’s null or add a condition
    before calling getEmail(). Would you like me to apply this fix?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Future debugging AIs could integrate directly with runtime environments, catching
    issues in real time. They might even predict issues *before* they happen by analyzing
    code paths:'
  prefs: []
  type: TYPE_NORMAL
- en: This function might throw a DivisionByZero exception if called with y = 0; consider
    handling that case.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is similar to static analysis but powered by the AI’s learned knowledge
    of countless codebases and error patterns, making it potentially more insightful
    or flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Predictive Maintenance and Refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As requirements change over time, code becomes outdated or suboptimal. Maintenance
    involves activities like refactoring (improving code structure without changing
    behavior), updating dependencies, and optimizing performance. AI can assist in
    each of these areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs: []
  type: TYPE_NORMAL
- en: A future AI could identify code smells (like duplicate code or long functions)
    and automatically refactor them. For instance, it might detect that you have similar
    chunks of code in three places and recommend abstracting them into a single helper
    function. Or it could transform a deeply nested set of loops into a more readable
    form. Since the AI has seen many examples of “good” code, it can suggest [stylistic
    improvements](https://oreil.ly/XWXC_) to keep the codebase clean and maintainable.
    We might one day have a mode in our editors where the AI continuously refactors
    code in the background, with the developer reviewing and approving changes.
  prefs: []
  type: TYPE_NORMAL
- en: Updating dependencies
  prefs: []
  type: TYPE_NORMAL
- en: A future AI service might monitor your project’s dependencies (such as libraries
    and frameworks) and automatically generate pull requests to update them to newer
    versions, including any code changes needed to accommodate breaking changes. For
    example, if a new version of a web framework changes the API, the AI could adapt
    your code to the new API. This would save developers the repetitive work of reading
    migration guides and fixing version issues.
  prefs: []
  type: TYPE_NORMAL
- en: Performance tuning
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance often includes improving performance as data scales or usage patterns
    shift. AI can play a role by analyzing performance profiles and pointing out inefficiencies.
    For example, an AI might notice that a certain database query in your code is
    taking a long time and suggest adding an index or rewriting the query. It might
    identify that a loop in your code is making redundant calculations and propose
    a cache. This is akin to having a performance expert always keeping an eye on
    your application—proactively detecting inefficiencies like redundant loops or
    suboptimal data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AI might run in a staging environment, simulate heavy loads, and then feed
    you a report: “Under high load, Module X becomes a bottleneck due to Y. Consider
    refactoring using approach Z.” In essence, the AI not only finds issues but also
    educates the team on better patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: AI-Driven Design and User Experience Personalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the code and logic, AI is set to influence *how we design software and
    how users experience it*.  Good software isn’t just correct under the hood; it’s
    also intuitive, accessible, and satisfying for users. AI will continue to develop
    new ways to create better user interfaces and tailor experiences to individual
    user needs.
  prefs: []
  type: TYPE_NORMAL
- en: Generative Design Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Today’s AI design tools use techniques from generative adversarial networks
    or transformers to produce UI mockups from descriptions. A product manager can
    describe a feature in natural language:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a mobile sign-up screen with a welcome message, a playful illustration,
    and a form for name, email, and password. It should have our brand colors and
    a friendly look.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An AI design assistant can take this description and generate several candidate
    UI designs in seconds, complete with layout, placeholder text, and even styled
    components. The designer or developer then picks the closest one and refines it.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, these tools could be integrated directly into design software
    or even coding environments so that the line between “designing” and “coding the
    UI” blurs. The AI might directly output HTML/CSS or Flutter code for the design
    it generates, making it immediately testable. This would speed up the design iteration
    cycle tremendously. Instead of sketching by hand or in software, you’d collaborate
    with an AI that proposes designs based on best practices and vast training data
    of what users find appealing or usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even in the creative process of design, an AI could be a muse. When a designer
    is brainstorming a color scheme or an illustration style for an app, an AI tool
    could generate a mood board of colors or even create custom iconography on the
    fly. For instance, they might tell the AI:'
  prefs: []
  type: TYPE_NORMAL
- en: I need a logo that combines the ideas of code and music.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It would produce a few sample logos mixing symbols of coding (like curly braces)
    with musical notes. While a professional designer might ultimately handcraft the
    final asset, the AI’s suggestions can spark ideas and accelerate the exploration
    phase. In essence, AI can fill the role of a quick prototyper and creative partner
    that broadens the designer’s palate of options.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that in design and UX, human judgment is paramount. Aesthetic
    taste, understanding of human emotions, brand identity—these are things an AI
    can approximate but not inherently possess. Thus, AI in design is a tool to enhance
    human creativity, not replace it. It can handle the grunt work of producing variants
    and processing user data, freeing designers to focus on empathy and creative decisions.
  prefs: []
  type: TYPE_NORMAL
- en: For developers, AI-driven design means that the traditional handoff between
    design and development might become more fluid. Developers could generate UI code
    with AI in collaboration with designers, or vice versa. It also means frontend
    developers might spend less time tweaking layouts pixel by pixel and more time
    ensuring the design aligns with functionality and is implemented accessibly. They
    might also work on creating the hooks for personalization—writing code that allows
    the AI to choose between layout A or B based on user data and ensuring both layouts
    are performant and solid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a future of vibe coding, you might “vibe design” as well: just describe
    the vibe (pun intended) you want for your application’s look and feel, and AI
    will help materialize it. The result is a holistic AI development process—not
    just writing backend logic or database queries with AI assistance but crafting
    the whole product experience in partnership with AI.'
  prefs: []
  type: TYPE_NORMAL
- en: AI for UX Research
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another aspect of design is understanding user behavior. AI can analyze usage
    data from your application (with privacy considerations in mind) to highlight
    where users struggle. For instance, an AI might detect that many users hover over
    a certain icon expecting it to be clickable, and it’s not—indicating a UX improvement
    opportunity. Or it might notice that users from a certain demographic consistently
    drop off at a particular step of a workflow, suggesting that step might not be
    intuitive for them.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, AI could even simulate user interactions (using models of user
    behavior) to predict UX issues *before* real users encounter them. This “virtual
    UX testing” could catch things like overly complex navigation or unclear labels
    during development, when they’re easier to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Personalized User Experiences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Personalization* has been a buzzword for a while—in the sense of providing
    different content to different users based on preferences or history. AI can take
    personalization to the next level by fine-tuning software behavior and interfaces
    for each user in real time. For example, an app’s AI could learn that a particular
    user tends to navigate the app via search rather than menus. The AI could then
    adapt by making the search bar more prominent for that user or even preloading
    search results it expects the user might want given the context (like a human
    assistant anticipating their boss’s needs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another scenario would improve accessibility: if the AI detects a user is using
    screen-reader technology (and thus is perhaps visually impaired), it could automatically
    switch the application to a high-contrast, larger-font mode with optimized screen-reader
    labels, even beyond what the static accessibility settings might do. Essentially,
    software can become *adaptive*.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an ecommerce site that rearranges its layout on the fly—some users might
    see a grid of products and others a list with more details, depending on what
    seems to engage them more. These changes could be subtle and continuous as the
    AI experiments and learns—somewhat like how A/B testing works but on an individual
    level and autonomously.
  prefs: []
  type: TYPE_NORMAL
- en: The Evolution of Project Management with AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software development isn’t just writing code and making designs; it’s also
    planning, coordinating, and making decisions—the domain of project management
    and team leadership. AI’s analytical and predictive capabilities can greatly assist
    in managing projects, from allocation of tasks to risk management and decision
    support. Here’s how AI could reshape the way we plan and execute software projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Task allocation
  prefs: []
  type: TYPE_NORMAL
- en: Managing a team involves knowing each developer’s strengths, weaknesses, and
    current workload, then assigning tasks accordingly. An AI project management assistant
    could analyze various data points—code commit history, areas of expertise (perhaps
    gleaned from which parts of the codebase a developer has worked on), even personal
    productivity patterns (some people code more effectively in the morning, others
    late at night)—and recommend who should tackle a new task.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a new feature involves database work and the AI knows Alice
    has done a lot of database-related tasks successfully and isn’t overloaded, it
    might suggest assigning the task to Alice. Moreover, the AI could predict how
    long the task might take by comparing it to similar tasks in the past and considering
    the individual’s velocity. This helps project managers set more realistic timelines
    and avoid overburdening any single team member. Over time, such an AI could learn
    to balance the workload like a skilled manager, ensuring that no one is idle and
    no one is overwhelmed.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling and sprint planning
  prefs: []
  type: TYPE_NORMAL
- en: AI can assist in breaking down high-level goals into actionable items. You might
    feed the AI a feature request or a user story, and it could suggest a list of
    subtasks required to implement it. Essentially, it could produce a draft plan
    or a work breakdown structure. During sprint planning (in Agile methodologies),
    the AI could analyze the backlog and, given the team’s past velocity, suggest
    which set of tasks fits into the next sprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'It could even highlight dependencies between tasks, ensuring the plan is logically
    ordered:'
  prefs: []
  type: TYPE_NORMAL
- en: Task B should be done after Task A, as it builds on that functionality.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For long-term roadmapping, AI tools might simulate different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: If we prioritize Feature X now, the model predicts we risk delaying Feature
    Y by 2 weeks due to overlapping resource needs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having these simulations and data-driven insights can help human managers make
    informed decisions on priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Risk analysis and management
  prefs: []
  type: TYPE_NORMAL
- en: Risk management often involves anticipating what could go wrong—delays, technical
    hurdles, integration issues—and planning mitigation efforts. AI is well suited
    for pattern recognition, so it could analyze historical project data (within the
    company or even industry-wide, if available) to identify risk factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the AI might flag things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Projects involving a switch in technology stack have a 30% higher chance of
    running over schedule based on historical data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have slipped in integration testing phase in the last three projects; likely
    a risk for this project as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this, managers can preemptively allocate more time or resources to those
    phases. Another angle is monitoring current progress: an AI system could watch
    the rate of task completion, the rate of bug discovery, etc., and send alerts
    if it senses trouble:'
  prefs: []
  type: TYPE_NORMAL
- en: The team is closing tasks at half the expected rate this sprint; possible blockers
    need attention.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Essentially, AI can be an ever-vigilant project auditor, spotting issues before
    they escalate.
  prefs: []
  type: TYPE_NORMAL
- en: Decision support
  prefs: []
  type: TYPE_NORMAL
- en: 'Project management involves many decisions—like whether to cut a feature to
    meet a deadline or whether to invest in refactoring instead of adding new features.
    AI can’t make these decisions because they involve business and human factors,
    but it can provide data to support them. For instance, if debating a refactor,
    the AI might report:'
  prefs: []
  type: TYPE_NORMAL
- en: If we refactor module Z, based on complexity metrics and team input, it could
    reduce future development time on related features by 20%. It might add a two-week
    delay now but pay off in six months.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While these numbers would be estimates, having an objective analysis helps stakeholders
    weigh trade-offs more concretely.
  prefs: []
  type: TYPE_NORMAL
- en: Another example might be deciding whether to adopt a new library or build in-house.
    The AI could scan documentation, community support, and known issues about that
    library and summarize its pros and cons, saving the team hours of research.
  prefs: []
  type: TYPE_NORMAL
- en: Natural-language status queries
  prefs: []
  type: TYPE_NORMAL
- en: 'Stakeholders or managers could one day query an AI in natural language about
    project status:'
  prefs: []
  type: TYPE_NORMAL
- en: How is the payment integration feature going? What are the blockers?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The AI, having parsed ticket updates, commit messages, and test results, might
    answer:'
  prefs: []
  type: TYPE_NORMAL
- en: The payment integration is 70% complete. One blocker is a failing test related
    to currency conversion, which two developers are currently debugging. If resolved
    by tomorrow, the feature is on track for completion by Friday.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This kind of accessible status reporting can improve communication, especially
    in large teams or teams with nontechnical stakeholders. The AI basically becomes
    an omniscient project assistant that knows the nitty-gritty details and can summarize
    them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Emotional and team health insights
  prefs: []
  type: TYPE_NORMAL
- en: This is a bit speculative, but AI could also gauge team morale or stress by
    analyzing communication patterns (respecting privacy and boundaries, of course).
    For example, an AI might detect that code review comments are becoming terse or
    Jira tickets are getting a lot of “reopen” actions—possibly indicating confusion
    or frustration—and gently alert a project lead to check in on the team’s well-being.
    In remote or distributed teams, where such signals are harder to read, an AI that
    monitors the “digital mood” could be valuable. Of course, this would have to be
    handled delicately and transparently to avoid feeling invasive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all these ways, AI acts as a force multiplier for project managers. It handles
    the heavy analysis and routine suggestions, allowing human managers to focus on
    what they do best: making judgment calls, motivating the team, and handling the
    human side of collaboration. Good project management is as much art as science;
    AI can strengthen the science part (data, predictions, analysis) so that the art
    (leadership, vision, adaptability) can shine. Developers should welcome these
    enhancements too: a well-planned, well-monitored project means clearer goals and
    fewer nasty surprises. It also means less time in status meetings or updating
    spreadsheets—since the AI takes care of those details—and more time doing creative
    development work.'
  prefs: []
  type: TYPE_NORMAL
- en: How Autonomous Agents Could Change Software Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re still in the early innings of this technology, but it’s moving fast.
    It’s worth pondering the longer-term implications and how things might evolve
    in the next few years. Here’s a vision of the future of software engineering in
    the age of autonomous coding agents, drawing from current trends and some informed
    speculation:'
  prefs: []
  type: TYPE_NORMAL
- en: AI agents will become a standard part of the dev team
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as using source control or CI/CD is standard today, having AI agents participate
    in development could become routine. It might be normal that, every morning, you
    check an “AI assistant board” showing tasks done overnight by agents⁠—the code
    reviews will be waiting for you when you log in. There’s already a hint of this
    today, with agents running “while you sleep.” Engineers might commonly delegate
    a batch of tasks at day’s end for the AI to attempt by next morning. The mindset
    of what a “developer’s job” is will shift: less about typing out boilerplate or
    doing rote updates, more about defining problems, integrating solutions, and guiding
    the AI. You might say, to be a bit fanciful, that developers become more like
    product managers for AI developers—they specify what needs doing and ensure that
    it meets requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiagent collaboration will be more common
  prefs: []
  type: TYPE_NORMAL
- en: Right now, each agent largely works in isolation on a task you give it. But
    the future could see scenarios where multiple agents with different specialties
    collaborate. One agent might be great at frontend tasks and another at backend
    tasks, and you give them a coordinated task (or maybe they even *figure out* how
    to split it). Alternatively, an agent could explore multiple solution paths in
    parallel—what Kojo calls *multibranch exploration*.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you give a complex problem to an AI and it spins up three subtasks with
    different approaches or architectures, then chooses the best one—or even asks
    *you* which direction you prefer. This could dramatically reduce the time it takes
    to evaluate different implementations (something that currently might take multiple
    engineers prototyping over days). Of course, orchestrating that is a nontrivial
    task, but it’s not out of the question as agent frameworks become more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent checkpointing will let AIs ask humans for help
  prefs: []
  type: TYPE_NORMAL
- en: 'Future agents may be smart enough to ask for guidance proactively at decision
    points. This isn’t just speculation: there’s active research happening on uncertainty
    estimation and self-reflection for LLMs, with early signs that models can be trained
    or prompted to recognize when they’re unsure and ask for help rather than forge
    ahead. For example, an agent might reach a point where two libraries could be
    used to implement something and instead of guessing, it pauses (much like a junior
    dev might) and asks you:'
  prefs: []
  type: TYPE_NORMAL
- en: I could use Library A or B for this—do you have a preference?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There’s a growing belief in the industry that adding this kind of “intelligent
    checkpointing” makes agents feel more trustworthy, like collaborators rather than
    black boxes. It also aligns well with how humans work in teams—knowing when to
    ask instead of bluffing. While it’s still early, we’re starting to see more models
    that support this kind of behavior through techniques like tool-use reflection,
    planning with uncertainty thresholds, and making explicit affordances for user
    feedback midrun. Intelligent checkpointing requires the agent to know its own
    uncertainty, which is a challenge, but researchers are working on AI self-awareness,
    including confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Agent UX will improve
  prefs: []
  type: TYPE_NORMAL
- en: As we offload more work to agents, we’ll need better ways to keep track of what
    they’re doing. Kojo proposes an *agent inbox*—a unified view of what tasks agents
    are working on, what’s been done, and what needs your attention. This could be
    a dashboard showing all running agent tasks along with their progress (“3/5 steps
    completed” or “awaiting review”) and results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the current mix of logs and PRs, a clear interface to manage agents
    will emerge. Perhaps IDEs will have an “Agents” sidebar listing active tasks and
    a feed of updates. You might also get notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Agent X has finished task Y and opened PR #123.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agent Z needs input to continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This infrastructure will be important to scaling up usage without losing overview.
    After all, no one wants 10 silent bots doing who knows what with no central control.
  prefs: []
  type: TYPE_NORMAL
- en: Agents will integrate with issue trackers and CI systems
  prefs: []
  type: TYPE_NORMAL
- en: I foresee a tighter loop where an issue in your tracker (Jira, GitHub Issues,
    Linear) can be addressed by an agent from end to end. In fact, CodeGen’s Linear
    integration already hints at this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A PM files a ticket with specs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A developer (or tech lead) approves it for AI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An AI agent picks it up, does it, and attaches the PR to the ticket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A human reviews and tests the fix and closes the ticket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This could make the development process more continuous. Similarly, CI systems
    might invoke agents automatically when certain checks fail. For instance, if a
    security scan finds vulnerabilities, an agent could attempt to upgrade the vulnerable
    library or refactor the risky code and then open a PR with the fix. Or if code
    coverage drops below threshold after a PR, an agent could generate additional
    tests to raise it. Think of it as *automated maintenance*.
  prefs: []
  type: TYPE_NORMAL
- en: As a concrete example, Dependabot currently opens PRs to update dependencies.
    Not only could an AI agent open the PR, but it could also adjust any code that
    broke due to the update, run tests, and ensure it’s all good—basically a supercharged
    Dependabot.
  prefs: []
  type: TYPE_NORMAL
- en: Model improvements will narrow the 30% gap
  prefs: []
  type: TYPE_NORMAL
- en: The major AI models themselves (GPT-4, Gemini, Claude, and the like) will continue
    to improve their code understanding and generation. As they get more capable,
    that “last 30%” gap might shrink. We might see agents that hardly ever miss an
    obvious reuse or edge case, because the model has been trained on even more scenarios
    or has better reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: With better models, agents will make fewer mistakes, require less oversight,
    and possibly handle more complex tasks. That said, software is inherently complex,
    so I suspect there will *always* be some gap for human judgment. Maybe it becomes
    the last 5%–10% rather than the last 30%.
  prefs: []
  type: TYPE_NORMAL
- en: I also expect models to become more efficient, making it feasible for those
    worried about data privacy (or cost) to run local or self-hosted agents. Open
    source coding models might catch up, to the point where you can have an on-prem
    agent that’s nearly as good for many tasks as the big cloud agents.
  prefs: []
  type: TYPE_NORMAL
- en: Agents and tooling will become more specialized
  prefs: []
  type: TYPE_NORMAL
- en: We might see specialized coding agents for different domains or roles. Imagine
    a “BugFixer” agent that you point at a failing test or error log and it zeroes
    in on the bug, a “PerformanceGuru” agent that focuses on profiling and optimizing
    hot spots, or a specialized agent for writing documentation and code comments
    from an existing codebase.
  prefs: []
  type: TYPE_NORMAL
- en: By specializing, agents could incorporate more domain-specific knowledge or
    tools. We might see an agent that integrates with game engines to help with game
    dev tasks, or one that’s great at data-engineering pipelines. A team of narrow
    AI specialists could parallel the distribution of expertise within human teams,
    where some devs are known for frontend work and others for infrastructure. You
    could have AI teammates like DocsBot, TestBot, RefactorBot, and SecurityBot, each
    tuned for those purposes. In fact, Cursor already has something called BugBot
    for automated PR reviews, which is a step in that direction. BugBot doesn’t write
    code; it comments on PRs with a focus on bug risks, like a static analysis on
    steroids.
  prefs: []
  type: TYPE_NORMAL
- en: Developers will undergo a cultural and skill shift
  prefs: []
  type: TYPE_NORMAL
- en: 'If agents handle more routine coding, the skill sets of developers will shift
    more toward design, architecture, and oversight, as discussed in [Chapter 4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362).
    Soft skills, like clearly communicating requirements (to humans and AIs alike),
    become even more important. Code reading and review skills may well become as
    essential as code writing skills. We might also place more emphasis on testing:
    since tests are a critical way to verify AI outputs, being good at writing test
    cases (or guiding AI to write them) remains valuable.'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the “human 30%” will concentrate on the higher-level critical thinking
    and quality-control aspects of software development. I suspect we’ll also see
    changes in how junior developers ramp up. Maybe they’ll start by managing an AI
    agent on simple tasks before writing a ton of code themselves, which could be
    both good (they can deliver value quickly) and challenging (they need to learn
    the fundamentals and not treat the AI as a crutch). It’s an exciting time for
    those willing to adapt, but it may be uncomfortable for those who prefer the old
    ways. As I noted in [Chapter 4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362),
    a big part of “future-proofing” your career in this AI era is embracing these
    tools and emphasizing your uniquely human strengths.
  prefs: []
  type: TYPE_NORMAL
- en: New roles and processes will emerge
  prefs: []
  type: TYPE_NORMAL
- en: We might see the rise of roles like “AI Wrangler” or “Automation Lead” in engineering
    teams—people who are particularly skilled at leveraging AI agents, designing workflows
    around them, and maintaining their configurations. It’s analogous to how “build/release
    engineers” emerged when build systems became complex, or “DevOps engineers” as
    infrastructure automation grew. Similarly, audits to check that AI has not introduced
    any insecure patterns might become standard in code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be more emphasis on testing culture to provide extra confidence:
    perhaps every agent PR will have to include tests (written by the agent or a human)
    to be considered for merge. If AI agents are writing a lot of the code, maybe
    human engineers should write more of the tests (or vice versa) to ensure independent
    verification.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, the future with background coding agents looks like one where developers
    orchestrate and verify, while AI agents execute and implement (see [Figure 11-1](#ch11_figure_1_1752630045353352)).
    Software engineering could become more about supervising a fleet of automated
    coders and less about doing every step manually. This could unlock massive productivity,
    reduce the boring grunt work, and even allow teams to tackle technical debt and
    maintenance tasks they never had time for before. (Imagine clearing out all those
    minor bugs and inconsistencies because now you can just tell an AI to handle them!)
    It might also lower the barrier to prototyping new ideas: you could have an AI
    draft a whole prototype app, then just fine-tune it yourself. We may also get
    to explore more solutions before settling on decisions, since AI can generate
    alternatives quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: However, our industry must integrate these changes carefully. The human element—with
    its creativity, intuition, and ethical judgment—remains irreplaceable. AI can
    amplify our abilities, but it can also amplify mistakes if unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: 'My vision is optimistic: used wisely, autonomous coding agents will make developers
    *more* productive and allow us to focus on the truly challenging and interesting
    parts of building software, ultimately leading us to build better software faster.
    Achieving that means cultivating good practices and being aware that our role
    as developers and engineers is evolving.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bevc_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1\. Multiagent AI collaboration architecture: developers orchestrate
    specialized AI agents for testing, design, coding, and security to collaboratively
    develop comprehensive software solutions.'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The Future of Programming Languages: Natural-Language-Driven Development?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most intriguing questions about the future of vibe coding is how
    it will shape programming languages. If we can “just tell the AI what we want,”
    will we even need traditional syntax and languages? Will English (or any human
    language) become the new programming language? This section explores the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already seen signs of natural language functioning as code in tools where
    you describe a task in plain language and the AI writes the code. If this trend
    continues, we might shift more of the programming effort to specifying the *intent*
    and *requirements* rather than the implementation. Future development environments
    could allow developers (or even nondevelopers) to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Every hour, check our database for inactive users, and send an email reminder
    to any user who hasn’t logged in for 90 days, using template X. If the email bounces,
    mark the user as ‘invalid email’ in the database.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI could take this specification and translate it into the appropriate code
    (like setting up a cron job or scheduled function, writing the SQL queries or
    using the ORM, or calling an email API). Essentially, the programmer’s role becomes
    more about policy and behavior description.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn’t mean programming languages will vanish overnight. Instead, what
    might happen is a *layering*: natural language for high-level orchestration and
    existing programming languages under the hood for fine-grained control.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason programming languages exist is because natural language can be ambiguous.
    If we remove formal languages entirely, we risk miscommunicating with the machine.
    AI might bridge this gap by disambiguating based on context and by asking clarifying
    questions, but there’s likely a limit; certain complex algorithms or optimizations
    might still require very specific instructions that are easier to convey in code
    than prose. Thus, it’s conceivable that programmers of the future will need to
    be bilingual in a sense: fluent in human language to talk to the AI, and fluent
    in the underlying technical concepts to verify and tweak what the AI produces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We might also see the rise of *domain-specific natural languages*—constrained
    forms of English (or other languages) that AIs can reliably understand, tailored
    to software domains: for example, a “requirements language” for writing use cases
    that the AI can convert into tests or code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if they don’t go all the way to full natural language, AI’s influence
    will likely bring programming languages to higher levels of abstraction. In the
    past, we moved from assembly to high-level languages and from manual memory management
    to garbage-collected environments, each time raising the level of abstraction.
    AI could allow us to define abstractions on the fly. Think of this in terms of
    “programming with intent,” as discussed throughout this book: you specify a goal
    and the AI figures out how to achieve it, possibly writing lower-level code as
    needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility is *hybrid* languages that blend natural language and code.
    For example, a future language might allow code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this pseudo example, the comment in English is almost executable by the AI.
    Maybe, in the actual environment, you wouldn’t even need the lambda syntax; the
    AI could infer from the comment what you intend and fill it out. Or maybe the
    language would have constructs that look like English but are formal enough for
    the AI to parse. Think of it as an evolution of comments and pseudocode into actual
    code, with AI interpreting the intent behind them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coding is already becoming more conversational. Instead of writing a complete
    program, you start a dialogue with the AI:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Prompt:* “I need a function to calculate loyalty points for customers based
    on their purchase history.”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*AI:* “Sure. Do all products count equally, or do some products give more points?
    And how should time factor in (e.g., recent purchases versus older)?”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Prompt:* “Electronics give 2x points compared to other categories. And purchases
    in the last month give a 10% bonus.”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*AI:* “Understood. Here is the function implementing that… *[AI presents code]*.
    Shall I also generate tests for different scenarios?”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Prompt:* “Yes, and also make sure it handles the case of no purchase history
    gracefully (should return 0 points).”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this scenario, programming is a back-and-forth in natural language with
    the AI, which writes the code and asks clarification questions. This is akin to
    pair programming, except the pair partner is an AI. We already see early versions
    with ChatGPT plug-ins and Copilot Chat, etc. In the future, this could become
    the dominant mode for creating software: a conversation that progressively refines
    the software, which is much more fluid than writing a strict static text file
    from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if much of coding becomes natural language–driven, understanding how code
    and computers work will remain important. Calculators and spreadsheets didn’t
    eliminate the need for a mathematician or accountant to understand arithmetic.
    You need to know when the AI’s output is *off* somehow. If the AI misunderstands
    an English instruction, a skilled developer might switch to pseudocode or actual
    code to pin it down. So while the trivia of syntax might become less crucial (no
    need to remember the exact order of some API’s parameters if the AI can fill that
    in), algorithmic thinking and debugging will still be vital. The languages might
    change, but the underlying logic and problem-solving skills persist.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the barrier to entry for programming is already lower. Nondevelopers
    and domain experts can directly create simple applications by conversing with
    AI through vibe coding. This democratization is exciting: more people can create
    software solutions without deep programming knowledge. The professional developers
    will then tackle the harder problems, integrate those citizen-developed scripts
    safely, or build the platforms that allow such interactions.'
  prefs: []
  type: TYPE_NORMAL
- en: Even as AI helps us code in natural language, AIs themselves might evolve new
    “languages” that are somewhere in between. Perhaps new programming paradigms will
    emerge that are inherently AI-friendly—meaning they leave space for the AI to
    fill in blanks, for instance, a language that allows partial programs with placeholders
    that an AI can resolve (“[Optimize here for speed]”) or with fuzzy logic that
    the AI can refine into deterministic logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, what’s likely is not a complete replacement of programming languages
    with English but a fusion of the two: more expressive power for developers and
    a more intuitive way to tell computers what to do. As [Andrej Karpathy aptly puts
    it](https://www.youtube.com/watch?v=LCEmiRjPEtQ), “Maybe the future of programming
    isn’t about writing perfect code anymore. Maybe it’s about perfectly explaining
    what you want.” The essence of programming—thinking clearly about a problem and
    specifying a solution—remains. The form of the specification, however, will evolve
    to be more natural, with AI as the translator that turns our high-level intentions
    into low-level execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This future holds great promise: faster development, more accessibility, and
    the ability to create increasingly complex systems by focusing on *what* we want
    to achieve rather than the nitty-gritty of *how to type it out*. As always, each
    leap in abstraction has led to an explosion in creativity (high-level languages
    enabled software that assembly could never have scaled to). Natural-language-driven
    development could unleash another wave of innovation, with vibe coders at the
    forefront, literally *talking* new worlds into existence through software.'
  prefs: []
  type: TYPE_NORMAL
- en: How Vibe Coding Is Reshaping the Industry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, several fundamental principles and ideas have emerged:'
  prefs: []
  type: TYPE_NORMAL
- en: Intent over implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'Vibe coding shifts the focus from writing step-by-step code to expressing the
    intent or desired outcome and letting AI handle the implementation details. This
    changes how we approach problems: we think more about *what* we want to achieve
    and less about *how to type it out*. It’s a higher-level way of thinking about
    software development.'
  prefs: []
  type: TYPE_NORMAL
- en: AI as a collaborative partner
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a tool used in isolation, AI in vibe coding is like a pair programmer
    or an assistant. It’s interactive and iterative. We saw how important it is to
    guide the AI (through prompt engineering), to review its output, and to combine
    our strengths with the AI’s. The future isn’t “AI replacing programmers” but programmers
    [working alongside AI for greater productivity](https://oreil.ly/0uP00).
  prefs: []
  type: TYPE_NORMAL
- en: Ethics and responsibility
  prefs: []
  type: TYPE_NORMAL
- en: We emphasized that with great power (of AI) comes great responsibility. Mitigating
    bias, ensuring fairness, keeping processes transparent, and maintaining accountability
    are all critical. The industry is recognizing that relying on AI without guardrails
    can cause issues, so best practices around testing AI outputs, documenting AI
    involvement, and addressing legal questions (like IP rights of AI-generated code)
    are becoming part of standard procedure.
  prefs: []
  type: TYPE_NORMAL
- en: AI goes beyond code generation
  prefs: []
  type: TYPE_NORMAL
- en: AI’s role extends to testing, debugging, design, project management, and more.
    This holistic integration means the entire software lifecycle is accelerated and
    enhanced by AI. Tools will increasingly support these phases—some already do,
    like AI test generation in IDEs or AI-based project scheduling tools.
  prefs: []
  type: TYPE_NORMAL
- en: Skills are evolving, but fundamentals are evergreen
  prefs: []
  type: TYPE_NORMAL
- en: Programmers who embrace the previously mentioned practices will find that their
    skill set is evolving—shifting to include prompt engineering, AI oversight, data
    analysis, and high-level design alongside traditional coding and algorithmic skills.
    The core problem-solving mindset remains crucial, but the day-to-day tasks look
    different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet certain fundamentals hold: understanding your problem domain deeply, writing
    clear specifications (prompts are basically specs), maintaining rigorous testing
    and validation, and focusing on user needs. AI doesn’t change these; if anything,
    it amplifies their importance because any ambiguity or lack of clarity can be
    magnified by AI’s ultrafast execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This new paradigm of vibe coding is reshaping the industry in practical ways.
    Teams that adopt AI tools report significant boosts in productivity: developers
    can complete features in less time, or handle more complex projects with the same
    resources. It’s also lowering entry barriers: less-experienced developers can
    achieve more with AI guidance, potentially leveling up faster. On the flip side,
    it’s pushing experienced devs to expand their horizons and avoid getting complacent
    with old workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: Companies are starting to hire not just for programming knowledge but also for
    “AI literacy”—the ability to leverage AI tools effectively. Job descriptions might
    soon include familiarity with AI coding assistants, just like they include familiarity
    with version control or cloud platforms today. Being a pioneer in vibe coding
    thus offers a career advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, vibe coding democratizes programming to an extent. More people—including
    those who aren’t traditional software engineers—can participate in software creation
    by describing what they want. This could lead to a flourishing of software tailored
    to niche needs, created by domain experts with the help of AI (with professional
    developers focusing on providing guardrails, platforms, and polished core components
    for them to use).
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s an inspirational time. We stand on the brink of a transformation that
    we as developers get to shape. Think back to the early days of computing: those
    who embraced the personal computer revolution ended up creating the world we have
    now. Today, AI in programming is a similar inflection point. Embracing it means
    being part of defining how software is built for decades to come.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The future of programming is not something that will just happen to us—it’s
    something we will create. Each of us in the developer community has a role to
    play in how vibe coding and AI tools are adopted, regulated, and advanced. This
    is a call to action for you as a reader and practitioner:'
  prefs: []
  type: TYPE_NORMAL
- en: Experiment
  prefs: []
  type: TYPE_NORMAL
- en: Don’t wait for all the answers to be given to you. Go out and try vibe coding
    in different contexts. Use AI to build something quirky and new. Push the boundaries
    of what these tools can do. Maybe you’ll discover a novel use case or a limitation
    that no one has documented yet. Each experiment, whether it succeeds or fails,
    contributes knowledge to the community.
  prefs: []
  type: TYPE_NORMAL
- en: Share your findings
  prefs: []
  type: TYPE_NORMAL
- en: Write about your experiences or at least discuss them with peers. If you find
    a technique that works brilliantly, publish it. If you encounter a pitfall, warn
    others. In this rapid evolution, community knowledge sharing is how we all keep
    up. You could save someone days of debugging by posting that solution you found
    to an AI quirk, or spark someone’s creativity by sharing a cool AI-assisted project.
  prefs: []
  type: TYPE_NORMAL
- en: Contribute to tools
  prefs: []
  type: TYPE_NORMAL
- en: If you have the inclination, contribute to the development of AI tools themselves.
    This might mean contributing code to open source AI frameworks or simply giving
    detailed feedback to tool makers (many of whom are very eager to hear from users
    about what to improve). By helping shape the tools, you directly influence how
    the future will look. Many AI coding assistants today have come a long way because
    developers like you tested beta versions and provided insight.
  prefs: []
  type: TYPE_NORMAL
- en: Advocate for positive change
  prefs: []
  type: TYPE_NORMAL
- en: Within your organizations or communities, advocate for using AI to improve productivity
    and also for training people to use it properly. Encourage managers to allow time
    for learning AI tools or to update policies that might forbid them out of misunderstanding.
    Show how it can be done securely and beneficially. The more success stories emerge
    of AI augmenting teams positively, the more the industry will lean into it.
  prefs: []
  type: TYPE_NORMAL
- en: Keep a lifelong student mentality
  prefs: []
  type: TYPE_NORMAL
- en: Adopt the mindset that we are all students in this new era. Stay humble and
    open-minded. The juniors of tomorrow might come in knowing AI tooling natively
    (like how today’s new grads might have grown up with more exposure to coding than
    some older folks did). Be ready to learn from anyone, regardless of experience
    level, because this is new to everyone in some way. If you keep that student mentality,
    you’ll always find growth and avoid the trap of thinking you’ve figured it all
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Balance enthusiasm with prudence
  prefs: []
  type: TYPE_NORMAL
- en: Be enthusiastic about what’s possible—your excitement will inspire others. But
    also be the voice of prudence when needed, ensuring that excitement doesn’t lead
    to careless use. For example, champion AI-driven development but also push for
    unit tests and code reviews on AI outputs. This balanced approach will make vibe
    coding sustainable and respected.
  prefs: []
  type: TYPE_NORMAL
- en: Mentor the next generation
  prefs: []
  type: TYPE_NORMAL
- en: As you gain mastery, help newcomers. Vibe coding lowers the barriers to entry,
    meaning more beginners might dive into programming. They’ll need guidance to learn
    solid fundamentals that AI might abstract away. By mentoring them, you ensure
    that the next generation of developers doesn’t become overly reliant on AI without
    understanding. You’ll be passing on the torch of good software engineering practices,
    now enhanced by AI.
  prefs: []
  type: TYPE_NORMAL
- en: The exponential change we’re seeing is a rare opportunity. Think of previous
    technological leaps, from the Industrial Revolution to the internet boom—those
    who engaged with them shaped entire industries. We are at such a juncture with
    AI in software development. It’s not just about keeping your job or making it
    easier; it’s about having a say in how technology evolves and how it impacts society.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this book, you’ve shown you’re a forward-thinking person. Now, I
    encourage you to take that forward thinking and put it into action. Every line
    of code you write with AI, every prompt you engineer, every colleague you teach,
    every policy you influence—it all contributes to the future of vibe coding.
  prefs: []
  type: TYPE_NORMAL
- en: In closing, remember that at its heart, coding has always been about creation
    and solving problems. Vibe coding, powered by AI, is an incredibly powerful new
    medium for creation. Embrace it with optimism and curiosity. Use it to build things
    that matter. And as you do, keep the human element at the center—our creativity,
    our judgment, our values.
  prefs: []
  type: TYPE_NORMAL
- en: The future of programming is being written right now, not just in code but in
    how we choose to integrate these AI partners into our work. It’s an exciting,
    uncharted path, and each of us gets to be a pioneer. So step forward, experiment
    boldly, share freely, and lead with the best of human intellect and spirit. By
    doing so, you won’t just be adapting to the future—you’ll be actively *shaping*
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Happy vibe coding, and I’ll see you in the future you help create!
  prefs: []
  type: TYPE_NORMAL
