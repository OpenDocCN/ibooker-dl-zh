- en: 10 Model deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 模型部署
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Deploying a deep learning model in a simple web application on our local system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的本地系统上部署深度学习模型到简单的网络应用程序
- en: An introduction to key Google Cloud concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud 关键概念的介绍
- en: An introduction to Vertex AI, the machine learning environment in Google Cloud
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI 简介，Google Cloud 中的机器学习环境
- en: Deploying a deep learning model with a Vertex AI endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vertex AI 端点部署深度学习模型
- en: Adapting the web application to use a Vertex AI endpoint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配网络应用程序以使用 Vertex AI 端点
- en: Getting generative AI assistance with Gemini for Google Cloud
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Gemini 为 Google Cloud 获取生成式 AI 辅助
- en: In chapter 9, we reviewed a set of best practices for training a deep learning
    model with tabular data and introduced the Kuala Lumpur real estate price prediction
    problem as a challenging tabular problem because of its mixed-type features. In
    this chapter, we will take the model we trained in chapter 9 and deploy it in
    a simple web application. First, we will deploy it locally—that is, having both
    the web server and the trained model on our local system. Next, we will introduce
    Google Cloud as an alternative way to deploy our model. In fact, we will take
    the trained model and deploy it with an endpoint in Vertex AI, the machine learning
    environment in Google Cloud. Finally, we will examine how to use Google’s generative
    AI assistant Gemini on Google Cloud. The code described in this chapter is available
    at [https://mng.bz/6e1A](https://mng.bz/6e1A).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 章中，我们回顾了使用表格数据训练深度学习模型的一组最佳实践，并介绍了吉隆坡房地产价格预测问题作为一个具有混合类型特征的挑战性表格问题。在本章中，我们将使用第
    9 章中训练的模型，并在一个简单的网络应用程序中部署它。首先，我们将本地部署它——也就是说，将网络服务器和训练好的模型都放在我们的本地系统上。接下来，我们将介绍
    Google Cloud 作为部署我们模型的另一种方式。实际上，我们将训练好的模型部署到 Vertex AI 中，这是 Google Cloud 中的机器学习环境。最后，我们将探讨如何在
    Google Cloud 上使用 Google 的生成式 AI 助手 Gemini。本章中描述的代码可在 [https://mng.bz/6e1A](https://mng.bz/6e1A)
    获取。
- en: 10.1 A simple web deployment
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 简单的 Web 部署
- en: Once we have trained a deep learning model, having followed the best practices
    described in chapter 9, we have only just scratched the surface of the process
    of getting value out of the model. Take the example of the Kuala Lumpur real estate
    price prediction model we trained in chapter 9\. This model could be useful for
    real estate agents who want to provide advice to their clients about the price
    they should set for new real estate listings. This model could also be useful
    for property owners who want to put their properties on the market to get an idea
    of what value they could expect to get from their properties. Finally, the model
    could also be useful for buyers who are interested in purchasing properties in
    Kuala Lumpur so they can get an idea of what kind of property they could buy in
    a particular location given a certain budget.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们训练了一个深度学习模型，并遵循了第 9 章中描述的最佳实践，我们仅仅只是触及了从模型中获取价值的过程的表面。以我们在第 9 章中训练的吉隆坡房地产价格预测模型为例。这个模型对于想要为他们的客户提供定价建议的房地产经纪人来说可能很有用。这个模型也可能对想要将他们的房产推向市场以了解他们可能期望从其房产中获得的价值的房主有用。最后，这个模型也可能对对在吉隆坡购买房产感兴趣的买家有用，这样他们就可以根据一定的预算了解在特定位置可以购买哪种类型的房产。
- en: 'It’s evident that the model that we trained in chapter 9 has the potential
    to be useful to a variety of audiences. The dilemma we face is how to make the
    model available to all these audiences who have different business goals and potentially
    different computer proficiency. Later in this chapter, we will learn how to put
    a model into production on a public cloud environment, but what if we want to
    do an initial experiment to learn the characteristics of the model and run some
    tests with some beta clients? Do we need to implement the whole process of deploying
    a model in a public cloud? No, because we can take advantage of Flask, a Python
    web application library and set up a self-contained web deployment of the model.
    Flask was first released in 2010 by Armin Ronacher and has since become one of
    the most popular web frameworks for Python. It may sound a bit outdated, given
    the more recent packages such as Streamlit ([https://streamlit.io/](https://streamlit.io/))
    or Gradio ([https://www.gradio.app/](https://www.gradio.app/)). However, despite
    its age, Flask remains a relevant choice for web development due to its lightweight
    and flexible nature, especially for small personal projects. We are not going
    to explore all the details of Flask in this book; we just provide the nuts and
    bolts to set up a demonstration for a model, but if you want to learn more about
    Flask, check out the documentation: [https://flask.palletsprojects.com/en/2.3.x/](https://flask.palletsprojects.com/en/2.3.x/).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们在第9章训练的模型有可能对各种受众都有用。我们面临的困境是如何让这个模型对所有具有不同商业目标和可能不同计算机技能的受众都可用。在本章的后面部分，我们将学习如何在公共云环境中部署模型，但如果我们想进行一个初步实验来了解模型的特点并与一些测试客户进行测试呢？我们需要实现整个在公共云中部署模型的过程吗？不，因为我们可以利用Flask，这是一个Python网络应用程序库，并设置一个自包含的模型网络部署。Flask最初由Armin
    Ronacher于2010年发布，并从此成为Python最受欢迎的Web框架之一。考虑到最近出现的包，如Streamlit ([https://streamlit.io/](https://streamlit.io/))
    或Gradio ([https://www.gradio.app/](https://www.gradio.app/))，它可能听起来有点过时。然而，尽管它已经存在了一段时间，但由于其轻量级和灵活的特性，Flask仍然是Web开发的合适选择，尤其是对于小型个人项目。我们不会在本书中探讨Flask的所有细节；我们只是提供设置模型演示所需的要点，但如果你想了解更多关于Flask的信息，请查看文档：[https://flask.palletsprojects.com/en/2.3.x/](https://flask.palletsprojects.com/en/2.3.x/)。
- en: Now that we have introduced the idea of a simple web deployment, we can get
    started. In this section, we will go over how to create a simple yet complete
    deployment of the model in a pair of web pages served by Flask.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了简单Web部署的概念，我们可以开始着手了。在本节中，我们将介绍如何使用Flask在两个网页中创建一个简单而完整的模型部署。
- en: 10.1.1 Overview of web deployment
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 网络部署概述
- en: So far in this book, we have examined a variety of libraries and frameworks
    for machine learning and deep learning. With the exception of configuration files
    defined in YAML, all of the code that we have looked at so far in this book has
    been Python. Like the examples we have seen so far, the web deployment of a machine
    learning or deep learning model does include Python, but it also requires handling
    HTML, JavaScript, and CSS scripts. Figure 10.1 shows an overview of the web deployment
    we have in mind.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们已经探讨了各种机器学习和深度学习的库和框架。除了在YAML中定义的配置文件外，我们在这本书中查看的所有代码都是Python编写的。像我们之前看到的例子一样，机器学习或深度学习模型的Web部署确实包括Python，但它还需要处理HTML、JavaScript和CSS脚本。图10.1展示了我们心中的网络部署概述。
- en: '![](../Images/CH10_F01_Ryan2.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F01_Ryan2.png)'
- en: Figure 10.1 Overview of the web deployment
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 网络部署概述
- en: 'Let’s review the components that make up the web deployment depicted in figure
    10.1:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下构成图10.1所示网络部署的组件：
- en: '*Trained model—*This is the model that we saved in the Keras with the preprocessing
    layers notebook. The model is actually saved as a directory structure ([https://mng.bz/oKJp](https://mng.bz/oKJp)).
    In the Flask server module, the model is loaded using a reference to this directory.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*训练好的模型—*这是我们保存在Keras预处理层笔记本中的模型。实际上，模型是以目录结构保存的 ([https://mng.bz/oKJp](https://mng.bz/oKJp))。在Flask服务器模块中，使用对该目录的引用来加载模型。'
- en: '*Flask server module*—This is a Python module that loads the trained model
    and contains view functions for each of the solution’s HTML pages. The view functions
    specify the actions that the Flask server module takes when these HTML pages are
    loaded.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Flask服务器模块*—这是一个Python模块，用于加载训练好的模型，并包含每个解决方案HTML页面的视图函数。视图函数指定当这些HTML页面被加载时，Flask服务器模块采取的操作。'
- en: '*Flask server config file*—YAML file where you can specify parameters for the
    Flask server, such as the directory containing the trained model.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Flask服务器配置文件*—YAML文件，其中可以指定Flask服务器的参数，例如包含训练模型的目录。'
- en: '`home.html`—One of the HTML pages served by the Flask server. This page contains
    fields in which the user can specify the characteristics (such as location, number
    of rooms, and number of parking spaces) of the property for which they want to
    get a price prediction. This page also contains JavaScript functions that load
    default values into each of the fields on the page, specify the valid values that
    can be entered into each field, and package the values entered by the user so
    they can be sent back to the Flask server module.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home.html`—由Flask服务器提供的HTML页面之一。此页面包含用户可以指定他们想要获取价格预测的房产特征的字段（例如位置、房间数量和停车位数量）。此页面还包含JavaScript函数，用于将默认值加载到页面上的每个字段中，指定可以输入到每个字段的合法值，并将用户输入的值打包，以便可以发送回Flask服务器模块。'
- en: '`show-prediction.html`—One of the HTML pages served by the Flask server. This
    page displays the prediction made by the model for the property with the characteristics
    entered by the user on the `home.html` page.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show-prediction.html`—由Flask服务器提供的HTML页面之一。此页面显示模型对用户在`home.html`页面上输入的房产特征的预测。'
- en: '*CSS file*—Specifies how the HTML pages in the solution are rendered.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CSS文件*—指定解决方案中HTML页面的渲染方式。'
- en: Unlike the other examples in this book, the web deployment runs on your local
    system by default. When the Flask server is running, it serves `home.html` at
    `localhost:5000` so you can exercise the system in your browser.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他示例不同，默认情况下Web部署运行在您的本地系统上。当Flask服务器运行时，它会在`localhost:5000`上提供`home.html`，这样您就可以在浏览器中练习系统。
- en: Now that we have introduced the web deployment, we will look at the Flask server
    module and the HTML pages in more detail in the subsequent subsections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Web部署，我们将在后续小节中更详细地查看Flask服务器模块和HTML页面。
- en: 10.1.2 The Flask server module
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 Flask服务器模块
- en: The Flask server module is the heart of web deployment. Unlike the other Python
    programs we have examined so far in this book, it is a standalone `.py` file rather
    than a Jupyter Notebook.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Flask服务器模块是Web部署的核心。与本书中迄今为止我们检查的其他Python程序不同，它是一个独立的`.py`文件，而不是Jupyter Notebook。
- en: 'In this subsection, we will review the key pieces of code in the Flask server
    module and explain how they drive the web deployment. The following listing shows
    the first key section of the Flask server module: the code to load the saved Keras
    model from the file system into an object in the Python module.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将回顾Flask服务器模块中的关键代码片段，并解释它们如何驱动Web部署。以下列表显示了Flask服务器模块的第一个关键部分：从文件系统将保存的Keras模型加载到Python模块中的对象的代码。
- en: Listing 10.1 Loading the saved Keras model
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 加载保存的Keras模型
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Gets the current directory
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ① 获取当前目录
- en: ② Gets the fully qualified model directory
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取完全限定的模型目录
- en: ③ Loads the model using the fully qualified model filename
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用完全限定的模型文件名加载模型
- en: In listing 10.1, the fully qualified model directory is built using the model
    filename loaded from the config file. The model directory is expected to be in
    a directory called `models`, in the same directory as the Flask server module.
    The model is loaded by the same `tf.keras.models.load_model` function that was
    used to load the model in the Keras preprocessing layers training notebook in
    chapter 9.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表10.1中，完全限定的模型目录是通过从配置文件中加载的模型文件名构建的。期望模型目录位于名为`models`的目录中，与Flask服务器模块在同一目录下。模型是通过与第9章中Keras预处理层训练笔记本中用于加载模型的相同`tf.keras.models.load_model`函数加载的。
- en: The most important parts of the Flask server module are the view functions which
    specify the actions taken for each of the HTML pages in the application. The following
    listing shows the view function for `home.html`, the code that gets invoked when
    `home.html` is the target.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Flask服务器模块最重要的部分是视图函数，它们指定了应用程序中每个HTML页面采取的操作。以下列表显示了`home.html`的视图函数，这是当`home.html`是目标时调用的代码。
- en: Listing 10.2 `home.html` view function
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 `home.html`视图函数
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Decorator to indicate that this view function is for home.html
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ① 装饰器，表示此视图函数用于`home.html`
- en: ② Parameter sent to home.html for its rendering
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ② 发送到`home.html`以进行渲染的参数
- en: The view function shown in listing 10.2 simply sends a title to the `home.html`
    page and renders the page.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2中显示的视图函数只是向`home.html`页面发送一个标题，并渲染页面。
- en: Listing 10.3 shows the view function for `show-prediction.html`. The Flask module
    runs this code when `show_prediction.html` is the target. This view function processes
    the values that the user entered in `home.html` and invokes the model to get a
    prediction on these values.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3显示了`show-prediction.html`的视图函数。当`show_prediction.html`是目标时，Flask模块运行此代码。此视图函数处理用户在`home.html`中输入的值，并调用模型对这些值进行预测。
- en: Listing 10.3 `show-prediction.html` view function
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 `show-prediction.html`视图函数
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Decorator to indicate that this view function is for show-prediction.html
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ① 装饰器表示此视图函数用于`show-prediction.html`
- en: ② Loads categorical feature values from the query string into the scoring_dict
    dictionary
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将查询字符串中的分类特征值加载到`scoring_dict`字典中
- en: ③ Loads continuous feature values from the query string into the scoring_dict
    dictionary
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将连续特征值从查询字符串加载到`scoring_dict`字典中
- en: ④ Sets the value of the size_type_bin parameter
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置`size_type_bin`参数的值
- en: ⑤ Builds the input dictionary from scoring_dict
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 从`scoring_dict`构建输入字典
- en: ⑥ Gets the prediction from the loaded model for the loaded feature values
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 从加载的模型中获取加载的特征值的预测
- en: ⑦ Sets the output prediction string based on the value of the prediction
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 根据预测值设置输出预测字符串
- en: ⑧ Renders show-prediction.html using the prediction string
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用预测字符串渲染`show-prediction.html`
- en: The view function shown in listing 10.3 takes the query string returned from
    `home.html`, loads all the values from the query string into the Python dictionary
    `scoring_dict`, and uses those values to invoke the model loaded by the code in
    listing 10.1 to get a prediction. The one exception is `size_type_bin`. For the
    purposes of this simple web deployment, we hard-code the bin value. As an exercise,
    consider how you would calculate the bin value to avoid this hard coding. The
    value of the prediction is used to set a string value that is sent to `show-prediction.html`
    to be displayed when the page is rendered.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3中显示的视图函数将`home.html`返回的查询字符串加载到Python字典`scoring_dict`中，并使用这些值调用列表10.1中代码加载的模型以获取预测。唯一的例外是`size_type_bin`。为了这个简单的Web部署，我们硬编码了分箱值。作为一个练习，考虑一下你将如何计算分箱值以避免这种硬编码。预测的值用于设置一个字符串值，该值在页面渲染时发送到`show-prediction.html`以显示。
- en: Figure 10.2 illustrates how the view functions shown in listings 10.2 and 10.3
    interact with the web pages `home.html` and `show-prediction.html`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2说明了列表10.2和10.3中显示的视图函数如何与`home.html`和`show-prediction.html`网页交互。
- en: '![](../Images/CH10_F02_Ryan2.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F02_Ryan2.png)'
- en: Figure 10.2 Interaction between the view functions and the web pages
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2视图函数与网页之间的交互
- en: Figure 10.2 explains that the view function for `home.html` in the Flask server
    module renders `home.html`. The JavaScript functions in `home.html` build a query
    string containing the user’s feature values in `home.html`. This query string
    is returned to the `show-prediction` view function in the Flask server module.
    That view function loads the feature values from the query string and uses them
    to get a prediction for the property from the model. The model prediction is used
    to create a prediction string, which is passed to `show-prediction.html` when
    it is rendered. The prediction string is displayed in `show-prediction.html`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2解释了Flask服务器模块中`home.html`的视图函数渲染`home.html`。`home.html`中的JavaScript函数构建一个包含用户在`home.html`中的特征值的查询字符串。这个查询字符串返回到Flask服务器模块中的`show-prediction`视图函数。该视图函数从查询字符串中加载特征值，并使用它们从模型中获取属性预测。模型预测用于创建预测字符串，当渲染时传递给`show-prediction.html`。预测字符串在`show-prediction.html`中显示。
- en: Now that we have examined the key parts of the Python code in the Flask server
    module on the right side of figure 10.2, in the next section, we will move beyond
    Python to look at the HTML and JavaScript code that drives what’s happening on
    the left side of figure 10.2.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了图10.2右侧Flask服务器模块中的Python代码的关键部分，在下一节中，我们将超越Python，查看驱动图10.2左侧发生的HTML和JavaScript代码。
- en: 10.1.3 The home.html page
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 `home.html`页面
- en: 'There is a lot happening in the `home.html` page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`home.html`页面中发生了很多事情：'
- en: Setting up fields where the user can enter values for the eight property characteristics
    that the prediction is based on
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用户可以输入基于预测的八个属性特征的值的字段
- en: Setting default values and ranges for each of the fields
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个字段设置默认值和范围
- en: Gathering the input from the fields when the user clicks Get Prediction and
    sending them to the view function in the Flask server module
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击获取预测并从字段收集输入时，将它们发送到 Flask 服务器模块中的视图函数
- en: Figure 10.3 summarizes the interaction between the JavaScript functions in `home.html`
    and the user interface elements in `home.html`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 总结了 `home.html` 中 JavaScript 函数与用户界面元素的交互。
- en: '![](../Images/CH10_F03_Ryan2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F03_Ryan2.png)'
- en: Figure 10.3 Interaction between JavaScript and UI elements in `home.html`
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 `home.html` 中 JavaScript 和 UI 元素的交互
- en: Having introduced what is happening in `home.html`, let’s examine the code for
    this web page. listing 10.4 shows examples of the definitions of the input fields
    in `home.html`. These are HTML fields where the user can enter input values to
    specify the details about the property for which they want to get a price prediction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了 `home.html` 中的情况之后，让我们来检查这个网页的代码。列表 10.4 展示了 `home.html` 中输入字段定义的示例。这些是用户可以输入值以指定他们想要获取价格预测的属性的详细信息的
    HTML 字段。
- en: Listing 10.4 Examples of HTML definitions for fields
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 字段 HTML 定义示例
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Label for the location field
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ① 位置字段的标签
- en: ② Defines ID for location field
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义位置字段的 ID
- en: ③ Defines label for rooms field
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义房间字段的标签
- en: ④ Defines ID for rooms field
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义房间字段的 ID
- en: ⑤ Defines maximum and minimum values for the rooms field
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义房间字段的最大值和最小值
- en: Listing 10.4 shows examples of HTML definitions for a categorical field (`location`)
    and a continuous field (`rooms`). The HTML definitions for other fields follow
    the same pattern, with minimums and maximums set for all the continuous fields.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 展示了用于分类字段（`location`）和连续字段（`rooms`）的 HTML 定义示例。其他字段的 HTML 定义遵循相同的模式，为所有连续字段设置了最小值和最大值。
- en: 'The `load-selections()` JavaScript function gets run when the page is loaded
    by the following statement near the beginning of the HTML page:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面通过以下语句在 HTML 页面开头加载时，`load-selections()` JavaScript 函数会被执行：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following listing presents the key parts of the `load-selections()` JavaScript
    function, the function that sets up the page so it is ready for the user to select
    the characteristics of the property for which they want to get a prediction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了 `load-selections()` JavaScript 函数的关键部分，该函数设置页面以便用户可以选择他们想要获取预测的属性的属性。
- en: Listing 10.5 `load-selections()` JavaScript function
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 `load-selections()` JavaScript 函数
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Defines identifier for the location field
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义位置字段的标识符
- en: ② Defines list containing values for the selection list in the location field
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义包含位置字段选择列表值的列表
- en: ③ Defines list containing values for the selection list in the property type
    field
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义包含属性类型字段选择列表值的列表
- en: ④ Defines list containing values for the selection list in the size type field
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义包含尺寸类型字段选择列表值的列表
- en: ⑤ Sets the default value for the rooms field
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置房间字段的默认值
- en: ⑥ Loops to populate the values in the selection list in the location field
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 循环填充位置字段选择列表中的值
- en: 'From listing 10.5 we can see the main actions taken by the `load-selections()`
    JavaScript function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表 10.5 中我们可以看到 `load-selections()` JavaScript 函数执行的主要操作：
- en: For continuous fields, set the default value. This is the value that appears
    in the field when the page is initially loaded and is passed along to the Flask
    server module if the user doesn’t change it.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于连续字段，设置默认值。这是页面初始加载时在字段中显示的值，如果用户没有更改它，则将其传递给 Flask 服务器模块。
- en: For categorical fields, define the values from which the user can select and
    populate the field’s selection list with those values. In `home.html`, these values
    are defined in a hard-coded list. In a more robust web application, these values
    would be maintained in a control file separate from the code to make it easier
    to maintain the values and reduce the chance of adding regressions to the code.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于分类字段，定义用户可以从中选择的值，并使用这些值填充字段的选择列表。在 `home.html` 中，这些值定义在一个硬编码的列表中。在一个更健壮的
    Web 应用程序中，这些值将保存在一个与代码分开的控制文件中，以便更容易维护这些值并减少向代码中添加回归的风险。
- en: 'When the user has set the values they want for their property and clicks the
    Get Prediction button, the following code specifies that the `link_with_args()`
    JavaScript function gets run:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户设置了他们想要的属性值并点击获取预测按钮时，以下代码指定运行 `link_with_args()` JavaScript 函数：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 10.6 shows the `link_with_args()` JavaScript function. This function
    is called when the user clicks the Get Prediction button in `home.html`. It invokes
    the rest of the code in `home.html`, which collects the user’s input values and
    packages them into a query string that is passed back to the `show_prediction()`
    view function in the Flask module.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 显示了 `link_with_args()` JavaScript 函数。此函数在用户点击 `home.html` 中的获取预测按钮时被调用。它调用
    `home.html` 中的其余代码，收集用户的输入值并将它们打包成一个查询字符串，然后将其传递回 Flask 模块中的 `show_prediction()`
    视图函数。
- en: Listing 10.6 `link_with_args()` JavaScript function
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 `link_with_args()` JavaScript 函数
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Echoes the query string to the console
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将查询字符串回显到控制台
- en: ② Sets the page target
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置页面目标
- en: As listing 10.6 shows, the `link_with_args()` JavaScript function simply calls
    the `getOption()` function and sets the resulting query string as the target of
    the page in `window.output`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 10.6 所示，`link_with_args()` JavaScript 函数简单地调用 `getOption()` 函数，并将生成的查询字符串设置为
    `window.output` 页面的目标。
- en: Listing 10.7 shows the `getOption()` JavaScript function. This function loads
    all the values that the user has entered in `home.html` and packages them into
    a query string that is passed back to the `show_prediction()` view function in
    the Flask module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 显示了 `getOption()` JavaScript 函数。此函数加载用户在 `home.html` 中输入的所有值，并将它们打包成一个查询字符串，然后将其传递回
    Flask 模块中的 `show_prediction()` 视图函数。
- en: Listing 10.7 `getOption()` JavaScript function
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 `getOption()` JavaScript 函数
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Gets the selected entry in the selection list for the location field
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ① 获取位置字段选择列表中的选定条目
- en: ② Gets the value entered into the rooms field
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取输入到房间字段的值
- en: ③ Gets the value of the selected entry in the selection list for the location
    field
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 获取位置字段选择列表中选定条目的值
- en: ④ Sets the value of window.output to the query string
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将 window.output 的值设置为查询字符串
- en: 'The `getOption()` JavaScript function shown in listing 10.7 performs the following
    actions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 中显示的 `getOption()` JavaScript 函数执行以下操作：
- en: 'Loads the values from the continuous fields: `rooms`, `bathrooms`, `car-parks`,
    and `size`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载连续字段中的值：`rooms`、`bathrooms`、`car-parks` 和 `size`。
- en: 'Loads the selected entries in the categorical fields: `location`, `property-type`,
    `furnishing`, and `size-type`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载分类字段中选定的条目：`location`、`property-type`、`furnishing` 和 `size-type`。
- en: 'Builds the query string. The query string looks as follows:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建查询字符串。查询字符串看起来如下：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The query string consists of
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串由以下内容组成
- en: 'The URL `/show-prediction/`. Note that this URL matches the decorator that
    precedes the view function for `show-prediction` view function from the Flask
    server module shown in listing 10.3:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL `/show-prediction/`。请注意，此 URL 与列表 10.3 中显示的 Flask 服务器模块中 `show-prediction`
    视图函数之前的前缀匹配：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`?` to indicate the beginning of the query string.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 用于表示查询字符串的开始。'
- en: 'A set of parameter and value pairs to indicate the values that have been set
    for each field in `home.html`, delineated by the separator `&`. For example, the
    parameter and value pairs could look as follows:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组参数和值对，用于指示为 `home.html` 中的每个字段设置的值，由分隔符 `&` 分隔。例如，参数和值对可能如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The query string is passed to the `show-prediction` view function in the Flask
    server module. As shown in listing 10.3, in that function, the query string is
    parsed to get the values entered in `home.html` for each feature, and those values
    are used to get a prediction from the model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询字符串传递给 Flask 服务器模块中的 `show-prediction` 视图函数。如列表 10.3 所示，在该函数中，查询字符串被解析以获取在
    `home.html` 中输入的每个特征的值，并使用这些值从模型中获取预测。
- en: 10.1.4 The show-prediction.html page
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4 show-prediction.html 页面
- en: 'Now that we have looked at the Flask server module and `home.html`, there is
    one more component of the web deployment to examine: `show-prediction.html`. This
    page displays the prediction that the model makes for the property that the user
    entered values for in `home.html` and has a button that takes the user back to
    `home.html`, where they can enter values for another property.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了 Flask 服务器模块和 `home.html`，还有另一个网络部署组件需要检查：`show-prediction.html`。此页面显示模型对用户在
    `home.html` 中输入值的属性所做的预测，并有一个按钮将用户带回到 `home.html`，在那里他们可以为另一个属性输入值。
- en: Listing 10.8 `show-prediction.html`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 `show-prediction.html`
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Sets the text that appears in the browser tab for this page
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置浏览器标签中显示的文本
- en: ② Sets the stylesheet for the page
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置页面的样式表
- en: ③ Introductory text
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 简介文本
- en: ④ Button to return to home.html
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 返回到 `home.html` 的按钮
- en: As shown in listing 10.8, `show-prediction.html` does not contain any JavaScript
    functions. The HTML for the page defines the text that appears on the page, and
    the button Get Another Prediction returns the user to `home.html`. Figure 10.4
    shows how the elements we have discussed in this section appear in `show-prediciton.html`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表10.8所示，`show-prediction.html`不包含任何JavaScript函数。页面的HTML定义了页面上的文本，按钮“获取另一个预测”将用户返回到`home.html`。图10.4显示了本节中讨论的元素在`show-prediciton.html`中的显示方式。
- en: '![](../Images/CH10_F04_Ryan2.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F04_Ryan2.png)'
- en: Figure 10.4 Key elements in `show-prediction.html`
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 `show-prediction.html`中的关键元素
- en: Now that we have examined all the components of web deployment, we will review
    the rationale for deploying our model simply on the web in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了Web部署的所有组件，我们将在下一节中回顾在Web上简单部署我们的模型的理由。
- en: 10.1.5 Exercising the web deployment
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.5 练习Web部署
- en: Now that we have gone through the components that make up the web deployment,
    the next step is to see the deployment in action. To exercise the web deployment,
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了构成Web部署的组件，下一步就是看到部署的实际效果。为了练习Web部署，
- en: Create a new directory on your local system and clone the repo [https://github.com/lmassaron/ml_on_tabular_data](https://github.com/lmassaron/ml_on_tabular_data).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的本地系统上创建一个新的目录并克隆仓库 [https://github.com/lmassaron/ml_on_tabular_data](https://github.com/lmassaron/ml_on_tabular_data)。
- en: 'Make `chapter_10` your current directory and start the Flask server module:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chapter_10`设置为当前目录并启动Flask服务器模块：
- en: '[PRE13]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the Flask server module is running, go to `localhost:5000` in a browser
    to exercise the deployment.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Flask服务器模块运行，请在浏览器中转到`localhost:5000`以练习部署。
- en: Congratulations! You have exercised a deep learning model trained on tabular
    data in the context of a simple, local web application. This deployment is an
    efficient way for us to exercise the trained model and see if it behaves as we
    expect. However, this very basic deployment does not incorporate many of the characteristics
    we expect to have in a production deployment. For example, we don’t want the resources
    for serving the model to be limited by our local system. In the remainder of this
    chapter, we will examine how we can use this same web application to exercise
    the trained model deployed from an endpoint in a cloud environment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经在简单本地Web应用程序的背景下练习了一个在表格数据上训练的深度学习模型。这种部署是我们练习训练好的模型并查看其是否按预期行为的一种高效方式。然而，这种非常基础的部署并没有包含我们在生产部署中期望拥有的许多特性。例如，我们不希望服务模型的资源受限于我们的本地系统。在本章的剩余部分，我们将探讨如何使用这个相同的Web应用程序来练习从云环境中的端点部署的训练模型。
- en: 10.2 Public clouds and machine learning operations
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 公共云和机器学习操作
- en: The simple web deployment that we reviewed in the previous section demonstrates
    some useful aspects of what it takes to put a trained model into production, but
    it has some serious limitations. It is running entirely on a local system, so
    it won’t be accessible to anyone who doesn’t have access to the local system.
    This is probably a good thing, because this deployment does not incorporate the
    characteristics that we want to have in a production deployment, including
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中回顾的简单Web部署展示了将训练好的模型投入生产所需的一些有用方面，但它有一些严重的局限性。它完全运行在本地系统上，因此没有访问本地系统的人将无法访问。这可能是一件好事，因为这种部署没有包含我们希望在生产部署中拥有的特性，包括
- en: '*Scaling capacity to meet demand*. What happens if the interest rate drops
    and the demand for price predictions doubles?'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扩展容量以满足需求*。如果利率下降，对价格预测的需求翻倍会发生什么？'
- en: '*Seamless model updates*. What if we retrain the model on the latest data and
    need to deploy it quickly, without any interruption to the service?'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无缝模型更新*。如果我们用最新数据重新训练模型并需要快速部署它，而不中断服务，会怎样？'
- en: '*Serving multiple versions of the model at the same time*. What if we want
    to experiment with a version of the model that is trained on a different dataset
    by exposing the new model to a subset of the users? How do we serve multiple versions
    of the model and control what proportion of users see each version?'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同时服务多个模型的版本*。如果我们想通过向用户子集展示新模型来实验在另一个数据集上训练的模型版本，会怎样？我们如何服务多个模型的版本并控制每个版本的用户比例？'
- en: '*Model monitoring*. How do we track the accuracy of the model as the real estate
    market develops? How do we catch and correct problems before they impact our users?'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模型监控*。随着房地产市场的不断发展，我们如何跟踪模型的准确性？我们如何在问题影响用户之前捕捉并纠正它们？'
- en: '*Resiliency and up-time*. With this application implemented on a local system,
    what happens when the system needs maintenance or has an unplanned outage? How
    do we ensure that our users can continue to get access to the application?'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*弹性与可用性*。当本地系统需要维护或出现计划外中断时，应用将如何应对？我们如何确保用户可以继续访问该应用？'
- en: We could implement custom code to handle all of these scenarios, but there is
    a simpler solution. Public clouds provide complete, end-to-end machine learning
    and machine learning operations (MLOps) environments to address all the challenges
    listed here. The three most-used public clouds in the world are
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施自定义代码来处理所有这些场景，但有一个更简单的解决方案。公共云提供了完整的、端到端的机器学习和机器学习操作（MLOps）环境，以解决这里列出的所有挑战。世界上使用最广泛的三个公共云是
- en: AWS
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS
- en: Azure
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure
- en: Google Cloud
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌云
- en: Many organizations will use one or more of these public clouds to put their
    models into production.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织将使用一个或多个这些公共云来部署他们的模型。
- en: The public cloud concepts that we describe in this chapter and chapter 11 are
    available in all three of these public clouds, but we are going to use Google
    Cloud for the public cloud examples in this chapter. There are a few reasons for
    this. One of the authors is a Google employee, but, more importantly, our objective
    opinion is that Google Cloud provides an easy-to-use environment for deploying
    models trained with tabular data and exploring the key concepts of MLOps. In the
    remainder of this chapter, we will go through how to get started with Google Cloud
    and how to use it to deploy a model. In chapter 11, we will go beyond the simple
    deployment in this chapter to explore the features in Google Cloud that make it
    easy to retrain and redeploy the model.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和第11章中描述的公共云概念在这三个公共云中都是可用的，但我们将在本章中使用谷歌云作为公共云示例。这样做有几个原因。其中一位作者是在谷歌工作的员工，但更重要的是，我们客观的看法是谷歌云提供了一个易于使用的环境，用于部署使用表格数据训练的模型并探索MLOps的关键概念。在本章的剩余部分，我们将介绍如何开始使用谷歌云以及如何用它来部署模型。在第11章中，我们将超越本章中的简单部署，探索谷歌云中使模型重新训练和重新部署变得容易的功能。
- en: 10.3 Getting started with Google Cloud
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 开始使用谷歌云
- en: In this section, we will go through the initial steps of getting started with
    Google Cloud, including accessing Google Cloud for the first time, creating a
    project, and creating a Google Cloud Storage bucket, a data storage container.
    In the subsequent section, we will see how to use Vertex AI, the machine learning
    platform in Google Cloud, to deploy our model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍开始使用谷歌云的初步步骤，包括首次访问谷歌云、创建项目以及创建谷歌云存储桶，一个数据存储容器。在下一节中，我们将了解如何使用谷歌云中的机器学习平台Vertex
    AI来部署我们的模型。
- en: 10.3.1 Accessing Google Cloud for the first time
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 首次访问谷歌云
- en: In this section, we will go through signing into Google Cloud for the first
    time and setting up a Google Cloud *project*. Everything you do in Google Cloud
    is associated with a project. You can use projects to organize your work and to
    control the teams and individuals who have access to given Google Cloud resources.
    To get started, go to [https://cloud.google.com](https://cloud.google.com) and
    click Sign In, as shown in figure 10.5.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何首次登录谷歌云并设置一个谷歌云*项目*。你在谷歌云中做的每一件事都与一个项目相关联。你可以使用项目来组织你的工作，并控制可以访问给定谷歌云资源的团队和个人。要开始，请访问[https://cloud.google.com](https://cloud.google.com)并点击登录，如图10.5所示。
- en: '![](../Images/CH10_F05_Ryan2.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F05_Ryan2.png)'
- en: Figure 10.5 Signing into Google Cloud
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 登录谷歌云
- en: Once you have signed in, click Console to open up the Google Cloud console,
    as shown in figure 10.6.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，点击控制台以打开谷歌云控制台，如图10.6所示。
- en: If you have not used Google Cloud before, you will need to set up your account
    for billing. You may be eligible for free credit, but you will need to enter credit
    card details to use the features that are described in this chapter and chapter
    11\. Once you have signed in and, if necessary, completed setting up your account
    with billing details, you will be at the console, as shown in figure 10.7.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有使用过 Google Cloud，您需要设置您的计费账户。您可能有资格获得免费信用额度，但您需要输入信用卡详细信息才能使用本章和第 11
    章中描述的功能。一旦您登录，并在必要时完成设置带有计费详情的账户，您将进入控制台，如图 10.7 所示。
- en: '![](../Images/CH10_F06_Ryan2.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F06_Ryan2.png)'
- en: Figure 10.6 Entering the Google Cloud console
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 输入 Google Cloud 控制台
- en: '![](../Images/CH10_F07_Ryan2.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F07_Ryan2.png)'
- en: Figure 10.7 Google Cloud console
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 Google Cloud 控制台
- en: The console is the user interface for Google Cloud. This is one of the interface
    choices for working with Google Cloud features, and it is what we will use for
    most of the actions we will take in Google Cloud in this chapter. In addition
    to the Cloud console, you can interact with Google Cloud features using
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台是 Google Cloud 的用户界面。这是与 Google Cloud 功能交互的界面选择之一，也是我们在本章中将在 Google Cloud
    中执行的大多数操作所使用的界面。除了 Cloud 控制台外，您还可以使用
- en: Command-line interface
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行界面
- en: Client libraries
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端库
- en: NOTE See [https://cloud.google.com/docs/overview](https://cloud.google.com/docs/overview)
    for more details on the interfaces for Google Cloud.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关 Google Cloud 接口的更多详细信息，请参阅 [https://cloud.google.com/docs/overview](https://cloud.google.com/docs/overview)。
- en: 10.3.2 Creating a Google Cloud project
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 创建 Google Cloud 项目
- en: You can create a project once you have successfully logged into Google Cloud
    and accessed the Google Cloud Console. In this section, we will go through the
    steps to create a project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您成功登录 Google Cloud 并访问 Google Cloud 控制台后，可以创建一个项目。在本节中，我们将介绍创建项目的步骤。
- en: In the Google Cloud console, click the Project Selection field, as shown in
    figure 10.8\. In the Select a Project screen, select New Project, as shown in
    figure 10.9\. Then, enter `first-project-ml-tabular` in the Project Name field
    and click on Create, as shown in figure 10.10.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 控制台中，单击“项目选择”字段，如图 10.8 所示。在“选择项目”屏幕中，选择“新建项目”，如图 10.9 所示。然后，在“项目名称”字段中输入
    `first-project-ml-tabular` 并单击创建，如图 10.10 所示。
- en: '![](../Images/CH10_F08_Ryan2.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F08_Ryan2.png)'
- en: Figure 10.8 Selecting a project
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 选择项目
- en: '![](../Images/CH10_F09_Ryan2.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F09_Ryan2.png)'
- en: Figure 10.9 Selecting a project screen
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 选择项目屏幕
- en: '![](../Images/CH10_F10_Ryan2.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F10_Ryan2.png)'
- en: Figure 10.10 Entering a project name
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 输入项目名称
- en: Congratulations! You have created your first Google Cloud project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功创建了您的第一个 Google Cloud 项目。
- en: Note that the project name needs to be unique for your set of projects. The
    project ID, which appears below the Project name field, must be universally unique,
    so if you have a project name that is shared with any other project in Google
    Cloud, the project ID for that project will be automatically updated to be unique.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，项目名称对于您的项目集合必须是唯一的。项目 ID，位于“项目名称”字段下方，必须是全局唯一的，因此如果您有一个与 Google Cloud 中任何其他项目共享的项目名称，该项目的项目
    ID 将自动更新为唯一。
- en: 10.3.3 Creating a Google Cloud Storage bucket
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 创建 Google Cloud 存储桶
- en: 'The primary way to store data in Google Cloud is to use Cloud Storage buckets.
    In this section, we will go through just what you need to know about Cloud Storage
    buckets for the purposes of deploying a model. If you are interested in more details
    on Cloud Storage buckets, see the documentation: [https://cloud.google.com/storage/docs/buckets](https://cloud.google.com/storage/docs/buckets).
    We will be using a bucket to store the model we trained in chapter 9\. To create
    a Cloud Storage bucket, enter “cloud storage” in the search bar in the Cloud Console
    and select Cloud Storage, as shown in figure 10.11.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 中存储数据的主要方式是使用 Cloud Storage 存储桶。在本节中，我们将介绍您在部署模型时需要了解的关于 Cloud
    Storage 存储桶的详细信息。如果您想了解更多关于 Cloud Storage 存储桶的细节，请参阅文档：[https://cloud.google.com/storage/docs/buckets](https://cloud.google.com/storage/docs/buckets)。我们将使用一个存储桶来存储第
    9 章中训练的模型。要创建 Cloud Storage 存储桶，请在 Cloud Console 的搜索栏中输入“cloud storage”，然后选择 Cloud
    Storage，如图 10.11 所示。
- en: '![](../Images/CH10_F11_Ryan2.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F11_Ryan2.png)'
- en: Figure 10.11 Searching for Cloud Storage
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 搜索 Cloud Storage
- en: The Cloud Storage Buckets page appears. Select Create to create a new Cloud
    Storage bucket, as shown in figure 10.12.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Storage 存储桶页面出现。选择创建以创建新的 Cloud Storage 存储桶，如图 10.12 所示。
- en: '![](../Images/CH10_F12_Ryan2.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F12_Ryan2.png)'
- en: Figure 10.12 Cloud Storage view
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 云存储视图
- en: In the Create a bucket page, enter a unique name for your bucket (figure 10.13),
    click Continue, and select Region in Location Type, and select a region, as shown
    in figure 10.14\. To work with the machine learning pipeline script code that
    we will explore in chapter 11, the bucket needs to be created in a region. For
    the purposes of this example, you can pick any region that you like. Click Create.
    Note that your bucket name has to be universally unique.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在“创建桶”页面中，为您的桶输入一个独特的名称（如图10.13所示），点击继续，然后在“位置类型”中选择区域，并选择一个区域，如图10.14所示。为了在11章中探索的机器学习管道脚本代码，桶需要创建在某个区域。为了本例的目的，您可以选择您喜欢的任何区域。点击创建。请注意，您的桶名称必须是全球唯一的。
- en: '![](../Images/CH10_F13_Ryan2.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F13_Ryan2.png)'
- en: Figure 10.13 Setting the bucket name
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 设置桶名称
- en: '![](../Images/CH10_F14_Ryan2.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F14_Ryan2.png)'
- en: Figure 10.14 Setting location type for the bucket
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 设置桶的位置类型
- en: The Bucket details page appears, showing your new bucket, as shown in figure
    10.15.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示新桶的“桶详细信息”页面，如图10.15所示。
- en: '![](../Images/CH10_F15_Ryan2.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F15_Ryan2.png)'
- en: Figure 10.15 Bucket details showing the new bucket
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 显示了新桶的详细信息
- en: Congratulations! You have created your first Google Cloud Storage bucket.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已创建了您的第一个Google Cloud Storage桶。
- en: 10.4 Deploying a model in Vertex AI
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 在Vertex AI中部署模型
- en: Earlier in this chapter, we deployed the Kuala Lumpur real estate price prediction
    model using a simple, Flask-based web application. In this section, we are going
    to deploy the same model using the Google Cloud Vertex AI environment.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们使用基于Flask的简单Web应用程序部署了吉隆坡房地产价格预测模型。在本节中，我们将使用Google Cloud Vertex AI环境部署相同的模型。
- en: 'Now that we have created a project in Google Cloud and created a Cloud Storage
    bucket in the new project, we are ready to deploy a model in Google Cloud. The
    following are the steps we will follow for this deployment (described in more
    detail in the Vertex AI documentation at [https://mng.bz/nRJ2](https://mng.bz/nRJ2)):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Google Cloud中创建了一个项目，并在新项目中创建了一个云存储桶，我们准备在Google Cloud中部署一个模型。以下是我们将遵循的部署步骤（在Vertex
    AI文档[https://mng.bz/nRJ2](https://mng.bz/nRJ2)中描述得更详细）：
- en: Upload the model we trained in chapter 9 to Google Cloud storage.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第9章中训练的模型上传到Google Cloud存储。
- en: Import the model to the Vertex AI Model Registry.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型导入Vertex AI模型注册表。
- en: The following sections describe each of these steps.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节描述了这些步骤。
- en: 10.4.1 Uploading the model to a Cloud Storage bucket
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 将模型上传到云存储桶
- en: The simplest way to get your trained model into Google Cloud Storage is to upload
    a folder containing the trained model. If you want to upload a version of the
    model that has already been trained, clone the repo at [https://github.com/lmassaron/Advanced_Analytics_for_Business](https://github.com/lmassaron/Advanced_Analytics_for_Business).
    The directory you want to upload is `chapter_10/models/kl_real_estate_keras_preprocessing_model`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将训练好的模型上传到Google Cloud Storage的最简单方法是上传包含训练模型的文件夹。如果您想上传已经训练过的模型版本，请克隆[https://github.com/lmassaron/Advanced_Analytics_for_Business](https://github.com/lmassaron/Advanced_Analytics_for_Business)上的repo。您要上传的目录是`chapter_10/models/kl_real_estate_keras_preprocessing_model`。
- en: To upload the model that you created in chapter 9, select the Cloud Storage
    bucket you created in the Cloud Storage page, as shown in figure 10.16\. In the
    Bucket Details page, select Upload Folder, as shown in figure 10.17.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要上传在第9章中创建的模型，请选择如图10.16所示的云存储页面中您创建的云存储桶。在“桶详细信息”页面中，选择“上传文件夹”，如图10.17所示。
- en: '![](../Images/CH10_F16_Ryan2.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F16_Ryan2.png)'
- en: Figure 10.16 Selecting your bucket in the Cloud Storage page
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 在云存储页面中选择您的桶
- en: '![](../Images/CH10_F17_Ryan2.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F17_Ryan2.png)'
- en: Figure 10.17 Uploading a folder in the Bucket details page
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 在桶详细信息页面中上传文件夹
- en: Select the folder on your local system containing the trained model from chapter
    9\. When the upload is complete, the folder will appear on the Bucket details
    page, as shown in figure 10.18.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 选择包含第9章训练模型的本地系统上的文件夹。上传完成后，文件夹将出现在“桶详细信息”页面中，如图10.18所示。
- en: '![](../Images/CH10_F18_Ryan2.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F18_Ryan2.png)'
- en: Figure 10.18 Your uploaded bucket in the Bucket details page
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 您上传的桶在桶详细信息页面中
- en: Congratulations! You have uploaded your model to Google Cloud.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已将模型上传到Google Cloud。
- en: 10.4.2 Importing the model to Vertex AI
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 将模型导入Vertex AI
- en: Now that we have uploaded the model to a Google Cloud Storage bucket, we can
    import it to the Vertex AI Model Registry. Enter “vertex ai” in the Google Cloud
    console search bar to get to the Vertex AI page. If this is the first time you
    have used Vertex AI, you will see Enable All Recommended API. If you see this
    button, click on it to enable the APIs that are required to use Vertex AI, as
    shown in figure 10.19\.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F19_Ryan2.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 Enabling Vertex AI APIs
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Then select Model Registry in the left navigation panel, as shown in figure
    10.20, and on the Model Registry page, click Import, as shown in figure 10.21.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F20_Ryan2.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 Model Registry in the Vertex AI page navigation panel
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F21_Ryan2.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 Model Registry import
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In the Import model page, select Import as New Model, enter “first-model-ml-tabular”
    in the Name field, and click Continue, as shown in figure 10.22.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F22_Ryan2.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 Specifying the name of the imported model in Model Registry
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Model settings tab of the Import model page, follow these steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In Model Framework, select TensorFlow. Recall from chapter 8 TensorFlow is the
    low-level framework for Keras, the framework we used to train the model.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Model Framework Version, select the TensorFlow level used to train the model.
    You can find this level from the output of `tf.__version__` in the notebook used
    to train the model:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Model Artifact Location, click Browse and select the folder where you uploaded
    the model.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Continue and Import, as shown in figure 10.23.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F23_Ryan2.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 Specifying model settings
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The model import process may take several minutes to complete. When the import
    is complete, you will see the new model name on the Model Registry page, as shown
    in figure 10.24.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F24_Ryan2.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 Model Registry showing the imported model
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have imported a model into Vertex AI. In the next section,
    we will go through the steps to make this model available through an endpoint.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.3 Deploying the model to an endpoint
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have imported the trained model into Vertex AI, we can deploy it
    to an endpoint. By deploying the model to an endpoint, we get a URL that we can
    use to invoke the model. In effect, the endpoint deployment can take the place
    of the model file in the local file system that the Flask server loaded in the
    simple web deployment that we did earlier in this chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: To deploy the model to an endpoint, on the Model Registry page, select the model
    we created in the previous section. In the model details page, select the version
    of the model (by default, 1), as shown in figure 10.25\. In the version page for
    the model, click Deploy to Endpoint, as shown in figure 10.26\. In the Deploy
    to Endpoint page, enter a name in Endpoint name and click Continue, as shown in
    figure 10.27.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F25_Ryan2.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 Model details page
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 模型详情页面
- en: '![](../Images/CH10_F26_Ryan2.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F26_Ryan2.png)'
- en: Figure 10.26 Deploying your model
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.26 部署您的模型
- en: '![](../Images/CH10_F27_Ryan2.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F27_Ryan2.png)'
- en: Figure 10.27 Deploying to endpoint page
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27 部署到端点页面
- en: In the Model Settings tab, under Advanced Scaling Options, select a minimal
    machine type, such as `n1-standard-2`, as shown in figure 10.28, and click Continue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型设置选项卡下，在高级扩展选项中，选择一个最小机器类型，例如 `n1-standard-2`，如图 10.28 所示，然后点击继续。
- en: '![](../Images/CH10_F28_Ryan2.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F28_Ryan2.png)'
- en: Figure 10.28 Setting the machine type for the deployment
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.28 设置部署的机器类型
- en: Because this is a test deployment of a simple model, we only need a minimal
    machine type. If we were deploying a more demanding model, or making a production
    deployment, we could choose a machine type with more memory or compute resources,
    depending on the requirements of our model. A minimal machine type is good enough
    for our test deployment, and it will cost us less than a more advanced machine
    type. When you are using a cloud environment, it’s a best practice to use the
    resources that are sufficient for your application and not more. Doing this will
    save you money.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个简单模型的测试部署，我们只需要一个最小机器类型。如果我们部署一个更复杂的需求模型或进行生产部署，我们可以根据模型的需求选择具有更多内存或计算资源的机器类型。对于我们的测试部署，最小机器类型已经足够好，并且它将比更高级的机器类型成本低。当您使用云环境时，使用足够满足您应用程序的资源而不是更多的资源是一种最佳实践。这样做可以为您节省金钱。
- en: TIP For more details about machine types for Vertex AI endpoint deployments,
    see the documentation at [https://mng.bz/vK14](https://mng.bz/vK14).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：有关 Vertex AI 端点部署的机器类型更详细的信息，请参阅[https://mng.bz/vK14](https://mng.bz/vK14)的文档。
- en: Click Deploy, as shown in figure 10.29.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 10.29 所示，点击部署。
- en: '![](../Images/CH10_F29_Ryan2.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F29_Ryan2.png)'
- en: Figure 10.29 Selecting Deploy in the Deploy to endpoint page
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.29 在部署到端点页面中选择部署
- en: Deployment can take several minutes to complete. When deployment is complete,
    the status of the deployment on the Model version details page changes to Active,
    as shown in figure 10.30.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 部署可能需要几分钟才能完成。当部署完成后，模型版本详情页面上的部署状态将变为活动状态，如图 10.30 所示。
- en: '![](../Images/CH10_F30_Ryan2.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F30_Ryan2.png)'
- en: Figure 10.30 Confirmation that the model has been deployed
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.30 模型已部署的确认
- en: Congratulations! You have completed the deployment of a model in Vertex AI.
    In the next section, we will go through the steps to quickly test the deployment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已在 Vertex AI 中完成了模型的部署。在下一节中，我们将介绍快速测试部署的步骤。
- en: 10.4.4 Initial test of the model deployment
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.4 模型部署的初步测试
- en: Now that we have deployed the model, we can do an initial test of the model
    deployment directly in the Google console.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了模型，我们可以在 Google 控制台中直接对模型部署进行初步测试。
- en: 'Recall the test of the trained model that we did in chapter 9 to exercise the
    model in the context of a Jupyter Notebook. We defined a Python dictionary that
    contained all the features used to train the model, along with values for each
    of the features:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 回想我们在第 9 章中进行的训练模型测试，以在 Jupyter Notebook 的上下文中锻炼模型。我们定义了一个包含所有用于训练模型的特征的 Python
    字典，以及每个特征的值：
- en: '[PRE15]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can reuse this sample to test the model deployment in Vertex AI. In the Model
    version details page, go to the Test Your Model section, as shown in figure 10.31.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用这个示例来测试在 Vertex AI 中的模型部署。在模型版本详情页面，转到测试您的模型部分，如图 10.31 所示。
- en: '![](../Images/CH10_F31_Ryan2.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F31_Ryan2.png)'
- en: Figure 10.31 Test Your Model section of the Deploy and Test tab
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.31 部署和测试标签页的测试您的模型部分
- en: Update the JSON request field to use the values from the sample from chapter
    9, with each value being an entry in a list and double quotes being used throughout.
    When you have completed the update, the JSON request field should look like figure
    10.32.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 JSON 请求字段以使用第 9 章示例中的值，每个值都是一个列表条目，并且在整个文档中使用双引号。当您完成更新后，JSON 请求字段应如图 10.32
    所示。
- en: '![](../Images/CH10_F32_Ryan2.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F32_Ryan2.png)'
- en: Figure 10.32 Test sample in JSON format
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.32 JSON 格式的测试样本
- en: 'Note three differences between the format of the sample in the JSON request
    and the original sample from the chapter 9 Jupyter Notebook:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 JSON 请求样本格式与第 9 章 Jupyter Notebook 中的原始样本之间的三个差异：
- en: Values in the key-value pairs are all arrays rather than single values. You
    will get an error if you have single values.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值对中的值都是数组而不是单个值。如果您有单个值，将会得到一个错误。
- en: Double quotes (“ “) are used throughout rather than single quotes.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全角引号（“ “）被广泛使用，而不是单引号。
- en: There is no comma after the last key-value pair.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一个键值对之后不需要逗号。
- en: Once the JSON Request field contains valid JSON, the frame turns blue. Click
    Predict to see the output of the endpoint in the Response field, as shown in figure
    10.33.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦JSON请求字段包含有效的JSON，框架就会变成蓝色。点击预测，在响应字段中查看端点的输出，如图10.33所示。
- en: '![](../Images/CH10_F33_Ryan2.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F33_Ryan2.png)'
- en: Figure 10.33 Response from the endpoint for the test sample
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33 端点对测试样本的响应
- en: 'Note that the prediction value is not a probability. Recall that when we got
    a prediction from the model in the model training notebook in chapter 9, and when
    we got a prediction from the model in the Flask server module, we needed to apply
    the sigmoid function to the output of the model to get the probability that the
    property has a price above the median:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，预测值不是概率。回想一下，当我们从第9章模型训练笔记本中的模型获取预测，以及当我们从Flask服务器模块中的模型获取预测时，我们需要将模型的输出应用sigmoid函数以获取该属性价格高于中值的概率：
- en: '[PRE16]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to apply the sigmoid function to get the probability from the output
    provided by the endpoint. If we update the statements that we used in the training
    notebook so that the input to the sigmoid function is the output of the endpoint,
    then we get the same probability that we got for this property when we used it
    to exercise the model in chapter 9:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要应用sigmoid函数来从端点提供的输出中获取概率。如果我们更新我们在训练笔记本中使用的语句，使得sigmoid函数的输入是端点的输出，那么我们就会得到与我们在第9章使用它来练习模型时相同的概率：
- en: '[PRE17]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, having validated that the endpoint works and that for the same property,
    we get the same results as when we applied the model directly in a Jupyter Notebook.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经验证了端点工作正常，并且对于相同的属性，我们得到的结果与我们在Jupyter Notebook中直接应用模型时得到的结果相同。
- en: 10.5 Using the Vertex AI deployment with Flask
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 使用Flask部署Vertex AI
- en: In the previous section, we deployed the Kuala Lumpur property price prediction
    model to an endpoint in Vertex AI. In this section, we will adapt the Flask web
    deployment to use this endpoint. When we are done, we should have the same experience
    from the web pages `home.html` and `show-prediction.html`, with the model being
    served from the Vertex AI endpoint rather than from a local system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将吉隆坡房价预测模型部署到了Vertex AI的端点。在本节中，我们将适配Flask Web部署以使用此端点。完成之后，我们应该从`home.html`和`show-prediction.html`网页中获得相同的使用体验，模型将由Vertex
    AI端点提供服务，而不是本地系统。
- en: 'To adapt the Flask deployment to work with the Vertex AI endpoint deployment,
    we will need to take the following steps:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Flask部署与Vertex AI端点部署兼容，我们需要采取以下步骤：
- en: Set up the Vertex AI SDK.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Vertex AI SDK。
- en: Update the Flask server module to access the Vertex AI endpoint to get predictions
    from the model served there.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Flask服务器模块以访问Vertex AI端点，从该端点获取模型的预测。
- en: Figure 10.34 shows the key components of the application that is adapted to
    use a Vertex AI endpoint deployment of the model.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34显示了适配使用Vertex AI端点部署的应用程序的关键组件。
- en: In the remainder of this section, we will go through the steps required to deploy
    the model with the Vertex AI endpoint using the web application.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将介绍使用Web应用程序部署模型所需的步骤。
- en: '![](../Images/CH10_F34_Ryan2.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F34_Ryan2.png)'
- en: Figure 10.34 Sample request link in the Deploy and Test tab
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/CH10_F34_Ryan2.png)'
- en: 10.5.1 Setting up the Vertex AI SDK
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 设置Vertex AI SDK
- en: Vertex AI provides client libraries that allow you to access Vertex AI features
    via an API in Python, Java, and `node.js` applications. The client library for
    Python is included in the Python SDK for Vertex AI, so we will install the SDK
    to get the API access required to invoke the model via the endpoint.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Vertex AI提供了客户端库，允许您通过Python、Java和`node.js`应用程序中的API访问Vertex AI功能。Python客户端库包含在Vertex
    AI的Python SDK中，因此我们将安装SDK以获取通过端点调用模型所需的API访问权限。
- en: NOTE For full details on the Vertex AI SDK, see the documentation at [https://mng.bz/4a1j](https://mng.bz/4a1j).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关Vertex AI SDK的完整详细信息，请参阅[https://mng.bz/4a1j](https://mng.bz/4a1j)上的文档。
- en: 'You can use the following command to install the Vertex AI SDK:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装Vertex AI SDK：
- en: '[PRE18]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have the Vertex AI SDK installed, we can proceed to the next step:
    updating the Flask server module.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Vertex AI SDK，我们可以进行下一步：更新Flask服务器模块。
- en: 10.5.2 Updating the Flask server module to call the endpoint
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 更新 Flask 服务器模块以调用端点
- en: To get an overview of how to use the Vertex AI API to access the model via the
    endpoint, click the Sample Request link in the Model version details page, as
    shown in figure 10.35.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何通过端点使用 Vertex AI API 访问模型，请点击模型版本详情页面中的示例请求链接，如图 10.35 所示。
- en: '![](../Images/CH10_F35_Ryan2.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F35_Ryan2.png)'
- en: Figure 10.35 Sample request link in the Deploy and Test tab
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.35 部署和测试选项卡中的示例请求链接
- en: 'The first update to the Flask server module is to import the libraries required
    for Vertex AI:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 服务器模块的第一个更新是导入 Vertex AI 所需的库：
- en: '[PRE19]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we add the `predict_custom_trained_model_sample()` function defined in
    [https://mng.bz/QD8v](https://mng.bz/QD8v). We need to make one update to this
    function so that it returns `predictions` (which contains the response from the
    endpoint) back to the `show-prediction.html` view function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加定义在 [https://mng.bz/QD8v](https://mng.bz/QD8v) 的 `predict_custom_trained_model_sample()`
    函数。我们需要对这个函数进行一项更新，以便它将 `predictions`（包含端点的响应）返回到 `show-prediction.html` 视图函数。
- en: Listing 10.9 highlights the updates that we need to make to the `show-prediction.html`
    view function. These changes package the input values in the format expected by
    the Vertex AI endpoint deployment and invoke the model at the Vertex AI endpoint
    via the `predict_custom_trained_model_sample()` function.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 突出了我们需要对 `show-prediction.html` 视图函数进行的更新。这些更改将输入值打包成 Vertex AI 端点部署所期望的格式，并通过
    `predict_custom_trained_model_sample()` 函数在 Vertex AI 端点调用模型。
- en: Listing 10.9 `show-prediction.html` view function for endpoints
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 `show-prediction.html` 端点视图函数
- en: '[PRE20]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Removes size_type from the feature list
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从特征列表中删除 size_type
- en: ② Converts the values in the scoring_dict to lists of values
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将 scoring_dict 中的值转换为值列表
- en: ③ Calls predict_custom_trained_model_sample
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 调用 predict_custom_trained_model_sample
- en: 'Listing 10.9 shows the following updates to the `show-prediction.html` view
    function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 显示了对 `show-prediction.html` 视图函数的以下更新：
- en: The call to the endpoint has to have the exact correct list of features and
    values, with no missing features or extra features. Since we don’t use `size_type`
    directly with the model, we need to explicitly remove it from the dictionary of
    features and values with the `scoring_dict.pop('size_type')` statement.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对端点的调用必须具有精确正确的特征和值列表，不能缺少特征或额外特征。由于我们不直接使用 `size_type` 与模型一起，我们需要使用 `scoring_dict.pop('size_type')`
    语句显式地从特征和值的字典中删除它。
- en: 'The endpoint expects to get the features and values in a dictionary with the
    same format as the JSON that we used to exercise the endpoint directly in the
    console in section 10.4.4\. That means the values in the dictionary need to be
    converted to lists of values, each of which contains exactly one value. This statement
    converts the dictionary to lists of values:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点期望以与我们在 10.4.4 节中直接在控制台练习端点所使用的 JSON 相同的格式从字典中获取特征和值。这意味着字典中的值需要转换为值列表，每个列表中恰好包含一个值。此语句将字典转换为值列表：
- en: '[PRE21]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `predict_custom_trained_model_sample()` function needs to be called with
    parameters specifying the project, endpoint, and key-value pairs for the features
    we want a prediction for.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predict_custom_trained_model_sample()` 函数需要使用指定项目、端点和我们想要预测的特征键值对的参数来调用。'
- en: In addition to these updates to the Flask server module, we can also remove
    the statements that loaded the model from the local file system since we don’t
    use the local model in this solution.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对 Flask 服务器模块的这些更新外，我们还可以删除从本地文件系统加载模型的语句，因为我们在这个解决方案中不使用本地模型。
- en: NOTE An updated version of the Flask server module that uses the endpoint is
    available at [https://mng.bz/Xx5a](https://mng.bz/Xx5a).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用端点的 Flask 服务器模块的更新版本可在 [https://mng.bz/Xx5a](https://mng.bz/Xx5a) 获取。
- en: 'To run this version of the Flask server module, follow these steps:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此版本的 Flask 服务器模块，请按照以下步骤操作：
- en: '1.  Authorize the account you used to access Google Cloud with this application
    by running the following command on the command line in the local system where
    you are running the Flask server module:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 通过在运行 Flask 服务器模块的本地系统上的命令行中运行以下命令，通过此应用程序授权您用于访问 Google Cloud 的账户：
- en: '[PRE22]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '2.  Start the Flask server module:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 启动 Flask 服务器模块：
- en: '[PRE23]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you get an error related to the protobuf (protocol buffer) level, try the
    following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到与 protobuf（协议缓冲区）级别相关的错误，请尝试以下命令：
- en: '[PRE24]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command adjusts the protobuf level to exactly what the endpoint requires.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将 protobuf 级别调整为端点所需的精确级别。
- en: 'NOTE You don’t need to know about the protobufs for the purposes of this application,
    but if you are curious, you can check out the documentation: [https://protobuf.dev/](https://protobuf.dev/).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本应用的目的上，您不需要了解protobufs，但如果您对此感兴趣，可以查看文档：[https://protobuf.dev/](https://protobuf.dev/).
- en: 3.  Once the Flask server module is running, go to `localhost:5000` in a browser
    to exercise the deployment.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 当Flask服务器模块运行时，在浏览器中转到`localhost:5000`以测试部署。
- en: 'Now we have seen two kinds of deployments of the model: a web deployment run
    entirely from a local system and a web deployment that uses the model served from
    a Vertex AI endpoint.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了模型的两种部署方式：一种是从本地系统完全运行的Web部署，另一种是使用从Vertex AI端点提供模型的Web部署。
- en: 10.5.3 Benefits of deploying a model to an endpoint
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.3 将模型部署到端点的益处
- en: 'If we get the same results from the model whether it is deployed in a simple
    web deployment or deployed to an endpoint, you may ask what the point is of deploying
    the model to an endpoint. There are a number of benefits that come from deploying
    to an endpoint:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型在简单的Web部署或部署到端点时得到相同的结果，您可能会问，将模型部署到端点有什么意义。将模型部署到端点可以带来许多好处：
- en: You can scale the endpoint instance to handle additional load.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以扩展端点实例以处理额外的负载。
- en: You can deploy multiple models to the same endpoint. Imagine a situation where
    you need to replace one model in production with another. If you deploy both models
    to the same endpoint, you can gradually adjust how much of the traffic goes to
    the new model without making any changes to the application and without causing
    jarring changes to the users of the application.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将多个模型部署到同一端点。想象一下这样一个场景，您需要用另一个模型替换生产环境中的一个模型。如果您将这两个模型部署到同一端点，您可以在不更改应用程序的情况下，逐渐调整流量分配到新模型的比例，而不会对应用程序的用户造成突兀的变化。
- en: You can deploy the same model to different endpoints, allowing you to optimize
    the machine resources. For example, if you have a production and a development
    environment, you can deploy the same model to two endpoints, with higher-spec
    machine resources for the production environment and cheaper machine resources
    for the development environment.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将相同的模型部署到不同的端点，从而优化机器资源。例如，如果您有一个生产和开发环境，您可以将相同的模型部署到两个端点，生产环境使用更高规格的机器资源，而开发环境使用更便宜的机器资源。
- en: With an endpoint, you can enable Vertex AI monitoring to detect skew (differences
    in the distribution between training data and the data seen applying the model
    in production) and drift (changes in the distribution of data seen by the model
    in production over time). Model monitoring can help to ensure that the model’s
    performance does not degrade over time and that changes in the data the model
    is being applied to in production do not occur unexpectedly. For more details
    on monitoring, see the documentation at [https://mng.bz/yWdd](https://mng.bz/yWdd).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用端点，您可以使用Vertex AI监控来检测偏差（训练数据与在生产中应用模型时看到的数据之间的分布差异）和漂移（模型在生产中看到的数据分布随时间的变化）。模型监控可以帮助确保模型的性能不会随时间下降，并且模型在生产中应用的数据的变化不会意外发生。有关监控的更多详细信息，请参阅[https://mng.bz/yWdd](https://mng.bz/yWdd)上的文档。
- en: Figure 10.36 shows examples of multiple models deployed to the same endpoint
    and one model deployed to multiple endpoints.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36显示了多个模型部署到同一端点和单个模型部署到多个端点的示例。
- en: 'In figure 10.36, there are two scenarios:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在图10.36中，有两种场景：
- en: '*Multiple models are deployed to the same endpoint*—Model A is the version
    currently in production, and Model B is the next level of the model that we want
    to introduce to production. By adjusting the values of X and Y, we can control
    the proportion of traffic that goes to each model, gradually increasing the proportion
    that goes to the new level of the model.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同一端点部署多个模型*——模型A是当前生产中的版本，模型B是我们希望引入生产的下一级模型。通过调整X和Y的值，我们可以控制流量分配到每个模型的比例，逐渐增加分配到新模型级别的比例。'
- en: '*Same model deployed to multiple endpoints*—Endpoint 1 has basic compute resources,
    and endpoint 2 has sufficient compute resources to handle our current production
    load. By doing this we can optimize the resource cost for the system to meet the
    needs of multiple groups of users.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同一模型部署到多个端点*——端点1具有基本的计算资源，端点2具有足够的计算资源来处理我们当前的生产负载。通过这种方式，我们可以优化系统的资源成本，以满足多组用户的需求。'
- en: '![](../Images/CH10_F36_Ryan2.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F36_Ryan2.png)'
- en: Figure 10.36 Relationship between models and endpoints
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.36 模型和端点之间的关系
- en: NOTE For more details on model deployment in Vertex AI, see the documentation
    at [https://mng.bz/MDlB](https://mng.bz/MDlB).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关 Vertex AI 中模型部署的更多详细信息，请参阅 [https://mng.bz/MDlB](https://mng.bz/MDlB)
    的文档。
- en: '10.6 Gemini for Google Cloud: Generative AI assistance in Google Cloud'
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 Gemini for Google Cloud：Google Cloud 中的生成式 AI 辅助
- en: 'As you worked through the steps in this chapter, you may have run into a roadblock
    or needed to clarify a question. To make progress, you may have referred to the
    documentation for Google Cloud, searched in Stack Overflow, or asked a colleague
    for help. In addition to these traditional sources of assistance, Google Cloud
    also includes an integrated, generative AI-driven source of assistance: Gemini
    for Google Cloud.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成本章步骤的过程中，你可能遇到了障碍或需要澄清问题。为了取得进展，你可能查阅了 Google Cloud 的文档，在 Stack Overflow
    中搜索，或向同事寻求帮助。除了这些传统的辅助来源外，Google Cloud 还包括一个集成、由生成式 AI 驱动的辅助来源：Gemini for Google
    Cloud。
- en: 'Gemini for Google Cloud is a set of generative AI capabilities for Google Cloud.
    Gemini for Google Workspace is a companion set of generative AI capabilities for
    Google Workspace (Google Docs, Sheets, Slides; see [https://workspace.google.com/solutions/ai/](https://workspace.google.com/solutions/ai/)).
    In this chapter and chapter 11, we’ll show how you can use generative AI via Gemini
    for Google Cloud to simplify the deployment of tabular data models and to automate
    some of scripting for machine learning pipelines. Gemini for Google Cloud provides
    a variety of capabilities, including the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Gemini for Google Cloud 是一套针对 Google Cloud 的生成式 AI 能力。Gemini for Google Workspace
    是一套针对 Google Workspace（Google Docs、Sheets、Slides）的配套生成式 AI 能力（参见 [https://workspace.google.com/solutions/ai/](https://workspace.google.com/solutions/ai/)）。在本章和第
    11 章中，我们将展示如何通过 Gemini for Google Cloud 使用生成式 AI 来简化表格数据模型的部署，并自动化机器学习管道的一些脚本。Gemini
    for Google Cloud 提供了各种能力，包括以下内容：
- en: Answering questions about Google Cloud
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回答有关 Google Cloud 的问题
- en: Generating code (including SQL and a variety of programming languages such as
    Python, Java, and JavaScript) from text
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文本生成代码（包括 SQL 和各种编程语言，如 Python、Java 和 JavaScript）
- en: Explaining code
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释代码
- en: 'NOTE See the Gemini for Google Cloud documentation for a more detailed overview
    of what Gemini for Google Cloud can do: [https://cloud.google.com/gemini/docs/overview](https://cloud.google.com/gemini/docs/overview).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关 Gemini for Google Cloud 的更详细概述，请参阅 Gemini for Google Cloud 文档：[https://cloud.google.com/gemini/docs/overview](https://cloud.google.com/gemini/docs/overview)。
- en: In this section, we’ll cover setting up Gemini for Google Cloud and using it
    to answer questions about Google Cloud. We’ll also discuss some of the actions
    we completed in this chapter to deploy our model in a Vertex AI endpoint. In chapter
    11, we’ll return to Gemini for Google Cloud to show how you can use it to generate
    and explain code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何设置 Gemini for Google Cloud 并使用它来回答有关 Google Cloud 的问题。我们还将讨论本章中完成的一些操作，以在
    Vertex AI 端点部署我们的模型。在第 11 章中，我们将回到 Gemini for Google Cloud，展示如何使用它来生成和解释代码。
- en: Google Cloud is not the only cloud platform that harnesses generative AI to
    make it easier to use the platform and to automate some steps in the development
    workflow. Copilot in Azure and Code Whisperer in AWS are generative AI-based features
    that each provide a subset of the benefits provided by Gemini for Google Cloud.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud 不是唯一利用生成式 AI 来简化平台使用并自动化开发工作流程中某些步骤的云平台。Azure 中的 Copilot 和 AWS
    中的 Code Whisperer 是基于生成式 AI 的功能，每个都提供了 Gemini for Google Cloud 提供的部分好处。
- en: 10.6.1 Setting up Gemini for Google Cloud
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.1 设置 Gemini for Google Cloud
- en: 'The following are instructions for setting up Gemini for Google Cloud:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为设置 Gemini for Google Cloud 提供的说明：
- en: 'Setting up Gemini for Google Cloud for a project: [https://cloud.google.com/gemini/docs/quickstart](https://cloud.google.com/gemini/docs/quickstart)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目设置 Gemini for Google Cloud：[https://cloud.google.com/gemini/docs/quickstart](https://cloud.google.com/gemini/docs/quickstart)
- en: 'Setting up Gemini Code Assist, the part of Gemini for Google Cloud that provides
    AI assistance for development, to be used in Cloud Shell Editor in Google Cloud:
    [https://mng.bz/avMm](https://mng.bz/avMm)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Gemini Code Assist，这是 Gemini for Google Cloud 中提供 AI 辅助开发的部分，用于 Google Cloud
    的 Cloud Shell 编辑器：[https://mng.bz/avMm](https://mng.bz/avMm)
- en: Once you have set up Gemini for Google Cloud for a project, you will see the
    Gemini for Google Cloud icon in the toolbar (see figure 10.37).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为项目设置了 Gemini for Google Cloud，你将在工具栏中看到 Gemini for Google Cloud 图标（参见图 10.37）。
- en: '![](../Images/CH10_F37_Ryan2.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F37_Ryan2.png)'
- en: Figure 10.37 Gemini for Google Cloud icon
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.37 Gemini for Google Cloud图标
- en: Now that we have done the basic setup for Gemini for Google Cloud, we’ll see
    how we can use it to get answers to questions about Google Cloud in the next section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了Gemini for Google Cloud的基本设置，我们将在下一节中看到如何使用它来回答关于Google Cloud的问题。
- en: 10.6.1  Using Gemini for Google Cloud to answer questions about Google Cloud
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.1 使用Gemini for Google Cloud回答关于Google Cloud的问题
- en: Gemini for Google Cloud manifests itself in various ways in Google Cloud, including
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Gemini for Google Cloud在Google Cloud中表现出多种方式，包括
- en: '*In a chat pane that’s available throughout Google Cloud*—Figure 10.38 shows
    the Gemini for the Google Cloud chat pane.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Google Cloud中可用的聊天面板中*——图10.38展示了Gemini for Google Cloud的聊天面板。'
- en: '![](../Images/CH10_F38_Ryan2.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F38_Ryan2.png)'
- en: Figure 10.38 Gemini for Google Cloud chat pane
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38 Gemini for Google Cloud聊天面板
- en: '*In a range of IDEs supported by Google Cloud, including VS Code, Cloud Workstations,
    and Cloud Shell Editor*—Figure 10.39 illustrates how Gemini for Google Cloud can
    generate a simple Python function from a comment in Cloud Shell Editor.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Google Cloud支持的多种IDE中，包括VS Code、Cloud Workstations和Cloud Shell Editor*——图10.39展示了Gemini
    for Google Cloud如何从Cloud Shell Editor中的注释生成一个简单的Python函数。'
- en: '![](../Images/CH10_F39_Ryan2.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F39_Ryan2.png)'
- en: Figure 10.39 Gemini for Google Cloud generating Python in Cloud Shell Editor
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.39 Gemini for Google Cloud在Cloud Shell Editor中生成Python
- en: '*In the query editors for Big Query and Spanner*—Figure 10.40 shows how Gemini
    for Google Cloud can generate SQL from a comment in the Spanner query editor.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Big Query和Spanner的查询编辑器中*——图10.40展示了Gemini for Google Cloud如何从Spanner查询编辑器中的注释生成SQL。'
- en: '![](../Images/CH10_F40_Ryan2.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F40_Ryan2.png)'
- en: Figure 10.40 Gemini for Google Cloud generating SQL in the query editor in Spanner
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.40 Gemini for Google Cloud在Spanner查询编辑器中生成SQL
- en: Now that we have reviewed examples of where Gemini for Google Cloud can be used,
    let’s examine the Gemini for Google Cloud chat pane more to see how it can be
    used to get answers to questions about Google Cloud. You can click on the Gemini
    icon (see figure 10.37) to open the Gemini for Google Cloud chat pane, as shown
    in figure 10.41.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了Gemini for Google Cloud的适用示例，接下来让我们更深入地考察Gemini for Google Cloud的聊天面板，看看它是如何被用来获取关于Google
    Cloud的问题答案。您可以通过点击Gemini图标（见图10.37）来打开Gemini for Google Cloud聊天面板，如图10.41所示。
- en: '![](../Images/CH10_F41_Ryan2.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F41_Ryan2.png)'
- en: Figure 10.41 Gemini for Google Cloud chat pane
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.41 Gemini for Google Cloud聊天面板
- en: Try out the Gemini for Google Cloud chat pane by entering an instruction prompt
    in the prompt field and clicking on the Send button, as shown in figure 10.42.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在提示字段中输入指令提示并点击发送按钮来尝试使用Gemini for Google Cloud聊天面板，如图10.42所示。
- en: '![](../Images/CH10_F42_Ryan2.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F42_Ryan2.png)'
- en: Figure 10.42 Gemini for Google Cloud chat pane Send button
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.42 Gemini for Google Cloud聊天面板发送按钮
- en: The Gemini for Google Cloud chat pane is available whenever you need it in Google
    Cloud, and you can use it to ask all kinds of questions about Google Cloud. For
    example, suppose we want to create a Cloud Storage bucket and we forgot the steps
    listed earlier in this chapter. Figure 10.43 shows the response given by Gemini
    for Google Cloud to the prompt “How to create a Google storage bucket.”
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Gemini for Google Cloud聊天面板在Google Cloud中随时可用，您可以使用它来提出关于Google Cloud的各种问题。例如，假设我们想要创建一个Cloud
    Storage存储桶，但我们忘记了本章前面列出的步骤。图10.43显示了Gemini for Google Cloud对提示“如何创建Google存储桶”的响应。
- en: '![](../Images/CH10_F43_Ryan2.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F43_Ryan2.png)'
- en: Figure 10.43 Gemini for Google Cloud response to “how to create a Google Cloud
    storage bucket”
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.43 Gemini for Google Cloud对“如何创建Google Cloud存储桶”的响应
- en: Gemini for Google Cloud has been trained specifically to provide useful answers
    to questions about using Google Cloud. Try out Gemini for Google Cloud by giving
    it prompts related to some of the sections in this chapter. For example, try “how
    to import a custom model into Vertex AI” or “how to deploy a model to a Vertex
    AI endpoint” and see how the responses from Gemini for Google Cloud compare to
    the steps listed in the analogous sections in this chapter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Gemini for Google Cloud专门训练以提供关于使用Google Cloud的有用答案。通过给出与本章某些部分相关的提示来尝试使用Gemini
    for Google Cloud。例如，尝试“如何将自定义模型导入Vertex AI”或“如何将模型部署到Vertex AI端点”，并查看Gemini for
    Google Cloud的响应与本章类似部分中列出的步骤有何不同。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Deploying your model in a simple web application can give you a sense of its
    characteristics in production.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在简单的Web应用程序中部署您的模型可以给您一个关于其在生产中的特性的感觉。
- en: We can create a simple web application to deploy the model we trained in chapter
    9\. This application includes a Flask server module and two simple web pages.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个简单的Web应用程序来部署我们在第9章训练的模型。这个应用程序包括一个Flask服务器模块和两个简单的网页。
- en: A public cloud environment provides an environment for deploying a model that
    allows you to scale capacity and control availability.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共云环境提供了一个部署模型的环境，允许你扩展容量并控制可用性。
- en: To prepare to deploy the model we trained in chapter 9 in Google Cloud, we need
    to create a Google Cloud project, create a Google Cloud bucket, and upload the
    model to the bucket.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在Google Cloud中部署我们在第9章训练的模型，我们需要创建一个Google Cloud项目，创建一个Google Cloud存储桶，并将模型上传到存储桶中。
- en: Once we have completed the steps to prepare for a Google Cloud model deployment,
    we can deploy a trained model to a Vertex AI endpoint.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们完成了准备Google Cloud模型部署的步骤，我们就可以将训练好的模型部署到Vertex AI端点。
- en: We can test the Vertex AI endpoint deployment of the model by making a few simple
    updates to the Flask module from the web application that we created at the beginning
    of this chapter.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过对我们在本章开头创建的Web应用程序中的Flask模块进行一些简单的更新来测试模型的Vertex AI端点部署。
- en: Deploying a model to an endpoint in Vertex AI makes the deployment more robust.
    In particular, we can specify the machine resources that are appropriate for our
    application, provide a mix of model levels, and monitor the model’s performance
    in production.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型部署到Vertex AI的端点使部署更加稳健。特别是，我们可以指定适合我们应用程序的机器资源，提供不同级别的模型组合，并监控模型在生产中的性能。
- en: Gemini for Google Cloud provides generative AI capabilities that can be helpful
    for model development and deployment tasks in Google Cloud.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gemini for Google Cloud提供了生成式AI能力，这些能力对于在Google Cloud中的模型开发和部署任务非常有帮助。
