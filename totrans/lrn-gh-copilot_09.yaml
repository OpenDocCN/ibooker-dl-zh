- en: Chapter 8\. Other Ways to Leverage Copilot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章\. 利用 Copilot 的其他方法
- en: As we’ve seen, Copilot provides a lot of value for working with traditional
    coding flows as well as traditional tasks like testing and documentation. Copilot
    can also help in many less common use cases encountered by programmers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Copilot 在处理传统编码流程以及传统任务（如测试和文档）方面提供了很多价值。Copilot 还可以帮助程序员遇到的一些不太常见的用例。
- en: We can’t cover all those use cases in this chapter or even in this book, but
    we can cover some representative examples. As a heads-up, the structure of this
    chapter is different from that of the other chapters. We’ll be covering multiple,
    diverse use cases rather than focusing on one overall feature or functional area.
    The examples we’ll look at are outlined in the next few paragraphs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在本章或本书中涵盖所有这些用例，但我们可以涵盖一些代表性的例子。作为提示，本章的结构与其他章节不同。我们将涵盖多个、多样化的用例，而不是专注于一个整体功能或功能区域。我们将探讨的例子将在接下来的几段中概述。
- en: You may primarily think of using GitHub Copilot for coding in popular languages
    like JavaScript and Python. However, Copilot has access to all the languages that
    the model you’re using was trained on. So, you can also use it on ones that we
    don’t think of as traditional programming languages. An example is one we’ve touched
    on before—SQL—commonly used to work with relational databases. Copilot can simplify
    a surprising number of database-related tasks when you’re working with queries,
    schemas, and stored procedures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能主要会想到使用 GitHub Copilot 来编写 JavaScript 和 Python 等流行语言的代码。然而，Copilot 可以访问你使用的模型训练时所涉及的所有语言。因此，你还可以将其用于我们通常不认为是传统编程语言的语言。一个例子是我们之前提到过的——SQL，通常用于与关系型数据库一起工作。当你在处理查询、模式和存储过程时，Copilot
    可以简化大量数据库相关任务。
- en: Frameworks, such as Kubernetes, also make use of an ordered format (most commonly
    expressed in YAML). While these frameworks are declarative rather than imperative,
    their syntax and structure are understood by Copilot. It can provide completion
    suggestions and answers about how to work with them, just as for any programming
    language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 框架，如 Kubernetes，也使用有序格式（通常用 YAML 表达）。虽然这些框架是声明性的而不是命令性的，但它们的语法和结构被 Copilot 所理解。它可以提供完成建议和关于如何使用它们的答案，就像对任何编程语言一样。
- en: Then there are regular expressions—those often complex and cryptic strings of
    characters. When you need one, they are important to get correct but usually frustrating
    to try to create. Copilot can make easy work of these.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是正则表达式——那些通常复杂且晦涩的字符字符串。当你需要它们时，它们对于正确获取很重要，但通常尝试创建它们会令人沮丧。Copilot 可以轻松处理这些。
- en: For testing a regular expression or unit-testing a function, you may also need
    structured test data. With specific prompting, Copilot can generate nearly any
    simple data structures needed, although there are a few nuances to be aware of.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试正则表达式或单元测试一个函数，你可能还需要结构化测试数据。通过特定的提示，Copilot 可以生成几乎所有所需的简单数据结构，尽管有一些需要注意的细微差别。
- en: Finally, it’s worth noting that some Copilot functionality is embedded in the
    GitHub CLI application. While this is currently limited, it’s reasonable to expect
    more functionality to be added over time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，一些 Copilot 功能已嵌入到 GitHub CLI 应用程序中。虽然目前功能有限，但合理预期未来会逐渐增加更多功能。
- en: We’ll cover all of these in this chapter, starting with how Copilot can be used
    when you’re working with SQL.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖所有这些内容，从 Copilot 在处理 SQL 时如何使用开始。
- en: Using Copilot with SQL
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Copilot 与 SQL
- en: While technically a programming language, SQL brings its own unique constructs
    to data management. These include the standard queries used with the data and
    schema in the database, indices for efficiencies, and stored procedures for more
    complex tasks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上是一种编程语言，但 SQL 为数据管理带来了自己独特的结构。这包括在数据库中使用的数据和模式的标准查询、用于效率的索引以及用于更复杂任务的存储过程。
- en: 'In this section, we’ll look at three areas where Copilot can help:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Copilot 可以帮助的三个领域：
- en: Using Copilot to help with queries
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Copilot 帮助查询
- en: Working with stored procedures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与存储过程一起工作
- en: Performing optimization
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行优化
- en: Let’s start by looking at the basic ways that Copilot can assist with generating
    SQL-related queries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 Copilot 在生成与 SQL 相关查询方面的基本辅助方式。
- en: Queries
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询
- en: As you know, Copilot draws from local content to get context. So if you are
    working in your editor and open a file with an extension of *.sql* or that contains
    SQL statements, Copilot can pick up on that to know that it needs to generate
    SQL. You can also use comments to help clue Copilot in further on what you want.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Copilot从本地内容中获取上下文。所以如果你在编辑器中工作并打开一个扩展名为*.sql*或包含SQL语句的文件，Copilot可以捕捉到这一点，知道它需要生成SQL。你还可以使用注释来进一步帮助Copilot了解你的需求。
- en: '[Chapter 7](ch07.html#ch07) showed an example of how to add context to make
    code generation and suggestions more relevant. There we used the technique of
    opening up an SQL file that had all the database schema definitions for a university
    student and course registration system to give Copilot more context for generating
    queries.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html#ch07)展示了如何添加上下文以使代码生成和建议更相关。在那里，我们使用了打开包含大学学生和课程注册系统所有数据库模式定义的SQL文件的技术，为Copilot提供更多生成查询的上下文。'
- en: 'You can refer back to [“Adding Context to Make Code More Relevant”](ch07.html#addingContextCh7)
    if you need a reminder, but we’ll assume the same setup here. Here is a partial
    schema definition underlying the registration system:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要提醒，可以参考[“添加上下文以使代码更相关”](ch07.html#addingContextCh7)，但我们将假设这里相同的设置。以下是注册系统下方的部分模式定义：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we open this up in the editor where we are working on our queries and then
    prompt Copilot via a comment to generate an SQL query to get all students enrolled
    in a course, we get a detailed result with table names, field names, etc. that
    match the schema:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在编写查询的编辑器中打开它，然后通过注释提示Copilot生成一个获取所有课程注册学生的SQL查询，我们会得到一个详细的结果，其中包含与模式匹配的表名、字段名等：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By simply having the other file open in the workspace, Copilot was able to draw
    on that content to create a better query for us.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地在工作区中打开另一个文件，Copilot能够利用该内容为我们创建更好的查询。
- en: Save Your Work
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存你的工作
- en: Remember to first save any new files as part of the project that you want Copilot
    to be able to use in context.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记得首先保存任何新的文件作为项目的一部分，这样Copilot才能在上下文中使用。
- en: 'As another example, we could ask Copilot to create a table for student attendance
    to capture attendance by class. Given the same context of the larger schema table,
    Copilot should respond with a complete table definition:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，我们可以要求Copilot创建一个用于记录学生出勤的表格。考虑到更大的模式表上下文，Copilot应该响应一个完整的表定义：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The format of this table is similar to the format used in the schema file for
    the *courses.registration* table, as shown next. Notice that both table definitions
    use status values of 1–4:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格的格式与用于*courses.registration*表的模式文件中使用的格式相似，如下所示。注意，两个表定义都使用了1-4的状态值：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can also have Copilot generate more complex types of SQL data like stored
    procedures.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以让Copilot生成更复杂的SQL数据类型，如存储过程。
- en: Stored Procedures
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储过程
- en: A *stored procedure* is prepared SQL code that is saved and can be reused easily.
    Copilot can help us generate these as well. Continuing with our university registration
    example, let’s ask Copilot to create a new stored procedure for getting a list
    of enrolled students at a particular location. We can use a simple prompt in chat
    (similar to the comment form we used earlier) to tell Copilot what we want. The
    prompt is “define a stored procedure to get course enrollment by location.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*存储过程*是保存的SQL代码，可以轻松重用。Copilot也可以帮助我们生成这些。继续我们的大学注册示例，让我们要求Copilot创建一个新的存储过程，用于获取特定位置的已注册学生列表。我们可以使用简单的聊天提示（类似于我们之前使用的注释表单）告诉Copilot我们想要什么。提示是“定义一个存储过程以通过位置获取课程注册信息。”'
- en: 'With this prompt and the additional context of the schemas, Copilot produces
    a reasonable result:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个提示以及额外的模式上下文，Copilot产生了一个合理的结果：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also be more directive. The more prescriptive we are with the prompt,
    the more likely that Copilot will generate better results. For example, consider
    the following very specific prompt in the chat interface:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更加明确。提示越具体，Copilot生成更好的结果的可能性就越大。例如，考虑以下在聊天界面中非常具体的提示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Copilot first explained its thinking in terms of a plan and then generated
    the detailed code to match the prompt:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot首先用计划的形式解释了它的思考过程，然后生成了与提示相匹配的详细代码：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While it’s helpful to have Copilot generating queries and stored procedures
    for us, that’s not its only SQL skill. The AI can also help optimize what we create.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Copilot为我们生成查询和存储过程很有帮助，但这不是它的唯一SQL技能。AI还可以帮助我们优化我们创建的内容。
- en: Optimizations
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: Copilot can make the code we have more efficient and can do so in two main ways.
    The first is by writing code leveraging built-in constructs that the language
    or framework provides for optimization. The second is by optimizing existing code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot可以使我们现有的代码更加高效，并且可以通过两种主要方式实现。第一种是通过编写利用语言或框架提供的内置结构进行优化的代码。第二种是优化现有代码。
- en: 'As an example of the first case, SQL provides indexes to speed up operations.
    Refer back to the query we worked with earlier in this chapter to get all students
    enrolled in a course. The complete query is listed here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个案例的例子，SQL提供了索引来加速操作。回顾一下本章前面我们用来获取所有课程注册学生的查询。完整的查询如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For this query, we can use a separate index to speed up operations. We ask
    Copilot to create a new index based on this query with the prompt “-- write an
    index to improve the performance of the query.” From this prompt, Copilot might
    suggest SQL like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个查询，我们可以使用一个单独的索引来加速操作。我们提示Copilot根据这个查询创建一个新的索引，提示内容为“--写一个索引来提高查询的性能。”从这个提示中，Copilot可能会建议如下SQL：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with the original query, Copilot was able to draw on the context of available
    code to create an index that uses the existing field names, table names, etc.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始查询一样，Copilot能够利用现有代码的上下文来创建一个使用现有字段名、表名等的索引。
- en: 'In addition to creating code to help optimize execution, Copilot can optimize
    static code. This is the second use case mentioned at the start of this section.
    Suppose we have a query to get all the course registrations for September 2024\.
    It might look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建帮助优化执行的代码之外，Copilot还可以优化静态代码。这是本节开头提到的第二个用例。假设我们有一个查询，用于获取2024年9月的所有课程注册信息。它可能看起来像这样：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can select this query and then prompt Copilot to optimize it via the prompt
    “optimize this query.”
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择这个查询，然后通过提示“优化这个查询”来提示Copilot进行优化。
- en: 'The AI then suggests an optimization that uses direct starting and ending dates
    instead:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，AI建议使用直接开始和结束日期的优化方案：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the same output, Copilot also provides additional background on *why* this
    is an improvement:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的输出中，Copilot还提供了关于*为什么*这是一个改进的额外背景信息：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Copilot not only suggested an optimization but also told us why and under what
    conditions this would actually be an optimization. Nice.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot不仅建议了优化方案，还告诉我们为什么以及在什么条件下这实际上是一个优化。很好。
- en: Now that you’ve seen how Copilot works with managing coding for databases, let’s
    look at how it handles a framework by using declarative specifications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了Copilot如何与数据库编码管理协同工作，让我们看看它是如何通过声明性规范来处理框架的。
- en: Working with YAML and Kubernetes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与YAML和Kubernetes协同工作
- en: YAML is a critical formatting language for many applications today. It can also
    be painful to work with because of its syntax and strict formatting requirements.
    But the ability to create specifications and configurations is key for applications
    like Kubernetes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: YAML是许多应用程序今天的关键格式化语言。由于其语法和严格的格式要求，它也可能难以处理。但创建规范和配置的能力对于像Kubernetes这样的应用程序至关重要。
- en: Kubernetes itself can also be challenging to work with for multiple reasons.
    These include learning and remembering how to define objects you want in YAML
    files. Each native object has a common set of attributes, but then each also has
    its own specification (spec). The challenges can multiply when trying to scale
    objects for a service or product. Since any error or incorrect formatting can
    cause your app not to function, we can leverage AI to good effect here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes本身也可能因为多个原因而难以协同工作。这包括学习和记住如何在YAML文件中定义你想要的对象。每个原生对象都有一个共同的属性集，但每个对象也有自己的规范（spec）。当尝试为服务或产品扩展对象时，挑战可能会成倍增加。由于任何错误或不正确的格式都可能使你的应用程序无法运行，我们可以利用AI在这里发挥积极作用。
- en: Suppose we want to code up a new deployment in Kubernetes. A *deployment* is
    a type of object in Kubernetes that instantiates and manages multiple instances
    of a Kubernetes *pod.* The pod, in turn, wraps one or more containers. The containers
    are based on images and provide a self-contained environment for an app to execute
    in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在Kubernetes中编写一个新的部署。在Kubernetes中，*部署*是一种对象类型，它实例化和管理Kubernetes *pod*的多个实例。pod反过来又封装了一个或多个容器。这些容器基于镜像，为应用程序提供一个自包含的环境来执行。
- en: 'Armed with basic knowledge of the parts, we can prompt Copilot to produce a
    YAML spec for a deployment via the chat interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了基本知识的基础上，我们可以通过聊天界面提示Copilot生成一个部署的YAML规范：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After a few moments, Copilot will suggest something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，Copilot 会建议如下：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you don’t know Kubernetes, this is valid syntax and mirrors what we would
    expect to have as a deployment spec. Notice that no personal knowledge of the
    Kubernetes syntax was needed to generate this other than the type of objects that
    should be in the spec. We can save this file as *deployment.yaml* and move on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道 Kubernetes，这是一个有效的语法，与我们预期的部署规范相匹配。请注意，除了应该包含在规范中的对象类型之外，生成此规范不需要任何关于
    Kubernetes 语法的个人知识。我们可以将此文件保存为 *deployment.yaml* 并继续。
- en: Now that we have this spec, we will want to execute it at some point. If we’re
    not clear on the process for that, we can ping Copilot about it. We simply go
    to the chat interface and ask, “How do I execute this?” As shown in [Figure 8-1](#copilot-explains-how),
    Copilot references the *deployment.yaml* file we created and then provides instructions
    to get it into the Kubernetes cluster (a system of machines for running Kubernetes)
    and verify that the deployment is running. It does this using the Kubernetes CLI
    called `kubectl`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个规范，我们将在某个时候执行它。如果我们不清楚执行过程，我们可以 ping Copilot 来询问。我们只需进入聊天界面，问“我该如何执行这个？”如图
    8-1 所示，Copilot 引用了我们创建的 *deployment.yaml* 文件，然后提供将文件放入 Kubernetes 集群（运行 Kubernetes
    的机器系统）并验证部署正在运行的说明。它是通过 Kubernetes CLI（称为 `kubectl`）来做的。
- en: '![](assets/lghc_0801.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0801.png)'
- en: Figure 8-1\. Copilot explains how to apply the spec to Kubernetes for execution
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. Copilot 解释如何将规范应用到 Kubernetes 以执行
- en: This is very helpful, but what if at some point we need to move to managing
    this Kubernetes deployment via the Kubernetes API instead of the CLI? And we’d
    also like to do it using Python and be able to change (scale) the number of instances
    of the container it’s running.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有帮助，但如果我们需要在某个时候通过 Kubernetes API 而不是 CLI 来管理这个 Kubernetes 部署，我们会怎么做？我们还希望使用
    Python 并能够更改（扩展）运行的容器实例数量。
- en: 'We can query Copilot about this through another simple natural language prompt
    in chat:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过聊天中的另一个简单的自然语言提示来查询 Copilot：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Copilot first tells us that we can do this using the Kubernetes Python client
    library and then dumps out the Python code for the task ([Figure 8-2](#copilots-response-to)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 首先告诉我们可以使用 Kubernetes Python 客户端库来完成这项任务，然后输出该任务的 Python 代码（[图 8-2](#copilots-response-to)）。
- en: '![](assets/lghc_0802.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0802.png)'
- en: Figure 8-2\. Copilot’s response to manage Kubernetes in Python
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. Copilot 对 Python 中管理 Kubernetes 的响应
- en: Beyond this, Copilot provides a helpful explanation of the steps needed to run
    the code ([Figure 8-3](#steps-for-execution)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Copilot 提供了运行代码所需步骤的详细解释（[图 8-3](#steps-for-execution)）。
- en: '![](assets/lghc_0803.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0803.png)'
- en: Figure 8-3\. Steps for execution
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. 执行步骤
- en: We can then save the suggested code as a new file in the editor and proceed
    with any edits we want to make, testing the code, etc.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将建议的代码保存为编辑器中的新文件，并进行任何我们想要的编辑，测试代码等。
- en: Let’s throw one more challenge at Copilot. The more common programming language
    for Kubernetes is Go. So, if we want to migrate this Python code to Go, can Copilot
    help? As it turns out, it can! And it’s very simple to do. With the Python code
    selected (and therefore referenced), all we need to do is tell Copilot to “Convert
    to Go.” Copilot then produces the equivalent pieces for Go code in the chat interface
    ([Figure 8-4](#code-for-kubernetes-d)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再给 Copilot 一个挑战。Kubernetes 更常见的编程语言是 Go。所以，如果我们想将此 Python 代码迁移到 Go，Copilot
    能帮忙吗？结果证明，它可以！而且非常简单。在选择了 Python 代码（因此引用了它）之后，我们只需要告诉 Copilot “转换为 Go。”然后 Copilot
    就会在聊天界面中生成 Go 代码的等效部分（[图 8-4](#code-for-kubernetes-d)）。
- en: '![](assets/lghc_0804.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0804.png)'
- en: Figure 8-4\. Code for Kubernetes deployment in Go
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. Kubernetes 部署的 Go 代码
- en: Copilot also provides a corresponding explanation and instructions on execution
    as it did for the Python version ([Figure 8-5](#steps-to-execute-go-c)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 也提供了与 Python 版本相同的相应解释和执行说明（[图 8-5](#steps-to-execute-go-c)）。
- en: '![](assets/lghc_0805.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0805.png)'
- en: Figure 8-5\. Steps to execute Go code
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-5\. 执行 Go 代码的步骤
- en: Yet again, we see an example of how Copilot can automate and simplify creating
    processing for complex tasks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们看到 Copilot 如何自动化并简化复杂任务的创建过程。
- en: Another often complex task that Copilot can greatly simplify is creating regular
    expressions. That’s the topic of our next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 可以极大地简化另一个经常复杂的任务，那就是创建正则表达式。这就是我们下一节的主题。
- en: Generating Regular Expressions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成正则表达式
- en: Most developers are not a fan of having to come up with the syntax for regular
    expressions. The process of trying to find a combination of letters, numbers,
    and symbols to effectively match a set of strings can be time consuming and frustrating.
    Add to that the need to devise tests that comprehensively test out the expression,
    and it becomes preferable to try to find something that matches closely from other
    code or from a resource like Stack Overflow.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者都不喜欢自己想出正则表达式的语法。尝试找到一组字母、数字和符号的组合以有效地匹配一组字符串的过程可能既耗时又令人沮丧。再加上需要设计全面测试表达式的测试，因此尝试从其他代码或像Stack
    Overflow这样的资源中找到与之匹配的东西变得更有吸引力。
- en: 'However, this is yet another area where Copilot shines. Given a suitable prompt,
    Copilot can easily create a corresponding regular expression. For example, suppose
    we tell Copilot to “Create a regular expression to validate a SSN” (where *SSN*
    stands for a *US Social Security number*). Copilot responds with the following
    implementation suggestion and explanation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这又是Copilot表现出色的领域之一。给定一个合适的提示，Copilot可以轻松地创建相应的正则表达式。例如，假设我们告诉Copilot“创建一个用于验证SSN的正则表达式”（其中*SSN*代表*美国社会安全号码*）。Copilot随后给出了以下实现建议和解释：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We may also want to generate a function that uses a regular expression for whatever
    language we’re coding in. Assume that we have a JavaScript file (*phone.js*),
    and we want a function in it to validate any global phone number.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想要生成一个函数，该函数使用我们正在编写的任何语言的正则表达式。假设我们有一个JavaScript文件（*phone.js*），我们想要在其中添加一个函数来验证任何全球电话号码。
- en: 'We can prompt Copilot with “create a function to validate any global phone
    number using a regular expression.” Copilot, in turn will produce JavaScript code
    like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用“创建一个使用正则表达式验证任何全球电话号码的函数”来提示Copilot。反过来，Copilot将生成如下JavaScript代码：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that while the code is short, the regular expression is not simple. And
    Copilot also provided example calls to use to validate the function. If the use
    cases in the examples don’t match what you were intending, you could reject the
    suggestion and use a more detailed prompt to get what you need.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然代码很短，但正则表达式并不简单。而且Copilot还提供了用于验证函数的示例调用。如果示例中的用例不符合你的意图，你可以拒绝建议，并使用更详细的提示来获取你需要的内容。
- en: After generating a regular expression, you may want some simple data to use
    for testing it, or you might need some data to do basic testing on some other
    part of your code. Rather than having to find or create this kind of data yourself,
    you can create it automatically with Copilot.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成正则表达式后，你可能想要一些简单的数据来测试它，或者你可能需要一些数据来对代码的其他部分进行基本测试。而不是自己寻找或创建这类数据，你可以使用Copilot自动创建。
- en: Automatic Data Generation
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动数据生成
- en: Another area where Copilot can come to the rescue for helping with boilerplate
    tasks is generating data and data mappings for validating coding approaches and
    testing after the coding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Copilot可以帮助处理模板化任务的领域是生成数据和数据映射，用于验证编码方法和编码后的测试。
- en: 'The approach here is the same: to use a well-defined prompt to achieve the
    desired results. Suppose we want some test data to verify a function that looks
    up area codes for a given state. We can direct Copilot to “Create a mapping of
    all 50 states to area codes where the key is the state abbreviation and the value
    is an array of codes with max 10.”'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的方法是相同的：使用一个定义良好的提示来实现预期的结果。假设我们想要一些测试数据来验证一个查找给定州区号的函数。我们可以指示Copilot“创建一个映射，将所有50个州映射到区号，其中键是州缩写，值是包含最多10个代码的数组。”
- en: Notice that we were specific about what the keys and corresponding values should
    be for the mapping. Copilot responds with the requested data ([Figure 8-6](#generated-data)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们对映射中键和对应值应该是什么有明确的要求。Copilot回应了所需的数据（[图8-6](#generated-data)）。
- en: '![](assets/lghc_0806.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0806.png)'
- en: Figure 8-6\. Generated data
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-6\. 生成的数据
- en: Sometimes Copilot may include a disclaimer about the accuracy of the generated
    data. A disclaimer for this data would note that the area codes are placeholders
    and not guaranteed to be the actual area codes for each state. Repeating a point
    we made in [Chapter 7](ch07.html#ch07), Copilot is working only from the data
    it was trained on. It is not going out and checking to ensure that the data it
    returns is correct or up-to-date. You must always remember to cross-check results
    if you need accurate, timely data. You cannot assume that the values provided
    through Copilot are current and correct.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 Copilot 可能会包含关于生成数据准确性的免责声明。对于这些数据，免责声明会指出区号是占位符，并不保证是每个州的实际区号。重复我们在 [第 7
    章](ch07.html#ch07) 中提到的观点，Copilot 只是从它训练的数据中工作的。它不会出去检查以确保它返回的数据是正确或最新的。你必须始终记住，如果你需要准确、及时的数据，你必须交叉检查结果。你不能假设通过
    Copilot 提供的值是当前和正确的。
- en: When you ask Copilot to generate data in this way, you may occasionally encounter
    two other types of issues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式要求 Copilot 生成数据时，你可能会偶尔遇到两种其他类型的问题。
- en: 'First, depending on the prompt and amount of data you request, Copilot might
    return only a portion of the data. This will usually be enough to get you started
    but not a complete set. For example, if the query left out the *all 50* part and
    was just “Create a mapping of states to area codes where the key is the state
    abbreviation and the value is an array of codes with max 10,” Copilot might return
    only a few records:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，根据提示和数据请求的数量，Copilot 可能只会返回部分数据。这通常足以让你开始，但不是完整的数据集。例如，如果查询省略了 *所有 50 个*
    部分，只是“创建一个将州映射到区号的映射，其中键是州缩写，值是包含最多 10 个代码的数组”，Copilot 可能只会返回几条记录：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you encounter a situation like this, you can prompt Copilot to generate the
    rest of the data via a prompt like “Create a mapping of the remaining states to
    area codes where the key is the state abbreviation and the value is an array of
    area codes with max 10.” We added the term *remaining* to tell Copilot to pick
    up where it left off.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到这种情况，你可以通过类似“创建一个将剩余状态映射到区号的映射，其中键是州缩写，值是包含最多 10 个区号的数组”的提示来提示 Copilot 生成剩余数据。我们添加了术语
    *remaining* 来告诉 Copilot 从它上次停止的地方继续。
- en: Second, when having Copilot generate data, you may be notified that the generated
    data matches data in a public repository. If you have the setting enabled to block
    generated code that matches public code, Copilot’s complete response to your prompt
    will be blocked.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，当使用 Copilot 生成数据时，你可能会收到通知，表示生成的数据与公共存储库中的数据匹配。如果你启用了阻止与公共代码匹配的生成代码的设置，Copilot
    对你的提示的完整响应将被阻止。
- en: In general, data such as this is less likely to be proprietary. If there is
    not a concern about license violations, you can usually tweak your prompt to have
    the AI generate the data with a different dimension. It may be as easy as changing
    the amount of data requested, as in “create a mapping of the states to area codes
    where the key is the state abbreviation and the value is an array of area codes
    with max 5.” Note the change in the max value from 10 to 5.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，此类数据不太可能是专有的。如果没有关于许可违规的担忧，你通常可以调整你的提示，让 AI 以不同的维度生成数据。这可能就像更改请求的数据量一样简单，例如，“创建一个将州映射到区号的映射，其中键是州缩写，值是包含最多
    5 个区号的数组”。注意最大值的从 10 变为 5。
- en: Finally, let’s look at one other way you can interact with Copilot. While not
    as common as the other interfaces we’ve discussed, the GitHub command line can
    also leverage Copilot to help you understand and generate answers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看另一种你可以与 Copilot 交互的方式。虽然不如我们讨论的其他接口常见，但 GitHub 命令行也可以利用 Copilot 来帮助你理解和生成答案。
- en: GitHub CLI and Copilot
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub CLI 和 Copilot
- en: If you use the GitHub CLI, you can use a couple of subcommands with Copilot.
    At the time of this writing, there are four.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 GitHub CLI，你可以使用一些与 Copilot 一起使用的子命令。在撰写本文时，有四个。
- en: 'Before being able to use Copilot with the GitHub CLI, some basic prerequisites
    have to be met:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够使用 GitHub CLI 与 Copilot 一起使用之前，必须满足一些基本前提条件：
- en: The GitHub CLI has to be installed.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub CLI 必须安装。
- en: You must have authenticated to GitHub, such as through the `gh auth` command.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须通过 `gh auth` 命令等方式在 GitHub 上进行身份验证。
- en: The Copilot extension must be installed in the GitHub CLI via the `gh extension
    install github/gh-copilot` command.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须通过 `gh extension install github/gh-copilot` 命令在 GitHub CLI 中安装 Copilot 扩展。
- en: After going through the prerequisites, the CLI commands listed in [Table 8-1](#copilot-commands-thro)
    will be available to you. The table also shows the purpose of each command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成先决条件后，您将可以使用[表8-1](#copilot-commands-thro)中列出的CLI命令。该表还显示了每个命令的目的。
- en: Table 8-1\. Copilot commands through the GitHub CLI
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1\. 通过GitHub CLI的Copilot命令
- en: '| Command | Function |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 功能 |'
- en: '| --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `alias` | Generate shell-specific aliases for convenience |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `alias` | 生成特定于shell的别名以方便使用 |'
- en: '| `config` | Configure options |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `config` | 配置选项 |'
- en: '| `explain` | Explain a command |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `explain` | 解释一个命令 |'
- en: '| `suggest` | Suggest a command |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `suggest` | 建议一个命令 |'
- en: 'As an example of using the CLI with Copilot, we can ask it to explain a Unix
    command via a simple invocation of the GitHub CLI like `gh copilot explain "ps
    -aux"`. The output is shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用CLI与Copilot的示例，我们可以通过简单的GitHub CLI调用（如`gh copilot explain "ps -aux"`）来要求它解释一个Unix命令。输出如下所示：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In some cases, you may be asked to select additional options as a follow-up.
    For example, if you ask Copilot via the CLI to suggest a command to install Python,
    there can be additional queries from the AI to make sure it provides you with
    the best response. Here’s the output and interactions based on an initial command
    of `gh copilot suggest "install python"`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要选择额外的选项作为后续操作。例如，如果您通过CLI要求Copilot建议一个安装Python的命令，AI可能会有额外的查询以确保它提供最佳响应。以下是基于初始命令`gh
    copilot suggest "install python"`的输出和交互：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice after the original command, there were several follow-up interactions
    with Copilot. We were given the option to select the context for the command (generic
    shell, CLI, or Git). Once we selected the shell command, Copilot provided the
    suggestion. We were then given the option to copy the command, have Copilot explain
    it, execute it, etc. Selecting the `explain` option provides an explanation like
    the one in the previous example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在原始命令之后，我们与Copilot进行了几次后续交互。我们被赋予了选择命令上下文（通用shell、CLI或Git）的选项。一旦我们选择了shell命令，Copilot就会提供建议。然后我们可以选择复制命令、让Copilot解释它、执行它等。选择`explain`选项会提供类似于上一个示例的解释。
- en: Conclusion
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we looked at a set of areas where AI assistance may not be
    the first option that comes to mind but can prove helpful. Copilot’s capabilities
    can be put to good use in each of these areas.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了一系列领域，在这些领域中，人工智能辅助可能不是首先想到的选项，但可以证明是有帮助的。Copilot的功能可以在这些领域的每个方面得到良好利用。
- en: When you need to interact with databases, Copilot can provide code-completion
    suggestions and generate full sets of code for SQL just as for more typical programming
    languages. Copilot can be especially helpful for creating stored procedures and
    optimizing programming.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要与数据库交互时，Copilot可以提供代码补全建议，并为SQL生成完整的代码集，就像为更典型的编程语言一样。Copilot在创建存储过程和优化编程方面尤其有帮助。
- en: Besides generating traditional code that tells the system how to do something,
    Copilot can also be used to generate declarative specifications that outline the
    desired end result. A good example of this is using Copilot to help declare Kubernetes
    specifications. Given a suitable prompt, Copilot can generate the YAML definition
    for any of the standard Kubernetes objects. In addition, Copilot can tell the
    user how to use the specification with Kubernetes and even turn it into code with
    API calls. This kind of help greatly simplifies working with the complexities
    of different frameworks and their representations in YAML.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成传统的代码，告诉系统如何做某事之外，Copilot还可以用来生成声明性规范，概述所需的最终结果。一个很好的例子是使用Copilot帮助声明Kubernetes规范。给定一个合适的提示，Copilot可以为任何标准Kubernetes对象生成YAML定义。此外，Copilot还可以告诉用户如何使用规范与Kubernetes一起使用，甚至将其转换为带有API调用的代码。这种帮助极大地简化了与不同框架及其在YAML中的表示的复杂性。
- en: 'Copilot’s capabilities can also automate another task that frequently frustrates
    developers: creating regular expressions. Given a suitable prompt, Copilot will
    generate the necessary combination of characters for whatever type of matching
    syntax you need and produce examples of how to validate.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot的功能还可以自动化另一个经常让开发者感到沮丧的任务：创建正则表达式。给定一个合适的提示，Copilot将生成所需字符组合，以满足您所需的任何匹配语法，并产生验证示例。
- en: In support of basic testing or demoing, Copilot can create a set of data for
    the code to operate against. This can be mapped data with keys and values as defined
    through a prompt or defined from context. The data is not guaranteed to be correct
    or timely and may be more susceptible to matching public examples, so additional
    diligence is needed when working with the results.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持基本的测试或演示，Copilot可以为代码创建一组操作数据。这些数据可以是通过提示定义的具有键和值的映射数据，或者是从上下文中定义的。这些数据不一定正确或及时，并且可能更容易与公共示例匹配，因此在处理结果时需要额外的谨慎。
- en: Finally, in this chapter, we looked at the capabilities that have been added
    to the GitHub CLI to work with Copilot. Through the CLI application `gh`, Copilot
    can help by suggesting commands to do tasks like install applications, as well
    as by explaining what commands and arguments do. This functionality is limited
    but will likely expand to other capabilities in the future.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章中，我们探讨了为与Copilot一起使用而添加到GitHub CLI的功能。通过CLI应用程序`gh`，Copilot可以通过建议执行诸如安装应用程序等任务的命令来帮助，同时解释这些命令和参数的作用。这种功能有限，但预计未来可能会扩展到其他功能。
- en: In the next chapter, we’ll look further into how Copilot’s capabilities are
    integrated into another core application that users rely on—GitHub itself.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨Copilot的功能是如何集成到用户依赖的另一个核心应用——GitHub本身中的。
