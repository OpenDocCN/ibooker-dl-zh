- en: Chapter 8\. Other Ways to Leverage Copilot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve seen, Copilot provides a lot of value for working with traditional
    coding flows as well as traditional tasks like testing and documentation. Copilot
    can also help in many less common use cases encountered by programmers.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t cover all those use cases in this chapter or even in this book, but
    we can cover some representative examples. As a heads-up, the structure of this
    chapter is different from that of the other chapters. We’ll be covering multiple,
    diverse use cases rather than focusing on one overall feature or functional area.
    The examples we’ll look at are outlined in the next few paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: You may primarily think of using GitHub Copilot for coding in popular languages
    like JavaScript and Python. However, Copilot has access to all the languages that
    the model you’re using was trained on. So, you can also use it on ones that we
    don’t think of as traditional programming languages. An example is one we’ve touched
    on before—SQL—commonly used to work with relational databases. Copilot can simplify
    a surprising number of database-related tasks when you’re working with queries,
    schemas, and stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks, such as Kubernetes, also make use of an ordered format (most commonly
    expressed in YAML). While these frameworks are declarative rather than imperative,
    their syntax and structure are understood by Copilot. It can provide completion
    suggestions and answers about how to work with them, just as for any programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Then there are regular expressions—those often complex and cryptic strings of
    characters. When you need one, they are important to get correct but usually frustrating
    to try to create. Copilot can make easy work of these.
  prefs: []
  type: TYPE_NORMAL
- en: For testing a regular expression or unit-testing a function, you may also need
    structured test data. With specific prompting, Copilot can generate nearly any
    simple data structures needed, although there are a few nuances to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s worth noting that some Copilot functionality is embedded in the
    GitHub CLI application. While this is currently limited, it’s reasonable to expect
    more functionality to be added over time.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover all of these in this chapter, starting with how Copilot can be used
    when you’re working with SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Using Copilot with SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While technically a programming language, SQL brings its own unique constructs
    to data management. These include the standard queries used with the data and
    schema in the database, indices for efficiencies, and stored procedures for more
    complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at three areas where Copilot can help:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Copilot to help with queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with stored procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by looking at the basic ways that Copilot can assist with generating
    SQL-related queries.
  prefs: []
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you know, Copilot draws from local content to get context. So if you are
    working in your editor and open a file with an extension of *.sql* or that contains
    SQL statements, Copilot can pick up on that to know that it needs to generate
    SQL. You can also use comments to help clue Copilot in further on what you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html#ch07) showed an example of how to add context to make
    code generation and suggestions more relevant. There we used the technique of
    opening up an SQL file that had all the database schema definitions for a university
    student and course registration system to give Copilot more context for generating
    queries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer back to [“Adding Context to Make Code More Relevant”](ch07.html#addingContextCh7)
    if you need a reminder, but we’ll assume the same setup here. Here is a partial
    schema definition underlying the registration system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open this up in the editor where we are working on our queries and then
    prompt Copilot via a comment to generate an SQL query to get all students enrolled
    in a course, we get a detailed result with table names, field names, etc. that
    match the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By simply having the other file open in the workspace, Copilot was able to draw
    on that content to create a better query for us.
  prefs: []
  type: TYPE_NORMAL
- en: Save Your Work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember to first save any new files as part of the project that you want Copilot
    to be able to use in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, we could ask Copilot to create a table for student attendance
    to capture attendance by class. Given the same context of the larger schema table,
    Copilot should respond with a complete table definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of this table is similar to the format used in the schema file for
    the *courses.registration* table, as shown next. Notice that both table definitions
    use status values of 1–4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can also have Copilot generate more complex types of SQL data like stored
    procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Stored Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *stored procedure* is prepared SQL code that is saved and can be reused easily.
    Copilot can help us generate these as well. Continuing with our university registration
    example, let’s ask Copilot to create a new stored procedure for getting a list
    of enrolled students at a particular location. We can use a simple prompt in chat
    (similar to the comment form we used earlier) to tell Copilot what we want. The
    prompt is “define a stored procedure to get course enrollment by location.”
  prefs: []
  type: TYPE_NORMAL
- en: 'With this prompt and the additional context of the schemas, Copilot produces
    a reasonable result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also be more directive. The more prescriptive we are with the prompt,
    the more likely that Copilot will generate better results. For example, consider
    the following very specific prompt in the chat interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Copilot first explained its thinking in terms of a plan and then generated
    the detailed code to match the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While it’s helpful to have Copilot generating queries and stored procedures
    for us, that’s not its only SQL skill. The AI can also help optimize what we create.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copilot can make the code we have more efficient and can do so in two main ways.
    The first is by writing code leveraging built-in constructs that the language
    or framework provides for optimization. The second is by optimizing existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the first case, SQL provides indexes to speed up operations.
    Refer back to the query we worked with earlier in this chapter to get all students
    enrolled in a course. The complete query is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For this query, we can use a separate index to speed up operations. We ask
    Copilot to create a new index based on this query with the prompt “-- write an
    index to improve the performance of the query.” From this prompt, Copilot might
    suggest SQL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As with the original query, Copilot was able to draw on the context of available
    code to create an index that uses the existing field names, table names, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to creating code to help optimize execution, Copilot can optimize
    static code. This is the second use case mentioned at the start of this section.
    Suppose we have a query to get all the course registrations for September 2024\.
    It might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can select this query and then prompt Copilot to optimize it via the prompt
    “optimize this query.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The AI then suggests an optimization that uses direct starting and ending dates
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same output, Copilot also provides additional background on *why* this
    is an improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Copilot not only suggested an optimization but also told us why and under what
    conditions this would actually be an optimization. Nice.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how Copilot works with managing coding for databases, let’s
    look at how it handles a framework by using declarative specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Working with YAML and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: YAML is a critical formatting language for many applications today. It can also
    be painful to work with because of its syntax and strict formatting requirements.
    But the ability to create specifications and configurations is key for applications
    like Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes itself can also be challenging to work with for multiple reasons.
    These include learning and remembering how to define objects you want in YAML
    files. Each native object has a common set of attributes, but then each also has
    its own specification (spec). The challenges can multiply when trying to scale
    objects for a service or product. Since any error or incorrect formatting can
    cause your app not to function, we can leverage AI to good effect here.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to code up a new deployment in Kubernetes. A *deployment* is
    a type of object in Kubernetes that instantiates and manages multiple instances
    of a Kubernetes *pod.* The pod, in turn, wraps one or more containers. The containers
    are based on images and provide a self-contained environment for an app to execute
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with basic knowledge of the parts, we can prompt Copilot to produce a
    YAML spec for a deployment via the chat interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few moments, Copilot will suggest something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t know Kubernetes, this is valid syntax and mirrors what we would
    expect to have as a deployment spec. Notice that no personal knowledge of the
    Kubernetes syntax was needed to generate this other than the type of objects that
    should be in the spec. We can save this file as *deployment.yaml* and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this spec, we will want to execute it at some point. If we’re
    not clear on the process for that, we can ping Copilot about it. We simply go
    to the chat interface and ask, “How do I execute this?” As shown in [Figure 8-1](#copilot-explains-how),
    Copilot references the *deployment.yaml* file we created and then provides instructions
    to get it into the Kubernetes cluster (a system of machines for running Kubernetes)
    and verify that the deployment is running. It does this using the Kubernetes CLI
    called `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Copilot explains how to apply the spec to Kubernetes for execution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is very helpful, but what if at some point we need to move to managing
    this Kubernetes deployment via the Kubernetes API instead of the CLI? And we’d
    also like to do it using Python and be able to change (scale) the number of instances
    of the container it’s running.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can query Copilot about this through another simple natural language prompt
    in chat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Copilot first tells us that we can do this using the Kubernetes Python client
    library and then dumps out the Python code for the task ([Figure 8-2](#copilots-response-to)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Copilot’s response to manage Kubernetes in Python
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Beyond this, Copilot provides a helpful explanation of the steps needed to run
    the code ([Figure 8-3](#steps-for-execution)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. Steps for execution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can then save the suggested code as a new file in the editor and proceed
    with any edits we want to make, testing the code, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s throw one more challenge at Copilot. The more common programming language
    for Kubernetes is Go. So, if we want to migrate this Python code to Go, can Copilot
    help? As it turns out, it can! And it’s very simple to do. With the Python code
    selected (and therefore referenced), all we need to do is tell Copilot to “Convert
    to Go.” Copilot then produces the equivalent pieces for Go code in the chat interface
    ([Figure 8-4](#code-for-kubernetes-d)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. Code for Kubernetes deployment in Go
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Copilot also provides a corresponding explanation and instructions on execution
    as it did for the Python version ([Figure 8-5](#steps-to-execute-go-c)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. Steps to execute Go code
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Yet again, we see an example of how Copilot can automate and simplify creating
    processing for complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Another often complex task that Copilot can greatly simplify is creating regular
    expressions. That’s the topic of our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most developers are not a fan of having to come up with the syntax for regular
    expressions. The process of trying to find a combination of letters, numbers,
    and symbols to effectively match a set of strings can be time consuming and frustrating.
    Add to that the need to devise tests that comprehensively test out the expression,
    and it becomes preferable to try to find something that matches closely from other
    code or from a resource like Stack Overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is yet another area where Copilot shines. Given a suitable prompt,
    Copilot can easily create a corresponding regular expression. For example, suppose
    we tell Copilot to “Create a regular expression to validate a SSN” (where *SSN*
    stands for a *US Social Security number*). Copilot responds with the following
    implementation suggestion and explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We may also want to generate a function that uses a regular expression for whatever
    language we’re coding in. Assume that we have a JavaScript file (*phone.js*),
    and we want a function in it to validate any global phone number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prompt Copilot with “create a function to validate any global phone
    number using a regular expression.” Copilot, in turn will produce JavaScript code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that while the code is short, the regular expression is not simple. And
    Copilot also provided example calls to use to validate the function. If the use
    cases in the examples don’t match what you were intending, you could reject the
    suggestion and use a more detailed prompt to get what you need.
  prefs: []
  type: TYPE_NORMAL
- en: After generating a regular expression, you may want some simple data to use
    for testing it, or you might need some data to do basic testing on some other
    part of your code. Rather than having to find or create this kind of data yourself,
    you can create it automatically with Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Data Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another area where Copilot can come to the rescue for helping with boilerplate
    tasks is generating data and data mappings for validating coding approaches and
    testing after the coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach here is the same: to use a well-defined prompt to achieve the
    desired results. Suppose we want some test data to verify a function that looks
    up area codes for a given state. We can direct Copilot to “Create a mapping of
    all 50 states to area codes where the key is the state abbreviation and the value
    is an array of codes with max 10.”'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we were specific about what the keys and corresponding values should
    be for the mapping. Copilot responds with the requested data ([Figure 8-6](#generated-data)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. Generated data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sometimes Copilot may include a disclaimer about the accuracy of the generated
    data. A disclaimer for this data would note that the area codes are placeholders
    and not guaranteed to be the actual area codes for each state. Repeating a point
    we made in [Chapter 7](ch07.html#ch07), Copilot is working only from the data
    it was trained on. It is not going out and checking to ensure that the data it
    returns is correct or up-to-date. You must always remember to cross-check results
    if you need accurate, timely data. You cannot assume that the values provided
    through Copilot are current and correct.
  prefs: []
  type: TYPE_NORMAL
- en: When you ask Copilot to generate data in this way, you may occasionally encounter
    two other types of issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, depending on the prompt and amount of data you request, Copilot might
    return only a portion of the data. This will usually be enough to get you started
    but not a complete set. For example, if the query left out the *all 50* part and
    was just “Create a mapping of states to area codes where the key is the state
    abbreviation and the value is an array of codes with max 10,” Copilot might return
    only a few records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you encounter a situation like this, you can prompt Copilot to generate the
    rest of the data via a prompt like “Create a mapping of the remaining states to
    area codes where the key is the state abbreviation and the value is an array of
    area codes with max 10.” We added the term *remaining* to tell Copilot to pick
    up where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: Second, when having Copilot generate data, you may be notified that the generated
    data matches data in a public repository. If you have the setting enabled to block
    generated code that matches public code, Copilot’s complete response to your prompt
    will be blocked.
  prefs: []
  type: TYPE_NORMAL
- en: In general, data such as this is less likely to be proprietary. If there is
    not a concern about license violations, you can usually tweak your prompt to have
    the AI generate the data with a different dimension. It may be as easy as changing
    the amount of data requested, as in “create a mapping of the states to area codes
    where the key is the state abbreviation and the value is an array of area codes
    with max 5.” Note the change in the max value from 10 to 5.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s look at one other way you can interact with Copilot. While not
    as common as the other interfaces we’ve discussed, the GitHub command line can
    also leverage Copilot to help you understand and generate answers.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub CLI and Copilot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use the GitHub CLI, you can use a couple of subcommands with Copilot.
    At the time of this writing, there are four.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before being able to use Copilot with the GitHub CLI, some basic prerequisites
    have to be met:'
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub CLI has to be installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must have authenticated to GitHub, such as through the `gh auth` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Copilot extension must be installed in the GitHub CLI via the `gh extension
    install github/gh-copilot` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After going through the prerequisites, the CLI commands listed in [Table 8-1](#copilot-commands-thro)
    will be available to you. The table also shows the purpose of each command.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Copilot commands through the GitHub CLI
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Function |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `alias` | Generate shell-specific aliases for convenience |'
  prefs: []
  type: TYPE_TB
- en: '| `config` | Configure options |'
  prefs: []
  type: TYPE_TB
- en: '| `explain` | Explain a command |'
  prefs: []
  type: TYPE_TB
- en: '| `suggest` | Suggest a command |'
  prefs: []
  type: TYPE_TB
- en: 'As an example of using the CLI with Copilot, we can ask it to explain a Unix
    command via a simple invocation of the GitHub CLI like `gh copilot explain "ps
    -aux"`. The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you may be asked to select additional options as a follow-up.
    For example, if you ask Copilot via the CLI to suggest a command to install Python,
    there can be additional queries from the AI to make sure it provides you with
    the best response. Here’s the output and interactions based on an initial command
    of `gh copilot suggest "install python"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice after the original command, there were several follow-up interactions
    with Copilot. We were given the option to select the context for the command (generic
    shell, CLI, or Git). Once we selected the shell command, Copilot provided the
    suggestion. We were then given the option to copy the command, have Copilot explain
    it, execute it, etc. Selecting the `explain` option provides an explanation like
    the one in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a set of areas where AI assistance may not be
    the first option that comes to mind but can prove helpful. Copilot’s capabilities
    can be put to good use in each of these areas.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to interact with databases, Copilot can provide code-completion
    suggestions and generate full sets of code for SQL just as for more typical programming
    languages. Copilot can be especially helpful for creating stored procedures and
    optimizing programming.
  prefs: []
  type: TYPE_NORMAL
- en: Besides generating traditional code that tells the system how to do something,
    Copilot can also be used to generate declarative specifications that outline the
    desired end result. A good example of this is using Copilot to help declare Kubernetes
    specifications. Given a suitable prompt, Copilot can generate the YAML definition
    for any of the standard Kubernetes objects. In addition, Copilot can tell the
    user how to use the specification with Kubernetes and even turn it into code with
    API calls. This kind of help greatly simplifies working with the complexities
    of different frameworks and their representations in YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copilot’s capabilities can also automate another task that frequently frustrates
    developers: creating regular expressions. Given a suitable prompt, Copilot will
    generate the necessary combination of characters for whatever type of matching
    syntax you need and produce examples of how to validate.'
  prefs: []
  type: TYPE_NORMAL
- en: In support of basic testing or demoing, Copilot can create a set of data for
    the code to operate against. This can be mapped data with keys and values as defined
    through a prompt or defined from context. The data is not guaranteed to be correct
    or timely and may be more susceptible to matching public examples, so additional
    diligence is needed when working with the results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in this chapter, we looked at the capabilities that have been added
    to the GitHub CLI to work with Copilot. Through the CLI application `gh`, Copilot
    can help by suggesting commands to do tasks like install applications, as well
    as by explaining what commands and arguments do. This functionality is limited
    but will likely expand to other capabilities in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look further into how Copilot’s capabilities are
    integrated into another core application that users rely on—GitHub itself.
  prefs: []
  type: TYPE_NORMAL
