["```py\nfrom torch.nn.functional import mse_loss                   ①\n\ny_pred = torch.tensor([-0.10, -0.24,  1.43, -0.14, -0.59]) ②\n\ny_gt = torch.tensor([ 0.59, -1.92, -1.27, -0.40,  0.50])   ③\n\nloss = mse_loss(y_pred, y_gt, reduction='sum')             ④\n```", "```py\nimport torch\n\ny_pred = torch.tensor([0.8, 0.15, 0.04, 0.01]) ①\n\ny_gt = torch.tensor([1., 0., 0., 0.])          ②\n\nloss = -1 * torch.dot(y_gt, torch.log(y_pred)) ①\n```", "```py\nfrom torch.nn.functional import binary_cross_entropy ①\n\ny_pred = torch.tensor([0.8])                         ②\n\ny_gt = torch.tensor([1.])                            ③\n\nloss = binary_cross_entropy(y_pred, y_gt)            ④\n```", "```py\nfrom torch.nn.functional import softmax      ①\n\nscores = torch.tensor([9.99, 10, 0.01, -10]) ②\n\noutput = softmax(scores, dim=0)              ③\n```", "```py\nfrom torch.nn.functional import cross_entropy\n\nscores = torch.tensor([[9.99, 10, 0.01, -10]])\n\ny_gt = torch.tensor([1])            ①\n\nloss = cross_entropy(scores, y_gt)  ②\n```", "```py\ndef focal_loss(y, y_gt, gamma):\n    y_t = (y_gt * y) + ((1 - y_gt) * (1 - y)) ①\n\n    loss = -1 * torch.pow((1 - y_t), gamma) * torch.log(y_t)\n    return loss\n```", "```py\nfrom torch.utils.data import Dataset, DataLoader\n\nclass StatsvilleDataset(Dataset):                ①\n    def __init__(self, X, y_gt):\n        self.X = X\n        self.y_gt = y_gt\n\n    def __len__(self):                           ②\n        return len(self.X)\n\n    def __getitem__(self, i):                    ③\n        return self.X[i], self.y_gt[i]\n\ndataset = StatsvilleDataset(X, y_gt)             ④\n\ndata_loader = DataLoader(dataset, batch_size=10, ⑤\n                       shuffle=True)\n```", "```py\nclass Model(torch.nn.Module):                                     ①\n    def __init__(self, input_size, hidden_size, output_size):\n        super(Model, self).__init__()\n        self.linear1 = torch.nn.Linear(input_size, hidden_size)   ②\n        self.linear2 = torch.nn.Linear(hidden_size, output_size)\n        self.softmax = torch.nn.Softmax(dim=1)\n\n    def forward(self, X):                                         ③\n        scores = self.linear2(self.linear1(X))\n        return scores\n\n    def predict(self, X):                                         ④\n        scores = self.forward(X)\n        y_pred = torch.argmax(self.softmax(scores), dim=1)\n        return y_pred\n\ndef initialize_weights(m):\n    if isinstance(m, torch.nn.Linear):\n        torch.nn.init.xavier_uniform_(m.weight.data)              ⑤\n        torch.nn.init.constant_(m.bias.data, 0)\n\nmodel = Model(input_size=2, hidden_size=100, output_size=3)\nmodel.apply(initialize_weights)\n```", "```py\nloss_fn = torch.nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.02) ①\n```", "```py\ndef train_loop(epoch, data_loader, model, loss_fn, optimizer):\n    for X_batch, y_gt_batch in data_loader:                   ①\n\n        scores = model(X_batch)                               ②\n\n        loss = loss_fn(scores, y_gt_batch)                    ③\n\n        optimizer.zero_grad()                                 ④\n\n        loss.backward()                                       ⑤\n\n        optimizer.step()                                      ⑥\n```", "```py\nnum_epochs = 2\nfor epoch in range(num_epochs):\n    train_loop(epoch, data_loader, model, loss_fn, optimizer)\n```", "```py\nfrom torch import optim\n\nsgd_optimizer = optim.SGD([params], lr=0.01)                   ①\n\nsgd_momentum_optimizer = optim.SGD([params], lr=0.01,\n                                    momentum=0.9)              ②\n\nsgd_nesterov_momentum_optimizer = optim.SGD([params], lr=0.01, ③\n                                    momentum=0.9, nesterov=True)\n\nadagrad_optimizer = optim.Adagrad([params], lr=0.001)\n\nrms_prop_optimizer = RMSprop([params], lr=1e-2,                ④\n                       alpha=0.99)\n\nadam_optimizer = optim.Adam([params], lr=0.001,\n                       betas=(0.9, 0.999))\n```", "```py\nfrom torch import optim\n\noptimizer = optim.SGD([params], lr=0.2, weight_decay=0.01) ①\n```", "```py\nclass ModelWithDropout(torch.nn.Module):\n    def __init__(self, input_size, hidden_size, output_size):\n        super(Model, self).__init__()\n        self.net = torch.nn.Sequential(\n            torch.nn.Linear(input_size, hidden_size),\n            torch.nn.Dropout(p=0.2),                 ①\n\n            torch.nn.Linear(hidden_size, output_size),\n            torch.nn.Dropout(p=0.2)\n        )\n\n    def forward(self, X):\n        return self.net(X)\n```"]