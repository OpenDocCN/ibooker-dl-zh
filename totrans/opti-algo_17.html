<html><head></head><body>
  <h1 class="tochead" id="heading_id_2">Appendix A. Search and optimization libraries in Python</h1>

  <p class="body">This appendix covers setting up the Python environment, along with essential libraries for mathematical programming, graph visualization, metaheuristic optimization, and machine learning.<a id="marker-493"/></p>

  <h2 class="fm-head" id="heading_id_3">A.1 Setting up the Python environment</h2>

  <p class="body">This book assumes that you already have Python 3.6 or a newer version installed on your system. For installation instructions specific to your operating system, see this Beginner’s Guide: <a class="url" href="https://wiki.python.org/moin/BeginnersGuide/">https://wiki.python.org/moin/BeginnersGuide/</a>.</p>

  <p class="body">For Windows, you can follow these steps to install Python:</p>

  <ol class="calibre7">
    <li class="fm-list-bullet">
      <p class="list">Go to the official website: <a class="url" href="https://www.python.org/downloads/">www.python.org/downloads/</a>.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Select the version of Python to install.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Download the Python executable installer.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Run the executable installer. Make sure you check the Install Launcher for all <span class="fm-underline">u</span>sers and Add Python 3.8 to PATH checkboxes.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Verify that Python was successfully installed by typing <code class="fm-code-in-text">python –V</code> in a command prompt.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Verify that pip was installed by typing <code class="fm-code-in-text">pip -V</code> in a command prompt.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Install <code class="fm-code-in-text">virtualenv</code> by typing <code class="fm-code-in-text">pip install</code> <code class="fm-code-in-text">virtualenv</code> in a command prompt.</p>
    </li>
  </ol>

  <p class="body">If you are a Linux user, execute the following commands in the terminal:</p>
  <pre class="programlisting">$ sudo apt update
$ sudo apt install python3-pip</pre>

  <p class="body">Install venv and create a Python virtual environment:</p>
  <pre class="programlisting">$ sudo apt install python3.8-venv
$ mkdir &lt;new directory for venv&gt;
$ python -m venv &lt;path to venv directory&gt;</pre>

  <p class="body">Make sure that you replace <code class="fm-code-in-text">python3.8</code> with the version of Python you are using.</p>

  <p class="body">You can now access your virtual environment using the following command:</p>
  <pre class="programlisting">$ source &lt;path to venv&gt;/bin/activate</pre>

  <p class="body">In the case of macOS, Python is already preinstalled, but if you need to upgrade or install a specific version, you can use the macOS terminal as follows:</p>
  <pre class="programlisting">$ python -m ensurepip --upgrade</pre>

  <p class="body"><code class="fm-code-in-text">venv</code> is included with python 3.8+. You can run the following command to create a virtual environment:</p>
  <pre class="programlisting">$ mkdir &lt;new directory&gt;
$ python -m venv &lt;path to venv directory&gt;</pre>

  <p class="body">You can now access your virtual environment using the following command:</p>
  <pre class="programlisting">$ source &lt;path to venv&gt;/bin/activate</pre>

  <p class="body">A better option is to install a Python distribution as explained in the next subsection.</p>

  <h3 class="fm-head1" id="heading_id_4">A.1.1 Using a Python distribution</h3>

  <p class="body"><a id="marker-494"/>Python distributions, such as Anaconda or Miniconda, come with a package manager called <code class="fm-code-in-text">conda</code> that allows you to install a wide range of Python packages and manage different Python environments. Install <code class="fm-code-in-text">conda</code> for your OS using the guide found here: <a class="url" href="https://conda.io/projects/conda/en/latest/user-guide/install/index.html">https://conda.io/projects/conda/en/latest/user-guide/install/index.html</a>.</p>

  <p class="body">Conda environments are used to manage multiple installations of different versions of Python packages and their dependencies. You can create a <code class="fm-code-in-text">conda</code> environment with this command:</p>
  <pre class="programlisting">$ conda create --name &lt;name of env&gt; python=&lt;your version of python&gt;</pre>

  <p class="body">Access the newly created environment like this:</p>
  <pre class="programlisting">$ conda activate &lt;your env name&gt;</pre>

  <p class="body">This command allows you to switch or move between environments.</p>

  <h3 class="fm-head1" id="heading_id_5">A.1.2 Installing Jupyter Notebook and JupyterLab</h3>

  <p class="body">Jupyter is a multi-language, open-source web-based platform for interactive programming (<a id="idTextAnchor000"/><a class="url" href="https://jupyter.org/">https://jupyter.org/</a>). The name “Jupyter” is a loose acronym meaning Julia, Python, and R. All of the code in this book is stored in Jupyter notebooks (.ipynb files), which can be opened and edited using JupyterLab or Jupyter Notebook. Jupyter Notebook feels more standalone, but JupyterLab feels more like an IDE.</p>

  <p class="body">You can install JupyterLab using <code class="fm-code-in-text">pip</code> as follows:</p>
  <pre class="programlisting">$ pip install jupyterlab
$ pip install notebook</pre>

  <p class="body">Or using <code class="fm-code-in-text">conda</code> as follows:</p>
  <pre class="programlisting">$ conda install -c conda-forge jupyterlab
$ conda install -c conda-forge notebook</pre>

  <p class="body">You can install the Python ipywidgets package to automatically configure classic Jupyter Notebook and JupyterLab 3.0 to display ipywidgets using <code class="fm-code-in-text">pip</code> or <code class="fm-code-in-text">conda</code> as follows:</p>
  <pre class="programlisting">$ pip install ipywidgets
$ conda install -c conda-forge ipywidgets</pre>

  <p class="body">If you have an old version of Jupyter Notebook installed, you may need to manually enable the ipywidgets notebook extension with these commands:</p>
  <pre class="programlisting">$ jupyter nbextension install --user --py widgetsnbextension
$ jupyter nbextension enable --user --py widgetsnbextension</pre>

  <p class="body">Google Colaboratory (Colab) can also be used. This cloud-based tool allows you to write, execute, and share Python code through the browser. It also provides free access to GPU and TPU for increased computational power. You can access Colab here: <a class="url" href="https://colab.research.google.com/">https://colab.research.google.com/</a>.</p>

  <h3 class="fm-head1" id="heading_id_6">A.1.3 Cloning the book’s repository</h3>

  <p class="body"><a id="marker-495"/>You can clone this book’s code repository as follows:</p>
  <pre class="programlisting">$git clone https://github.com/Optimization-Algorithms-Book/Code-Listings.git  </pre>

  <p class="body">Many of the operations in this book are long and burdensome to code from scratch. Often, they’re highly standardized and can benefit from having a helper function take care of the various intricacies. <code class="fm-code-in-text">optalgotools</code> is a Python package developed for this purpose.</p>

  <p class="body">You can use these supporting tools locally without installing this package. To do so, you will need to download <code class="fm-code-in-text">optalgotools</code> in a local folder and add this folder to the system path. If you’re using Jupyter notebook or Jupyter lab, you can do so as follows:</p>
  <pre class="programlisting">import sys
sys.path.insert(0, '../')</pre>

  <p class="body">If you’re using Colab, you can mount your Google Drive with these commands:</p>
  <pre class="programlisting">from google.colab import drive
drive.mount('/content/drive')</pre>

  <p class="body">Then copy the <code class="fm-code-in-text">optalgotools</code> folder to your Google Drive.</p>

  <p class="body">This package is also available on the Python Package Index (PyPI) repository here: <a class="url" href="https://pypi.org/project/optalgotools/">https://pypi.org/project/optalgotools/</a>. You can install it as follows:</p>
  <pre class="programlisting">$pip install optalgotools </pre>

  <p class="body">You can then use the <code class="fm-code-in-text">import</code> command to use these tools. Here is an example:</p>
  <pre class="programlisting">from optalgotools.problems import TSP
from optalgotools.algorithms import SimulatedAnnealing</pre>

  <p class="body">The first line imports the <code class="fm-code-in-text">TSP</code> instance from the <code class="fm-code-in-text">problems</code> module, and the second line imports a simulated annealing solver from the <code class="fm-code-in-text">algorithms</code> module.</p>

  <h2 class="fm-head" id="heading_id_7">A.2 Mathematical programming solvers</h2>

  <p class="body"><i class="fm-italics">Mathematical programming</i>, also known as <i class="fm-italics">mathematical optimization</i>, is the process of finding the best solution to a problem that can be represented in mathematical terms. It involves formulating a mathematical model of a problem, determining the parameters of the model, and using mathematical and computational techniques to find a solution that maximizes or minimizes a particular objective function or set of objective functions subject to a set of constraints. Linear programming (LP), mixed-integer linear programming (MILP), and nonlinear programming (NLP) are examples of mathematical optimization problems. Several Python libraries can be used for solving mathematical optimization problems.<a id="marker-496"/></p>

  <p class="body">Let’s consider the following production planning example from Guerte el al.’s <i class="fm-italics">Linear Programming</i> [1]. A small woodworking shop produces two sizes of boxwood chess sets. Crafting the smaller set involves 3 hours of lathe machining, while the larger set requires 2 hours. With four skilled operators each working a 40-hour week, the shop has a total of 160 lathe-hours available weekly. The smaller chess set consumes 1 kg of boxwood, while the larger set requires 3 kg. However, due to scarcity, only 200 kg of boxwood can be obtained per week. Upon sale, each large chess set generates a profit of $12, while each small set yields $5 in profit. The objective is to determine the optimal weekly production quantities for each set to maximize profit.</p>

  <p class="body">Let’s assume that <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">1</sub></span> and <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">2</sub></span> are decision variables that represent the number of small and large chess sets respectively to make. The total profit is the sum of the individual profits from making and selling the <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">1</sub></span> small sets and the <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">2</sub></span> large sets: <span class="times">profit = 5<i class="fm-italics">x</i><sub class="fm-subscript">1</sub> + 12<i class="fm-italics">x</i><sub class="fm-subscript">2</sub></span>. However, this profit is subject to the following constraints:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">The total number of hours of machine time we will use is <span class="times">3<i class="fm-italics">x</i><sub class="fm-subscript">1</sub> + 2<i class="fm-italics">x</i><sub class="fm-subscript">2</sub></span>. This time shouldn’t exceed the maximum of 160 hours of machine time available per week. This means that <span class="times">3<i class="fm-italics">x</i><sub class="fm-subscript">1</sub> + 2<i class="fm-italics">x</i><sub class="fm-subscript">2</sub> ≤</span> 160 (lathe-hours).</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Only 200 kg of boxwood is available each week. Since small sets use 1 kg for every set made, against 3 kg needed to make a large set, <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">1</sub> + 3<i class="fm-italics">x</i><sub class="fm-subscript">2</sub> ≤ 200</span> (kg of boxwood).</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The joinery cannot produce a negative number of chess sets, so we have two further non-negativity constraints: <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">1</sub></span> and <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">2</sub> &gt;= 0</span>.</p>
    </li>
  </ul>

  <p class="body">This linear programming problem can be summarized as follows. Find <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">1</sub></span> and <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">2</sub></span> that maximize <span class="times">5<i class="fm-italics">x</i><sub class="fm-subscript">1</sub> + 12<i class="fm-italics">x</i><sub class="fm-subscript">2</sub></span>, subject to</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">Machining time constraint: <span class="times">3<i class="fm-italics">x</i><sub class="fm-subscript">1</sub> + 2<i class="fm-italics">x</i><sub class="fm-subscript">2</sub> ≤ 160</span></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Weight constraint: <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">1</sub> + 3<i class="fm-italics">x</i><sub class="fm-subscript">2</sub> ≤ 200</span></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Non-negativity constraints: <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">1</sub></span> and <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">2</sub> ≥ 0</span></p>
    </li>
  </ul>

  <p class="body">Let’s see how we can solve this linear programming problem using different solvers.</p>

  <h3 class="fm-head1" id="heading_id_8">A.2.1 SciPy</h3>

  <p class="body"><a class="url" href="https://scipy.org/">SciPy</a> is an open source scientific computing Python library that provides tools for optimization, linear algebra, and statistics. SciPy optimize is a submodule of the SciPy library, which includes solvers for nonlinear problems (with support for both local and global optimization algorithms), linear programing, constrained and nonlinear least-squares, root finding, and curve fitting.</p>

  <p class="body">To use SciPy, you will need to install it and its dependencies. You can install SciPy using the pip package manager:</p>
  <pre class="programlisting">$pip install scipy</pre>

  <p class="body">Alternatively, you can use a Python distribution, such as Anaconda or Miniconda, that comes with SciPy and other scientific libraries pre-installed.</p>

  <p class="body">Listing A.1 shows the steps to solve the car manufacturing problem using SciPy. The code defines the coefficient vector <code class="fm-code-in-text">c</code> and the left-hand side (<code class="fm-code-in-text">lhs</code>) and right-hand side (<code class="fm-code-in-text">rhs</code>) of the constraint equations. The objective function represents the profit to be maximized. Since many optimization algorithms in SciPy are designed for minimization, the problem of profit maximization is typically converted into a minimization problem by minimizing the negative of the profit function. Moreover, constraints using the greater-than-or-equal-to sign cannot be defined directly. Less-than-or-equal-to must be used instead.</p>

  <p class="fm-code-listing-caption">Listing A.1 Solving the chess set problem using SciPy</p>
  <pre class="programlisting">import numpy as np
import scipy
from scipy.optimize import linprog
  
c = -np.array([5,12])                                            <span class="fm-combinumeral">①</span>
  
lhs_constraints=([3,2],                                          <span class="fm-combinumeral">②</span>
                 [1,3])                                          <span class="fm-combinumeral">③</span>
  
rhs_constraints=([160,                                           <span class="fm-combinumeral">④</span>
                  200])                                          <span class="fm-combinumeral">⑤</span>
  
bounds = [(0, scipy.inf), (0, scipy.inf)]                        <span class="fm-combinumeral">⑥</span>
  
results = linprog(c=c, A_ub=lhs_constraints, b_ub=rhs_constraints,
<span class="fm-code-continuation-arrow">➥</span> bounds=bounds, method='highs-ds')                             <span class="fm-combinumeral">⑦</span>
  
  
print('LP Solution:')                                            <span class="fm-combinumeral">⑧</span>
print(f'Profit: = {-round(results.fun,2)} $')                    <span class="fm-combinumeral">⑧</span>
print(f'Make {round(results.x[0],0)} small sets, and make        <span class="fm-combinumeral">⑧</span>
{round(results.x[1],0)} large sets')                             <span class="fm-combinumeral">⑧</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Declare coefficients of the objective function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Left-hand side of the machining time constraint</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Left-hand side of the weight constraint</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Right-hand side of the machining time constraint</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Right-hand side of the weight constraint</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Bounds of the decision variables</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Solve the linear programming problem.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Print the solution.</p>

  <p class="body">Running this code gives the following results:</p>
  <pre class="programlisting">LP Solution:
Profit: = 811.43 $
Make 11.0 small sets, and make 63.0 large sets</pre>

  <p class="body">The <code class="fm-code-in-text">linprog()</code> function used in the preceding code returns a data structure with several attributes such as <code class="fm-code-in-text">x</code> (the current solution vector), <code class="fm-code-in-text">fun</code> (the current value of the objective function), and <code class="fm-code-in-text">success</code> (<code class="fm-code-in-text">true</code> when the algorithm has completed successfully).</p>

  <h3 class="fm-head1" id="heading_id_9">A.2.2 PuLP</h3>

  <p class="body"><a class="url" href="https://coin-or.github.io/pulp/">PuLP</a> is a linear programming library in Python that allows you to define and solve linear optimization problems. There are two main classes in PuLP: <code class="fm-code-in-text">LpProblem</code> and <code class="fm-code-in-text">LpVariable</code>. PuLP variables can be declared individually or as “dictionaries” (variables indexed on another set).</p>

  <p class="body">You can install PuLP using pip as follows:</p>
  <pre class="programlisting">$pip install pulp</pre>

  <p class="body">The following code (a continuation of listing A.1) shows how to use PuLP to solve the chess set problem:</p>
  <pre class="programlisting">#!pip install pulp
from pulp import LpMaximize, LpProblem, LpVariable, lpSum, LpStatus
  
model = LpProblem(name='ChessSet', sense=LpMaximize)                      <span class="fm-combinumeral">①</span>
  
x1 = LpVariable('SmallSet', lowBound = 0, upBound =  None, cat='Integer') <span class="fm-combinumeral">②</span>
x2 = LpVariable('LargeSet', lowBound = 0, upBound =  None, cat='Integer') <span class="fm-combinumeral">②</span>
  
model += (3*x1 + 2*x2 &lt;=160, 'Machining time constraint')                 <span class="fm-combinumeral">③</span>
model += (  x1 + 3*x2 &lt;= 200, 'Weight constraint')                        <span class="fm-combinumeral">③</span>
  
profit= 5*x1 + 12*x2                                                      <span class="fm-combinumeral">④</span>
model.setObjective(profit)                                                <span class="fm-combinumeral">④</span>
  
model.solve()                                                             <span class="fm-combinumeral">⑤</span>
  
print('LP Solution:')                                                     <span class="fm-combinumeral">⑥</span>
print(f'Profit: = {model.objective.value()} $')                           <span class="fm-combinumeral">⑥</span>
print(f'Make {x1.value()} small sets, and make {x2.value()} large sets')  <span class="fm-combinumeral">⑥</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define the model.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Define the decision variables.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Add constraints.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Set the profit as the objective function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Solve the optimization problem.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Print the solution.</p>

  <p class="body">PuLP implements several algorithms for solving linear programming (LP) and mixed-integer linear programming (MILP) problems. Examples include COIN-OR (computational infrastructure for operations research), CLP (COIN-OR linear programming), Cbc (COIN-OR branch and cut), CPLEX (Cplex), GLPK (GNU linear programming lit), SCIP (solving constraint integer programs), HiGHS (highly scalable global solver), Gurobi LP/MIP solver, Mosek optimizer, and the XPRESS LP solver.</p>

  <h3 class="fm-head1" id="heading_id_10">A.2.3 Other mathematical programming solvers</h3>

  <p class="body">There are several other libraries in Python for solving mathematical optimization problems. This is a non-exhaustive list of other available libraries:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://developers.google.com/optimization">OR-Tools</a>—This is an open source software suite for optimization and constraint programming developed by Google. It includes a variety of algorithms and tools for solving problems in areas such as operations research, transportation, scheduling, and logistics. OR-Tools can be used to model and solve linear and integer programming problems, as well as constraint programming problems. Examples of OR-Tools solvers include GLOP (Google linear programming), Cbc (COIN-OR branch and cut), CP-SAT (constraint programming-satisfiability) solver, max flow and min cost flow solvers, the shortest path solver, and the BOP (binary optimization problem) solver. It is written in C++ and includes interfaces for several programming languages, including Python, C#, and Java. See section A.4.5 for more details and an example.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://www.gurobi.com/documentation/">Gurobi</a>—This is commercial optimization software that offers state-of-the-art solvers for linear programming, quadratic programming, and mixed integer programming. It has a Python interface that can be used to define and solve optimization problems.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://web.casadi.org/">CasADi</a>—This is an open source tool for nonlinear optimization and algorithmic differentiation.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://www.python-mip.com/">Python-MIP</a>—This is a Python library for solving mixed-integer programming problems. It is built on top of the Cbc open source optimization library and allows users to express optimization models in a high-level, mathematical programming language.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="http://www.pyomo.org/">Pyomo</a>—This is an open source optimization modeling language that can be used to define and solve mathematical optimization problems in Python. It supports a wide range of optimization solvers, including for linear programming, mixed integer programming, and nonlinear optimization.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://gekko.readthedocs.io/en/latest/">GEKKO</a>—This is a Python package for machine learning and the optimization of mixed-integer and differential algebraic equations.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://www.cvxpy.org/">CVXPY</a>—This is an open source Python-embedded modeling language for convex optimization problems. It lets you express your problem in a natural way that follows the math, rather than in the restrictive standard form required by solvers.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://pymprog.sourceforge.net/">PyMathProg</a>—This is a mathematical programming environment for Python that allows for modeling, solving, analyzing, modifying, and manipulating linear programming problems.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://optlang.readthedocs.io/en/latest/">Optlang</a>—This is a Python library for modeling and solving mathematical optimization problems. It provides a common interface to a series of optimization tools so that different solver backends can be changed in a transparent way. It is compatible with most of the popular optimization solvers like Gurobi, Cplex, and Ipopt (interior point optimizer).</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://picos-api.gitlab.io/picos/">Python interface to conic optimization solvers (PICOS)</a>—This is a Python library for modeling and solving optimization problems. It can handle complex problems with multiple objectives, and it supports both local and global optimization methods. PICOS has interfaces to different solvers such as Gurobi, CPLEX, SCS (splitting conic solver), ECOS (embedded cone solver), and MOSEK.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/coin-or/cylp">CyLP</a>—This is a Python interface to COIN-OR’s linear and mixed-integer program solvers (CLP, Cbc, and CGL). COIN-OR (computational infrastructure for operations research) is a collection of open source software packages for operations research and computational optimization. It includes libraries for linear and integer programming, constraint programming, and other optimization techniques.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://www.sympy.org/en/index.html">SymPy</a>—This is a Python library for symbolic mathematics. It can be used to solve equations, handle combinatorics, plot in 2D/3D, or work on polynomials, calculus, discrete math, matrices, geometry, parsing, physics, statistics, and cryptography.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Other libraries</i>—These include but are not limited to, <a class="url" href="https://docs.mosek.com/latest/pythonapi/index.html">MOSEK</a>, <a class="url" href="https://cvxopt.org/">CVXOPT</a>, ,, , , and .</p>
    </li>
  </ul>

  <p class="body">Jupyter notebook “Listing A.1_Mathematical_programming_solvers.ipynb,” included in the GitHub repo for the book shows how to use some of these solvers to solve the chess set problem.</p>

  <h2 class="fm-head" id="heading_id_11">A.3 Graph and mapping libraries</h2>

  <p class="body">The following Python libraries are used in this book to process and visualize graphs, networks, and geospatial data.</p>

  <h3 class="fm-head1" id="heading_id_12">A.3.1 NetworkX</h3>

  <p class="body"><a class="url" href="https://networkx.org/">NetworkX</a> is a library for working with graphs and networks in Python. It provides tools for creating, manipulating, and analyzing graph data, as well as for visualizing graph structures. NetworkX also contains approximations of graph properties and heuristic methods for optimization. You can install NetworkX as follows:</p>
  <pre class="programlisting">$pip install networkx</pre>

  <p class="body">Let’s consider the traveling salesman problem (TSP). Listing A.2 shows the steps for creating a random undirected graph for this problem. Each randomly scattered node represents a city to be visited by the salesman, and the weight of each edge connecting the cities is calculated based on the Euclidian distance between the nodes using the <code class="fm-code-in-text">hypot</code> function, which calculates the square root of the sum of the squares. Christofides algorithm is used to solve this TSP instance—this algorithm provides a 3/2-approximation of TSP. This means that its solutions will be within a factor of 1.5 of the optimal solution length.</p>

  <p class="fm-code-listing-caption">Listing A.2 Solving TSP using NetworkX</p>
  <pre class="programlisting">import matplotlib.pyplot as plt
import networkx as nx
import networkx.algorithms.approximation as nx_app
import math
 
plt.figure(figsize=(10, 7))
 
G = nx.random_geometric_graph(20, radius=0.4, seed=4)                   <span class="fm-combinumeral">①</span>
pos = nx.get_node_attributes(G, "pos")
 
pos[0] = (0.5, 0.5)                                                     <span class="fm-combinumeral">②</span>
 
H = G.copy()                                                            <span class="fm-combinumeral">③</span>
 
for i in range(len(pos)):                                               <span class="fm-combinumeral">④</span>
    for j in range(i + 1, len(pos)):                                    <span class="fm-combinumeral">④</span>
        dist = math.hypot(pos[i][0] - pos[j][0], pos[i][1] - pos[j][1]) <span class="fm-combinumeral">④</span>
        dist = dist                                                     <span class="fm-combinumeral">④</span>
        G.add_edge(i, j, weight=dist)                                   <span class="fm-combinumeral">④</span>
 
cycle = nx_app.christofides(G, weight="weight")                         <span class="fm-combinumeral">⑤</span>
edge_list = list(nx.utils.pairwise(cycle))
 
nx.draw_networkx_edges(H, pos, edge_color="blue", width=0.5)            <span class="fm-combinumeral">⑥</span>
 
nx.draw_networkx(                                                       <span class="fm-combinumeral">⑦</span>
    G,                                                                  <span class="fm-combinumeral">⑦</span>
    pos,                                                                <span class="fm-combinumeral">⑦</span>
    with_labels=True,                                                   <span class="fm-combinumeral">⑦</span>
    edgelist=edge_list,                                                 <span class="fm-combinumeral">⑦</span>
    edge_color="red",                                                   <span class="fm-combinumeral">⑦</span>
    node_size=200,                                                      <span class="fm-combinumeral">⑦</span>
    width=3,                                                            <span class="fm-combinumeral">⑦</span>
)                                                                       <span class="fm-combinumeral">⑦</span>
 
print("The route of the salesman is:", cycle)                           <span class="fm-combinumeral">⑧</span>
plt.show() </pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Create a random geometric graph with 20 nodes.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Set (0,0) as the home city/depot.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Create an independent shallow copy of the graph and attributes.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Calculate the distances between the nodes as the edge's weight.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Solve TSP using Christofides algorithm.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Highlight the closest edges on each node only.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Draw the route.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Print the route.</p>

  <p class="body">Figure A.1 shows the solution for this TSP.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/APPA_F01_Khamis.jpg"/></p>

    <p class="figurecaption">Figure A.1 Solving TSP using Christofides algorithm implemented in NetworkX. The found route is 0, 10, 7, 2, 6, 1, 15, 14, 5, 17, 4, 9, 12, 18, 3, 19, 16, 8, 11, 13, 0.</p>
  </div>

  <p class="body">NetworkX supports a variety of graph search algorithms and can perform network analyses using packages within the geospatial Python ecosystem.</p>

  <h3 class="fm-head1" id="heading_id_13">A.3.2 OSMnx</h3>

  <p class="body"><a class="url" href="https://osmnx.readthedocs.io/en/stable/">OSMnx</a> is a Python library developed to ease the process of retrieving and manipulating data from <a class="url" href="https://www.openstreetmap.org">OpenStreetMap</a> (OSM). It offers the ability to download the data (filtered) from OSM and returns the network as a NetworkX graph data structure. It is a free and open source geographic data for the world.</p>

  <p class="body">You can install OSMnx with <code class="fm-code-in-text">conda</code>:</p>
  <pre class="programlisting">$ conda config --prepend channels conda-forge
$ conda create -n ox --strict-channel-priority osmnx
$ conda activate ox</pre>

  <p class="body">OSMnx can be used to convert a text descriptor of a place into a NetworkX graph. Let’s use Times Square in New York City as an example in the following continuation of listing A.2.</p>
  <pre class="programlisting">import osmnx as ox
  
place_name = "Times Square, NY"                                 <span class="fm-combinumeral">①</span>
  
graph = ox.graph_from_address(place_name, network_type='drive') <span class="fm-combinumeral">②</span>
  
ox.plot_graph(graph,figsize=(10,10))                            <span class="fm-combinumeral">③</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Name of the place or point of interest</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> NetworkX graph of the named place</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Plot the graph.</p>

  <p class="body">Figure A.2 shows the graph of Times Square based on driving mode.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/APPA_F02_Khamis.jpg"/></p>

    <p class="figurecaption">Figure A.2 Times Square graph with drivable streets</p>
  </div>

  <p class="body"><code class="fm-code-in-text">network_type</code> allows you to select the type of street network based on the mobility mode: <code class="fm-code-in-text">all_private</code>, <code class="fm-code-in-text">all</code>, <code class="fm-code-in-text">bike</code>, <code class="fm-code-in-text">drive</code>, <code class="fm-code-in-text">drive_service</code>, or <code class="fm-code-in-text">walk</code>. You can highlight all the one-way edges in the Times Square street network using these two lines of code:</p>
  <pre class="programlisting">ec = ['y' if data['oneway'] else 'w' for u, v, key, data in graph.edges(keys=True, data=True)]
fig, ax = ox.plot_graph(graph, figsize=(10,10), node_size=0, edge_color=ec, edge_linewidth=1.5, edge_alpha=0.7)</pre>

  <p class="body">Various properties of the graph can be examined, such as the graph type, edge (road) types, CRS projection, etc. For example, you can print the graph type using <code class="fm-code-in-text">type(graph)</code> and extract the nodes and edges of the graph as separate structures as follows:</p>
  <pre class="programlisting">nodes, edges = o.graph_to_gdfs(graph)
nodes.head(5)</pre>

  <p class="body">We can further drill down to examine each individual node or edge.</p>
  <pre class="programlisting">list(graph.nodes(data=True))[1]
list(graph.edges(data=True))[0]</pre>

  <p class="body">You can also retrieve the street types for the graph:</p>
  <pre class="programlisting">print(edges['highway'].value_counts())</pre>

  <p class="body">Running the preceding code line gives the following statistics about the Times Square road network:</p>
  <pre class="programlisting">secondary                      236
residential                    120
primary                         83
unclassified                    16
motorway_link                   12
tertiary                        10
motorway                         7
living_street                    3
[unclassified, residential]      1
[motorway_link, primary]         1
trunk                            1</pre>

  <p class="body">More statistics can be generated using <code class="fm-code-in-text">osmnx.basic_stats(graph)</code>.</p>

  <p class="body">GeoDataFrames can be easily converted to MultiDiGraphs by using <code class="fm-code-in-text">osmnx.graph_from_gdfs</code> as follows:</p>
  <pre class="programlisting">new_graph = ox.graph_from_gdfs(nodes,edges)
ox.plot_graph(new_graph,figsize=(10,10))</pre>

  <p class="body">This results in the same road network shown in figure A.2. You can also save the street network in different formats as follows:</p>
  <pre class="programlisting">ox.plot_graph(graph, figsize=(10,10), show=False, save=True, close=True, 
filepath='./data/TimesSquare.png')                                    <span class="fm-combinumeral">①</span>
ox.plot_graph(graph, figsize=(10,10), show=False, save=True, close=True, 
filepath='./data/TimesSquare.svg')                                    <span class="fm-combinumeral">②</span>
ox.save_graph_xml(graph, filepath='./data/TimesSquare.osm')           <span class="fm-combinumeral">③</span>
ox.save_graph_geopackage(graph, filepath='./data/TimesSquare.gpkg')   <span class="fm-combinumeral">④</span>
ox.save_graphml(graph, filepath='./data/TimesSquare.graphml')         <span class="fm-combinumeral">⑤</span>
ox.save_graph_shapefile(graph, filepath='./data/TimesSquare')         <span class="fm-combinumeral">⑥</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Save the street network as a PNG.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Save the street network as an SVG.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Save the graph to disk as an .osm XML file.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Save the street network as a GeoPackage file for GIS</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Save the street network as a GraphML file for OSMnx, NetworkX, or Gephi.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Save the graph as a shapefile.</p>

  <h3 class="fm-head1" id="heading_id_14">A.3.3 GeoPandas</h3>

  <p class="body"><a class="url" href="https://geopandas.org/en/stable/index.html">GeoPandas</a> is an extension to Pandas that handles geospatial data by extending the datatypes of Pandas and the ability to query and manipulate spatial data. It provides tools for reading, writing, and manipulating geospatial data, as well as for visualizing and mapping data on a map. You can install GeoPandas using pip or conda as follows:</p>
  <pre class="programlisting">$conda install geopandas or $pip install geopandas</pre>

  <p class="body">GeoPandas can handle different geospatial data formats such as shapefiles (.shp), CSV (comma separated values), GeoJSON, ESRI JSON, GeoPackage (.gpkg), GML, GPX (GPS exchange format), and KML (Keyhole Markup Language). For example, let’s assume we want to read Ontario’s health region data based on a shapefile that can be downloaded from the Ontario data catalogue included in the book’s GitHub repo (in the appendix B data folder). A shapefile is a popular geospatial data format for storing vector data (such as points, lines, and polygons). It is a widely used format for storing GIS data, and it’s supported by many GIS software packages, including ArcGIS and QGIS. A shapefile is actually a collection of several files with different extensions, including the following:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">.shp</i>—The main file, which contains the geospatial data (points, lines, or polygons)</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">.shx</i>—The index file, which allows for faster access to the data in the .shp file</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">.dbf</i>—The attribute file, which contains the attribute data (non-geographic information) for each feature in the .shp file</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">.prj</i>—The projection file, which defines the coordinate system and projection information for the data in the .shp file</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">.sbx</i>—A spatial index of the features</p>
    </li>
  </ul>

  <p class="body">The following continuation of listing A.2 shows how to read this geospatial data from <a class="url" href="https://data.ontario.ca/dataset/ontario-s-health-region-geographic-data">https://data.ontario.ca/dataset/ontario-s-health-region-geographic-data</a>, which is stored in the book’s GitHub repo:</p>
  <pre class="programlisting">import geopandas as gpd
import requests
import os
  
base_url = "https://raw.githubusercontent.com/Optimization-Algorithms-
<span class="fm-code-continuation-arrow">➥</span>Book/Code-Listings/05766c64c5e83dcd6788cc4415b462e2f82e0ccf/
<span class="fm-code-continuation-arrow">➥</span>Appendix%20B/data/OntarioHealth/"                                 <span class="fm-combinumeral">①</span>
  
files = ["Ontario_Health_Regions.shp", "Ontario_Health_Regions.shx",
<span class="fm-code-continuation-arrow">➥</span> "Ontario_Health_Regions.dbf", "Ontario_Health_Regions.prj"]      <span class="fm-combinumeral">②</span>
  
for file in files:                                                  <span class="fm-combinumeral">③</span>
    response = requests.get(base_url + file)                        <span class="fm-combinumeral">③</span>
    with open(file, 'wb') as f:                                     <span class="fm-combinumeral">③</span>
        f.write(response.content)                                   <span class="fm-combinumeral">③</span>
  
ontario =  gpd.read_file("Ontario_Health_Regions.shp")              <span class="fm-combinumeral">④</span>
 
for file in files:                                                  <span class="fm-combinumeral">⑤</span>
    os.remove(file)                                                 <span class="fm-combinumeral">⑤</span>
  
print(ontario.head())                                               <span class="fm-combinumeral">⑥</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define the base URL for the raw files.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Files associated with the shapefile.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Temporarily download the files from the specified URL.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Read the shapefile with geopandas.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Cleanup/remove the downloaded files.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Print the first n rows.</p>

  <p class="body">The complete version of <a class="url" href="https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.2_Graph_libraries.ipynb">listing A.2</a> is available in the book’s GitHub repo.</p>

  <h3 class="fm-head1" id="heading_id_15">A.3.4 contextily</h3>

  <p class="body"><a class="url" href="https://contextily.readthedocs.io/en/latest/">contextily</a> is a Python library for adding contextual basemaps to plots created with libraries such as Matplotlib, Plotly, and others. For example, contextily can be used to add context when we render the Ontario health region data, as follows:</p>
  <pre class="programlisting">#!pip install contextily
import contextily as ctx
ax=ontario.plot(cmap='jet', edgecolor='black', column='REGION', alpha=0.5,
<span class="fm-code-continuation-arrow">➥</span> legend=True, figsize=(10,10))
ax.set_title("EPSG:4326, WGS 84")
ctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik,
<span class="fm-code-continuation-arrow">➥</span> crs=ontario.crs.to_string())</pre>

  <p class="body">contextily supports several different sources for basemaps, including the following commonly used sources:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">OpenStreetMap (OSM)</i>—This is the default source for contextily. It is a free and open source map service that provides a variety of different styles, including the default Mapnik style and others such as Humanitarian and Cycle.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Stamen</i>—This source provides a variety of different map styles, including Toner, Terrain, and Watercolor.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Mapbox</i>—This source provides a variety of different map styles, including Streets, Outdoors, and Satellite. It requires an API key to use.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">MapQuest</i>—This source provides a variety of different map styles, including OSM and Aerial. It requires an API key to use.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Here</i>—This source provides a variety of different map styles, including Normal Day and Normal Night. It requires an API key to use.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Google Maps</i>—This source provides a variety of different map styles, including Roadmap, Satellite, and Terrain. It requires an API key to use.</p>
    </li>
  </ul>

  <h3 class="fm-head1" id="heading_id_16">A.3.5 Folium</h3>

  <p class="body"><a class="url" href="https://python-visualization.github.io/folium/">Folium</a> is a library for creating interactive maps in Python using the Leaflet.js library. It provides tools for reading, writing, and manipulating geospatial data, as well as for visualizing and mapping data on a map. Folium can be used to create static or dynamic maps, as well as to customize the appearance and behavior of the map. The following continuation of listing A.2 shows how to use Folium to visualize Ontario Health regions on a map:</p>
  <pre class="programlisting">#!pip install folium
import folium
  
ontario = ontario.to_crs(epsg=4326)                               <span class="fm-combinumeral">①</span>
  
m = folium.Map(location=[43.67621,-79.40530],zoom_start=7,
<span class="fm-code-continuation-arrow">➥</span> tiles='cartodbpositron', scrollWheelZoom=False, dragging=True) <span class="fm-combinumeral">②</span>
  
for index, row in ontario.iterrows():                             <span class="fm-combinumeral">③</span>
    sim_geo = gpd.GeoSeries(row['geometry']).simplify(tolerance=0.001)
    geo_j = sim_geo.to_json()
    geo_j = folium.GeoJson(data=geo_j,
<span class="fm-code-continuation-arrow">➥</span> name=row['REGION'],style_function=lambda x: {'fillColor': 'black'})
    folium.Popup(row['REGION']).add_to(geo_j)
    geo_j.add_to(m)
  
m                                                                 <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Transform geometries to a new coordinate reference system (CRS).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Set starting location, initial zoom, and base layer source.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Simplify each region's polygon, as intricate details are unnecessary.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Render the map.</p>

  <p class="body">The “<a class="url" href="https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.2_Graph_libraries.ipynb">Listing A.2_Graph_libraries.ipynb</a>” notebook available in the book’s GitHub repo provides examples of different ways of visualizing geospatial data, such as chloropleth map, cartogram map, bubble map, hexagonal binning, heat map, and cluster map.</p>

  <h3 class="fm-head1" id="heading_id_17">A.3.6 Other libraries and tools</h3>

  <p class="body">The following is a non-exhaustive list of other useful libraries and tools for working on geospatial data, graphs, and networks:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://pyrosm.readthedocs.io/en/latest/">Pyrosm</a>—This is another Python library for reading OpenStreetMap from Protocolbuffer Binary Format files (*.osm.pbf). It can be used to download and read OpenStreetMap data, extract features such as roads, buildings, and points of interest, and analyze and visualize the data. The main difference between Pyrosm and OSMnx is that OSMnx reads the data using an OverPass API, whereas Pyrosm reads the data from local OSM data dumps that are downloaded from the Protocolbuffer Binary Format file (*.osm.pbf) data providers (Geofabrik, BBBike) and converts it into GeoPandas GeoDataFrames. This makes it possible to parse OSM data faster and makes it more feasible to extract data covering large regions.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://udst.github.io/pandana/">Pandana</a>—This is a Python library for network analysis that uses contraction hierarchies to calculate super-fast travel accessibility metrics and shortest paths.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://geopy.readthedocs.io/en/stable/">GeoPy</a>—This is a Python client for several popular geocoding web services.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://graphviz.org/">Graphviz</a>—This is a library for creating visualizations of graphs and tree structures in Python. It provides tools for defining the structure of a graph, as well as for rendering the graph in various formats, such as PNG, PDF, and SVG. Graphviz is a useful tool for visualizing algorithms that operate on graphs, such as graph search algorithms and graph traversal algorithms.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://gephi.org/">Gephi</a>—This is a tool for visualizing and analyzing graphs and networks. It provides a graphical user interface for defining and customizing the appearance of graphs and diagrams, as well as for visualizing algorithms and data structures. Gephi can be used to visualize algorithms that operate on graph data, such as graph search algorithms and shortest path algorithms.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://cytoscape.org/">Cytoscape</a>—This is an open-source software platform for visualizing complex networks and integrating these with any type of attribute data.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/jupyter-widgets/ipyleaflet">ipyleaflet</a>—This is an interactive widgets library that is based on ipywidgets. ipywidgets, also known as jupyter-widgets or simply widgets, are interactive HTML widgets for Jupyter notebooks and the IPython kernel. Ipyleaflet brings mapping capabilities to the notebook and JupyterLab.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://hvplot.holoviz.org/">hvPlot</a>— This is a Python library that provides a high-level plotting API built on top of the HoloViews library. It can be used with GeoPandas to create interactive visualizations of geospatial data.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/jwass/mplleaflet">mplleaflet</a>—This is another <code class="fm-code-in-text">leaflet</code>-based library, but it plays nicely with <code class="fm-code-in-text">matplotlib</code>.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://scitools.org.uk/cartopy/docs/latest/">Cartopy</a>—Cartopy is a library for creating maps and geospatial plots in Python.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/andrea-cuttone/geoplotlib">geoplotlib</a>—geoplotlib is a library for creating maps and visualizations in Python. It provides tools for styling and customizing map elements, as well as for overlaying data on top of maps. geoplotlib can be used to create static or interactive maps and supports a variety of map projections and coordinate systems.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://shapely.readthedocs.io/en/stable/">Shapely</a>—This is an open source Python library for performing geometric operations on objects in the Cartesian plane.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://deck.gl/">deck.gl</a>—This is an open source JavaScript library for WebGL-powered large dataset visualization.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://kepler.gl/">kepler.gl</a>—This is a powerful open source geospatial analysis tool for large-scale data sets.</p>
    </li>
  </ul>

  <h2 class="fm-head" id="heading_id_18">A.4 Metaheuristics optimization libraries</h2>

  <p class="body">There are several libraries in Python that provide implementations of different metaheuristic optimization algorithms. The following subsections cover some commonly used libraries.</p>

  <h3 class="fm-head1" id="heading_id_19">A.4.1 PySwarms</h3>

  <p class="body"><a class="url" href="https://pyswarms.readthedocs.io/en/latest/index.html">PySwarms</a> is a library for implementing swarm intelligence algorithms in Python. It provides tools for defining, training, and evaluating swarm intelligence models, as well as for visualizing the optimization process. PySwarms supports a variety of swarm intelligence algorithms, including particle swarm optimization (PSO) and ant colony optimization (ACO). The next listing shows the steps for solving a function optimization problem using PSO implemented in PySwarms.</p>

  <p class="fm-code-listing-caption">Listing A.3 Solving function optimization using PSO implemented in PySwarms</p>
  <pre class="programlisting">#!pip install pyswarms
import pyswarms as ps
from pyswarms.utils.functions import single_obj as fx
from pyswarms.utils.plotters import plot_cost_history, plot_contour,
<span class="fm-code-continuation-arrow">➥</span> plot_surface
from pyswarms.utils.plotters.formatters import Mesher, Designer
import matplotlib.pyplot as plt
from IPython.display import Image                                     <span class="fm-combinumeral">①</span>
  
options = {'c1':0.5, 'c2':0.3, 'w':0.9}                               <span class="fm-combinumeral">②</span>
optimizer = ps.single.GlobalBestPSO(n_particles=50, dimensions=2,
  
<span class="fm-code-continuation-arrow">➥</span> options=options)                                                   <span class="fm-combinumeral">③</span>
  
optimizer.optimize(fx.sphere, iters=100)                              <span class="fm-combinumeral">④</span>
  
plot_cost_history(optimizer.cost_history)                             <span class="fm-combinumeral">⑤</span>
plt.show()
  
m = Mesher(func=fx.sphere, limits=[(-1,1), (-1,1)])                   <span class="fm-combinumeral">⑥</span>
d = Designer(limits=[(-1,1), (-1,1), (-0.1,1)], label=['x-axis', 'y-axis',
<span class="fm-code-continuation-arrow">➥</span> 'z-axis'])                                                         <span class="fm-combinumeral">⑦</span>
  
animation = plot_contour(pos_history=optimizer.pos_history, mesher=m,
<span class="fm-code-continuation-arrow">➥</span> designer=d, mark=(0,0))                                            <span class="fm-combinumeral">⑧</span>
animation.save('solution.gif', writer='imagemagick', fps=10)
Image(url='solution.gif')                                             <span class="fm-combinumeral">⑨</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import the Image class to enable the display of images within the notebook environment.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Set up PSO as an optimizer with 50 particles and predefined parameters.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Solve the function optimization problem using PSO.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Set up the sphere unimodal function to be optimized using PSO, and set up the number of iterations.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Plot the cost.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Plot the sphere function's mesh for better plots.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Adjust the figure limits.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Generate animation for the solution history on a contour.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑨</span> Render the animation.</p>

  <h3 class="fm-head1" id="heading_id_20">A.4.2 Scikit-opt</h3>

  <p class="body"><a class="url" href="https://scikit-opt.github.io/">Scikit-opt</a> is an optimization library that provides a simple and flexible interface for defining and running optimization problems with various metaheuristics, such as genetic algorithms, particle swarm optimization, simulated annealing, ant colony algorithm, immune algorithm, and artificial fish swarm algorithm. Scikit-opt can be used to solve both continuous and discrete problems. The following continuation of listing A.3 shows the steps for solving a function optimization problem using scikit-opt:</p>
  <pre class="programlisting">#!pip install scikit-opt
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sko.SA import SA
  
obj_func = lambda x: np.sin(x[0]) * np.cos(x[1])                    <span class="fm-combinumeral">①</span>
  
sa = SA(func=obj_func, x0=np.array([-3, -3]), T_max=1, T_min=1e-9, L=300,
<span class="fm-code-continuation-arrow">➥</span> max_stay_counter=150)                                            <span class="fm-combinumeral">②</span>
best_x, best_y = sa.run()
print('best_x:', best_x, 'best_y', best_y)
  
plt.plot(pd.DataFrame(sa.best_y_history).cummin(axis=0))            <span class="fm-combinumeral">③</span>
plt.show()</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define a multimodal function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Solve the problem using simulated annealing (SA).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Print the result.</p>

  <p class="body">Let’s consider the TSP instance shown in figure A.3. In this TSP, a travelling salesman must visit 20 major US cities starting from a specific city.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/APPA_F03_Khamis.jpg"/></p>

    <p class="figurecaption">Figure A.3 Travelling salesman problem (TSP) for 20 major US cities</p>
  </div>

  <p class="body">The following continuation of listing A.3 shows the steps for solving this problem using scikit-opt:</p>
  <pre class="programlisting">import numpy as np
import matplotlib.pyplot as plt
from sko.PSO import PSO_TSP
  
num_points = len(city_names)                                            <span class="fm-combinumeral">①</span>
points_coordinate = city_names                                          <span class="fm-combinumeral">①</span>
pairwise_distances = distances                                          <span class="fm-combinumeral">①</span>
  
def cal_total_distance(routine):                                        <span class="fm-combinumeral">②</span>
    num_points, = routine.shape
    return sum([pairwise_distances[routine[i % num_points], routine[(i + 1)
<span class="fm-code-continuation-arrow">➥</span> % num_points]] for i in range(num_points)])
  
pso_tsp = PSO_TSP(func=cal_total_distance, n_dim=num_points, size_pop=200,
<span class="fm-code-continuation-arrow">➥</span> max_iter=800, w=0.8, c1=0.1, c2=0.1)                                 <span class="fm-combinumeral">③</span>
best_points, best_distance = pso_tsp.run()                              <span class="fm-combinumeral">③</span>
best_points_ = np.concatenate([best_points, [best_points[0]]])
  
print('best_distance', best_distance)                                   <span class="fm-combinumeral">④</span>
print('route', best_points_)                                            <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define the TSP problem.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Calculate the total distance.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Solve the problem using PSO.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Print the solution.</p>

  <h3 class="fm-head1" id="heading_id_21">A.4.3 NetworkX</h3>

  <p class="body">NetworkX, introduced in the previous section, provides approximations of graph properties and heuristic methods for optimization. An example of these heuristics algorithms is simulated annealing. The following continuation of listing A.3 shows the steps for solving TSP using simulated annealing implemented in NetworkX:</p>
  <pre class="programlisting">#!pip install networkx
import matplotlib.pyplot as plt
import networkx as nx
from networkx.algorithms import approximation as approx
  
G=nx.Graph()                                                              <span class="fm-combinumeral">①</span>
  
for i in range(len(city_names)):                                          <span class="fm-combinumeral">②</span>
    for j in range(1,len(city_names)):                                    <span class="fm-combinumeral">②</span>
        G.add_weighted_edges_from({(city_names[i], city_names[j],         <span class="fm-combinumeral">②</span>
<span class="fm-code-continuation-arrow">➥</span> distances[i][j])})                                                     <span class="fm-combinumeral">②</span>
        G.remove_edges_from(nx.selfloop_edges(G))                         <span class="fm-combinumeral">②</span>
  
pos = nx.spring_layout(G)                                                 <span class="fm-combinumeral">③</span>
  
cycle = approx.simulated_annealing_tsp(G, "greedy", source=city_names[0]) <span class="fm-combinumeral">④</span>
edge_list = list(nx.utils.pairwise(cycle))                                <span class="fm-combinumeral">④</span>
cost = sum(G[n][nbr]["weight"] for n, nbr in nx.utils.pairwise(cycle))    <span class="fm-combinumeral">④</span>
  
print("The route of the salesman is:", cycle, "with cost of ", cost)      <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Create a graph.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Add weighted edges to the graph, and remove selfloop edges.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Define pos as a dictionary of positions using the Fruchterman-Reingold force-directed algorithm.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Solve TSP using simulated annealing.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Print the route and the cost.</p>

  <h3 class="fm-head1" id="heading_id_22">A.4.4 Distributed evolutionary algorithms in Python (DEAP)</h3>

  <p class="body"><a class="url" href="https://github.com/deap/deap">DEAP</a> is a library for implementing genetic algorithms in Python. It provides tools for defining, training, and evaluating genetic algorithm models, as well as for visualizing the optimization process. DEAP supports a variety of genetic algorithm techniques, including selection, crossover, and mutation. The following continuation of listing A.3 shows the steps for solving TSP using simulated annealing implemented in DEAP:</p>
  <pre class="programlisting">#!pip install deap
from deap import base, creator, tools, algorithms
import random
import numpy as np
  
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))                <span class="fm-combinumeral">①</span>
creator.create("Individual", list, fitness=creator.FitnessMin)             <span class="fm-combinumeral">①</span>
  
toolbox = base.Toolbox()                                                   <span class="fm-combinumeral">②</span>
toolbox.register("permutation", random.sample, range(len(city_names)),     <span class="fm-combinumeral">②</span>
<span class="fm-code-continuation-arrow">➥</span> len(city_names))                                                        <span class="fm-combinumeral">②</span>
toolbox.register("individual", tools.initIterate, creator.Individual,      <span class="fm-combinumeral">②</span>
<span class="fm-code-continuation-arrow">➥</span> toolbox.permutation)                                                    <span class="fm-combinumeral">②</span>
toolbox.register("population", tools.initRepeat, list, toolbox.individual) <span class="fm-combinumeral">②</span>
  
def eval_tsp(individual):                                                  <span class="fm-combinumeral">③</span>
    total_distance = 0
    for i in range(len(individual)):
        city_1 = individual[i]
        city_2 = individual[(i + 1) % len(individual)]
        total_distance += distances[city_1][city_2]
    return total_distance,
  
toolbox.register("evaluate", eval_tsp)                                     <span class="fm-combinumeral">④</span>
toolbox.register("mate", tools.cxOrdered)                                  <span class="fm-combinumeral">⑤</span>
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.05)            <span class="fm-combinumeral">⑥</span>
toolbox.register("select", tools.selTournament, tournsize=3)               <span class="fm-combinumeral">⑦</span>
  
pop = toolbox.population(n=50)                                             <span class="fm-combinumeral">⑧</span>
hof = tools.HallOfFame(1)                                                  <span class="fm-combinumeral">⑨</span>
stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("avg", np.mean)
stats.register("min", np.min)
stats.register("max", np.max)
  
pop, log = algorithms.eaSimple(pop, toolbox, cxpb=0.5, mutpb=0.2, ngen=50,
<span class="fm-code-continuation-arrow">➥</span> stats=stats, halloffame=hof,verbose=True)                               <span class="fm-combinumeral">⑩</span>
  
best_individual = hof[0] 
print("Best solution:")                                                    <span class="fm-combinumeral">⑪</span>
print("  - Fitness: ", eval_tsp(best_individual))                          <span class="fm-combinumeral">⑪</span>
print("  - Route: ", [city_names[i] for i in best_individual])             <span class="fm-combinumeral">⑪</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Create a fitness function that minimizes the total distance</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Create the genetic operator functions.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Calculate the route length.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Set the evaluation function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Set an ordered crossover.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Set the shuffle mutation with probability 0.05.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Select the best individual among three randomly chosen individuals.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Set the population size.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑨</span> Set the hall of fame to select the best individual that ever lived in the population during the evolution.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑩</span> Solve the problem using a simple evolutionary algorithm.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑪</span> Print the solution.</p>

  <p class="body">DEAP includes several built-in algorithms such as genetic algorithm (GA), evolutionary strategy (ES), genetic programming (GA), estimation of distribution algorithms (EDA), and particle swarm optimization (PSO).</p>

  <h3 class="fm-head1" id="heading_id_23">A.4.5 OR-Tools</h3>

  <p class="body">As previously mentioned, <a class="url" href="https://developers.google.com/optimization">OR-Tools</a> (Operations Research Tools) is an open source library for optimization and constraint programming developed by Google. The following continuation of listing A.3 shows the steps for solving TSP using tabu search implemented in OR-Tools:</p>
  <pre class="programlisting">#!pip install --upgrade --user ortools
import numpy as np
import matplotlib.pyplot as plt
from ortools.constraint_solver import pywrapcp
from ortools.constraint_solver import routing_enums_pb2
  
distances2=np.asarray(distances, dtype = 'int')                           <span class="fm-combinumeral">①</span>
  
data = {}                                                                 <span class="fm-combinumeral">②</span>
data['distance_matrix'] = distances                                       <span class="fm-combinumeral">②</span>
data['num_vehicles'] = 1                                                  <span class="fm-combinumeral">②</span>
data['depot'] = 0                                                         <span class="fm-combinumeral">②</span>
  
manager = pywrapcp.RoutingIndexManager(len(data['distance_matrix']),
<span class="fm-code-continuation-arrow">➥</span> data['num_vehicles'], data['depot'])                                   <span class="fm-combinumeral">③</span>
routing = pywrapcp.RoutingModel(manager)                                  <span class="fm-combinumeral">③</span>
def distance_callback(from_index, to_index):                              <span class="fm-combinumeral">④</span>
    from_node = manager.IndexToNode(from_index)
    to_node = manager.IndexToNode(to_index)
    return data['distance_matrix'][from_node][to_node]
  
transit_callback_index = routing.RegisterTransitCallback(distance_callback)   
  
routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
  
search_parameters = pywrapcp.DefaultRoutingSearchParameters()
search_parameters.local_search_metaheuristic = (
    routing_enums_pb2.LocalSearchMetaheuristic.TABU_SEARCH)               <span class="fm-combinumeral">⑤</span>
search_parameters.time_limit.seconds = 30
search_parameters.log_search = True
  
def print_solution(manager, routing, solution):                           <span class="fm-combinumeral">⑥</span>
    print('Objective: {} meters'.format(solution.ObjectiveValue()))
    index = routing.Start(0)
    plan_output = 'Route for vehicle 0:\n'
    route_distance = 0
    while not routing.IsEnd(index):
        plan_output += ' {} -&gt;'.format(manager.IndexToNode(index))
        previous_index = index
        index = solution.Value(routing.NextVar(index))
        route_distance += routing.GetArcCostForVehicle(previous_index,
<span class="fm-code-continuation-arrow">➥</span> index, 0)
    plan_output += ' {}\n'.format(manager.IndexToNode(index))
    print(plan_output)
    plan_output += 'Route distance: {}meters\n'.format(route_distance)
  
solution = routing.SolveWithParameters(search_parameters)
if solution:
    print_solution(manager, routing, solution)</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Convert a float array into an integer array for OR_Tools.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Define the problem data.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Define a constraint programming solver.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Get the distance between the cities.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Set up tabu search as a local search metaheuristic.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Print the solution.</p>

  <p class="body">The OR-Tools library also implements some metaheuristics but not as many as dedicated metaheuristics frameworks like DEAP. Examples include simulated annealing (SA), tabu search (TS), and guided local search (GLS).</p>

  <h3 class="fm-head1" id="heading_id_24">A.4.6 Other libraries</h3>

  <p class="body">The following non-exhaustive list identifies other useful libraries and tools for solving optimization problems using metaheuristics:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/perrygeo/simanneal">simanneal</a>—This is an open source Python module for simulated annealing. Listing A.3 shows the steps for solving TSP using simulated annealing implemented in simanneal.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://pymoo.org/algorithms/moo/nsga2.html">Non-dominated Sorting Genetic Algorithm (NSGA-II)</a>—This is a solid multi-objective algorithm, widely used in many real-world applications. The algorithm is designed to find a set of solutions, called the Pareto front, which represents the trade-off between multiple conflicting objectives. NSGA-II implementations are available in pymoo and DEAP.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://pygad.readthedocs.io/en/latest/">Python genetic algorithm (PyGAD)</a>—This is a library for implementing genetic algorithms and differential evolution in Python. It provides tools for defining, training, and evaluating genetic algorithm models, as well as for visualizing the optimization process. PyGAD supports a variety of genetic algorithm techniques, including selection, crossover, and mutation.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://leap-gmu.readthedocs.io/en/latest/index.html">Library for Evolutionary Algorithms in Python (LEAP)</a>—This is a general-purpose evolutionary algorithm (EA) package that is simple and easy to use. It provides a high-level abstraction for defining and running EAs.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://pyevolve.sourceforge.net/index.html">Pyevolve</a>—This is a Python library that provides a simple and flexible API for implementing and running genetic algorithms.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/danielwilczak101/EasyGA">Genetic algorithms made easy (EasyGA)</a>—This is another Python library for genetic algorithms with several built-in genetic operators, such as selection, crossover, and mutation. EasyGA and Pyevolve are simple libraries with less functionality and fewer predefined problems than other libraries such as DEAP and Pymoo.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://mealpy.readthedocs.io/en/latest/index.html">MEAPLY</a>—This is a Python library for population metaheuristic algorithms.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://pypi.org/project/swarmlib/">swarmlib</a>—This library implements several swarm optimization algorithms and visualizes their (intermediate) solutions.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://rwuilbercq.github.io/Hive/">Hive</a>—This is a swarm-based optimization algorithm based on the intelligent foraging behavior of honeybees. Hive implements the artificial bee colony (ABC) algorithm.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://aco-pants.readthedocs.io/en/latest/">Pants</a>—This is a Python3 implementation of the ant colony optimization (ACO) metaheuristics.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://mlrose.readthedocs.io/en/stable/index.html">mlrose</a>—This library provides implementations of hill climb, random hill climb, simulated annealing, and genetic algorithm.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Mixed integer distributed ant colony optimization (<a class="url" href="http://www.midaco-solver.com/index.php/about">MIDACO</a>)—This is a numerical high-performance library based on ACO for solving single- and multi-objective optimization problems.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://www.nvidia.com/en-us/ai-data-science/products/cuopt/">cuOpt</a>: This is a Python SDK and cloud service provided by NVIDIA that provides access to GPU-accelerated logistics solvers relying on metaheuristics to calculate complex vehicle routing problems with a wide range of constraints.</p>
    </li>
  </ul>

  <p class="body">“<a class="url" href="https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.3_Metaheuristics_libraries.ipynb">Listing A.3_Metaheuristics_libraries.ipynb</a>,” included in the book’s GitHub repo, shows how to use some of these metaheuristics libraries.</p>

  <h2 class="fm-head" id="heading_id_25">A.5 Machine learning libraries</h2>

  <p class="body">Machine learning can be used to solve discrete optimization problems where an ML model is trained to output solutions directly from the input, usually represented as a graph. To train the model, the problem graph needs to be turned first into a feature vector using graph embedding/representation learning methods. Several Python libraries can be used for graph embedding and for solving optimization problems. The following subsections shed some light on the commonly used libraries.</p>

  <h3 class="fm-head1" id="heading_id_26">A.5.1 node2vec</h3>

  <p class="body"><a class="url" href="https://snap.stanford.edu/node2vec/">node2vec</a> is an algorithmic framework for learning low-dimensional representations of nodes in a graph. Given any graph, it can learn continuous feature representations for the nodes, which can then be used for various downstream ML tasks.</p>

  <p class="body">To install node2vec, use the following command:</p>
  <pre class="programlisting">$ pip install node2vec</pre>

  <p class="body">Alternatively, you can install node2vec by cloning the repository from GitHub and running the setup.py file:</p>
  <pre class="programlisting">$ git clone https://github.com/aditya-grover/node2vec
$ cd node2vec
$ pip install -e .</pre>

  <p class="body">The following code illustrates how to use node2vec to learn low-dimensional representations of nodes in a graph based on Zachary’s karate club dataset. This is a graph-based dataset commonly used in network analysis and graph-based machine learning algorithms. It represents a social network that contains information about the relationships between 34 individuals in a karate club. It was created and first described by Wayne W. Zachary in his paper “An Information Flow Model for Conflict and Fission in Small Groups” in 1977, and it has since become a popular benchmark dataset for evaluating graph-based machine learning algorithms.</p>

  <p class="fm-code-listing-caption">Listing A.4 A node2vec example</p>
  <pre class="programlisting">import networkx as nx
from node2vec import Node2Vec
  
G = nx.karate_club_graph()                                                <span class="fm-combinumeral">①</span>
  
node2vec = Node2Vec(G, dimensions=64, walk_length=30, num_walks=200,
<span class="fm-code-continuation-arrow">➥</span> workers=4)                                                             <span class="fm-combinumeral">②</span>
  
model = node2vec.fit(window=10, min_count=1, batch_words=4)               <span class="fm-combinumeral">③</span>
  
representations_all = model.wv.vectors                                    <span class="fm-combinumeral">④</span>
   
representations_specific = model.wv['1']                                  <span class="fm-combinumeral">⑤</span>
  
print(representations_specifi)                                            <span class="fm-combinumeral">⑥</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Create a sample graph</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Create an instance of the Node2Vec class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Learn the representations.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Get the representations of all nodes.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Get the representations of a specific node.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Print the representations of a specific node.</p>

  <p class="body">You can visualize the generated low-dimensional representations using a dimensionality reduction technique such as t-SNE to project the representations onto a 2D or 3D space, and then use a visualization library such as Matplotlib to plot the nodes in this space. t-distributed stochastic neighbor embedding (t-SNE) is a statistical method for visualizing high-dimensional data by giving each data point a location in a 2D or 3D map. Here is an example:</p>
  <pre class="programlisting">from sklearn.manifold import TSNE                                         <span class="fm-combinumeral">①</span>
import matplotlib.pyplot as plt
  
tsne = TSNE(n_components=2, learning_rate='auto', init='random',
<span class="fm-code-continuation-arrow">➥</span> perplexity=3)                                                          <span class="fm-combinumeral">②</span>
reduced_representations = tsne.fit_transform(representations_all)         <span class="fm-combinumeral">②</span>
  
plt.scatter(reduced_representations[:, 0], reduced_representations[:, 1]) <span class="fm-combinumeral">③</span>
plt.show()                                                                <span class="fm-combinumeral">③</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import the required libraries.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Perform t-SNE dimensionality reduction.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Plot the nodes.</p>

  <p class="body">Running this code gives the visualization in figure A.4.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/APPA_F04_Khamis.jpg"/></p>

    <p class="figurecaption">Figure A.4 t-SNE-based visualization for the low-dimensional representations generated by node2vec</p>
  </div>

  <h3 class="fm-head1" id="heading_id_27">A.5.2 DeepWalk</h3>

  <p class="body">DeepWalk is a random walk-based method for graph embedding based on representation learning. For this example, we’ll use a DeepWalk module provided by the <a class="url" href="https://karateclub.readthedocs.io/en/latest/">Karate Club</a> library. This library is an unsupervised machine learning extension for NetworkX. To use DeepWalk, you can install Karate Club as follows:</p>
  <pre class="programlisting">$ pip install karateclub</pre>

  <p class="body">The following continuation of listing A.4 illustrates how to use DeepWalk:</p>
  <pre class="programlisting">from karateclub import DeepWalk, Node2Vec                   <span class="fm-combinumeral">①</span>
from sklearn.decomposition import PCA                       <span class="fm-combinumeral">②</span>
import networkx as nx 
import matplotlib.pyplot as plt
G=nx.karate_club_graph()                                    <span class="fm-combinumeral">③</span>
  
  
model=DeepWalk(dimensions=128, walk_length=100)             <span class="fm-combinumeral">④</span>
model.fit(G)                                                <span class="fm-combinumeral">④</span>
  
embedding=model.get_embedding()                             <span class="fm-combinumeral">⑤</span>
  
officer=[]                                                  <span class="fm-combinumeral">⑥</span>
mr=[]                                                       <span class="fm-combinumeral">⑥</span>
for i in G.nodes:                                           <span class="fm-combinumeral">⑥</span>
  t=G.nodes[i]['club']
  officer.append(True if t=='Officer' else False)
  mr.append(False if t=='Officer' else True)
  
nodes=list(range(len(G)))
X=embedding[nodes]
  
pca=PCA(n_components=2)                                     <span class="fm-combinumeral">⑦</span>
pca_out=pca.fit_transform(X)                                <span class="fm-combinumeral">⑦</span>
  
plt.figure(figsize=(15, 10))                                <span class="fm-combinumeral">⑧</span>
plt.scatter(pca_out[:,0][officer],pca_out[:,1][officer])    <span class="fm-combinumeral">⑧</span>
plt.scatter(pca_out[:,0][mr],pca_out[:,1][mr])              <span class="fm-combinumeral">⑧</span>
plt.show()                                                  <span class="fm-combinumeral">⑧</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import DeepWalk. node2vec is also available.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Import principal component analysis (PCA).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Create the Karate Club graph.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Define the DeepWalk mode, and fit the graph.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Graph embedding.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Retrieve the club membership attribute of each node.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Define the DeepWalk mode, and fit the graph.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Visualize the embedding.</p>

  <h3 class="fm-head1" id="heading_id_28">A.5.3 PyG</h3>

  <p class="body"><a class="url" href="https://www.pyg.org/">PyG</a> (PyTorch Geometric) is a library for implementing graph neural networks in Python using the PyTorch deep learning framework. It provides tools for defining, training, and evaluating graph neural network (GNN) models, as well as for visualizing the optimization process. PyG supports a variety of GNN architectures, including graph convolutional network (GCN) and graph attention networks (GATs).</p>

  <p class="body">You can install PyG as follows:</p>
  <pre class="programlisting">$pip install torch-scatter torch-sparse torch-cluster torch-spline-conv torch-geometric -f https://data.pyg.org/whl/torch-1.13.0+cpu.html</pre>

  <p class="body">The following continuation of listing A.4 shows how you can use PyG to generate Karate Club graph embedding using GCN:</p>
  <pre class="programlisting">import networkx as nx
import matplotlib.pyplot as plt
import torch
from torch_geometric.datasets import KarateClub
from torch_geometric.utils import to_networkx
from torch.nn import Linear
from torch_geometric.nn import GCNConv
  
dataset = KarateClub()                                             <span class="fm-combinumeral">①</span>
data = dataset[0]
  
class GCN(torch.nn.Module):                                        <span class="fm-combinumeral">②</span>
    def __init__(self):
        super().__init__()
        torch.manual_seed(1234)
        self.conv1 = GCNConv(dataset.num_features, 4)
        self.conv2 = GCNConv(4, 4)
        self.conv3 = GCNConv(4, 2)
        self.classifier = Linear(2, dataset.num_classes)
  
    def forward(self, x, edge_index):
        h = self.conv1(x, edge_index)
        h = h.tanh()
        h = self.conv2(h, edge_index)
        h = h.tanh()
        h = self.conv3(h, edge_index)
        h = h.tanh()                                                <span class="fm-combinumeral">③</span>
        out = self.classifier(h)                                    <span class="fm-combinumeral">④</span>
  
        return out, h
  
model = GCN()                                                       <span class="fm-combinumeral">⑤</span>
  
criterion = torch.nn.CrossEntropyLoss()                             <span class="fm-combinumeral">⑥</span>
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)           <span class="fm-combinumeral">⑦</span>
optimizer.zero_grad()
  
for epoch in range(401):
    out, h = model(data.x, data.edge_index)                         <span class="fm-combinumeral">⑧</span>
  
    loss = criterion(out[data.train_mask], data.y[data.train_mask]) <span class="fm-combinumeral">⑨</span>
    loss.backward()                                                 <span class="fm-combinumeral">⑩</span>
    optimizer.step()                                                <span class="fm-combinumeral">⑪</span>
  
h = h.detach().cpu().numpy()                                        <span class="fm-combinumeral">⑫</span>
  
plt.figure(figsize=(15, 10))                                        <span class="fm-combinumeral">⑬</span>
plt.scatter(h[:, 0], h[:, 1], s=140, c=data.y, cmap="Set2")         <span class="fm-combinumeral">⑬</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Use the Karate Club dataset.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Graph Convolutional Network class</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Apply a final (linear) classifier.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Final GNN embedding space</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Define the model.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Define the loss criterion.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Define an optimizer and clear gradient.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Perform a single forward pass.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑨</span> Compute the loss solely based on the training nodes.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑩</span> Derive the gradients.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑪</span> Update the parameters based on the gradients.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑫</span> Convert 'h' from tenser format to the numpy format for visualizing.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑬</span> Visualize the embedding.</p>

  <p class="body">PyG is a well-supported library that provides several features, such as common benchmark datasets (e.g., KarateClub, CoraFull, Amazon, Reddit, Actor), data handling of graphs, mini-batches, data transforms, and learning methods on graphs (e.g., node2vec, MLP, GCN, GAT, GraphSAGE, GraphUNet, DeepGCNLayer, GroupAddRev, and MetaLayer).</p>

  <h3 class="fm-head1" id="heading_id_29">A.5.4 OpenAI Gym</h3>

  <p class="body"><a class="url" href="https://github.com/openai/gym">OpenAI Gym</a> is a toolkit for developing and comparing reinforcement learning algorithms. It gives you access to variety of environments, such as</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Classic control</i>—A variety of classic control tasks</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Box2d</i>—A 2D physics engine</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">MuJoCo</i>—A physics engine that can do detailed, efficient simulations with contacts</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Algorithmic</i>—A variety of algorithmic tasks, such as learning to copy a sequence</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Atari</i>—A variety of Atari video games</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">gym-maze</i>—A simple 2D maze environment where an agent finds its way from the start position to the goal</p>
    </li>
  </ul>

  <p class="body"><a class="url" href="https://gymnasium.farama.org/">Gymnasium</a> is a maintained fork of OpenAI’s Gym library. The following continuation of listing A.4 illustrates how to use OpenAI Gym:</p>
  <pre class="programlisting">#!pip install gym[all]            <span class="fm-combinumeral">①</span>
import gym
env = gym.make('MountainCar-v0')  <span class="fm-combinumeral">②</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Install all included environments.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Create an environment.</p>

  <p class="body">In this simple example, <code class="fm-code-in-text">MountainCar-v0</code> has discrete actions. You can also use <code class="fm-code-in-text">MountainCarCoutinous</code><code class="fm-code-in-text">-V0</code>, which has continuous actions corresponding to the force with which the car is pushed. The complete code listing is available in the book’s GitHub repo, in “<a class="url" href="https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.4_ML_libraries.ipynb">Listing A.4_ML_libraries.ipynb</a>”.</p>

  <h3 class="fm-head1" id="heading_id_30">A.5.5 Flow</h3>

  <p class="body"><a class="url" href="https://flow-project.github.io/">Flow</a><a id="idTextAnchor001"/> is a deep reinforcement learning framework for mixed autonomy traffic. It allows you to run deep RL-based control experiments for traffic microsimulation.</p>

  <p class="body">You can install Flow as follows:</p>
  <pre class="programlisting">$git clone https://github.com/flow-project/flow.git
$cd flow
$conda env create –f environment.yml
$conda activate flow
$python setup.py develop</pre>

  <p class="body">Install Flow within the environment:</p>
  <pre class="programlisting">$pip install –e .</pre>

  <p class="body">Flow enables studying complex, large-scale, and realistic multirobot control scenarios. It can be used to develop controllers that optimize the system-level velocity or other objectives in the presence of different types of vehicles, model noise, and road networks such as single-lane circular tracks, multi-lane circular tracks, figure-eight networks, loops with merge networks, and intersections.</p>

  <h3 class="fm-head1" id="heading_id_31">A.5.6 Other libraries</h3>

  <p class="body">The following is a non-exhaustive list of other useful ML libraries:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://www.dgl.ai/">Deep Graph Library (DGL)</a>—A library for implementing graph neural networks in Python. It provides tools for defining, training, and evaluating GNN models, as well as for visualizing the optimization process. DGL supports a variety of GNN architectures, including GCN and GAT.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/snap-stanford/snap">Stanford Network Analysis Platform (SNAP)</a>—A general-purpose, high-performance system for the analysis and manipulation of large, complex networks. SNAP includes a number of algorithms for network analysis, such as centrality measures, community detection, and graph generation. It is particularly well-suited for large-scale network analysis and is used in a variety of fields, including computer science, physics, biology, and social science.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://graphneural.network/">Spektral</a>—An open-source Python library for graph neural networks (GNNs) built on top of TensorFlow and Keras. It is designed to make it easy to implement GNNs in research and production. It provides a high-level, user-friendly API for building GNNs, as well as a number of prebuilt layers and models for common tasks in graph deep learning. The library also includes utilities for loading and preprocessing graph data and for visualizing and evaluating the performance of GNNs.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/deepmind/jraph">Jraph</a> (pronounced “giraffe”)—A lightweight library for working with graph neural networks that also provides lightweight data structure for working with graphs. You can easily work with this library to construct and visualize your graph.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/deepmind/graph_nets">GraphNets</a>—A library for implementing GNNs in Python. It provides tools for defining, training, and evaluating GNN models, as well as for visualizing the optimization process. GraphNets supports a variety of GNN architectures, including GCN and GAT.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://stable-baselines3.readthedocs.io/en/master/">Stable-Baselines3 (SB3)</a>—A set of reliable implementations of reinforcement learning algorithms in PyTorch.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://vowpalwabbit.org/index.html">Vowpal Wabbit (VW)</a>—An open source ML library specifically designed for large-scale online learning. Developed originally at Yahoo Research, and currently at Microsoft Research, it is widely used for solving reductions and contextual bandits problems.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://docs.ray.io/en/latest/rllib/index.html">Ray RLlib</a>—An open source library for RL, offering support for production-level, highly distributed multi-agent RL workloads while maintaining unified and simple APIs for a large variety of industry applications.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://www.tensorflow.org/agents">TF-Agents</a>—A library for developing RL algorithms in TensorFlow, which includes a collection of environments, algorithms, and tools for training RL agents.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/keras-rl/keras-rl">Keras-RL</a>—A deep reinforcement learning library built on top of Keras. It provides an easy-to-use interface for developing and testing RL algorithms. Keras-RL supports a variety of RL algorithms such as deep Q-networks (DQN) and actor-critic methods. There are also built-in environments for testing RL algorithms.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://github.com/accel-brain/accel-brain-code/tree/master/Reinforcement-Learning">pyqlearning</a>—A Python library to implement reinforcement learning and deep reinforcement learning, especially for Q-learning, deep Q-network, and multi-agent deep Q-network, which can be optimized by annealing models such as simulated annealing, adaptive simulated annealing, and quantum Monte Carlo method.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><a class="url" href="https://pythonot.github.io/">Python Optimal Transport (POT)</a>—An open source Python library providing several solvers for optimization problems related to optimal transport for signals, image processing, and machine learning.</p>
    </li>
  </ul>

  <p class="body">The “<a class="url" href="https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.4_ML_libraries.ipynb">Listing A.4_ML_libraries.ipynb</a>” notebook available in the book’s GitHub repo provides examples of how to install and use some of these libraries.</p>

  <h2 class="fm-head" id="heading_id_32">A.6 Projects</h2>

  <p class="body">My course “ECE1724H: Bio-inspired Algorithms for Smart Mobility,” at the University of Toronto, features a collection of exemplary projects available in the “AI for Smart Mobility (AI4SM)” publication hub (<a class="url" href="https://medium.com/ai4sm">https://medium.com/ai4sm</a>) with Python code implementations. These projects encompass a broad spectrum of optimization algorithms covered in this book and their practical applications in the smart mobility domain. Among the topics tackled are</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">Employing large language models for reinforcement learning in intelligent driving</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Forecasting traffic flows</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Strategizing the placement of EV charging stations</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Optimizing food delivery services</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Predicting estimated times of arrival</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Improving the deployment of traffic sensors</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Customizing cycling routes</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Reorganizing urban fire districts</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Pricing strategies for ride-sharing</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Refining school bus routes</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Availability predictions for bikes</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Districting for efficient waste collection</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Enhancing bus stop layouts</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Implementing dynamic pricing for public transportation</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Optimizing student transportation and boarding</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Integrating hotel recommendations with route planning</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Determining ideal locations for public parcel lockers</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Predictive responses and accessibility scoring for healthcare facilities</p>
    </li>
  </ul>
</body></html>