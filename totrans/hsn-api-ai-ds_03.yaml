- en: Chapter 2\. Selecting Your API Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：选择你的 API 架构
- en: The happy towns are those that have an architecture.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 快乐的城镇是那些拥有架构的城镇。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Le Corbusier, *Towards a New Architecture* (Dover Publications, 1965)
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 勒·柯布西耶，《走向新建筑》（多佛出版社，1965年）
- en: In [Chapter 1](ch01.html#chapter_1), you began your portfolio project by understanding
    user needs and selecting use cases to fulfill. That initial work is critical to
    make sure you build the right products to fulfill real customer needs. In this
    chapter, you will begin developing the architecture you will use to build your
    first APIs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第一章](ch01.html#chapter_1) 中，你通过了解用户需求和选择用例来开始你的项目组合，以满足这些需求。这项初步工作是确保你构建出满足真实客户需求的产品至关重要。在本章中，你将开始开发你将用于构建第一个
    API 的架构。
- en: API Architectural Styles
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 架构风格
- en: 'One of the most significant decisions to make is selecting the API architectural
    style you will be using. Since you are using a consumer-centric design process,
    it follows that one of your first goals would be to use a style that is widely
    supported and understood by potential consumers. The [Postman 2023 State of the
    API Report](https://oreil.ly/x25Zw) found these were the top six API architectural
    styles:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 需要作出的最重要的决定之一是选择你将要使用的 API 架构风格。由于你正在使用以消费者为中心的设计流程，因此可以推断，你的首要目标之一将是使用一种被潜在消费者广泛支持和理解的风格。《Postman
    2023 API 状态报告》（https://oreil.ly/x25Zw）发现这六大 API 架构风格是最受欢迎的：
- en: '*REST*: 86%'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*REST*: 86%'
- en: '*Webhooks*: 36%'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Webhooks*: 36%'
- en: '*GraphQL*: 29%'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GraphQL*: 29%'
- en: '*Simple Object Access Protocol (SOAP)*: 26%'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单对象访问协议 (SOAP)*: 26%'
- en: '*WebSockets*: 25%'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WebSockets*: 25%'
- en: '*gRPC*: 11%'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*gRPC*: 11%'
- en: The overwhelming popularity of REST found in the survey is consistent with what
    you will experience if you explore most public APIs. REST is currently the typical
    style used for APIs. For an example relevant to your project, all of the APIs
    that I have found for real-world fantasy football league hosts use REST.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查中发现的 REST 的压倒性流行与你在探索大多数公共 API 时将经历的情况一致。REST 目前是典型的 API 风格。例如，我找到的所有针对现实世界幻想足球联赛主办方的
    API 都使用 REST。
- en: There are a couple of other API architectural styles that are worth reviewing
    because they also make sense in data science and AI-related situations. Let’s
    take a closer look at REST, GraphQL, and gRPC.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种其他的 API 架构风格值得审查，因为它们在数据科学和人工智能相关情况下也有意义。让我们更详细地看看 REST、GraphQL 和 gRPC。
- en: Representational State Transfer (REST)
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表现性状态转移 (REST)
- en: REST was formally defined by Roy Fielding’s doctoral dissertation, [“Architectural
    Styles and the Design of Network-Based Software Architectures”](https://oreil.ly/cLpNu).
    In practice, you will find that not all of the REST-style APIs conform completely
    to this format definition.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: REST 由 Roy Fielding 的博士论文正式定义，论文题目为[“架构风格和网络化软件架构设计”](https://oreil.ly/cLpNu)。在实践中，你会发现并非所有
    REST 风格的 API 都完全符合这一格式定义。
- en: 'A useful implementation of this architectural style is sometimes referred to
    as *Pragmatic REST* or *RESTful*. The following is a mix of formal definitions
    and some pragmatic practices:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构风格的有用实现有时被称为 *实用 REST* 或 *RESTful*。以下是一系列正式定义和一些实用实践的混合：
- en: API providers make resources available at individual addresses (e.g., */customers*,
    */products*, etc.). Consumers make requests to these resources using standard
    HTTP verbs. Producers provide a response. This is the client/server model.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 提供者通过单个地址提供资源（例如，*/customers*、*/products* 等）。消费者使用标准的 HTTP 动词对这些资源发出请求。生产者提供响应。这是客户端/服务器模型。
- en: The response is defined by the producer. The standard structure of the response
    is the same for each consumer.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应由生产者定义。每个消费者的响应标准结构是相同的。
- en: The REST response is typically in JSON or, sometimes, XML format, both of which
    are standard text-based data transfer formats.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 响应通常是 JSON 格式，有时是 XML 格式，这两种都是标准的基于文本的数据传输格式。
- en: The interaction is stateless, which means that each message back and forth stands
    on its own. So, in a conversation of multiple requests and responses, each request
    has to provide information or *context* from previous responses. For example,
    a consumer might retrieve a list of players and then provide one player’s ID to
    request additional details.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互是无状态的，这意味着每条来回的信息都独立存在。因此，在多个请求和响应的对话中，每个请求都必须提供来自先前响应的信息或 *上下文*。例如，消费者可能会检索玩家列表，然后提供一个玩家的
    ID 以请求更多详细信息。
- en: Increasingly, REST APIs are defined by an [OpenAPI Specification file](https://oreil.ly/d7xYG),
    although a variety of other options have been used over the years.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越来越多的REST API是通过[OpenAPI规范文件](https://oreil.ly/d7xYG)定义的，尽管多年来已经使用了各种其他选项。
- en: It is a best practice to use API versions to protect existing consumers from
    changes.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API版本来保护现有消费者免受更改是一种最佳实践。
- en: Graph Query Language (GraphQL)
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图查询语言（GraphQL）
- en: '[GraphQL](https://oreil.ly/gphql) is both a query language for APIs and a query
    runtime engine. GraphQL was developed by Facebook and was made open source in
    2015\. Here are some attributes of GraphQL APIs, with comparisons to REST:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[GraphQL](https://oreil.ly/gphql)既是API的查询语言，也是查询运行时引擎。GraphQL由Facebook开发，并于2015年开源。以下是GraphQL
    API的一些属性，与REST的比较：'
- en: Communication uses the client/server model (like RESTful APIs).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信使用客户端/服务器模型（类似于RESTful API）。
- en: Communication is stateless (like RESTful APIs).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信是无状态的（类似于RESTful API）。
- en: The response is usually in JSON (like RESTful APIs).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应通常以JSON格式（类似于RESTful API）返回。
- en: Instead of only using HTTP verbs, the consumer uses the GraphQL query language.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与仅使用HTTP动词不同，消费者使用GraphQL查询语言。
- en: The consumer can specify the contents of the response, along with the query
    options. (In REST, the producer defines the response contents.)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者可以指定响应的内容，以及查询选项。（在REST中，生产者定义响应内容。）
- en: The producer makes the API available at a single address (e.g., */graphql*),
    and the consumer passes queries to it via the HTTP POST verb.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者将API放在单个地址上（例如，*/graphql*），消费者通过HTTP POST动词向其传递查询。
- en: Versioning is not recommended, because the consumer defines the contents they
    are requesting.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不推荐使用版本控制，因为消费者定义了他们请求的内容。
- en: A big advantage of GraphQL over RESTful APIs is that fewer API calls are needed
    for the consumer to get the information they need. This requires less network
    traffic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与RESTful API相比，GraphQL的一个大优势是消费者获取所需信息所需的API调用更少。这需要更少的网络流量。
- en: gRPC
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC
- en: 'Like GraphQL, [gRPC](https://oreil.ly/iJFdv) was developed by a commercial
    company (Google) and was made open source in 2015\. gRPC was developed for very
    fast, efficient communication between microservices. gRPC is usually used for
    a different set of problems than REST, and it has many differences:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与GraphQL一样，[gRPC](https://oreil.ly/iJFdv)是由一家商业公司（Google）开发的，并于2015年开源。gRPC是为了在微服务之间实现非常快速、高效的通信而开发的。gRPC通常用于与REST不同的问题集，并且有许多不同之处：
- en: Instead of sharing resources, gRPC provides remote procedure calls, which are
    more like traditional code functions.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与共享资源不同，gRPC提供远程过程调用，这更类似于传统的代码函数。
- en: Instead of being limited to stateless request-response patterns, gRPC can be
    used for continuous streaming.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC不仅可以限于无状态的请求-响应模式，还可以用于连续流。
- en: Instead of returning data in a text-based format like JSON, it uses [protocol
    buffers](https://protobuf.dev), which is a format for serializing data that is
    smaller and faster than JSON or XML.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与返回基于文本的格式如JSON的数据不同，它使用[协议缓冲区](https://protobuf.dev)，这是一种比JSON或XML更小、更快的序列化数据格式。
- en: Instead of using an OpenAPI specification file, it uses protocol buffers as
    the specification in a *.proto* file.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与使用OpenAPI规范文件不同，它使用协议缓冲区作为*.proto*文件中的规范。
- en: 'gRPC is not a likely candidate for the APIs that you will be creating in your
    portfolio project. However, it’s worth mentioning in this discussion of API architectural
    styles related to data science for one big reason: *large language models* (LLMs).
    These machine learning models are the engines behind generative AI services such
    as Gemini and ChatGPT. These are very big models that need all the performance
    they can get, and they are using gRPC in some cases to achieve this.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC不太可能成为您在组合项目中创建的API的候选者。然而，在讨论与数据科学相关的API架构风格时，有一个重要原因值得提及：*大型语言模型*（LLMs）。这些机器学习模型是Gemini和ChatGPT等生成式AI服务的引擎。这些是非常大的模型，需要尽可能多的性能，在某些情况下，它们使用gRPC来实现这一点。
- en: 'Your Choice: REST'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的选择：REST
- en: For your company’s needs, REST is the appropriate choice. It is the industry
    standard, and it is appropriate for providing resource-based APIs for the user
    stories you identified. It is also supported by a broad range of technologies,
    so your customers should have no problem using a RESTful API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您公司的需求，REST是合适的选择。它是行业标准，适用于为您的用户故事提供基于资源的API。它还得到了广泛技术的支持，因此您的客户应该没有问题使用RESTful
    API。
- en: GraphQL is also a good choice for a user querying your football data, and you
    should keep an eye on it in the future. But you are safe to wait until your users
    request it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL也是一个很好的选择，用于用户查询你的足球数据，你应该在未来关注它。但是，你可以等到用户请求它时再考虑。
- en: 'Before diving into the Python coding for your API, let’s discuss how this book
    will use a couple of key terms. For this book, we will consider a *RESTful API*
    to be a set of endpoints that are all related to the same data source. From this
    perspective, your SWC website will start with a single API: the SWC Fantasy Football
    API.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入Python编码你的API之前，让我们讨论一下这本书将如何使用一些关键术语。对于这本书，我们将考虑一个*RESTful API*是一组所有端点都与同一数据源相关的端点。从这个角度来看，你的SWC网站将从单个API开始：SWC幻想足球API。
- en: An *API version* is a group of endpoints that are consistent for some time so
    that consumers can count on them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*API版本*是一组在一段时间内保持一致的端点，以便消费者可以依赖它们。
- en: 'An *API endpoint* (also referred to as an *operation*) is a combination of
    two fundamental building blocks: an HTTP verb and a URL path.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*API端点*（也称为*操作*）是两个基本构建块的组合：一个HTTP动词和一个URL路径。
- en: 'The overall structure of these terms is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语的整体结构如下：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s look at a few examples using a general Acme widget company ([Table 2-1](#acme_endpoints)).
    We’ll assume that the company’s APIs reside under the *[*https://api.acme.com*](https://api.acme.com)*
    subdomain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个通用的Acme小部件公司（[表2-1](#acme_endpoints)）的几个例子来看看。我们假设该公司的API位于*[*https://api.acme.com*](https://api.acme.com)子域下。
- en: Table 2-1\. Example endpoints in Acme API version 1
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. Acme API版本1中的示例端点
- en: '| Endpoint description | HTTP verb | URL | Message body |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 端点描述 | HTTP动词 | URL | 消息体 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Read product list | GET | *api.acme.com/v1/products/* | Empty |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 读取产品列表 | GET | *api.acme.com/v1/products/* | 空值 |'
- en: '| Read individual product | GET | *api.acme.com/v1/products/{product_id}/*
    | Empty |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 读取单个产品 | GET | *api.acme.com/v1/products/{product_id}/* | 空值 |'
- en: '| Create new product | POST | *api.acme.com/v1/products/* | Contains new product
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 创建新产品 | POST | *api.acme.com/v1/products/* | 包含新产品信息 |'
- en: '| Update existing product | PUT | *api.acme.com/v1/products/{product_id}/*
    | Contains updated product |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 更新现有产品 | PUT | *api.acme.com/v1/products/{product_id}/* | 包含更新后的产品信息 |'
- en: '| Delete existing product | DELETE | *api.acme.com/v1/products/{product_id}*/
    | Varies |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 删除现有产品 | DELETE | *api.acme.com/v1/products/{product_id}*/ | 可变 |'
- en: You can see that the URL is reused for several of the endpoints. For example,
    the read product list endpoint uses a URL of *api.acme.com/v1/products* with a
    `GET` verb. The `GET` verb reads the product records. The create new product endpoint
    uses the same URL but with a `POST` verb. The `POST` creates a new record.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到URL被用于多个端点。例如，读取产品列表端点使用带有`GET`动词的URL *api.acme.com/v1/products*。`GET`动词读取产品记录。创建新产品端点使用相同的URL，但带有`POST`动词。`POST`创建一个新记录。
- en: But by combining the HTTP verb with the URL, a specific action is taken when
    this resource is called. This HTTP verb plus URL combination can only be used
    once. For your portfolio project, you will develop a set of endpoints to fulfill
    the user cases you selected.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，通过将HTTP动词与URL结合，当调用此资源时，将执行特定的操作。这种HTTP动词加URL组合只能使用一次。对于你的项目，你将开发一组端点来满足你选择的用户案例。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information about all the HTTP verbs, see [“HTTP Basics”](ch08.html#http_basics).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有HTTP动词的更多信息，请参阅[“HTTP基础知识”](ch08.html#http_basics)。
- en: Technology Architecture
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术架构
- en: The SWC league host website is a web application that uses a relational database.
    Fantasy managers access the website through their web browsers. Although a large
    amount of technology is necessary to host this large website, [Figure 2-1](#current_state_architecture_ch2)
    is a high-level view of the current state application architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SWC联赛主办方网站是一个使用关系型数据库的Web应用程序。幻想经理们通过他们的网络浏览器访问该网站。尽管托管这个大型网站需要大量的技术，但[图2-1](#current_state_architecture_ch2)展示了当前状态的应用程序架构。
- en: '![Current state application architecture](assets/haad_0201.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![当前状态应用程序架构](assets/haad_0201.png)'
- en: Figure 2-1\. Current state application architecture
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. 当前状态应用程序架构
- en: 'The following components are in this architecture:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该架构包含以下组件：
- en: Fantasy managers
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 幻想经理
- en: Current web users of Sportsworldcentral.com
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Sportsworldcentral.com的当前网络用户
- en: Web application
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序
- en: The existing league host website (assume it already exists for your project)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的联赛主办方网站（假设它已经存在于你的项目中）
- en: Website database
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 网站数据库
- en: The relational database that is used for the web application (assume it already
    exists and contains data for your project)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 用于网络应用的数据库关系型数据库（假设它已经存在并包含你的项目数据）
- en: When deciding on the architecture for an API, many choices are available. When
    a web application already exists, one option is to create the API as part of the
    web application. Many web applications use APIs as part of their design, so this
    may be the simplest route in those cases. Another option is to create the API
    as a separate application but allow the API to read directly from the website
    database. This has the advantage that the API’s data will always be up-to-date
    with the web application, but it could potentially slow down the web application
    if a large number of requests are being made to the API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定 API 架构时，有许多选择。当网络应用已经存在时，一个选项是将 API 作为网络应用的一部分来创建。许多网络应用将 API 作为其设计的一部分，因此在这种情况下这可能是最简单的方法。另一个选项是创建一个独立的
    API 应用程序，但允许 API 直接从网站数据库读取。这有一个优点，即 API 的数据将始终与网络应用保持最新，但如果对 API 发起了大量请求，这可能会潜在地减慢网络应用的性能。
- en: You will create the API as a separate application and pull the API’s data from
    a *read replica database*. This is a read-only copy of the website database that
    receives quick updates from the website database but is physically separate so
    that the API traffic doesn’t impact the website’s performance. Since your API
    will be read-only, the read replica is a good choice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个独立的 API 应用程序，并从 *读取副本数据库* 中提取 API 的数据。这是一个只读的网站数据库副本，它从网站数据库接收快速更新，但在物理上是独立的，这样
    API 流量就不会影响网站的性能。由于你的 API 将是只读的，读取副本是一个好的选择。
- en: '[Figure 2-2](#future_state_architecture_ch2) shows the future state application
    architecture that you will implement.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#future_state_architecture_ch2) 显示了你将实施的未来状态应用程序架构。'
- en: '![Future state application architecture](assets/haad_0202.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![未来状态应用程序架构](assets/haad_0202.png)'
- en: Figure 2-2\. Future state application architecture
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 未来状态应用程序架构
- en: 'These are the new components for your project:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你项目的新组件：
- en: Fantasy advice websites
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 梦想建议网站
- en: Will be importing your league data to their advice website.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将将导入你的联赛数据到他们的建议网站。
- en: Data science users
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学用户
- en: Will be calling your APIs to create their analytics products.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用你的 API 来创建他们的分析产品。
- en: Read replica database
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 读取副本数据库
- en: A separate read-only copy of the website database you will create.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建的网站数据库的单独只读副本。
- en: API
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: API
- en: The new API application you will create. Notice that it will use the base web
    address *api.sportsworldcentral.com* to keep it separate from the main website.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建的新 API 应用程序。请注意，它将使用基础网址 *api.sportsworldcentral.com* 以保持与主网站分离。
- en: 'The technology architecture of APIs is a deep and very interesting topic, and
    the potential variations of components are nearly endless. One thing to remember
    is that a software architecture changes over time, so decisions that you make
    are not permanent. I highly recommend the book *Mastering API Architecture: Design,
    Operate, and Evolve API-Based Systems* by James Gough, Daniel Bryant, and Matthew
    Auburn (O’Reilly, 2022) to build foundational knowledge of this subject.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: API 的技术架构是一个深奥且非常有趣的话题，组件的潜在变化几乎是无穷无尽的。要记住的一件事是，软件架构会随着时间的推移而变化，所以你做出的决定不是永久的。我强烈推荐
    James Gough、Daniel Bryant 和 Matthew Auburn 著的《精通 API 架构：设计、运营和演进基于 API 的系统》（O’Reilly，2022）这本书，以建立这个主题的基础知识。
- en: Software Used in This Chapter
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章使用的软件
- en: Since you will be creating a new API application and standalone database, take
    a look at the tools and services you will use, as shown in [Table 2-2](#tools_table_chapter_2).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将创建一个新的 API 应用程序和独立数据库，请查看你将使用的工具和服务，如[表 2-2](#tools_table_chapter_2)所示。
- en: Table 2-2\. New tools or services used in this chapter
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 本章使用的新工具或服务
- en: '| Software name | Version | Purpose |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 软件名称 | 版本 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Python | 3.10 | Programming language |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| Python | 3.10 | 编程语言 |'
- en: '| GitHub | NA | Source control, development environment |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| GitHub | NA | 源代码控制，开发环境 |'
- en: Python
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python
- en: Python is the programming language you will use for all of the API code in Part
    I. You will also use it in [Part II](part02.html#part_2) to create analytics products,
    data pipelines, and interactive data applications. You will use it in [Part III](part03.html#part_3)
    to build a generative AI application. It’s possible to use Python for almost any
    job in data science, and it is the language most frequently used by data scientists,
    according to the [Anaconda 2022 State of Data Science Report](https://oreil.ly/fD4u7).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分的所有API代码中，你将使用Python编程语言。你还将使用它来在[第二部分](part02.html#part_2)中创建分析产品、数据管道和交互式数据应用。你将在[第三部分](part03.html#part_3)中用它来构建一个生成式AI应用。根据[Anaconda
    2022数据科学报告](https://oreil.ly/fD4u7)，Python几乎可以用于数据科学中的任何工作，并且是数据科学家最常使用的语言。
- en: The Python open source ecosystem is very strong and deep, with high-quality
    frameworks and libraries available for almost any task you want to perform. You
    will work with a variety of popular Python libraries throughout this book, such
    as those that follow.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python的开源生态系统非常强大且深入，几乎为任何你想要执行的任务提供了高质量的框架和库。在这本书中，你将使用各种流行的Python库，如下所示。
- en: Python adoption has accelerated in recent years for a variety of software development
    tasks. The [2023 Stack Overflow Developer Survey](https://oreil.ly/pvfEB) found
    that Python was in a dead heat for first as the language most developers wanted
    to use, and it ranked as the third most used at the time. Python is very flexible
    and is used in a variety of situations. It is a great tool for any developer to
    have in their toolbox.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，Python在各种软件开发任务中的采用速度加快。[2023 Stack Overflow开发者调查](https://oreil.ly/pvfEB)发现，Python在开发者最想使用的语言中竞争激烈，当时排名第三。Python非常灵活，在各种情况下都得到使用。它是任何开发者工具箱中的伟大工具。
- en: For this book, you will be using Python 3.10 or higher.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，你将使用Python 3.10或更高版本。
- en: GitHub
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub
- en: GitHub is a website that plays a major role in software development. At its
    core, GitHub is a cloud host of source control software, but it has added additional
    features over the years. These capabilities are generally free or low cost. Many
    prominent open source projects use GitHub to host their source code and allow
    developers to contribute to the project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub是一个在软件开发中扮演重要角色的网站。在其核心，GitHub是一个源代码控制软件的云托管服务，但多年来它增加了额外的功能。这些功能通常是免费或低成本的。许多著名的开源项目使用GitHub来托管他们的源代码，并允许开发者为项目做出贡献。
- en: You will use GitHub in several ways in this book. You will store all of your
    program code in repositories while you develop it. You will use GitHub Codespaces
    as your Python development environment. You will use GitHub Pages to publish your
    developer portal.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将以多种方式使用GitHub。在开发过程中，你将把所有的程序代码存储在仓库中。你将使用GitHub Codespaces作为你的Python开发环境。你将使用GitHub
    Pages来发布你的开发者门户。
- en: This book uses many of GitHub’s tools because they simplify environment management
    and work together well. The result will be a professional-looking API and data
    science portfolio that demonstrates what you have accomplished. Most of the work
    can also be performed on your local machine or another virtual environment instead
    of using GitHub. However, the instructions will assume you are using GitHub.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书使用了GitHub的许多工具，因为它们简化了环境管理，并且协同工作得很好。结果将是一个看起来专业的API和数据科学组合，展示了你所取得的成就。大部分工作也可以在你的本地机器或另一个虚拟环境中完成，而无需使用GitHub。然而，说明将假设你正在使用GitHub。
- en: Getting Started with Your GitHub Codespace
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用您的GitHub Codespace
- en: GitHub Codespaces will be the development environment for all of the API code
    you develop in Part I of this book. You can think of a Codespace as a development
    environment running VS Code in the browser. Working with Codespaces will allow
    you to run the code from the GitHub repository that I share with you, with a minimum
    of distractions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Codespaces将作为本书第一部分中你开发的全部API代码的开发环境。你可以把Codespace想象成一个在浏览器中运行VS Code的开发环境。使用Codespaces将允许你以最小的干扰运行我从GitHub仓库分享给你的代码。
- en: Creating Your GitHub Account
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的GitHub账户
- en: Before getting started with Codespaces, you need a GitHub account. [Follow the
    instructions to create a GitHub free personal account](https://oreil.ly/7j595).
    The free account will give you plenty of Codespace storage and core hours to work
    through this book. During the writing of this book, I often exceeded the free
    allocation by running multiple Codespaces, but the charge was generally a few
    dollars. Be sure to enable two-factor authentication to protect your account.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Codespaces 之前，你需要一个 GitHub 账户。[按照说明创建一个免费的 GitHub 个人账户](https://oreil.ly/7j595)。免费账户将为你提供足够的
    Codespace 存储和核心小时数来完成这本书。在本书的编写过程中，我经常因为运行多个 Codespaces 而超出免费配额，但费用通常只有几美元。请确保启用双因素认证以保护您的账户。
- en: Cloning the Part I Repository
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆第一部分仓库
- en: 'When you use another repository and make edits that you want to keep, there
    are two ways to accomplish this: forking or cloning. When you *fork* the repository,
    you create a copy in your account that remains linked to the original repository.
    This is useful when you will be submitting changes back to the original repository
    for updates. *Cloning* the repository creates a standalone copy in your GitHub
    account. For this book, I recommend that you clone the repository so that your
    portfolio project stands alone and shows the work you have completed.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用另一个仓库并希望保留所做的编辑时，有两种方法可以实现：分叉或克隆。当您*分叉*仓库时，您在您的账户中创建了一个副本，该副本仍然与原始仓库保持链接。当您需要将更改提交回原始仓库以进行更新时，这很有用。*克隆*仓库将在您的
    GitHub 账户中创建一个独立的副本。对于这本书，我建议您克隆仓库，这样您的项目组合就可以独立展示您已完成的工作。
- en: 'To clone the repository, log in to GitHub and go to the [GitHub Import Repository
    page](https://github.com/new/import). Enter the following information in the fields
    on this page:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要克隆仓库，请登录到 GitHub 并转到[GitHub 导入库页面](https://github.com/new/import)。在此页面的字段中输入以下信息：
- en: '*The URL for your source repository*: **`[*https://github.com/handsonapibook/api-book-part-one*](https://github.com/handsonapibook/api-book-part-one)`**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的源代码库的 URL*：**`[*https://github.com/handsonapibook/api-book-part-one*](https://github.com/handsonapibook/api-book-part-one)`**'
- en: '*Your username for your source code repository*: Leave this blank.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的源代码库的用户名*：留空。'
- en: '*Your access token or password for your source code repository*: Leave this
    blank.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的源代码库的访问令牌或密码*：留空。'
- en: '*Repository name*: **`portfolio-project`**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仓库名称*：**`portfolio-project`**'
- en: '*Public*: Select this so that you can share the results of the work you are
    doing.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公开*：选择这个选项，这样您就可以分享您正在进行的工作的结果。'
- en: Click Begin Import. The import process will begin and the message “Preparing
    your new repository” will be displayed. After several minutes, you will receive
    an email notifying you that your import has finished. Follow the link to your
    new cloned repository.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“开始导入”。导入过程将开始，并显示消息“准备您的新的仓库”。几分钟后，您将收到一封电子邮件通知您导入已完成。点击链接访问您的新克隆仓库。
- en: I will tell you more about the contents of this repository after you launch
    a GitHub Codespace.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在您启动 GitHub Codespace 之后，我会向您介绍更多关于这个仓库的内容。
- en: Launching Your GitHub Codespace
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动您的 GitHub Codespace
- en: Launching a Codespace to work with this repository is simple. On this repository,
    click the Code button and select the Codespaces tab. Click “Create Codespace on
    main.” You should see a page with the status “Setting up your Codespace.” Your
    Codespace window will open as the setup continues. When the setup completes, your
    display will look similar to [Figure 2-3](#codespace_setup_complete_ch2).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个 Codespace 来与此仓库一起工作很简单。在此仓库上，点击“代码”按钮并选择“Codespaces”标签。点击“在 main 上创建 Codespace”。您应该会看到一个状态为“设置您的
    Codespace”的页面。在设置过程中，您的 Codespace 窗口将打开。当设置完成后，您的显示将类似于[图 2-3](#codespace_setup_complete_ch2)。
- en: '![New GitHub Codespace](assets/haad_0204.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![新的 GitHub Codespace](assets/haad_0204.png)'
- en: Figure 2-3\. New GitHub Codespace
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 新的 GitHub Codespace
- en: Your Codespace is now created with the cloned repository. This is the environment
    you will be using for the rest of Part I of this book. Before looking around,
    take a minute to open the [GitHub Codespaces page](https://github.com/codespaces)
    and make a couple of updates. Scroll down the page to find this new Codespace,
    click the ellipsis to the right of the name, and select Rename. Enter the name
    **`Portfolio project codespace`** and click Save. You should see the message “Your
    codespace *Portfolio project codespace* has been updated.” Click the ellipsis
    again, and then click the ribbon next to “Auto-delete Codespace” to turn off autodeletion.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Codespace现在已通过克隆的仓库创建。这是您将用于本书第一部分剩余部分的环境。在四处查看之前，花一分钟时间打开[GitHub Codespaces页面](https://github.com/codespaces)并进行一些更新。滚动到页面底部找到这个新的Codespace，点击名称右侧的省略号，选择重命名。输入名称**`Portfolio
    project codespace`**并点击保存。您应该看到消息“您的codespace *Portfolio project codespace* 已更新。”再次点击省略号，然后点击“自动删除Codespace”旁边的彩带以关闭自动删除功能。
- en: Touring Your New Codespace
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索您的新Codespace
- en: Go back to the tab that has your Codespace open, which looks like [Figure 2-3](#codespace_setup_complete_ch2).
    The URL of this page is an auto-generated address such as *happy-circus-1234.github.dev*.
    This will be the URL you will use to come back to this Codespace. You could bookmark
    it if you like. I typically go to the [GitHub Codespaces page](https://github.com/codespaces)
    and launch my Codespace from there.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到打开您的Codespace的标签页，它看起来像[图2-3](#codespace_setup_complete_ch2)。此页面的URL是一个自动生成的地址，例如*happy-circus-1234.github.dev*。这将是你返回此Codespace时使用的URL。如果您喜欢，可以将其添加到书签中。我通常去[GitHub
    Codespaces页面](https://github.com/codespaces)并从那里启动我的Codespace。
- en: The display that you see for Codespaces is VS Code, which is a popular open
    source IDE. Working in Codespaces will be like using VS Code through the browser.
    Remember that all of the work you do is being executed in a remote container that
    is running on the cloud. If you would like to know more about how this works,
    take a look at the [GitHub Codespaces overview](https://oreil.ly/cdesps).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您在Codespaces中看到的显示是VS Code，这是一个流行的开源IDE。在Codespaces中工作将类似于通过浏览器使用VS Code。请记住，您所做的所有工作都在云上运行的远程容器中执行。如果您想了解更多关于它是如何工作的信息，请查看[GitHub
    Codespaces概述](https://oreil.ly/cdesps)。
- en: On the left side of the screen is the Explorer, which shows the directory structure
    of your Codespace. This structure begins with the structure from the cloned repository.
    There is a separate subfolder for each chapter in the book that has code. For
    example, the *chapter2* folder is where you will do your coding for this chapter.
    Inside each chapter folder is a *\complete* subfolder that contains a working
    copy of the completed code from this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕左侧是资源管理器，它显示了您的Codespace的目录结构。这个结构从克隆的仓库的结构开始。为书中每个有代码的章节都有一个单独的子文件夹。例如，*chapter2*文件夹是您将为本章进行编码的地方。在每个章节文件夹内部有一个*\complete*子文件夹，其中包含本章完成代码的工作副本。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: I suggest that you follow along with the chapter and type the files yourself.
    You will learn the purpose of the files as you perform the work. If you run into
    any trouble, the files in *\complete* are available to check your work. If you
    would like to complete the chapters out of order, you can also use the completed
    files from the previous chapters as the starting point.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您跟随章节内容并亲自输入文件。您将在执行工作的过程中了解文件的目的。如果您遇到任何问题，*\complete*中的文件可供您检查工作。如果您想按顺序完成章节，您也可以使用前几章的完成文件作为起点。
- en: At the bottom of the window, you will see the Terminal window selected. This
    is an interface to the command line of the Linux container that is running your
    Code​spa⁠ces. Throughout Part I, you will enter commands in the terminal window.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口底部，您将看到选中的终端窗口。这是您CodeSpaces运行的Linux容器命令行界面。在整个第一部分中，您将在终端窗口中输入命令。
- en: 'Your Codespace has been preloaded with the version of Python that you need.
    Verify this by entering **`python3 --version`** in the terminal command line.
    You should see Python version 3.10 or later, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Codespace已经预装了您需要的Python版本。通过在终端命令行中输入**`python3 --version`**来验证这一点。您应该看到Python版本3.10或更高版本，如下所示：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Stop the Codespace by clicking in the bottom left of the window and entering
    **`Stop current codespace`** from the dialog window. This will reduce the number
    of free hours you use working in Codespaces.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击窗口左下角并从对话框窗口中选择**`停止当前codespace`**来停止Codespace。这将减少您在Codespaces中工作所使用的免费小时数。
- en: Congratulations! This is the repository and Codespace you will use for your
    Part I portfolio project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这就是你将用于你的第一部分项目组合的仓库和Codespace。
- en: Making Your First Commit
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行第一次提交
- en: Restart your Codespace from the [GitHub Codespaces page](https://github.com/codespaces).
    There is one item to notice as you work in this environment. Your new Codespace
    begins with the same directory structure as your repository on GitHub.com. However,
    files you add or make in your Codespace are initially stored only on the Codespace—they
    are not updated in your repository automatically. As you complete the code in
    this book and develop your project, you should periodically *commit* your changes
    to GitHub, which saves your changes and adds a message about the purpose of the
    change. Frequent commits ensure that you don’t lose changes if something happens
    to your Codespace and allow you to go back to a working copy if you break something.
    Consistent commits over time demonstrate activity in your GitHub profile, which
    is a sign of credibility for those viewing your GitHub history.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从[GitHub Codespaces页面](https://github.com/codespaces)重新启动你的Codespace。在你工作在这个环境中时，有一件事需要注意。你的新Codespace以与GitHub.com上你的仓库相同的目录结构开始。然而，你添加或创建在Codespace中的文件最初仅存储在Codespace中——它们不会自动更新到你的仓库中。当你完成这本书中的代码并开发你的项目时，你应该定期将你的更改提交到GitHub，这样可以保存你的更改并添加关于更改目的的消息。频繁的提交确保了如果发生什么问题导致你的Codespace损坏，你不会丢失更改，并且如果你破坏了某些东西，你可以回到一个工作副本。随着时间的推移，一致的提交显示了你在GitHub个人资料中的活动，这对于查看你的GitHub历史的人来说是一个可信的标志。
- en: You do not want to commit everything in your Codespace to your repository. There
    will be some files that get generated that you don’t need to save in GitHub. This
    is where the *.gitignore* file comes in. Open this file and take a look at it
    now.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望将Codespace中的所有内容都提交到你的仓库中。将有一些文件被生成，你不需要在GitHub中保存。这就是*.gitignore*文件发挥作用的地方。现在打开这个文件并查看它。
- en: The *.gitignore* file contains file patterns or specific names of all the files
    in your local Codespace that should be excluded from your repository. Many of
    these are local config files generated by the libraries you use. Some are sensitive
    files that should not be published in your repository.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*.gitignore*文件包含了你本地Codespace中所有应该从你的仓库中排除的文件的模式或特定名称。其中许多是由你使用的库生成的本地配置文件。一些是敏感文件，不应该发布在你的仓库中。'
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: At a minimum, you should always commit your work when you complete a working
    session. I commit code several times an hour, when I have completed a chunk of
    work that is related. For example, if I am modifying multiple files to add a new
    scoring field to an API, I modify each file and then make a commit with the comment
    “Added scoring field.” (It is not necessary to state the files you changed in
    the comment, because GitHub tracks that.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，你应在完成一个工作会话后始终提交你的工作。我每小时提交几次代码，当我完成了一块相关的工作时。例如，如果我正在修改多个文件以向API添加一个新的评分字段，我会修改每个文件，然后提交一个带有注释“添加评分字段”的提交。（在注释中声明你更改的文件不是必要的，因为GitHub会跟踪这些信息。）
- en: 'Next, you will update the *README.md* file in the root directory. Each GitHub
    repository has a README file that provides information about the purpose and contents
    of the repository. It is written in *Markdown*, which is a lightweight formatting
    language. In your Codespace, click on the *README.md* file in the Explorer. Modify
    the text of this file as shown here, and then save it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将更新根目录中的*README.md*文件。每个GitHub仓库都有一个README文件，它提供了关于仓库目的和内容的信息。它使用的是*Markdown*，这是一种轻量级的格式化语言。在你的Codespace中，点击资源管理器中的*README.md*文件。按照这里所示修改这个文件的文本，然后保存它：
- en: '[PRE2]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To preview what this file will look like on GitHub, right-click the *README.md*
    file and select Open Preview. You will see the updates you made. From the burger
    menu on the upper left of the window, select File, then Save. Now that you have
    saved this file, the built-in version control has flagged this. First, you see
    that the *README.md* file in the Explorer has changed color. Beside that file
    you see an M, which stands for modified. In the left sidebar, the source control
    icon has a colored circle with the numeral 1\. This means that one change is available
    to commit to source control. Click on that source control icon, and you will see
    the Source Control tab, as shown in [Figure 2-4](#source_control_tab_ch2).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预览此文件在 GitHub 上的外观，右键单击 *README.md* 文件并选择打开预览。您将看到您所做的更新。从窗口左上角的汉堡菜单中选择文件，然后保存。现在您已经保存了此文件，内置的版本控制已经标记了此文件。首先，您会看到资源管理器中的
    *README.md* 文件已更改颜色。在该文件旁边，您会看到一个 M，代表已修改。在左侧侧边栏中，源控制图标有一个带数字 1 的彩色圆圈。这意味着有一个更改可以提交到源控制。单击该源控制图标，您将看到源控制选项卡，如图[图
    2-4](#source_control_tab_ch2)所示。
- en: '![Source control with change flagged](assets/haad_0205.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![带有更改标记的源控制](assets/haad_0205.png)'
- en: Figure 2-4\. Source control with change flagged
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 带有更改标记的源控制
- en: 'Updating your repository requires several steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更新您的仓库需要几个步骤：
- en: 'Add commit message: The message you add will be the subject of the commit in
    GitHub.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加提交信息：您添加的消息将是 GitHub 上提交的主题。
- en: 'Stage your changes: Identify the changed files to be included in the commit.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阶段性提交更改：识别要包含在提交中的更改文件。
- en: 'Commit the changes to your local repository: Your Codespace comes preloaded
    with a Git repository, and your changes get committed there first.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改提交到本地仓库：您的 Codespace 预先加载了 Git 仓库，并且您的更改首先提交到那里。
- en: 'Sync the changes from your local repo to GitHub: Push your changes up to the
    repository at the GitHub.com website, and pull down any changes that occurred
    directly on the website.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本地仓库的更改同步到 GitHub：将您的更改推送到 GitHub.com 上的仓库，并拉取网站上直接发生的任何更改。
- en: 'To save time from here going forward, I’m going to walk you through a shortcut
    that will save a few steps as you commit in the future. For step 1, add this message
    in the box: **`Personalize title of project.`** Next, click the Commit button.
    A dialog will be displayed that says, “There are no staged changes to commit.
    Would you like to stage all your changes and commit them directly?” Click Always.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间，我将向您介绍一个快捷方式，这样在您未来的提交中可以节省几个步骤。对于步骤 1，在框中添加此消息：**`个性化项目标题。`** 然后，点击提交按钮。将显示一个对话框，上面写着：“没有已暂存的更改要提交。您想要暂存所有更改并直接提交吗？”
    点击始终。
- en: By choosing to always stage all changes and commit them, you are combining steps
    2 and 3\. For step 4, click Sync Changes to send the updates to the repository
    at GitHub, which is the *origin* or source of the files. When the dialog is displayed
    that says “This action will pull and push commits from and to origin/main,” click
    OK, Don’t Show Again. One last dialog will be displayed that says “Would you like
    Visual Studio Code to periodically run git fetch?” Click Yes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择始终暂存所有更改并提交，您正在合并步骤 2 和 3。对于步骤 4，点击同步更改以将更新发送到 GitHub 上的仓库，这是文件的 *origin*
    或源。当显示对话框说“此操作将从 origin/main 拉取和推送提交”时，点击确定，不再显示。最后，将显示一个对话框说“您想要 Visual Studio
    Code 定期运行 git fetch 吗？” 点击是。
- en: In another tab, go to GitHub.com and open the *portfolio-project* repository,
    which should look like [Figure 2-5](#committed_code_ch2).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个标签页中，前往 GitHub.com 并打开 *portfolio-project* 仓库，它应该看起来像[图 2-5](#committed_code_ch2)。
- en: '![Repository showing first commit](assets/haad_0206.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![显示首次提交的仓库](assets/haad_0206.png)'
- en: Figure 2-5\. Repository showing first commit
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 显示首次提交的仓库
- en: Above the directories, click the linked text “Personalize title of your project.”
    This is the record of the commit that you just sent. You can see the files that
    you changed. When you want to commit changes going forward, you only need to add
    a title and click Commit, then click Sync Changes to commit your code to GitHub.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录上方，点击链接文本“个性化项目标题”。这是您刚刚提交的提交记录。您可以看到您更改的文件。当您想要继续提交更改时，您只需添加一个标题并点击提交，然后点击同步更改以将您的代码提交到
    GitHub。
- en: This is excellent progress. You have made your first commit, and you are working
    in your Codespace environment. It’s time to get started with your source data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是出色的进展。您已经完成了首次提交，并且正在 Codespace 环境中工作。现在是时候开始处理您的源数据了。
- en: Additional Resources
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'To learn about the technical architecture of APIs, I recommend *Mastering API
    Architecture: Design, Operate, and Evolve API-Based Systems*, by James Gough,
    Daniel Bryant, and Matthew Auburn (O’Reilly, 2022).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '要了解API的技术架构，我推荐James Gough、Daniel Bryant和Matthew Auburn合著的《Mastering API Architecture:
    Design, Operate, and Evolve API-Based Systems》（O’Reilly，2022年）。'
- en: For some tips about RESTful API design, read [“The Ten REST Commandments” by
    Steve McDougall](https://oreil.ly/_97zo).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于RESTful API设计的技巧，请阅读[Steve McDougall的《The Ten REST Commandments》](https://oreil.ly/_97zo)。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you started creating an API to fill the user needs you identified
    in [Chapter 1](ch01.html#chapter_1). Here is what you have accomplished so far:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您开始创建一个API来满足您在[第1章](ch01.html#chapter_1)中确定的用户需求。到目前为止，您已经取得了以下成就：
- en: You defined the API endpoints needed to complete the user stories.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您定义了完成用户故事所需的API端点。
- en: You set up your development environment using GitHub Codespaces.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用GitHub Codespaces设置了您的开发环境。
- en: In [Chapter 3](ch03.html#chapter_3), you will create the website database using
    SQLite, create Python code to read the database with SQLAlchemy, and perform unit
    testing with pytest.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html#chapter_3)中，您将使用SQLite创建网站数据库，编写Python代码使用SQLAlchemy读取数据库，并使用pytest进行单元测试。
