- en: Chapter 2\. Selecting Your API Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The happy towns are those that have an architecture.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Le Corbusier, *Towards a New Architecture* (Dover Publications, 1965)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html#chapter_1), you began your portfolio project by understanding
    user needs and selecting use cases to fulfill. That initial work is critical to
    make sure you build the right products to fulfill real customer needs. In this
    chapter, you will begin developing the architecture you will use to build your
    first APIs.
  prefs: []
  type: TYPE_NORMAL
- en: API Architectural Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most significant decisions to make is selecting the API architectural
    style you will be using. Since you are using a consumer-centric design process,
    it follows that one of your first goals would be to use a style that is widely
    supported and understood by potential consumers. The [Postman 2023 State of the
    API Report](https://oreil.ly/x25Zw) found these were the top six API architectural
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '*REST*: 86%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Webhooks*: 36%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GraphQL*: 29%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Simple Object Access Protocol (SOAP)*: 26%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WebSockets*: 25%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*gRPC*: 11%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overwhelming popularity of REST found in the survey is consistent with what
    you will experience if you explore most public APIs. REST is currently the typical
    style used for APIs. For an example relevant to your project, all of the APIs
    that I have found for real-world fantasy football league hosts use REST.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of other API architectural styles that are worth reviewing
    because they also make sense in data science and AI-related situations. Let’s
    take a closer look at REST, GraphQL, and gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Representational State Transfer (REST)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST was formally defined by Roy Fielding’s doctoral dissertation, [“Architectural
    Styles and the Design of Network-Based Software Architectures”](https://oreil.ly/cLpNu).
    In practice, you will find that not all of the REST-style APIs conform completely
    to this format definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful implementation of this architectural style is sometimes referred to
    as *Pragmatic REST* or *RESTful*. The following is a mix of formal definitions
    and some pragmatic practices:'
  prefs: []
  type: TYPE_NORMAL
- en: API providers make resources available at individual addresses (e.g., */customers*,
    */products*, etc.). Consumers make requests to these resources using standard
    HTTP verbs. Producers provide a response. This is the client/server model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response is defined by the producer. The standard structure of the response
    is the same for each consumer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The REST response is typically in JSON or, sometimes, XML format, both of which
    are standard text-based data transfer formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interaction is stateless, which means that each message back and forth stands
    on its own. So, in a conversation of multiple requests and responses, each request
    has to provide information or *context* from previous responses. For example,
    a consumer might retrieve a list of players and then provide one player’s ID to
    request additional details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasingly, REST APIs are defined by an [OpenAPI Specification file](https://oreil.ly/d7xYG),
    although a variety of other options have been used over the years.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a best practice to use API versions to protect existing consumers from
    changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph Query Language (GraphQL)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[GraphQL](https://oreil.ly/gphql) is both a query language for APIs and a query
    runtime engine. GraphQL was developed by Facebook and was made open source in
    2015\. Here are some attributes of GraphQL APIs, with comparisons to REST:'
  prefs: []
  type: TYPE_NORMAL
- en: Communication uses the client/server model (like RESTful APIs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication is stateless (like RESTful APIs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response is usually in JSON (like RESTful APIs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of only using HTTP verbs, the consumer uses the GraphQL query language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consumer can specify the contents of the response, along with the query
    options. (In REST, the producer defines the response contents.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The producer makes the API available at a single address (e.g., */graphql*),
    and the consumer passes queries to it via the HTTP POST verb.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning is not recommended, because the consumer defines the contents they
    are requesting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A big advantage of GraphQL over RESTful APIs is that fewer API calls are needed
    for the consumer to get the information they need. This requires less network
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like GraphQL, [gRPC](https://oreil.ly/iJFdv) was developed by a commercial
    company (Google) and was made open source in 2015\. gRPC was developed for very
    fast, efficient communication between microservices. gRPC is usually used for
    a different set of problems than REST, and it has many differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of sharing resources, gRPC provides remote procedure calls, which are
    more like traditional code functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of being limited to stateless request-response patterns, gRPC can be
    used for continuous streaming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of returning data in a text-based format like JSON, it uses [protocol
    buffers](https://protobuf.dev), which is a format for serializing data that is
    smaller and faster than JSON or XML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using an OpenAPI specification file, it uses protocol buffers as
    the specification in a *.proto* file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gRPC is not a likely candidate for the APIs that you will be creating in your
    portfolio project. However, it’s worth mentioning in this discussion of API architectural
    styles related to data science for one big reason: *large language models* (LLMs).
    These machine learning models are the engines behind generative AI services such
    as Gemini and ChatGPT. These are very big models that need all the performance
    they can get, and they are using gRPC in some cases to achieve this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Choice: REST'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For your company’s needs, REST is the appropriate choice. It is the industry
    standard, and it is appropriate for providing resource-based APIs for the user
    stories you identified. It is also supported by a broad range of technologies,
    so your customers should have no problem using a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is also a good choice for a user querying your football data, and you
    should keep an eye on it in the future. But you are safe to wait until your users
    request it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into the Python coding for your API, let’s discuss how this book
    will use a couple of key terms. For this book, we will consider a *RESTful API*
    to be a set of endpoints that are all related to the same data source. From this
    perspective, your SWC website will start with a single API: the SWC Fantasy Football
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: An *API version* is a group of endpoints that are consistent for some time so
    that consumers can count on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'An *API endpoint* (also referred to as an *operation*) is a combination of
    two fundamental building blocks: an HTTP verb and a URL path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall structure of these terms is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at a few examples using a general Acme widget company ([Table 2-1](#acme_endpoints)).
    We’ll assume that the company’s APIs reside under the *[*https://api.acme.com*](https://api.acme.com)*
    subdomain.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Example endpoints in Acme API version 1
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoint description | HTTP verb | URL | Message body |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read product list | GET | *api.acme.com/v1/products/* | Empty |'
  prefs: []
  type: TYPE_TB
- en: '| Read individual product | GET | *api.acme.com/v1/products/{product_id}/*
    | Empty |'
  prefs: []
  type: TYPE_TB
- en: '| Create new product | POST | *api.acme.com/v1/products/* | Contains new product
    |'
  prefs: []
  type: TYPE_TB
- en: '| Update existing product | PUT | *api.acme.com/v1/products/{product_id}/*
    | Contains updated product |'
  prefs: []
  type: TYPE_TB
- en: '| Delete existing product | DELETE | *api.acme.com/v1/products/{product_id}*/
    | Varies |'
  prefs: []
  type: TYPE_TB
- en: You can see that the URL is reused for several of the endpoints. For example,
    the read product list endpoint uses a URL of *api.acme.com/v1/products* with a
    `GET` verb. The `GET` verb reads the product records. The create new product endpoint
    uses the same URL but with a `POST` verb. The `POST` creates a new record.
  prefs: []
  type: TYPE_NORMAL
- en: But by combining the HTTP verb with the URL, a specific action is taken when
    this resource is called. This HTTP verb plus URL combination can only be used
    once. For your portfolio project, you will develop a set of endpoints to fulfill
    the user cases you selected.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For more information about all the HTTP verbs, see [“HTTP Basics”](ch08.html#http_basics).
  prefs: []
  type: TYPE_NORMAL
- en: Technology Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SWC league host website is a web application that uses a relational database.
    Fantasy managers access the website through their web browsers. Although a large
    amount of technology is necessary to host this large website, [Figure 2-1](#current_state_architecture_ch2)
    is a high-level view of the current state application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Current state application architecture](assets/haad_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Current state application architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following components are in this architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Fantasy managers
  prefs: []
  type: TYPE_NORMAL
- en: Current web users of Sportsworldcentral.com
  prefs: []
  type: TYPE_NORMAL
- en: Web application
  prefs: []
  type: TYPE_NORMAL
- en: The existing league host website (assume it already exists for your project)
  prefs: []
  type: TYPE_NORMAL
- en: Website database
  prefs: []
  type: TYPE_NORMAL
- en: The relational database that is used for the web application (assume it already
    exists and contains data for your project)
  prefs: []
  type: TYPE_NORMAL
- en: When deciding on the architecture for an API, many choices are available. When
    a web application already exists, one option is to create the API as part of the
    web application. Many web applications use APIs as part of their design, so this
    may be the simplest route in those cases. Another option is to create the API
    as a separate application but allow the API to read directly from the website
    database. This has the advantage that the API’s data will always be up-to-date
    with the web application, but it could potentially slow down the web application
    if a large number of requests are being made to the API.
  prefs: []
  type: TYPE_NORMAL
- en: You will create the API as a separate application and pull the API’s data from
    a *read replica database*. This is a read-only copy of the website database that
    receives quick updates from the website database but is physically separate so
    that the API traffic doesn’t impact the website’s performance. Since your API
    will be read-only, the read replica is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-2](#future_state_architecture_ch2) shows the future state application
    architecture that you will implement.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Future state application architecture](assets/haad_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Future state application architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'These are the new components for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Fantasy advice websites
  prefs: []
  type: TYPE_NORMAL
- en: Will be importing your league data to their advice website.
  prefs: []
  type: TYPE_NORMAL
- en: Data science users
  prefs: []
  type: TYPE_NORMAL
- en: Will be calling your APIs to create their analytics products.
  prefs: []
  type: TYPE_NORMAL
- en: Read replica database
  prefs: []
  type: TYPE_NORMAL
- en: A separate read-only copy of the website database you will create.
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs: []
  type: TYPE_NORMAL
- en: The new API application you will create. Notice that it will use the base web
    address *api.sportsworldcentral.com* to keep it separate from the main website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technology architecture of APIs is a deep and very interesting topic, and
    the potential variations of components are nearly endless. One thing to remember
    is that a software architecture changes over time, so decisions that you make
    are not permanent. I highly recommend the book *Mastering API Architecture: Design,
    Operate, and Evolve API-Based Systems* by James Gough, Daniel Bryant, and Matthew
    Auburn (O’Reilly, 2022) to build foundational knowledge of this subject.'
  prefs: []
  type: TYPE_NORMAL
- en: Software Used in This Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since you will be creating a new API application and standalone database, take
    a look at the tools and services you will use, as shown in [Table 2-2](#tools_table_chapter_2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. New tools or services used in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: '| Software name | Version | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Python | 3.10 | Programming language |'
  prefs: []
  type: TYPE_TB
- en: '| GitHub | NA | Source control, development environment |'
  prefs: []
  type: TYPE_TB
- en: Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is the programming language you will use for all of the API code in Part
    I. You will also use it in [Part II](part02.html#part_2) to create analytics products,
    data pipelines, and interactive data applications. You will use it in [Part III](part03.html#part_3)
    to build a generative AI application. It’s possible to use Python for almost any
    job in data science, and it is the language most frequently used by data scientists,
    according to the [Anaconda 2022 State of Data Science Report](https://oreil.ly/fD4u7).
  prefs: []
  type: TYPE_NORMAL
- en: The Python open source ecosystem is very strong and deep, with high-quality
    frameworks and libraries available for almost any task you want to perform. You
    will work with a variety of popular Python libraries throughout this book, such
    as those that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Python adoption has accelerated in recent years for a variety of software development
    tasks. The [2023 Stack Overflow Developer Survey](https://oreil.ly/pvfEB) found
    that Python was in a dead heat for first as the language most developers wanted
    to use, and it ranked as the third most used at the time. Python is very flexible
    and is used in a variety of situations. It is a great tool for any developer to
    have in their toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, you will be using Python 3.10 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitHub is a website that plays a major role in software development. At its
    core, GitHub is a cloud host of source control software, but it has added additional
    features over the years. These capabilities are generally free or low cost. Many
    prominent open source projects use GitHub to host their source code and allow
    developers to contribute to the project.
  prefs: []
  type: TYPE_NORMAL
- en: You will use GitHub in several ways in this book. You will store all of your
    program code in repositories while you develop it. You will use GitHub Codespaces
    as your Python development environment. You will use GitHub Pages to publish your
    developer portal.
  prefs: []
  type: TYPE_NORMAL
- en: This book uses many of GitHub’s tools because they simplify environment management
    and work together well. The result will be a professional-looking API and data
    science portfolio that demonstrates what you have accomplished. Most of the work
    can also be performed on your local machine or another virtual environment instead
    of using GitHub. However, the instructions will assume you are using GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Your GitHub Codespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Codespaces will be the development environment for all of the API code
    you develop in Part I of this book. You can think of a Codespace as a development
    environment running VS Code in the browser. Working with Codespaces will allow
    you to run the code from the GitHub repository that I share with you, with a minimum
    of distractions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your GitHub Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before getting started with Codespaces, you need a GitHub account. [Follow the
    instructions to create a GitHub free personal account](https://oreil.ly/7j595).
    The free account will give you plenty of Codespace storage and core hours to work
    through this book. During the writing of this book, I often exceeded the free
    allocation by running multiple Codespaces, but the charge was generally a few
    dollars. Be sure to enable two-factor authentication to protect your account.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the Part I Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use another repository and make edits that you want to keep, there
    are two ways to accomplish this: forking or cloning. When you *fork* the repository,
    you create a copy in your account that remains linked to the original repository.
    This is useful when you will be submitting changes back to the original repository
    for updates. *Cloning* the repository creates a standalone copy in your GitHub
    account. For this book, I recommend that you clone the repository so that your
    portfolio project stands alone and shows the work you have completed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone the repository, log in to GitHub and go to the [GitHub Import Repository
    page](https://github.com/new/import). Enter the following information in the fields
    on this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The URL for your source repository*: **`[*https://github.com/handsonapibook/api-book-part-one*](https://github.com/handsonapibook/api-book-part-one)`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your username for your source code repository*: Leave this blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your access token or password for your source code repository*: Leave this
    blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Repository name*: **`portfolio-project`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Public*: Select this so that you can share the results of the work you are
    doing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Begin Import. The import process will begin and the message “Preparing
    your new repository” will be displayed. After several minutes, you will receive
    an email notifying you that your import has finished. Follow the link to your
    new cloned repository.
  prefs: []
  type: TYPE_NORMAL
- en: I will tell you more about the contents of this repository after you launch
    a GitHub Codespace.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Your GitHub Codespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launching a Codespace to work with this repository is simple. On this repository,
    click the Code button and select the Codespaces tab. Click “Create Codespace on
    main.” You should see a page with the status “Setting up your Codespace.” Your
    Codespace window will open as the setup continues. When the setup completes, your
    display will look similar to [Figure 2-3](#codespace_setup_complete_ch2).
  prefs: []
  type: TYPE_NORMAL
- en: '![New GitHub Codespace](assets/haad_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. New GitHub Codespace
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Your Codespace is now created with the cloned repository. This is the environment
    you will be using for the rest of Part I of this book. Before looking around,
    take a minute to open the [GitHub Codespaces page](https://github.com/codespaces)
    and make a couple of updates. Scroll down the page to find this new Codespace,
    click the ellipsis to the right of the name, and select Rename. Enter the name
    **`Portfolio project codespace`** and click Save. You should see the message “Your
    codespace *Portfolio project codespace* has been updated.” Click the ellipsis
    again, and then click the ribbon next to “Auto-delete Codespace” to turn off autodeletion.
  prefs: []
  type: TYPE_NORMAL
- en: Touring Your New Codespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go back to the tab that has your Codespace open, which looks like [Figure 2-3](#codespace_setup_complete_ch2).
    The URL of this page is an auto-generated address such as *happy-circus-1234.github.dev*.
    This will be the URL you will use to come back to this Codespace. You could bookmark
    it if you like. I typically go to the [GitHub Codespaces page](https://github.com/codespaces)
    and launch my Codespace from there.
  prefs: []
  type: TYPE_NORMAL
- en: The display that you see for Codespaces is VS Code, which is a popular open
    source IDE. Working in Codespaces will be like using VS Code through the browser.
    Remember that all of the work you do is being executed in a remote container that
    is running on the cloud. If you would like to know more about how this works,
    take a look at the [GitHub Codespaces overview](https://oreil.ly/cdesps).
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of the screen is the Explorer, which shows the directory structure
    of your Codespace. This structure begins with the structure from the cloned repository.
    There is a separate subfolder for each chapter in the book that has code. For
    example, the *chapter2* folder is where you will do your coding for this chapter.
    Inside each chapter folder is a *\complete* subfolder that contains a working
    copy of the completed code from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I suggest that you follow along with the chapter and type the files yourself.
    You will learn the purpose of the files as you perform the work. If you run into
    any trouble, the files in *\complete* are available to check your work. If you
    would like to complete the chapters out of order, you can also use the completed
    files from the previous chapters as the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the window, you will see the Terminal window selected. This
    is an interface to the command line of the Linux container that is running your
    Code​spa⁠ces. Throughout Part I, you will enter commands in the terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Codespace has been preloaded with the version of Python that you need.
    Verify this by entering **`python3 --version`** in the terminal command line.
    You should see Python version 3.10 or later, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Stop the Codespace by clicking in the bottom left of the window and entering
    **`Stop current codespace`** from the dialog window. This will reduce the number
    of free hours you use working in Codespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! This is the repository and Codespace you will use for your
    Part I portfolio project.
  prefs: []
  type: TYPE_NORMAL
- en: Making Your First Commit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Restart your Codespace from the [GitHub Codespaces page](https://github.com/codespaces).
    There is one item to notice as you work in this environment. Your new Codespace
    begins with the same directory structure as your repository on GitHub.com. However,
    files you add or make in your Codespace are initially stored only on the Codespace—they
    are not updated in your repository automatically. As you complete the code in
    this book and develop your project, you should periodically *commit* your changes
    to GitHub, which saves your changes and adds a message about the purpose of the
    change. Frequent commits ensure that you don’t lose changes if something happens
    to your Codespace and allow you to go back to a working copy if you break something.
    Consistent commits over time demonstrate activity in your GitHub profile, which
    is a sign of credibility for those viewing your GitHub history.
  prefs: []
  type: TYPE_NORMAL
- en: You do not want to commit everything in your Codespace to your repository. There
    will be some files that get generated that you don’t need to save in GitHub. This
    is where the *.gitignore* file comes in. Open this file and take a look at it
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The *.gitignore* file contains file patterns or specific names of all the files
    in your local Codespace that should be excluded from your repository. Many of
    these are local config files generated by the libraries you use. Some are sensitive
    files that should not be published in your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At a minimum, you should always commit your work when you complete a working
    session. I commit code several times an hour, when I have completed a chunk of
    work that is related. For example, if I am modifying multiple files to add a new
    scoring field to an API, I modify each file and then make a commit with the comment
    “Added scoring field.” (It is not necessary to state the files you changed in
    the comment, because GitHub tracks that.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will update the *README.md* file in the root directory. Each GitHub
    repository has a README file that provides information about the purpose and contents
    of the repository. It is written in *Markdown*, which is a lightweight formatting
    language. In your Codespace, click on the *README.md* file in the Explorer. Modify
    the text of this file as shown here, and then save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To preview what this file will look like on GitHub, right-click the *README.md*
    file and select Open Preview. You will see the updates you made. From the burger
    menu on the upper left of the window, select File, then Save. Now that you have
    saved this file, the built-in version control has flagged this. First, you see
    that the *README.md* file in the Explorer has changed color. Beside that file
    you see an M, which stands for modified. In the left sidebar, the source control
    icon has a colored circle with the numeral 1\. This means that one change is available
    to commit to source control. Click on that source control icon, and you will see
    the Source Control tab, as shown in [Figure 2-4](#source_control_tab_ch2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Source control with change flagged](assets/haad_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Source control with change flagged
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Updating your repository requires several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add commit message: The message you add will be the subject of the commit in
    GitHub.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stage your changes: Identify the changed files to be included in the commit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Commit the changes to your local repository: Your Codespace comes preloaded
    with a Git repository, and your changes get committed there first.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sync the changes from your local repo to GitHub: Push your changes up to the
    repository at the GitHub.com website, and pull down any changes that occurred
    directly on the website.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To save time from here going forward, I’m going to walk you through a shortcut
    that will save a few steps as you commit in the future. For step 1, add this message
    in the box: **`Personalize title of project.`** Next, click the Commit button.
    A dialog will be displayed that says, “There are no staged changes to commit.
    Would you like to stage all your changes and commit them directly?” Click Always.'
  prefs: []
  type: TYPE_NORMAL
- en: By choosing to always stage all changes and commit them, you are combining steps
    2 and 3\. For step 4, click Sync Changes to send the updates to the repository
    at GitHub, which is the *origin* or source of the files. When the dialog is displayed
    that says “This action will pull and push commits from and to origin/main,” click
    OK, Don’t Show Again. One last dialog will be displayed that says “Would you like
    Visual Studio Code to periodically run git fetch?” Click Yes.
  prefs: []
  type: TYPE_NORMAL
- en: In another tab, go to GitHub.com and open the *portfolio-project* repository,
    which should look like [Figure 2-5](#committed_code_ch2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Repository showing first commit](assets/haad_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Repository showing first commit
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Above the directories, click the linked text “Personalize title of your project.”
    This is the record of the commit that you just sent. You can see the files that
    you changed. When you want to commit changes going forward, you only need to add
    a title and click Commit, then click Sync Changes to commit your code to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: This is excellent progress. You have made your first commit, and you are working
    in your Codespace environment. It’s time to get started with your source data.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn about the technical architecture of APIs, I recommend *Mastering API
    Architecture: Design, Operate, and Evolve API-Based Systems*, by James Gough,
    Daniel Bryant, and Matthew Auburn (O’Reilly, 2022).'
  prefs: []
  type: TYPE_NORMAL
- en: For some tips about RESTful API design, read [“The Ten REST Commandments” by
    Steve McDougall](https://oreil.ly/_97zo).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you started creating an API to fill the user needs you identified
    in [Chapter 1](ch01.html#chapter_1). Here is what you have accomplished so far:'
  prefs: []
  type: TYPE_NORMAL
- en: You defined the API endpoints needed to complete the user stories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You set up your development environment using GitHub Codespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#chapter_3), you will create the website database using
    SQLite, create Python code to read the database with SQLAlchemy, and perform unit
    testing with pytest.
  prefs: []
  type: TYPE_NORMAL
