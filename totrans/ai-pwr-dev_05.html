<html><head></head><body>
  <h1 class="tochead" id="heading_id_2">4 <a id="idTextAnchor000"/><a id="idTextAnchor001"/><a id="idTextAnchor002"/><a id="idTextAnchor003"/><a id="idTextAnchor004"/><a id="idTextAnchor005"/><a id="idTextAnchor006"/>Building software with GitHub Copilot</h1>

  <p class="co-summary-head">This chapter covers<a id="idIndexMarker000"/><a id="marker-53"/></p>

  <ul class="calibre5">
    <li class="co-summary-bullet">Developing the core of our system using Copilot</li>

    <li class="co-summary-bullet">Refactoring to apply patterns</li>

    <li class="co-summary-bullet">Integrating hexagonal architecture</li>

    <li class="co-summary-bullet">Incorporating event-driven principles</li>
  </ul>

  <p class="body">In the last chapter, we used ChatGPT to help us design our information technology asset management (ITAM) system. Now, with the design firmly in hand, we begin to build out this application, starting with the domain model. The domain model is the core of our system. It represents the classes that will be applying and enforcing our business rules. We will use GitHub Copilot extensively in this chapter. The most important takeaway from this chapter is that using a large language model (LLM) helps to illuminate the unknown unknowns: that is, the non-obvious, the arcane, or the hidden complexity in the systems that we build. It makes the hard things easier and the seemingly impossible, possible. <a id="idIndexMarker001"/><a id="idIndexMarker002"/><a id="idIndexMarker003"/></p>

  <p class="body">One additional note: this chapter is code-heavy. Your code almost certainly will not exactly match the code presented in this chapter. Instead of dwelling on this fact, accept it. Try to understand why these differences exist. Observe if altering your prompt modifies the result, and if it does, in what ways.</p>

  <h2 class="fm-head" id="heading_id_3">4.1 Laying the foundation</h2>

  <p class="body"><a id="marker-54"/>In the first section of this chapter, we lay the foundation for the rest of our application. We begin with the core of our application: the domain model. The domain model should contain the unvarnished business rules and responsibilities of our application, free from the outside world, focusing solely on business logic and workflows. As you can see from figure 4.1, the domain sits at the heart of our application. This is no coincidence, given that it is the heart of the application. We will return to this figure throughout this chapter as we deepen our understanding of and appreciation for hexagonal architecture.<a id="idIndexMarker004"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH04_F01_Crocker2.png"/></p>

    <p class="figurecaption">Figure 4.1 A traditional visualization of hexagonal architecture in which the domain, or business logic, sits in the middle</p>
  </div>

  <p class="body">Hexagonal architecture, as you will recall from the last chapter, is an architectural pattern that aims to create a clear separation between an application’s core logic and its interaction with external systems. This principle is clearly on display in the figure 4.1.</p>

  <h3 class="fm-head1" id="heading_id_4">4.1.1 Expressing our domain model</h3>

  <p class="body">Before we begin, let’s review the documentation we created in the last chapter with the assistance of ChatGPT. The class diagram (figure 4.2) will provide us with a template for implementation. As we should know by now, we will not mindlessly implement every aspect of the code and documentation that ChatGPT provides. Doing so may inadvertently lead to a design that is brittle and hard to change, insecure, or incomplete. <a id="idIndexMarker005"/><a id="idIndexMarker006"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH04_F02_Crocker2.png"/></p>

    <p class="figurecaption">Figure 4.2 The domain object model that ChatGPT produced for us, highlighting the relationships between the classes</p>
  </div>

  <p class="body">If we drill into the methods and fields for the <code class="fm-code-in-text">Asset</code> class we created in the last chapter (see figure 4.3), note two things. First, it differs from the <code class="fm-code-in-text">Asset</code> class we created in chapter 2. Second, ChatGPT suggested that we have a constructor that takes all the attributes for this class; however, it also added mutator methods—the <i class="fm-italics">setters</i>—for all the attributes. <a id="idIndexMarker007"/><a id="idIndexMarker008"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH04_F03_Crocker2.png"/></p>

    <p class="figurecaption">Figure 4.3 The <code class="fm-code-in-text">Asset</code> class we created with the assistance of ChatGPT. It includes a constructor and mutator methods for each attribute.</p>
  </div>

  <h3 class="fm-head1" id="heading_id_5">4.1.2 Favoring immutability</h3>

  <p class="body"><a id="marker-55"/>Immutable objects, in which the internal state cannot be changed, make classes more secure and more amenable to concurrency. Should two or more threads access the same object, we do not need to synchronize access; the state will almost certainly be the same for both threads. Therefore, we will favor constructor-based value injection over mutator methods. When we code this class, we will not add mutators. <a id="idIndexMarker009"/><a id="idIndexMarker010"/><a id="idIndexMarker011"/></p>

  <p class="body">First we will pull the <code class="fm-code-in-text">purchase_date</code> field up from <code class="fm-code-in-text">Hardware</code>. This field is shared among all <code class="fm-code-in-text">Asset</code>s (this book will not discuss cases in which <code class="fm-code-in-text">Asset</code>s are leased); therefore, the <code class="fm-code-in-text">purchase_date</code> field should belong in the parent class.<a id="idIndexMarker012"/><a id="idIndexMarker013"/></p>

  <p class="body">Next we need to add a few additional fields that are not present in our design from the last chapter: <code class="fm-code-in-text">cost</code>, <code class="fm-code-in-text">useful_life</code>, and <code class="fm-code-in-text">salvage_value</code>. These fields will be necessary to correctly calculate <i class="fm-italics">depreciation</i>. You may remember that depreciation is an accounting method used to allocate the cost of an asset over its useful life. You should notice that the terms <code class="fm-code-in-text">cost</code> and <code class="fm-code-in-text">useful_life</code> appear in that definition. Thus these fields are required. In addition, the salvage value is the amount of money a business, department, or company can expect to get from selling the asset at the end of its useful life. This field is essential in some depreciation calculations; therefore, we will add it to our class. Create a package called <code class="fm-code-in-text">domain</code>/<code class="fm-code-in-text">model</code>, add a file called asset.py, and then add the following prompt to the beginning of this file:<a id="idIndexMarker014"/><a id="idIndexMarker015"/><a id="idIndexMarker016"/><a id="idIndexMarker017"/><a id="idIndexMarker018"/><a id="idIndexMarker019"/><a id="marker-56"/></p>
  <pre class="programlistinge"># Define a class named Asset
# It should have the following attributes: 
# - id: int
# - name: str
# - status: str
# - category: str
# - cost: float
# - useful_life: float
# - salvage_value: float
# - purchase_date: datetime
# 
# The attributes cannot be None and cannot be added after construction
# However, we should be able to access the attributes using methods</pre>

  <p class="body">As you tab through the file to have GitHub Copilot autogenerate the code for you, you may notice that it will create the mutator despite us explicitly instructing it not to do that. For this and many other reasons (as we will see throughout this chapter), you must remain vigilant and mindful as you code. Of course, you can signal your intent, but these tools may override your desires in the way the tools construct code. Additionally, you may notice that Copilot added the <code class="fm-code-in-text">@dataclasses</code> decorator. <a id="idIndexMarker020"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Decorator Design Pattern</p>

    <p class="fm-sidebar-text">The Decorator Design Pattern is a structural design pattern that allows you to add new or modify existing behavior to an object dynamically without changing the existing class. This is done by wrapping the existing object in the decorating object. <a id="idIndexMarker021"/></p>
  </div>

  <p class="body">An interesting exercise for an intrepid explorer would be to ask Copilot to assume the persona—using the Persona Pattern—of a software engineer. Does this change the output in any meaningful way?</p>

  <p class="fm-callout"><span class="fm-callout-head">Definition</span> <i class="fm-italics">Design patterns</i> are common solutions to recurring design problems in software development. We will explore them more throughout this chapter.<a id="idIndexMarker022"/></p>

  <h3 class="fm-head1" id="heading_id_6">4.1.3 Decorating our favorite classes</h3>

  <p class="body"><a id="marker-57"/>This decorator autogenerates common methods for Python (equals and string representation, among others). A data class is a class that is primarily used to store data and does not have much behavior. In Python, data classes were introduced in Python 3.7 as a utility to make classes that are mainly used to store data cleaner and more efficient. This is opposed to a user-defined class, whose purpose can be mixed (that is, data and behavior). Using a data class in this context is useful in that you can avoid boilerplate code for constructing, representing, and comparing objects. Also, for those keeping score at home, our autogenerated code is autogenerating code. <a id="idIndexMarker023"/><a id="idIndexMarker024"/></p>

  <p class="fm-code-listing-caption">Listing 4.1 Code that GitHub Copilot creates in response to our prompt</p>
  <pre class="programlisting">from dataclasses import dataclass
from itam.domain.funding_details import FundingDetails
  
@dataclass
class Asset:
    id: int
    name: str
    status: str
    category: str
    cost: float
    useful_life: float
    salvage_value: float
    purchase_date: datetime
  
    def __post_init__(self):
        if self.id is None:
            raise TypeError("ID cannot be None")
        if self.name is None:
            raise TypeError("Name cannot be None")
        if self.status is None:
            raise TypeError("Status cannot be None")
        if self.category is None:
            raise TypeError("Category cannot be None")
        if self.cost is None:
            raise TypeError("Cost cannot be None")
        if self.useful_life is None:
            raise TypeError("Useful life cannot be None")
        if self.salvage_value is None:
            raise TypeError("Salvage value cannot be None")
  
    def get_id(self):
        return self.id
  
    ... # other accessors omitted for clarity</pre>

  <p class="body">The <code class="fm-code-in-text">__post_init__()</code> method will run after the constructor and enforce that none of the parameters are null (<code class="fm-code-in-text">None</code> in Python parlance). Coding defensively this way will ensure that your values cannot change after initialization. Of course, you are free to add additional validations as well, such as acceptable values for the status of the category. But if you wish to enforce values in that case, it is better to do so by making them proper classes or using the <code class="fm-code-in-text">Enum</code> class. <a id="idIndexMarker025"/><a id="idIndexMarker026"/><a id="marker-58"/></p>

  <p class="body">Next, let’s review the <code class="fm-code-in-text">Hardware</code> class in the Mermaid diagram we created in the last chapter (see figure 4.4). There are several items to note from this diagram: it contains neither accessor nor mutator methods. We will need to add accessor methods to our prompt.<a id="idIndexMarker027"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH04_F04_Crocker2.png"/></p>

    <p class="figurecaption">Figure 4.4 The <code class="fm-code-in-text">Hardware</code> class that we drafted with the aid of ChatGPT. Note that it does not have any accessor methods.</p>
  </div>

  <p class="body">Now that we have reviewed and assessed what methods and attributes we need in our <code class="fm-code-in-text">Hardware</code> class, we can build it. Create a file called hardware.py in the domain directory. At the beginning of this file, add the following prompt to have GitHub Copilot create our <code class="fm-code-in-text">Hardware</code> class:<a id="idIndexMarker028"/></p>
  <pre class="programlistinge"># Define a class called Hardware, which is an instance of Asset.
# The Hardware entity has the following attributes:
# - serial_number: str,
# - location: Location,
# - warranty_expiration_date: date,
# - notes: str
# - maintenance_schedules: List[MaintenanceSchedule]
# - warranty: Warranty
# - retirement_date: date
# - retirement_reason: str
# - usage_statistics: UsageStatistics
# - budget: Budget
# The attributes can be None and the class should have a constructor that takes all attributes as parameters.
# The attributes should be private and the class should have accessor methods for all attributes.</pre>

  <p class="body">The post-constructor code and accessor methods are not included in the code listing, for brevity’s sake. However, they should be automatically added to your file.</p>

  <p class="fm-code-listing-caption">Listing 4.2 Definition of the <code class="fm-code-in-text">Hardware</code> class<a id="idIndexMarker029"/></p>
  <pre class="programlisting">from datetime import datetime
from dataclasses import dataclass
from itam.domain.asset import Asset
from itam.domain.location import Location
from itam.domain.warranty import Warranty
from itam.domain.maintenance_schedule import MaintenanceSchedule
from itam.domain.usage_statistics import UsageStatistics
from itam.domain.budget import Budget
  
@dataclass
class Hardware(Asset):
    serial_number: str
    location: Location
    warranty_expiration_date: datetime
    notes: str
    maintenance_schedules: list[MaintenanceSchedule]
    warranty: Warranty
    retirement_date: datetime
    retirement_reason: str
    usage_statistics: UsageStatistics
    budget: Budget</pre>

  <p class="body">Next, given that it was referenced in the <code class="fm-code-in-text">Asset</code> class, let’s add the <code class="fm-code-in-text">FundingDetails</code> class. First, however, let’s review the class diagram (see figure 4.5). Notice that the <code class="fm-code-in-text">lines_of_business</code> dictionary, which we will rename to <code class="fm-code-in-text">department_allocations,</code> uses a string as the key. We should change this to be an actual <code class="fm-code-in-text">Department</code>. This is another reminder that we must actively monitor the generated code and make decisions about how to best implement the project. <a id="idIndexMarker030"/><a id="idIndexMarker031"/><a id="idIndexMarker032"/><a id="idIndexMarker033"/><a id="idIndexMarker034"/><a id="marker-59"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH04_F05_Crocker2.png"/></p>

    <p class="figurecaption">Figure 4.5 The <code class="fm-code-in-text">FundingDetails</code> class that we drafted with the aid of ChatGPT. We need to change the <code class="fm-code-in-text">lines_of_business</code> dict (renamed to <code class="fm-code-in-text">department_allocations</code>) to use a <code class="fm-code-in-text">Department</code> as the key.<a id="idIndexMarker035"/><a id="idIndexMarker036"/><a id="idIndexMarker037"/><a id="idIndexMarker038"/></p>
  </div>

  <p class="body">We need to make two additional edits to this class. First, we need to include the <code class="fm-code-in-text">Asset</code> in the constructor. This will allow us access to the fields needed for calculating depreciations, as previously mentioned. Additionally, we need to include a depreciation rate in the constructor. This is used for declining depreciation but not straight-line depreciation. We could set the value of this field in the specific deprecation constructor or use a mutator method, but for now we will add it to the <code class="fm-code-in-text">FundingDetails</code> class. The updated prompt to create the <code class="fm-code-in-text">FundingDetails</code> class, including the updated field name, is shown next:<a id="idIndexMarker039"/><a id="idIndexMarker040"/></p>
  <pre class="programlistinge"># Define a class called FundingDetails
# It should have the following attributes: 
# - asset: Asset
# - depreciation_strategy: DepreciationStrategy,
# - depreciation_rate: float
# - department_allocations: Dict[Department, float]
# The attributes cannot be None and cannot be modified after construction
# However, we should be able to access the attributes using methods</pre>

  <p class="body">There is nothing surprising in the generated class: the code establishes the internal attributes and sets them via the constructor. After the constructor has finished, it will check that all attributes are <code class="fm-code-in-text">None</code>.</p>

  <p class="fm-code-listing-caption">Listing 4.3 <code class="fm-code-in-text">FundingDetails</code> class (post constructor and accessor omitted)<a id="idIndexMarker041"/><a id="marker-60"/></p>
  <pre class="programlisting">from dataclasses import dataclass
from itam.domain.asset import Asset
from itam.domain.depreciation_strategy import DepreciationStrategy
from itam.domain.department import Department
  
@dataclass
class FundingDetails:
    asset: Asset
    depreciation_strategy: DepreciationStrategy
    depreciation_rate: float
    department_allocations: Dict[Department, float]
  
    def __post_init__(self):
        if self.asset is None:
            raise TypeError("Asset cannot be None")
        if self.depreciation_strategy is None:
            raise TypeError("Depreciation strategy cannot be None")
        if self.depreciation_rate is None:
            raise TypeError("Depreciation rate cannot be None")
        if self.department_allocations is None:
            raise TypeError("Department allocations cannot be None")
  
    def get_asset(self):
        return self.asset
  
    def get_depreciation_strategy(self):
        return self.depreciation_strategy
  
    def get_depreciation_rate(self):
        return self.depreciation_rate
  
    def get_department_allocations(self):
        return self.department_allocations</pre>

  <p class="body">The final class we will generate in this chapter is <code class="fm-code-in-text">DepreciationStrategy</code>. In the last chapter, we were briefly introduced to this class. What we did not mention at the time was that this class will employ a new design pattern: the <i class="fm-italics">Strategy</i> Pattern.<a id="idIndexMarker042"/><a id="idIndexMarker043"/><a id="idIndexMarker044"/><a id="idIndexMarker045"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Strategy Pattern</p>

    <p class="fm-sidebar-text">The Strategy Pattern is a behavioral design pattern that lets you define a family of algorithms, encapsulate each one as an object, and make them interchangeable. The idea behind the Strategy Pattern is to define a common interface for a group of algorithms so they’re interchangeable despite having potentially very different implementations.<a id="idIndexMarker046"/></p>
  </div>

  <h3 class="fm-head1" id="heading_id_7">4.1.4 Adapting a strategy for depreciation</h3>

  <p class="body">Before we attempt to create the <code class="fm-code-in-text">DepreciationStrategy</code> class, let’s review the class diagram that we created in the last chapter (see figure 4.6). The implementations of this class contain substantial hidden complexity. If we don’t give Copilot very specific instructions about how the calculations are to be performed, it will not come up with the correct algorithms. For example, here’s an incomplete, inexact prompt to create <code class="fm-code-in-text">DepreciationStrategy</code>:<a id="idIndexMarker047"/><a id="idIndexMarker048"/><a id="idIndexMarker049"/><a id="idIndexMarker050"/><a id="marker-61"/></p>
  <pre class="programlistinge"># Define an interface called DepreciationStrategy. 
# It should have four concrete implementations of the interface: StraightLineDepreciationStrategy, DecliningBalanceDepreciationStrategy, DoubleDecliningDepreciationStrategy, and NoDepreciationStrategy.
# Each implementation overrides the calculate_depreciation() method to provide a specific way of calculating depreciation for an asset based on its funding details.
# The calculate_depreciation() method should take a FundingDetails object as a parameter and return a float value representing the depreciation amount.</pre>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH04_F06_Crocker2.png"/></p>

    <p class="figurecaption">Figure 4.6 The interface class <code class="fm-code-in-text">DepreciationStrategy</code> defines the functionality to calculate the depreciation of our assets in our domain model. There are four concrete classes representing how we can depreciate an asset.</p>
  </div>

  <p class="body">This prompt will return methods that, at first sight, appear correct. But they are not. For example, if we examine the straight-line depreciation method, we see that it neither includes the salvage value in the calculation nor uses the useful life.</p>

  <p class="fm-code-listing-caption">Listing 4.4 Incorrect implementation of straight-line depreciation</p>
  <pre class="programlisting">class StraightLineDepreciationStrategy(DepreciationStrategy):
    def calculate_depreciation(self, funding_details: FundingDetails) -&gt; float:
    return funding_details.get_asset().get_cost() * 
funding_details.get_depreciation_rate()</pre>

  <p class="body">To correct this, we should update the prompt with the actual formulas for the depreciation methods. Fortunately, we do not have to provide the exact syntax, just the calculations. Copilot will translate our algorithms to validate Python code. Here is the updated prompt:<a id="marker-62"/></p>
  <pre class="programlistinge"># Define an interface called DepreciationStrategy. 
# It should have four concrete implementations of the interface: StraightLineDepreciationStrategy, DecliningBalanceDepreciationStrategy, DoubleDecliningDepreciationStrategy, and NoDepreciationStrategy.
# Each implementation overrides the calculate_depreciation() method to provide a specific way of calculating depreciation for an asset based on its funding details.
# The calculate_depreciation() method should take a FundingDetails object as a parameter and return a float value representing the depreciation amount.
# NoDepreciationStrategy should return 0 for all assets.
# The other three strategies should return the depreciation amount based on the following formulas:
# - Straight Line: (cost - salvage value) / useful_life
# - Declining Balance: cost * (1-rate/100)^(current_year - purchase_year)
# - Double Declining: Declining Balance * 2</pre>

  <p class="body">Note that we can use pseudocode. Copilot handles the rest.</p>

  <p class="fm-code-listing-caption">Listing 4.5 Output from our prompt to calculate depreciation methods</p>
  <pre class="programlisting">from abc import ABC, abstractmethod
from itam.domain.funding_details import FundingDetails
from math import pow
  
class DepreciationStrategy(ABC):
    @abstractmethod
    def calculate_depreciation(self, funding_details: FundingDetails) -&gt; float:
        pass
  
class StraightLineDepreciationStrategy(DepreciationStrategy):
    def calculate_depreciation(self, funding_details: FundingDetails) -&gt; float:
        cost = funding_details.get_asset().get_cost()
        salvage_value = funding_details.get_asset().get_salvage_value()
        useful_life = funding_details.get_asset().get_useful_life()
        return (cost - salvage_value) / useful_life
  
class DecliningBalanceDepreciationStrategy(DepreciationStrategy):
    def calculate_depreciation(self, funding_details: FundingDetails) -&gt; float:
        cost = funding_details.get_asset().get_cost()
        depreciation_rate = funding_details.get_depreciation_rate()
        return cost * pow(1 - (depreciation_rate / 100), 
datetime.now().year - asset.get_purchase_date().year)
  
  
class DoubleDecliningDepreciationStrategy(DepreciationStrategy):
    def calculate_depreciation(self, funding_details: FundingDetails) -&gt; float:
        cost = funding_details.get_asset().get_cost()
        depreciation_rate = funding_details.get_depreciation_rate()
        return DecliningBalanceDepreciationStrategy()
.calculate_depreciation(funding_details) * 2
  
class NoDepreciationStrategy(DepreciationStrategy):
    def calculate_depreciation(self, asset: Asset) -&gt; float:
        return 0</pre>

  <p class="body">Many other classes are left undefined. Feel free to practice perfecting your prompt engineering by implementing the missing classes. For example, you may want to add <code class="fm-code-in-text">Organizations</code>, <code class="fm-code-in-text">MaintenanceSchedule</code>, <code class="fm-code-in-text">Address</code>, <code class="fm-code-in-text">UsageStatistics</code>, <code class="fm-code-in-text">User</code>, <code class="fm-code-in-text">Role</code>, and <code class="fm-code-in-text">Warranty</code>. In the next section, we will work with Copilot to apply patterns to our code, starting with a familiar one. <a id="idIndexMarker051"/><a id="idIndexMarker052"/><a id="idIndexMarker053"/><a id="idIndexMarker054"/><a id="idIndexMarker055"/><a id="idIndexMarker056"/><a id="idIndexMarker057"/><a id="idIndexMarker058"/><a id="idIndexMarker059"/><a id="idIndexMarker060"/><a id="marker-63"/></p>

  <h2 class="fm-head" id="heading_id_8">4.2 Weaving patterns, patterns, patterns</h2>

  <p class="body">In this section, we enrich our domain model with commonly used design patterns. They represent best practices and can be used to speed up the development process by providing a set of proven solutions to certain problems. Design patterns are not ready-to-use code snippets but rather general guides on how to solve a particular problem in a way that is flexible and can be reused across different projects.<a id="idIndexMarker061"/></p>

  <h3 class="fm-head1" id="heading_id_9">4.2.1 Paying a visit to our department</h3>

  <p class="body">The first pattern we will revisit is <i class="fm-italics">Visitor</i>. As you may recall from chapter 3, you use the Visitor Pattern to add new behavior to or change the existing behavior of a given class. Figure 4.7 shows how it was modeled in the last chapter. <a id="idIndexMarker062"/><a id="idIndexMarker063"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH04_F07_Crocker2.png"/></p>

    <p class="figurecaption">Figure 4.7 The <code class="fm-code-in-text">DepartmentVisitor</code> interface (updated to use the new name; previously called <code class="fm-code-in-text">LineOfBusinessVisitor</code>). This class “visits” both hardware and software, holding the total cost and depreciation internally. <a id="idIndexMarker064"/></p>
  </div>

  <p class="body">Let’s design a prompt to have Copilot generate an implementation of our <code class="fm-code-in-text">Visitor</code> Pattern, <code class="fm-code-in-text">DepartmentVisitor</code>, which visits our <code class="fm-code-in-text">Asset</code>:<a id="idIndexMarker065"/><a id="idIndexMarker066"/></p>
  <pre class="programlistinge"># Define an interface called class DepartmentVisitor with the following methods:
#  +visit(self, asset: Asset) -&gt; None
# Additionally, define a class called class DepartmentStatisticsVisitor that implements the interface DepartmentVisitor</pre>

  <p class="body">Copilot generates the straightforward implementation of this class.</p>

  <p class="fm-code-listing-caption">Listing 4.6 <code class="fm-code-in-text">Vistor</code> implementation<a id="idIndexMarker067"/><a id="marker-64"/></p>
  <pre class="programlisting">from abc import ABC, abstractmethod
from itam.domain.asset import Asset
  
class DepartmentVisitor(ABC):
    @abstractmethod
    def visit(self, asset: Asset) -&gt; None:
        pass
  
class DepartmentStatisticsVisitor(DepartmentVisitor):
    def __init__(self):
        self._total_cost = 0
        self._total_depreciation = 0
        self._total_allocation = 0
  
    def visit(self, asset: Asset) -&gt; None:
        self._total_cost += asset.get_cost()
        self._total_depreciation += asset.get_depreciation()
        self._total_allocation += asset.get_allocation()
  
    def get_total_cost(self):
        return self._total_cost
  
    def get_total_depreciation(self):
        return self._total_depreciation
  
    def get_total_allocation(self):
        return self._total_allocation</pre>

  <h3 class="fm-head1" id="heading_id_10">4.2.2 Creating objects in a factory (pattern)</h3>

  <p class="body">The <i class="fm-italics">Factory</i> Pattern is another creation pattern that allows you to abstract away some of the details of the object you are attempting to create. In our ITAM system, we have two types of <code class="fm-code-in-text">Asset</code> (currently): <code class="fm-code-in-text">Hardware</code> and <code class="fm-code-in-text">Software</code>. Each of these objects has attributes idiosyncratic to itself. One effect of this is that our application does not need to know the specifics of the concrete class (<code class="fm-code-in-text">Hardware</code>, for example). From the application’s perspective, it just gets an instance of <code class="fm-code-in-text">Asset</code> with additional fields. Let’s look at how to get Copilot to create an <code class="fm-code-in-text">AssetFactory</code> class for us:<a id="idIndexMarker068"/><a id="idIndexMarker069"/><a id="idIndexMarker070"/><a id="idIndexMarker071"/><a id="idIndexMarker072"/><a id="idIndexMarker073"/><a id="idIndexMarker074"/><a id="idIndexMarker075"/></p>
  <pre class="programlistinge"># Define a class called AssetFactory
# It should have the following methods:
#        +new(self, asset_type: str, asset_name: str, asset_cost: float, useful_life: int, depreciation_strategy: str, depreciation_rate: float, salvage_value: float, asset_purchase_date: str) -&gt; Asset
# When asset_type is equal to "hardware" it should delegate the call to a class called HardwareAssetFactory
# When asset_type is equal to "software" it should delegate the call to a class called SoftwareAssetFactory
# If it is neither "hardware" nor "software" it should raise a ValueError
# When depreciation_strategy is equal to "straight_line" it should return a new instance of StraightLineDepreciationStrategy
# When depreciation_strategy is equal to "double_declining_balance" it should return a new instance of DoubleDecliningDepreciationStrategy
# When depreciation_strategy is equal to "none" it should return a new instance of NoDepreciationStrategy
# When depreciation_strategy is equal to "declining_balance" it should return a new instance of DecliningBalanceDepreciationStrategy
# The HardwareAssetFactory and the SoftwareAssetFactory should get the id from the AssetFactory on each call to new.</pre>

  <p class="body">This prompt is one of the most detailed we have encountered. As our needs get more and more niche, our prompts will naturally become more meticulous. Let’s examine this code in detail, starting with the <code class="fm-code-in-text">new</code> method.<a id="marker-65"/></p>

  <p class="fm-code-listing-caption">Listing 4.7 Code for <code class="fm-code-in-text">AssetFactory</code>, containing two embedded factories</p>
  <pre class="programlisting">from datetime import datetime
from itam.domain.asset import Asset
from itam.domain.hardware import Hardware
from itam.domain.funding_details import FundingDetails
from itam.domain.depreciation_strategy import (
    DepreciationStrategy,
    StraightLineDepreciationStrategy,
    DecliningBalanceDepreciationStrategy,
    DoubleDecliningDepreciationStrategy,
    NoDepreciationStrategy
)
 
class AssetFactory:
    def __init__(self):
        self.id = 0
 
    def date_from_string(self, date_string: str) -&gt; datetime:
        return datetime.strptime(date_string, "%Y-%m-%d")
  
    def new(self, asset_type: str, asset_name: str, 
asset_cost: float, useful_life: int, 
depreciation_strategy: str, depreciation_rate: 
float, salvage_value: float, 
asset_purchase_date: str) -&gt; Asset:
        self.id += 1
        purchase_date = self.date_from_string(asset_purchase_date)
  
        if asset_type == "hardware":
            return HardwareAssetFactory().new(self.id, 
asset_name, asset_cost, useful_life, 
depreciation_strategy, 
depreciation_rate, salvage_value, 
purchase_date)
        elif asset_type == "software":
            return SoftwareAssetFactory().new(self.id, 
asset_name, asset_cost, useful_life, 
depreciation_strategy, depreciation_rate, 
salvage_value, purchase_date)
        else:
            raise ValueError</pre>

  <p class="body">The <code class="fm-code-in-text">new</code> method determines which of the specific factories it needs to call based on the <code class="fm-code-in-text">asset_type</code> parameter. Additionally, it keeps track of the number of assets it has created, ensuring that the identifier (<code class="fm-code-in-text">id</code> field) is always unique. Otherwise, if the identifier creation were pushed down to the specific <code class="fm-code-in-text">Factory</code> object, we would get duplicate keys.<a id="idIndexMarker076"/><a id="idIndexMarker077"/><a id="idIndexMarker078"/><a id="idIndexMarker079"/><a id="marker-66"/></p>

  <p class="fm-code-listing-caption">Listing 4.8 Embedded <code class="fm-code-in-text">HardwareAssetFactory</code> class</p>
  <pre class="programlisting">class HardwareAssetFactory:
    def new(self, id: int, asset_name: 
str, asset_cost: float, 
useful_life: int, 
depreciation_strategy: str, 
depreciation_rate: float, 
salvage_value: float, 
purchase_date: datetime) -&gt; Asset:
        a = Hardware (
            id=id,
            name=asset_name,
            category="hardware",
            cost=asset_cost,
            useful_life=useful_life,
            status="active",
            salvage_value=salvage_value,
            purchase_date=purchase_date
        )
        
        funding_details=FundingDetails(
                asset=a,
                depreciation_strategy=
                    self._get_depreciation_strategy(depreciation_strateg,
                depreciation_rate=depreciation_rate,
                department_allocations=dict()
            )
        
        a.funding_details = funding_details
        return a
  
    def _get_depreciation_strategy(self, 
depreciation_strategy: str) -&gt; DepreciationStrategy:
        if depreciation_strategy == "straight_line":
            return StraightLineDepreciationStrategy()
        elif depreciation_strategy == "double_declining_balance":
            return DoubleDecliningDepreciationStrategy()
        elif depreciation_strategy == "none":
            return NoDepreciationStrategy()
        elif depreciation_strategy == "declining_balance":
            return DecliningBalanceDepreciationStrategy()
        else:
            raise ValueError</pre>

  <p class="body">The <code class="fm-code-in-text">new</code> method of the <code class="fm-code-in-text">HardwareAssetFactory</code> class is relatively straightforward. This method accepts the parameters from the <code class="fm-code-in-text">AssetFactory</code>, attempts to resolve the <code class="fm-code-in-text">DepreciationStrategy</code>, and sets some sensible defaults. <a id="idIndexMarker080"/><a id="idIndexMarker081"/><a id="marker-67"/></p>

  <p class="fm-code-listing-caption">Listing 4.9 Embedded <code class="fm-code-in-text">SoftwareAssetFactory</code> class</p>
  <pre class="programlisting">class SoftwareAssetFactory:
    def new(self, id: int, asset_name: str, 
asset_cost: float, 
useful_life: int, 
depreciation_strategy: str, 
depreciation_rate: float, 
salvage_value: float, 
purchase_date: datetime) -&gt; Asset:
        a = Asset(
            id=id,
            name=asset_name,
            category="software",
            cost=asset_cost,
            useful_life=useful_life,
            status="active",
            salvage_value=salvage_value,
            purchase_date=purchase_date
        )
  
        funding_details=FundingDetails(
            asset=a,
            depreciation_strategy=self.
_get_depreciation_strategy(depreciation_strategy),
            depreciation_rate=depreciation_rate,
            department_allocations=dict()
        )
        
        a.funding_details = funding_details
        return a
  
    def _get_depreciation_strategy(self, 
depreciation_strategy: str) -&gt; DepreciationStrategy:
        if depreciation_strategy == "straight_line":
            return StraightLineDepreciationStrategy()
        elif depreciation_strategy == "double_declining_balance":
            return DoubleDecliningDepreciationStrategy()
        elif depreciation_strategy == "none":
            return NoDepreciationStrategy()
        elif depreciation_strategy == "declining_balance":
            return DecliningBalanceDepreciationStrategy()
        else:
            raise ValueError</pre>

  <p class="body">The <code class="fm-code-in-text">SoftwareAssetFactory</code> class is nearly identical to the <code class="fm-code-in-text">HardwareAssetFactory</code> class—so much so that it likely has a code smell. The term <i class="fm-italics">code smell</i> in software development describes an intuition a developer has, indicating that there may be a deeper problem with the code. It is not a bug per se, but a feeling. You may find yourself with the urge to refactor, because this does appear to violate the DRY principle (Don’t Repeat Yourself).<a id="idIndexMarker082"/><a id="idIndexMarker083"/><a id="idIndexMarker084"/><a id="marker-68"/></p>

  <p class="body">But there is an easier way to handle this deduplication. To do this, we will look at our next design pattern: the <i class="fm-italics">Builder</i> Pattern. <a id="idIndexMarker085"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Builder Pattern</p>

    <p class="fm-sidebar-text">The Builder Pattern is a creational design pattern that provides a fluent API for the creation of objects by providing step-by-step instructions for how to create an object. <a id="idIndexMarker086"/></p>
  </div>

  <h3 class="fm-head1" id="heading_id_11">4.2.3 Instructing the system on how to build</h3>

  <p class="body">First we will write a prompt to have Copilot create our builders: one for <code class="fm-code-in-text">Asset</code> and one for <code class="fm-code-in-text">FundingDetails</code>. We will let the builder know that if <code class="fm-code-in-text">asset_type</code> is hardware, it should return an instance of <code class="fm-code-in-text">Hardware</code>, and the same for <code class="fm-code-in-text">Software</code>:<a id="idIndexMarker087"/><a id="idIndexMarker088"/></p>
  <pre class="programlistinge"># Create a class called AssetBuilder
# It should use the Builder pattern to build an Asset
# Create another class called FundingDetailsBuilder
# It should use the Builder pattern to build a FundingDetails
# The AssetBuilder should have an embedded FundingDetailsBuilder
# When the category is "hardware" the AssetBuilder should create a Hardware object
# When the category is "software" the AssetBuilder should create a Software object
# When depreciation_strategy is equal to "straight_line" it should return a new instance of StraightLineDepreciationStrategy
# When depreciation_strategy is equal to "double_declining_balance" it should return a new instance of DoubleDecliningDepreciationStrategy
# When depreciation_strategy is equal to "none" it should return a new instance of NoDepreciationStrategy
# When depreciation_strategy is equal to "declining_balance" it should return a new instance of DecliningBalanceDepreciationStrategy
# The variables will need to be held in local variables and then passed to the Asset and FundingDetails objects when they are created.
# The final method of the AssetBuilder should return an Asset and be called build().
# The final method of the FundingDetailsBuilder should return a FundingDetails and be called build().</pre>

  <p class="body">One thing to note is that all the values need to be stored in local variables; otherwise, we would encounter post-initialization exceptions. The generated code for the <code class="fm-code-in-text">AssetBuilder</code> is is shown next. The <code class="fm-code-in-text">import</code> statements and accessor methods are omitted for the sake of brevity. One thing worth mentioning is that the methods return <code class="fm-code-in-text">self</code> so they can be chained together.<a id="idIndexMarker089"/></p>

  <p class="fm-code-listing-caption">Listing 4.10 Corresponding <code class="fm-code-in-text">AssetBuilder</code> classes</p>
  <pre class="programlisting">class AssetBuilder:
    def __init__(self):
        self.id = 0
        self.name = ""
        self.category = ""
        self.cost = 0.0
        self.useful_life = 0
        self.status = ""
        self.salvage_value = 0.0
        self.purchase_date = datetime.now()
  
    def with_name(self, name):
        self.name = name
        return self
  
    ...</pre>

  <p class="body"><a id="marker-69"/>Next we will examine the <code class="fm-code-in-text">build()</code> method of the <code class="fm-code-in-text">AssetBuilder</code> class. This method uses the <code class="fm-code-in-text">category</code> field to return the correct subclass of <code class="fm-code-in-text">Asset</code>.<a id="idIndexMarker090"/></p>

  <p class="fm-code-listing-caption">Listing 4.11 <code class="fm-code-in-text">build()</code> method for the <code class="fm-code-in-text">AssetBuilder</code> classes</p>
  <pre class="programlisting">def build(self) -&gt; Asset:
        if self.category == "hardware":
            return Hardware(
                id=self.id,
                name=self.name,
                category=self.category,
                cost=self.cost,
                useful_life=self.useful_life,
                status=self.status,
                salvage_value=self.salvage_value,
                purchase_date=self.purchase_date
            )
        elif self.category == "software":
            return Software(
                id=self.id,
                name=self.name,
                category=self.category,
                cost=self.cost,
                useful_life=self.useful_life,
                status=self.status,
                salvage_value=self.salvage_value,
                purchase_date=self.purchase_date
            )
        else:
            return Asset(
                id=self.id,
                name=self.name,
                category=self.category,
                cost=self.cost,
                useful_life=self.useful_life,
                status=self.status,
                salvage_value=self.salvage_value,
                purchase_date=self.purchase_date
            )</pre>

  <p class="body">We can now look at <code class="fm-code-in-text">FundingDetailsBuilder</code>. This class closely resembles <code class="fm-code-in-text">AssetBuilder</code>, but without the polymorphic <code class="fm-code-in-text">build()</code> method. <a id="idIndexMarker091"/><a id="marker-70"/></p>

  <p class="fm-code-listing-caption">Listing 4.12 <code class="fm-code-in-text">FundingDetailsBuilder</code> class</p>
  <pre class="programlisting">class FundingDetailsBuilder:
    def __init__(self):
        self.asset = None
        self.depreciation_strategy = ""
        self.depreciation_rate = 0.0
        self.department_allocations = dict()
  
    def with_asset(self, asset: Asset) -&gt; FundingDetailsBuilder:
        self.asset = asset
        return self
  
    ...</pre>

  <p class="body">The class’s <code class="fm-code-in-text">build()</code> method implementation is fairly straightforward; it only returns an instance of the <code class="fm-code-in-text">FundingDetails</code> object after applying the parameters to the constructor.<a id="idIndexMarker092"/></p>

  <p class="fm-code-listing-caption">Listing 4.13 <code class="fm-code-in-text">build()</code> method of the <code class="fm-code-in-text">FundingDetailsBuilder</code> class</p>
  <pre class="programlisting">def build(self) -&gt; FundingDetails:
        return FundingDetails(
            asset=self.asset,
            depreciation_strategy=self.depreciation_strategy,
            depreciation_rate=self.depreciation_rate,
            department_allocations=self.department_allocations)</pre>

  <p class="body">Next, let’s extract the <code class="fm-code-in-text">_get_depreciation_strategy</code> method from the <code class="fm-code-in-text">AssetFactory</code> class, consolidating the logic of mapping the name of the depreciation strategy to an instance of the <code class="fm-code-in-text">DepreciationStrategy</code>.<a id="idIndexMarker093"/></p>

  <p class="fm-code-listing-caption">Listing 4.14 Updated <code class="fm-code-in-text">build()</code> method of <code class="fm-code-in-text">FundingDetailsBuilder</code></p>
  <pre class="programlisting">    def _get_depreciation_strategy(self, 
depreciation_strategy: str) -&gt; DepreciationStrategy:
        if depreciation_strategy == "straight_line":
            return StraightLineDepreciationStrategy()
        elif depreciation_strategy == "double_declining_balance":
            return DoubleDecliningDepreciationStrategy()
        elif depreciation_strategy == "none":
            return NoDepreciationStrategy()
        elif depreciation_strategy == "declining_balance":
            return DecliningBalanceDepreciationStrategy()
        else:
            raise ValueError
  
    def build(self) -&gt; FundingDetails:
        return FundingDetails(
            asset=self.asset,
            depreciation_strategy=self.
_get_depreciation_strategy(depreciation_strategy),
            depreciation_rate=self.depreciation_rate,
            department_allocations=self.department_allocations
        )</pre>

  <p class="body">Now that we have written the builders, we can modify the <code class="fm-code-in-text">AssetFactory</code> to use them.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">A pattern hiding in plain sight: The Adapter</p>

    <p class="fm-sidebar-text">The <i class="fm-italics">Adapter</i> Pattern is a structural design pattern that allows us to bridge the gap between the target interface and a class with an incompatible interface. For example, in our case, we could have formalized the interface for <code class="fm-code-in-text">str</code> -&gt; <code class="fm-code-in-text">DepreciationStrategy</code> in an adapter called <code class="fm-code-in-text">StringDepreciationStrategyAdapter</code>.<a id="idIndexMarker094"/><a id="marker-71"/></p>
  </div>

  <p class="body">We will update the prompt in the <code class="fm-code-in-text">AssetFactory</code> class to use the new builders to construct the instances of <code class="fm-code-in-text">Asset</code> and <code class="fm-code-in-text">FundingDetails</code>:</p>
  <pre class="programlistinge"># Define a class called AssetFactory
# It should have the following methods:
#        +new(asset_type: str, asset_name: str, asset_cost: float, useful_life: int, depreciation_strategy: str, depreciation_rate: float, salvage_value: float) -&gt; Asset
# Create a function that will take a string and return a datetime
# Use the AssetBuilder to create the Asset and use the FundingDetailsBuilder to create the FundingDetails</pre>

  <p class="body">Using the new builders will drastically reduce this class’s code volume. For example, the <code class="fm-code-in-text">new</code> method is now only eight lines long (as formatted in Microsoft VS Code).</p>

  <p class="fm-code-listing-caption">Listing 4.15 The updated factory method for an <code class="fm-code-in-text">Asset</code></p>
  <pre class="programlisting">    def new(self, asset_type: str, 
   asset_name: str, asset_cost: float, 
   useful_life: int, depreciation_strategy: str, 
   depreciation_rate: float, salvage_value: float, 
   asset_purchase_date: str) -&gt; Asset:
        self.id += 1
        purchase_date = self.date_from_string(asset_purchase_date)
        a = AssetBuilder()
.with_id(self.id)
.with_name(asset_name)
.with_category(asset_type)
.with_cost(asset_cost)
.with_useful_life(useful_life)
.with_status("active")
.with_salvage_value(salvage_value)
.with_purchase_date(purchase_date)
.build()
        f = FundingDetailsBuilder()
.with_asset(a)
.with_depreciation_strategy(depreciation_strategy)
.with_depreciation_rate(depreciation_rate)
.build()
  
        a.funding_details = f
        return a</pre>

  <h3 class="fm-head1" id="heading_id_12">4.2.4 Observing changes</h3>

  <p class="body">Next we are going to apply the <i class="fm-italics">Observer</i> Pattern to our ITAM system. This pattern’s real value will become more obvious in the next chapter, but we will sow the seeds here. <a id="idIndexMarker095"/><a id="marker-72"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Observer Pattern</p>

    <p class="fm-sidebar-text">The Observer Pattern is a behavioral pattern in which the <code class="fm-code-in-text">Subject</code> class reports certain state changes to observer classes via notifications. The pattern is useful in user interfaces and event-driven systems. <a id="idIndexMarker096"/></p>
  </div>

  <p class="body">We will create a new class called <code class="fm-code-in-text">AssetManager</code> in the directory service. The <code class="fm-code-in-text">AssetManager</code> class will be responsible for interacting with the outside world (more on this in the next section). This prompt instructs Copilot about to how to define this class:<a id="idIndexMarker097"/></p>
  <pre class="programlistinge"># Define a class called AssetManager
# with CRUD operations for Asset</pre>

  <p class="body">Our current implementation of <code class="fm-code-in-text">AssetManager</code> uses a list to track the lifecycle of the <code class="fm-code-in-text">Asset</code>s it manages. <code class="fm-code-in-text">AssetManager</code> supports all the CRUD (create, read, update, and delete) operations of <code class="fm-code-in-text">Asset</code>s.</p>

  <p class="fm-code-listing-caption">Listing 4.16 Implementation of <code class="fm-code-in-text">AssetManager</code></p>
  <pre class="programlisting">from itam.domain.asset import Asset
  
class AssetManager:
    def __init__(self):
        self._assets = []
  
    def create(self, asset: Asset) -&gt; None:
        self._assets.append(asset)
  
    def read(self, asset_id: int) -&gt; Asset:
        for asset in self._assets:
            if asset.get_id() == asset_id:
                return asset
        raise ValueError("Asset not found")
  
    def update(self, asset: Asset) -&gt; None:
        for i in range(len(self._assets)):
            if self._assets[i].get_id() == asset.get_id():
                self._assets[i] = asset
                return
        raise ValueError("Asset not found")
 
    def delete(self, asset_id: int) -&gt; None:
        for i in range(len(self._assets)):
            if self._assets[i].get_id() == asset_id:
                del self._assets[i]
                return
        raise ValueError("Asset not found")
  
    def get_assets(self):
        return self._assets</pre>

  <p class="body">Let’s update our prompt to add notifications to our <code class="fm-code-in-text">AssetManager</code> class. Right now, we will not assign any observers; we will save that for chapter 5, when we start to deal with data flow:<a id="idIndexMarker098"/><a id="marker-73"/></p>
  <pre class="programlistinge"># Define a class called AssetManager
# with CRUD operations for Asset
# and a method to notify observers</pre>

  <p class="body">In response to our prompt, if we re-create the entire class, Copilot adds the notification framework on which we will eventually expand.</p>

  <p class="fm-code-listing-caption">Listing 4.17 Updated <code class="fm-code-in-text">AssetManager</code> definition with notifications enabled</p>
  <pre class="programlisting">from itam.domain.asset import Asset
  
class AssetManager:
    def __init__(self):
        self._assets = []
        self.observers = []
  
    def add_observer(self, observer):
        self.observers.append(observer)
  
    def remove_observer(self, observer):
        self.observers.remove(observer)
  
    def notify_observers(self, event, asset):
        for observer in self.observers:
            observer.update(event, asset)
  
    def read(self, asset_id: int) -&gt; Asset:
        for asset in self._assets:
            if asset.get_id() == asset_id:
                return asset
        raise ValueError("Asset not found")
  
    def create(self, asset: Asset) -&gt; None:
        self.notify_observers("CREATE", asset)
        self._assets.append(asset)
  
    def update(self, asset: Asset) -&gt; None:
        for i in range(len(self._assets)):
            if self._assets[i].get_id() == asset.get_id():
                self._assets[i] = asset
                self.notify_observers("UPDATE", asset)
                return
        raise ValueError("Asset not found")
  
    def delete(self, asset_id: int) -&gt; None:
        for i in range(len(self._assets)):
            if self._assets[i].get_id() == asset_id:
                del self._assets[i]
                self.notify_observers("DELETE", asset_id)
                return
        raise ValueError("Asset not found")
  
    def get_assets(self):
        return self._assets</pre>

  <p class="body">We will see two more patterns in the next section of this chapter: Singleton and Repository. But first we need to set up a controller to interact with our system. That takes us to the usage of ports and adapters.</p>

  <h2 class="fm-head" id="heading_id_13">4.3 Plugging in ports and adapters</h2>

  <p class="body">Our ITAM system is beginning to come together; the core business model has been built out. We have applied patterns to make the code more concise, readable, and maintainable. There is, however, one glaring deficiency: how do we interact with our application? In this section, we continue to deepen our investigation into hexagonal architecture.<a id="idIndexMarker099"/><a id="idIndexMarker100"/><a id="idIndexMarker101"/><a id="idIndexMarker102"/><a id="marker-74"/></p>

  <h3 class="fm-head1" id="heading_id_14">4.3.1 Hexagonal architecture in review</h3>

  <p class="body">As you may recall, hexagonal architecture is an approach to designing software that emphasizes the separation of the core business logic from external services. The business logic can be thought of as the “brain” of the application. It contains all the important rules and constructs that the application will need to guarantee the correctness of the program. In this analogy, the external services are your “hands” or “eyes;” they allow interactions with the outside world (user interfaces, database, etc.).<a id="idIndexMarker103"/></p>

  <p class="body">Hexagonal architecture separates the main program logic from the outside parts like buttons, screens, and databases. It makes it easy to change those outside parts without changing the main program. It does this by using <i class="fm-italics">ports</i> that define how the outside parts can interact with the main program and <i class="fm-italics">adapters</i> that make those interactions happen in a concrete way.<a id="idIndexMarker104"/><a id="idIndexMarker105"/></p>

  <p class="body">This approach makes it easier to change and evolve the application over time. If a change needs to be made to one of the external systems, the application’s core should be unaffected; you only need to update the adapter (see figure 4.8).</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH04_F08_Crocker2.png"/></p>

    <p class="figurecaption">Figure 4.8 A more conceptual visualization of the hexagonal architecture in action. Notice that the core is segregated from the rest of the system and is only interacted with via ports.</p>
  </div>

  <h3 class="fm-head1" id="heading_id_15">4.3.2 Driving our application</h3>

  <p class="body"><a id="marker-75"/>We will begin by building out a driver for the system. A <i class="fm-italics">driver</i> is a system external to the context boundary of the application that sends requests to the system and, optionally, receives responses from the application. A conventional example is a Representational State Transfer (commonly referred to as REST) call from a web browser to a REST controller. <a id="idIndexMarker106"/><a id="idIndexMarker107"/><a id="idIndexMarker108"/><a id="idIndexMarker109"/></p>

  <p class="body">First we will add a REST controller to our ITAM system. It will expose the functionality provided by the <code class="fm-code-in-text">AssetManager</code> class. Create a directory called infrastructure/API in which to create a file called asset_controller.py. At the beginning of this file, add the following prompt:<a id="idIndexMarker110"/></p>
  <pre class="programlistinge"># Import statements for Asset, AssetService, AssetFactory, AssetIn, AssetOut, and from_asset
# Use AssetFactory to create an Asset from an AssetIn
# Construct an instance of the APIRouter class from FastAPI
# Define HTTP endpoints to handle CRUD operations for the AssetService
# Implementation of error handling, logging, and other necessary components for a robust and reliable HTTP API
# All methods should be asynchronous</pre>

  <p class="body">Given that we do not specify the path to use, Copilot may produce inconsistent or invalid paths with the routes. The following code was output in VS Code in response to the previous prompt. The route is <code class="fm-code-in-text">asset</code> rather than <code class="fm-code-in-text">assets</code>; it’s more of a preference than a standard, but in REST the nouns are generally made plural.</p>

  <p class="fm-code-listing-caption">Listing 4.18 Generated code with route <code class="fm-code-in-text">asset</code></p>
  <pre class="programlisting">@router.post('/asset', response_model=AssetOut)
async def create_asset(asset_in: AssetIn):
    asset = AssetFactory.create_asset(asset_in)
    asset_service.create(asset)
    return from_asset(asset)</pre>

  <p class="body">You may elect to manually update the code to reflect your path preference. Above all, though, ensure that it is consistent across the various methods. The following listing shows how to initialize all the services needed to run the application.<a id="marker-76"/></p>

  <p class="fm-code-listing-caption">Listing 4.19 Updated <code class="fm-code-in-text">main</code> class to reflect consistent routes</p>
  <pre class="programlisting">from fastapi import APIRouter, HTTPException
from itam.domain.asset import Asset
from itam.service.asset_manager import AssetManager
from itam.domain.factory.asset_factory import AssetFactory
from itam.infrastructure.api.asset_model import AssetIn, AssetOut, from_asset
import logging
  
router = APIRouter()
  
asset_manager = AssetManager()
asset_factory = AssetFactory()<a id="idIndexMarker111"/></pre>

  <p class="body">Next, let’s see how the routes are defined and how their methods are used. The first two routes define how we access our <code class="fm-code-in-text">Asset</code> objects. The first GET request gets all <code class="fm-code-in-text">Asset</code>s that we currently have in the system. In the real world, we would include convenience features such as pagination and sorting. However, given the limited number of entries in the system currently, we will forgo this. The next GET method gets a specific <code class="fm-code-in-text">Asset</code> by its identifier.</p>

  <p class="fm-code-listing-caption">Listing 4.20 <code class="fm-code-in-text">AssetController</code> methods to access <code class="fm-code-in-text">Asset</code>s</p>
  <pre class="programlisting">@router.get('/assets', response_model=list[AssetOut])
async def get_assets():
    assets = asset_manager.get_assets()
    return [from_asset(asset) for asset in assets]
  
@router.get('/assets/{asset_id}', response_model=AssetOut)
async def read_asset(asset_id: int):
    try:
        asset = asset_manager.read(asset_id)
        return from_asset(asset)
    except ValueError as e:
        logging.error(e)
        raise HTTPException(status_code=404, detail="Asset not found")</pre>

  <p class="body">The final set of routes defines how we create <code class="fm-code-in-text">Asset</code>s, update them, and remove them from our system. Note that we are not doing “soft” deletes, which would just set a flag and not return this <code class="fm-code-in-text">Asset</code> in response to subsequent queries.<a id="marker-77"/></p>

  <p class="fm-code-listing-caption">Listing 4.21 <code class="fm-code-in-text">AssetController</code> methods to modify and delete <code class="fm-code-in-text">Asset</code>s</p>
  <pre class="programlisting">@router.post('/assets', response_model=AssetOut)
async def create_asset(asset_in: AssetIn):
    asset = asset_factory.new(asset_in.asset_type, 
    asset_in.name, asset_in.unit_cost, 
    asset_in.useful_life, asset_in.depreciation_strategy, 
    asset_in.depreciation_rate, asset_in.salvage_value,  
    asset_in.purchase_date)
    asset_manager.create(asset)
    return from_asset(asset)
    
@router.put('/assets/{asset_id}', response_model=AssetOut)
async def update_asset(asset_id: int, asset_in: AssetIn):
    try:
        asset = asset_factory.new(asset_in.asset_type, 
         asset_in.name, asset_in.unit_cost, 
         asset_in.useful_life, asset_in.depreciation_strategy, 
         asset_in.depreciation_rate, asset_in.salvage_value, 
         asset_in.purchase_date)
         asset.set_id(asset_id)
         asset_manager.update(asset)
         return from_asset(asset)
    except ValueError as e:
        logging.error(e)
        raise HTTPException(status_code=404, detail="Asset not found")
  
@router.delete('/assets/{asset_id}')
async def delete_asset(asset_id: int):
    try:
        asset_manager.delete(asset_id)
    except ValueError as e:
        logging.error(e)
        raise HTTPException(status_code=404, detail="Asset not found")</pre>

  <p class="body">Note the simplified representations of the <code class="fm-code-in-text">Asset</code> class called, not coincidently, <code class="fm-code-in-text">AssetIn</code> and <code class="fm-code-in-text">AssetOut</code>. You can define those classes in the <code class="fm-code-in-text">AssetController</code>, or you can add a separate class and define them there. In the reference implementation for this book, they are defined in a file called asset_model.py. This prompt defines the <code class="fm-code-in-text">AssetIn</code> and <code class="fm-code-in-text">AssetOut</code> classes:<a id="idIndexMarker112"/><a id="idIndexMarker113"/><a id="idIndexMarker114"/></p>
  <pre class="programlistinge"># Define a pydantic model for AssetIn
# It should have the following attributes:
#    name: str
#    asset_type: str
#    department: str
#    depreciation_strategy: str
#    useful_life: int
#    unit_cost: float
#    depreciation_rate: float
#    salvage_value: float
  
# Define a pydantic model for AssetOut
# It should have the following attributes:
#    id: int
#    name: str
#    asset_type: str
#    department: str
#    depreciation_strategy: str
#    useful_life: int
#    unit_cost: float
#    depreciation_rate: float
#    salvage_value: float
# It should have a method that transforms an Asset into an AssetOut</pre>

  <p class="body">With the prompt defined at the beginning of the file, Copilot generates code similar to the following listing.<a id="marker-78"/></p>

  <p class="fm-code-listing-caption">Listing 4.22 <code class="fm-code-in-text">AssetIn</code> and <code class="fm-code-in-text">AssetOut</code> classes in asset_model.py</p>
  <pre class="programlisting">from pydantic import BaseModel
from itam.domain.asset import Asset
  
class AssetIn(BaseModel):
    name: str
    asset_type: str
    department: str
    depreciation_strategy: str
    useful_life: int
    unit_cost: float
    depreciation_rate: float
    salvage_value: float
    purchase_date: str
  
class AssetOut(BaseModel):
    id: int
    name: str
    asset_type: str
    depreciation_strategy: str
    useful_life: int
    unit_cost: float
    depreciation_rate: float
    salvage_value: float
    purchase_date: str
  
@staticmethod
def from_asset(asset: Asset) -&gt; AssetOut:
    return AssetOut(
        id=asset.id,
        name=asset.name,
        asset_type=asset.category,
        depreciation_strategy=str(asset.funding_details.depreciation_strategy),
        useful_life=asset.useful_life,
        unit_cost=asset.cost,
        depreciation_rate=asset.funding_details.depreciation_rate,
        salvage_value=asset.salvage_value,
        purchase_date=asset.purchase_date.strftime("%Y-%m-%d"),
    )</pre>

  <p class="body">Optionally, we can add another layer of abstraction between <code class="fm-code-in-text">AssetController</code> and <code class="fm-code-in-text">AssetManager</code>. Doing so may be considered hexagonal architecture in extremis, but there are few challenges in computer science that cannot be resolved by adding one more layer of abstraction. We will add a port that will be used to interface with <code class="fm-code-in-text">AssetController</code>. Let’s create a prompt for the class <code class="fm-code-in-text">AssetRestPort</code> and have Copilot generate the code:<a id="idIndexMarker115"/><a id="idIndexMarker116"/><a id="idIndexMarker117"/><a id="idIndexMarker118"/><a id="marker-79"/></p>
  <pre class="programlistinge"># Define an interface called AssetRestPort
# It should expose all of the methods in AssetManager as abstract methods</pre>

  <p class="body">This prompt instructs Copilot to create an interface that we will implement shortly.</p>

  <p class="fm-code-listing-caption">Listing 4.23 Complete source code for <code class="fm-code-in-text">AssetRestPort</code></p>
  <pre class="programlisting">from itam.domain.asset import Asset
from abc import abstractmethod
  
class AssetRestPort:
    @abstractmethod
    def read(self, asset_id: int) -&gt; Asset:
        pass
  
    @abstractmethod
    def create(self, asset: Asset) -&gt; None:
        pass
  
    @abstractmethod
    def update(self, asset: Asset) -&gt; None:
        pass
   
    @abstractmethod
    def delete(self, asset_id: int) -&gt; None:
        pass
  
    @abstractmethod
    def get_assets(self):
        pass</pre>

  <p class="body">Next we will implement this port with an adapter that will be used to interact with the controller to further abstract the components. We can swap out this adapter for another if we want to, for example, turn this into a command-line application. The prompt for <code class="fm-code-in-text">AssetRestAdapter</code> is as follows:<a id="idIndexMarker119"/><a id="marker-80"/></p>
  <pre class="programlistinge"># Define an interface called AssetRestAdapter
# It should take an AssetManager as a parameter in its constructor
# It should expose all of the methods in AssetManager
# It should inherit from AssetRestPort</pre>

  <p class="body">There are two important elements to this prompt. The first is that it implements the port interface that we defined previously. The second is that it wraps <code class="fm-code-in-text">AssetManager</code>’s functionality.</p>

  <p class="fm-code-listing-caption">Listing 4.24 Source code for <code class="fm-code-in-text">AssetRestAdapter</code></p>
  <pre class="programlisting">from itam.domain.asset import Asset
from itam.infrastructure.ports.asset_rest_port import AssetRestPort
from itam.service.asset_manager import AssetManager
  
class AssetRestAdapter(AssetRestPort):
    def __init__(self, asset_manager: AssetManager):
        self._asset_manager = asset_manager
    
    def read(self, asset_id: int) -&gt; Asset:
        return self._asset_manager.read(asset_id)
  
    def create(self, asset: Asset) -&gt; None:
        self._asset_manager.create(asset)
    
    def update(self, asset: Asset) -&gt; None:
        self._asset_manager.update(asset)
  
    def delete(self, asset_id: int) -&gt; None:
        self._asset_manager.delete(asset_id)
    
    def get_assets(self):
        return self._asset_manager.get_assets()</pre>

  <p class="body">All that is left to do is to update <code class="fm-code-in-text">AssetController</code> to remove its direct invocation of the <code class="fm-code-in-text">AssetManager</code> methods and instead have <code class="fm-code-in-text">AssetController</code> invoke the methods of the adapter, which in turn invokes the methods of <code class="fm-code-in-text">AssetManager</code>. The key takeaway from the Ports and Adapters Pattern is that it abstracts the interaction between the driving parts of the system—in this case, the REST API—and the driven application: the business model and core of our system, <code class="fm-code-in-text">AssetManager</code>. To make this more explicit and as a preview, we will shortly modify this class again to add the port to the constructor. <a id="idIndexMarker120"/><a id="idIndexMarker121"/><a id="idIndexMarker122"/><a id="idIndexMarker123"/></p>

  <p class="fm-code-listing-caption">Listing 4.25 Updated code for <code class="fm-code-in-text">AssetController</code> using <code class="fm-code-in-text">AssetRestAdapter</code></p>
  <pre class="programlisting">router = APIRouter()
  
asset_rest_adapter = AssetRestAdapter(AssetManager())
asset_factory = AssetFactory()
  
@router.post('/assets', response_model=AssetOut)
async def create_asset(asset_in: AssetIn):
    asset = asset_factory.new(asset_in.asset_type,
    asset_in.name, asset_in.unit_cost, 
    asset_in.useful_life, asset_in.depreciation_strategy,
    asset_in.depreciation_rate, asset_in.salvage_value,
    asset_in.purchase_date)
    asset_rest_adapter.create(asset)
    return from_asset(asset)</pre>

  <p class="body">As previously mentioned, we will modify <code class="fm-code-in-text">AssetController</code> to remove all direct references to the <code class="fm-code-in-text">AssetManager</code>. Our current <code class="fm-code-in-text">AssetController</code>, although it does not directly invoke any <code class="fm-code-in-text">AssetManager</code> methods, does hold an indirect reference to <code class="fm-code-in-text">AssetManager</code>, because <code class="fm-code-in-text">AssetManager</code> is constructed in <code class="fm-code-in-text">AssetController</code>. Doing so further insulates <code class="fm-code-in-text">AssetManager</code> from changes in the drivers.</p>

  <h3 class="fm-head1" id="heading_id_16">4.3.3 Accessing our data and persisting our changes</h3>

  <p class="body"><a id="marker-81"/>Abstractions in software are not merely an academic matter. These abstractions give us flexibility when it comes to satisfying requirements and making changes. They can hide complexity, encapsulating behavior behind seemingly simple interfaces. This brings us to our next pattern: the <i class="fm-italics">Repository</i> Pattern.<a id="idIndexMarker124"/><a id="idIndexMarker125"/><a id="idIndexMarker126"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Repository Pattern</p>

    <p class="fm-sidebar-text">The Repository Pattern is a design pattern that helps manage data by creating a separate place to handle tasks like getting, saving, updating, and deleting data. It connects the data source (such as a database or file) to the rest of the application, keeping data access code separate from other code.<a id="idIndexMarker127"/></p>
  </div>

  <p class="body">In our ITAM project, the Repository Pattern will allow us to present a greatly simplified interface, masking the complexity of, in this case, our data access. From the perspective of the repository or <code class="fm-code-in-text">AssetManager</code>, our data access layer is just a series of methods. Behind the scenes, it may be a REST API, a Redis cache, MongoDB, a file, or a database of any flavor. Let’s create a prompt that will set up our generic data access layer using the Repository Pattern:</p>
  <pre class="programlistinge"># Create an abstract base class called BaseRepository that represents a generic data access layer using the Repository pattern. 
# The class should define common methods for CRUD operations such as create, read, update, and delete. 
# Make sure to use type hints for the input parameters and return values.</pre>

  <p class="body">With this prompt, Copilot should have everything it needs to establish the contract that all implementations will honor. Let’s examine the code.</p>

  <p class="fm-code-listing-caption">Listing 4.26 Code for <code class="fm-code-in-text">BaseRepository</code>, our generic data access layer</p>
  <pre class="programlisting">from abc import ABC, abstractmethod
from typing import List, TypeVar, Generic
  
T = TypeVar('T')
  
class BaseRepository(ABC, Generic[T]):
    @abstractmethod
    def create(self, entity: T) -&gt; None:
        pass
  
    @abstractmethod
    def read(self, entity_id: int) -&gt; T:
        pass
  
    @abstractmethod
    def update(self, entity: T) -&gt; None:
        pass
  
    @abstractmethod
    def delete(self, entity_id: int) -&gt; None:
        pass
  
    @abstractmethod
    def get_entities(self) -&gt; List[T]:
        pass</pre>

  <p class="body"><a id="marker-82"/>Copilot introduced a <code class="fm-code-in-text">Generic</code> type, allowing for some typing hints when it comes time to implement. If we express that the type should be an <code class="fm-code-in-text">Asset</code>, the method signature will demonstrate this. Our first attempt at an implementation will be an in-memory data store. This will allow us to perform an end-to-end test of our entire system. It also nicely demonstrates why abstractions are useful. Before long, we will add another implementation that uses Postgres. But first, the prompt:<a id="idIndexMarker128"/></p>
  <pre class="programlistinge"># Define a class called InMemoryAssetRepository that inherits from the BaseRepository abstract class. 
# The InMemoryAssetRepository should be specific to managing Asset objects using an in-memory list to store and update the assets. 
# Implement the necessary methods for CRUD operations such as create, read, update, and delete for Asset objects using the in-memory list. 
# Make sure to use type hints for the input parameters and return values.</pre>

  <p class="body">Our in-memory implementation will use a simple list to store <code class="fm-code-in-text">Asset</code>s. We will be able to perform all CRUD operations. Additionally, Copilot will add typing hints for us, letting others know that it should accept and return <code class="fm-code-in-text">Asset</code>s. That is what is meant by <code class="fm-code-in-text">BaseRepository</code>[<code class="fm-code-in-text">Asset</code>]: it’s an implementation of a <code class="fm-code-in-text">BaseRepository</code> whose <code class="fm-code-in-text">Generic</code> type is <code class="fm-code-in-text">Asset</code>. <a id="idIndexMarker129"/><a id="idIndexMarker130"/><a id="marker-83"/></p>

  <p class="fm-code-listing-caption">Listing 4.27 Code for <code class="fm-code-in-text">InMemoryAssetRepository</code></p>
  <pre class="programlisting">from itam.infrastructure.repository.base_repository import BaseRepository
from itam.domain.asset import Asset
  
class InMemoryAssetRepository(BaseRepository[Asset]):
    def __init__(self):
        self._assets = []
    
    def create(self, asset: Asset) -&gt; None:
        self._assets.append(asset)
    
    def read(self, asset_id: int) -&gt; Asset:
        return next((asset for asset in self._assets 
if asset.id == asset_id), None)
    
    def update(self, asset: Asset) -&gt; None:
        for i in range(len(self._assets)):
            if self._assets[i].id == asset.id:
                self._assets[i] = asset
                break
    
    def delete(self, asset_id: int) -&gt; None:
        self._assets = [asset for asset in self._assets 
if asset.id != asset_id]
    
    def get_entities(self) -&gt; list[Asset]:
        return self._assets</pre>

  <p class="body">Finally, we will update <code class="fm-code-in-text">AssetManager</code> to delegate the CRUD operations of the <code class="fm-code-in-text">Asset</code>s to a <code class="fm-code-in-text">BaseRepository</code> instance (<code class="fm-code-in-text">_repository</code>). The full source code follows, including the prompt at the beginning of the file. <a id="idIndexMarker131"/></p>

  <p class="fm-code-listing-caption">Listing 4.28 <code class="fm-code-in-text">AssetManager</code> using <code class="fm-code-in-text">InMemoryAssetRepository</code></p>
  <pre class="programlisting"># Define a class called AssetManager
# with CRUD operations for Asset
# and a method to notify observers whenever an asset is created, updated or deleted
# The AssetManager should use an instance of the InMemoryAssetRepository class for data access and CRUD operations on Asset objects. 
# Implement methods for creating, reading, updating, and deleting assets using the AssetRepository instance. 
# Please include type hints for the input parameters and return values.
# The methods should be named create, read, update, get_assets, and delete.
  
from itam.domain.asset import Asset
from itam.infrastructure.repository.in_memory_asset_repository import InMemoryAssetRepository
  
class AssetManager:
    def __init__(self):
        self._repository = InMemoryAssetRepository()
    
    def create(self, asset: Asset) -&gt; Asset:
        self._repository.create(asset)
        return asset
    
    def read(self, asset_id: int) -&gt; Asset:
        return self._repository.read(asset_id)
    
    def update(self, asset: Asset) -&gt; Asset:
        self._repository.update(asset)
        return asset
    
    def get_assets(self) -&gt; list[Asset]:
        return self._repository.get_entities()
    
    def delete(self, asset_id: int) -&gt; None:
        self._repository.delete(asset_id)</pre>

  <p class="body">At this point, we have a core business domain that is untouched directly by our system. We have ports by which requests can come in. We also have ports by which we can store the data (at least while the system is running). We should be able to test the system end to end by running it, POSTing requests to the creation end point, and reading from the GET end points. Once we have confirmed that the system works end to end, we can tackle the problem that our data is only persisted in memory; we can now hook up an actual database. To do this, we introduce the final pattern of this chapter: the <i class="fm-italics">Singleton</i> Pattern. A singleton, conceptually, is very simple to grok; there should only ever be one instance of it running. It is good for many use cases: logging, caching, configuration settings, or a database connection manager.<a id="idIndexMarker132"/><a id="marker-84"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Singleton Pattern</p>

    <p class="fm-sidebar-text">The Singleton Pattern is a design pattern that ensures a class has only one instance and provides a global access point to that instance. It is used when you want to have a single object shared across different parts of your program instead of creating multiple instances of the same class.</p>
  </div>

  <h3 class="fm-head1" id="heading_id_17">4.3.4 Centralizing (and externalizing) our data access</h3>

  <p class="body">We will ask Copilot to create a singleton class for us to manage our database’s connections. We should never hardcode usernames or passwords (or any connection details, for that matter) in our source code, not only because it is inherently less secure but also because the details will likely differ depending on the environment (DEV versus QA versus PROD). We will therefore ask Copilot to accept these values as environmental variables and configure the connections using them:<a id="idIndexMarker133"/><a id="idIndexMarker134"/><a id="idIndexMarker135"/></p>
  <pre class="programlistinge"># Create a Python class called DatabaseConnection using the Singleton pattern to manage a single connection to a PostgreSQL database using SQLAlchemy. 
# The class should read the database username, password, and connection string from environment variables
# The environment variables should be named: DB_USERNAME, DB_PASSWORD, DB_HOST, DB_PORT, and DB_NAME</pre>

  <p class="body">We are asking Copilot to employ SQLAlchemy, an object-relational mapping (ORM) tool, to perform the actions against the database. Copilot will adroitly assemble our source code. The <code class="fm-code-in-text">@staticmethod</code> keyword creates a method that belongs to a class rather than the instance of the class. This keyword is used to get the instance of the <code class="fm-code-in-text">DatabaseConnection</code> class. Because a static method cannot modify the instance data, it can be used to ensure that only one instance of this class is ever running and is thus a singleton. The constructor initializes the connection to the database using string interpolation with environment variables. <a id="idIndexMarker136"/><a id="idIndexMarker137"/><a id="idIndexMarker138"/><a id="marker-85"/></p>

  <p class="fm-code-listing-caption">Listing 4.29 Implementation of a <code class="fm-code-in-text">DatabaseConnection</code></p>
  <pre class="programlisting">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import os
 
class DatabaseConnection:
    __instance = None
    @staticmethod
    def get_instance():
        if DatabaseConnection.__instance == None:
            DatabaseConnection()
        return DatabaseConnection.__instance
  
    def __init__(self):
        if DatabaseConnection.__instance != None:
            raise Exception("This class is a singleton!")
        else:
            DatabaseConnection.__instance = self
            self.engine = 
create_engine(f"postgresql://
{os.environ['DB_USERNAME']}:
{os.environ['DB_PASSWORD']}@
{os.environ['DB_HOST']}:
{os.environ['DB_PORT']}/
{os.environ['DB_NAME']}")
            self.Session = sessionmaker(bind=self.engine)
    
    def get_session(self):
        return self.Session()</pre>

  <p class="body">Now that we can get a connection to our database, we need to create a repository that will use this connection to store and retrieve our <code class="fm-code-in-text">Asset</code> objects. We will create a class that does just that called <code class="fm-code-in-text">SQLAlchemyAssetRepository</code>.</p>

  <p class="fm-code-listing-caption">Listing 4.30 Prompt and code for the <code class="fm-code-in-text">SQLAlchemyAssetRepository</code> class</p>
  <pre class="programlisting"># Define a class called SQLAlchemyAssetRepository that implements the AssetRepository interface for data access using SQLAlchemy. 
# The class should handle the CRUD operations (create, read, update, and delete) for assets, storing and retrieving them in a PostgreSQL database using SQLAlchemy.
  
from itam.domain.asset import Asset
from itam.infrastructure.repository.base_repository import BaseRepository
from sqlalchemy.orm import Session
  
class SQLAlchemyAssetRepository(BaseRepository[Asset]):
    def __init__(self, session: Session):
        self._session = session
    
    def create(self, asset: Asset) -&gt; Asset:
        self._session.add(asset)
        self._session.commit()
        return asset
    
    def read(self, asset_id: int) -&gt; Asset:
        return self._session.query(Asset)
.filter(Asset.id == asset_id).first()
    
    def update(self, asset: Asset) -&gt; Asset:
        self._session.query(Asset)
.filter(Asset.id == asset.id).update(asset)
        self._session.commit()
        return asset
    
    def get_assets(self) -&gt; list[Asset]:
        return self._session.query(Asset).all()
    
    def delete(self, asset_id: int) -&gt; None:
        self._session.query(Asset).filter(Asset.id == asset_id).delete()
        self._session.commit()</pre>

  <p class="body">Next we will refactor <code class="fm-code-in-text">AssetController</code> to allow us to pass in <code class="fm-code-in-text">AssetRestPort</code>. By doing this, we can swap out the driven aspect of our application. This refactor further abstracts the driver from the business core. <a id="idIndexMarker139"/><a id="marker-86"/></p>

  <p class="fm-code-listing-caption">Listing 4.31 Updated <code class="fm-code-in-text">AssetController</code> that exposes routes</p>
  <pre class="programlisting">from itam.infrastructure.ports.asset_rest_port import AssetRestPort
import logging
  
class AssetController:
    def __init__(self, asset_rest_port:  AssetRestPort):
        self._asset_factory = AssetFactory()
        self._asset_rest_port = asset_rest_port
        ...
  
    def get_router(self):
        return self._router
  
    async def get_assets(self):
        return  [ from_asset(a) for a in self._asset_rest_port.get_assets()]
  
    async def get_asset(self, asset_id: int):
        asset = self._asset_rest_port.read(asset_id)
        if asset is None:
            raise HTTPException(status_code=404, detail="Asset not found")
        return from_asset(asset)
    
    async def create_asset(self, asset_in: AssetIn):
        asset = self._asset_factory.new(
asset_in.asset_type, 
asset_in.name, 
asset_in.unit_cost, 
asset_in.useful_life, 
asset_in.depreciation_strategy, 
asset_in.depreciation_rate, 
asset_in.salvage_value, 
asset_in.purchase_date)
        self._asset_rest_port.create(asset)
        return from_asset(asset)
  
    async def update_asset(self, asset_id: int, asset_in: AssetIn):
        asset = self._asset_factory.new(
asset_in.asset_type, 
asset_in.name, 
asset_in.unit_cost, 
asset_in.useful_life, 
asset_in.depreciation_strategy, 
asset_in.depreciation_rate, 
asset_in.salvage_value, 
asset_in.purchase_date)
    
        asset.id = asset_id
        asset = self._asset_rest_port.update(asset)
        if asset is None:
            raise HTTPException(status_code=404, detail="Asset not found")
        return from_asset(asset)
  
    async def delete_asset(self, asset_id: int):
        asset = self._asset_rest_port.read(asset_id)
        if asset is None:
            raise HTTPException(status_code=404, detail="Asset not found")
        self._asset_rest_port.delete(asset_id)
        return from_asset(asset)<a id="marker-87"/></pre>

  <p class="body">We can now consolidate the initialization logic of our application into the main.py file. This is the big payoff. Our system will have layering, facilitating the swapping out of components as needed or when requirements change.</p>

  <p class="fm-code-listing-caption">Listing 4.32 Final version of main.py, wiring our application together</p>
  <pre class="programlisting">from fastapi import FastAPI
from itam.infrastructure.api.asset_controller import AssetController
#from itam.infrastructure.repository.in_memory_asset_repository     
     import InMemoryAssetRepository
from itam.infrastructure.repository.sqlalchemy_asset_repository   
     import SQLAlchemyAssetRepository
from itam.infrastructure.database.database_connection 
     import DatabaseConnection
from itam.service.asset_manager import AssetManager
from itam.infrastructure.adapters.asset_rest_adapter import AssetRestAdapter
import uvicorn
  
app = FastAPI()
session = DatabaseConnection().get_session()
#repository = InMemoryAssetRepository()
repository = SQLAlchemyAssetRepository(session)
asset_manager = AssetManager(repository)
asset_rest_adapter = AssetRestAdapter(asset_manager)
asset_controller = AssetController(asset_rest_adapter)
app.include_router(asset_controller.get_router())
  
if __name__ == '__main__':
    uvicorn.run(app, host='0.0.0.0', port=8000)</pre>

  <p class="body">Congratulations! We now have a running system that persists data to our database.<a id="marker-88"/></p>

  <h2 class="fm-head" id="heading_id_18">Summary</h2>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">The Decorator Pattern is a structural design pattern that allows you to add new object behavior or modify existing behavior dynamically without changing the existing class. This is done by wrapping the current object in the decorating object.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Visitor Pattern adds new behavior to changes the existing behavior of a given class.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Factory Pattern is another creation pattern that allows you to abstract away some of the details of the object you are attempting to create.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Builder Pattern is a creational design pattern that provides a fluent API for the creation of objects by providing step-by-step instructions for creating those objects.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Adapter Pattern is a structural design pattern that allows you to bridge the gap between the target interface and a class with an incompatible interface.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Observer Pattern is a behavioral pattern in which the subject class reports certain state changes to observer classes via notifications.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Hexagonal architecture separates the main program logic from outer parts like buttons, screens, and databases. It makes changing outer parts easy without changing the main program.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Repository Pattern is a design pattern that helps manage data by creating a separate place to handle tasks like getting, saving, updating, and deleting data. It connects the data source (such as a database or file) to the rest of the application, keeping data access code separate from other code.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The Singleton Pattern is a design pattern that ensures a class has only one instance and provides a global access point to that instance. It is used when you want a single object to be shared across different parts of your program instead of creating multiple instances of the same class<a id="marker-90"/>.</p>
    </li>
  </ul>
</body></html>