- en: Appendix A. Deep Dives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we dive deep into a few technical areas that are important
    to understand for completion, but are not essential.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Chain Rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First up is an explanation of why we can substitute *W*^T for <math><mrow><mfrac><mrow><mi>∂</mi><mi>ν</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <mo>)</mo></mrow></mrow></math>
    in the chain rule expression from [Chapter 1](ch01.html#foundations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that *L* is literally:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mi>σ</mi> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>σ</mi> <mrow><mo>(</mo> <mi>X</mi>
    <msub><mi>W</mi> <mn>12</mn></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <mi>X</mi> <msub><mi>W</mi> <mn>21</mn></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>σ</mi>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>22</mn></msub> <mo>)</mo></mrow>
    <mo>+</mo> <mi>σ</mi> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>31</mn></msub>
    <mo>)</mo></mrow> <mo>+</mo> <mi>σ</mi> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>32</mn></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'where this is shorthand for the fact that:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mi>σ</mi> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mn>11</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub> <mo>+</mo> <msub><mi>x</mi>
    <mn>12</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub> <mo>+</mo> <msub><mi>x</mi>
    <mn>13</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub> <mo>)</mo></mrow></mrow></math><math
    display="block"><mrow><mi>σ</mi> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>12</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mn>11</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>12</mn></msub> <mo>+</mo> <msub><mi>x</mi>
    <mn>12</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>22</mn></msub> <mo>+</mo> <msub><mi>x</mi>
    <mn>13</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>32</mn></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: and so on. Let’s zoom in on just one of these expressions. What would it look
    like if we took the partial derivative of, say, <math><mrow><mi>σ</mi> <mo>(</mo>
    <mi>X</mi> <msub><mi>W</mi> <mn>11</mn></msub> <mo>)</mo></mrow></math> with respect
    to every element of <math><mi>X</mi></math> (which is ultimately what we’ll want
    to do with all six components of <math><mi>L</mi></math> )?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, since:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mi>σ</mi> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mn>11</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub> <mo>+</mo> <msub><mi>x</mi>
    <mn>12</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub> <mo>+</mo> <msub><mi>x</mi>
    <mn>13</mn></msub> <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'it isn’t too hard to see that the partial derivative of this with respect to
    <math><msub><mi>x</mi> <mn>1</mn></msub></math> , via a very simple application
    of the chain rule, is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>11</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Since the only thing that *x*[11] is multiplied by in the *XW*[11] expression
    is *w*[11], the partial derivative with respect to everything else is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, computing the partial derivative of *σ*(*XW*[11]) with respect to all of
    the elements of *X* gives us the following overall expression for <math><mfrac><mrow><mi>∂</mi><mi>σ</mi><mo>(</mo><mi>X</mi><msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac></math>
    :'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi><mo>(</mo><mi>X</mi><msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub></mrow></mtd>
    <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>11</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can, for example, work out the partial derivative of *σ*(*XW*[32])
    with respect to each element of *X*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>32</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>12</mn></msub></mrow></mtd>
    <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>32</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>22</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>32</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>32</mn></msub></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the components to actually compute <math><mrow><mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow>
    <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>S</mi> <mo>)</mo></mrow></mrow></math>
    directly. We can simply compute six matrices of the same form as the preceding
    matrices and add the results together.
  prefs: []
  type: TYPE_NORMAL
- en: Note that once again the math gets messy, though not advanced. You can skip
    the following calculations and move straight to the conclusion, which is ultimately
    a simple expression. But working through the calculations will give you a greater
    appreciation for how surprisingly simple the conclusion is. And what else is life
    for but appreciating things?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are just two steps here. First, we’ll actually write out explicitly that
    <math><mrow><mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>S</mi> <mo>)</mo></mrow></mrow></math> is a sum of the six
    matrices just described:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>S</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi><mo>(</mo><mi>X</mi><msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi><mo>(</mo><mi>X</mi><msub><mi>W</mi>
    <mn>12</mn></msub> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi><mo>(</mo><mi>X</mi><msub><mi>W</mi>
    <mn>21</mn></msub> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi><mo>(</mo><mi>X</mi><msub><mi>W</mi>
    <mn>22</mn></msub> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi><mo>(</mo><mi>X</mi><msub><mi>W</mi>
    <mn>31</mn></msub> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi><mo>(</mo><mi>X</mi><msub><mi>W</mi>
    <mn>32</mn></msub> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub></mrow></mtd>
    <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>11</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced> <mo>+</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>12</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>12</mn></msub></mrow></mtd>
    <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>12</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>22</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>12</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>32</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced> <mo>+</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>21</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub></mrow></mtd>
    <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>21</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>21</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>22</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>12</mn></msub></mrow></mtd>
    <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>22</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>22</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>22</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>32</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>31</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>31</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub></mrow></mtd>
    <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>31</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub></mrow></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>32</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>12</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>32</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>22</mn></msub></mrow></mtd>
    <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>32</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>32</mn></msub></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s combine this sum into one big matrix. This matrix won’t immediately
    have any intuitive form, but it is in fact the result of computing the preceding
    sum:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>S</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>12</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>12</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>12</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>22</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>12</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>32</mn></msub></mrow></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>21</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>22</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>12</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>21</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>22</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>22</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>21</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>22</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>32</mn></msub></mrow></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>31</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>11</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>32</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>12</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>31</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>21</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>32</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>22</mn></msub></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>31</mn></msub> <mo>)</mo></mrow> <mo>×</mo> <msub><mi>w</mi> <mn>31</mn></msub>
    <mo>+</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi> <mn>32</mn></msub> <mo>)</mo></mrow>
    <mo>×</mo> <msub><mi>w</mi> <mn>32</mn></msub></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the cool part. Recall that:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mi>W</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><msub><mi>w</mi>
    <mn>11</mn></msub></mtd> <mtd><msub><mi>w</mi> <mn>12</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>w</mi> <mn>21</mn></msub></mtd> <mtd><msub><mi>w</mi> <mn>22</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>w</mi> <mn>31</mn></msub></mtd> <mtd><msub><mi>w</mi> <mn>32</mn></msub></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, *W* is hidden in the preceding matrix—it is just transposed. Recalling
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>S</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>12</mn></msub> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>21</mn></msub> <mo>)</mo></mrow></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>22</mn></msub> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>31</mn></msub> <mo>)</mo></mrow></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>32</mn></msub> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'it turns out that the previous matrix is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>11</mn></msub> <mo>)</mo></mrow></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>12</mn></msub> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>21</mn></msub> <mo>)</mo></mrow></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>22</mn></msub> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>31</mn></msub> <mo>)</mo></mrow></mrow></mtd> <mtd><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <msub><mi>W</mi>
    <mn>32</mn></msub> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></mfenced> <mo>×</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><msub><mi>w</mi> <mn>11</mn></msub></mtd>
    <mtd><msub><mi>w</mi> <mn>21</mn></msub></mtd> <mtd><msub><mi>w</mi> <mn>31</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>w</mi> <mn>12</mn></msub></mtd> <mtd><msub><mi>w</mi> <mn>22</mn></msub></mtd>
    <mtd><msub><mi>w</mi> <mn>32</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>S</mi> <mo>)</mo></mrow> <mo>×</mo> <msup><mi>W</mi> <mi>T</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'And further, remember that we were looking for something to fill in the question
    mark in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>∂</mi><mi>Λ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>S</mi> <mo>)</mo></mrow>
    <mo>×</mo> <mo>?</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Well, it turns out that thing is *W*. This result falls out like meat falling
    off the bone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that this is the same result we saw earlier in one dimension; again,
    this will turn out to be a result that both explains why deep learning works and
    allows us to implement it cleanly. Does this mean that we can *actually* replace
    the question mark in the preceding equation and say that <math><mrow><mfrac><mrow><mi>∂</mi><mi>ν</mi></mrow>
    <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>X</mi> <mo>,</mo>
    <mi>W</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>W</mi> <mi>T</mi></msup></mrow></math>
    ? No, not exactly. But if we multiply together two inputs (*X* and *W*) to get
    a result *N* and feed these inputs through some nonlinear function *σ* to end
    up with an output *S*, then we *can* say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>X</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <mo>,</mo> <mi>W</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>N</mi> <mo>)</mo></mrow> <mo>×</mo> <msup><mi>W</mi> <mi>T</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This mathematical fact is what allows us to compute and express gradient updates
    efficiently using the notation of matrix multiplication. Furthermore, we could
    reason similarly to discover that:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow> <mrow><mi>∂</mi><mi>W</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>X</mi> <mo>,</mo> <mi>W</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>X</mi> <mi>T</mi></msup> <mo>×</mo> <mfrac><mrow><mi>∂</mi><mi>σ</mi></mrow>
    <mrow><mi>∂</mi><mi>u</mi></mrow></mfrac> <mrow><mo>(</mo> <mi>N</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Gradient of the Loss with Respect to the Bias Terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we’ll go into detail on why, when computing the derivative of the loss
    with respect to the bias terms in a fully connected neural network, we sum along
    `axis=0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The addition of a bias term in a neural network occurs in the following context:
    we have a batch of data represented by a matrix of dimension *n* rows (the batch
    size) by *f* columns (the number of features), and we add a single number to each
    of the *f* features. For example, in the neural network example from [Chapter 2](ch02.html#fundamentals),
    we have 13 features, and the bias term *B* has 13 numbers; the first number will
    be added to every row in the first column of `M1 = np.dot(X, weights[*W1*])`,
    the second number will be added to every row in the second column, and so on.
    Further on in the network, <math><mrow><mi>B</mi> <mn>2</mn></mrow></math> will
    contain one number, which will simply be added to every row in the single column
    of `M2`. Thus, since the same numbers will be added to each *row* of the matrix,
    on the backward pass we need to sum the gradients along the dimension representing
    the rows that each bias element was added to. This is why we sum the expressions
    for `dLdB1` and `dLdB2` along `axis=0`; for example, `dLdB1 = (dLdN1 × dN1dB1).sum(axis=0)`.
    [Figure A-1](#fig_08_01) provides a visual explanation of all this, with some
    commentary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neural net diagram](assets/dlfs_aa01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-1\. A summary of why computing the derivative of the output of the
    fully connected layer with respect to the bias involves summing along axis = 0
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Convolutions via Matrix Multiplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we’ll show how to express the batch, multichannel convolution operation
    in terms of a batch matrix multiplication to implement it efficiently in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the convolution works, consider what happens in the forward
    pass of a fully connected neural network:'
  prefs: []
  type: TYPE_NORMAL
- en: We receive an input of size `[batch_size, in_features]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We multiply it by a parameter of size `[in_features, out_features]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get a resulting output of size `[batch_size, out_features]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a convolutional layer, by contrast:'
  prefs: []
  type: TYPE_NORMAL
- en: We receive an input of size `[batch_size, in_channels, img_height, img_width]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We convolve it with a parameter of size `[in_channels, out_channels, param_height,
    param_width]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get a resulting output of size `[batch_size, in_channels, img_height, img_width]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key to making the convolution operation look more like a regular feed-forward
    operation is to *first extract `img_height × img_width` “image patches” from each
    channel of the input image*. Once these patches are extracted, the input can be
    reshaped so that the convolution operation can be expressed as a batch matrix
    multiplication using NumPy’s `np.matmul` function. First:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can compute the output of the convolution operation in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: Get image patches of size `[batch_size, in_channels, img_height x img_width,
    filter_size, filter_size]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reshape this to be `[batch_size, img_height × img_width, in_channels × filter_size×
    filter_size]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reshape parameter to be `[in_channels × filter_size × filter_size, out_channels]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we do a batch matrix multiplication, the result will be `[batch_size,
    img_height × img_width, out_channels]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reshape this to be `[batch_size, out_channels, img_height, img_width]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s the forward pass! For the backward pass, we have to calculate both the
    parameter gradient and the input gradients. Again, we can use the way this is
    done in a fully connected neural network as a guide. Starting with the parameter
    gradient, the gradient of a fully connected neural network is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This should motivate how we implement the backward pass through the convolution
    operation: here, the input shape is `[batch_size, in_channels, img_height, img_width]`,
    and the output *gradient* received will be `[batch_size, out_channels, img_height,
    img_width]`. Considering that the shape of the parameter is `[in_channels, out_channels,
    param_height, param_width]`, we can effect this transformation with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll have to extract image patches from the input image, resulting in
    the same output from last time, of shape `[batch_size, in_channels, img_height
    x img_width, filter_size, filter_size]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, using the multiplication from the fully connected case as a motivation,
    reshape it to be of shape `[in_channels × param_height × param_width, batch_size
    × img_height × img_width]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, reshape the output—originally of shape `[batch_size, out_channels, img_height,
    img_width]`—to be of shape `[batch_size × img_height × img_width, out_channels]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply these together to get an output of shape `[in_channels × param_height
    × param_width, out_channels]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reshape this to get the final parameter gradient, of shape `[in_channels, out_channels,
    param_height, param_width]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we follow a very similar set of steps to get the input gradient,
    motivated by mimicking the operation in the fully connected layer, which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code computes the input gradient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These three functions form the core of the `Conv2DOperation`, specifically its
    `_output`, `_param_grad`, and `_input_grad` methods, which you can see in the
    [`lincoln` library](https://oreil.ly/2KPdFay) within the book’s GitHub repo.
  prefs: []
  type: TYPE_NORMAL
