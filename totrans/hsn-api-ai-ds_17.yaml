- en: Chapter 14\. Using APIs with LangChain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A system is more “agentic” the more an LLM decides how the system can behave.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Harrison Chase, LangChain creator
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: AI applications use LLMs as a natural language interface with users, and researchers
    are exploring ways to use the LLMs to perform multistep tasks. This chapter examines
    two important ways that APIs and LLMs are used together to create AI applications.
    First, you will look at calling LLMs using APIs, and then you will reverse the
    roles and call APIs with LLMs. You will use LangChain for both of these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: LangChain and its related project, LangGraph, are open source frameworks for
    creating *agentic* applications—applications that use LLMs to control the system
    behavior. Although many developers build these applications by calling the LLM
    APIs directly and performing custom coding to interact with them, LangChain and
    LangGraph standardize many of the tasks required. You can think of them as frameworks
    that sit on top of the APIs or models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few new terms:'
  prefs: []
  type: TYPE_NORMAL
- en: Agent
  prefs: []
  type: TYPE_NORMAL
- en: Harrison Chase defines an agent as “a system that uses an LLM to decide the
    control flow of an application.” Agents are not preprogrammed, like traditional
    software—they use a model to reason and decide the flow of a conversation. They
    can execute tool calls that are suggested by function-calling models.
  prefs: []
  type: TYPE_NORMAL
- en: Function-calling model
  prefs: []
  type: TYPE_NORMAL
- en: This is a specialized type of model that considers available *functions* or
    *tools* and suggests when they should be used. Despite the name, the models don’t
    call the tool directly; they give that suggestion to *agents*, who do the calling.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs: []
  type: TYPE_NORMAL
- en: These are the AI models that LangChain users call. LangChain can use models
    that are downloaded locally or called via web APIs provided by model providers.
  prefs: []
  type: TYPE_NORMAL
- en: Model families
  prefs: []
  type: TYPE_NORMAL
- en: These are multiple models that share a name and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Toolkit
  prefs: []
  type: TYPE_NORMAL
- en: This is a collection of multiple tools that an agent will use to perform tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Tools or functions
  prefs: []
  type: TYPE_NORMAL
- en: This is code that provides extra skills to an agent. A simple Python function
    might perform mathematical operations. You will create a tool that calls the SWC
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The software introduced in this chapter will focus on using the LangChain ecosystem
    with APIs. [Table 14-1](#tools_table_chapter_14) displays the new tools you will
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-1\. Tools used in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: '| Software name | Version | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LangChain | 0.3 | Python library used to create tools and toolkits that allow
    agents to use your API |'
  prefs: []
  type: TYPE_TB
- en: '| LangGraph | 0.2 | Python library used to create an agent |'
  prefs: []
  type: TYPE_TB
- en: '| Anthropic Claude | 3.5 Sonnet | Model used to provide reasoning to the LangGraph
    agent |'
  prefs: []
  type: TYPE_TB
- en: '| Pydantic | 2 | Python library used to perform validation in your toolkit
    |'
  prefs: []
  type: TYPE_TB
- en: '| swcpy | NA | SDK created in [Chapter 7](ch07.html#chapter_7) for your API
    |'
  prefs: []
  type: TYPE_TB
- en: Calling AI Using APIs (via LangChain)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Figure 14-1](#langgraph_architecture_ch14) shows the high-level architecture
    of the project you will create in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand the capabilities that LangChain is harnessing, it is helpful to
    look at the APIs that LangChain interacts with. The [LangChain “Chat Models” page](https://oreil.ly/2elFn)
    lists more than 60 providers of chat models. The list also displays which models
    are function-calling, which will be important in this chapter because they are
    capable of using tools to call APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '![High-level architecture](assets/haad_1401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1\. High-level architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you look at the documentation for these model providers, they typically
    provide documentation for their APIs and allow you to register for an API key
    (for a fee). These companies follow many of the best practices from [Chapter 6](ch06.html#chapter_6):
    interactive API documentation, SDKs in Python and other languages, methods of
    contacting support, and many other features. For these providers, APIs are not
    a side business—they *are* the business.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'While it’s tempting to focus only on the potential of LLMs, the model providers
    also publish some sobering warnings. The providers often provide a *model card*
    or *system card* that describes the intended use and limitations of their models.
    At the time of this writing, these cards of major LLMs list risks such as bias,
    hallucinations, mistakes, and harmful content. For example, Anthropic states in
    their article, [“The Claude 3 Model Family: Opus, Sonnet, Haiku”: “The models
    should not be used on their own in high-stakes situations”](https://oreil.ly/vq7FK).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be using a read-only fantasy football API, which is
    low risk.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a LangGraph Agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Letting an LLM decide the control flow of an application (i.e. what we call
    agents) is attractive, as they can unlock a variety of tasks that couldn’t previously
    be automated. In practice, however, it is incredibly difficult to build systems
    that reliably execute on these tasks.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LangChain blog post, [“Announcing LangGraph v0.1 & LangGraph Cloud: Running
    agents at scale, reliably”](https://oreil.ly/KoxAw), June 2024'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: LangGraph is a LangChain-related project focused on creating applications that
    have one or more agents working together. LangChain has methods for using agents,
    which have recently been labeled as *legacy methods*, at the time of this writing.
    LangGraph is intended to be an improvement on these methods by allowing more developer
    control and supporting multiagent applications.
  prefs: []
  type: TYPE_NORMAL
- en: LangGraph uses some terminology from mathematical graph theory (see [“Orchestrating
    the Data Pipeline with Apache Airflow”](ch10.html#data_pipeline_apache_airflow)).
    The logical flow of LangGraph agents is represented by *nodes*, which are processes
    that update the *state* of the application. The nodes are connected by *edges*,
    which are one-way flows between one node and another. Where Airflow had *acyclic*
    graphs that begin at a start node and go in one direction to an end node, LangGraph
    allows *cyclical* graphs, where nodes and edges can loop multiple times. For example,
    a loop may allow a user to ask multiple questions to a model before getting the
    final answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-2](#directed_cyclic_graph_ch14) shows how nodes and edges relate
    to each other in a *directed cyclic graph* that contains loops.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Directed cyclic graph](assets/haad_1402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-2\. Directed cyclic graph
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will be creating an agent in this chapter that can be represented by a directed
    cyclic graph.
  prefs: []
  type: TYPE_NORMAL
- en: Signing Up for Anthropic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will be using a model from Anthropic, so you need to sign up for an Anthropic
    account at the [“Build with Claude” web page](https://console.anthropic.com/login).
  prefs: []
  type: TYPE_NORMAL
- en: To use the Anthropic API, you will need to upgrade your initial account to a
    Build Plan and add funds to your account. To limit potential overspending, I suggest
    initially adding $5 and disabling auto-reload. This means the maximum amount you
    can spend is $5, even if your API key is misused.
  prefs: []
  type: TYPE_NORMAL
- en: Next, navigate to the [Anthropic API keys page](https://oreil.ly/fcaYA) and
    select Create Key. Give the key a name such as **`secret-api-key`** and select
    the Default workspace. Your display should look like [Figure 14-3](#anthropic_api_key_ch14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Anthropic API key](assets/haad_1403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-3\. Creating an Anthropic API key
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click Add. You will be prompted to “Save Your API key.” This is the only time
    the key will be displayed. Store this key in a secure location.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you lose your Anthropic API key or think it may have been exposed, delete
    it from the keys page and create a new one. This is called *rotating* a credential,
    and it is a convenient way to lower the risk of your API key being abused.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Your GitHub Codespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you launch the GitHub Codespace for this chapter, you want to add the
    Anthropic API key as a secret in your Codespace. This will allow you to use the
    Anthropic models with LangGraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the instructions for [“Adding a secret”](https://oreil.ly/VGSJ3) and
    create a new secret with the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Name*: `ANTHROPIC_API_KEY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Value*: Use the value of the Anthropic API key you created in the previous
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Repository access:* Select the `ai-project` repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When completed, you should see the key saved as shown in [Figure 14-4](#codespaces_secret_ch14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Codespaces secrets](assets/haad_1404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-4\. Codespaces secrets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Installing the New Libraries in Your Codespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now launch your Codespace. You will be working with the Part III GitHub Codespace
    that you created in [“Cloning the Part III Repository”](ch12.html#cloning_part_3_sect).
    If you haven’t created your Part III Codespace yet, you can complete that section
    now. To install the libraries you need for this chapter, create a file named *chapter14/requirements.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Update *chapter14/requirements.txt* with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This installs the base LangChain library and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This library is used for the specific model you use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_with_langchain_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the LangGraph library used to define your agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to install the new libraries in your Codespace,
    and make sure to upgrade to the latest version available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should see a message that states that these libraries were successfully
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Jupyter Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be using a Jupyter Notebook to implement a conversational chat agent,
    based on an example from the [LangChain GitHub repository](https://oreil.ly/U-TJF).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, run the following commands in the Terminal window to create
    the new directory and the Jupyter Notebook you will be using in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Click the *langgraph_notebook.ipynb* file to open it. In the top-right of the
    file, click Select Kernel. Codespaces should prompt you to “Install/Enable suggested
    extensions Python + Jupyter”—select this. Click Install in the additional pop-up
    window, if prompted. This will install some extensions to VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: After the installation completes, the title of the window will change to Select
    Another Kernel. Select Python Environments. The title of the window will change
    to Select a Python Environment. One Python version should be listed with a star
    next to it—select this Python version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click “+ Markdown” to create a new Markdown cell. Enter the following title
    in the Markdown cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run this cell by clicking the play icon on the left of the cell or by pressing
    Shift-Enter. You should see your message formatted as a title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another Markdown cell and run it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Hover your cursor below this cell and click “+ Code” to create a new Python
    cell. Enter the following code in the Python cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This import defines the messages you’ll use to communicate with the agent.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the library for using the Anthropic model.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_with_langchain_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The following libraries enable different parts of the LangGraph framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_apis_with_langchain_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This will be used for the formatting of the messages returned by the agent.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_using_apis_with_langchain_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This will be used to display a visual view of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Placing all the imports at the top of your notebook helps keep track of the
    libraries you are using. These imports will work for all the cells in this Jupyter
    Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another Markdown cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement removes any existing logging handlers configured by Codespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This sets the logging level to record in the log. Review [Table 7-1](ch07.html#python_logging_levels_ch7)
    for more details about Python logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another Markdown cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This initializes the Anthropic model. The `temperature` sets how creative the
    responses are. Lower is less creative and more predictable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This function is used to send messages to the model using the `state` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_with_langchain_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `workflow` is used to define the tasks available to the agent.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_apis_with_langchain_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `agent` node will use the `call_model` function defined above.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_using_apis_with_langchain_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This defines the start of the graph, which will directly call the `agent` node.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_using_apis_with_langchain_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement compiles the graph into a LangChain `Runnable` object named `app`.
    (For more information, see the [documentation for the Runnable interface](https://oreil.ly/UJJzq).)
    The `app` object will act as the agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewing a visual representation of the graph will help you see the nodes and
    edges that were created in this code, and the flow of the agent you created. Add
    another Markdown cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Displaying an image of the graph demonstrates the flow of your agent. You should
    see an image that matches [Figure 14-5](#graph_visual_1_ch14). This shows that
    the graph will start and a message will be sent to the agent without referencing
    any other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph of the basic agent](assets/haad_1405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-5\. Graph of the basic agent
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Chatting with the LangGraph Agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are ready to have a conversation with the agent you have created. You will
    accomplish this by using the `app.invoke()` method along with a `messages` object.
    The call to the `invoke()` method also includes a `config` object with a `thread_id`
    value. The `thread_id` allows the agent to remember previous messages in the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another Markdown cell with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is how you will chat with your agent. The `app.invoke` command sends the
    `messages` object and adds a question as a `HumanMessage`. The `config` object
    passes a `thread_id` so that the agent knows you are in the same conversation.
    While you are using this `thread_id`, the agent will remember the previous messages
    in the same conversation. After each `invoke()` statement, the `final_state` object
    contains a list of messages between the model and the human.
  prefs: []
  type: TYPE_NORMAL
- en: To get the most recent message in the conversation, you will display `final_state["messages"][-1].content`.
    The messages will have Markdown formatting, so you can use the `display(Markdown())`
    statement to format them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that models are *nondeterministic*, even with a temperature setting
    of zero. This means that each interaction may be slightly different. But if your
    call to the graph is successful, you should see a message similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you receive an error at this step related to the API key, check to make sure
    that you have added funds to your Anthropic account, created an API key, and set
    it in your Codespaces secrets. If any of these steps were skipped, you won’t be
    able to use the Anthropic model in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears that the Anthropic model has been trained with historical information
    about the NFL. Let’s see how it does when we ask questions about the SportsWorldCentral
    app. Add and run a Python code cell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will receive a message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The model apparently suspects that SportsWorldCentral may not be “a real platform,”
    but even for real-world platforms like Sleeper or MyFantasyLeague.com, the model
    doesn’t contain information about specific leagues and teams.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this knowledge gap, you will create a toolkit that provides access
    to the SportsWorldCentral API.
  prefs: []
  type: TYPE_NORMAL
- en: Running the SportsWorldCentral (SWC) API Locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code and database files for the SWC API are in the */api* folder of your
    Codespace. Start a second session in the Terminal and install the required libraries
    for the API in your Codespace as shown, using the *requirements.txt* file that
    is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch the API from the command line as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see several messages from the FastAPI CLI, ending with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The API is now running in Codespaces. Copy the URL shown in the Terminal (in
    this example it is `[*http://0.0.0.0:8000*](http://0.0.0.0:8000)`, and it may
    be in yours too).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the primary Terminal session, create a file named *.env* in the base project
    directory as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Update this file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will be used in the Jupyter Notebook you create later.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the swcpy Software Development Kit (SDK)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build the toolkit for using your API, you will first install the swcpy SDK
    that you created in [Chapter 7](ch07.html#chapter_7). If you completed that project
    already, you can copy that code to this repository and install it locally using
    `pip3 install -e` in the */sdk* directory. If you have not completed that yet,
    execute the following command to install the SDK from the Part I GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the installation is successful, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will be creating a tool that uses the swcpy SDK, which gives the most robust
    way to interact with your API. There are other methods you could use to interact
    with your API. For example, you could also build a tool that is based on the simple
    API client that you created in [Chapter 9](ch09.html#chapter_9). Or you could
    create a tool that directly calls individual API endpoints using httpx or requests.
    You may want to experiment with different methods to see which you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a LangChain Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A LangChain toolkit contains multiple tools. LangChain provides multiple ways
    to create tools, as shown in [“How to Create Tools”](https://oreil.ly/V8tBi).
    You will create tools by subclassing the `BaseTool` class. According to the documentation,
    this method “provides maximal control over the tool definition.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python file named *swc_toolkit.py* as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of your toolkit file, you will add your imports and load the Codespace
    secret. Add the following contents to *swc_toolkit.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These imports use the LangChain libraries for defining tools and toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement checks to see if the swcpy SDK has been installed in the environment.
    If not, an error is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_with_langchain_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This instantiates the SDK. For more information about how this works, see [Chapter 7](ch07.html#chapter_7).
  prefs: []
  type: TYPE_NORMAL
- en: 'The swcpy SDK has multiple functions, which call API endpoints in different
    ways. For each of the SDK functions you make available to the agent, create an
    instance of the Pydantic `BasesModel` class for input values and an instance of
    the LangChain `BaseTool` class to call the SDK. You will create the following
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HealthCheckTool`: Allows the agent to check if the API is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListLeaguesTool`: Allows the agent to get a list of leagues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListTeamsTool`: Allows the agent to get a list of teams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following contents to the bottom of *swc_toolkit.py*, which add the
    `HealthCheckTool` and `ListLeaguesTool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: For each tool, you will define an input object, which is a subclass of the Pydantic
    `BaseModel`. This tool does not accept parameters, so you are creating an empty
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the definition of the tool for the health check, and it is a subclass
    of the LangChain `BaseTool`. The information you provide in this section will
    be used by the model to decide how and when to use this tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_with_langchain_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `args_schema` defines what inputs are expected, and the model will use this
    to send input to the tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_apis_with_langchain_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the action occurs. It is calling the `get_health_check()` method
    from the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_using_apis_with_langchain_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the input defined for the `ListLeaguesTool`. It contains parameters
    used by that tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_using_apis_with_langchain_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the tool that will call the SDK’s `list_leagues()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you will add the `ListTeamsTool` and create a `BaseToolkit` object that
    represents all of the tools that you will be providing to an agent. Add the following
    contents to the bottom of *swc_toolkit.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the input defined for the `ListTeamsTool`. It contains parameters used
    by that tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the tool that will call the SDK’s `list_teams()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_with_langchain_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The toolkit is subclassed from the LangChain `BaseToolkit` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_apis_with_langchain_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `get_tools()` method returns a list of the tools in the toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_using_apis_with_langchain_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement instantiates the tools and returns them in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Calling APIs Using AI (with LangGraph)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *langgraph_notebook.ipynb* notebook, you created an agent that could
    chat, but the agent was unable to answer questions from the SWC API. Now you will
    make an improved version that can use tools to call the SWC API. First, make a
    copy of the Jupyter Notebook with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Open *langgraph_notebook_with_toolkit.ipynb* and select the Python kernel as
    you did previously. Update the first Markdown cell with the following text for
    clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the first Python cell that contains the `import` statements
    and re-run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the `import` statement for the toolkit that you created.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This `import` provides the LangChain tool functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_with_langchain_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This `import` adds LangGraph support for toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the Python cell that is used to configure logging. Beneath that cell,
    add the following Markdown cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will reference the toolkit you created and imported earlier. To instantiate
    your toolkit, add the following Python cell and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These statements create an instance of your toolkit class, then retrieve all
    of the tools from it and put those into the `tools` object.
  prefs: []
  type: TYPE_NORMAL
- en: For the main body of your agent, there will be many changes. You will be *binding*
    the tools to your model, which means making the model aware of the tools it has
    access to. Then, you will create a node for the tools and update the flow of the
    agent to use tools when needed to answer questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the Python cell following the title “Configure Agent and Model.” Replace
    the entire contents with the following, and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_apis_with_langchain_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This adds the `bind_tools()` function to the model initialization so that the
    model can use the toolkit you created.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_apis_with_langchain_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This will be used as a *conditional edge*, which is a workflow that decides
    how to proceed based on the results. If the model suggests a tool call, this returns
    the literal “tools.”
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_apis_with_langchain_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This adds a new node in the graph to perform tool calls using the new toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_apis_with_langchain_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This adds the conditional edge that uses the `should_continue` function defined
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: To see how the flow has been updated to add a tool node, rerun the Python cell
    under the “Visualize the Graph” heading.
  prefs: []
  type: TYPE_NORMAL
- en: You should see an image that matches [Figure 14-6](#graph_visual_2_ch14). This
    shows a loop between the agent and the available tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph of the agent with tools](assets/haad_1406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-6\. Graph of the agent with tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The agent will decide how many times it needs to use the tools to answer the
    question. Depending on the question asked and the reasoning of the agent, this
    may involve one API call, multiple API calls, or no API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Chatting with Your Agent (with Tools)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it’s time to see if your effort to provide tools to the agent has improved
    its ability to answer questions about SportsWorldCentral. Let’s start with the
    question that stumped it before. Enter the following in a new Python cell and
    run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You will receive a message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the Terminal window, you should see the following, which indicates
    that the agent used the `ListLeaguesTool` from the toolkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have created a LangGraph agent and provided it a toolkit
    to call your custom API.
  prefs: []
  type: TYPE_NORMAL
- en: Take time and experiment with questions that will encourage the agent to use
    the `HealthCheckTool` and the `ListTeamsTool`. Look at the Terminal output or
    log file to see the API calls that are generated. How can you influence its tool
    use? How can you guide it to answer more difficult questions using the tools?
    How can you stump it?
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LangChain is a recent framework, so published resources are having a hard time
    keeping up. As you look at online resources and demos, check the versions of libraries
    that are being discussed, because at the time of this writing, some of the resources
    contained deprecated code.
  prefs: []
  type: TYPE_NORMAL
- en: With that caveat, the most up-to-date resource is the [official LangChain docs
    page](https://oreil.ly/jyC-I).
  prefs: []
  type: TYPE_NORMAL
- en: LangGraph is even newer than LangChain; the [LangGraph documentation](https://oreil.ly/WBOXF)
    has the most detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: To see Anthropic’s advice on agents, including several recommended workflows,
    read [“Building Effective Agents”](https://oreil.ly/QvAKC).
  prefs: []
  type: TYPE_NORMAL
- en: Google produced an [Agents Whitepaper](https://oreil.ly/M5hV_) that explains
    the key components in a fully functional agent. It has a strong emphasis on how
    agents can use tools, which includes APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you used the LangChain and LangGraph frameworks to create an
    intelligent agent that interacted with an AI model and your SWC API. This allowed
    you to ask questions about SWC data with natural language in a Jupyter Notebook.
    These are the beginning steps to using APIs with AI applications.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.html#chapter_15), you will use ChatGPT, which is a full-featured
    application that uses LLMs and can call APIs like you did in this chapter. You
    will create a custom action and custom GPT that can interact with the SWC API.
  prefs: []
  type: TYPE_NORMAL
