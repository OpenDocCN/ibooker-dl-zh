- en: Capitolo 4\. Implementazione di servizi AI sicuri dal punto di vista tipologico
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 从类型安全角度实现安全的 AI 服务
- en: 'Questo lavoro è stato tradotto utilizzando l''AI. Siamo lieti di ricevere il
    tuo feedback e i tuoi commenti: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作是用 AI 翻译的。我们很高兴收到你的反馈和评论：[translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)
- en: Quando lavori con codebase complesse che vengono modificate continuamente da
    più collaboratori e quando interagisci con servizi esterni come API o database,
    vorrai seguire le migliori pratiche come la sicurezza dei tipi nella creazione
    delle tue applicazioni.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与复杂且不断由多个协作者修改的代码库以及与外部服务（如 API 或数据库）交互时，你将希望遵循最佳实践，例如在创建你的应用程序时确保类型安全。
- en: Questo capitolo si concentra sull'importanza della sicurezza dei tipi nella
    creazione di servizi backend e API. Imparerai come implementare la sicurezza dei
    tipi utilizzando le classi di dati integrate in Python e i modelli di dati Pydantic,
    e vedrai le loro somiglianze e differenze. Inoltre, esplorerai come utilizzare
    i modelli di dati Pydantic con i validatori personalizzati per proteggerti da
    input errati da parte dell'utente o da dati non corretti, e imparerai come utilizzare
    le Impostazioni di Python per il caricamento e la convalida delle variabili d'ambiente.
    Infine, scoprirai le strategie per affrontare le modifiche allo schema nei sistemi
    esterni e per gestire la complessità in codebase in evoluzione per evitare bug.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章侧重于在创建后端服务和 API 时类型安全的重要性。你将学习如何使用 Python 中的内置数据类和 Pydantic 数据模型来实现类型安全，并了解它们的相似之处和不同之处。此外，你将探索如何使用
    Pydantic 数据模型与自定义验证器一起使用，以保护自己免受用户错误输入或数据不正确的影响，并学习如何使用 Python 设置进行环境变量的加载和验证。最后，你将了解处理外部系统模式更改的策略以及管理不断发展的代码库中的复杂性的策略，以避免错误。
- en: Alla fine di questo capitolo, avrai un servizio GenAI completamente tipizzato
    e meno soggetto a bug quando si tratta di modifiche, input errati dell'utente
    erisposte incoerenti del modello.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将拥有一个完全类型化的 GenAI 服务，它在修改、用户输入错误或模型不一致的响应方面更不容易出现错误。
- en: Per seguirci, puoi trovare il codice iniziale di questo capitolo passando al
    [ramo`ch04-start`](https://github.com/Ali-Parandeh/building-generative-ai-services/tree/ch04-start)
    .
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随我们，你可以通过访问[ramo`ch04-start`](https://github.com/Ali-Parandeh/building-generative-ai-services/tree/ch04-start)来找到本章的初始代码。
- en: Introduzione alla sicurezza di tipo
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型安全简介
- en: '*Tipi* nella programmazione specifica quali valori possono essere assegnati
    alle variabili e le operazioni che possono essere eseguite su tali variabili.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型*在编程中指定可以分配给变量的值以及可以在这些变量上执行的操作。'
- en: 'In Python, i tipi più comuni sono i seguenti:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，最常见的类型如下：
- en: Intero
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: Rappresentare numeri interi
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表示整数
- en: Galleggiante
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数
- en: Rappresentare numeri con parti frazionarie
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表示有分数部分的数字
- en: Stringa
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Rappresentare sequenze di caratteri
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表示字符序列
- en: Booleano
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值
- en: Rappresentare i valori di `True` o `False`
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 `True` 或 `False` 的值
- en: Suggerimento
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 建议
- en: Puoi utilizzare il pacchetto `typing` per importare tipi speciali, come hai
    visto in altri esempi di codice del [Capitolo 3](ch03.html#ch03).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `typing` 包来导入特殊类型，就像你在[第三章](ch03.html#ch03)中的其他代码示例中看到的那样。
- en: La*sicurezza dei tipi* è una pratica di programmazione che garantisce che alle
    variabili vengano assegnati solo valori compatibili con i loro tipi definiti.
    In Python, puoi usare i tipi per controllare l'uso delle variabili in una base
    di codice, in particolare se la base di codice cresce in complessità e dimensioni.
    Gli strumenti di controllo dei tipi (ad esempio, `mypy`) possono quindi usare
    questi tipi per individuare assegnazioni o operazioni errate sulle variabili.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型安全*是一种编程实践，它确保变量只被分配与其定义的类型兼容的值。在 Python 中，你可以使用类型来控制代码库中变量的使用，特别是当代码库在复杂性和尺寸上增长时。类型控制工具（例如，`mypy`）可以使用这些类型来识别变量上的错误分配或操作。'
- en: Puoi imporre vincoli di tipo dichiarando variabili e funzioni completamente
    tipizzate, come mostrato nell'[Esempio 4-1](#type_safe_code).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过声明完全类型化的变量和函数来施加约束，如下面的[Esempio 4-1](#type_safe_code)所示。
- en: Esempio 4-1\. Usare i tipi in Python
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1. 在 Python 中使用类型
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Anche gli editor di codice e gli IDE (ad esempio VS Code o JetBrains PyCharm)
    possono utilizzare estensioni di controllo del tipo, come mostrato nella [Figura
    4-1](#type_safety), per segnalare le violazioni del tipo durante la scrittura
    del codice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑器和IDE（例如VS Code或JetBrains PyCharm）也可以使用类型检查扩展，如[图4-1](#type_safety)所示，在编写代码时报告类型违规。
- en: '![bgai 0401](assets/bgai_0401.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0401](assets/bgai_0401.png)'
- en: Figura 4-1\. Cattura degli errori di tipo nell'estensione VS Code `mypy`
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1\. VS Code `mypy`扩展中的类型错误捕获
- en: In una base di codice complessa, è facile perdere di vista le variabili, i loro
    stati e gli schemi in continua evoluzione. Ad esempio, potresti dimenticare che
    la funzione `timestamp_to_isostring` accetta numeri come input e passare erroneamente
    un timestamp come stringa, come mostrato nella [Figura 4-1](#type_safety).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的代码库中，很容易失去对变量、它们的状态和不断演变的模式的视线。例如，你可能会忘记`timestamp_to_isostring`函数接受数字作为输入，并错误地将时间戳作为字符串传递，如[图4-1](#type_safety)所示。
- en: I tipi sono estremamente utili anche quando i manutentori dei pacchetti o i
    fornitori esterni di API aggiornano il loro codice. I controllori di tipo possono
    immediatamente emettere degli avvisi per aiutarti ad affrontare tali modifiche
    durante lo sviluppo. In questo modo, sarai immediatamente indirizzato alle fonti
    di potenziali errori senza dover eseguire il tuo codice e testare ogni endpoint.
    Di conseguenza, le pratiche di sicurezza dei tipi possono farti risparmiare tempo
    con il rilevamento precoce e impedirti di avere a che fare con errori di runtime
    più oscuri.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件包维护者或外部API提供商更新他们的代码时，类型也非常有用。类型检查器可以立即发出警告，帮助你处理开发中的此类更改。这样，你将立即被引导到潜在错误源，而无需执行你的代码和测试每个端点。因此，类型安全实践可以让你通过早期检测节省时间，并防止你遇到更难以追踪的运行时错误。
- en: Infine, puoi fare un ulteriore passo avanti per impostare controlli automatici
    del tipo nella tua pipeline di distribuzione, per evitare di spingere le modifiche
    di rottura negli ambienti di produzione.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以进一步设置在您的发布管道中自动的类型检查，以避免在生产环境中推送破坏性的更改。
- en: 'La sicurezza dei tipi all''inizio sembra un peso: devi digitare esplicitamente
    ogni funzione che scrivi, il che può essere una seccatura e rallentare le fasi
    iniziali dello sviluppo.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全一开始可能感觉像是一个负担：你必须明确地输入你写的每个函数，这可能会很麻烦并减慢开发的早期阶段。
- en: Alcune persone saltano la digitazione del codice per una prototipazione rapida
    e per scrivere meno codice boilerplate. L'approccio è più flessibile e più facile
    da usare, e Python è abbastanza potente per dedurre i tipi semplici. Inoltre,
    alcuni schemi di codice (come le funzioni con argomenti multitipo) possono essere
    così dinamici che è più facile evitare di implementare una sicurezza di tipo rigorosa
    quando si sta ancora sperimentando. Tuttavia, questo ti farà risparmiare ore di
    sviluppo perché inevitabilmente i tuoi servizi diventano complessi e cambiano
    continuamente.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人为了快速原型设计和编写更少的样板代码而跳过代码的输入。这种方法更灵活，更容易使用，Python也足够强大，可以推断简单的类型。此外，一些代码模式（如多类型参数的函数）可能非常动态，因此在实验阶段更容易避免实施严格的安全类型。然而，这会为你节省开发时间，因为你的服务不可避免地会变得复杂并不断变化。
- en: La buona notizia è che alcuni di questi tipi possono essere generati automaticamente
    utilizzando strumenti come Prisma, quando si lavora con i database, o generatori
    di client, quando si lavora con API esterne. Per quanto riguarda le API esterne,
    spesso è possibile trovare SDK ufficiali contenenti client con suggerimenti di
    tipo (cioè client completamente tipizzati) che specificano i tipi di input e output
    previsti per l'utilizzo dell'API. In caso contrario, puoi ispezionare l'API per
    creare il tuo client completamente tipizzato. Tratterò Prisma e i generatori di
    client API in modo più dettagliato più avanti nel libro.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，一些类型可以使用像Prisma这样的工具自动生成，当你与数据库一起工作时，或者当你在处理外部API时使用客户端生成器。对于外部API，通常可以找到包含具有类型建议（即完全类型化客户端）的官方SDK，这些客户端指定了API使用的预期输入和输出类型。否则，你可以检查API以创建你自己的完全类型化客户端。本书后面将更详细地介绍Prisma和API客户端生成器。
- en: Quando non usi i tipi, ti esponi a ogni sorta di bug ed errori che potrebbero
    verificarsi perché altri sviluppatori hanno aggiornato inaspettatamente le tabelle
    del database o gli schemi API con cui il tuo servizio interagisce. In altri casi,
    potresti aggiornare una tabella del database - ad esempio, eliminando una colonna
    - e dimenticare di aggiornare il codice che interagisce con quella tabella.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Senza i tipi, potresti non accorgerti mai delle modifiche dovute agli aggiornamenti.
    Questo può essere difficile da debuggare perché gli errori a valle non gestiti
    potrebbero non individuare il componente rotto o i problemi generali legati a
    casi limite non gestiti dal tuo team di sviluppo. Di conseguenza, ciò che avrebbe
    potuto richiedere un minuto per essere risolto può durare mezza giornata o anche
    di più.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Puoi sempre evitare qualche disastro in produzione con test approfonditi, ma
    è molto più facile evitare problemi di integrazione e affidabilità se inizi a
    usare i tipi fin dall'inizio.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Sviluppare buone abitudini di programmazione
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Se in passato non hai digitato il tuo codice, non è mai troppo tardi per iniziare
    a prendere l'abitudine di digitare tutte le variabili, i parametri delle funzioni
    e i tipi di ritorno.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: L'uso dei tipi renderà il tuo codice più leggibile, ti aiuterà a individuare
    tempestivamente i bug e ti farà risparmiare molto tempo quando dovrai rivisitare
    codebase complesse per capire rapidamente come scorrono i dati.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Implementare la sicurezza di tipo
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Da Python 3.5 puoi dichiarare esplicitamente i tipi di variabili, parametri
    di funzioni e valori di ritorno. La sintassi che ti permette di dichiarare questi
    tipi è l'*annotazione del tipo*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Annotazioni sul tipo
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Le annotazioni sui tipi non influiscono sul comportamento runtime dell'applicazione,
    ma aiutano a individuare gli errori di tipo, in particolare nelle applicazioni
    complesse e di grandi dimensioni in cui più persone lavorano insieme. Gli strumenti
    per il controllo statico dei tipi, come `mypy`, `pyright`, o `pyre`, insieme agli
    editor di codice, possono verificare che i tipi di dati memorizzati e restituiti
    dalle funzioni corrispondano ai tipi previsti.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Nelle applicazioni Python, le annotazioni di tipo vengono utilizzate per:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '*Supporto per il completamento automatico dell''editor di codice*'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I*controlli statici del tipo* utilizzano strumenti come `mypy`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FastAPI sfrutta anche i suggerimenti sui tipi per:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '*Definire i requisiti del gestore*, compresi i parametri del percorso e della
    query, i corpi, le intestazioni, le dipendenze, ecc.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Convertire i dati* ogni volta che è necessario'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Convalidare i dati* provenienti dalle richieste in arrivo, dai database e
    dai servizi esterni.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Aggiornare automaticamente la specifica OpenAPI* che alimenta la pagina di
    documentazione generata'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Puoi installare `loguru` utilizzando `pip`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2] # utils.py  from typing import Literal, TypeAlias from loguru import
    logger import tiktoken  SupportedModels: TypeAlias = Literal["gpt-3.5", "gpt-4"]
    PriceTable: TypeAlias = dict[SupportedModels, float] ![1](assets/1.png) ![2](assets/2.png)
    price_table: PriceTable = {"gpt-3.5": 0.0030, "gpt-4": 0.0200} ![3](assets/3.png)  def
    count_tokens(text: str | None) -> int: ![4](assets/4.png)     if text is None:         logger.warning("Response
    is None. Assuming 0 tokens used")         return 0 ![5](assets/5.png)     enc
    = tiktoken.encoding_for_model("gpt-4o")     return len(enc.encode(text)) ![6](assets/6.png)  def
    calculate_usage_costs(     prompt: str,     response: str | None,     model: SupportedModels,
    ) -> tuple[float, float, float]: ![7](assets/7.png)     if model not in price_table:         #
    raise at runtime - in case someone ignores type errors         raise ValueError(f"Cost
    calculation is not supported for {model} model.") ![8](assets/8.png)     price
    = price_table[model] ![9](assets/9.png)     req_costs = price * count_tokens(prompt)
    / 1000     res_costs = price * count_tokens(response) / 1000 ![10](assets/10.png)     total_costs
    = req_costs + res_costs     return req_costs, res_costs, total_costs ![11](assets/11.png)
    [PRE3]`  [PRE4] from typing import Annotated, Literal  SupportedModels = Annotated[     Literal["gpt-3.5-turbo",
    "gpt-4o"], "Supported text models" ] PriceTableType = Annotated[     dict[SupportedModels,
    float], "Supported model pricing table" ]  prices: PriceTableType = {     "gpt-4o":
    0.000638,     # error: Dict entry 1 has incompatible type "Literal[''gpt4-o'']"
    [dict-item]     "gpt4-o": 0.000638,     # error: Dict entry 2 has incompatible
    type "Literal[''gpt-4'']" [dict-item]     "gpt-4": 0.000638, } [PRE5] # utils.py  from
    dataclasses import dataclass from typing import Literal, TypeAlias from utils
    import count_tokens  SupportedModels: TypeAlias = Literal["gpt-3.5", "gpt-4"]
    PriceTable: TypeAlias = dict[SupportedModels, float] prices: PriceTable = {"gpt-3.5":
    0.0030, "gpt-4": 0.0200}  @dataclass ![1](assets/1.png) class Message:     prompt:
    str     response: str | None ![2](assets/2.png)     model: SupportedModels  @dataclass
    class MessageCostReport:     req_costs: float     res_costs: float     total_costs:
    float  # Define count_tokens function as normal ...  def calculate_usage_costs(message:
    Message) -> MessageCostReport: ![3](assets/3.png)     if message.model not in
    prices :         # raise at runtime - in case someone ignores type errors         raise
    ValueError(             f"Cost calculation is not supported for {message.model}
    model."         )     price = prices[message.model]     req_costs = price * count_tokens(message.prompt)
    / 1000     res_costs = price * count_tokens(message.response) / 1000     total_costs
    = req_costs + res_costs     return MessageCostReport(         req_costs=req_costs,
    res_costs=res_costs, total_costs=total_costs     ) [PRE6]`  [PRE7][PRE8][PRE9]
    $ pip install pydantic [PRE10]`Pydantic implementa un `BaseModel`, che è il metodo
    principale per definire i modelli.*I modelli* sono semplicemente classi che ereditano
    da `BaseModel` e definiscono i campi come attributi annotati utilizzando i suggerimenti
    di tipo. I modelli possono essere utilizzati come schemi per convalidare i dati.    Oltre
    a raggruppare i dati,^([3](ch04.html#id762)) i modelli Pydantic ti permettono
    di specificare i requisiti di richiesta e risposta dei tuoi endpoint di servizio
    e di convalidare i dati non attendibili in arrivo da fonti esterne. Puoi anche
    arrivare a filtrare i tuoi output LLM utilizzando i modelli Pydantic (e i validatori,
    che imparerai a conoscere meglio tra poco).    Puoi creare i tuoi modelli Pydantic
    come mostrato nell''[Esempio 4-5](#pydantic_models).    ##### Esempio 4-5\. Creare
    modelli Pydantic    [PRE11]    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO3-1)      Definisci
    il modello `TextModelRequest` ereditando il modello Pydantic `BaseModel`.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO3-2)      Imposta
    i valori predefiniti se non viene fornito un valore esplicito. Per esempio, imposta
    il campo `temperature` a `0.0` se non viene fornito un valore all''inizializzazione.      L[''esempio
    4-5](#pydantic_models) mostra anche come puoi trasformare le tue classi di dati
    in modelli Pydantic per sfruttare le sue numerose funzionalità.[PRE12][PRE13][PRE14]
    ## Modelli pidantici composti    Con i modelli Pydantic puoi dichiarare *schemi
    di* dati, che definiscono le strutture di dati supportate nelle operazioni del
    tuo servizio. Inoltre, puoi anche utilizzare l''ereditarietà per costruire modelli
    composti, come mostrato nell''[Esempio 4-6](#pydantic_compound_models).    #####
    Esempio 4-6\. Creazione di modelli Pydantic    [PRE15]    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO4-1)      Definisci
    il modello `ModelRequest` ereditando il modello Pydantic `BaseModel`.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO4-2)      Definisci
    il campo `ModelResponse`. Se i dati per il campo opzionale `ip` non sono forniti,
    utilizza i valori predefiniti di `None`. Il campo `content` può essere sia byte
    (per le immagini) che stringa (per i modelli di testo).      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO4-3)      Definisci
    i modelli `TextModelRequest` e `ImageModelRequest` ereditando`ModelRequest`. Il
    campo opzionale della temperatura è impostato di default a 0.0\. Il campo `num_inference_steps`
    per il modello `ImageModelRequest` è opzionale e impostato a 200\. Entrambi i
    modelli richiedono ora l''inserimento del campo prompt string.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO4-4)      Definisci
    i modelli `ImageModelResponse` e `TextModelResponse` ereditando il modello `ModelResponse`.
    Per `TextModelResponse`, fornisci il conteggio dei token e per `ImageModelResponse`,
    fornisci le dimensioni dell''immagine in pixel insieme all''URL remoto per scaricare
    l''immagine.      Con i modelli mostrati nell''[Esempio 4-6](#pydantic_compound_models),
    hai gli schemi necessari per definire i requisiti dei tuoi endpoint di generazione
    di testo e immagini.    ## Vincoli e validatori di campo    Oltre al supporto
    per i tipi standard, Pydantic offre anche *tipi vincolati* come `EmailStr`, `PositiveInt`,
    `UUID4`, `AnyHttpUrl` e altri che possono eseguire la convalida dei dati durante
    l''inizializzazione del modello per i formati di dati più comuni. L''elenco completo
    dei tipi di Pydantic è disponibile nella [documentazione ufficiale](https://oreil.ly/xNbXX).    ######
    Nota    Alcuni tipi vincolati come `EmailStr` richiedono l''installazione di pacchetti
    di dipendenza per funzionare, ma possono essere estremamente utili per convalidare
    formati di dati comuni come le e-mail.    Per definire vincoli di campo più complessi
    e personalizzati in aggiunta ai tipi vincolati da Pydantic, puoi utilizzare la
    funzione `Field` di Pydantic con il tipo `Annotated` per introdurre vincoli di
    validazione come un intervallo di input valido.    L[''Esempio 4-7](#pydantic_constrained_fields)
    sostituisce i suggerimenti di tipo standard dell''[Esempio 4-6](#pydantic_compound_models)
    con tipi vincolati e funzioni di `Field` per implementare requisiti di dati più
    severi per i tuoi endpoint basati sui vincoli del modello.    ##### Esempio 4-7\.
    Utilizzo di campi vincolati    [PRE16]    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO5-1)      Sostituisci
    il tipo standard `str` con `Field` e `Annotated` per delimitare la lunghezza della
    stringa a un intervallo di caratteri.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO5-2)      Genera
    un nuovo UUID della richiesta passando un callable a `default_factory` che verrà
    chiamato per generare un nuovo UUID.      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO5-3)      Vincola
    il campo opzionale `ip` a qualsiasi intervallo di indirizzi IPv4 o IPv6 valido.
    Anche`None` è una voce valida se non è possibile determinare l''IP del client.
    Questo campo opzionale non ha un valore predefinito, quindi se non viene fornito
    un IP valido o `None`, Pydantic solleverà un `ValidationError`.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO5-4)      Limita
    il campo `content` a 10.000 caratteri o byte.      [![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO5-5)      Vincola
    la temperatura tra `0.0` e `1.0` con un valore predefinito di `0.0`.      [![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO5-6)      Riutilizza
    un vincolo `Annotated` sul campo `output_size` a numeri interi positivi utilizzando
    il tipo vincolato `PositiveInt`. Le parole chiave `lte` e `gte` si riferiscono
    rispettivamente a *meno di uguale* e *maggiore di uguale*.      [![7](assets/7.png)](#co_implementing_type_safe_ai_services_CO5-8)      Vincola
    il campo `num_inference_steps` con `Field` tra `0` e `2000` e un valore predefinito
    di `200`.      [![8](assets/8.png)](#co_implementing_type_safe_ai_services_CO5-10)      Vincola
    il campo opzionale `url` a qualsiasi URL HTTP o HTTPS valido, dove il nome dell''host
    e il dominio di primo livello (TLD) sono obbligatori.      Con i modelli definiti
    nell''[Esempio 4-7](#pydantic_constrained_fields), ora puoi eseguire la convalida
    dei dati in entrata o in uscita per soddisfare i requisiti di dati che hai. In
    questi casi, FastAPI sfrutterà Pydantic per restituire automaticamente le risposte
    di errore quando i controlli di convalida dei dati falliscono durante il runtime
    di una richiesta, come mostrato nell''[Esempio 4-8](#fastapi_pydantic_validation_failure).    #####
    Esempio 4-8\. Risposta di errore di FastAPI in caso di mancata convalida dei dati    [PRE17][PRE18][PRE19]``py[PRE20]py`
    `"type"`: `"literal_error"`, [PRE21]`py `"loc"`: `[` [PRE22] `"body"`, [PRE23][PRE24]``py[PRE25]``
    `"msg"`: `"Input should be ''tinyllama'' or ''gemma2b''"`, [PRE26]`` `"input"`:
    `"gpt-4o"`, [PRE27]` `"ctx"`: `{` [PRE28] `"expected"`: `"''tinyllama'' or ''gemma2b''"`
    [PRE29]`py [PRE30]py`` [PRE31]py[PRE32][PRE33][PRE34][PRE35]py[PRE36]py` [PRE37]`py``
    [PRE38]`py[PRE39]   [PRE40]` [PRE41] [PRE42]`py [PRE43]py[PRE44]py[PRE45]`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
