- en: Chapter 4\. Implementing Type-Safe AI Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章\. 实现类型安全的AI服务
- en: When working with complex codebases that continuously change by multiple contributors
    and when interacting with external services such as APIs or databases, you will
    want to follow best practices such as type safety in building your applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当与由多个贡献者持续更改的复杂代码库一起工作，并且与外部服务（如API或数据库）交互时，您将希望遵循最佳实践，例如在构建应用程序时确保类型安全。
- en: This chapter focuses on the importance of type safety when building backend
    services and APIs. You will learn how to implement type safety using Python’s
    built-in dataclasses and then Pydantic data models, and you will see their similarities
    and differences. In addition, you will explore how to use Pydantic data models
    with custom validators to protect against bad user input or incorrect data, and
    you will learn how to use Pydantic Settings for loading and validating environment
    variables. Finally, you will discover strategies for dealing with schema changes
    in external systems and managing complexity in evolving codebases to prevent bugs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍在构建后端服务和API时类型安全的重要性。您将学习如何使用Python的内置数据类和Pydantic数据模型来实现类型安全，并了解它们的相似之处和不同之处。此外，您将探索如何使用自定义验证器与Pydantic数据模型一起使用，以防止不良用户输入或数据错误，并学习如何使用Pydantic设置来加载和验证环境变量。最后，您将发现处理外部系统模式更改的策略以及管理不断发展的代码库中的复杂性的策略，以防止错误。
- en: By the end of this chapter, you will have a fully typed GenAI service that is
    less prone to bugs when dealing with changes, bad user inputs, and inconsistent
    model responses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个完全类型化的GenAI服务，在处理更改、不良用户输入和不一致模型响应时，该服务更不容易出现错误。
- en: To follow along, you can find the starting code for this chapter by switching
    to the [`ch04-start` branch](https://github.com/Ali-Parandeh/building-generative-ai-services/tree/ch04-start).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟上进度，您可以通过切换到[`ch04-start`分支](https://github.com/Ali-Parandeh/building-generative-ai-services/tree/ch04-start)来找到本章的起始代码。
- en: Introduction to Type Safety
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型安全简介
- en: '*Types* in programming specify what values can be assigned to variables and
    operations that can be performed on those variables.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的*类型*指定可以分配给变量的值以及可以在这些变量上执行的操作。
- en: 'In Python, common types include the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，常见类型包括以下内容：
- en: Integer
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: Representing whole numbers
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表示整数
- en: Float
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数
- en: Representing numbers with fractional parts
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表示有分数部分的数字
- en: String
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Representing sequences of characters
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表示字符序列
- en: Boolean
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值
- en: Representing `True` or `False` values
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表示`True`或`False`值
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use the `typing` package to import special types as you saw in other
    code examples in [Chapter 3](ch03.html#ch03).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`typing`包导入特殊类型，正如您在[第 3 章](ch03.html#ch03)中的其他代码示例中看到的那样。
- en: '*Type safety* is a programming practice that ensures variables are only assigned
    values compatible with their defined types. In Python, you can use types to check
    the usage of variables across a codebase, in particular if the codebase grows
    in complexity and size. Type checking tools (e.g., `mypy`) can then use these
    types to catch incorrect variable assignments or operations.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型安全*是一种编程实践，确保变量只分配与其定义类型兼容的值。在Python中，您可以使用类型来检查代码库中变量的使用情况，特别是如果代码库在复杂性和大小方面增长。然后，类型检查工具（例如，`mypy`）可以使用这些类型来捕获错误的变量分配或操作。'
- en: You can enforce type constraints by declaring fully typed variables and functions
    as shown in [Example 4-1](#type_safe_code).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过声明完全类型化的变量和函数来强制类型约束，如[示例 4-1](#type_safe_code)所示。
- en: Example 4-1\. Using types in Python
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 在Python中使用类型
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code editors and IDEs (e.g., VS Code or JetBrains PyCharm) can also use type
    checking extensions, as shown in [Figure 4-1](#type_safety), to raise warnings
    on type violations as you write code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑器和IDE（例如，VS Code或JetBrains PyCharm）也可以使用类型检查扩展，如[图 4-1](#type_safety)所示，在编写代码时发出类型违规警告。
- en: '![bgai 0401](assets/bgai_0401.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0401](assets/bgai_0401.png)'
- en: Figure 4-1\. Catching type errors in VS Code `mypy` extension
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 在VS Code `mypy`扩展中捕获类型错误
- en: In a complex codebase, it is easy to lose track of variables, their states,
    and constantly changing schemas. For example, you might forget that the `timestamp_to_isostring`
    function accepts numbers as input and mistakenly pass a timestamp as a string,
    as shown in [Figure 4-1](#type_safety).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的代码库中，很容易失去对变量、它们的状态和不断变化的模式的跟踪。例如，您可能会忘记`timestamp_to_isostring`函数接受数字作为输入，并错误地将时间戳作为字符串传递，如[图
    4-1](#type_safety)所示。
- en: Types are also extremely useful when package maintainers or external API providers
    update their code. Type checkers can immediately raise warnings to help you address
    such changes during development. This way, you will be immediately directed to
    sources of potential errors without having to run your code and test every endpoint.
    As a result, type safety practices can save you time with early detection and
    prevent you from dealing with more obscure runtime errors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当包维护者或外部API提供商更新他们的代码时，类型也非常有用。类型检查器可以立即发出警告，帮助你在开发过程中处理这些更改。这样，你将立即被引导到潜在错误源，而无需运行你的代码并测试每个端点。因此，类型安全实践可以通过早期检测节省你的时间，并防止你处理更难以捉摸的运行时错误。
- en: Finally, you can go one step further to set up automatic type checks in your
    deployment pipeline to prevent pushing breaking changes to production environments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以更进一步，在你的部署管道中设置自动类型检查，以防止将破坏性的更改推送到生产环境。
- en: Type safety at first seems like a burden. You have to explicitly type each and
    every function you write, which can be a hassle and slow you down in the initial
    phases of development.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全一开始可能感觉像是一种负担。你必须明确地为每个你编写的函数指定类型，这可能会很麻烦，并会在开发的初期阶段减慢你的速度。
- en: Some people skip typing their code for rapid prototyping and to write less boilerplate
    code. The approach is more flexible and easier to use, and Python is powerful
    enough to infer simple types. Also, some code patterns (such as functions with
    multitype arguments) can be so dynamic that it is easier to avoid implementing
    strict type safety when still experimenting. However, it will come to save you
    hours of development as inevitably your services become complex and continuously
    change.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人为了快速原型设计和编写更少的样板代码而跳过代码的打字。这种方法更加灵活，更容易使用，而且Python足够强大，可以推断简单的类型。此外，一些代码模式（例如具有多类型参数的函数）可能非常动态，因此在实验阶段更容易避免实施严格的类型安全。然而，随着你的服务不可避免地变得复杂并持续变化，这将会为你节省数小时的开发时间。
- en: The good news is some of these types can be auto-generated using tools such
    as Prisma, when working with databases, or client generators, when working with
    external APIs. For external APIs, you can often find official SDKs containing
    clients with type hints (i.e., fully typed client) specifying expected types of
    inputs and outputs for using the API. If not, you can inspect the API to create
    your own fully typed client. I will cover Prisma and API client generators in
    more detail later in the book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，在使用数据库时，一些类型可以使用Prisma等工具自动生成，当与外部API一起工作时，可以使用客户端生成器。对于外部API，你通常可以找到包含具有类型提示（即完全类型化的客户端）的官方SDK，这些类型提示指定了使用API时输入和输出的预期类型。如果没有，你可以检查API以创建自己的完全类型化的客户端。我将在本书的后面更详细地介绍Prisma和API客户端生成器。
- en: When you don’t use types, you open yourself to all sorts of bugs and errors
    that might occur because other developers unexpectedly updated the database tables
    or API schemas that your service interacts with. In other cases, you may update
    a database table—drop a column for instance—and forget to update the code interacting
    with that table.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不使用类型时，你可能会暴露于各种可能发生的错误和问题，这些问题可能是因为其他开发人员意外更新了你的服务交互的数据库表或API模式。在其他情况下，你可能会更新数据库表——例如删除一个列，并忘记更新与该表交互的代码。
- en: Without types, you may never notice breaking changes due to updates. This can
    be challenging to debug as unhandled downstream errors might not pinpoint the
    broken component or general issues around unhandled edge cases from your own development
    team. As a result, what might have taken a minute to resolve can last half a day
    or even longer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 没有类型，你可能永远不会注意到由于更新而导致的破坏性更改。这可能很难调试，因为未处理的下游错误可能无法确定损坏的组件或你自己的开发团队周围未处理的边缘案例的一般问题。结果，可能只需一分钟就能解决的问题可能需要半天甚至更长的时间。
- en: You can always prevent a few disasters in production with extensive testing.
    However, it’s much easier to avoid integration and reliability issues if you start
    using types from the start.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过广泛的测试始终预防一些生产中的灾难。然而，如果你从一开始就使用类型，那么避免集成和可靠性问题会容易得多。
- en: Developing good programming habits
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 培养良好的编程习惯
- en: If you haven’t been typing your code in the past, it is never too late to start
    getting into the habit of typing all your variables, function parameters, and
    return types.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没有为代码打字，现在开始养成为所有变量、函数参数和返回类型打字的习惯永远不会太晚。
- en: Using types will make your code more readable, help you catch bugs early on,
    and save you a lot of time when you revisit complex codebases to quickly understand
    how data flows.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型可以使您的代码更易于阅读，帮助您在早期捕获错误，并在重新访问复杂的代码库时节省大量时间，以便快速理解数据流。
- en: Implementing Type Safety
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现类型安全
- en: Since Python 3.5, you can explicitly declare types for your variables, function
    parameters, and return values. The syntax that allows you to declare these types
    is *type annotation*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.5 以来，您可以显式声明变量的类型、函数参数和返回值。允许您声明这些类型的语法是 *类型注解*。
- en: Type Annotations
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型注解
- en: Type annotations don’t affect the runtime behavior of your application. They
    help catch type errors, particularly in complex larger applications where multiple
    people are working together. Tools for static type checking, such as `mypy`, `pyright`,
    or `pyre`, alongside code editors, can validate that the data types stored and
    returned from functions, match the expected types.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解不会影响应用程序的运行时行为。它们有助于捕获类型错误，尤其是在复杂的大型应用程序中，多人协作时尤为重要。静态类型检查工具，如 `mypy`、`pyright`
    或 `pyre`，以及代码编辑器，可以验证从函数存储和返回的数据类型是否与预期类型匹配。
- en: 'In Python applications, type annotations are used for:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 应用程序中，类型注解用于：
- en: '*Code editor auto-complete support*'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码编辑器自动完成支持*'
- en: '*Static type checks* using tools like `mypy`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `mypy` 等工具进行静态类型检查*'
- en: 'FastAPI also leverages types hints to:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 还利用类型提示来完成：
- en: '*Define handler requirements* including path and query parameters, bodies,
    headers, and dependencies, etc.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义处理程序要求* 包括路径和查询参数、主体、头和依赖项等。'
- en: '*Convert data* whenever needed'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要时*转换数据*
- en: '*Validate data* from incoming requests, databases, and external services'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证来自传入请求、数据库和外部服务的数据*'
- en: '*Auto-update the OpenAPI specification* that powers the generated documentation
    page'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动更新生成文档页面的 OpenAPI 规范*'
- en: 'You can install `loguru` using `pip`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以使用 `pip` 安装 `loguru`:'
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 4-2](#type_annotation) shows several examples of type annotation.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-2](#type_annotation) 展示了几个类型注解的示例。'
- en: Example 4-2\. Using type annotation to reduce future bugs as code changes occur
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 使用类型注解来减少代码变更时出现的未来错误
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO1-1)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO1-1)'
- en: Use the `Literal` from Python’s `typing` module included in its standard library.^([1](ch04.html#id749))
    Declare literals `gpt-3.5` and `gpt-4` and assign them to `SupportedModel` *type
    alias*. The `PriceTable` is also a simple type alias that defines a dictionary
    with keys limited to `SupportedModel` literals and with values of type `float`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 的 `typing` 模块中的 `Literal`，它包含在其标准库中.^([1](ch04.html#id749)) 声明字面量
    `gpt-3.5` 和 `gpt-4` 并将它们分配给 `SupportedModel` *类型别名*。`PriceTable` 也是一个简单的类型别名，它定义了一个字典，其键限于
    `SupportedModel` 字面量，其值为 `float` 类型。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO1-2)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO1-2)'
- en: Mark type aliases with `TypeAlias` to be explicit that they’re not a normal
    variable assignment. Types are also normally declared using CamelCase as a best
    practice to differentiate them from variables. You can now reuse the `PriceTable`
    type alias later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TypeAlias` 标记类型别名，以明确它们不是普通变量赋值。类型通常使用驼峰式命名作为最佳实践来区分变量。您现在可以稍后重用 `PriceTable`
    类型别名。
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO1-3)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO1-3)'
- en: Declare the pricing table dictionary and assign the `PriceTable` type to explicitly
    limit what keys and values are allowed for in the pricing table dictionary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 声明定价表字典，并将 `PriceTable` 类型分配给定价表字典，以显式限制允许的键和值。
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO1-4)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO1-4)'
- en: Type the `count_tokens` function to accept strings or `None` types and always
    return an integer. Implement exception handling in case someone tries to pass
    in anything other than strings or `None` types. When defining `count_tokens`,
    code editor and static checkers will raise warnings if `count_tokens` doesn’t
    return an integer even if it receives a `None` and raises errors if any other
    types other than string or `None`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `count_tokens` 函数的类型定义为接受字符串或 `None` 类型，并始终返回整数。在定义 `count_tokens` 时，如果传入
    `None` 并引发错误，则代码编辑器和静态检查器会发出警告，如果传入除字符串或 `None` 类型之外的任何其他类型，则会引发错误。
- en: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO1-5)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO1-5)'
- en: Return `0` even if a `None` type is passed to ensure you comply with function
    typing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使传入的是 `None` 类型，也返回 `0` 以确保您符合函数类型定义。
- en: '[![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO1-6)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_implementing_type_safe_ai_services_CO1-6]'
- en: Tokenize the given text using OpenAI’s `tiktoken` library using the same encoding
    that was used for the `gpt-4o` model.^([2](ch04.html#id750))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenAI 的 `tiktoken` 库对给定文本进行分词，使用与 `gpt-4o` 模型相同的编码。[2](ch04.html#id750)
- en: '[![7](assets/7.png)](#co_implementing_type_safe_ai_services_CO1-7)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_implementing_type_safe_ai_services_CO1-7]'
- en: Type the `calculate_usage_costs` function to always take a text prompt and the
    prespecified literals for `model` parameter. Pass the `price_table` with the previously
    declared `PriceTable` type alias. The function should return a tuple of three
    floats.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `calculate_usage_costs` 函数的类型定义为始终接受文本提示和 `model` 参数的预指定字面量。传递之前声明的 `PriceTable`
    类型别名 `price_table`。该函数应返回三个浮点数的元组。
- en: '[![8](assets/8.png)](#co_implementing_type_safe_ai_services_CO1-8)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![8](assets/8.png)[#co_implementing_type_safe_ai_services_CO1-8]'
- en: Type checkers will raise warnings when an unexpected model literal is passed
    in, but you should always check for incorrect inputs to functions and raise errors
    at runtime if an unexpected model parameter is passed in.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器会在传入意外的模型字面量时发出警告，但您应该始终检查函数的输入是否正确，并在运行时如果传入意外的模型参数则引发错误。
- en: '[![9](assets/9.png)](#co_implementing_type_safe_ai_services_CO1-9)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![9](assets/9.png)[#co_implementing_type_safe_ai_services_CO1-9]'
- en: Grab the correct price from the pricing table. No need to worry about exception
    handling, as there is no chance a `KeyError` can be raised here if an unsupported
    model is passed in. If the pricing table is not updated, the function will raise
    a `ValueError` early on. Catch the `KeyError`, issue a warning that pricing table
    needs updating and then reraise the `KeyError` so that full details of the issue
    are still printed to the terminal, as you can’t make assumptions about prices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从定价表中获取正确的价格。无需担心异常处理，因为没有机会在这里引发 `KeyError`（如果传入不支持的模型）。如果定价表未更新，函数将提前引发 `ValueError`。捕获
    `KeyError`，发出警告称定价表需要更新，然后重新引发 `KeyError`，以便将问题的全部详细信息打印到终端，因为您不能对价格做出假设。
- en: '[![10](assets/10.png)](#co_implementing_type_safe_ai_services_CO1-10)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![10](assets/10.png)[#co_implementing_type_safe_ai_services_CO1-10]'
- en: Use `count_tokens` function to calculate the LLM request and response costs.
    If for any reason the LLM doesn’t return a response (returns `None`), the `count_tokens`
    can handle it and assume zero tokens.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `count_tokens` 函数计算 LLM 请求和响应的成本。如果由于任何原因 LLM 没有返回响应（返回 `None`），`count_tokens`
    可以处理它并假设为零个令牌。
- en: '[![11](assets/11.png)](#co_implementing_type_safe_ai_services_CO1-11)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![11](assets/11.png)[#co_implementing_type_safe_ai_services_CO1-11]'
- en: Return a tuple of three floats as per function typing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 按照函数类型定义返回三个浮点数的元组。
- en: In a complex codebase, it can be challenging to guess which data types are being
    passed around, especially if you make lots of changes everywhere. With typed functions,
    you can be confident that unexpected parameters aren’t passed to functions that
    don’t yet support it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的代码库中，猜测正在传递的数据类型可能具有挑战性，尤其是如果您在各个地方做了很多更改。使用类型化函数，您可以确信不会将意外的参数传递给尚未支持它的函数。
- en: As you can see from [Example 4-2](#type_annotation), typing your code assists
    in catching unexpected bugs as you make updates to your code. For instance, if
    you start using a new LLM model, you can’t yet calculate costs for the new model.
    To support cost calculation for other LLM models, you first should update the
    pricing table, related typing, and any exception handling logic. Once done, you
    can be pretty confident that your calculation logic is now extended to work with
    new model types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [示例 4-2](#type_annotation) 所示，对代码进行类型检查有助于在更新代码时捕获意外的错误。例如，如果您开始使用新的 LLM 模型，您还不能计算新模型的成本。为了支持其他
    LLM 模型的成本计算，您首先应该更新定价表、相关类型定义和任何异常处理逻辑。一旦完成，您可以相当有信心，您的计算逻辑现在已扩展到支持新的模型类型。
- en: Using Annotated
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Annotated
- en: In [Example 4-2](#type_annotation), you can use `Annotated` instead of type
    aliases. `Annotated` is a feature of the `typing` module—​introduced in Python
    3.9—​and is similar to type aliases for reusing types, but it allows you to also
    define *metadata* for your types.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 4-2](#type_annotation) 中，您可以使用 `Annotated` 而不是类型别名。`Annotated` 是 `typing`
    模块的一个特性——自 Python 3.9 引入——它类似于类型别名，用于重用类型，但它还允许您为您的类型定义 *元数据*。
- en: The metadata doesn’t affect the type checkers but is useful for code documentation,
    analysis, and runtime inspections.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据不会影响类型检查器，但对代码文档、分析和运行时检查很有用。
- en: Since its introduction in Python 3.9, you can use `Annotated` as shown in [Example 4-3](#annotated_usage).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 3.9 介绍以来，您可以使用 `Annotated`，如[示例 4-3](#annotated_usage)所示。
- en: Example 4-3\. Using `Annotated` to declare custom types with metadata
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. 使用 `Annotated` 声明带有元数据的自定义类型
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The [FastAPI documentation](https://oreil.ly/mtGcY) recommends the use of `Annotated`
    instead of type aliases for reusability, for enhanced type checks in the code
    editor, and for catching issues during runtime.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[FastAPI 文档](https://oreil.ly/mtGcY)建议使用 `Annotated` 而不是类型别名以提高可重用性、增强代码编辑器中的类型检查以及在运行时捕获问题。'
- en: Warning
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Keep in mind that the `Annotated` feature requires a minimum of two arguments
    to work. The first should be the type passed in, and the other arguments are the
    annotation or metadata you want to attach to the type such as a description, validation
    rule, or other metadata, as shown in [Example 4-3](#annotated_usage).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`Annotated` 功能需要至少两个参数才能工作。第一个应该是传入的类型，其他参数是您想要附加到类型上的注释或元数据，例如描述、验证规则或其他元数据，如[示例
    4-3](#annotated_usage)所示。
- en: Typing, while beneficial by itself, doesn’t address all aspects of data handling
    and structuring. Thankfully, Python’s *dataclasses* from the standard library
    help to extend the typing system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化，虽然本身有益，但并不解决数据处理和结构化的所有方面。幸运的是，Python 的标准库中的 *dataclasses* 有助于扩展类型系统。
- en: Let’s see how you can leverage dataclasses to improve typing across your application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您如何利用数据类来改进应用程序中的类型化。
- en: Dataclasses
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类
- en: Dataclasses were introduced in Python 3.7 as part of the standard library. If
    you need custom data structures, you can use dataclasses to organize, store, and
    transfer data across your application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类是在 Python 3.7 作为标准库的一部分引入的。如果您需要自定义数据结构，可以使用数据类来组织、存储和跨应用程序传输数据。
- en: They can help with avoiding code “smells” such as function parameter bloat,
    where a function is hard to use because it requires more than a handful of parameters.
    Having a dataclass allows you to organize your data in a custom-defined structure
    and pass it as a single item to functions that require data from different places.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以帮助避免代码“异味”，例如函数参数膨胀，其中函数难以使用，因为它需要超过几个参数。使用数据类允许您以自定义定义的结构组织您的数据，并将其作为单个项目传递给需要来自不同位置数据的函数。
- en: You can update [Example 4-2](#type_annotation) to leverage dataclasses, as shown
    in [Example 4-4](#dataclasses).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将[示例 4-2](#type_annotation)更新为利用数据类，如[示例 4-4](#dataclasses)所示。
- en: Example 4-4\. Using dataclasses to enforce type safety
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. 使用数据类强制类型安全
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO2-1)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_implementing_type_safe_ai_services_CO2-1]'
- en: Use dataclasses to decorate the `Message` and `MessageCost` classes as special
    classes for holding data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据类将 `Message` 和 `MessageCost` 类装饰为特殊类，用于存储数据。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO2-2)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_implementing_type_safe_ai_services_CO2-2]'
- en: 'Type the `response` attribute to be either a `str` or `None`. This is similar
    to using `Optional[str]` from the `typing` module. This new syntax is available
    in Python 3.10 and later, using the new union operator: `|`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `response` 属性的类型指定为 `str` 或 `None`。这与使用 `typing` 模块中的 `Optional[str]` 相似。这种新语法在
    Python 3.10 及以后的版本中可用，使用新的联合运算符：`|`。
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO2-3)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_implementing_type_safe_ai_services_CO2-3]'
- en: Change the signature of the `calculate_usage_costs` function to use the predefined
    dataclasses. This change simplifies the function signature.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `calculate_usage_costs` 函数的签名更改为使用预定义的数据类。此更改简化了函数签名。
- en: You should aim to leverage dataclasses when your code accumulates code smells
    and becomes difficult to read.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的代码积累代码异味且难以阅读时，应旨在利用数据类。
- en: 'The primary benefit of using dataclasses in [Example 4-4](#dataclasses) was
    to group related parameters to simplify the function signature. In other scenarios,
    you may use dataclasses to:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-4](#dataclasses)中使用数据类的首要好处是将相关参数分组以简化函数签名。在其他场景中，您可以使用数据类来：
- en: Eliminate code duplication
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除代码重复
- en: Shrink down code bloat (large classes or functions)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩小代码膨胀（大类或函数）
- en: Refactor data clumps (variables that are commonly used together)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构数据块（常用在一起的变量）
- en: Prevent inadvertent data mutation
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止意外数据突变
- en: Promote data organization
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进数据组织
- en: Promote encapsulation
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进封装
- en: Enforce data validation
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制数据验证
- en: They can also be used to implement many other code enhancements.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还可以用于实现许多其他代码增强功能。
- en: 'Dataclasses are an excellent tool to improve data organization and exchange
    anywhere in your application. However, they don’t natively support several features
    when building API services:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类是改进应用程序中任何位置的数据组织和交换的出色工具。然而，当构建 API 服务时，它们在几个方面并不原生支持：
- en: Automatic data parsing
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 自动数据解析
- en: Parsing ISO datetime-formatted strings to datetime objects on assignment
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值时将 ISO 日期时间格式字符串解析为日期时间对象
- en: Field validation
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 字段验证
- en: Performing complex checks on assignment of values to fields, such as checking
    if a string is too long
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对字段值赋值执行复杂检查，例如检查字符串是否过长
- en: Serialization and deserialization
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化
- en: Converting between JSON and Pythonic data structures, especially when using
    uncommon types
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用不常见类型时，在 JSON 和 Python 数据结构之间进行转换
- en: Field filtering
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 字段过滤
- en: Removing fields of objects that are unset or contain `None` values
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 移除未设置或包含 `None` 值的对象字段
- en: None of the mentioned limitations would force you to move away from using dataclasses.
    You should use dataclasses rather than normal classes when you need to create
    data-centric classes with minimal boilerplate code, as they automatically generate
    special methods, type annotations, and support for default values, reducing potential
    errors. However, libraries such as `pydantic` support these features if you don’t
    want to implement your own custom logic (e.g., serializing datetime objects).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的任何限制都不会迫使你放弃使用数据类。当你需要创建具有最小样板代码的数据中心类时，应使用数据类而不是普通类，因为它们会自动生成特殊方法、类型注解和默认值支持，从而减少潜在的错误。然而，如
    `pydantic` 这样的库支持这些功能，如果你不想实现自己的自定义逻辑（例如，序列化 datetime 对象）。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: FastAPI also supports dataclasses through Pydantic, which implements its own
    version of dataclasses with support for the aforementioned features, enabling
    you to migrate codebases that heavily use dataclasses.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 也通过 Pydantic 支持数据类，它实现了具有上述功能的数据类的自定义版本，使你可以迁移大量使用数据类的代码库。
- en: Let’s take a look at Pydantic next and what makes it great for building GenAI
    services.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Pydantic，以及它为什么适合构建 GenAI 服务。
- en: Pydantic Models
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pydantic 模型
- en: Pydantic is the most widely used data validation library with support for custom
    validators and serializers. Pydantic’s core logic is controlled by type annotations
    in Python and can emit data in JSON format, allowing for seamless integration
    with any other tools.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 是最广泛使用的支持自定义验证器和序列化器的数据验证库。Pydantic 的核心逻辑由 Python 中的类型注解控制，并可以以 JSON
    格式输出数据，从而允许与其他工具无缝集成。
- en: In addition, the core data validation logic in Pydantic V2 has been rewritten
    in Rust to maximize its speed and performance, positioning it as one of the fastest
    data validation libraries in Python. As a result, Pydantic has heavily influenced
    FastAPI and 8,000 other packages in the Python ecosystem including Hugging Face,
    Django, and LangChain. It is a battle-tested toolkit used by major tech companies
    with 141 million downloads a month at the time of writing, making it a suitable
    candidate for adoption in your projects in replacement for dataclasses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Pydantic V2 的核心数据验证逻辑已被重写为 Rust，以最大化其速度和性能，使其成为 Python 中最快的几个数据验证库之一。因此，Pydantic
    对 FastAPI 以及 Python 生态系统中的 8,000 多个其他包（包括 Hugging Face、Django 和 LangChain）产生了重大影响。它是一个经过实战检验的工具包，由主要科技公司使用，截至撰写本文时，每月有
    1.41 亿次下载，使其成为在项目中替代数据类的合适候选。
- en: Pydantic provides an extensive toolset for data validation and processing using
    its own `BaseModel` implementation. Pydantic models share many similarities with
    dataclasses but differ in subtle areas. When you create Pydantic models, a set
    of initialization hooks are called that add data validation, serialization, and
    JSON schema generation features to the models that vanilla dataclasses lack.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 通过其自己的 `BaseModel` 实现提供了一套广泛的数据验证和处理工具集。Pydantic 模型与数据类有许多相似之处，但在细微之处有所不同。当你创建
    Pydantic 模型时，会调用一系列初始化钩子，这些钩子为模型添加数据验证、序列化和 JSON 模式生成功能，这些是纯数据类所缺乏的。
- en: FastAPI tightly integrates with Pydantic and leverages its rich feature set
    under the hood for data processing. Type checkers and code editors can also read
    Pydantic models similar to dataclasses to perform checks and provide auto-completions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 与 Pydantic 紧密集成，并在底层利用其丰富的功能集进行数据处理。类型检查器和代码编辑器也可以像数据类一样读取 Pydantic
    模型，以执行检查并提供自动完成功能。
- en: How to Use Pydantic
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用 Pydantic
- en: 'You can install Pydantic into your project using the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令将 Pydantic 安装到您的项目中：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pydantic at its core implements a `BaseModel`, which is the primary method for
    defining models. *Models* are simply classes that inherit from `BaseModel` and
    define fields as annotated attributes using type hints. Any models can then be
    used as schemas to validate your data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 在其核心实现了一个 `BaseModel`，这是定义模型的主要方法。*模型* 简单地是继承自 `BaseModel` 的类，并使用类型提示定义字段作为注解属性。任何模型都可以用作模式来验证您的数据。
- en: Aside from grouping data,^([3](ch04.html#id762)) Pydantic models let you specify
    the request and response requirements of your service endpoints and validate incoming
    untrusted data from external sources. You can also go as far as filter your LLM
    outputs using Pydantic models (and validators, which you will learn more about
    shortly).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分组数据，^([3](ch04.html#id762)) Pydantic 模型还允许您指定服务端点的请求和响应需求，并验证来自外部来源的未经验证的传入数据。您还可以使用
    Pydantic 模型（以及您将在不久后了解到的验证器）过滤 LLM 输出。
- en: You can create your own Pydantic models as shown in [Example 4-5](#pydantic_models).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建自己的 Pydantic 模型，如 [示例 4-5](#pydantic_models) 所示。
- en: Example 4-5\. Creating Pydantic models
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 创建 Pydantic 模型
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO3-1)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_implementing_type_safe_ai_services_CO3-1]'
- en: Define the `TextModelRequest` model inheriting the Pydantic `BaseModel`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 定义继承自 Pydantic `BaseModel` 的 `TextModelRequest` 模型。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO3-2)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_implementing_type_safe_ai_services_CO3-2]'
- en: Set defaults if an explicit value isn’t provided. For instance, set the `temperature`
    field to `0.0` if a value is not provided on initialization.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供显式值，则设置默认值。例如，如果初始化时未提供值，则将 `temperature` 字段设置为 `0.0`。
- en: '[Example 4-5](#pydantic_models) also shows how you can switch your dataclasses
    into Pydantic models to leverage its many features.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-5](#pydantic_models) 也展示了如何将您的数据类转换为 Pydantic 模型以利用其众多功能。'
- en: Compound Pydantic Models
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合 Pydantic 模型
- en: With Pydantic models, you can declare data *schemas*, which define data structures
    supported in the operations of your service. Additionally, you can also use inheritance
    for building compound models, as shown in [Example 4-6](#pydantic_compound_models).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pydantic 模型，您可以声明数据 *模式*，这些模式定义了服务操作中支持的数据结构。此外，您还可以使用继承来构建复合模型，如 [示例 4-6](#pydantic_compound_models)
    所示。
- en: Example 4-6\. Creating Pydantic models
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. 创建 Pydantic 模型
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO4-1)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_implementing_type_safe_ai_services_CO4-1]'
- en: Define the `ModelRequest` model inheriting the Pydantic `BaseModel`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 定义继承自 Pydantic `BaseModel` 的 `ModelRequest` 模型。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO4-2)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_implementing_type_safe_ai_services_CO4-2]'
- en: Define the `ModelResponse`. If the data for the `ip` optional field is not provided,
    then use the defaults of `None`. The `content` field can be both bytes (for image
    images) or string (for text models).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `ModelResponse`。如果未提供 `ip` 可选字段的数据，则使用默认值 `None`。`content` 字段可以是字节（用于图像图像）或字符串（用于文本模型）。
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO4-3)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_implementing_type_safe_ai_services_CO4-3]'
- en: Define the `TextModelRequest` and `ImageModelRequest` models by inheriting `ModelRequest`.
    The optional temperature field by default is set to 0.0. The `num_inference_steps`
    field for the `ImageModelRequest` model is optional and set to 200. Both of these
    models will now require the prompt string field to be provided.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承 `ModelRequest` 来定义 `TextModelRequest` 和 `ImageModelRequest` 模型。默认情况下，可选的温度字段设置为
    0.0。`ImageModelRequest` 模型的 `num_inference_steps` 字段是可选的，并设置为 200。这两个模型现在都需要提供提示字符串字段。
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO4-4)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_implementing_type_safe_ai_services_CO4-4]'
- en: Define the `ImageModelResponse` and `TextModelResponse` models by inheriting
    the `ModelResponse` model. For `TextModelResponse`, provide the count of tokens,
    and with `ImageModelResponse`, provide an image size in pixels alongside the remote
    URL for downloading the image.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承 `ModelResponse` 模型来定义 `ImageModelResponse` 和 `TextModelResponse` 模型。对于
    `TextModelResponse`，提供标记的数量；对于 `ImageModelResponse`，提供图像的像素大小以及下载图像的远程 URL。
- en: With the models shown in [Example 4-6](#pydantic_compound_models), you have
    schemas needed to define the requirements of your text and image generation endpoints.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [示例 4-6](#pydantic_compound_models) 所示的模型，您拥有了定义文本和图像生成端点需求所需的模式。
- en: Field Constraints and Validators
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段约束和验证器
- en: Aside from support for standard types, Pydantic also ships with *constrained
    types* such as `EmailStr`, `PositiveInt`, `UUID4`, `AnyHttpUrl`, and more that
    can perform data validation out of the box during model initialization for common
    data formats. The full list of Pydantic types is available in [the official documentation](https://oreil.ly/xNbXX).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持标准类型外，Pydantic 还附带了一些受限类型，如 `EmailStr`、`PositiveInt`、`UUID4`、`AnyHttpUrl`
    等，这些类型可以在模型初始化时直接进行数据验证，适用于常见的数据格式。Pydantic 的完整类型列表可在[官方文档](https://oreil.ly/xNbXX)中找到。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some constrained types such as `EmailStr` will require dependency packages to
    be installed to function but can be extremely useful for validating common data
    formats such as emails.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些受限类型，如 `EmailStr`，可能需要安装依赖包才能正常工作，但可以非常有助于验证常见的数据格式，例如电子邮件。
- en: To define more custom and complex field constraints on top of Pydantic-constrained
    types, you can use the `Field` function from Pydantic with the `Annotated` type
    to introduce validation constraints such as a valid input range.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Pydantic 限制类型之上定义更多自定义和复杂的字段约束，您可以使用 Pydantic 的 `Field` 函数与 `Annotated` 类型一起引入验证约束，例如有效的输入范围。
- en: '[Example 4-7](#pydantic_constrained_fields) replaces the standard type hints
    in [Example 4-6](#pydantic_compound_models) with constrained types and `Field`
    functions to implement stricter data requirements for your endpoints based on
    model constraints.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-7](#pydantic_constrained_fields) 使用受限类型和 `Field` 函数替换了 [示例 4-6](#pydantic_compound_models)
    中的标准类型提示，以根据模型约束为您的端点实现更严格的数据要求。'
- en: Example 4-7\. Using constrained fields
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. 使用受限字段
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO5-1)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_implementing_type_safe_ai_services_CO5-1]'
- en: Replace the `str` standard type with `Field` and `Annotated` to bound the string
    length to a range of characters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `str` 标准类型替换为 `Field` 和 `Annotated` 以将字符串长度限制在字符范围内。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO5-2)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_implementing_type_safe_ai_services_CO5-2]'
- en: Generate a new request UUID by passing a callable to `default_factory` that
    will be called to generate a new UUID.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递一个可调用的函数到 `default_factory` 来生成一个新的请求 UUID，该函数将被调用来生成新的 UUID。
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO5-3)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_implementing_type_safe_ai_services_CO5-3]'
- en: Constrain the optional `ip` field to any valid IPv4 or IPv6 address ranges.
    `None` is also a valid entry if the client’s IP can’t be determined. This optional
    field doesn’t have a default value, so if a valid IP or `None` is not provided,
    Pydantic will raise a `ValidationError`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将可选的 `ip` 字段限制为任何有效的 IPv4 或 IPv6 地址范围。如果客户端的 IP 地址无法确定，`None` 也是一个有效的条目。此可选字段没有默认值，因此如果未提供有效的
    IP 或 `None`，Pydantic 将引发 `ValidationError`。
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO5-4)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_implementing_type_safe_ai_services_CO5-4]'
- en: Constrain the `content` field to 10,000 characters or bytes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `content` 字段限制为 10,000 个字符或字节。
- en: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO5-5)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_implementing_type_safe_ai_services_CO5-5]'
- en: Constrain the temperature between `0.0` and `1.0` with a default value of `0.0`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将温度限制在 `0.0` 和 `1.0` 之间，默认值为 `0.0`。
- en: '[![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO5-6)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_implementing_type_safe_ai_services_CO5-6]'
- en: Reuse an `Annotated` constrain on the `output_size` field to positive integers
    using the `PositiveInt` constrained type. The `lte` and `gte` keywords refer to
    *less than equal* and *greater than equal*, respectively.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用 `Annotated` 限制 `output_size` 字段为正整数，使用 `PositiveInt` 限制类型。`lte` 和 `gte`
    关键字分别表示 *小于等于* 和 *大于等于*。
- en: '[![7](assets/7.png)](#co_implementing_type_safe_ai_services_CO5-8)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_implementing_type_safe_ai_services_CO5-8]'
- en: Constrain the `num_inference_steps` field with `Field` between `0` and `2000`
    and a default of `200`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Field` 函数将 `num_inference_steps` 字段限制在 `0` 到 `2000` 之间，默认值为 `200`。
- en: '[![8](assets/8.png)](#co_implementing_type_safe_ai_services_CO5-10)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![8](assets/8.png)[#co_implementing_type_safe_ai_services_CO5-10]'
- en: Constrain the optional `url` field to any valid HTTP or HTTPS URL, where the
    hostname and top-level domain (TLD) are required.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将可选的 `url` 字段限制为任何有效的 HTTP 或 HTTPS URL，其中主机名和顶级域名（TLD）是必需的。
- en: With the models defined in [Example 4-7](#pydantic_constrained_fields), you
    can now perform validation on incoming or outgoing data to match the data requirements
    you have. In such cases, FastAPI will leverage Pydantic to automatically return
    error responses when data validation checks fail during a request runtime, as
    shown in [Example 4-8](#fastapi_pydantic_validation_failure).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 [示例 4-7](#pydantic_constrained_fields) 中的模型后，你现在可以对传入或传出的数据进行验证，以匹配您所需的数据要求。在这种情况下，FastAPI
    将利用 Pydantic 在请求运行时数据验证检查失败时自动返回错误响应，如 [示例 4-8](#fastapi_pydantic_validation_failure)
    所示。
- en: Example 4-8\. FastAPI error response on data validation failure
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 数据验证失败时的 FastAPI 错误响应
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Custom Field and Model Validators
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义字段和模型验证器
- en: Another excellent feature of Pydantic for performing data validation checks
    is *custom field validators*. [Example 4-9](#field_validators) shows how both
    types of custom validators can be implemented on the `ImageModelRequest`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 进行数据验证检查的另一个优秀功能是 *自定义字段验证器*。[示例 4-9](#field_validators) 展示了如何在 `ImageModelRequest`
    上实现这两种类型的自定义验证器。
- en: Example 4-9\. Implementing custom field and model validators for `ImageModelRequest`
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. 为 `ImageModelRequest` 实现自定义字段和模型验证器
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO6-1)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO6-1)'
- en: In addition to static type checks, raise a runtime validation error if incorrect
    parameters have been passed to both the `is_square_image` and `is_valid_​infer⁠ence_step`
    functions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态类型检查外，如果向 `is_square_image` 和 `is_valid_​infer⁠ence_step` 函数传递了不正确的参数，则引发运行时验证错误。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO6-2)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO6-2)'
- en: The `tinysd` model can generate square images in certain sizes only. Asking
    for a nonsquare image size (an aspect ratio other than `1`) should raise a `ValueError`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`tinysd` 模型只能生成特定尺寸的方形图像。请求非方形图像尺寸（除 `1` 以外的纵横比）应引发 `ValueError`。'
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO6-4)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO6-4)'
- en: Raise a `ValueError` if the user asks for a large number of inference steps
    for the `tinysd` model.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户请求 `tinysd` 模型的许多推理步骤，则引发 `ValueError`。
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO6-5)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO6-5)'
- en: Create reusable and more readable validators using the annotated pattern for
    both `OutputSize` and `InferenceSteps`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `OutputSize` 和 `InferenceSteps` 的注解模式创建可重用且更易于阅读的验证器。
- en: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO6-7)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO6-7)'
- en: Attach the `OutputSize` field validator to the `output_size` field to check
    for incorrect values after the model is initialized.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `OutputSize` 字段验证器附加到 `output_size` 字段，以在模型初始化后检查不正确的值。
- en: '[![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO6-8)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO6-8)'
- en: Attach the `InferenceSteps` validator to the `ImageModelRequest` model to perform
    checks on the model field values *after* the model is initialized.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `InferenceSteps` 验证器附加到 `ImageModelRequest` 模型，以在模型初始化后对模型字段值进行检查。
- en: With custom field validators, as shown in [Example 4-9](#field_validators),
    you can now be confident that your image generation endpoints will be protected
    from incorrect configurations provided by users.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [示例 4-9](#field_validators) 所示，使用自定义字段验证器，您现在可以确信您的图像生成端点将受到用户提供的错误配置的保护。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the decorator pattern to validate model fields. Special methods
    can be associated with model fields to execute conditional data checks by employing
    the `@field_validator` or `@model_validator` decorator.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用装饰器模式来验证模型字段。可以通过使用 `@field_validator` 或 `@model_validator` 装饰器将特殊方法与模型字段关联起来，以执行条件数据检查。
- en: While `@field_validator` accesses a value of a single field to perform checks,
    the `@model_validator` decorator allows for checks that involve multiple fields.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `@field_validator` 通过访问单个字段的值来执行检查，但 `@model_validator` 装饰器允许对涉及多个字段的检查。
- en: With `after` validators, you can perform extra checks or modify the data after
    Pydantic has completed its parsing and validation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `after` 验证器，您可以在 Pydantic 完成其解析和验证后执行额外的检查或修改数据。
- en: Computed Fields
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算字段
- en: Similar to dataclasses, Pydantic also allows you to implement methods to compute
    fields derived from other fields.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据类类似，Pydantic 也允许您实现方法来计算来自其他字段派生的字段。
- en: You can use the `@computed_field` decorator to implement a computed field for
    calculating count of tokens and cost, as shown in [Example 4-10](#computed_fields).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `@computed_field` 装饰器来实现一个计算字段，用于计算令牌和成本的数量，如下所示[示例 4-10](#computed_fields)。
- en: Example 4-10\. Using computed fields to automatically count the total number
    of tokens
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. 使用计算字段自动计算令牌总数
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Computed fields are useful for encapsulating any field computation logic inside
    your Pydantic models to keep code organized. Bear in mind that computed fields
    are only accessible when you convert a Pydantic model to a dictionary using `.model_dump()`
    or via serialization when a FastAPI API handler returns a response.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 计算字段对于封装 Pydantic 模型中的任何字段计算逻辑非常有用，以保持代码整洁。请注意，计算字段仅在将 Pydantic 模型转换为字典时通过 `.model_dump()`
    或在 FastAPI API 处理程序返回响应时的序列化时才可访问。
- en: Model Export and Serialization
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型导出和序列化
- en: As Pydantic models can serialize to JSONs, the models you defined in [Example 4-7](#pydantic_constrained_fields)
    can also be dumped into (or be loaded from) JSON strings or Python dictionaries
    while maintaining any compound schemas, as shown in [Example 4-11](#model_export).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Pydantic 模型可以序列化为 JSON，因此你在[示例 4-7](#pydantic_constrained_fields)中定义的模型也可以被导出到（或从）JSON
    字符串或 Python 字典中，同时保持任何复合模式，如下所示[示例 4-11](#model_export)。
- en: Example 4-11\. Exporting and serializing the `TextModelResponse` model
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-11\. 导出和序列化 `TextModelResponse` 模型
- en: '[PRE12]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Parsing Environment Variables with Pydantic
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pydantic 解析环境变量
- en: 'Alongside the `BaseModel`, Pydantic also implements a `Base` class for parsing
    settings and secrets from files. This feature is provided in an optional Pydantic
    package called `pydantic-settings`, which you can install as a dependency:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `BaseModel`，Pydantic 还实现了一个 `Base` 类，用于从文件中解析设置和秘密。此功能由一个可选的 Pydantic 包 `pydantic-settings`
    提供，你可以将其作为依赖项安装：
- en: '[PRE13]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `BaseSettings` class provides optional Pydantic features for loading a settings
    or config class from environment variables or secret files. Using this feature,
    the settings values can be set in code or overridden by environment variables.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseSettings` 类提供了可选的 Pydantic 功能，用于从环境变量或秘密文件中加载设置或配置类。使用此功能，设置值可以在代码中设置或由环境变量覆盖。'
- en: This is useful in production where you don’t want to expose secrets inside the
    code or the container environment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，这很有用，因为你不想在代码或容器环境中暴露秘密。
- en: When you create a model inheriting from `BaseSettings`, the model initializer
    will attempt to set values of each field using provided defaults. If unsuccessful,
    the initializer will then read the values of any unset fields from the environment
    variables.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个继承自 `BaseSettings` 的模型时，模型初始化器将尝试使用提供的默认值设置每个字段的值。如果失败，初始化器将然后从环境变量中读取任何未设置字段的值。
- en: 'Given a dotenv environment file (ENV):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 dotenv 环境文件 (ENV)：
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An ENV is an environment variable file that can use a shell script syntax for
    key-value pairs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ENV 是一个环境变量文件，可以使用 shell 脚本语法来表示键值对。
- en: '[Example 4-12](#pydantic_settings) shows parsing environment variables using
    `BaseSettings` in action.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-12](#pydantic_settings) 展示了使用 `BaseSettings` 解析环境变量的实际操作。'
- en: Example 4-12\. Using Pydantic `BaseSettings` to parse environment variables
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-12\. 使用 Pydantic `BaseSettings` 解析环境变量
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO7-1)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_implementing_type_safe_ai_services_CO7-1]'
- en: Declare `AppSettings` inheriting from the `BaseSettings` class from the `pydantic_settings`
    package.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 声明从 `pydantic_settings` 包继承的 `AppSettings` 类。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO7-2)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_implementing_type_safe_ai_services_CO7-2]'
- en: Configure `AppSettings` to read environment variables from the ENV file at the
    root of a project with the `UTF-8` encoding. By default, the snake_case field
    names will map to environment variables names that are an uppercase version of
    those names. For instance, `app_secret` becomes `APP_SECRET`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `AppSettings` 配置为以 `UTF-8` 编码从项目根目录的 ENV 文件中读取环境变量。默认情况下，snake_case 字段名称将映射到环境变量名称的大写版本。例如，`app_secret`
    变为 `APP_SECRET`。
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO7-3)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_implementing_type_safe_ai_services_CO7-3]'
- en: Validate that the `DATABASE_URL` environment variable has a valid Postgres connection
    string format. If not provided, set the default value.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 `DATABASE_URL` 环境变量是否具有有效的 Postgres 连接字符串格式。如果没有提供，则设置默认值。
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO7-4)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_implementing_type_safe_ai_services_CO7-4]'
- en: Check that the `CORS_WHITELIST` environment variable has a unique list of valid
    URLs with hostname and TLDs. If not provided, set the default to a set with a
    single value of `http://localhost:3000`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`CORS_WHITELIST`环境变量是否包含具有主机名和顶级域的唯一URL列表。如果没有提供，则将默认值设置为包含单个值`http://localhost:3000`的集合。
- en: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO7-5)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO7-5)'
- en: We can check the `AppSettings` class is working by printing a dump of the model.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打印模型的转储来检查`AppSettings`类是否正常工作。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can switch environment files when using the `_env_file` argument:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`_env_file`参数时，你可以切换环境文件：
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Dataclasses or Pydantic Models in FastAPI
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FastAPI中的数据类或Pydantic模型
- en: Even though dataclasses support serialization of only the common types (e.g.,
    `int`, `str`, `list`, etc.) and won’t perform field validation at runtime, FastAPI
    can still work with both Pydantic models and Python’s dataclasses. For field validation
    and additional features, you should use Pydantic models. [Example 4-13](#dataclass_fastaspi)
    shows how dataclasses can be used in FastAPI route handlers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管dataclasses只支持常见类型的序列化（例如，`int`，`str`，`list`等）并且在运行时不会执行字段验证，但FastAPI仍然可以与Pydantic模型和Python的数据类一起工作。对于字段验证和附加功能，你应该使用Pydantic模型。[示例4-13](#dataclass_fastaspi)展示了如何在FastAPI路由处理程序中使用数据类。
- en: Example 4-13\. Using dataclasses in FastAPI
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-13\. 在FastAPI中使用数据类
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO8-1)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO8-1)'
- en: Define models for text model request and response schemas.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 定义用于文本模型请求和响应模式的模型。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO8-3)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO8-3)'
- en: Convert the handler to serve `POST` requests with a body. Then, declare the
    request body as `TextModelRequest` and the response as `TextModelResponse`. Static
    code checkers like `mypy` will read the type annotations and raise warnings if
    your controller doesn’t return the expected response model.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将处理程序转换为服务带有正文的`POST`请求。然后，声明请求正文为`TextModelRequest`，响应为`TextModelResponse`。静态代码检查器（如`mypy`）将读取类型注解，并在你的控制器未返回预期响应模型时发出警告。
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO8-5)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO8-5)'
- en: Explicitly check whether the service supports the `model` parameter provided
    in the request `body`. If not, return a bad request HTTP exception response to
    the client.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 明确检查服务是否支持请求`body`中提供的`model`参数。如果不支持，则向客户端返回一个错误的HTTP异常响应。
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO8-4)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO8-4)'
- en: FastAPI converts vanilla dataclasses to Pydantic dataclasses to serialize/deserialize
    and validate the request and response data.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI将纯数据类转换为Pydantic数据类以序列化/反序列化和验证请求和响应数据。
- en: In [Example 4-13](#dataclass_fastaspi), you have leveraged type annotations
    by refactoring the text model controller to be resilient to new changes and bad
    user input. Static type checkers can now help you catch any data-related issues
    as changes occur. In addition, FastAPI used your type annotations to validate
    request and responses alongside the auto-generation of an OpenAPI documentation
    page, as shown in [Figure 4-2](#fastapi_dataclasses_docs).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例4-13](#dataclass_fastaspi)中，你通过重构文本模型控制器以适应新的更改和不良用户输入，利用了类型注解。静态类型检查器现在可以在更改发生时帮助你捕获任何数据相关的问题。此外，FastAPI使用你的类型注解来验证请求和响应，同时自动生成一个OpenAPI文档页面，如[图4-2](#fastapi_dataclasses_docs)所示。
- en: You now see that FastAPI leverages Pydantic models under the hood for data handling
    and validation, even if you use vanilla dataclasses. FastAPI converts your vanilla
    dataclasses to Pydantic-flavored dataclasses to use its data validation features.
    This behavior is intentional because if you have projects with several pre-existing
    dataclass type annotations, you can still migrate them over without having to
    rewrite them into Pydantic models for leveraging data validation features. However,
    if you’re starting a fresh project, it is recommended to use Pydantic models directly
    in replacement for Python’s built-in dataclasses.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到，即使你使用纯数据类，FastAPI也利用Pydantic模型在底层进行数据处理和验证。FastAPI将你的纯数据类转换为Pydantic风格的数据类，以使用其数据验证功能。这种行为是有意为之的，因为如果你有包含几个预存在数据类类型注解的项目，你仍然可以迁移它们，而无需将它们重写为Pydantic模型以利用数据验证功能。然而，如果你正在启动一个全新的项目，建议直接使用Pydantic模型来替换Python的内置数据类。
- en: '![bgai 0402](assets/bgai_0402.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0402](assets/bgai_0402.png)'
- en: Figure 4-2\. Automatic generation of validation schemas using vanilla dataclasses
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 使用 vanilla dataclasses 自动生成验证模式
- en: Now let’s see how you can replace dataclasses with Pydantic in your FastAPI
    application. See [Example 4-14](#pydantic_fastapi).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在您的 FastAPI 应用程序中将 dataclasses 替换为 Pydantic。参见 [示例 4-14](#pydantic_fastapi)。
- en: Example 4-14\. Using Pydantic to model request and response schemas
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. 使用 Pydantic 模型请求和响应模式
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO9-1)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png) (#co_implementing_type_safe_ai_services_CO9-1)'
- en: Import Pydantic models for text model request and response schemas.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Pydantic 模型以用于文本模型请求和响应模式。
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO9-2)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png) (#co_implementing_type_safe_ai_services_CO9-2)'
- en: Convert the handler to serve `POST` requests with a body. Then, declare the
    request body as `TextModelRequest` and the response as `TextModelResponse`. Static
    code checkers like `mypy` will read the type annotations and raise warnings if
    your controller doesn’t return the expected response model.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将处理器转换为处理带有正文的 `POST` 请求。然后，将请求正文声明为 `TextModelRequest`，将响应声明为 `TextModelResponse`。静态代码检查器如
    `mypy` 将读取类型注解，并在您的控制器未返回预期响应模型时引发警告。
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO9-3)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png) (#co_implementing_type_safe_ai_services_CO9-3)'
- en: Explicitly check whether the service supports the `model` parameter provided
    in the request `body`. If not, return a bad request HTTP exception response to
    the client.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 明确检查服务是否支持请求 `body` 中提供的 `model` 参数。如果不支持，向客户端返回一个不良请求 HTTP 异常响应。
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO9-4)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png) (#co_implementing_type_safe_ai_services_CO9-4)'
- en: Return the `TextModelResponse` Pydantic model as per the function typing. Access
    the client’s IP address using the request object via `request.client.host`. FastAPI
    will take care of serializing your model using `.model_dump()` under the hood.
    As you also implemented the computed fields for `tokens` and `cost` properties,
    these will automatically will be included in your API response without any additional
    work.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 根据函数类型返回 `TextModelResponse` Pydantic 模型。通过 `request.client.host` 使用请求对象访问客户端的
    IP 地址。FastAPI 将在底层使用 `.model_dump()` 处理序列化您的模型。由于您还实现了 `tokens` 和 `cost` 属性的计算字段，这些字段将自动包含在您的
    API 响应中，无需任何额外工作。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As shown in [Example 4-13](#dataclass_fastaspi), if you use dataclasses instead
    of Pydantic models, FastAPI will convert them to Pydantic dataclasses to serialize/deserialize
    and validate the request and response data. However, you may not be able to leverage
    advanced features such as field constraints and computed fields with dataclasses.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [示例 4-13](#dataclass_fastaspi) 所示，如果您使用 dataclasses 而不是 Pydantic 模型，FastAPI
    将将它们转换为 Pydantic dataclasses 以进行序列化/反序列化和验证请求和响应数据。但是，您可能无法利用数据类的高级功能，如字段约束和计算字段。
- en: As you can see in [Example 4-14](#pydantic_fastapi), Pydantic can provide exceptional
    developer experience by helping in type checks, data validation, serialization,
    code editor auto-completions, and computed attributes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 [示例 4-14](#pydantic_fastapi) 中所见，Pydantic 可以通过帮助进行类型检查、数据验证、序列化、代码编辑器自动完成和计算属性，提供卓越的开发者体验。
- en: FastAPI can also use your Pydantic models to auto-generate an OpenAPI specification
    and documentation page so that you can manually test your endpoints seamlessly.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 还可以使用您的 Pydantic 模型自动生成 OpenAPI 规范和文档页面，以便您可以无缝地手动测试您的端点。
- en: Once you start the server, you should see an updated documentation page with
    the new Pydantic models and the updated constrained fields, as shown in [Figure 4-3](#fastapi_pydnatic_models).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动服务器，您应该看到一个带有新 Pydantic 模型和更新约束字段的更新文档页面，如图 4-3 所示。[图 4-3](#fastapi_pydnatic_models)。
- en: '![bgai 0403](assets/bgai_0403.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0403](assets/bgai_0403.png)'
- en: Figure 4-3\. Automatic generation of FastAPI docs using Pydantic models
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 使用 Pydantic 模型自动生成 FastAPI 文档
- en: If you send a request to the `/generate/text` endpoint, you should now see the
    prepopulated fields via the `TextModelResponse` Pydantic model, as shown in [Example 4-15](#fastapi_pydnatic_docs).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向 `/generate/text` 端点发送请求，您现在应该通过 `TextModelResponse` Pydantic 模型看到预填充的字段，如
    [示例 4-15](#fastapi_pydnatic_docs) 所示。
- en: Example 4-15\. Automatic population of the response fields via the `TextModelResponse`
    Pydantic model
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. 通过 `TextModelResponse` Pydantic 模型自动填充响应字段
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Pydantic model features I covered in this chapter represent just a fraction
    of the tools at your disposal for constructing GenAI services. You should now
    feel more confident in leveraging Pydantic to annotate your own services to improve
    its reliability and your own developer experience.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我介绍的 Pydantic 模型功能只是你可用于构建 GenAI 服务的工具中的一小部分。现在你应该更有信心利用 Pydantic 注释你的服务，以提高其可靠性和你的开发体验。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the importance of creating fully typed services
    for GenAI models. You now understand how to implement type safety with standard
    and constrained types, how to use Pydantic models for data validation, and how
    to implement your own custom data validators across your GenAI service. You also
    discovered strategies for validating request and response content and managing
    application settings with Pydantic to prevent bugs and to improve your development
    experience. Overall, by following along with the practical examples, you learned
    how to implement a robust, less error-prone GenAI service.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了为 GenAI 模型创建完全类型化服务的重要性。你现在理解了如何使用标准类型和约束类型实现类型安全，如何使用 Pydantic 模型进行数据验证，以及如何在你的
    GenAI 服务中实现自定义数据验证器。你还发现了验证请求和响应内容以及使用 Pydantic 管理应用程序设置的策略，以防止错误并提高你的开发体验。总的来说，通过跟随实际示例，你学习了如何实现一个健壮、错误更少的
    GenAI 服务。
- en: The next chapter covers asynchronous programming in AI workloads, discussing
    performance and parallel operations. You will learn more about I/O-bound and CPU-bound
    tasks and understand the role and limitations of FastAPI’s background tasks with
    concurrent workflows.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 AI 工作负载中的异步编程，讨论性能和并行操作。你将了解更多关于 I/O 密集型和 CPU 密集型任务，以及 FastAPI 的后台任务在并发工作流程中的作用和限制。
- en: ^([1](ch04.html#id749-marker)) A [`Literal` type](https://oreil.ly/69Pmn) can
    be used to indicate to type checkers that the annotated object has a value equivalent
    to one of the provided literals.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#id749-marker)) 一个 [文本类型](https://oreil.ly/69Pmn) 可以用来向类型检查器指示，被注释的对象的值等同于提供的文本之一。
- en: ^([2](ch04.html#id750-marker)) OpenAI’s `tiktoken` uses the [*Byte-Pair Encoding*
    (BPE) algorithm](https://oreil.ly/l67GS) to tokenize text. Different models use
    different encodings to convert text into tokens.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#id750-marker)) OpenAI 的 `tiktoken` 使用 [*字节对编码 (BPE)* 算法](https://oreil.ly/l67GS)
    来分词文本。不同的模型使用不同的编码将文本转换为标记。
- en: ^([3](ch04.html#id762-marker)) Structs in C-like languages and dataclasses in
    Python can also be used to group and pass data around.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.html#id762-marker)) 类 C 语言中的结构体和 Python 中的数据类也可以用来分组和传递数据。
