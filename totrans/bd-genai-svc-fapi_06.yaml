- en: Capitolo 4\. Implementazione di servizi AI sicuri dal punto di vista tipologico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Questo lavoro è stato tradotto utilizzando l''AI. Siamo lieti di ricevere il
    tuo feedback e i tuoi commenti: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Quando lavori con codebase complesse che vengono modificate continuamente da
    più collaboratori e quando interagisci con servizi esterni come API o database,
    vorrai seguire le migliori pratiche come la sicurezza dei tipi nella creazione
    delle tue applicazioni.
  prefs: []
  type: TYPE_NORMAL
- en: Questo capitolo si concentra sull'importanza della sicurezza dei tipi nella
    creazione di servizi backend e API. Imparerai come implementare la sicurezza dei
    tipi utilizzando le classi di dati integrate in Python e i modelli di dati Pydantic,
    e vedrai le loro somiglianze e differenze. Inoltre, esplorerai come utilizzare
    i modelli di dati Pydantic con i validatori personalizzati per proteggerti da
    input errati da parte dell'utente o da dati non corretti, e imparerai come utilizzare
    le Impostazioni di Python per il caricamento e la convalida delle variabili d'ambiente.
    Infine, scoprirai le strategie per affrontare le modifiche allo schema nei sistemi
    esterni e per gestire la complessità in codebase in evoluzione per evitare bug.
  prefs: []
  type: TYPE_NORMAL
- en: Alla fine di questo capitolo, avrai un servizio GenAI completamente tipizzato
    e meno soggetto a bug quando si tratta di modifiche, input errati dell'utente
    erisposte incoerenti del modello.
  prefs: []
  type: TYPE_NORMAL
- en: Per seguirci, puoi trovare il codice iniziale di questo capitolo passando al
    [ramo`ch04-start`](https://github.com/Ali-Parandeh/building-generative-ai-services/tree/ch04-start)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Introduzione alla sicurezza di tipo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Tipi* nella programmazione specifica quali valori possono essere assegnati
    alle variabili e le operazioni che possono essere eseguite su tali variabili.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, i tipi più comuni sono i seguenti:'
  prefs: []
  type: TYPE_NORMAL
- en: Intero
  prefs: []
  type: TYPE_NORMAL
- en: Rappresentare numeri interi
  prefs: []
  type: TYPE_NORMAL
- en: Galleggiante
  prefs: []
  type: TYPE_NORMAL
- en: Rappresentare numeri con parti frazionarie
  prefs: []
  type: TYPE_NORMAL
- en: Stringa
  prefs: []
  type: TYPE_NORMAL
- en: Rappresentare sequenze di caratteri
  prefs: []
  type: TYPE_NORMAL
- en: Booleano
  prefs: []
  type: TYPE_NORMAL
- en: Rappresentare i valori di `True` o `False`
  prefs: []
  type: TYPE_NORMAL
- en: Suggerimento
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Puoi utilizzare il pacchetto `typing` per importare tipi speciali, come hai
    visto in altri esempi di codice del [Capitolo 3](ch03.html#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: La*sicurezza dei tipi* è una pratica di programmazione che garantisce che alle
    variabili vengano assegnati solo valori compatibili con i loro tipi definiti.
    In Python, puoi usare i tipi per controllare l'uso delle variabili in una base
    di codice, in particolare se la base di codice cresce in complessità e dimensioni.
    Gli strumenti di controllo dei tipi (ad esempio, `mypy`) possono quindi usare
    questi tipi per individuare assegnazioni o operazioni errate sulle variabili.
  prefs: []
  type: TYPE_NORMAL
- en: Puoi imporre vincoli di tipo dichiarando variabili e funzioni completamente
    tipizzate, come mostrato nell'[Esempio 4-1](#type_safe_code).
  prefs: []
  type: TYPE_NORMAL
- en: Esempio 4-1\. Usare i tipi in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Anche gli editor di codice e gli IDE (ad esempio VS Code o JetBrains PyCharm)
    possono utilizzare estensioni di controllo del tipo, come mostrato nella [Figura
    4-1](#type_safety), per segnalare le violazioni del tipo durante la scrittura
    del codice.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0401](assets/bgai_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figura 4-1\. Cattura degli errori di tipo nell'estensione VS Code `mypy`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In una base di codice complessa, è facile perdere di vista le variabili, i loro
    stati e gli schemi in continua evoluzione. Ad esempio, potresti dimenticare che
    la funzione `timestamp_to_isostring` accetta numeri come input e passare erroneamente
    un timestamp come stringa, come mostrato nella [Figura 4-1](#type_safety).
  prefs: []
  type: TYPE_NORMAL
- en: I tipi sono estremamente utili anche quando i manutentori dei pacchetti o i
    fornitori esterni di API aggiornano il loro codice. I controllori di tipo possono
    immediatamente emettere degli avvisi per aiutarti ad affrontare tali modifiche
    durante lo sviluppo. In questo modo, sarai immediatamente indirizzato alle fonti
    di potenziali errori senza dover eseguire il tuo codice e testare ogni endpoint.
    Di conseguenza, le pratiche di sicurezza dei tipi possono farti risparmiare tempo
    con il rilevamento precoce e impedirti di avere a che fare con errori di runtime
    più oscuri.
  prefs: []
  type: TYPE_NORMAL
- en: Infine, puoi fare un ulteriore passo avanti per impostare controlli automatici
    del tipo nella tua pipeline di distribuzione, per evitare di spingere le modifiche
    di rottura negli ambienti di produzione.
  prefs: []
  type: TYPE_NORMAL
- en: 'La sicurezza dei tipi all''inizio sembra un peso: devi digitare esplicitamente
    ogni funzione che scrivi, il che può essere una seccatura e rallentare le fasi
    iniziali dello sviluppo.'
  prefs: []
  type: TYPE_NORMAL
- en: Alcune persone saltano la digitazione del codice per una prototipazione rapida
    e per scrivere meno codice boilerplate. L'approccio è più flessibile e più facile
    da usare, e Python è abbastanza potente per dedurre i tipi semplici. Inoltre,
    alcuni schemi di codice (come le funzioni con argomenti multitipo) possono essere
    così dinamici che è più facile evitare di implementare una sicurezza di tipo rigorosa
    quando si sta ancora sperimentando. Tuttavia, questo ti farà risparmiare ore di
    sviluppo perché inevitabilmente i tuoi servizi diventano complessi e cambiano
    continuamente.
  prefs: []
  type: TYPE_NORMAL
- en: La buona notizia è che alcuni di questi tipi possono essere generati automaticamente
    utilizzando strumenti come Prisma, quando si lavora con i database, o generatori
    di client, quando si lavora con API esterne. Per quanto riguarda le API esterne,
    spesso è possibile trovare SDK ufficiali contenenti client con suggerimenti di
    tipo (cioè client completamente tipizzati) che specificano i tipi di input e output
    previsti per l'utilizzo dell'API. In caso contrario, puoi ispezionare l'API per
    creare il tuo client completamente tipizzato. Tratterò Prisma e i generatori di
    client API in modo più dettagliato più avanti nel libro.
  prefs: []
  type: TYPE_NORMAL
- en: Quando non usi i tipi, ti esponi a ogni sorta di bug ed errori che potrebbero
    verificarsi perché altri sviluppatori hanno aggiornato inaspettatamente le tabelle
    del database o gli schemi API con cui il tuo servizio interagisce. In altri casi,
    potresti aggiornare una tabella del database - ad esempio, eliminando una colonna
    - e dimenticare di aggiornare il codice che interagisce con quella tabella.
  prefs: []
  type: TYPE_NORMAL
- en: Senza i tipi, potresti non accorgerti mai delle modifiche dovute agli aggiornamenti.
    Questo può essere difficile da debuggare perché gli errori a valle non gestiti
    potrebbero non individuare il componente rotto o i problemi generali legati a
    casi limite non gestiti dal tuo team di sviluppo. Di conseguenza, ciò che avrebbe
    potuto richiedere un minuto per essere risolto può durare mezza giornata o anche
    di più.
  prefs: []
  type: TYPE_NORMAL
- en: Puoi sempre evitare qualche disastro in produzione con test approfonditi, ma
    è molto più facile evitare problemi di integrazione e affidabilità se inizi a
    usare i tipi fin dall'inizio.
  prefs: []
  type: TYPE_NORMAL
- en: Sviluppare buone abitudini di programmazione
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Se in passato non hai digitato il tuo codice, non è mai troppo tardi per iniziare
    a prendere l'abitudine di digitare tutte le variabili, i parametri delle funzioni
    e i tipi di ritorno.
  prefs: []
  type: TYPE_NORMAL
- en: L'uso dei tipi renderà il tuo codice più leggibile, ti aiuterà a individuare
    tempestivamente i bug e ti farà risparmiare molto tempo quando dovrai rivisitare
    codebase complesse per capire rapidamente come scorrono i dati.
  prefs: []
  type: TYPE_NORMAL
- en: Implementare la sicurezza di tipo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Da Python 3.5 puoi dichiarare esplicitamente i tipi di variabili, parametri
    di funzioni e valori di ritorno. La sintassi che ti permette di dichiarare questi
    tipi è l'*annotazione del tipo*.
  prefs: []
  type: TYPE_NORMAL
- en: Annotazioni sul tipo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Le annotazioni sui tipi non influiscono sul comportamento runtime dell'applicazione,
    ma aiutano a individuare gli errori di tipo, in particolare nelle applicazioni
    complesse e di grandi dimensioni in cui più persone lavorano insieme. Gli strumenti
    per il controllo statico dei tipi, come `mypy`, `pyright`, o `pyre`, insieme agli
    editor di codice, possono verificare che i tipi di dati memorizzati e restituiti
    dalle funzioni corrispondano ai tipi previsti.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nelle applicazioni Python, le annotazioni di tipo vengono utilizzate per:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Supporto per il completamento automatico dell''editor di codice*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I*controlli statici del tipo* utilizzano strumenti come `mypy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FastAPI sfrutta anche i suggerimenti sui tipi per:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Definire i requisiti del gestore*, compresi i parametri del percorso e della
    query, i corpi, le intestazioni, le dipendenze, ecc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Convertire i dati* ogni volta che è necessario'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Convalidare i dati* provenienti dalle richieste in arrivo, dai database e
    dai servizi esterni.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Aggiornare automaticamente la specifica OpenAPI* che alimenta la pagina di
    documentazione generata'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Puoi installare `loguru` utilizzando `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2] # utils.py  from typing import Literal, TypeAlias from loguru import
    logger import tiktoken  SupportedModels: TypeAlias = Literal["gpt-3.5", "gpt-4"]
    PriceTable: TypeAlias = dict[SupportedModels, float] ![1](assets/1.png) ![2](assets/2.png)
    price_table: PriceTable = {"gpt-3.5": 0.0030, "gpt-4": 0.0200} ![3](assets/3.png)  def
    count_tokens(text: str | None) -> int: ![4](assets/4.png)     if text is None:         logger.warning("Response
    is None. Assuming 0 tokens used")         return 0 ![5](assets/5.png)     enc
    = tiktoken.encoding_for_model("gpt-4o")     return len(enc.encode(text)) ![6](assets/6.png)  def
    calculate_usage_costs(     prompt: str,     response: str | None,     model: SupportedModels,
    ) -> tuple[float, float, float]: ![7](assets/7.png)     if model not in price_table:         #
    raise at runtime - in case someone ignores type errors         raise ValueError(f"Cost
    calculation is not supported for {model} model.") ![8](assets/8.png)     price
    = price_table[model] ![9](assets/9.png)     req_costs = price * count_tokens(prompt)
    / 1000     res_costs = price * count_tokens(response) / 1000 ![10](assets/10.png)     total_costs
    = req_costs + res_costs     return req_costs, res_costs, total_costs ![11](assets/11.png)
    [PRE3]`  [PRE4] from typing import Annotated, Literal  SupportedModels = Annotated[     Literal["gpt-3.5-turbo",
    "gpt-4o"], "Supported text models" ] PriceTableType = Annotated[     dict[SupportedModels,
    float], "Supported model pricing table" ]  prices: PriceTableType = {     "gpt-4o":
    0.000638,     # error: Dict entry 1 has incompatible type "Literal[''gpt4-o'']"
    [dict-item]     "gpt4-o": 0.000638,     # error: Dict entry 2 has incompatible
    type "Literal[''gpt-4'']" [dict-item]     "gpt-4": 0.000638, } [PRE5] # utils.py  from
    dataclasses import dataclass from typing import Literal, TypeAlias from utils
    import count_tokens  SupportedModels: TypeAlias = Literal["gpt-3.5", "gpt-4"]
    PriceTable: TypeAlias = dict[SupportedModels, float] prices: PriceTable = {"gpt-3.5":
    0.0030, "gpt-4": 0.0200}  @dataclass ![1](assets/1.png) class Message:     prompt:
    str     response: str | None ![2](assets/2.png)     model: SupportedModels  @dataclass
    class MessageCostReport:     req_costs: float     res_costs: float     total_costs:
    float  # Define count_tokens function as normal ...  def calculate_usage_costs(message:
    Message) -> MessageCostReport: ![3](assets/3.png)     if message.model not in
    prices :         # raise at runtime - in case someone ignores type errors         raise
    ValueError(             f"Cost calculation is not supported for {message.model}
    model."         )     price = prices[message.model]     req_costs = price * count_tokens(message.prompt)
    / 1000     res_costs = price * count_tokens(message.response) / 1000     total_costs
    = req_costs + res_costs     return MessageCostReport(         req_costs=req_costs,
    res_costs=res_costs, total_costs=total_costs     ) [PRE6]`  [PRE7][PRE8][PRE9]
    $ pip install pydantic [PRE10]`Pydantic implementa un `BaseModel`, che è il metodo
    principale per definire i modelli.*I modelli* sono semplicemente classi che ereditano
    da `BaseModel` e definiscono i campi come attributi annotati utilizzando i suggerimenti
    di tipo. I modelli possono essere utilizzati come schemi per convalidare i dati.    Oltre
    a raggruppare i dati,^([3](ch04.html#id762)) i modelli Pydantic ti permettono
    di specificare i requisiti di richiesta e risposta dei tuoi endpoint di servizio
    e di convalidare i dati non attendibili in arrivo da fonti esterne. Puoi anche
    arrivare a filtrare i tuoi output LLM utilizzando i modelli Pydantic (e i validatori,
    che imparerai a conoscere meglio tra poco).    Puoi creare i tuoi modelli Pydantic
    come mostrato nell''[Esempio 4-5](#pydantic_models).    ##### Esempio 4-5\. Creare
    modelli Pydantic    [PRE11]    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO3-1)      Definisci
    il modello `TextModelRequest` ereditando il modello Pydantic `BaseModel`.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO3-2)      Imposta
    i valori predefiniti se non viene fornito un valore esplicito. Per esempio, imposta
    il campo `temperature` a `0.0` se non viene fornito un valore all''inizializzazione.      L[''esempio
    4-5](#pydantic_models) mostra anche come puoi trasformare le tue classi di dati
    in modelli Pydantic per sfruttare le sue numerose funzionalità.[PRE12][PRE13][PRE14]
    ## Modelli pidantici composti    Con i modelli Pydantic puoi dichiarare *schemi
    di* dati, che definiscono le strutture di dati supportate nelle operazioni del
    tuo servizio. Inoltre, puoi anche utilizzare l''ereditarietà per costruire modelli
    composti, come mostrato nell''[Esempio 4-6](#pydantic_compound_models).    #####
    Esempio 4-6\. Creazione di modelli Pydantic    [PRE15]    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO4-1)      Definisci
    il modello `ModelRequest` ereditando il modello Pydantic `BaseModel`.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO4-2)      Definisci
    il campo `ModelResponse`. Se i dati per il campo opzionale `ip` non sono forniti,
    utilizza i valori predefiniti di `None`. Il campo `content` può essere sia byte
    (per le immagini) che stringa (per i modelli di testo).      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO4-3)      Definisci
    i modelli `TextModelRequest` e `ImageModelRequest` ereditando`ModelRequest`. Il
    campo opzionale della temperatura è impostato di default a 0.0\. Il campo `num_inference_steps`
    per il modello `ImageModelRequest` è opzionale e impostato a 200\. Entrambi i
    modelli richiedono ora l''inserimento del campo prompt string.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO4-4)      Definisci
    i modelli `ImageModelResponse` e `TextModelResponse` ereditando il modello `ModelResponse`.
    Per `TextModelResponse`, fornisci il conteggio dei token e per `ImageModelResponse`,
    fornisci le dimensioni dell''immagine in pixel insieme all''URL remoto per scaricare
    l''immagine.      Con i modelli mostrati nell''[Esempio 4-6](#pydantic_compound_models),
    hai gli schemi necessari per definire i requisiti dei tuoi endpoint di generazione
    di testo e immagini.    ## Vincoli e validatori di campo    Oltre al supporto
    per i tipi standard, Pydantic offre anche *tipi vincolati* come `EmailStr`, `PositiveInt`,
    `UUID4`, `AnyHttpUrl` e altri che possono eseguire la convalida dei dati durante
    l''inizializzazione del modello per i formati di dati più comuni. L''elenco completo
    dei tipi di Pydantic è disponibile nella [documentazione ufficiale](https://oreil.ly/xNbXX).    ######
    Nota    Alcuni tipi vincolati come `EmailStr` richiedono l''installazione di pacchetti
    di dipendenza per funzionare, ma possono essere estremamente utili per convalidare
    formati di dati comuni come le e-mail.    Per definire vincoli di campo più complessi
    e personalizzati in aggiunta ai tipi vincolati da Pydantic, puoi utilizzare la
    funzione `Field` di Pydantic con il tipo `Annotated` per introdurre vincoli di
    validazione come un intervallo di input valido.    L[''Esempio 4-7](#pydantic_constrained_fields)
    sostituisce i suggerimenti di tipo standard dell''[Esempio 4-6](#pydantic_compound_models)
    con tipi vincolati e funzioni di `Field` per implementare requisiti di dati più
    severi per i tuoi endpoint basati sui vincoli del modello.    ##### Esempio 4-7\.
    Utilizzo di campi vincolati    [PRE16]    [![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO5-1)      Sostituisci
    il tipo standard `str` con `Field` e `Annotated` per delimitare la lunghezza della
    stringa a un intervallo di caratteri.      [![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO5-2)      Genera
    un nuovo UUID della richiesta passando un callable a `default_factory` che verrà
    chiamato per generare un nuovo UUID.      [![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO5-3)      Vincola
    il campo opzionale `ip` a qualsiasi intervallo di indirizzi IPv4 o IPv6 valido.
    Anche`None` è una voce valida se non è possibile determinare l''IP del client.
    Questo campo opzionale non ha un valore predefinito, quindi se non viene fornito
    un IP valido o `None`, Pydantic solleverà un `ValidationError`.      [![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO5-4)      Limita
    il campo `content` a 10.000 caratteri o byte.      [![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO5-5)      Vincola
    la temperatura tra `0.0` e `1.0` con un valore predefinito di `0.0`.      [![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO5-6)      Riutilizza
    un vincolo `Annotated` sul campo `output_size` a numeri interi positivi utilizzando
    il tipo vincolato `PositiveInt`. Le parole chiave `lte` e `gte` si riferiscono
    rispettivamente a *meno di uguale* e *maggiore di uguale*.      [![7](assets/7.png)](#co_implementing_type_safe_ai_services_CO5-8)      Vincola
    il campo `num_inference_steps` con `Field` tra `0` e `2000` e un valore predefinito
    di `200`.      [![8](assets/8.png)](#co_implementing_type_safe_ai_services_CO5-10)      Vincola
    il campo opzionale `url` a qualsiasi URL HTTP o HTTPS valido, dove il nome dell''host
    e il dominio di primo livello (TLD) sono obbligatori.      Con i modelli definiti
    nell''[Esempio 4-7](#pydantic_constrained_fields), ora puoi eseguire la convalida
    dei dati in entrata o in uscita per soddisfare i requisiti di dati che hai. In
    questi casi, FastAPI sfrutterà Pydantic per restituire automaticamente le risposte
    di errore quando i controlli di convalida dei dati falliscono durante il runtime
    di una richiesta, come mostrato nell''[Esempio 4-8](#fastapi_pydantic_validation_failure).    #####
    Esempio 4-8\. Risposta di errore di FastAPI in caso di mancata convalida dei dati    [PRE17][PRE18][PRE19]``py[PRE20]py`
    `"type"`: `"literal_error"`, [PRE21]`py `"loc"`: `[` [PRE22] `"body"`, [PRE23][PRE24]``py[PRE25]``
    `"msg"`: `"Input should be ''tinyllama'' or ''gemma2b''"`, [PRE26]`` `"input"`:
    `"gpt-4o"`, [PRE27]` `"ctx"`: `{` [PRE28] `"expected"`: `"''tinyllama'' or ''gemma2b''"`
    [PRE29]`py [PRE30]py`` [PRE31]py[PRE32][PRE33][PRE34][PRE35]py[PRE36]py` [PRE37]`py``
    [PRE38]`py[PRE39]   [PRE40]` [PRE41] [PRE42]`py [PRE43]py[PRE44]py[PRE45]`'
  prefs: []
  type: TYPE_NORMAL
