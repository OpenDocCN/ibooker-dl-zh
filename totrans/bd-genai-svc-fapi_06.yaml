- en: Chapter 4\. Implementing Type-Safe AI Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with complex codebases that continuously change by multiple contributors
    and when interacting with external services such as APIs or databases, you will
    want to follow best practices such as type safety in building your applications.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on the importance of type safety when building backend
    services and APIs. You will learn how to implement type safety using Python’s
    built-in dataclasses and then Pydantic data models, and you will see their similarities
    and differences. In addition, you will explore how to use Pydantic data models
    with custom validators to protect against bad user input or incorrect data, and
    you will learn how to use Pydantic Settings for loading and validating environment
    variables. Finally, you will discover strategies for dealing with schema changes
    in external systems and managing complexity in evolving codebases to prevent bugs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a fully typed GenAI service that is
    less prone to bugs when dealing with changes, bad user inputs, and inconsistent
    model responses.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, you can find the starting code for this chapter by switching
    to the [`ch04-start` branch](https://github.com/Ali-Parandeh/building-generative-ai-services/tree/ch04-start).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Type Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Types* in programming specify what values can be assigned to variables and
    operations that can be performed on those variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, common types include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integer
  prefs: []
  type: TYPE_NORMAL
- en: Representing whole numbers
  prefs: []
  type: TYPE_NORMAL
- en: Float
  prefs: []
  type: TYPE_NORMAL
- en: Representing numbers with fractional parts
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: Representing sequences of characters
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs: []
  type: TYPE_NORMAL
- en: Representing `True` or `False` values
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use the `typing` package to import special types as you saw in other
    code examples in [Chapter 3](ch03.html#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: '*Type safety* is a programming practice that ensures variables are only assigned
    values compatible with their defined types. In Python, you can use types to check
    the usage of variables across a codebase, in particular if the codebase grows
    in complexity and size. Type checking tools (e.g., `mypy`) can then use these
    types to catch incorrect variable assignments or operations.'
  prefs: []
  type: TYPE_NORMAL
- en: You can enforce type constraints by declaring fully typed variables and functions
    as shown in [Example 4-1](#type_safe_code).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Using types in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code editors and IDEs (e.g., VS Code or JetBrains PyCharm) can also use type
    checking extensions, as shown in [Figure 4-1](#type_safety), to raise warnings
    on type violations as you write code.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0401](assets/bgai_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Catching type errors in VS Code `mypy` extension
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In a complex codebase, it is easy to lose track of variables, their states,
    and constantly changing schemas. For example, you might forget that the `timestamp_to_isostring`
    function accepts numbers as input and mistakenly pass a timestamp as a string,
    as shown in [Figure 4-1](#type_safety).
  prefs: []
  type: TYPE_NORMAL
- en: Types are also extremely useful when package maintainers or external API providers
    update their code. Type checkers can immediately raise warnings to help you address
    such changes during development. This way, you will be immediately directed to
    sources of potential errors without having to run your code and test every endpoint.
    As a result, type safety practices can save you time with early detection and
    prevent you from dealing with more obscure runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can go one step further to set up automatic type checks in your
    deployment pipeline to prevent pushing breaking changes to production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety at first seems like a burden. You have to explicitly type each and
    every function you write, which can be a hassle and slow you down in the initial
    phases of development.
  prefs: []
  type: TYPE_NORMAL
- en: Some people skip typing their code for rapid prototyping and to write less boilerplate
    code. The approach is more flexible and easier to use, and Python is powerful
    enough to infer simple types. Also, some code patterns (such as functions with
    multitype arguments) can be so dynamic that it is easier to avoid implementing
    strict type safety when still experimenting. However, it will come to save you
    hours of development as inevitably your services become complex and continuously
    change.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is some of these types can be auto-generated using tools such
    as Prisma, when working with databases, or client generators, when working with
    external APIs. For external APIs, you can often find official SDKs containing
    clients with type hints (i.e., fully typed client) specifying expected types of
    inputs and outputs for using the API. If not, you can inspect the API to create
    your own fully typed client. I will cover Prisma and API client generators in
    more detail later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: When you don’t use types, you open yourself to all sorts of bugs and errors
    that might occur because other developers unexpectedly updated the database tables
    or API schemas that your service interacts with. In other cases, you may update
    a database table—drop a column for instance—and forget to update the code interacting
    with that table.
  prefs: []
  type: TYPE_NORMAL
- en: Without types, you may never notice breaking changes due to updates. This can
    be challenging to debug as unhandled downstream errors might not pinpoint the
    broken component or general issues around unhandled edge cases from your own development
    team. As a result, what might have taken a minute to resolve can last half a day
    or even longer.
  prefs: []
  type: TYPE_NORMAL
- en: You can always prevent a few disasters in production with extensive testing.
    However, it’s much easier to avoid integration and reliability issues if you start
    using types from the start.
  prefs: []
  type: TYPE_NORMAL
- en: Developing good programming habits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven’t been typing your code in the past, it is never too late to start
    getting into the habit of typing all your variables, function parameters, and
    return types.
  prefs: []
  type: TYPE_NORMAL
- en: Using types will make your code more readable, help you catch bugs early on,
    and save you a lot of time when you revisit complex codebases to quickly understand
    how data flows.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Type Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Python 3.5, you can explicitly declare types for your variables, function
    parameters, and return values. The syntax that allows you to declare these types
    is *type annotation*.
  prefs: []
  type: TYPE_NORMAL
- en: Type Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type annotations don’t affect the runtime behavior of your application. They
    help catch type errors, particularly in complex larger applications where multiple
    people are working together. Tools for static type checking, such as `mypy`, `pyright`,
    or `pyre`, alongside code editors, can validate that the data types stored and
    returned from functions, match the expected types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python applications, type annotations are used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code editor auto-complete support*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Static type checks* using tools like `mypy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FastAPI also leverages types hints to:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Define handler requirements* including path and query parameters, bodies,
    headers, and dependencies, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Convert data* whenever needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Validate data* from incoming requests, databases, and external services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Auto-update the OpenAPI specification* that powers the generated documentation
    page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can install `loguru` using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 4-2](#type_annotation) shows several examples of type annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. Using type annotation to reduce future bugs as code changes occur
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `Literal` from Python’s `typing` module included in its standard library.^([1](ch04.html#id749))
    Declare literals `gpt-3.5` and `gpt-4` and assign them to `SupportedModel` *type
    alias*. The `PriceTable` is also a simple type alias that defines a dictionary
    with keys limited to `SupportedModel` literals and with values of type `float`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Mark type aliases with `TypeAlias` to be explicit that they’re not a normal
    variable assignment. Types are also normally declared using CamelCase as a best
    practice to differentiate them from variables. You can now reuse the `PriceTable`
    type alias later.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the pricing table dictionary and assign the `PriceTable` type to explicitly
    limit what keys and values are allowed for in the pricing table dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Type the `count_tokens` function to accept strings or `None` types and always
    return an integer. Implement exception handling in case someone tries to pass
    in anything other than strings or `None` types. When defining `count_tokens`,
    code editor and static checkers will raise warnings if `count_tokens` doesn’t
    return an integer even if it receives a `None` and raises errors if any other
    types other than string or `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Return `0` even if a `None` type is passed to ensure you comply with function
    typing.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Tokenize the given text using OpenAI’s `tiktoken` library using the same encoding
    that was used for the `gpt-4o` model.^([2](ch04.html#id750))
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_implementing_type_safe_ai_services_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Type the `calculate_usage_costs` function to always take a text prompt and the
    prespecified literals for `model` parameter. Pass the `price_table` with the previously
    declared `PriceTable` type alias. The function should return a tuple of three
    floats.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_implementing_type_safe_ai_services_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Type checkers will raise warnings when an unexpected model literal is passed
    in, but you should always check for incorrect inputs to functions and raise errors
    at runtime if an unexpected model parameter is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_implementing_type_safe_ai_services_CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Grab the correct price from the pricing table. No need to worry about exception
    handling, as there is no chance a `KeyError` can be raised here if an unsupported
    model is passed in. If the pricing table is not updated, the function will raise
    a `ValueError` early on. Catch the `KeyError`, issue a warning that pricing table
    needs updating and then reraise the `KeyError` so that full details of the issue
    are still printed to the terminal, as you can’t make assumptions about prices.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_implementing_type_safe_ai_services_CO1-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `count_tokens` function to calculate the LLM request and response costs.
    If for any reason the LLM doesn’t return a response (returns `None`), the `count_tokens`
    can handle it and assume zero tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_implementing_type_safe_ai_services_CO1-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Return a tuple of three floats as per function typing.
  prefs: []
  type: TYPE_NORMAL
- en: In a complex codebase, it can be challenging to guess which data types are being
    passed around, especially if you make lots of changes everywhere. With typed functions,
    you can be confident that unexpected parameters aren’t passed to functions that
    don’t yet support it.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from [Example 4-2](#type_annotation), typing your code assists
    in catching unexpected bugs as you make updates to your code. For instance, if
    you start using a new LLM model, you can’t yet calculate costs for the new model.
    To support cost calculation for other LLM models, you first should update the
    pricing table, related typing, and any exception handling logic. Once done, you
    can be pretty confident that your calculation logic is now extended to work with
    new model types.
  prefs: []
  type: TYPE_NORMAL
- en: Using Annotated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Example 4-2](#type_annotation), you can use `Annotated` instead of type
    aliases. `Annotated` is a feature of the `typing` module—​introduced in Python
    3.9—​and is similar to type aliases for reusing types, but it allows you to also
    define *metadata* for your types.
  prefs: []
  type: TYPE_NORMAL
- en: The metadata doesn’t affect the type checkers but is useful for code documentation,
    analysis, and runtime inspections.
  prefs: []
  type: TYPE_NORMAL
- en: Since its introduction in Python 3.9, you can use `Annotated` as shown in [Example 4-3](#annotated_usage).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. Using `Annotated` to declare custom types with metadata
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The [FastAPI documentation](https://oreil.ly/mtGcY) recommends the use of `Annotated`
    instead of type aliases for reusability, for enhanced type checks in the code
    editor, and for catching issues during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Keep in mind that the `Annotated` feature requires a minimum of two arguments
    to work. The first should be the type passed in, and the other arguments are the
    annotation or metadata you want to attach to the type such as a description, validation
    rule, or other metadata, as shown in [Example 4-3](#annotated_usage).
  prefs: []
  type: TYPE_NORMAL
- en: Typing, while beneficial by itself, doesn’t address all aspects of data handling
    and structuring. Thankfully, Python’s *dataclasses* from the standard library
    help to extend the typing system.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how you can leverage dataclasses to improve typing across your application.
  prefs: []
  type: TYPE_NORMAL
- en: Dataclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dataclasses were introduced in Python 3.7 as part of the standard library. If
    you need custom data structures, you can use dataclasses to organize, store, and
    transfer data across your application.
  prefs: []
  type: TYPE_NORMAL
- en: They can help with avoiding code “smells” such as function parameter bloat,
    where a function is hard to use because it requires more than a handful of parameters.
    Having a dataclass allows you to organize your data in a custom-defined structure
    and pass it as a single item to functions that require data from different places.
  prefs: []
  type: TYPE_NORMAL
- en: You can update [Example 4-2](#type_annotation) to leverage dataclasses, as shown
    in [Example 4-4](#dataclasses).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. Using dataclasses to enforce type safety
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use dataclasses to decorate the `Message` and `MessageCost` classes as special
    classes for holding data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the `response` attribute to be either a `str` or `None`. This is similar
    to using `Optional[str]` from the `typing` module. This new syntax is available
    in Python 3.10 and later, using the new union operator: `|`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Change the signature of the `calculate_usage_costs` function to use the predefined
    dataclasses. This change simplifies the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: You should aim to leverage dataclasses when your code accumulates code smells
    and becomes difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary benefit of using dataclasses in [Example 4-4](#dataclasses) was
    to group related parameters to simplify the function signature. In other scenarios,
    you may use dataclasses to:'
  prefs: []
  type: TYPE_NORMAL
- en: Eliminate code duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shrink down code bloat (large classes or functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactor data clumps (variables that are commonly used together)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent inadvertent data mutation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promote data organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promote encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforce data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also be used to implement many other code enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dataclasses are an excellent tool to improve data organization and exchange
    anywhere in your application. However, they don’t natively support several features
    when building API services:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic data parsing
  prefs: []
  type: TYPE_NORMAL
- en: Parsing ISO datetime-formatted strings to datetime objects on assignment
  prefs: []
  type: TYPE_NORMAL
- en: Field validation
  prefs: []
  type: TYPE_NORMAL
- en: Performing complex checks on assignment of values to fields, such as checking
    if a string is too long
  prefs: []
  type: TYPE_NORMAL
- en: Serialization and deserialization
  prefs: []
  type: TYPE_NORMAL
- en: Converting between JSON and Pythonic data structures, especially when using
    uncommon types
  prefs: []
  type: TYPE_NORMAL
- en: Field filtering
  prefs: []
  type: TYPE_NORMAL
- en: Removing fields of objects that are unset or contain `None` values
  prefs: []
  type: TYPE_NORMAL
- en: None of the mentioned limitations would force you to move away from using dataclasses.
    You should use dataclasses rather than normal classes when you need to create
    data-centric classes with minimal boilerplate code, as they automatically generate
    special methods, type annotations, and support for default values, reducing potential
    errors. However, libraries such as `pydantic` support these features if you don’t
    want to implement your own custom logic (e.g., serializing datetime objects).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: FastAPI also supports dataclasses through Pydantic, which implements its own
    version of dataclasses with support for the aforementioned features, enabling
    you to migrate codebases that heavily use dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at Pydantic next and what makes it great for building GenAI
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pydantic is the most widely used data validation library with support for custom
    validators and serializers. Pydantic’s core logic is controlled by type annotations
    in Python and can emit data in JSON format, allowing for seamless integration
    with any other tools.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the core data validation logic in Pydantic V2 has been rewritten
    in Rust to maximize its speed and performance, positioning it as one of the fastest
    data validation libraries in Python. As a result, Pydantic has heavily influenced
    FastAPI and 8,000 other packages in the Python ecosystem including Hugging Face,
    Django, and LangChain. It is a battle-tested toolkit used by major tech companies
    with 141 million downloads a month at the time of writing, making it a suitable
    candidate for adoption in your projects in replacement for dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic provides an extensive toolset for data validation and processing using
    its own `BaseModel` implementation. Pydantic models share many similarities with
    dataclasses but differ in subtle areas. When you create Pydantic models, a set
    of initialization hooks are called that add data validation, serialization, and
    JSON schema generation features to the models that vanilla dataclasses lack.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI tightly integrates with Pydantic and leverages its rich feature set
    under the hood for data processing. Type checkers and code editors can also read
    Pydantic models similar to dataclasses to perform checks and provide auto-completions.
  prefs: []
  type: TYPE_NORMAL
- en: How to Use Pydantic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can install Pydantic into your project using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pydantic at its core implements a `BaseModel`, which is the primary method for
    defining models. *Models* are simply classes that inherit from `BaseModel` and
    define fields as annotated attributes using type hints. Any models can then be
    used as schemas to validate your data.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from grouping data,^([3](ch04.html#id762)) Pydantic models let you specify
    the request and response requirements of your service endpoints and validate incoming
    untrusted data from external sources. You can also go as far as filter your LLM
    outputs using Pydantic models (and validators, which you will learn more about
    shortly).
  prefs: []
  type: TYPE_NORMAL
- en: You can create your own Pydantic models as shown in [Example 4-5](#pydantic_models).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. Creating Pydantic models
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `TextModelRequest` model inheriting the Pydantic `BaseModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Set defaults if an explicit value isn’t provided. For instance, set the `temperature`
    field to `0.0` if a value is not provided on initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-5](#pydantic_models) also shows how you can switch your dataclasses
    into Pydantic models to leverage its many features.'
  prefs: []
  type: TYPE_NORMAL
- en: Compound Pydantic Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Pydantic models, you can declare data *schemas*, which define data structures
    supported in the operations of your service. Additionally, you can also use inheritance
    for building compound models, as shown in [Example 4-6](#pydantic_compound_models).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6\. Creating Pydantic models
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `ModelRequest` model inheriting the Pydantic `BaseModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `ModelResponse`. If the data for the `ip` optional field is not provided,
    then use the defaults of `None`. The `content` field can be both bytes (for image
    images) or string (for text models).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `TextModelRequest` and `ImageModelRequest` models by inheriting `ModelRequest`.
    The optional temperature field by default is set to 0.0. The `num_inference_steps`
    field for the `ImageModelRequest` model is optional and set to 200. Both of these
    models will now require the prompt string field to be provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `ImageModelResponse` and `TextModelResponse` models by inheriting
    the `ModelResponse` model. For `TextModelResponse`, provide the count of tokens,
    and with `ImageModelResponse`, provide an image size in pixels alongside the remote
    URL for downloading the image.
  prefs: []
  type: TYPE_NORMAL
- en: With the models shown in [Example 4-6](#pydantic_compound_models), you have
    schemas needed to define the requirements of your text and image generation endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Field Constraints and Validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from support for standard types, Pydantic also ships with *constrained
    types* such as `EmailStr`, `PositiveInt`, `UUID4`, `AnyHttpUrl`, and more that
    can perform data validation out of the box during model initialization for common
    data formats. The full list of Pydantic types is available in [the official documentation](https://oreil.ly/xNbXX).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some constrained types such as `EmailStr` will require dependency packages to
    be installed to function but can be extremely useful for validating common data
    formats such as emails.
  prefs: []
  type: TYPE_NORMAL
- en: To define more custom and complex field constraints on top of Pydantic-constrained
    types, you can use the `Field` function from Pydantic with the `Annotated` type
    to introduce validation constraints such as a valid input range.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-7](#pydantic_constrained_fields) replaces the standard type hints
    in [Example 4-6](#pydantic_compound_models) with constrained types and `Field`
    functions to implement stricter data requirements for your endpoints based on
    model constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7\. Using constrained fields
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the `str` standard type with `Field` and `Annotated` to bound the string
    length to a range of characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a new request UUID by passing a callable to `default_factory` that
    will be called to generate a new UUID.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Constrain the optional `ip` field to any valid IPv4 or IPv6 address ranges.
    `None` is also a valid entry if the client’s IP can’t be determined. This optional
    field doesn’t have a default value, so if a valid IP or `None` is not provided,
    Pydantic will raise a `ValidationError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Constrain the `content` field to 10,000 characters or bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Constrain the temperature between `0.0` and `1.0` with a default value of `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Reuse an `Annotated` constrain on the `output_size` field to positive integers
    using the `PositiveInt` constrained type. The `lte` and `gte` keywords refer to
    *less than equal* and *greater than equal*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_implementing_type_safe_ai_services_CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Constrain the `num_inference_steps` field with `Field` between `0` and `2000`
    and a default of `200`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_implementing_type_safe_ai_services_CO5-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Constrain the optional `url` field to any valid HTTP or HTTPS URL, where the
    hostname and top-level domain (TLD) are required.
  prefs: []
  type: TYPE_NORMAL
- en: With the models defined in [Example 4-7](#pydantic_constrained_fields), you
    can now perform validation on incoming or outgoing data to match the data requirements
    you have. In such cases, FastAPI will leverage Pydantic to automatically return
    error responses when data validation checks fail during a request runtime, as
    shown in [Example 4-8](#fastapi_pydantic_validation_failure).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8\. FastAPI error response on data validation failure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Custom Field and Model Validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another excellent feature of Pydantic for performing data validation checks
    is *custom field validators*. [Example 4-9](#field_validators) shows how both
    types of custom validators can be implemented on the `ImageModelRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9\. Implementing custom field and model validators for `ImageModelRequest`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to static type checks, raise a runtime validation error if incorrect
    parameters have been passed to both the `is_square_image` and `is_valid_​infer⁠ence_step`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `tinysd` model can generate square images in certain sizes only. Asking
    for a nonsquare image size (an aspect ratio other than `1`) should raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Raise a `ValueError` if the user asks for a large number of inference steps
    for the `tinysd` model.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Create reusable and more readable validators using the annotated pattern for
    both `OutputSize` and `InferenceSteps`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Attach the `OutputSize` field validator to the `output_size` field to check
    for incorrect values after the model is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_implementing_type_safe_ai_services_CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Attach the `InferenceSteps` validator to the `ImageModelRequest` model to perform
    checks on the model field values *after* the model is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: With custom field validators, as shown in [Example 4-9](#field_validators),
    you can now be confident that your image generation endpoints will be protected
    from incorrect configurations provided by users.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also use the decorator pattern to validate model fields. Special methods
    can be associated with model fields to execute conditional data checks by employing
    the `@field_validator` or `@model_validator` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: While `@field_validator` accesses a value of a single field to perform checks,
    the `@model_validator` decorator allows for checks that involve multiple fields.
  prefs: []
  type: TYPE_NORMAL
- en: With `after` validators, you can perform extra checks or modify the data after
    Pydantic has completed its parsing and validation.
  prefs: []
  type: TYPE_NORMAL
- en: Computed Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to dataclasses, Pydantic also allows you to implement methods to compute
    fields derived from other fields.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `@computed_field` decorator to implement a computed field for
    calculating count of tokens and cost, as shown in [Example 4-10](#computed_fields).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10\. Using computed fields to automatically count the total number
    of tokens
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Computed fields are useful for encapsulating any field computation logic inside
    your Pydantic models to keep code organized. Bear in mind that computed fields
    are only accessible when you convert a Pydantic model to a dictionary using `.model_dump()`
    or via serialization when a FastAPI API handler returns a response.
  prefs: []
  type: TYPE_NORMAL
- en: Model Export and Serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Pydantic models can serialize to JSONs, the models you defined in [Example 4-7](#pydantic_constrained_fields)
    can also be dumped into (or be loaded from) JSON strings or Python dictionaries
    while maintaining any compound schemas, as shown in [Example 4-11](#model_export).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11\. Exporting and serializing the `TextModelResponse` model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Parsing Environment Variables with Pydantic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alongside the `BaseModel`, Pydantic also implements a `Base` class for parsing
    settings and secrets from files. This feature is provided in an optional Pydantic
    package called `pydantic-settings`, which you can install as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseSettings` class provides optional Pydantic features for loading a settings
    or config class from environment variables or secret files. Using this feature,
    the settings values can be set in code or overridden by environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful in production where you don’t want to expose secrets inside the
    code or the container environment.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a model inheriting from `BaseSettings`, the model initializer
    will attempt to set values of each field using provided defaults. If unsuccessful,
    the initializer will then read the values of any unset fields from the environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a dotenv environment file (ENV):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: An ENV is an environment variable file that can use a shell script syntax for
    key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-12](#pydantic_settings) shows parsing environment variables using
    `BaseSettings` in action.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12\. Using Pydantic `BaseSettings` to parse environment variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare `AppSettings` inheriting from the `BaseSettings` class from the `pydantic_settings`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Configure `AppSettings` to read environment variables from the ENV file at the
    root of a project with the `UTF-8` encoding. By default, the snake_case field
    names will map to environment variables names that are an uppercase version of
    those names. For instance, `app_secret` becomes `APP_SECRET`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Validate that the `DATABASE_URL` environment variable has a valid Postgres connection
    string format. If not provided, set the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the `CORS_WHITELIST` environment variable has a unique list of valid
    URLs with hostname and TLDs. If not provided, set the default to a set with a
    single value of `http://localhost:3000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_implementing_type_safe_ai_services_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We can check the `AppSettings` class is working by printing a dump of the model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can switch environment files when using the `_env_file` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Dataclasses or Pydantic Models in FastAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though dataclasses support serialization of only the common types (e.g.,
    `int`, `str`, `list`, etc.) and won’t perform field validation at runtime, FastAPI
    can still work with both Pydantic models and Python’s dataclasses. For field validation
    and additional features, you should use Pydantic models. [Example 4-13](#dataclass_fastaspi)
    shows how dataclasses can be used in FastAPI route handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13\. Using dataclasses in FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define models for text model request and response schemas.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the handler to serve `POST` requests with a body. Then, declare the
    request body as `TextModelRequest` and the response as `TextModelResponse`. Static
    code checkers like `mypy` will read the type annotations and raise warnings if
    your controller doesn’t return the expected response model.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly check whether the service supports the `model` parameter provided
    in the request `body`. If not, return a bad request HTTP exception response to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI converts vanilla dataclasses to Pydantic dataclasses to serialize/deserialize
    and validate the request and response data.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 4-13](#dataclass_fastaspi), you have leveraged type annotations
    by refactoring the text model controller to be resilient to new changes and bad
    user input. Static type checkers can now help you catch any data-related issues
    as changes occur. In addition, FastAPI used your type annotations to validate
    request and responses alongside the auto-generation of an OpenAPI documentation
    page, as shown in [Figure 4-2](#fastapi_dataclasses_docs).
  prefs: []
  type: TYPE_NORMAL
- en: You now see that FastAPI leverages Pydantic models under the hood for data handling
    and validation, even if you use vanilla dataclasses. FastAPI converts your vanilla
    dataclasses to Pydantic-flavored dataclasses to use its data validation features.
    This behavior is intentional because if you have projects with several pre-existing
    dataclass type annotations, you can still migrate them over without having to
    rewrite them into Pydantic models for leveraging data validation features. However,
    if you’re starting a fresh project, it is recommended to use Pydantic models directly
    in replacement for Python’s built-in dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0402](assets/bgai_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Automatic generation of validation schemas using vanilla dataclasses
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now let’s see how you can replace dataclasses with Pydantic in your FastAPI
    application. See [Example 4-14](#pydantic_fastapi).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14\. Using Pydantic to model request and response schemas
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_implementing_type_safe_ai_services_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Import Pydantic models for text model request and response schemas.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_implementing_type_safe_ai_services_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the handler to serve `POST` requests with a body. Then, declare the
    request body as `TextModelRequest` and the response as `TextModelResponse`. Static
    code checkers like `mypy` will read the type annotations and raise warnings if
    your controller doesn’t return the expected response model.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_implementing_type_safe_ai_services_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly check whether the service supports the `model` parameter provided
    in the request `body`. If not, return a bad request HTTP exception response to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_implementing_type_safe_ai_services_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the `TextModelResponse` Pydantic model as per the function typing. Access
    the client’s IP address using the request object via `request.client.host`. FastAPI
    will take care of serializing your model using `.model_dump()` under the hood.
    As you also implemented the computed fields for `tokens` and `cost` properties,
    these will automatically will be included in your API response without any additional
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As shown in [Example 4-13](#dataclass_fastaspi), if you use dataclasses instead
    of Pydantic models, FastAPI will convert them to Pydantic dataclasses to serialize/deserialize
    and validate the request and response data. However, you may not be able to leverage
    advanced features such as field constraints and computed fields with dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Example 4-14](#pydantic_fastapi), Pydantic can provide exceptional
    developer experience by helping in type checks, data validation, serialization,
    code editor auto-completions, and computed attributes.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI can also use your Pydantic models to auto-generate an OpenAPI specification
    and documentation page so that you can manually test your endpoints seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Once you start the server, you should see an updated documentation page with
    the new Pydantic models and the updated constrained fields, as shown in [Figure 4-3](#fastapi_pydnatic_models).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0403](assets/bgai_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Automatic generation of FastAPI docs using Pydantic models
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you send a request to the `/generate/text` endpoint, you should now see the
    prepopulated fields via the `TextModelResponse` Pydantic model, as shown in [Example 4-15](#fastapi_pydnatic_docs).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15\. Automatic population of the response fields via the `TextModelResponse`
    Pydantic model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Pydantic model features I covered in this chapter represent just a fraction
    of the tools at your disposal for constructing GenAI services. You should now
    feel more confident in leveraging Pydantic to annotate your own services to improve
    its reliability and your own developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the importance of creating fully typed services
    for GenAI models. You now understand how to implement type safety with standard
    and constrained types, how to use Pydantic models for data validation, and how
    to implement your own custom data validators across your GenAI service. You also
    discovered strategies for validating request and response content and managing
    application settings with Pydantic to prevent bugs and to improve your development
    experience. Overall, by following along with the practical examples, you learned
    how to implement a robust, less error-prone GenAI service.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers asynchronous programming in AI workloads, discussing
    performance and parallel operations. You will learn more about I/O-bound and CPU-bound
    tasks and understand the role and limitations of FastAPI’s background tasks with
    concurrent workflows.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.html#id749-marker)) A [`Literal` type](https://oreil.ly/69Pmn) can
    be used to indicate to type checkers that the annotated object has a value equivalent
    to one of the provided literals.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.html#id750-marker)) OpenAI’s `tiktoken` uses the [*Byte-Pair Encoding*
    (BPE) algorithm](https://oreil.ly/l67GS) to tokenize text. Different models use
    different encodings to convert text into tokens.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch04.html#id762-marker)) Structs in C-like languages and dataclasses in
    Python can also be used to group and pass data around.
  prefs: []
  type: TYPE_NORMAL
