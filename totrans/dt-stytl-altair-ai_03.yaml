- en: 3 Reviewing the basic concepts of Altair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vega and Vega-Lite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic components of an Altair chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A relevant case study
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It may, at first glance, seem counterintuitive for the topic of running a data
    story in Altair (chapter 2) to be covered before the basics of Altair (chapter
    3). The reason is that now that you have a general understanding of how Altair
    works, you’re ready to see all the details. If you had read this chapter right
    away, you probably would have gotten bored and skipped it. Instead, now, you are
    ready to read it calmly. In this chapter, we will review the basic concepts underlying
    Vega and Vega-Lite, the visualization grammars upon which Altair is built. Then,
    we’ll focus on the Altair main components: encodings, marks, conditions, compound
    charts, and interactivity. In the last part of the chapter, we’ll implement a
    practical example.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Vega and Vega-Lite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vega and Vega-Lite are visualization grammars used by Altair. A *visualization
    grammar* is a set of rules and principles defining how to represent data visually,
    much like how grammar functions in a spoken language. A visualization grammar
    includes a vocabulary of visual elements, such as points, lines, and bars, as
    well as rules for combining and arranging these elements to create meaningful
    visualizations. Using a visualization grammar allows you to create clear and effective
    data visualizations that convey insights and tell stories.
  prefs: []
  type: TYPE_NORMAL
- en: Vega and Vega-Lite provide declarative language for creating interactive visualizations.
    Learning Vega and Vega-Lite before Altair is important because Altair is built
    on top of these two visualization libraries. By first mastering these foundational
    tools, you can gain a deeper understanding of how Altair works and take advantage
    of its full potential. Additionally, learning Vega and Vega-Lite enables you to
    create custom visualizations that may not be possible with Altair alone, allowing
    for more flexibility and creativity in data exploration and communication. In
    the following section, we’ll explore the main components of a Vega and Vega-Lite
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 Vega
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Vega* is a visualization grammar used to define the visual aspects and interactive
    features of a chart by writing code in JSON format. Vega is built at the top of
    D3.js ([https://d3js.org/](https://d3js.org/)), a very popular JavaScript library
    for data visualization. Using Vega, you can generate web-based views that utilize
    HTML5 Canvas or SVG to display the resulting chart. HTML5 Canvas is a bitmap-based
    drawing technology that enables you to render dynamic graphics and animations
    on the web. SVG is a vector-based graphics format for building scalable and resolution-independent
    graphics.'
  prefs: []
  type: TYPE_NORMAL
- en: A Vega JSON file contains the specifications for the visual appearance and interactive
    behavior of a chart. Listing 3.1 shows the basic structure of a JSON specification.
    For testing, you can use the Vega Editor ([https://vega.github.io/editor/#/](https://vega.github.io/editor/#/))
    to render the chart produced by Vega. We will produce a basic Vega line chart
    gradually, throughout this section.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.1 The basic structure of a Vega JSON file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note  First, define the version of the schema (`$schema`), a `description`,
    the `width`, and the `height` of the chart. Then, specify the main sections (`signals`,
    `data`, and so on). Listing 3.1 shows only the structure of a Vega JSON file and
    will not produce any chart if pasted in the Vega Editor.
  prefs: []
  type: TYPE_NORMAL
- en: The main sections of a Vega JSON file include `data`, `scales`, `axes`, `marks`,
    and `signals`. In the remainder of this section, we’ll describe an overview of
    the main sections of a Vega specification. For more details, please refer to the
    Vega official documentation. ([https://vega.github.io/vega/docs/](https://vega.github.io/vega/docs/)).
  prefs: []
  type: TYPE_NORMAL
- en: data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section defines the data source to use. It specifies the data format, where
    the data is located, and how it should be loaded and transformed. The following
    listing shows an example of a `data` section.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.2 An example `data` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note  Specify the list of data to use in the visualization. For each element
    of data, specify the name and content. We will use `myData` to refer to the associated
    data in the specification. We can specify more than one data source. The example
    specifies data values directly. However, you can also retrieve the data from a
    CSV file, by specifying the URL and the format as follows: `"url":` `"/path/to/csv/myfile.csv",`
    `format":` `{"type":` `"csv"}.` Alternatively, you can retrieve data from other
    formats or embed them in the JSON directly.'
  prefs: []
  type: TYPE_NORMAL
- en: scales
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section defines the scales that map the data to visual properties. Scales
    map a data domain (input range) to a visual range (output range). The following
    listing shows an example of a `scales` section.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.3 An example `scales` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note  Specify the list of `scales` to use in the visualization. For each scale,
    specify at least the name, range, and domain. The example defines two scales,
    one for the x-axis and the other for the y-axis. Specify the data to use as the
    value of the domain attribute.
  prefs: []
  type: TYPE_NORMAL
- en: axes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section defines the axes of the chart. Use `axes` to define tick marks
    and labels along an axis. The following listing shows an example of an `axes`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.4 An example `axes` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note  Specify the list of `axes` to use in the visualization. For each axis,
    specify at least the scale and how to orient it. The example defines two axes,
    one for the x-axis and the other for the y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: marks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section defines the visual `marks` that represent the data. Marks include
    points, lines, rectangles, areas, and other shapes. Use visual properties, like
    size, color, opacity, and shape, to style marks. The following listing shows an
    example of a `marks` section.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.5 An example `marks` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note  Specify the list of `marks` to use in the visualization. For each `mark`,
    specify at least the `type` (line, symbol, rect, and so on), the source of data
    (`from`), and how to encode the data (`encode`). Use the `enter` block to define
    the initial properties of the visualization. The example defines a line chart
    representing data contained in the `myData` variable defined in the `data` section.
    It also defines two encoding channels, `x` and `y`, and the color of the line
    stroke.
  prefs: []
  type: TYPE_NORMAL
- en: signals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This section defines the interactive signals you can use to modify the visualization,
    such as sliders, dropdowns, and check boxes. Every signal is composed of two parts:
    the *listener*, which is identified by the `signals` section, and the *handler*,
    which is defined by the keyword `signal` within the `marks` section. The signal
    listener responds to signal changes, and the signal handler determines how the
    visualization reacts. For example, a signal handler might change the color or
    size of data points based on a signal’s value. The following listing provides
    an example that changes the color of a selected element in a chart when the user
    hovers over the bar with the mouse (figure 3.1).'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.6 An example `signals` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note  `signals` are used to capture events or changes in the visualization.
    For each signal, specify its name (`changeColor`, in the example), the property
    to modify (`value`, in the example), and the list of events to listen (`on`, in
    the example).
  prefs: []
  type: TYPE_NORMAL
- en: To use the signal, you must specify an `update` block within your `mark` section.
    Rememember that you used the `enter` block to specify the initial condition of
    the chart. Now, you can use the `update` block to specify a change. The following
    listing specifies a change in the line color.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.7 An example `update` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note  Under the `marks` section, specify a handler associated with the signal.
    This handler will be triggered when the specified event (like mouseover) associated
    with the signal occurs. Within the `update` property of the `marks` section, a
    handler is defined. This handler checks whether the signal corresponds to the
    mouseover event (e.g., `changeColor` `===` `datum`). If the condition is met (i.e.,
    if the mouse is over the line), the handler performs an action, such as changing
    the color of the line accordingly. Refer to the Vega documentation ([https://vega.github.io/vega/docs/signals/](https://vega.github.io/vega/docs/signals/))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 shows the resulting line chart. You can find the complete example
    in the book’s GitHub repository under 03/vega/json/line-chart.json.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 The line chart written in Vega
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Draw a line chart in Vega as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load data from the following URL: [https://mng.bz/ZEyZ](https://mng.bz/ZEyZ).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add points to the line. To do this, add a new mark (in addition to the line),
    using `symbol` as a type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the solution to this exercise in the GitHub repository for the
    book under 03/vega/json/spec.json.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Draw a bar chart in Vega as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load data from the following URL: [https://mng.bz/Ad6W](https://mng.bz/Ad6W).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `band` as the type for the `X` scale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `rect` as the `mark` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, set a signal that changes the bar color while hovering over it with
    the mouse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can find the solution to this exercise in the book’s GitHub repository
    under 03/vega/json/spec2.json. Now that you have learned the basic concepts behind
    Vega, let’s move to the next step: Vega-Lite.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 Vega-Lite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Vega-Lite* is a concise JSON of a Vega visualization. Vega-Lite still maintains
    the specifications already defined in Vega, but it represents them through a more
    compact syntax. Compared to Vega, Vega-Lite offers a more streamlined and concise
    syntax, ideal for quickly generating simple visualizations with less code complexity,
    making it more accessible to users seeking rapid creation of common charts. While
    Vega-Lite provides a high-level abstraction for creating visualizations, it may
    lack the flexibility to customize every aspect of visualization. It may also perform
    worse than Vega. The basic sections of a Vega-Lite JSON specification are `data`,
    `encoding`, `mark`, and `layer`.'
  prefs: []
  type: TYPE_NORMAL
- en: data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section specifies the data source for the visualization. The following
    listing provides an example of a `data` section in Vega-Lite.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.8 An example `data` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note  This specifies the data to use in the visualization. Refer to the Vega-Lite
    documentation ([https://vega.github.io/vega-lite/docs/data.xhtml](https://vega.github.io/vega-lite/docs/data.xhtml))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: encoding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section maps the data fields to visual properties, such as position, color,
    and size. The following listing shows an example of an `encoding` section in Vega-Lite.
    Use the Vega Editor to test your code in Vega-Lite, ensuring you select Vega-Lite
    from the top-left drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.9 An example `encoding` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note  Specify the encodings to use in the visualization. The example defines
    two channels, `x` and `y`, and specifies the data type as `quantitative`. Vega
    and Vega-Lite also support other data types, such as `ordinal`, for sequential
    data; `nominal`, for text; and `time`, for temporal data.
  prefs: []
  type: TYPE_NORMAL
- en: mark
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section defines the type of visual mark, such as `bars`, `points`, or `lines`.
    The following listing shows an example of a `mark` section in Vega-Lite.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.10 An example `mark` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note  Specify the `mark` to use in the visualization. The example defines a
    line chart.
  prefs: []
  type: TYPE_NORMAL
- en: layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section combines multiple marks in a single chart. The next listing shows
    an example of a `layer` section in Vega-Lite.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.11 An example `layer` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note  Specify the list of marks to combine. This combines two charts: a line
    chart and a point chart.'
  prefs: []
  type: TYPE_NORMAL
- en: Interactivity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Vega-Lite simplifies the way of managing signals by using `params`. Instead
    of defining a signal, you define a `param`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.12 How to specify `params` in Vega-Lite
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note  Specify the name of each signal using the `params` keyword. For each `param`,
    specify the name and how to trigger it. The type can be set to `point`, to select
    a single point in the chart or interval.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the `params`, you can use them in the marks, as specified in
    the following listing. You can find the complete example in the GitHub repository
    for the book under 03/vega-lite/json/line-chart.json.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.13 How to use `params` in a `mark` in Vega-Lite
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note  The example in listing 3.13 uses the `params` defined in listing 3.12
    to set the stroke color based on a condition. If the `changeColor` `param` is
    triggered, then the color line is set to `red`; if the `default` `param` is triggered,
    then the color line is set to `blue`. The default stroke color is `blue`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Convert the result of exercise 1 into Vega-Lite. The solution to the exercise
    is provided in the book’s GitHub repository under 03/vega-lite/json/spec.json.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned the basic concepts behind Vega and Vega-Lite, let’s
    see how to render a Vega/Vega-Lite visualization using HTML and JavaScript. If
    you are unfamiliar with HTML and JavaScript, you can skip the next section and
    move on to section 3.2.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.3 How to render a Vega or Vega-Lite visualization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both Vega and Vega-Lite are JSON objects that need a renderer to be shown, such
    as an external JavaScript library, to render the visualization from an HTML page.
    Vega-Lite provides a JavaScript API that automatically builds both Vega and Vega-Lite
    visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render a Vega or Vega-Lite JSON, import the following JavaScript libraries
    into your HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cdn.jsdelivr.net/npm/vega@5.22.1](https://cdn.jsdelivr.net/npm/vega@5.22.1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cdn.jsdelivr.net/npm/vega-lite@5.6.0](https://cdn.jsdelivr.net/npm/vega-lite@5.6.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cdn.jsdelivr.net/npm/vega-embed@6.21.0](https://cdn.jsdelivr.net/npm/vega-embed@6.21.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library versions may vary. In our case, we import version 5.22.1 for Vega,
    5.6.0 for Vega-Lite, and 6.21.0 for Vega-Embed, as we usually do to import JavaScript
    libraries. Then, you can wrap the code described in listing 3.11 to render your
    Vega/Vega-Lite JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code to render a Vega or Vega-Lite JSON specification
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For example, to render the chart described in listing 3.7, use the following
    HTML specification.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.14 The complete HTML file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports Vega and Vega-Lite libraries'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates a div to contain the chart'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Builds the chart'
  prefs: []
  type: TYPE_NORMAL
- en: Note  First, import the Vega and Vega-Lite libraries in the header section.
    Then, create a `div` that will contain the chart. Finally, build the chart. Use
    an external JSON file to define the chart specifications. In the `script` body,
    specify the JavaScript code to import your Vega JSON file. Open a new `XMLHttpRequest()`
    to load the JSON file, and then use the `vegaEmbed()` function to render the JSON.
    Note that you must provide a valid external URL to the request object. You can’t
    use a local JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete example and other examples in the book’s GitHub repository,
    section 03/vega ([https://mng.bz/x2NB](https://mng.bz/x2NB)) and 03/vega-lite
    ([https://mng.bz/Vxj5](https://mng.bz/Vxj5)). Now that you have learned the basic
    concepts underlying Vega and Vega-Lite, let’s move to the next topic: the basic
    components of an Altair chart.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 The basic components of an Altair chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we mostly use the *just-in-time teaching* methodology, which combines
    theory and practice to teach concepts at the exact moment you need them. However,
    in this chapter, we will not use this methodology. This is because we want to
    establish a strong foundation of fundamental concepts about Altair before diving
    into the more advanced topics covered later in the book. By deviating from the
    just-in-time teaching methodology for this chapter, we can provide a comprehensive
    overview and in-depth understanding of the underlying principles that will serve
    as building blocks for the subsequent material. Altair is built on top of Vega-Lite
    and offers a user-friendly API to build charts. You learned how to build a basic
    chart in Altair in chapter 2, and in this chapter, we’ll dive deep into the basic
    components of an Altair chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic Altair components include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Encodings* —These define how data is mapped to visual properties, such as
    color, shape, and size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Marks* —These refer to the visual elements representing the data, such as
    bars, points, and lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conditions* —These enable us to create more complex visualizations by specifying
    rules for when we should use certain encodings or marks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compound charts* —These combine multiple visual elements to create more complex
    and informative visualizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interactivity* —This enables us to interact with the visualization and explore
    the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configurations* —These define general properties for compound charts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s analyze each component separately, starting with the first one: encodings.
    You can find some sample code in the 03/altair directory ([https://mng.bz/rVXX](https://mng.bz/rVXX))
    of the book’s GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1 Encodings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Altair utilizes *encodings* to indicate where to show data. An encoding defines
    a mapping between a column in the dataset and an encoding channel. Each encoding
    channel corresponds to a specific column of the DataFrame that can be mapped to
    a visual feature of the plot. The encoding process determines where to display
    the data in the chart, according to the chosen channel type. Altair identifies
    several key types of channels, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Position* —This specifies the location of data in the chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mark property* —This determines the chart’s appearance such as color, size,
    and shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Text and tooltip* —These offer supplementary annotations for the graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table 3.1 provides a brief description of the main encodings. For more details,
    please refer to the Altair documentation ([https://mng.bz/d6RQ](https://mng.bz/d6RQ)).
  prefs: []
  type: TYPE_NORMAL
- en: Refer to chapter 2 to build a chart using encodings.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.1 The main encodings in Altair
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Type | Channel | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Position  | `x, y`  | Horizontal and vertical positions  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `longitude, latitude`  | Geographical coordinates  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `xError, xError`  | Error values for `x` and `y`  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `x2,y2, longitude2, latitude2`  | Second positions for ranges  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `theta, theta2`  | Start and end arc angles  |'
  prefs: []
  type: TYPE_TB
- en: '| Mark property  | `angle, radius`  | The angle and the radius of the mark  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `color, fill`  | The color and the fill of the mark  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `opacity, fillOpacity`  | The opacity and the fill opacity of the mark  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `shape, size`  | The shape and the size of the mark  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `stroke, strokeDash, strokeOpacity, strokeWidth`  | Stroke properties
    of the mark  |'
  prefs: []
  type: TYPE_TB
- en: '| Text and tooltip  | `text`  | The text of the mark  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `tooltip`  | The tooltip of the mark  |'
  prefs: []
  type: TYPE_TB
- en: 'Each column in the dataset is associated with a data type, which defines the
    kind of values a variable can store. A data type includes primitive types, like
    integers and characters, and complex types, like arrays and objects. Altair supports
    the following data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Nominal* —Data that can be divided into distinct categories, without any specific
    order, such as the names of different fruits in a dataset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ordinal* —Data that can be divided into distinct categories with an inherent
    order, such as the days of the week, where the order of the days is essential'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quantitative* —Numerical and continuous data, such as the number of product
    sales'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Temporal* —Data with a temporal (i.e., date or time) component, such as the
    date on which a sale occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Geojson* —Data with a geographic component, such as latitude and longitude
    coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we build a chart in Altair, we must associate each column involved in
    the chart with a data type. Altair defines two ways to specify a data type:'
  prefs: []
  type: TYPE_NORMAL
- en: The type property of the channel, such as `x=alt.X('category',` `type= 'quantitative')`,
    where `category` is the column name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shorthand code following the `:` symbol, after the column name, `x=alt.X ('category:Q')`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have learned the concept of encodings, let’s move on to the next
    concept, marks.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2 Marks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Marks* enable you to represent data in visualizations. Examples of marks include
    bar charts, line charts, heat maps, and box plots, among others. To specify the
    type of mark, use the `mark_<type>()` function, where `<type>` represents the
    specific type of mark. For instance, to create a bar chart, use `mark_bar()`.
    Additionally, you can provide a list of attributes as input parameters for each
    mark property defined in table 3.1\. When using a mark property within the `mark_<type>()`
    function, the value of that property is fixed to a constant value. For example,
    `mark_circle(size=5)` will draw circles with a constant size of 5\. However, if
    you want to vary the size of the circles depending on a specific column of your
    DataFrame, use the `size` channel within the encoding function. Table 3.2 shows
    the main mark types provided by Altair.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.2 The main mark types provided by Altair
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_arc()`  | A pie chart  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_area()`  | A filled-area chart  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_bar()`  | A bar chart  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_circle()`  | A scatter plot with filled points  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_geoshape()`  | A geographic shape  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_line()`  | A line chart  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_point()`  | A scatter plot with configurable points  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_rect()`  | A filled rectangle for heatmaps  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_rule()`  | A vertical or horizontal line spanning the axis  |'
  prefs: []
  type: TYPE_TB
- en: '| `mark_text()`  | A text  |'
  prefs: []
  type: TYPE_TB
- en: Refer to chapter 2 to build a chart using marks.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.3 Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Altair provides several ways to create *conditions* in visualizations, which
    enable you to customize and control the appearance of your charts based on specific
    criteria. One common way to create conditions in Altair is to use the *if-else*
    *statements* in the encoding channels of a chart. To define a condition in Altair,
    use the `alt.condition()` method, which takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value to use when the condition is true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value to use when the condition is false
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, if we want to change the color of the bars in a bar chart based
    on a specific condition, write the code shown in the following listing and the
    GitHub repository for the book under 03/altair/condition.py. The final chart is
    rendered in 03/altair/condition.xhtml.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.15 Using the `alt.condition()` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Color to use when condition is true'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Color to use when condition is false'
  prefs: []
  type: TYPE_NORMAL
- en: Note  The condition in the example checks if the Region is Europe. If the condition
    is true, the bars will be colored red, and if the condition is false, the bars
    will be colored blue. Use the datum variable to directly access the DataFrame
    column name within a condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to using if-else statements with the `alt.condition()` method and
    the type-checking functions, Altair provides two other ways to create conditions
    in visualizations: *transformations* and *selections*. You will see transformations
    in chapter 5 and selections in chapter 6\. You can use transformations and selections
    to build interconnected charts that update synchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.4 Compound charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Compound charts* enable you to combine visualizations in a single chart. Altair
    supports the following types of compound charts: layering, horizontal concatenation,
    vertical concatenation, and repeated charts. To explain how each type of compound
    chart works, consider the two charts described in the following listing and 03/altair/
    layering.py.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.16 Building two charts in Altair
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note  Build a base chart, with the encodings and properties shared among all
    the charts, and then use it to build the other charts, a bar chart (`chart1`),
    and a line chart (`chart2`). Use `properties()` to set the chart properties, such
    as the width and the title.
  prefs: []
  type: TYPE_NORMAL
- en: Layering
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Layering* lets you combine charts on top of each other, as shown in figure
    3.2\. In Altair, use the `alt.layer(chart1,chart2)` function to layer two charts,
    or the `+` operator (`chart1` `+` `chart2`). If each chart has a title and you
    don’t specify any general title for the compound chart, layering will set the
    title of the layered chart as that of the first chart.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 A bar chart layered with a line chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Horizontal concatenation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Horizontal concatenation* enables you to concatenate charts horizontally,
    as shown in figure 3.3\. In Altair, use the `alt.hconcat(chart1,chart2)` function
    to layer two charts or, alternatively, the `|` operator. Refer to 03/altair/hconcat.py
    for the complete example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 A bar chart concatenated horizontally with a line chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Vertical concatenation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Vertical concatenation* enables you to concatenate charts vertically, as shown
    in figure 3.4\. In Altair, use the `alt.vconcat(chart1,chart2)` function to layer
    two charts or the `&` operator. Refer to 03/altair/vconcat.py for the complete
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 A bar chart concatenated vertically with a line chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Repeated charts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *repeated chart* displays similar data views in a single visualization. With
    a repeated chart, you can create a set of charts, each displaying a subset of
    the data, by repeating a base chart using different data subsets or by changing
    a visual encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `repeat()` function to create a repeated chart in Altair. This function
    takes the list of fields for the repeat, as shown in the following listing and
    under 03/altair/ repeat.py.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.17 Building a repeated chart in Altair
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note  First, create the pandas DataFrame. Then, extract the list of fields to
    repeat and store them in the `fields` variable. Next, define the `repeat()` method
    with the rows and columns to repeat. Finally, use the `row` and `column` variables
    just defined as a variable of the chart encodings.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 shows the output of listing 3.17\. Altair has built 25 charts, one
    for each combination of the columns of the DataFrame specified in the `fields`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 A repeated chart varying the encodings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 3.2.5 Interactivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Interactivity* refers to the ability to manipulate visualizations through
    user input, such as hovering over data points, clicking legends, or dragging sliders.
    In Altair, use the `interactive()` method to enable features like zooming, panning,
    and hovering over data points to display tooltips. Listing 3.18 shows an example
    of how to make a chart interactive, and figure 3.6 shows the resulting chart.
    You can also find the complete example under 03/altair/interactive.py.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.18 Building an interactive chart in Altair
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note  First, create the pandas DataFrame. Then, build the Altair chart, appending
    the `interactive()` method at the end. Also, add a tooltip, which receives the
    list of DataFrame columns to show.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 A bar chart with interactivity enabled
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 3.2.6 Configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To configure the basic properties of a single chart, use the `properties()`
    method. For more complex properties and to configure a compound chart, instead,
    you must use *global configurations*. Altair supports many global configurations.
    In this section, we will describe axes, title, and view. We will wait to describe
    the other configurations until later in the book, when we will require them.
  prefs: []
  type: TYPE_NORMAL
- en: To show how configurations work, we will start with the chart described in figure
    3.7 and generated through the code in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.19 Defining the basic chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/3-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 The basic bar chart built by the default configuration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now, let’s start modifying the basic chart by configuring axes.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring axes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To configure axes at a global level, Altair supports three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configure_axis()`—Configures both axes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configure_axisX()`—Configures the x-axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configure_axisY()`—Configures the y-axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring axes enables you to customize several properties, such as labels,
    tick marks, and scales. The following listing shows an example, which you can
    also find under 03/altair/configure-axis.py.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.20 Configuring axes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets the label angle'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sets the font size of the axis title'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Sets the font size of the axis labels'
  prefs: []
  type: TYPE_NORMAL
- en: Note  Use `configure_axis()` to configure labels and titles in axes. As an alternative,
    use `configure_axisX()` to configure the x-axis and `configure_` `axisY()` configure
    the y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 shows the difference between the layouts when using `configure_axis()`
    (on the left) and not using `configure_axis()` (on the right).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 The difference between the layouts with `configure_axis()` and without
    `configure_axis()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Configuring title
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the `configure_title()` method to customize the title properties of your
    chart, such as color, font size, and font family. The following listing shows
    an example of how to use the `configure_title()` method, which you can also find
    under 03/altair/ configure-title.py.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.21 Configuring `title`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets the title font size'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sets the title color'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Sets the distance between the title and the chart'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Sets where to anchor the title'
  prefs: []
  type: TYPE_NORMAL
- en: Note  Use `configure_title()` to configure the title properties. The anchor
    must be either `None`, `start`, `middle`, or `end`.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 shows the difference between the layouts when using `configure_title()`
    (on the left) and not using `configure_title()` (on the right).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 The difference between the layouts with `configure_title()` and without
    `configure_title()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Configuring view
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the `configure_view()` method to customize the general view of the chart.
    The following listing shows an example of usage of the `configure_view()` method,
    which you can also find under 03/altair/configure-view.py.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.22 Configuring `view`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets the border stroke width'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sets the border stroke color'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Sets the background color'
  prefs: []
  type: TYPE_NORMAL
- en: Note  Use `configure_view()` to configure the general view of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 shows the difference between the layouts when using `configure_view()`
    (on the left) and not using `configure_view()` (on the right).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 The difference between the layouts with `configure_view()` and without
    `configure_view()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that you have learned the basic components of an Altair chart, let’s move
    to the next step: implementing a case study.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Case study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us imagine you work as a researcher at the Global Demographic Analysis Center
    (GDAC), who wants to study population growth in North America. For this study,
    you will be using the World Bank’s population dataset (released under the CC BY-4.0
    license, [https://data.worldbank.org/indicator/SP.POP.TOTL](https://data.worldbank.org/indicator/SP.POP.TOTL));
    you can find a cleaned version of the dataset in the GitHub repository for the
    book under CaseStudies/population/source/population.csv. The dataset contains
    the population from 1960 to 2021 for all the countries of the world, as shown
    in table 3.3\. The Country Name column also contains continents. You can find
    this case study’s complete code provided as a Jupyter Notebook in the book’s GitHub
    repository under CaseStudies/population/ population.ipynb. In this case, simply
    execute a cell with the chart variable to visualize an Altair chart.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.3 The population dataset
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Country Name | 1960 | … | 2021 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Aruba  | 54,608  |  | 106,537  |'
  prefs: []
  type: TYPE_TB
- en: '| …  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Zimbabwe  | 3,806,310  |  | 15,993,524  |'
  prefs: []
  type: TYPE_TB
- en: You start by drawing a raw chart in the following listing, showing all the trend
    lines from 1960 to 2021 for all the countries and continents. The Country Name
    column is dirty, so the resulting chart is very confusing, as shown in figure
    3.11.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.23 Drawing the raw chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses this Altair function for datasets with more than 5,000 rows'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Unpivots the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Draws the chart'
  prefs: []
  type: TYPE_NORMAL
- en: Note  Use `mark_line()` to draw the chart. To plot the different countries,
    use the `color` channel.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 The chart with raw data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The chart is very confusing because it presents the following problems: there
    are too many countries, there are too many colors, and it does not focus on North
    America. To solve these issues, let us use the DIKW pyramid, starting from the
    first step: turning data into information.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 From data to information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Turning data into information involves extracting insights from data. From the
    point of view of a chart, it means making the chart readable and understandable.
    Start by grouping countries by continent. The dataset already contains values
    for continents. List the countries using the `unique()` method provided by the
    pandas DataFrame applied to the Country Name column. For more details on the `unique()`
    method, please refer to appendix B. Note that the list of countries also contains
    the continents, so we can build a list of the continents and filter the DataFrame
    based on that list. Then, plot the resulting chart.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.24 Decluttering the chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines the list of continents'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Filters the DataFrame on the basis of the list'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Draws the chart'
  prefs: []
  type: TYPE_NORMAL
- en: Note  Group data by continents to reduce the number of lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.12 shows the resulting chart, which is more readable. However, it
    still presents some problems: there too many colors and it does not focus on North
    America. In practice, it is difficult to compare North America with the other
    continents.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 The chart with a focus on continents
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Change the chart by focusing on North America and grouping the other continents
    by calculating their average value, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.25 Focusing on North America
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a mask that selects only North America'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Calculates the average value for the continents not in the mask'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Builds a new DataFrame with North America and the average value of the other
    continents'
  prefs: []
  type: TYPE_NORMAL
- en: Note  Focus on North America, and calculate the average value of the other continents.
  prefs: []
  type: TYPE_NORMAL
- en: Then, draw the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.26 Drawing the chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Formats x labels'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Formats y labels'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Sets the range of colors'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Does not show the legend'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Disables grid'
  prefs: []
  type: TYPE_NORMAL
- en: Note  To format the x-axis labels, use the `format` parameter. Use `.0f` to
    show only the integer part. Also, use the `tickMinStep` parameter to set the distance
    between two labels. The example sets the value to `10`, thus labeling the decades.
    To format the y-axis labels, set the format parameter to `.2s`, using scientific
    notation with two significant figures.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 shows the resulting chart. We have omitted the legend for now and
    will add it later. The chart is clearer; however, the audience needs to do some
    calculations to understand the difference between the two lines.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 The chart focuses on North America.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When drawing a chart, do the calculations for the audience to serve them the
    ready-made dish. Let us calculate the difference from the starting year (1960)
    for both lines, thus making them comparable. The following listing shows how to
    calculate the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.27 Calculating the difference
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note  Calculate the baseline value for 1960, and then for each continent, calculate
    the difference between each year and the baseline.
  prefs: []
  type: TYPE_NORMAL
- en: Having calculated the difference, draw the chart. The code is similar to that
    in listing 3.23\. Change only the y-axis column to `Diff`. Figure 3.14 shows the
    resulting chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 The chart with a focus on the difference in population from 1960
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The chart clearly shows the difference between the two lines, although it is
    not explicit. To complete the chart, add a label for each line as an additional
    textual mark.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.28 Adding labels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sets the x position'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sets the y position'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note  Use `mark_text()` to set the line labels. We label the lines by placing
    a text annotation next to each line. We could have used the legend to label the
    lines, but as Cole Nussbaumer Knaflic says in her book, *Storytelling with Data:
    A Data Visualization Guide for Business Professionals* (John Wiley & Sons, 2015),
    it’s clearer to use text annotations for better clarity. To set the y text position,
    use the coordinates of the last point in each line. For the x, instead, slightly
    increase the coordinates of the last point in each line (e.g., 2023 in the example,
    while the last point is 2021).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, combine the textual mark and the original chart.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.29 Combining the chart and the text labels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note  Use `+` to combine the two layers. Then, use `configure_axis()`, `configure_title()`,
    and `configure_view()` to set the global chart configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 illustrates the resulting chart at the end of the information step.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-15.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 The chart at the end of the information step
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next step of the DIKW pyramid is turning information into knowledge. So
    let us proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 From information to knowledge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Turning information into knowledge involves adding context to the chart. We
    add three types of context: an annotation showing the gap between the two lines,
    an annotation containing the data source, and a text explaining the causes of
    this gap.'
  prefs: []
  type: TYPE_NORMAL
- en: Chart annotation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Chart annotation* aims to ease the audience’s life by making explicit the
    gap between the two lines. Figure 3.16 shows the annotation we are going to add
    to the chart. The annotation comprises two elements: a vertical line showing the
    gap between the two lines and a “big number” (BAN), a large number containing
    the gap value.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-16.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 The chart with an explicit annotation on the gap between North America
    and the rest of the world
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To draw the chart annotation, use `mark_line()` to draw the vertical line and
    `mark_ text()` to draw the text. The following listing describes how to render
    the previous annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.30 Adding the annotation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines the distance between the vertical line and the last point in the
    country line'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Calculates the last value for North America line'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Calculates the last value for the other line'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Draws the vertical line'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Places the BAN at the middle of the vertical line'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Draws the BAN'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Combines the charts'
  prefs: []
  type: TYPE_NORMAL
- en: Note  Use the last data points of the lines of the continents as y-coordinates
    for the vertical line and the BAN. We have hardcoded the BAN value for simplicity.
    However, you can dynamically calculate it in a complex scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Data source
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Place the data source as a textual annotation immediately under the title.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.31 Adding the data source
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note  Use the `mark_text()` mark to add a text to the chart. Also, set the `href`
    channel to the link to the data source.
  prefs: []
  type: TYPE_NORMAL
- en: Text annotation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Place the text annotation to the left of the graph to prepare your audience
    for the chart. The text explains the possible causes of the gap between North
    America and the other continents. The following listing describes how to add a
    text annotation to the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.32 Adding a text annotation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note  Use `mark_text()` to draw the text. Then, combine the text annotation
    with the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 shows the resulting chart at the end of the knowledge step.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-17.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 The chart at the end of the knowledge step
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The chart is almost ready. Let us proceed to the last step: turning knowledge
    into wisdom.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.3 From knowledge to wisdom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Turning knowledge into wisdom involves adding a call to action. In the previous
    chapters, we added a simple call to action in the title, inviting the audience
    to do something. However, in a real scenario, the call to action must include
    a proposal of possible next steps, justified with appropriate resources. The next
    step invites the audience to do something concrete; thus, the situation depicted
    in the chart changes. For example, you can add the call to action as an additional
    chart, which describes the percentage of success of each possible alternative.
    In our example, we can add a bar chart with possible strategies to improve population
    growth in North America. The percentages in the example are imaginary and do not
    reflect reality—we’ve added them just to show how a call to action works. The
    following listing shows how to build the call to action as a bar chart and add
    it to the main chart.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.33 Adding a call to action
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note  Draw a chart specifying the possible alternatives and their percentage
    of success.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 shows the final chart. Following the steps specified by the DIKW,
    we have transformed the raw chart of figure 3.11 into a data story.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-18.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 The final chart at the end of the wisdom step
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this chapter, you have learned the basic concepts of Altair. In the next
    chapter, you’ll review the basic concepts of generative AI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vega and Vega-Lite are visualization grammars to define the visual aspects and
    interactive features of a chart by writing code in JSON format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altair is built at the top of Vega-Lite and offers a user-friendly API to build
    charts. The basic components of an Altair chart are encodings, marks, conditions,
    compound charts, interactivity, and configurations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encodings define how data attributes (like x-coordinates, y-coordinates, color,
    and size) are visually represented in the chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marks are the visual elements in the chart, such as bars, points, lines, or
    areas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions specify how data attributes are mapped to visual properties based
    on different criteria.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compound charts involve combining multiple charts into a single view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactivity refers to the ability of the chart to respond or change based
    on user input or interactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations encompass various settings to alter the appearance of the chart,
    such as adjusting axes, scales, or layout, to better convey the intended information
    or aesthetics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data visualization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Belorkar, A., Guntuku, S. C., Hora, S., and Kumar, A. (2020). *Interactive Data
    Visualization with Python*. Packt Publishing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abbott, D. (2024). *Everyday Data Visualization*. Manning Publications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vega, Vega-Lite, and D3.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kats, P. and Katz, D. (2019). *Learn Python by Building Data Science Applications*.
    Packt Publications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meeks, E. and Dufour, A.M. (2024). *D3.js in Action*. Manning Publications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vega: A Visualization Grammar*. (n.d.). [https://vega.github.io/vega/](https://vega.github.io/vega/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vega-Lite: A Grammar of Interactive Graphics*. (n.d.). [https://vega.github.io/vega-lite/](https://vega.github.io/vega-lite/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Knaflic, C. N. (2015). Storytelling with Data: A Data Visualization Guide for
    Business Professionals. John Wiley & Sons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
