<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">10</span> </span><span class="chapter-title-text">Company information</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header"><span class="CharOverride-1">This chapter covers</span><span class="CharOverride-1"/></h3>
<ul>
<li class="readable-text" id="p2"><span class="CharOverride-2">Adding functionality to support a company dashboard</span></li>
<li class="readable-text" id="p3"><span class="CharOverride-2">Adding a Company Information component</span></li>
<li class="readable-text" id="p4"><span class="CharOverride-2">Adding a Recent ACH Batches component</span></li>
<li class="readable-text" id="p5"><span class="CharOverride-2">Adding an Expected Files component</span></li>
<li class="readable-text" id="p6"><span class="CharOverride-2">Adding a Company Limits component</span></li>
</ul>
</div>
<div class="readable-text" id="p7">
<p>This chapter looks at another iteration during our program increment. The business had previously mapped out the additional functionality regarding the storing and displaying of company information. Basically, the business is now requesting a dashboard at the company level. In addition, users have provided some input on additional functionality they would like to see implemented, which was not in the original scope of the project, and the business has asked us to include it as well. </p>
</div>
<div class="readable-text" id="p8">
<h2 class="readable-text-h2"><span class="num-string">10.1</span> Sprint planning</h2>
</div>
<div class="readable-text" id="p9">
<p>In this sprint, we create a dashboard that focuses on data at the company level. In addition to tables and APIs, there are four additional components that our team must create during this sprint:</p>
</div>
<ul>
<li class="readable-text" id="p10">Company information</li>
<li class="readable-text" id="p11">Recent batches</li>
<li class="readable-text" id="p12">Expected files</li>
<li class="readable-text" id="p13">Company limits</li>
</ul>
<div class="readable-text" id="p14">
<p>The company information tables are identified as blockers in our sprint because they must be designed and built before working on the components. It may be possible to start with some other components with little to no rework, as many of the tables for enhancements—such as the Expected Files component—only have a foreign key requirement back to the company ID. In such situations, it may be okay to start working without the foreign key, but other changes such as displaying customer information will require tables built to a certain extent. Figure 10.1 shows the Gantt chart created using PlantUML.</p>
</div>
<div class="browsable-container figure-container" id="p15">
<img alt="" height="562" src="../Images/CH10_F01_Kardell.png" style="width: 100%; max-width: max-content;" width="600"/>
<h5 class="figure-container-h5"><span class="">Figure 10.1</span><span class=""> </span><span class="">ACH dashboard enhancement timeline</span></h5>
</div>
<div class="readable-text" id="p16">
<h2 class="readable-text-h2"><span class="num-string">10.2</span> Company Information</h2>
</div>
<div class="readable-text" id="p17">
<p>As stated previously, this sprint is all about working with companies. Each ACH file consists of batches with various entry and addenda records. These batches are associated with companies. If the companies are customers of our financial institution, we have an opportunity to provide various reports and controls around them. It is important to understand that the batches are not necessarily from companies associated with our institution—they may be from another company or partners we work with to deliver transactions to the institution. The company dashboard and components we build for it will provide additional ACH-processing services to our customers. While these components can be indispensable to the company as they provide the potential for additional auditing, alerts, and controls, they are not part of the ACH standard. </p>
</div>
<div class="readable-text intended-text" id="p18">
<p> We have to create database tables and APIs to support storing and accessing the company information in our database. The companies are business customers of our financial institution, and as such, we want to provide them with additional information and controls of ACH files that are beyond what may be typically needed for a personal customer. For instance, processing ACH batches for our personal customers usually results in posting paychecks and other prearranged payments or debits. From an individual’s perspective, there is no interest in the batch information and statistics except that the resulting transaction within the batch posts to their account correctly.</p>
</div>
<div class="readable-text intended-text" id="p19">
<p>If we contrast that to business customers (companies), they may very well be interested in the batch information because they will be able to tell the totals for all transactions within the batch. Similar to personal customers managing their account balances for individual transactions, companies need to be aware of all the transactions within the batch because they affect the company.</p>
</div>
<div class="readable-text intended-text" id="p20">
<p>While we may receive and process ACH batches from companies that are not customers of our financial institution, in cases where they are, we want to provide additional details about the batch. By creating database tables for these companies, we also open the possibility to originate files in addition to receiving files to process, as we have been doing throughout the project. Originating ACH files is beyond the scope of the current development, but it is something that we could look at to enhance our project as a logical next step in building a fully functional ACH system. We will be populating our company tables with dummy data to give ourselves something to work with throughout the chapter.</p>
</div>
<div class="readable-text" id="p21">
<h3 class="readable-text-h3"><span class="num-string">10.2.1</span> Database design: Company information</h3>
</div>
<div class="readable-text" id="p22">
<p>In addition to the <code>audit_log</code> in chapter 9 (listing 9.20) and the <code>bank_routing_numbers</code> table in chapter 8, we had to add many tables that were not specifically ACH related. With supporting company information, we now get to add a few more tables and supporting types. First, it makes sense to start with the company table and see what we need to keep track of.</p>
</div>
<div class="readable-text intended-text" id="p23">
<p>Listing 10.1 introduces a couple of custom types into our database. For both the <code>tax_id_type</code> and <code>industry</code> fields, we created new custom types to provide some validation and assist with data entry. These custom types help enforce the values of data we expect to be present in the field, which prevents entering erroneous data.</p>
</div>
<div class="readable-text intended-text" id="p24">
<p>The <code>tax_id_type</code> and <code>tax_id_number</code> are correalted because in the United States, there is more than just the Social Security Number (SSN) that individuals are assigned, such as Employer Identification Number (EIN) and Individual Tax Identification Number (ITIN) just to name a few. So, we give the field a more general name instead of simply calling it <code>ssn</code> or <code>ein</code>. We default to <code>EIN</code> because companies are more likely to use an EIN number.</p>
</div>
<div class="readable-text intended-text" id="p25">
<p>The <code>industry</code> is used for reporting purposes so that various reporting and marketing campaigns can filter out industries when users wish to drill down or create reports based on industries. The <code>logo</code> field is used to store an image for the company so that the image can be loaded onto the company page as necessary and only serves to make the pages and reporting a bit nicer. We use a new type <code>BYTEA</code>, which can store binary data. While we would benefit from having the logo stored outside the database in terms of UI performance, being able to keep things within the database prevents us from having to introduce other technologies such as AWS S3 or a CDN. </p>
</div>
<div class="readable-text intended-text" id="p26">
<p>Listing 10.1 shows the <code>create</code> <code>table</code> statement. The <code>ach_company_id</code> is used to identify the company within ACH. This field corresponds to the company identification field on the batch header record (type 5) in an ACH system. While it is common to use the EIN number or some variation of it, using it is not obligatory. We only need to keep in mind that the field is 10 positions long and should be padded with leading zeros when the file is created to maintain file formatting.</p>
</div>
<div class="browsable-container listing-container" id="p27">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.1<span class="CharOverride-5"> </span>Table to store company details</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TABLE company (
    company_id UUID PRIMARY KEY 
                     DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    tax_id_type TIN_TYPE NOT NULL DEFAULT 'EIN',  #1
    tax_id_number VARCHAR(9) NOT NULL,
    ach_company_id NUMERIC(10) NOT NULL, #2
    duns NUMERIC(9) DEFAULT NULL,  #3
    logo BYTEA DEFAULT NULL,   #4
    website VARCHAR(255) DEFAULT NULL,
    industry INDUSTRY_TYPE DEFAULT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines the tax_id_type with a default value of EIN since, most likely, this will be the type of value used</span>
<br/>#2 
     <span class="CharOverride-6">The company identification number used on the ACH type 5 record (batch header)</span>
<br/>#3 
     <span class="CharOverride-6">Many companies have a DUNS number, required for many services when registering as a company.</span>
<br/>#4 
     <span class="CharOverride-6">We store the logo as BYTEA so that we can upload an image to the database. Typically, this is a URL for the location where the image is stored. Storing it in our database was only for convenience.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p28">
<p>The custom types in the previous listing need to be defined before creating the table. Creating the types is a straightforward process, and having these custom types helps us with an additional level of validation for the database and fields. The approach of course can vary, depending on our application’s needs. For instance, it would also be acceptable to store these as strings in the database, or perhaps as a numeric value, while having the labels stored in another location.</p>
</div>
<div class="readable-text intended-text" id="p29">
<p>Depending on several factors (company policy, team members, application, database, etc.) it may be preferable to store the values in another table rather than defining a type in the database to avoid database change requests. Since we have limited values, and there is no need for them to change very often, we are comfortable with defining them as types. The following listing shows creating of our <code>industry_type</code> and <code>tin_type</code>.</p>
</div>
<div class="browsable-container listing-container" id="p30">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.2<span class="CharOverride-5"> </span>The <code>industry_type</code> and <code>tin_type</code></h5>
<div class="code-area-container">
<pre class="code-area">CREATE TYPE industry_type AS ENUM ('basic materials', …, 'utilities');

CREATE TYPE tin_type AS ENUM ('SSN', 'EIN', 'ITIN', 'ATIN', 'PTIN');</pre>
</div>
</div>
<div class="readable-text" id="p31">
<p>As shown, creating a type to store values is simple. Another concern we may have—which is also a reason why team members may argue for using separate tables—is the ability to extract the list of valid values (e.g., if we wanted to build a dynamic drop-down of the valid values for the <code>tin_type</code> on the UI side). The following listing shows how to extract the labels for an <code>ENUM</code> type. </p>
</div>
<div class="browsable-container listing-container" id="p32">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.3<span class="CharOverride-5"> </span>Returning the labels for an <code>ENUM</code> in Postgres</h5>
<div class="code-area-container">
<pre class="code-area">SELECT e.enumlabel AS label  #1
  FROM pg_type AS t #2
  JOIN pg_enum AS e   #2
    ON t.oid = e.enumtypid #2
 WHERE t.typname = 'tin_type'; #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Returns the label </span>
<span class="CharOverride-6">for our ENUM</span>
<br/>#2 
     <span class="CharOverride-6">Postgres tables needed to return the ENUM label</span>
<br/>#3 
     <span class="CharOverride-6">The specific ENUM type we are interested in</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p33">
<p>Once we have our company table in place, we can create an address table. It will show two addresses—the mailing and a street address—which we define with <code>address_type</code>. The rest of the table is standard in terms of what we need to store. We allow four lines for an address to cover apartment/floor numbers or additional information, plus other standard fields such as city, state, and zip.</p>
</div>
<div class="browsable-container listing-container" id="p34">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.4<span class="CharOverride-5"> </span>The <code>address_type</code> and table</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TYPE address_type AS ENUM ('mailing', 'street'); #1

CREATE TABLE company_address (
    company_address_id UUID DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES company(company_id)    #2
                           ON DELETE CASCADE ON UPDATE CASCADE, 
    address_type ADDRESS_TYPE NOT NULL DEFAULT 'mailing',  #3
    address_line_1 VARCHAR(255) NOT NULL,     #4
    address_line_2 VARCHAR(255) DEFAULT NULL,  #4
    address_line_3 VARCHAR(255) DEFAULT NULL,  #4
    address_line_4 VARCHAR(255) DEFAULT NULL, 
    city VARCHAR(255) NOT NULL,   #5
    state VARCHAR(2) NOT NULL,     #5
    zip_code NUMERIC(5) NOT NULL,   #5
    zip_code_4 NUMERIC(4) DEFAULT NULL, 
    created_at TIMESTAMP NOT NULL DEFAULT NOW(), #6
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(), 
    PRIMARY KEY (company_id, address_type)  #7
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines possible mailing address types</span>
<br/>#2 
     <span class="CharOverride-6">This record is tied to the company, so a foreign key is defined.</span>
<br/>#3 
     <span class="CharOverride-6">Defaults the address_type to a mailing address</span>
<br/>#4 
     <span class="CharOverride-6">Standard address lines with room for department or floor numbers</span>
<br/>#5 
     <span class="CharOverride-6">Standard address lines</span>
<br/>#6 
     <span class="CharOverride-6">Fields that can </span>
<span class="CharOverride-6">help with auditing</span>
<br/>#7 
     <span class="CharOverride-6">Prevents more than one type of address for a company by defining a primary key that also uses the address_type</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p35">
<p>We also created a table named <code>company_phone</code> to store phone numbers for the company. Again, we define a <code>phone_type</code> to identify different categories of phones. We also define a primary key of the company and phone type so that each company can have only one type of phone defined. Another restriction is to have unique <code>phone_number</code> and <code>extension</code> so that a phone number cannot be reused.</p>
</div>
<div class="browsable-container listing-container" id="p36">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.5<span class="CharOverride-5"> </span>The <code>company_phone</code> type and table</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TYPE phone_type AS ENUM ( 'main', 'direct', 'department', #1
'fax', 'toll-free', 'mobile', 'home', 'other');   

CREATE TABLE company_phone (
    company_phone_id UUID DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES company(company_id) #2
                             ON DELETE CASCADE ON UPDATE CASCADE, 
    phone_type VARCHAR(25) NOT NULL,  #3
    phone_number NUMERIC(10) NOT NULL,  #3
    extension NUMERIC(5) DEFAULT NULL,  #3
    created_at TIMESTAMP NOT NULL DEFAULT NOW(), #4
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(), 
    PRIMARY KEY (company_id, phone_type), #5
    UNIQUE (phone_number, extension) #6
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines possible values for types of phones</span>
<br/>#2 
     <span class="CharOverride-6">The table is associated with the company table with a foreign key.</span>
<br/>#3 
     <span class="CharOverride-6">Phone number fields</span>
<br/>#4 
     <span class="CharOverride-6">Audit fields</span>
<br/>#5 
     <span class="CharOverride-6">Prevents having more than </span>
<span class="CharOverride-6">one type of phone per company</span>
<br/>#6 
     <span class="CharOverride-6">Prevents more than one phone number from being used</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p37">
<p>We should now have more than enough database structure to support companies in our ACH dashboard. Much of this information is not strictly necessary when working with ACH files, but the additional information will be useful for expanding our project with different functionality.</p>
</div>
<div class="readable-text" id="p38">
<h3 class="readable-text-h3"><span class="num-string">10.2.2</span> Using generative AI to generate mock data </h3>
</div>
<div class="readable-text" id="p39">
<p>We can use generative AI to help boost our productivity by creating some test data for our companies. Using the industries we defined for our SQL type <code>industry_type</code>, we can instruct ChatGPT to do the following:</p>
</div>
<div class="readable-text prompt" id="p40">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Given this list of industries “'basic materials,’ . . . 'utilities’,” create fake company names, address information, and logos for each industry.</p>
</div>
<div class="readable-text" id="p41">
<p>We were provided with company names such as Elemental Resource Inc. with the address of 123 Mineral Lane, Boulder, CO 80301. We also asked for randomly generated EIN and DUNS numbers. It is also possible to see whether ChatGPT can share with us any interesting phone numbers that we can include in our data. For instance, here are two amusing ones if you have anyone on your team who likes Phil Collins or Hall and Oates: </p>
</div>
<ul>
<li class="readable-text" id="p42">424-888-PHIL (7445), known as the Phil Call-Ins Hotline, where you can listen to songs from Phil Collins.</li>
<li class="readable-text" id="p43">719-266-OATES (2837), known as the Callin Oates Hotline, where you can listen to a variety of songs from Hall and Oates.</li>
</ul>
<div class="readable-text" id="p44">
<p>While having some fun test data can brighten our day, we need to get all that data incorporated into SQL as well. Up until this point, we have been keeping all our SQL in the init.sql in the Dockerfile to create tables and data. With the need to input the generated company data, we want to do a bit of restructuring. We create a subfolder named <code>sql</code> and move all the <code>SQL</code> commands that currently exist in init.sql, while breaking them up into different files. It should be easier now to manage and update our SQL as necessary. The following listing shows the new structure of our Docker folders.</p>
</div>
<div class="browsable-container listing-container" id="p45">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.6<span class="CharOverride-5"> </span>Docker folder structure for the database</h5>
<div class="code-area-container">
<pre class="code-area">docker/
├─ db/
│  ├─ sql_scripts/
│  │  ├─ sql/
│  │  │  ├─ create_tables.sql
│  │  │  ├─ general_ach_data.sql
│  │  │  ├─ elemental_resources_inc.sql
│  │  ├─ init.sql</pre>
</div>
</div>
<div class="readable-text" id="p46">
<p>Next, we update init.sql so that it references the new files.</p>
</div>
<div class="browsable-container listing-container" id="p47">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.7<span class="CharOverride-5"> </span>Updating the init.sql file</h5>
<div class="code-area-container">
<pre class="code-area">…
\i /docker-entrypoint-initdb.d/sql/create_tables.sql #1
\i /docker-entrypoint-initdb.d/sql/general_ach_data.sql #2
\i /docker-entrypoint-initdb.d/sql/ #3
<span class="CharOverride-8">➥</span>elemental_resources_inc.sql
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Includes the creation</span>
<span class="CharOverride-6">of tables</span>
<br/>#2 
     <span class="CharOverride-6">Includes general ACH data such as exception information</span>
<br/>#3 
     <span class="CharOverride-6">Each company can be stored in its own file.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p48">
<p>Each company is added with the following SQL.</p>
</div>
<div class="browsable-container listing-container" id="p49">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.8<span class="CharOverride-5"> </span>Adding a company</h5>
<div class="code-area-container">
<pre class="code-area">DO
$$
    DECLARE
        saved_uuid UUID; #1
    BEGIN
        WITH company_insert AS (        #2
            INSERT INTO company (name, tax_id_number, #3
                                duns, industry, logo)  #4
                VALUES ('Elemental Resources Inc.', 459876543,  #4
        123456789, 'basic materials', 'data:image/webp;base64,...') 
                RETURNING company_id #4
        ) 
        SELECT company_id INTO saved_uuid FROM company_insert; #5

        INSERT INTO company_address (saved_uuid, address_line_1, #6
                                     city, state, zip_code)   #7
        VALUES (saved_uuid, '123 Mineral Lane',  #7
               'Boulder', 'CO', 80301); 

        INSERT INTO company_phone (saved_uuid, phone_number) #7
        VALUES (saved_uuid, '7192662837'); 
    END
$$;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Creates a variable saved_uuid as </span>
<span class="CharOverride-6">we need it for the other inserts to satisfy the foreign key constraint</span>
<br/>#2 
     <span class="CharOverride-6">Uses a CTE to </span>
<span class="CharOverride-6">insert the company</span>
<br/>#3 
     <span class="CharOverride-6">Inserts a record </span>
<span class="CharOverride-6">with our test data</span>
<br/>#4 
     <span class="CharOverride-6">Returns the company_id </span>
<span class="CharOverride-6">assigned by the database</span>
<br/>#5 
     <span class="CharOverride-6">Uses our CTE to save the company_id into our saved_uuid</span>
<br/>#6 
     <span class="CharOverride-6">Inserts the address using the stored company ID</span>
<br/>#7 
     <span class="CharOverride-6">Inserts the phone using the stored company ID</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p50">
<p>We can tell ChatGPT to use the previous listing as a template to insert the company data it generated previously. Having ChatGPT generate some of this setup code makes it easier to get some default companies added to the database. We certainly could have done it ourselves, but it would have been somewhat tedious and error prone as we copied/pasted the data.</p>
</div>
<div class="readable-text" id="p51">
<h3 class="readable-text-h3"><span class="num-string">10.2.3</span> API design </h3>
</div>
<div class="readable-text" id="p52">
<p>We start with a simple unit test with a new twist to ensure that we can get a <code>200</code> <code>HTTP</code> response code, which will indicate we are reaching the endpoint successfully. As we have seen, we have default companies that are loaded into the database when our container is started. Typically, we have been clearing our database for each test using <code>SqlUtils().truncate_all(),</code> and if we wanted to avoid truncating a table, we would need to update that method to exclude that particular table. Running our tests in this fashion also required the containers to be up and running.</p>
</div>
<div class="readable-text intended-text" id="p53">
<p>We will now create a test that uses Testcontainers to start and stop our containers so that we receive a fresh database every time. This makes the test self-contained, which is perfect for when we must move our project into a CI/CD environment.</p>
</div>
<div class="browsable-container listing-container" id="p54">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.9<span class="CharOverride-5"> </span>Initial unit test with Testcontainers</h5>
<div class="code-area-container">
<pre class="code-area">…
@pytest.fixture(scope="class") #1
def client():  #1
    return TestClient(app)  #1


@pytest.fixture(scope="module") #2
def docker_compose():   #2
    absolute_path = Path("../../../../docker/db").resolve()  #2
    with DockerCompose(absolute_path) as compose:  #2
        compose.start()  #2
        yield compose #2
        compose.stop()  #2


class TestCompanyApis:

    @pytest.fixture(autouse=True) #3
    def mock_client_host(self):  #3
        with patch(  #3
            "fastapi.Request.client",  #3
            new_callable=lambda: type("Client", (),   #3
                             {"host": "127.0.0.1"}),  #3
        ):  #3
            yield #3

    def test_get_companies(self, client, docker_compose): #4
        response = client.get("/api/v1/companies")  #5
        assert response.status_code == 200, response.text #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines a fixture </span>
<span class="CharOverride-6">to make test calls</span>
<br/>#2 
     <span class="CharOverride-6">Defines the container using Docker Compose because we have been using it throughout the project. Everything is set up as expected.</span>
<br/>#3 
     <span class="CharOverride-6">Defines an IP address for our record</span>
<br/>#4 
     <span class="CharOverride-6">Defines a test that validates we return successfully; further validation can be done for the response as well.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p55">
<p>We now have a way to run tests in an isolated environment. The more we isolate our tests and keep them self-contained, the easier it will be for the rest of the team to run them in their own environment. That way, we can avoid the WOMM (Works on My Machine) problems—a common theme in software development.</p>
</div>
<div class="readable-text intended-text" id="p56">
<p>We now follow the same formula as for previous APIs. We first create a record that we can return and that contains some company information we will display as an overview. At this point, we just want to be able to display a list of companies that users can then drill down into. In the following listing, we define an enumeration for the <code>IndustryType</code>.</p>
</div>
<div class="browsable-container listing-container" id="p57">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.10<span class="CharOverride-5"> </span>The <code>IndustryType</code> enumeration</h5>
<div class="code-area-container">
<pre class="code-area">class IndustryType(Enum):
    BASIC_MATERIALS = "basic materials"
    CONSUMER_GOODS = "consumer goods"
    CONSUMER_SERVICES = "consumer services"
    FINANCIALS = "financials"
    HEALTHCARE = "healthcare"
    INDUSTRIALS = "industrials"
    OIL_AND_GAS = "oil &amp; gas"
    TECHNOLOGY = "technology"
    TELECOMMUNICATIONS = "telecommunications"
    UTILITIES = "utilities"</pre>
</div>
</div>
<div class="readable-text" id="p58">
<p>We define a <code>CompanyOverviewRecord</code> as shown in the following listing. While you have seen most of this code before, we do include a regular expression to verify the image is a valid format for displaying on the page.</p>
</div>
<div class="browsable-container listing-container" id="p59">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.11<span class="CharOverride-5"> </span>The <code>CompanyOverview</code> Record</h5>
<div class="code-area-container">
<pre class="code-area">class CompanyOverviewRecord(BaseModel):
    company_id: Optional[UUID4] = Field(
        None,
        title="Company ID",
        description="Unique identifier for the company.",
    )
    name: Optional[str] = Field(
        None,
        title="Name",
        description="Name of the company.",
        max_length=255,
    )
    industry: Optional[IndustryType] = Field( #1
        None,
        title="Industry",
        description="Type of industry the company operates in.",
    )
    logo: Optional[str] = Field(
        None,
        title="Logo",
        description="Base64 Image of the Logo.", #2
        <span>pattern=r"^data:image\/[a-zA-Z]+; </span>#3
<span class="CharOverride-8">➥</span><span>base64,[A-Za-z0-9+/=]+$" </span>
<span>    </span>)</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">We use the IndustryType to help with validation.</span>
<br/>#2 
     <span class="CharOverride-6">States that the logo should be Base64</span>
<br/>#3 
     <span class="CharOverride-6">Enforces the correct format with a regular expression</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p60">
<p>Next, we create a class to handle any SQL calls dealing with companies. The following listing shows the simple <code>SELECT</code> statement using a <code>row_factory</code> of <code>class_row</code>. In such cases where we are simply returning the data and not performing data manipulation, we could also use the <code>dict_row </code>just as easily—the choice really depends on our application needs.</p>
</div>
<div class="browsable-container listing-container" id="p61">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.12<span class="CharOverride-5"> </span> <code>CompaniesSql </code>class</h5>
<div class="code-area-container">
<pre class="code-area">class CompaniesSql:

    def get_all_companies(self) -&gt; list[CompanyOverviewRecord]:
        with get_db_connection(row_factory= #1
<span class="CharOverride-8">➥</span>class_row(CompanyOverviewRecord)) as conn: 
            result = conn.execute(
                """
                SELECT company_id, name, industry, logo FROM companies #2
                """,
                [],
            )

        records = result.fetchall() #3

        return records</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Retrieves the database connection and sets the row_factory to a class_row for the CompanyOverviewRecord</span>
<br/>#2 
     <span class="CharOverride-6">Limits the fields we are returning; we prefer specific fields rather than “*”.</span>
<br/>#3 
     <span class="CharOverride-6">Returns all records</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p62">
<p>We are almost there! Now we need to add the endpoint. We have built the pieces starting from the bottom as we feel that makes things more reasonable as we develop the API. However, we could have started with defining the endpoint, drilling down to details of retrieving the data.</p>
</div>
<div class="browsable-container listing-container" id="p63">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.13<span class="CharOverride-5"> </span>Getting the endpoint for all companies </h5>
<div class="code-area-container">
<pre class="code-area">router = APIRouter(prefix="/api/v1/companies") #1
…
@router.get(  #2
    path="",  #2
    response_model=list[CompanyOverviewRecord],  #2
    summary="Retrieve an Overview of Companies",  #2
    description="Return a list of defined companies.",  #2
    response_description="An overview of the company.",  #2
    tags=["Company"],  #2
)
@log_message("Company Overview") #3
async def get_company_overview(request: Request) -&gt;   #4
list[CompanyOverviewRecord]: 
    return CompaniesSql().get_all_companies() #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">We assign a prefix for all the endpoints.</span>
<br/>#2 
     <span class="CharOverride-6">Standard documentation for the API</span>
<br/>#3 
     <span class="CharOverride-6">Our annotation to provide some audit information for the API</span>
<br/>#4 
     <span class="CharOverride-6">Defines the function and that it will return a list of CompanyOverviewRecords</span>
<br/>#5 
     <span class="CharOverride-6">The SQL call for getting all companies</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p64">
<p>Finally, we only need to add the router to our main.py. We do a little refactoring to add the routers into an array and loop through them instead of having multiple <code>include_router</code> statements. The following listing shows the refactoring results.</p>
</div>
<div class="browsable-container listing-container" id="p65">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.14<span class="CharOverride-5"> </span>Refactored <code>app.include_router</code></h5>
<div class="code-area-container">
<pre class="code-area">routers = [files.router, audit.router, #1
<span class="CharOverride-8">➥</span> companies.router] 
for router in routers: #2
    app.include_router(router) </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines an array of routers</span>
<br/>#2 
     <span class="CharOverride-6">Loops through them and includes each </span>
<span class="CharOverride-6">of them, which prevents the somewhat redundant include_router statements</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p66">
<p>With that, we have a passing test, but we should not stop here. It is important to validate the data being returned as well, not only that we received a valid response code of <code>200</code>. We should take a moment to think about what else needs to be validated to feel confident in publishing the code with a passing test. </p>
</div>
<div class="readable-text intended-text" id="p67">
<p>In this case, we could receive a <code>200</code>-response code but not receive any companies. If the database has been populated with company data, should we check whether those company names exist? Or maybe there is a subset of those companies? We only want to drive home the point that the purpose of testing is to have confidence in the code we have written. Even if we do not intend to publish our code to production after successful automated testing, having a test suite that covers and tests our code so thoroughly that we feel confident in publishing it is a valuable goal.</p>
</div>
<div class="readable-text intended-text" id="p68">
<p>On the side note, in addition to the ability to read companies from the database, for a fully functioning dashboard, we also need the ability to add, update, and delete. This would be a great time to take a break from reading, pull down one of the project versions, and get busy with some full stack development!</p>
</div>
<div class="readable-text" id="p69">
<h3 class="readable-text-h3"><span class="num-string">10.2.4</span> User interface</h3>
</div>
<div class="readable-text" id="p70">
<p>The first step in creating the user interface is to add a button to NavButtons.tsx so that we can navigate to the new page. Finding an appropriate icon should be the hardest part of this process. Luckily, Material UI has more than enough icons to choose from.</p>
</div>
<div class="browsable-container listing-container" id="p71">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.15<span class="CharOverride-5"> </span>NavButtons.tsx</h5>
<div class="code-area-container">
<pre class="code-area">&lt;ListItemButton onClick={() =&gt; route.push("/companies")}&gt; #1
   <span>&lt;ListItemIcon&gt; </span>#2
<span>      &lt;Store/&gt; </span> #2
<span>      &lt;/ListItemIcon&gt; </span>
<span>   </span>&lt;ListItemText primary="Companies"/&gt; #3
&lt;/ListItemButton&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">When the navigation button is clicked, we navigate to the companies page.</span>
<br/>#2 
     <span class="CharOverride-6"> Defines the icon to display</span>
<br/>#3 
     <span class="CharOverride-6">Sets the text to Companies</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p72">
<p>When navigating to the company page, there will be a list of companies provided. We use the same pattern as for other pages. The page.tsx makes the API call retrieve the information about the companies, and we pass it to another component that does the actual work to display it.</p>
</div>
<div class="browsable-container listing-container" id="p73">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.16<span class="CharOverride-5"> </span>The <code>CompanyListing</code> page</h5>
<div class="code-area-container">
<pre class="code-area">export default function CompaniesOverviewPage() { #1

    const [companies, setCompanies] =  #2
useState&lt;CompaniesListingResponse[]&gt;([]); 

    useEffect(() =&gt; {
        const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? ''; #3
        axios.get&lt;CompaniesListingResponse[]&gt; #4
<span class="CharOverride-8">➥</span>(`${apiUrl}/companies`, { 
…
            .then(response =&gt; { #5
                setCompanies(response.data); 
            })
…
                    &lt;CompaniesListing companies={companies}/&gt; #6
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines a function </span>
<span class="CharOverride-6">for the page</span>
<br/>#2 
     <span class="CharOverride-6">Variable to store the companies; defaulted to an empty array</span>
<br/>#3 
     <span class="CharOverride-6">The URL for the API; defaults to an empty string when the environment variable is not defined</span>
<br/>#4 
     <span class="CharOverride-6">API call</span>
<br/>#5 
     <span class="CharOverride-6">When the response is successful, sets the companies from the response data</span>
<br/>#6 
     <span class="CharOverride-6">Passes the companies down to the CompaniesListing</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p74">
<p>The <code>CompaniesListing</code> component, shown in the following listing, adds several new items that we have not used. The <code>onRowClick</code> for the DataGrid element allows us to click anywhere on the row and navigate to details about that company and the row height property so that we can see the company images a bit better. We also created an <code>ImageBase64</code> to encapsulate some of the needed pieces to display an image.</p>
</div>
<div class="browsable-container listing-container" id="p75">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.17<span class="CharOverride-5"> </span>The <code>CompanyListing</code> component</h5>
<div class="code-area-container">
<pre class="code-area">interface CompaniesListingProps {  #1
    companies: CompaniesListingResponse[];  #1
}  #1

export default function CompaniesListing({companies}: #2
Readonly&lt;CompaniesListingProps&gt;) { 

    const route = useRouter(); #3
    const columns: GridColDef[] = [ #4
        {field: 'view', headerName: '', sortable: false,
            width: 100, renderCell: (params) =&gt; (
            &lt;ImageBase64 base64={params.row.logo} #5
                         alt={params.row.name}  #5
                         width="100%" maxWidth="200px" /&gt;  #5
            )},
        {field: 'name', headerName: 'Name', width: 300 },
        {field: 'industry', headerName: 'Industry', width: 150 },
    ];

    const handleRowClick = (params: { id: any; }) =&gt; { #6
        const companyId = params.id;  #7
        route.push(`/companies/${companyId}/dashboard`);  #7
    };  #7
…
       &lt;DataGrid
          rowHeight={100}
          columns={columns} 
          rows={companies} 
          getRowId={(row) =&gt; row.company_id}
          onRowClick={handleRowClick} #7
       /&gt;
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines the properties for this component</span>
<br/>#2 
     <span class="CharOverride-6">The function defines the properties as Readonly.</span>
<br/>#3 
     <span class="CharOverride-6">Obtains a router object so that we can navigate as necessary</span>
<br/>#4 
     <span class="CharOverride-6">Columns definitions </span>
<span class="CharOverride-6">for the DataGrid</span>
<br/>#5 
     <span class="CharOverride-6">An image element </span>
<span class="CharOverride-6">that can display </span>
<span class="CharOverride-6">the company logo</span>
<br/>#6 
     <span class="CharOverride-6">Defines the row click method that </span>
<span class="CharOverride-6">executes when a row is clicked and </span>
<span class="CharOverride-6">takes us to the company dashboard</span>
<br/>#7 
     <span class="CharOverride-6">Uses onRowClick to handle the user clicking a row on the DataGrid</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p76">
<p>The <code>ImageBase64</code> is straightforward—we have a routine to ensure that the image is in the correct format, as seen in the following listing. This allows us to perform validation, and we return an empty string if we do not have a correctly formatted string.</p>
</div>
<div class="browsable-container listing-container" id="p77">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.18<span class="CharOverride-5"> </span><code>Base64</code> image</h5>
<div class="code-area-container">
<pre class="code-area">const isBase64Image = (base64: string) =&gt; {  #1
    const regex = /^data:image\/[a-zA-Z]+;base64,/;  #1
    if (!regex.test(base64)) {  #1
        return '';  #1
    } else {  #1
        return base64;  #1
    }  #1
}  #1

export default function ImageBase64({base64, #2
      alt = 'Image',  width = '100%',  maxWidth = '100px'}:  #3
<span class="CharOverride-8">➥</span> Readonly&lt;ImageProps&gt;) {  #3

    const imageSource = isBase64Image(base64); #3

    return (
        &lt;Box  #4
            component="img"  #4
            src={imageSource}  #4
            alt={alt}  #4
            sx={{  #4
                width: width,  #4
                maxWidth: maxWidth,  #4
            }}  #4
        /&gt;  #4
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">A function to ensure we have a src string formatted correctly to display the image in the source tag. If not, we return an empty string, which will display the alt tags for the image.</span>
<br/>#2 
     <span class="CharOverride-6">Defines the component to allow for multiple properties and default values if they are not passed</span>
<br/>#3 
     <span class="CharOverride-6">Assigns the result of the function call to isBase64Image to imageSource</span>
<br/>#4 
     <span class="CharOverride-6">There is no img component; instead, the appropriate parameters are passed </span>
<span class="CharOverride-6">to a Box element.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p78">
<p>We could certainly have just used a <code>Box</code> element in our component or page, but wrapping the element and treating it as its own component has some benefits. We can use this tactic in multiple areas and enforce consistency throughout the code. Having a dedicated <code>ImageBase64</code> may be a too specific. We could create a more general element and pass a type to it that determines the type of <code>src</code> we are using and performs the necessary validation.</p>
</div>
<div class="readable-text intended-text" id="p79">
<p>At this point, we have the database structure to store company information and the APIs to access the information about the company. We have also created a component capable of listing our companies, as shown in figure 10.2</p>
</div>
<div class="browsable-container figure-container" id="p80">
<img alt="A screenshot of a computer  Description automatically generated" height="582" src="../Images/CH10_F02_Kardell.png" style="width: 100%; max-width: max-content;" width="521"/>
<h5 class="figure-container-h5"><span class="">Figure 10.2</span><span class=""> </span><span class="">Component for listing the companies</span></h5>
</div>
<div class="readable-text" id="p81">
<p>Now that we can view the companies in our database, we begin putting our company dashboard together.</p>
</div>
<div class="readable-text" id="p82">
<h2 class="readable-text-h2"><span class="num-string">10.3</span> Company dashboard</h2>
</div>
<div class="readable-text" id="p83">
<p>With a way to navigate to a listing of companies in place, we want to be able to display a company-level dashboard. This feature will allow us to create a few other components that—although not necessarily unique to companies (we could incorporate versions of these components at the file level)—can provide information specific to companies and present other directions for our application to grow.</p>
</div>
<div class="readable-text" id="p84">
<h3 class="readable-text-h3"><span class="num-string">10.3.1</span> Navigation for the company dashboard</h3>
</div>
<div class="readable-text" id="p85">
<p>With a way to view all the companies, we want to be able to drill down and get to the company dashboard. The structure required to support the company listing and dashboard is shown in listing 10.19.</p>
</div>
<div class="browsable-container listing-container" id="p86">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.19<span class="CharOverride-5"> </span>UI structure for companies</h5>
<div class="code-area-container">
<pre class="code-area">src/
├─ app/
│  ├─ companies/
│  │  ├─ [companyId]/
│  │  │  ├─ dashboard/
│  │  │  │  ├─ page.tsx #1
│  │  ├─ page.tsx #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">This page will contain the company specific dashboard; the [companyID] will be the UUID of the company.</span>
<br/>#2 
     <span class="CharOverride-6">This is the page that displays the company listing shown in figure 10.2.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p87">
<p>With the page structure set up, we only need to create an empty dashboard page that can be populated with the company-specific components. We can use our file-level dashboard as a template.</p>
</div>
<div class="browsable-container listing-container" id="p88">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.20<span class="CharOverride-5"> </span>Empty company dashboard</h5>
<div class="code-area-container">
<pre class="code-area">…
export default function CompanyDashboard({params}: any) {

    const companyId: string = params.companyId; #1
    const [company, setCompany] 
                     = useState&lt;Company | undefined&gt;(undefined); #2
…
    useEffect(() =&gt; {   #3
        const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? ''; 
axios.get&lt;CompanyDetailResponse&gt;(`${apiUrl} 
<span class="CharOverride-8">➥</span>/companies/${companyId}`, { 
… 
            .then(response =&gt; { 
        console.log(`Response data ${JSON.stringify
<span class="CharOverride-8">➥</span>(response.data)}`); 
… 
    }, []); 

    return (
…
                    &lt;Typography&gt;Empty Company Dashboard&lt;/Typography&gt; #4
…
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Gets the Company ID from the URL; this is possible because of the file-based routing being used and the directory we defined as [companyId].</span>
<br/>#2 
     <span class="CharOverride-6">Stores the </span>
<span class="CharOverride-6">company</span>
<br/>#3 
     <span class="CharOverride-6">Retrieves the </span>
<span class="CharOverride-6">company details</span>
<br/>#4 
     <span class="CharOverride-6">Placeholder for the dashboard to verify navigation</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p89">
<p>While we can now navigate to the dashboard and retrieve company details, the dashboard is a little barren. However, before we can start creating dashboard components, we need ACH batches for the companies. The next section shows how to produce ACH files with company-specific data.</p>
</div>
<div class="readable-text" id="p90">
<h3 class="readable-text-h3"><span class="num-string">10.3.2</span> Creating ACH files for our companies</h3>
</div>
<div class="readable-text" id="p91">
<p>We have already created BDD-style tests to generate ACH files for our dashboard. Thankfully, we can use the same code to create files specifically for our companies. The following listing shows a sample scenario we wrote to create a test file for building the company dashboard. We used ChatGPT only for getting some original names that might be appropriate for the company’s customers.</p>
</div>
<div class="browsable-container listing-container" id="p92">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.21<span class="CharOverride-5"> </span>Creating a file for Elemental Resources Inc.</h5>
<div class="code-area-container">
<pre class="code-area">  Scenario: Create an ACH file for company "Elemental Resources Inc"
    Given I want to create an ACH file named "elemental_resources.ach"
    And I want to have an immediate destination of "990000013"
    And I want to have an immediate origin of "987654321"
    And I want to have 2 batch with ACH credits and debits
<span class="CharOverride-8">➥</span> and a standard entry class code of "PPD"
    And I want 10 entries per batch with random amounts
<span class="CharOverride-8">➥</span> between 100 and 5000
    And I want to use individual names of "Rocky Gravel, Sandy Stone,
 Clay Earthman, Mason Bricks, Gemmy Quartz, Rusty Ironwood, 
Flint Stoney, Dusty Boulderson, Shelly Shale"
    And I want to have company name "ElementalResourcesInc"
<span class="CharOverride-8">➥</span> and company id "459876543"
    When my ACH is created
    Then I should have a file of the same name
    And there should be 2 batch in the file
    And there should be 20 entries in the file</pre>
</div>
</div>
<div class="readable-text" id="p93">
<p>Here we only have to ensure that our company name is not too long as this could offset the record. In our original code, we made sure that the field itself was padded out to 16 characters when too short. Now, we have the opposite problem where we entered a field with 22 characters. The following listing shows a simple piece of code that can be used to truncate the company name.</p>
</div>
<div class="browsable-container listing-container" id="p94">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.22<span class="CharOverride-5"> </span>Truncating and padding the company name</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">setup_info["company_name"] = company_name<strong>[:16]</strong>.ljust(16, " ")</pre>
</div>
</div>
<div class="readable-text" id="p95">
<p>It may be tempting to go through the code and find all those areas that look like they should be truncating strings as well. If you go down that route, make sure to leave enough time for testing. </p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p96">
<h5 class="callout-container-h5 readable-text-h5">To fix or not to fix?</h5>
</div>
<div class="readable-text" id="p97">
<p>We encountered similar production problems before and had to make the call on whether we needed to expand the scope of the story (e.g., where an invalid amount was reported on a particular field). The user story was originally written to fix the single field reported as incorrect; however, after researching the problem and finding the root cause, it was discovered that the problematic pattern was used in several other places in the program. Due to the problem causing invalid data being sent to a third party, it was decided to update the story and expand the scope (i.e., increase the story points) so that the problem could be addressed in full. </p>
</div>
</div>
<div class="readable-text" id="p98">
<p>With company data and specific company ACH files loaded into the database, we can start building the dashboard. </p>
</div>
<div class="readable-text" id="p99">
<h2 class="readable-text-h2"><span class="num-string">10.4</span> Company Information component</h2>
</div>
<div class="readable-text" id="p100">
<p>The first component we want to build is a screen with more details about the company. These will only be some additional details that can be edited as needed.</p>
</div>
<div class="readable-text intended-text" id="p101">
<p>We create the required <code>Pydantic</code> class, which is used to return the data. We are returning more information in the <code>CompanyDetailRecord</code> than we need to display because the data will also be passed to a form where all the data will be updateable. The following listing shows the <code>CompanyDetailRecord</code> where we pass back the arrays of <code>Address</code> and <code>Phone</code> objects. The company has a one-to-many relationship for the <code>Address</code> and <code>Phone</code> types, so it is possible to have more than one row. </p>
</div>
<div class="browsable-container listing-container" id="p102">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.23<span class="CharOverride-5"> </span>The <code>CompanyDetailRecord </code>field</h5>
<div class="code-area-container">
<pre class="code-area">class CompanyDetailRecord(BaseModel):
    company_id: Optional[UUID4] = Field(
        None,
        title="Company ID",
        description="Unique identifier for the company.",
    )
    name: Optional[str] = Field(
        None,
        title="Name",
        description="Name of the company.",
        max_length=255,
    )
…
    addresses: Optional[list[Address]] = Field( #1
        None,                    #1
        title="Addresses",  #1
        description="List of Addresses.",  #1
    )  #1
    phones: Optional[list[Phone]] = Field( #2
        None,  #2
        title="Phones",  #2
        description="List of Phone Numbers.",  #2
    )  #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">An array of Address objects used to store addresses for the company</span>
<br/>#2 
     <span class="CharOverride-6">An array of Phone objects used to store phone numbers for the company</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p103">
<p>Because the address and phone records are arrays, we find that building the <code>CompanyDetailRecord</code> is somewhat more complicated than our previous data retrievals. This is because, before, we used to simply pull a record from the database and map it to the object. Now, we have multiple rows from multiple tables that we need to handle. </p>
</div>
<div class="readable-text intended-text" id="p104">
<p>We could follow several approaches, but we want to stay with a single query like we did in the past. However, depending on our query design, this will potentially duplicate fields in the company table. Returning duplicated data is not the end of the world; however, it is an indicator that there is some room for improvement. After all, we have taken great pains not to carelessly return all fields by simply using an asterisk (which can result in returning fields we have no intention of using). The duplication may be of concern for performance reasons, as well as for causing confusion among developers. </p>
</div>
<div class="readable-text intended-text" id="p105">
<p>It may not be obvious, but for each address and phone number, the query in listing 10.24 will return a row. So, if we have two addresses and three phone numbers, we will receive five rows from the query. Given the expected number of addresses and phone numbers, this is not extremely problematic at this point. We do have a relatively large amount of data being returned for the image, but as mentioned before, storing data as a <code>Base64</code>-encoded string was a matter of convenience. </p>
</div>
<div class="readable-text intended-text" id="p106">
<p>Furthermore, we use <code>LEFT</code> <code>JOIN</code> as we have no guarantee that companies will have addresses or phones populated. Had we used <code>INNER</code> <code>JOIN</code>, companies would have required addresses and phone numbers to be returned by the query. While having company records without an address/phone is not likely, it is not impossible. Perhaps the initial record was set up but—for business reasons—the address was not populated (maybe there was no official documentation for their address), or perhaps, fields did not come over properly during a conversion or migration.</p>
</div>
<div class="browsable-container listing-container" id="p107">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.24<span class="CharOverride-5"> </span>Query to return company details</h5>
<div class="code-area-container">
<pre class="code-area">   SELECT c.company_id, c.ach_company_id, c.name, c.tax_id_type,#1
c.tax_id_number, c.duns, c.logo, c.website, c.industry, 
ca.company_address_id, ca.address_type, ca.address_type, #2
ca.address_line_1, ca.address_line_2, ca.address_line_3,  #2
ca.address_line_4, ca.city, ca.state,  #2
ca.zip_code, ca.zip_code_4,  #2
cp.company_phone_id, cp.phone_type, #3
cp.phone_number, cp.extension
FROM companies AS c
LEFT JOIN company_addresses AS ca USING (company_id) #4
LEFT JOIN company_phones AS cp USING (company_id) 
WHERE company_id = %s #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">We organized selected fields by their respective tables, and these are from the companies table.</span>
<br/>#2 
     <span class="CharOverride-6">These fields are from the company address table.</span>
<br/>#3 
     <span class="CharOverride-6">These fields are from the company phone table.</span>
<br/>#4 
     <span class="CharOverride-6">We use a LEFT JOIN because records are not required to be in these tables.</span>
<br/>#5 
     <span class="CharOverride-6">Limiting our details by the company, with %s being a placeholder</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p108">
<p>We have multiple rows and will need the application logic to ensure the duplicated data is not passed back. The following listing shows the full method to accomplish this. We must loop through each record and use a hash to ensure that <code>id</code> has not been encountered before.</p>
</div>
<div class="browsable-container listing-container" id="p109">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.25<span class="CharOverride-5"> </span>Returning company details</h5>
<div class="code-area-container">
<pre class="code-area">def get_company_by_id(self, company_id: UUID) -&gt; CompanyDetailRecord:
   with get_db_connection(row_factory=dict_row) as conn:
      result = conn.execute(
…
      )

      rows = result.fetchall() #1

      if not rows: #2
         raise KeyError(f"Record with id {company_id} not found") 

      addresses = {} #3
      phones = {} 
        for row in rows: #4
           if row["company_address_id"] not in addresses: #5
              addresses[row["company_address_id"]] = Address(  #5
              …  #5
              )  #5
           if row["company_phone_id"] not in phones: #6
               …  #6
              )  #6

        company_data = {
            "company_id": rows[0]["company_id"], #7
            "name": rows[0]["name"],  #7
            "tax_id_type": rows[0]["tax_id_type"],  #7
            "ach_company_id": rows[0]["ach_company_id"],  #7
            "tax_id_number": rows[0]["tax_id_number"],  #7
            "duns": rows[0]["duns"],  #7
            "logo": rows[0]["logo"],  #7
            "website": rows[0]["website"],  #7
            "industry": rows[0]["industry"],  #7
            "addresses": list(addresses.values()), #8
            "phones": list(phones.values()), 
        }

        return CompanyDetailRecord(**company_data) #9</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Fetches all rows </span>
<span class="CharOverride-6">for our SQL query</span>
<br/>#2 
     <span class="CharOverride-6">If no details are found, this is an error and is reported as such.</span>
<br/>#3 
     <span class="CharOverride-6">Sets up empty hashes to store our data</span>
<br/>#4 
     <span class="CharOverride-6">Loops through each row that was returned</span>
<br/>#5 
     <span class="CharOverride-6">Creates an Address object as necessary</span>
<br/>#6 
     <span class="CharOverride-6">Creates a Phone object when we have a phone number not encountered before</span>
<br/>#7 
     <span class="CharOverride-6">We can just reference the company fields from our first row.</span>
<br/>#8 
     <span class="CharOverride-6">Creates an array </span>
<span class="CharOverride-6">from our hash</span>
<br/>#9 
     <span class="CharOverride-6">Creates an object using the company_data</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p110">
<p>While this code works as expected, we can also condense the resulting dataset by using more complicated SQL. We have explored CTE in Postgres in previous examples and can use some of the JSON processing available in Postgres as well. The tradeoff is that our SQL may become less portable, but JSON processing is available for other major databases, such as MySQL, with some slight modifications. The following listing shows the updated SQL.</p>
</div>
<div class="browsable-container listing-container" id="p111">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.26<span class="CharOverride-5"> </span>Getting company data using Postgres CTE</h5>
<div class="code-area-container">
<pre class="code-area">WITH company_info AS (
   SELECT c.company_id, c.ach_company_id, c.name, c.tax_id_type,
          c.tax_id_number, c.duns, c.logo, c.website, c.industry
     FROM companies AS c
    WHERE c.company_id = %s
),
addresses AS (
   SELECT ca.company_id, #1
          JSON_AGG(   #1
             JSON_BUILD_OBJECT(  #1
                'company_address_id', ca.company_address_id,  #1
                'address_type', ca.address_type,  #1
                'address_line_1', ca.address_line_1,  #1
                'address_line_2', ca.address_line_2,  #1
                'address_line_3', ca.address_line_3,  #1
                'address_line_4', ca.address_line_4,  #1
                'city', ca.city,  #1
                'state', ca.state,  #1
                <span>'zip_code', ca.zip_code, </span> #1
<span>                'zip_code_4', ca.zip_code_4</span> #1
<span>             </span>)  #1
          ) AS addresses #1
     FROM company_addresses AS ca  #1#2
     WHERE ca.company_id = %s #3
     GROUP BY ca.company_id #4
),
phones AS ( #5
   SELECT cp.company_id, 
          JSON_AGG( 
             JSON_BUILD_OBJECT( 
                'company_phone_id', cp.company_phone_id, 
                'phone_type', cp.phone_type, 
                'phone_number', cp.phone_number, 
                'extension', cp.extension
             ) 
          ) AS phones
     FROM company_phones AS cp #6
     WHERE cp.company_id = %s
     GROUP BY cp.company_id
) 
SELECT ci.company_id, ci.ach_company_id, ci.name,
ci.tax_id_type,  ci.tax_id_number, ci.duns, 
ci.logo, ci.website, ci.industry, 
COALESCE(a.addresses, '[]'::json) AS addresses, #7
<span>COALESCE(p.phones, '[]'::json) AS phones</span>
FROM company_info AS ci
LEFT JOIN addresses AS a ON ci.company_id = a.company_id
LEFT JOIN phones AS p ON ci.company_id = p.company_id;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Uses the JSON_AGG and JSON_BUILD_OBJECT </span>
<span class="CharOverride-6">to create an array of addresses for the company</span>
<br/>#2 
     <span class="CharOverride-6">Uses the company_addresses table</span>
<br/>#3 
     <span class="CharOverride-6">Selects only the records for our company</span>
<br/>#4 
     <span class="CharOverride-6">Groups the records </span>
<span class="CharOverride-6">by company_id</span>
<br/>#5 
     <span class="CharOverride-6">Uses the JSON_AGG and JSON_BUILD_OBJECT </span>
<span class="CharOverride-6">to create an array of phones for the company</span>
<br/>#6 
     <span class="CharOverride-6"> Uses the JSON_AGG and <br/>JSON_BUILD_OBJECT to create an array of phones for the company</span>
<br/>#7 
     <span class="CharOverride-6">Uses COALESCE to return an empty JSON array when there are no records in the table</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p112">
<p>The application becomes more streamlined, as shown in the following listing. We can use <code>**</code> to unpack the returned JSON into keyword arguments passed to their respective objects, thus creating a list of elements. </p>
</div>
<div class="browsable-container listing-container" id="p113">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.27<span class="CharOverride-5"> </span>Python code to return the data</h5>
<div class="code-area-container">
<pre class="code-area">        row = result.fetchone()

        if not row:
            raise KeyError(f"Record with id {company_id} not found")

        addresses = [Address(**address) for #1
<span class="CharOverride-8">➥</span> address in row["addresses"]]  #2
        phones = [Phone(**phone) for phone in row["phones"]] 

        company_data = {
            "company_id": row["company_id"],
             …
            "addresses": addresses, #2
            "phones": phones, 
        }

        return CompanyDetailRecord(**company_data) #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Loops through the data returned to create appropriate array</span>
<br/>#2 
     <span class="CharOverride-6">Assigns them to the company_data hash</span>
<br/>#3 
     <span class="CharOverride-6">Creates a CompanyDetailRecord object using the hash we created</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p114">
<p>Several factors should always be considered when choosing one path over another. This selection may depend on the application and data involved. Performing profiling on the application and doing <code>EXPLAIN</code> <code>ANALYZE</code> on the SQL queries are some of the ways to determine which method performs better. A human factor is also involved; it takes into consideration which version is clearer and easier to maintain. Either way, we can now retrieve and display customer data!</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p115">
<h5 class="callout-container-h5 readable-text-h5">Company Information form challenge</h5>
</div>
<div class="readable-text" id="p116">
<p>Because we are prepopulating the company information, and completing a form covers much of the same material laid out in previous chapters, we believe this is another good opportunity to take a break and put together a form to display the company information. You may create something from scratch, find a template, or use generative AI to see if things can be done faster that way. Using generative AI is a good way to get started. Try feeding the SQL tables or interfaces defined for the fields to see whether it can generate the boilerplate code.</p>
</div>
</div>
<div class="readable-text" id="p117">
<p>With a basic form in place, we move to a component showing recent company batches.</p>
</div>
<div class="readable-text" id="p118">
<h2 class="readable-text-h2"><span class="num-string">10.5</span> Recent Batches component</h2>
</div>
<div class="readable-text" id="p119">
<p>When we navigate to the company dashboard, we want to be able to get an idea of activity for the company. A great way to see the activity is listing the batches found for the company. Being able to pull batch information will require us to have some knowledge of the ACH layout for batches because we need to gather some information from both the batch header (type 5) and the batch control (type 8) records. Figure 10.3 shows an example of the component we will be building.</p>
</div>
<div class="browsable-container figure-container" id="p120">
<img alt="A screenshot of a company profile  Description automatically generated" height="282" src="../Images/CH10_F03_Kardell.png" style="width: 100%; max-width: max-content;" width="872"/>
<h5 class="figure-container-h5"><span class="">Figure 10.3</span><span class=""> </span><span class="">Recent company batches</span></h5>
</div>
<div class="readable-text" id="p121">
<p>To build the Recent Batches component, we follow three easy steps:</p>
</div>
<ol>
<li class="readable-text" id="p122">Create an API endpoint in FastAPI.</li>
<li class="readable-text" id="p123">Write the SQL query to gather the required data.</li>
<li class="readable-text" id="p124">Display the returned data in a MUI DataGrid.</li>
</ol>
<div class="readable-text" id="p125">
<h3 class="readable-text-h3"><span class="num-string">10.5.1</span> Implementing the recent batches API</h3>
</div>
<div class="readable-text" id="p126">
<p>Whereas we could build an endpoint that is related to other company functions, we will instead implement this function as a search. While doing so is certainly a preference for our individual approach, we feel that rather than having something such as <code>/companies/{company_id}/batches</code>, we will achieve more flexibility if we just create an endpoint similar to our transaction search from the previous chapter. Therefore, we create an endpoint of <code>/api/v1/files/batches/search</code> and use it. The following listing from the files.py generates our API endpoint.</p>
</div>
<div class="browsable-container listing-container" id="p127">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.28<span class="CharOverride-5"> </span>Batches search endpoint</h5>
<div class="code-area-container">
<pre class="code-area">@router.get(
…
)
@log_message("Retrieving ACH batches")
async def search_ach_batches(
    request: Request,
    criteria: str = Query(..., description="Search criteria for batches"),
) -&gt; list[BatchSearchResponse]:
    return BatchSearchSql().get_batches(criteria)</pre>
</div>
</div>
<div class="readable-text" id="p128">
<p>The endpoint should be straightforward by now. The <code>get_batches</code> routine follows a flow very similar to that in our transaction search. We support a few different search methods right from the get-go because we ignore the YAGNI principle from chapter 3. While this is usually something we stay away from, rules are meant to be broken. Since this routine is based on the transaction search, it won’t take too much effort to code this up to make it available (of course, testing is another matter). The following listing shows the initial <code>get_batches</code> method. While these patterns will likely be useful in the future, for now, we are interested in when we do not match any of the previous patterns and will instead search using company’s UUID. Recall that when we are on the company dashboard, we have the company’s UUID in the URL. So, this will be easy to pass as a query parameter for the search.</p>
</div>
<div class="browsable-container listing-container" id="p129">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.29<span class="CharOverride-5"> </span>The <code>get_batches</code> method</h5>
<div class="code-area-container">
<pre class="code-area">    def get_batches(self, criteria: str) -&gt; list[BatchSearchResponse]:
        amount_pattern = r"^\d+\.\d{2}$"
        multiple_amounts_pattern = r"(^\d+\.\d{2})\s+(\d+\.\d{2})$"
        company_id_pattern = r"^\d+$"
        company_name_pattern = r"^[a-zA-Z1-9\s]+$"
        if re.match(amount_pattern, criteria): #1
            return self._get_batches_using_amount(criteria)  #2
        elif match := re.match(multiple_amounts_pattern, criteria):  #2
            begin_amount, end_amount = match.groups()  #2
            return self._get_batches_using_amount_range(begin_amount,  #2
 end_amount)  #2
        elif re.match(company_id_pattern, criteria):  #2
            return self._get_batches_using_company_id(criteria)  #2
        elif re.match(company_name_pattern, criteria):  #2
            return self._get_batches_using_company_name(criteria)  #2
        else:  #2
            return self._get_batches_using_company_uuid(criteria)  #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">We created the ability to search for batches using many different methods, even though we are only interested in searching by the UUID at this point.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p130">
<p>The call for <code>_get_batches_using_company_uuid</code> is simple. As with our previous search queries, we have pulled the selection logic out of the query into a shared method since each of these search methods shares the same selection logic and only differs in how we filter the results.</p>
</div>
<div class="readable-text intended-text" id="p131">
<p>Of course, the selection criteria are going to be the biggest and most important part of this search effort. The query needs to pull together a few different tables to build the search response. Listing 10.30 shows the SQL we used. Note that most of the tables are <code>INNER JOIN</code>s, but the companies table is using a <code>LEFT</code> <code>JOIN</code> because there is no guarantee that the company name exists in our database. </p>
</div>
<div class="readable-text intended-text" id="p132">
<p>We know that ACH files can contain batches from companies that may or may not be our customers. Because it is entirely possible that our search results may return a batch for a specified company not defined in our database, the query may fail to return any results. We use the Postgres <code>COALESCE</code> command to pull the name from the company table. If that is <code>NULL</code>, we will use the record from the batch header and, finally, an empty string. The following listing shows the SQL query.</p>
</div>
<div class="browsable-container listing-container" id="p133">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.30<span class="CharOverride-5"> </span>SQL query</h5>
<div class="code-area-container">
<pre class="code-area">SELECT art1.ach_files_id AS file_id,
       art5.ach_records_type_5_id AS batch_header_id,
       af.file_name AS filename,
       COALESCE(c.name, abh.company_name, '') AS company_name, #1
       abh.company_identification AS company_identification,
       abcr.total_credit_entry_dollar_amount 
                          AS total_credit_entry_dollar_amount,
       abcr.total_debit_entry_dollar_amount 
                          AS total_debit_entry_dollar_amount,
       abcr.entry_addenda_count AS entry_addenda_count
  FROM ach_files af
INNER JOIN ach_records_type_1 art1 USING ( ach_files_id )
INNER JOIN ach_records_type_5 art5 USING ( ach_records_type_1_id )
INNER JOIN ach_records_type_8 art8 USING ( ach_records_type_5_id )
INNER JOIN ach_batch_headers abh USING ( ach_records_type_5_id )
INNER JOIN ach_batch_control_records abcr USING ( ach_records_type_8_id )    
 LEFT JOIN companies c ON #2
 abh.company_identification = c.ach_company_id #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">We use the name as we have it in our database, as displayed on the batch header, or an empty string.</span>
<br/>#2 
     <span class="CharOverride-6">We use a LEFT JOIN but must use ON instead of USING since the fields we want to join are not named the same.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p134">
<p>The results of our query are stored in the <code>BatchSearchResponse</code> object in api/batch_search_response.py and is a standard Pydantic data model that we will not elaborate on since we have defined a fair amount of these already.</p>
</div>
<div class="readable-text" id="p135">
<h3 class="readable-text-h3"><span class="num-string">10.5.2</span> Displaying recent batches</h3>
</div>
<div class="readable-text" id="p136">
<p>This UI component is simple and is responsible for making an API call to get data and display the results in a DataGrid. The main thing to consider is whether we truly want the component to be responsible for making the API call. We have changed our approach when handling different components. When multiple components are on a page and use similar data, we pass that data to the components to minimize server calls, hoping to reduce latency and provide a better UX. In this case, the data is specific to this component, so we keep everything contained in the component. We can envision that this may become problematic if we were to allow users customize components on the dashboard, but some redesign would be required, and we will cross that bridge once we get there.</p>
</div>
<div class="readable-text intended-text" id="p137">
<p>Listing 10.31 shows the basics of the UI component. We use the <code>renderCell</code> attribute of the MUI DataGrid to provide clickable View links that take a user directly to the file or batch. We also use the <code>formatCurrency</code> method whenever we need to format a currency. Also, note how we can use our search API with the parameter <code>companyId</code> that was passed in. So, in this case, the search is programmatically driven and not necessarily done via the user input like when searching for transactions.</p>
</div>
<div class="browsable-container listing-container" id="p138">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.31<span class="CharOverride-5"> </span>The <code>RecentCompanyBatches</code> Component</h5>
<div class="code-area-container">
<pre class="code-area">interface RecentCompanyBatchesProps {
    companyId?: string;
}

export default function 
<span class="CharOverride-8">➥</span>RecentCompanyBatches({companyId}: Readonly&lt;RecentCompanyBatchesProps&gt;) {

    const router = useRouter(); #1
    const [results, setResults] =  #2
<span class="CharOverride-8">➥</span> useState&lt;AchBatchSearchResponse[]&gt;([]); 

    useEffect(() =&gt; {

        if (!companyId) {
            return;
        }

        const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? '';
        axios.get&lt;AchBatchSearchResponse[]&gt;(`${apiUrl}/files/ #3
<span class="CharOverride-8">➥</span>batches/search?criteria=${companyId}`, {  #3
…  #3
    }, [companyId]); 

    const columns: GridColDef[] = [
       {field: 'file_id', headerName: 'File', 
        sortable: false, width: 50, renderCell: (params) =&gt; (
            &lt;Link onClick={() =&gt; #4
router.push(`/fileDetails/${params.row.file_id}`)}  #5
    sx={{ cursor: 'pointer' }}&gt;View&lt;/Link&gt; 
            )},
        {field: 'batch_header_id', headerName: 'Batch',
         sortable: false, width: 50, renderCell: (params) =&gt; (
            &lt;Link onClick={() =&gt; #5
router.push(`/fileDetails/${params.row.file_id}/batchDetails/  #5
   ${params.row.batch_header_id}`)}   #5
         sx={{ cursor: 'pointer' }}&gt;View&lt;/Link&gt;  #5
…
        {field: 'total_credit_entry_dollar_amount', 
            headerName: 'Total Credit', width: 125, 
            renderCell: (params) =&gt; ( #6
               formatCurrency(Number(  #6
                  params.row.total_credit_entry_dollar_amount))  #6
            )},  #6
        {field: 'total_debit_entry_dollar_amount',
         headerName: 'Total Debit', width: 125, 
         renderCell: (params) =&gt; (
            formatCurrency(Number(params.row.total_debit_entry_dollar_amount))
            )},
    ];

    return (
…
       &lt;Title&gt;Recent Company Batches&lt;/Title&gt;
       &lt;DataGrid rows={results}  #7
                 columns={columns}   #8
                 getRowId={(row: any) =&gt; row.batch_header_id}/&gt;  #8
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">The useRouter enables </span>
<span class="CharOverride-6">the component to navigate to other pages.</span>
<br/>#2 
     <span class="CharOverride-6">Stores the </span>
<span class="CharOverride-6">search response</span>
<br/>#3 
     <span class="CharOverride-6">Uses Axios to retrieve data from our endpoint</span>
<br/>#4 
     <span class="CharOverride-6">Creates a hyperlink that allows us to navigate to the file containing the batch</span>
<br/>#5 
     <span class="CharOverride-6">Creates a hyperlink that allows us to navigate directly </span>
<span class="CharOverride-6">to the batch</span>
<br/>#6 
     <span class="CharOverride-6">Reuses our formatCurrency routine</span>
<br/>#7 
     <span class="CharOverride-6">Passes the required fields to create our grid; we also need to specify an ID for the row because we do not have a field named ID.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p139">
<p>Now, we can show users current activity for the company, which is very useful and provides an at-a-glance UX. If a customer were to call for ACH support, they are mostly likely calling about something that happened recently. Being able to quickly jump to a particular file is going to be important. The next component will provide another way to help customers stay on top of their ACH files.</p>
</div>
<div class="readable-text" id="p140">
<h2 class="readable-text-h2"><span class="num-string">10.6</span> Expected Files component</h2>
</div>
<div class="readable-text" id="p141">
<p>Another useful component for our company dashboard is a component that allows users to keep track of any expected ACH files for a company. A company may want a financial institution to process files on a set schedule, and if the particular file has not arrived, then someone needs to be alerted and follow up. For instance, if the financial institution’s customer expects to see their paycheck on the 15th,<span class="_Superscript _idGenCharOverride-1">, </span>then the bank better make sure it is processed before that date. </p>
</div>
<div class="readable-text intended-text" id="p142">
<p>This component displays a simple list and an indicator of whether the file has been loaded. We will be using the filename as the basis for whether a file has been loaded. It is common for financial institutions, data centers, and similar to rely on naming conventions to help facilitate various checks and balances, so using a filename for our component is not a unique approach to our dashboard. Of course, we could also expand the conditions to match any other constraints that might be useful from an ACH perspective—whether it is the company ID or totals from the batch. </p>
</div>
<div class="readable-text intended-text" id="p143">
<p>Although we are approaching this problem from the company perspective, it would also be incorporated from a more general perspective (e.g., a financial institution will also expect files on a set schedule). Figure 10.4 shows an example of the component. </p>
</div>
<div class="browsable-container figure-container" id="p144">
<img alt="A screenshot of a computer  Description automatically generated" height="307" src="../Images/CH10_F04_Kardell.png" style="width: 100%; max-width: max-content;" width="714"/>
<h5 class="figure-container-h5"><span class="">Figure 10.4</span><span class=""> </span><span class="">Expected Files component</span></h5>
</div>
<div class="readable-text" id="p145">
<p>We build the Expected Files component using the following steps:</p>
</div>
<ol>
<li class="readable-text" id="p146">Define the database table and type.</li>
<li class="readable-text" id="p147">Define the API endpoint.</li>
<li class="readable-text" id="p148">Display the data using a MUI DataGrid.</li>
</ol>
<div class="readable-text" id="p149">
<h3 class="readable-text-h3"><span class="num-string">10.6.1</span> Storing expected files</h3>
</div>
<div class="readable-text" id="p150">
<p>For our database, we create another database table named <code>company_expected_files</code> to store a list of filenames. We also create a <code>SCHEDULE_TYPE</code> like before to limit the possible values in the field. The table will only be responsible for holding the data necessary to determine whether the file should be found. There may be cases where an external job would make the determination and update a flag in the table. That is not required in our case, and we can rely on the API call to return the additional flag.</p>
</div>
<div class="readable-text intended-text" id="p151">
<p>The following listing shows the creation of the table and type. We also use the <code>last_file_date</code>, which has to be maintained to be adjusted. We need to revise our file-upload logic to update this field.</p>
</div>
<div class="browsable-container listing-container" id="p152">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.32<span class="CharOverride-5"> </span>Creating the type and table for expected files</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TYPE schedule_type AS ENUM ('daily', 'weekly', 'bi-weekly',
       'monthly', 'quarterly', 'semi-annually', 'annually');

CREATE TABLE company_expected_files (
    company_expected_files_id UUID DEFAULT uuid_generate_v4(), #1
    company_id UUID NOT NULL REFERENCES companies(company_id)
    ON DELETE CASCADE ON UPDATE CASCADE,
    file_name VARCHAR(255) NOT NULL,
    schedule SCHEDULE_TYPE NOT NULL DEFAULT 'daily',
    last_file_date TIMESTAMP DEFAULT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    PRIMARY KEY (company_id, file_name) #2
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Although it is not required, we define a UUID that the record could be referenced by.</span>
<br/>#2 
     <span class="CharOverride-6">The key is actually the company and filename as we only want to have one filename per company.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p153">
<p>We take similar steps to populate the database with some data to see the component in action. Listing 10.33 shows the <code>INSERT</code> for the <code>company_expected_files</code> table. We can insert these records for each company by using a <code>SELECT</code> statement to select the <code>company_id</code> field based on the <code>tax_id_number</code> for the company. Remember that the <code>company_id</code> is set dynamically by the database when the record is inserted. We could also choose to insert the record with a known UUID, but using the preceding approach allows us to work with the data as we expect to see it in production and prepare ourselves for the times when we do not have the luxury of inserting a known field in our test.</p>
</div>
<div class="browsable-container listing-container" id="p154">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.33<span class="CharOverride-5"> </span>Inserting records into the expected files table</h5>
<div class="code-area-container">
<pre class="code-area">INSERT INTO company_expected_files ( company_id, file_name,
            schedule, last_file_date )
VALUES (
   (SELECT c.company_id FROM companies AS c  #1
             WHERE tax_id_number = '345678901'), 
   'stellar_services.ach',
   'daily',
   NOW() - INTERVAL '1 day'
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Gets the company_id by searching companies by the tax_id_number</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p155">
<p>With our database set up, we can now work on the logic that will power the <code>ExpectedFiles</code> component.</p>
</div>
<div class="readable-text" id="p156">
<h3 class="readable-text-h3"><span class="num-string">10.6.2</span> Implementing the expected files API</h3>
</div>
<div class="readable-text" id="p157">
<p>With the data for expected files loaded into the database, we need to be able to retrieve it, and we also need to be able to update the <code>last_file_date</code> when a file is uploaded. </p>
</div>
<div class="readable-text" id="p158">
<p>The first thing we did was start with a test to work on building the required SQL logic. Again, we utilized Testcontainers to run our <code>docker_compose</code> container for the duration of the test. </p>
</div>
<div class="readable-text intended-text" id="p159">
<p>Listing 10.34 shows the basic structure of our test file. As part of the test, we created a basic <code>CompanySearchSql</code> class to search for companies by their <code>tax_id_number</code> or <code>ach_company_id</code> number. The need for such a class is another result of the database dynamically assigning the UUID. To avoid scope creep, we only built enough functionality to get a single company, but it could easily be incorporated into a search page or company page so that when we have hundreds or thousands of customers, we do not have to page through them all.</p>
</div>
<div class="browsable-container listing-container" id="p160">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.34<span class="CharOverride-5"> </span>Test for the <code>ExpectedFilesSql</code> class</h5>
<div class="code-area-container">
<pre class="code-area">@pytest.fixture(scope="module")
def docker_compose():
    absolute_path = Path("../../../../../docker/db").resolve()
    with DockerCompose(absolute_path, build=True, #1
                       services=["postgres"])  #2
 as compose:  #2
        compose.start() #2
        yield compose #2
        compose.stop() 
…
    def test_get_expected_files_for_company(self, docker_compose, sql):
        company_id =  #3
CompanySearchSql().get_companies("459876543").company_id #4
        assert company_id is not None #4
        results = sql.get_expected_files_for_company(company_id) #5
        assert len(results) == 2 #6
        assert any(  #7
            record.file_name == "elemental_resources.ach"  #7
                                            for record in results #7
        )  #7
        assert any(  #7
            record.file_name == "elemental_resources_daily_billpay.ach"  #7
                                            for record in results #7
        )  #7</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Uses Testcontainers and DockerCompose to build the container and start only the Postgres service. There is no need to start CloudBeaver for a temporary test.</span>
<br/>#2 
     <span class="CharOverride-6">Ensures the container is started and stopped for our test</span>
<br/>#3 
     <span class="CharOverride-6">Uses CompanySearchSql to get the company UUID</span>
<br/>#4 
     <span class="CharOverride-6">Makes sure we actually find something</span>
<br/>#5 
     <span class="CharOverride-6">Runs the SQL that we want to test</span>
<br/>#6 
     <span class="CharOverride-6">Makes the necessary assertions to ensure the method worked</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p161">
<p>With our unit test in place, we are free to build the logic behind the <code>get_expected_files_for_company</code>. The <code>SQL</code> query creates two additional fields that are not stored directly in the database. These fields are a Boolean value for whether the file has been loaded and the <code>next_file_date</code>, which is the next time we expect to see the file according to the file’s schedule. For now, we do not consider filtering our results by the date simply because that makes testing a bit more difficult. So, we are returning all the data. This does not necessarily make sense for the component when the current objective is to show files that were expected today. However, it works well enough to demonstrate the intent of the functionality. We could expand this component or create a new one that shows files for the coming week, gets the number of files expected, and similar. The <code>SQL</code> query utilizes the <code>INTERVAL</code> function, which makes it easy to compute the given time interval. The following listing shows the <code>SQL</code> statement.</p>
</div>
<div class="browsable-container listing-container" id="p162">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.35<span class="CharOverride-5"> </span>SQL for the Expected Files component</h5>
<div class="code-area-container">
<pre class="code-area">WITH future_file_dates AS ( #1
   SELECT ef.company_expected_file_id,  #1
       ef.company_id,  #1
       ef.file_name,  #1
       CASE ef.schedule #1
          WHEN 'daily' THEN ef.last_file_date + INTERVAL '1 day' #1
          WHEN 'weekly' THEN ef.last_file_date + INTERVAL '1 week' #1
          WHEN 'bi-weekly' THEN ef.last_file_date + INTERVAL '2 weeks'  #1
          WHEN 'monthly' THEN ef.last_file_date + INTERVAL '1 month'  #1
          WHEN 'quarterly' THEN ef.last_file_date  #1
                                               + INTERVAL '3 months'  #1
          WHEN 'semi-annually' THEN ef.last_file_date   #1
                                               + INTERVAL '6 months'  #1
          WHEN 'annually' THEN ef.last_file_date + INTERVAL '1 year'  #1
          ELSE ef.last_file_date  #1
       END AS next_file_date  #1
  FROM company_expected_files AS ef  #1
 WHERE ef.company_id = %s  #1
)  #1
SELECT ef.company_expected_file_id, ef.file_name, ef.schedule, #1
    ef.last_file_date, ffd.next_file_date,
    CASE #2
       WHEN af.file_name IS NOT NULL   #2
            AND af.created_at::date = ef.last_file_date::date   #2
               THEN TRUE #2
       ELSE FALSE  #2
    END AS file_loaded  #2
   FROM company_expected_files AS ef
INNER JOIN future_file_dates AS ffd USING (company_expected_file_id)
 LEFT JOIN ach_files AS af ON ef.file_name = af.file_name
     WHERE ef.company_id = %s;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Uses a CTE to determine when the file is next expected</span>
<br/>#2 
     <span class="CharOverride-6">Determines whether the file was loaded</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p163">
<p>Finally, we revise the posting of a file to update the <code>last_file_date</code> and <code>updated_at</code> fields for the table. This approach works well for now—when expected files are loaded, the date will increment accordingly and everything will function normally. However, problems arise when files are not uploaded. Perhaps the expected file does not need to be loaded that day–maybe it was a company holiday. For that reason, many financial institutions do not process files on weekends. When a file is loaded on a Friday, it may be necessary to adjust the next expected day to Monday instead of a Saturday. Handling these edge cases or addressing our users’ additional needs helps make our software more robust. The following listing shows the addition of updating the necessary dates for our expected files.</p>
</div>
<div class="browsable-container listing-container" id="p164">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.36<span class="CharOverride-5"> </span>Updating the dates for our expected files</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">    parser = AchFileProdates
    ach_file = AchFileSchema(file_name=file.filename, <br/>file_hash=file.content_type)
    ach_files_id = AchFileSql().insert_record(ach_file)
    try:
        print(f"Processing file {temp_file.name}")
        seq = parser.parse(ach_files_id, temp_file.name)
<strong>        ExpectedFilesSql().update_last_file_date(file.filename) </strong>#1
    except Exception as e:
        print(e)
        return {"error": "Invalid file"}
    return {
        "filename": file.filename,
        "content_type": file.content_type,
        "last_seq": seq,</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Once parsing of the file is completed, we can update the date.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p165">
<p>The logic of updating the dates can be kept simple for now. The <code>updated_at</code> is just for audit purposes, and determining when the file was uploaded. The last time the file was uploaded was also at the time of the update, so we use the function <code>NOW</code> for both updates. The following listing shows the simple update logic used by the <code>update_last_file_date </code>mehod.</p>
</div>
<div class="browsable-container listing-container" id="p166">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.37<span class="CharOverride-5"> </span>Simple update logic</h5>
<div class="code-area-container">
<pre class="code-area">   UPDATE company_expected_files
                       SET last_file_date = NOW(), #1
                           updated_at = NOW() 
                     WHERE file_name = %s</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Updates the table to indicate the file has been uploaded</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p167">
<p>Things would get more complicated if we wanted to always keep the last file date set to a Monday and the processing fell on a weekend. This is an important problem because financial institutions may not be open on the weekend (or federal holidays), and it may not be appropriate to process files on those days. We certainly do not want to be enjoying our Sunday afternoon only to have numerous alerts come in, showing the files are missing! The following listing assumes a daily interval, but we could easily change this dynamic as needed.</p>
</div>
<div class="browsable-container listing-container" id="p168">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.38<span class="CharOverride-5"> </span>Default to Monday as needed</h5>
<div class="code-area-container">
<pre class="code-area">WITH adjusted_date AS (
    SELECT
        NOW() + INTERVAL '1 day' AS initial_date
)
UPDATE company_expected_files
        SET last_file_date = (SELECT CASE #1
                           WHEN EXTRACT(DOW FROM initial_date) = 0 THEN   #2
initial_date + INTERVAL '1 day' #2
                           WHEN EXTRACT(DOW FROM initial_date) = 6 THEN  #2
initial_date + INTERVAL '2 day'  #2
                           ELSE initial_date  #2
                         END
                            FROM adjusted_date),
            updated_at = NOW()
      WHERE file_name = %s</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">If the date falls on a Sunday or Saturday, adds the appropriate number of days to force it to Monday. Be aware that this </span>
<span class="CharOverride-6">does not work if Monday is a holiday and the financial institution is closed. That would take some additional effort.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p169">
<p>While we are not overly concerned about addressing the field <code>last_file_date</code>, we should begin to see some of the problems that may occur with scheduled tasks, especially when we must consider what happens when files are not loaded. It is unlikely that our application should have to directly address this, and—ironically enough—there may be another scheduled job that needs to run and clean the database. For now, we can retrieve the needed data from the database, so let’s proceed with creating the UI side of our component.</p>
</div>
<div class="readable-text" id="p170">
<h3 class="readable-text-h3"><span class="num-string">10.6.3</span> Displaying the expected files</h3>
</div>
<div class="readable-text" id="p171">
<p>The heavy lifting should have been done on the backend. The UI component simply needs to display the information and an icon dependent on the <code>file_loaded</code> Boolean that is returned as part of the response. The most interesting part of the UI component (considering we have done this many times by now) is the ternary statement we use to decide whether to display a <code>TaskAlt</code> or a <code>RadioButtonUnchecked</code> icon. Otherwise, it is the typical flow of adding the component to the page.tsx and having the component retrieve the necessary data and display it in the DataGrid. The following listing shows the UI component.</p>
</div>
<div class="browsable-container listing-container" id="p172">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.39<span class="CharOverride-5"> </span>The <code>ExpectedFiles</code> component</h5>
<div class="code-area-container">
<pre class="code-area">…
interface ExpectedFilesProps {
    companyId?: string;
}
export default function ExpectedFiles({companyId}:
<span class="CharOverride-8">➥</span> Readonly&lt;ExpectedFilesProps&gt;) {

    const [results, setResults] = useState&lt;CompanyExpectedFilesResponse[]&gt;([]);
…
  axios.get&lt;CompanyExpectedFilesResponse[]&gt;
<span class="CharOverride-8">➥</span>(`${apiUrl}/companies/${companyId}/expect…

    const columns: GridColDef[] = [
        {field: 'file_loaded', headerName: 'Loaded', width: 75,
         renderCell: (params) =&gt; (
                params.value ? &lt;TaskAlt sx={{color: "green"}} /&gt; : #1
&lt;RadioButtonUnchecked /&gt; 
…
        {field: 'file_name', headerName: 'File Name', width: 200},
        {field: 'schedule', headerName: 'Schedule', width: 75},
…
            field: 'last_file_date', headerName: 'Last File Date',
            width: 100,
            renderCell: (params) =&gt; (
                params.value ? new Date(params.value as 
<span class="CharOverride-8">➥</span> string).toLocaleDateString() : ''
…
            field: 'next_file_date', 
            headerName: 'Next Expected Date', width: 150,
            renderCell: (params) =&gt; (
                params.value ? new Date(params.value as
<span class="CharOverride-8">➥</span> string).toLocaleDateString() : ''
…

    return (
…
                    &lt;Title&gt;Expected Files&lt;/Title&gt;
                    &lt;DataGrid rows={results} columns={columns}
                     getRowId={(row: any) =&gt;
                     row.company_expected_file_id}/&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">We use a ternary statement to determine which icon to display.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p173">
<p>That completes the expected files component. We started by defining the required database table and a custom type to support the scheduling of expected files. Then we created a unit test with Testcontainers so that we could get a fresh database for each run. This approach allowed us to work out the needed SQL to return the data required for our component. Finally, we called the API from our UI and formatted the data to display it to the user.</p>
</div>
<div class="readable-text intended-text" id="p174">
<p>Next, we look to add another component that can help companies monitor and control suspicious activity with company limits.</p>
</div>
<div class="readable-text" id="p175">
<h2 class="readable-text-h2"><span class="num-string">10.7</span> Company Limits component</h2>
</div>
<div class="readable-text" id="p176">
<p>This component is centered around proactive monitoring for the company. We would like the company to be able to set limits that would trigger alerts and possibly prevent transactions from being posted should those limits be hit. This can help companies identify and deal with transactions or activity that may be outside of normal behavior.</p>
</div>
<div class="browsable-container figure-container" id="p177">
<img alt="A screenshot of a credit card  Description automatically generated" height="167" src="../Images/CH10_F05_Kardell.png" style="width: 100%; max-width: max-content;" width="304"/>
<h5 class="figure-container-h5"><span class="">Figure 10.5</span><span class=""> </span><span class="">Company Limits component</span></h5>
</div>
<div class="readable-text intended-text" id="p178">
<p>As a business, if you expect less than, say, $10,000 of debit activity in a day, and suddenly, there is a $15,000 batch being posted for your company, you likely want to be alerted about that activity. In principle, this is a straightforward component that lists totals for the day and compares them to a limit set by the company or the bank—functionality that needs to be built out in a future sprint. In practice, we need to handle alerting the customer, allowing for processing when the company is okay with exceeding the limit, and rejecting the file load otherwise. Figure 10.5 shows the Company Limits component we will be implementing.</p>
</div>
<div class="readable-text intended-text" id="p179">
<p>We work on creating this component using the following steps:</p>
</div>
<ol>
<li class="readable-text" id="p180">Create the database table.</li>
<li class="readable-text" id="p181">Define the API endpoint.</li>
<li class="readable-text" id="p182">Display the returned information <br/>to the user.</li>
</ol>
<div class="readable-text" id="p183">
<h3 class="readable-text-h3"><span class="num-string">10.7.1</span> Storing the company limits</h3>
</div>
<div class="readable-text" id="p184">
<p>We need a new table to store limits for the company. As with previous tables, this table will use a foreign key that references the company ID from the companies table. Remember that the use of the foreign key helps us maintain referential integrity for the database. The <code>ON</code> <code>DELETE</code> <code>CASCADE</code> and <code>ON</code> <code>UPDATE</code> <code>CASCADE</code> will ensure the record is removed when the company is deleted or changed accordingly if updated. Not every company needs to have limits, so we will keep that in mind as we create queries which utilize this table.</p>
</div>
<div class="browsable-container listing-container" id="p185">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.40<span class="CharOverride-5"> </span>Company Limits table</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TABLE company_limits
(
    company_limit_id   UUID               DEFAULT uuid_generate_v4(),
    company_id         UUID      NOT NULL REFERENCES 
                                 companies (company_id) 
                   ON DELETE CASCADE ON UPDATE CASCADE,
    daily_debit_limit  NUMERIC(12, 2)     DEFAULT NULL,
    daily_credit_limit NUMERIC(12, 2)     DEFAULT NULL,
    created_at         TIMESTAMP NOT NULL DEFAULT NOW(), #1
    updated_at         TIMESTAMP NOT NULL DEFAULT NOW() 
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Keeping track of when records are created and updated can help with auditing.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p186">
<p>There are a few approaches to implementing this functionality, and we will use a basic one that can be expanded as needed. The basic approach will not require us to store the totals. Instead we rely on the API to gather the totals and determine whether they are exceeded. This means that our logic will be executed when the company dashboard is displayed and when the file has finished loading so that we can add an associated exception. Remember from chapter 8 that if we want to add an exception, we will have to add it to the database along with any recovery options if desired. The following listing shows how the general_ach_data.sql was updated to insert these records.</p>
</div>
<div class="browsable-container listing-container" id="p187">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.41<span class="CharOverride-5"> </span>Setting up the exception data</h5>
<div class="code-area-container">
<pre class="code-area">INSERT INTO ach_exception_codes (exception_code, #1
    exception_severity, exception_description)  #1
VALUES ('006', 'warning',   #1
 'Company Limits  Exceeded');  #1
…
INSERT INTO ach_recovery_options #2
       (exception_code, recovery_option)   #3
VALUES ('006', 'Alert company their limit has been exceeded'); </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">We can add a new exception code for our company limits condition.</span>
<br/>#2 
     <span class="CharOverride-6">It is helpful to provide the users with some guidance on what to do when an exception is encountered.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p188">
<p>We also set up the data for the company limits so that there is existing data in the database. The following listing shows the simple insertion into the database table.</p>
</div>
<div class="browsable-container listing-container" id="p189">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.42<span class="CharOverride-5"> </span> Inserting records for the company limit</h5>
<div class="code-area-container">
<pre class="code-area">INSERT INTO company_limits 
   ( company_id, daily_debit_limit, daily_credit_limit)
VALUES (
        (SELECT c.company_id FROM companies AS c 
              WHERE tax_id_number = '459876543'),
        400.00,
        750.00
       );</pre>
</div>
</div>
<div class="readable-text" id="p190">
<p>That should be all we need to get up and running with company limits. The next section will show you how to update APIs so that you can work with the table.</p>
</div>
<div class="readable-text" id="p191">
<h3 class="readable-text-h3"><span class="num-string">10.7.2</span> Implementing the company limits API</h3>
</div>
<div class="readable-text" id="p192">
<p>Take a minute to think about what we would like to accomplish with the company limits API. Of course, we need to be able to retrieve what the limits are set to, but we will also want to determine what the current totals are for the company and a Boolean flag to indicate whether the limits have been exceeded. As mentioned, when designing the database tables, we decided not to store the current totals for the debits and credits, although we certainly could have created those fields and updated them as we loaded them.</p>
</div>
<div class="readable-text intended-text" id="p193">
<p>A potential drawback in this case is that depending on when/where we decide to do this check, we may have limited ability to narrow down the problem for the user. We should take a moment to think about where the exception can be written. For example, we just added a check for the expected files right after the file was loaded. Should we put this check in the same place? That may be our first inclination since we just added similar code. However, by putting it there, we miss out on being able to identify which batch is responsible for causing the company limit to be exceeded as we do not access the record numbers at that point, and it makes it difficult to put the actual batch header on the exception. The following listing shows that we included the exception during the processing of the batch control record.</p>
</div>
<div class="browsable-container listing-container" id="p194">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.43<span class="CharOverride-5"> </span>Adding the exception</h5>
<div class="code-area-container">
<pre class="code-area">case "8":
    ach_record = AchRecordType8Schema(
        ach_records_type_5_id=current_batch_header_id,
            unparsed_record=line,
            sequence_number=sequence_number,
         )
    ach_record_id = AchRecordsSqlType8().insert_record(ach_record)
    self.last_trace_number = None
    self._parse_batch_control(ach_record_id, line)
    if CompanyLimitsSql(). #1
<span class="CharOverride-8">➥</span>file_exceeds_company_limits(ach_file_id): 
        AchExceptionsSql().insert_record( #2
            AchExceptionSchema( #3
                ach_files_id=ach_file_id,  #4
                ach_batch_id=current_batch_header_id,  #4
                record_number=sequence_number,  #4
                exception_code=  #4
                   AchExceptions.COMPANY_LIMITS_EXCEEDED.value,  #4
            )  #4
        ) </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Checks whether we exceeded the company limits</span>
<br/>#2 
     <span class="CharOverride-6">Calls the insert_record method from AchExceptionsSql </span>
<span class="CharOverride-6">to insert the record</span>
<br/>#3 
     <span class="CharOverride-6">This is our standard exception schema. It is the first time we actually use the ach_batch_id, although there are plenty of exceptions we need it for.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p195">
<p>We write out our new <code>COMPANY_LIMITS_EXCEEDED</code> exception when a file exceeds company limits. This means that we need to define the <code>CompanyLimitsSql</code> class and a method to determine whether the file exceeds the company limits. We can tell from the use of the method that it just needs to return a Boolean value to determine whether this causes an exception. The method itself is straightforward, with the usual getting of the connection running a SQL query and fetching the results. The following listing shows the method details.</p>
</div>
<div class="browsable-container listing-container" id="p196">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.44<span class="CharOverride-5"> </span>Determining whether a file exceeded company limits</h5>
<div class="code-area-container">
<pre class="code-area">with get_db_connection(row_factory=class_row(CompanyLimitsRecord)) as conn:
   result = conn.execute(
   """
      WITH ach_batch_totals AS ( #1
         SELECT
                c.company_id,
                SUM(abcr.total_credit_entry_dollar_amount) #2
                                     AS current_credit_total,  #2
                SUM(abcr.total_debit_entry_dollar_amount)   #2
                                     AS current_debit_total 
           FROM ach_files AS af
     INNER JOIN ach_records_type_1 AS art1 USING (ach_files_id)
     INNER JOIN ach_records_type_5 AS art5 USING (ach_records_type_1_id)
     INNER JOIN ach_records_type_8 AS art8 USING (ach_records_type_5_id)
     INNER JOIN ach_batch_headers AS abh USING (ach_records_type_5_id)
     INNER JOIN ach_batch_control_records AS abcr 
        USING (ach_records_type_8_id)
     INNER JOIN companies AS c 
        ON c.ach_company_id = abh.company_identification
          WHERE af.ach_files_id = %s
       GROUP BY c.company_id
   )
   SELECT 1 #3
   FROM ach_files AS af
   INNER JOIN ach_records_type_1 AS art1 USING (ach_files_id)
   INNER JOIN ach_records_type_5 AS art5 USING (ach_records_type_1_id)
   INNER JOIN ach_records_type_8 AS art8 USING (ach_records_type_5_id)
   INNER JOIN ach_batch_headers AS abh USING (ach_records_type_5_id)
   INNER JOIN companies AS c ON c.ach_company_id = abh.company_identification
   INNER JOIN company_limits AS cl USING (company_id)
    LEFT JOIN ach_batch_totals AS abt USING (company_id)
        WHERE af.ach_files_id = %s  #4
          AND ( abt.current_credit_total &gt; cl.daily_credit_limit #5
                OR abt.current_debit_total &gt; cl.daily_debit_limit ) 
        LIMIT 1
   """,
   [file_id, file_id],
   )
return result.fetchone() is not None #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Creates a CTE to </span>
<span class="CharOverride-6">select the batch totals</span>
<br/>#2 
     <span class="CharOverride-6">Sums the credits </span>
<span class="CharOverride-6">and debits</span>
<br/>#3 
     <span class="CharOverride-6">We only need to </span>
<span class="CharOverride-6">return something.</span>
<br/>#4 
     <span class="CharOverride-6">Selects the file and sums</span>
<br/>#5 
     <span class="CharOverride-6">We want to return a Boolean, so the “is not None” helps us return True/False.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p197">
<p>The previous listing helps us determine whether we need to write an exception, but we also need to define a method that will be used with the UI. This is similar to the previous SQL with the addition of the actual fields for the limits, the current totals, and flags indicating whether the limit was exceeded. We prefer to return explicit flags for the UI to use rather than have the UI rely on making the determination itself. The following listing shows the SQL used to return the required information for our <code>get_company_limits</code> method.</p>
</div>
<div class="browsable-container listing-container" id="p198">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.45<span class="CharOverride-5"> </span>Query for the totals, limits, and flags</h5>
<div class="code-area-container">
<pre class="code-area">WITH ach_batch_totals AS (
    SELECT
        c.company_id,
        SUM(abcr.total_credit_entry_dollar_amount) 
                                AS current_credit_total,
        SUM(abcr.total_debit_entry_dollar_amount) 
                                AS current_debit_total
    FROM ach_records_type_5 AS art5
    INNER JOIN ach_records_type_8 
                         AS art8 USING (ach_records_type_5_id)
    INNER JOIN ach_batch_headers 
                         AS abh USING (ach_records_type_5_id)
    INNER JOIN ach_batch_control_records 
                         AS abcr USING (ach_records_type_8_id)
    INNER JOIN companies AS c 
              ON c.ach_company_id = abh.company_identification 
             AND c.company_id = %s
    GROUP BY c.company_id
)
SELECT cl.company_limit_id,
       cl.daily_debit_limit,
       cl.daily_credit_limit,
       COALESCE(abt.current_credit_total, 0) AS current_credit_total, #1
       COALESCE(abt.current_debit_total, 0) AS current_debit_total, 
       CASE #2
           WHEN abt.current_credit_total &gt; cl.daily_credit_limit   #2
           THEN TRUE #2
           ELSE FALSE #2
       END AS daily_credit_exceeded,  #2
       CASE  #2
           WHEN abt.current_debit_total &gt; cl.daily_debit_limit   #2
           THEN TRUE  #2
           ELSE FALSE  #2
       END AS daily_debit_exceeded  #2
FROM company_limits AS cl
LEFT JOIN ach_batch_totals AS abt USING (company_id)
WHERE cl.company_id = %s</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Returns the current debit/credit totals; defaulting to zero when no batches are found</span>
<br/>#2 
     <span class="CharOverride-6">Returns flags to indicate whether limits have been exceeded</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p199">
<p>There is just some minor housekeeping to create the API endpoint and the class that holds the response for the UI, but there is plenty of existing code to reference for these tasks. In the next section, we finish adding the company limits to the dashboard.</p>
</div>
<div class="readable-text" id="p200">
<h3 class="readable-text-h3"><span class="num-string">10.7.3</span> Displaying the company limits</h3>
</div>
<div class="readable-text" id="p201">
<p>As we saw in figure 10.5, the component itself is straightforward as we are just trying to convey to the user in the simplest terms whether the limits have been exceeded. We do want to add a little more visual appeal to the component by displaying the amount as red when it exceeds the limit and green otherwise. The following listing shows the basics of setting this feature up.</p>
</div>
<div class="browsable-container listing-container" id="p202">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.46<span class="CharOverride-5"> </span>Company credits and debit limits</h5>
<div class="code-area-container">
<pre class="code-area">…
        axios.get&lt;CompanyLimitsResponse&gt;(`${apiUrl}/companies
<span class="CharOverride-8">➥</span>/${companyId}/limits`, …
   return (
…
      &lt;Title&gt;Company Limits&lt;/Title&gt;
      &lt;Typography component="p" variant="h4"&gt;
         Company Credits:
      &lt;/Typography&gt;
      &lt;Typography component="p" variant="h6"&gt;
      &lt;Typography component="span" 
                  variant="h6" 
                  style={{color: response.daily_credit_exceeded ? #1
                                                'red' : 'green'}}&gt; 
         {formatCurrency(response.current_credit_total)}
      &lt;/Typography&gt;
         {" of "}
         {formatCurrency(response.daily_credit_limit)}
      &lt;/Typography&gt;
      &lt;Typography component="p" variant="h4"&gt;
         Company Debits:
      &lt;/Typography&gt;
      &lt;Typography component="p" variant="h6"&gt;
      &lt;Typography component="span" 
                  variant="h6" 
                  style={{color: response.daily_debit_exceeded ? #2
                                              'red' : 'green'}}&gt; 
      {formatCurrency(response.current_debit_total)}
   &lt;/Typography&gt;
      {" of "}
      {formatCurrency(response.daily_debit_limit)}
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Colors the field red when the field has been exceeded</span>
<br/>#2 
     <span class="CharOverride-6">Colors the field green when </span>
<span class="CharOverride-6">the field is within range</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p203">
<p>The other aspects of the UI for the company limits already fall into place because we are using the existing logic for exceptions. So, that means that the file is automatically flagged as having an exception when viewing the dashboard, and the exception is returned to the DataGrid when viewing the exceptions. This does bring up a problem with viewing the exception for this company limit. We see the ACH batch control record (type 8), but we cannot easily tell which company it was dealing with. Even though we did save the batch header UUID as part of creating the exception, this was the first time we ever used it. It would be nice to update our code to include some batch header information when viewing an exception. Let’s use this opportunity to make a few changes to the exceptions and exception detail screens.</p>
</div>
<div class="readable-text intended-text" id="p204">
<p>First, the simplest change is to drop the column for the error code from the exceptions screen. From a developer’s perspective, this move makes sense, but it can be confusing and does not add any value to the UX, especially since end-users have the description the code translates to.</p>
</div>
<div class="readable-text intended-text" id="p205">
<p>Next, the details for the exception consisted of only the unparsed record, which used a generic alert component we created for other purposes. Now that we have some experience in creating a modal to display details as we did with the audit details in chapter 9, we can use those skills to build a more detailed screen. We can work on displaying the details we already have (we can move the error code to this screen if we want), as well as information we have not used yet, such as the recovery action. Figure 10.6 shows the exception details modal we ended up with.</p>
</div>
<div class="browsable-container figure-container" id="p206">
<img alt="A close-up of a computer screen  Description automatically generated" height="354" src="../Images/CH10_F06_Kardell.png" style="width: 100%; max-width: max-content;" width="430"/>
<h5 class="figure-container-h5"><span class="">Figure 10.6</span><span class=""> </span><span class="">Exception details modal</span></h5>
</div>
<div class="readable-text" id="p207">
<p>The <code>AchExceptionDetailsResponse</code> will have to be updated so that it returns the required information—the company name if available and a recovery action. If we have access to the records, there is certainly an opportunity to return a lot more information, but in the interest of bringing back the YAGNI principle (chapter 3), and as a reminder of KISS (Keep It Simple, Stupid), we only return what we need at the moment.</p>
</div>
<div class="readable-text intended-text" id="p208">
<p>The main work that we need to do is update the SQL statement for the <code>get_exception_detail_response</code>. We have to pull in extra tables to get the company name and recovery options. Keep in mind that we are not guaranteed to have recovery options nor are we guaranteed to have a company name. This means that we will want to avoid using an <code>INNER</code> <code>JOIN</code>. Instead, we will use a <code>LEFT</code> <code>JOIN</code> as in previous cases where we needed to keep the rows on one side of the query even when there were no matching records in the subsequent parts. The following listing shows the additional SQL logic that needs to be included. Note that since we have saved the parsed header record ID, we do not have to do a lot of joins to get to the record like in previous queries, where we had to start at the file level and drill down.</p>
</div>
<div class="browsable-container listing-container" id="p209">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.47<span class="CharOverride-5"> </span>Updates to get more exception details</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">SELECT
       ae.ach_exceptions_id AS id,
       af.created_at AS created_at,
       <span>ae.exception_code AS exception_code,</span>
<span>       aec.exception_description AS description,</span>
<span>       </span>acr.unparsed_record AS unparsed_record,
<strong>       COALESCE(c.name, abh.company_name, '') AS company_name, </strong>#1
<strong>       aro.recovery_option AS recovery_option</strong>
FROM ach_exceptions AS ae
INNER JOIN ach_exception_codes AS aec USING (exception_code)
INNER JOIN ach_files AS af USING (ach_files_id)
INNER JOIN ach_combined_records AS acr 
             ON ae.ach_files_id = acr.ach_files_id
             AND ae.record_number = acr.sequence_number
<strong>LEFT JOIN ach_recovery_options AS aro </strong>#2
<strong>                 USING (exception_code) </strong> #3
<strong>LEFT JOIN ach_batch_headers AS abh </strong> #3
<strong>                 USING(ach_records_type_5_id) </strong> #3
<strong>LEFT JOIN companies AS c  </strong> #3
<strong>             ON abh.company_identification = c.ach_company_id </strong> #3
WHERE ae.ach_files_id = %s 
AND ae.ach_exceptions_id = %s   </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">These fields are new to our query and select the company name if available and any recovery steps.</span>
<br/>#2 
     <span class="CharOverride-6">Joins the new tables. Again, we need to use LEFT JOIN because we are not guaranteed data will exist in tables.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p210">
<p>With the fields now included in our response, we can make the necessary updates to the UI to include them as well.</p>
</div>
<div class="browsable-container listing-container" id="p211">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.48<span class="CharOverride-5"> </span>Using the <code>ExceptionsModal</code></h5>
<div class="code-area-container">
<pre class="code-area">const [exceptionData, setExceptionData] = 
        useState&lt;AchExceptionDetailsResponse | null&gt;(null);
…
            setExceptionData(response.data);

            &lt;ExceptionsModal open={isOpen} #1
                             onClose={() =&gt; setIsOpen(false)}   #2
                             exceptionData={exceptionData} /&gt; 
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Includes the ExceptionsModal and the required parameters</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p212">
<p>The <code>ExceptionsModal</code> takes care of formatting the <code>exceptionData</code> and is based on what we did before for our <code>AuditModal</code> in chapter 9. We will not display the company name with this component if it is an empty string, and we would like to provide a default recovery option of None Provided if no recovery options were available. Depending on the situation, it can often be beneficial to display a confirmation or message that validates this is an expected situation—sort of a 21<span class="_Superscript _idGenCharOverride-1">st</span>-century “This page intentionally left blank” message. It may make sense not to include the company name if the problem is not directly dealing with a company (although a case could be made for referencing the batch for any entry exceptions as well). However, hiding the recovery options may make users think something has gone wrong, especially when they may depend on referring to recovery options. The following listing shows the basics of the modal. Since the query to return the exception detail uses the <code>COALESCE</code> function, we are guaranteed to return at the very least an empty string for the company name, so we use that knowledge to check whether the label and field should be displayed. In addition, we use <code>??</code> to default the recovery text when nothing has been provided.</p>
</div>
<div class="browsable-container listing-container" id="p213">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.49<span class="CharOverride-5"> </span>The <code>ExceptionsModal</code> Component</h5>
<div class="code-area-container">
<pre class="code-area">…
interface ExceptionModalProps {
  open: boolean;
  onClose: () =&gt; void;
  exceptionData: AchExceptionDetailsResponse | null;
}
…
const ExceptionsModal: FC&lt;ExceptionModalProps&gt; = 
      ({ open, onClose, exceptionData }:
<span class="CharOverride-8">➥</span> Readonly&lt;ExceptionModalProps&gt;) =&gt; {
  return (
 …
        { exceptionData?.company_name !== '' &amp;&amp; #1
            &lt;Box&gt;  #1
        &lt;Typography id="audit-modal-description"   #1
           sx={{ mt: 2 }}  fontWeight={'fontWeightBold'}&gt;  #1
          Company Name:  #1
        &lt;/Typography&gt;  #1
        &lt;Typography&gt;{exceptionData?.company_name}&lt;/Typography&gt;  #1
        &lt;/Box&gt;  #1
        }  #1
  …
        &lt;Typography&gt; #2
          {exceptionData?.recovery_option ?? 'None Provided'}  #3
        &lt;/Typography&gt; 
     &lt;Button onClick={onClose} sx={{ mt: 2 }}&gt;
          Close
        &lt;/Button&gt;
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Conditionally includes the company name if something was returned</span>
<br/>#2 
     <span class="CharOverride-6">Always prints something for the recovery steps, even if it is just something to let users know they are on their own</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p214">
<p>Only slight adjustments to the Exceptions component are necessary to ensure that data is passed properly to the new modal. The following listing shows the updated Exceptions component. The biggest change here is simply passing a function that will set the open state to <code>False</code> when the modal button is clicked.</p>
</div>
<div class="browsable-container listing-container" id="p215">
<h5 class="listing-container-h5 browsable-container-h5">Listing 10.50<span class="CharOverride-5"> </span>The Exceptions component</h5>
<div class="code-area-container">
<pre class="code-area">…    
const [isOpen, setIsOpen] = useState(false);
    const [exceptionData, setExceptionData] = 
              useState&lt;AchExceptionDetailsResponse | null&gt;(null);
        {field: 'file_name', headerName: 'Filename', width: 150},
        {field: 'created_at', headerName: 'Date', width: 150, 
           valueGetter: (params) =&gt; convertDateFormat(params.value)},
        {field: 'record_number', headerName: 'Record Number', width: 150},
<span class="CharOverride-9">        {field: 'exception_code', headerName: 'Code', width: 10},</span> #1
        {field: 'description', headerName: 'Description', width: 300},
…
            &lt;ExceptionsModal open={isOpen}  #2
onClose={() =&gt; setIsOpen(false)}  #3
 exceptionData={exceptionData} /&gt;  #3
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">No longer needed because it does not add anything useful for the user</span>
<br/>#2 
     <span class="CharOverride-6">Includes the ExceptionsModal</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p216">
<p>So, we have now built a company dashboard that provides information that can ensure correct/desired files are loaded, show recent batches for the company, and send alerts when activity does not match the company’s expectations. </p>
</div>
<div class="readable-text" id="p217">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p218">Sprint planning in this chapter focused on building key components—company information, recent batches, expected files, and company limits—emphasizing the importance of comprehensive data-structure design.</li>
<li class="readable-text" id="p219">A company-level dashboard was created to address the need for storing and displaying detailed company information beyond the initial project scope.</li>
<li class="readable-text" id="p220">The importance of building robust company data management systems that provide a framework for enhancing ACH-processing services for business customers who need detailed batch information was highlighted.</li>
<li class="readable-text" id="p221">Designing foundational company information tables as blockers stressed their dependency on further development and the consideration of early work on some components to reduce modifications.</li>
<li class="readable-text" id="p222">Generative AI can help create meaningful test data quickly, which enhances productivity by generating more than typical name and address information, including logos.</li>
<li class="readable-text" id="p223">Implementing a company dashboard demonstrated the necessity of organizing UI structures for efficient navigation and detailed data presentation for specific company metrics.</li>
<li class="readable-text" id="p224">Creating detailed UI components for company overviews highlighted the value of user-friendly interfaces that facilitate seamless navigation and interaction at the company level.</li>
<li class="readable-text" id="p225">Designing an API for company data retrieval reinforced the importance of well-structured responses and validation mechanisms for dynamic user inter­action with dashboards.</li>
<li class="readable-text" id="p226">Developing recent batch components highlighted the importance of flexible search functions for batch data retrieval to meet diverse business needs.</li>
<li class="readable-text" id="p227">Creating expected file components stressed the need for alerting mechanisms and schedule compliance to ensure timely processing of crucial documents and mitigate risks.</li>
<li class="readable-text" id="p228">Proactive monitoring of ACH files was explored to shift from reactive to pro­active measures for improved customer service.</li>
<li class="readable-text" id="p229">Company limit components emphasized configurable alerts and thresholds to safeguard against unauthorized or unexpected financial transactions.</li>
<li class="readable-text" id="p230">Expanding exception functionality, such as alert generation, can help us notify customers through various channels if limits are exceeded.</li>
<li class="readable-text" id="p231">Utilizing Testcontainers enhances testing reliability by ensuring isolated environments, eliminating dependency on developer-specific configurations, and allowing robust and portable tests.</li>
</ul>
</div></body></html>