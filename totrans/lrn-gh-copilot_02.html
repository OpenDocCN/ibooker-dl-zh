<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section class="pagenumrestart" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 1. Foundations"><div class="chapter" id="ch01">
<h1><span class="label">Chapter 1. </span>Foundations</h1>

<p><a contenteditable="false" data-primary="Chat (Copilot)" data-see="Copilot Chat" data-type="indexterm" id="id381"/><a contenteditable="false" data-primary="Codespaces" data-see="GitHub Codespaces" data-type="indexterm" id="id382"/><a contenteditable="false" data-primary="Copilot" data-see="GitHub Copilot" data-type="indexterm" id="id383"/>Welcome to <em>Learning GitHub Copilot</em>! I’m excited you’re reading this book and hope you find it useful. AI tools like ChatGPT and AI agents have changed, and will continue to change, how we interact with software applications. GitHub Copilot and similar tools have changed, and will continue to change, how programmers create software applications. Through its ability to take context from existing code or natural language prompts, GitHub Copilot provides a richer and more powerful code-generation capability than any we’ve seen before.</p>

<p>In this book, I’ll help you understand how to use GitHub Copilot<a contenteditable="false" data-primary="GitHub Copilot" data-secondary="capabilities" data-type="indexterm" id="id384"/>’s capabilities—from performing code generation and completion, forming tests, and translating and explaining code, to working with repositories, pull requests, and issues directly in GitHub. You’ll see examples of using Copilot across multiple domains and programming languages. You’ll learn to leverage it to your advantage and craft prompts to get the best results. You’ll even learn how to add your own custom functionality to it. And you’ll understand how it does what it does, including why it sometimes doesn’t provide the results you expect—and how to mitigate those situations.</p>

<p>Some foundational knowledge is required to begin with, though. That’s the purpose of this chapter. I’ll start by explaining GitHub Copilot at a high level. We’ll then explore the key underlying technology, its overall flow, some usage considerations, how it differs from tools like ChatGPT, and what you need to know about getting and installing it. So, let’s get started.</p>

<div data-type="note" epub:type="note">
<h1>Copilot Catchall</h1>

<p>As we begin this discussion, be aware that <em>copilot</em> is a popular term for AI applications that collect information, formulate prompts, and return answers and suggestions. For example, Microsoft<a contenteditable="false" data-primary="Microsoft 365 Copilot" data-type="indexterm" id="id385"/> has an <a href="https://oreil.ly/DaSLT">Office 365 Copilot</a><a contenteditable="false" data-primary="Office 365 Copilot" data-type="indexterm" id="id386"/> that does this for Microsoft Office applications. It analyzes context from Word, Teams, Outlook, etc., and provides summarizations, suggested responses, and other valuable interactions.</p>

<p>In this book, I use <em>Copilot</em> to mean <em>GitHub Copilot</em>. The only exceptions will occur when I am referring to another system that uses the same word. In those cases, I’ll explicitly identify them with their formal names, such as <em>Office 365 Copilot</em>.</p>
</div>

<section data-type="sect1" data-pdf-bookmark="What Is GitHub Copilot?"><div class="sect1" id="id2">
<h1>What Is GitHub Copilot?</h1>

<p>GitHub Copilot<a contenteditable="false" data-primary="GitHub Copilot" data-secondary="what it is" data-type="indexterm" id="xi_GitHubCopilotwhatitis12118"/> is a cloud-based, generative artificial intelligence<a contenteditable="false" data-primary="AI (artificial intelligence)" data-type="indexterm" id="xi_AIartificialintelligence12171"/> (AI) tool. Let’s break down these buzzwords. We can generically define AI as <em>computers doing tasks that previously only humans were thought to be able to accomplish because of required reasoning and skills</em>. More recently, this has also taken on the aspect of interacting with humans in a natural and human-like way through natural language processing (NLP), chat interfaces, and automated processing and decision making with AI agents.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id387">
<h1>AI Concerns</h1>

<p>When we talk about AI, popular culture would have us think of machines becoming conscious, sentient, and taking over the world. While many of us in the technical professions understand that that is not realistic, programmers using tools like GitHub Copilot may think of AI (in the coding domain) as potentially taking over their jobs.</p>

<p>Some job displacement has undoubtedly taken place due to the use of AI. But this is not the intended purpose of Copilot. For all the seeming intelligence that Copilot may display in some use cases, it is still subject to creating incorrect or unusable code. And it still needs human oversight and review. The hope is that the information in this book will help make this particular AI tool a valuable tool in your toolbox to assist you in your project and in your role.</p>
</div></aside>

<p><em>Cloud-based<a contenteditable="false" data-primary="cloud-based" data-type="indexterm" id="id388"/></em> refers to the pathway through which Copilot returns suggestions and generates answers. It refers to a cloud environment managed by GitHub that facilitates interaction with the AI models. <em>Generative<a contenteditable="false" data-primary="generative" data-type="indexterm" id="id389"/></em> expresses the AI’s ability to <em>generate</em> new results from the context it takes in. Copilot can offer responses and suggestions for software development based on the context and prompts from the user’s environment. How well it does this depends on several factors that we’ll talk about in the next section. But, as a quick example, <a data-type="xref" href="#using-copilot-on-a-pr">Figure 1-1</a> shows using Copilot to suggest optimizations based on a project in Visual Studio (VS) Code.</p>

<figure><div id="using-copilot-on-a-pr" class="figure"><img alt="" src="assets/lghc_0101.png" width="1881" height="955"/>
<h6><span class="label">Figure 1-1. </span>Using Copilot on a project in VS Code</h6>
</div></figure>

<div data-type="note" epub:type="note">
<h1>Default IDE</h1>

<p>Because it’s not possible to represent all integrated development environments<a contenteditable="false" data-primary="IDEs" data-type="indexterm" id="id390"/> (IDEs) in this book, we’ll be using VS Code or GitHub Codespace in our examples where an IDE is involved. If you use a different IDE, please consult the Copilot documentation for any differences in use, controls, etc<a contenteditable="false" data-primary="" data-startref="xi_GitHubCopilotwhatitis12118" data-type="indexterm" id="id391"/><a contenteditable="false" data-primary="" data-startref="xi_AIartificialintelligence12171" data-type="indexterm" id="id392"/>.</p>
</div>
</div></section>

<section data-type="sect1" data-pdf-bookmark="How Does Copilot Work?"><div class="sect1" id="id121">
<h1>How Does Copilot Work?</h1>

<p>To<a contenteditable="false" data-primary="GitHub Copilot" data-secondary="how it works" data-type="indexterm" id="xi_GitHubCopilothowitworks1476"/> understand how Copilot works, we need to understand some of the pieces that underpin its functionality and that of similar AI tools. These details include where it gets information to base responses on and its overall flow.</p>

<p>Copilot and most AI applications get their data from large language models (LLMs) trained on extensive data collections. If you’re unfamiliar with term LLM, the following section provides a brief explanation.</p>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Large Language Models"><div class="sect2" id="id3">
<h2 class="less_space">Large Language Models</h2>

<p><a contenteditable="false" data-primary="LLMs (large language models)" data-type="indexterm" id="xi_LLMslargelanguagemodels1544"/>It’s challenging to discuss AI tooling today without mentioning LLMs. LLMs are AI models trained on vast amounts of existing data to predict the next words or other types of content (e.g., <em>tokens</em>) that <em>fit</em> given some input (a <em>prompt</em>).</p>

<p>LLMs differ from traditional computer models that can process formatted data or respond to a math problem because LLMs are taught to understand context, syntax, and structure. This is done by algorithms that consider vast numbers of parameters to figure out what words or tokens make the most sense to come next. In this way, the models statistically craft responses based on how the input is presented, not just the input itself.</p>

<p>The model’s prediction capabilities are learned and tuned from extensive collections of existing content. In this training process, the models map how the various pieces of information relate in any given domain. Technically, given a sequence of tokens as a query, LLMs can assess the input’s syntax and structure, infer context based on the model’s training data, and predict the sequence of tokens that would likely come next. Simply put, LLMs can figure out what would sound right based on all the data they’ve digested and continue the conversation.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id393">
<h1>Not Just LLMs</h1>

<p>There are more variants of AI models than just <em>traditional<a contenteditable="false" data-primary="traditional LLMs" data-type="indexterm" id="id394"/></em> LLMs, such as small language models and reasoning models. Copilot continues to be updated to use various models with different capabilities and training, but we’re using the LLM terminology to keep explanations simple.</p>
</div></aside>

<p>To appreciate the difference from traditional processing, think of learning a language and then conversing with someone who speaks it as a first language. You can learn the vocabulary and individual words and phrases. But in a conversation with someone who speaks this language well, you also need to gather and understand the context of what the other person is saying. This is so you can choose the right words or phrases to respond with. You also need to be able to frame your response in a context that will make sense to the other person. Language has syntax and structure, but the context of a conversation is how we ensure that syntax and structure make sense and convey meaning. LLMs can assess context from the inputs and supply relevant context in their outputs.</p>

<p class="pagebreak-before">Turning back to Copilot, it uses, by default, LLMs developed and managed by <a href="https://openai.com">OpenAI</a><a contenteditable="false" data-primary="OpenAI" data-type="indexterm" id="id395"/>, the same company behind <a href="https://chat.openai.com">ChatGPT</a><a contenteditable="false" data-primary="ChatGPT" data-type="indexterm" id="id396"/>. In conjunction with OpenAI, GitHub developed Copilot over several years. Recently, they have added options to use several other families of models, including ones from Claude<a contenteditable="false" data-primary="Claude (Anthropic)" data-type="indexterm" id="id397"/> by Anthropic<a contenteditable="false" data-primary="Anthropic's Claude" data-type="indexterm" id="id398"/> and Google Gemini<a contenteditable="false" data-primary="Google Gemini" data-type="indexterm" id="id399"/>. Across models, the common characteristic of Copilot is the focus on creating software, and its conversational language is code<a contenteditable="false" data-primary="" data-startref="xi_LLMslargelanguagemodels1544" data-type="indexterm" id="id400"/>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Code and Generative AI"><div class="sect2" id="id4">
<h2>Code and Generative AI</h2>

<p><a contenteditable="false" data-primary="code" data-secondary="generative AI and" data-type="indexterm" id="xi_codegenerativeAIand1744"/><a contenteditable="false" data-primary="generative AI" data-secondary="code and" data-type="indexterm" id="xi_generativeAIcodeand1744"/>Programming languages, by definition, have specific, required syntax and semantics that differ for each language. When coding in Python versus Go, you use different tokens and structures to create the program. However, the tokens and structure you use have rules. They are well-defined and form a closed set. Copilot’s abilities are targeted to provide coding suggestions and related information that match syntax and structure. But the real value-add is providing responses that are relevant to what the coder is creating or prompting about. The context that gets fed into Copilot can come from several sources, including these:</p>

<ul>
	<li>A set of code being written in an editor in a development environment</li>
	<li>Interactions with the model via direct natural language prompts or queries, aka <em>chat models</em></li>
	<li>Typical development activities in GitHub itself, such as pull requests</li>
</ul>

<p class="fix_tracking">I’ll discuss these interactions more throughout the book. But regardless of the interface, the context (code, directives/input, or GitHub elements you work with) gets turned into a <em>prompt<a contenteditable="false" data-primary="prompts" data-type="indexterm" id="id401"/></em>—your side of the conversation that you expect the AI to respond to. Processing those and deciding on a response based on context and the model’s training and capabilities is the <em>generative</em> part of Copilot’s <em>generative AI </em>functionality. The response can be suggested code, an answer to a question, or step-by-step directions. It is what the AI thinks completes the code, satisfies the prompt, or answers the query.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id402">
<h1>Chat Models</h1>

<p><a contenteditable="false" data-primary="chat models" data-type="indexterm" id="id403"/>Most of the time, we think of programming as sitting in front of a terminal and typing code into an IDE. However, a programmer often needs to answer some questions or gain some understanding before entering the code. For example, if learning a new language, they may need to understand how to implement a data structure or control flow. Or they may need to know how to open files or read and write to a database. Going further, they might want to understand the differences in versions of a third-party platform or whether a certain functionality is deprecated. These are the kinds of details you might ask a colleague about or search for on Stack Overflow. If you’re using AI instead, you need to be able to communicate questions or directives to the AI (have the ability to <em>chat</em> with it).</p>

<p>Typical <em>social</em> implementations of generative AI (like ChatGPT<a contenteditable="false" data-primary="ChatGPT" data-type="indexterm" id="id404"/>) have gained broad appeal because they can<em> </em>converse and respond in a human-friendly way. Copilot adds this ability through <em>Copilot Chat<a contenteditable="false" data-primary="Copilot Chat" data-type="indexterm" id="id405"/></em>. Using this chat interface, it’s simple to prompt Copilot for tasks like “generate unit tests for the code” as well as ask it questions like “What is the current version of Kubernetes?” and even “What does this code do?” Generating answers based on directives or questions in the chat interface is another example of the <em>generative</em> part of <em>generative AI</em>.</p>
</div></aside>

<p>You can think of this process like describing a set of symptoms to a doctor over a Zoom call so they can try to reach a diagnosis based on their years of training. Or describing to the car mechanic over the phone an issue that you are seeing with your vehicle so that they can suggest a fix. In these cases, the communication and context you provide, with the professional’s training, make all the difference. The interaction can result in suggestions to address the issue (some of which may not apply) or indicate that the professional didn’t have enough context or understanding to help. Generative AI behaves the same way.</p>

<p>When Copilot offers suggestions as you’re coding, items in your coding environment provide the context to create a prompt for the AI model. Copilot can produce suggestions that follow the coding style used in the files that are part of the project you’re working on. This can be both good and bad.</p>

<p>It can be good that Copilot’s suggestions are often similar to the users’ existing coding styles if those coding styles reflect best practices. It can be bad if Copilot sometimes skews too much towards bad practices in existing code. The latter situation can lead to reinforcing limited and inefficient coding practices—or you may have to wade through a more extensive set of suggestions to find the one that fits. The quality and quantity of the examples that Copilot has to draw on from your environment, and its own training, can affect its responses.</p>

<p>Ultimately, the generative AI employed with Copilot can be very useful. Still, be aware that the coding suggestions will be biased by the context and training Copilot has to work with. You can use this to your advantage to provide Copilot with more examples of the style of suggestions it should return. However, this bias can also be a disadvantage if the context that Copilot has to work with is limited. We’ll discuss how to help Copilot return the best results throughout the book.</p>

<p>Let’s briefly look at Copilot’s high-level flow to understand more about how it interacts with context to respond to you<a contenteditable="false" data-primary="" data-startref="xi_codegenerativeAIand1744" data-type="indexterm" id="id406"/><a contenteditable="false" data-primary="" data-startref="xi_generativeAIcodeand1744" data-type="indexterm" id="id407"/>.</p>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="High-Level Flow"><div class="sect2" id="id5">
<h2 class="less_space">High-Level Flow</h2>

<p><a contenteditable="false" data-primary="high-level flow" data-type="indexterm" id="xi_highlevelflow11064"/>To understand how Copilot works at a high level, we can trace the basic workflow from the perspective of working in one of the supported IDEs. Currently, the supported IDEs for Copilot include Visual Studio<a contenteditable="false" data-primary="Visual Studio" data-type="indexterm" id="id408"/>, VS Code<a contenteditable="false" data-primary="VS Code (Visual Studio Code)" data-type="indexterm" id="id409"/>, NeoVim<a contenteditable="false" data-primary="Neovim" data-type="indexterm" id="id410"/>, any of the JetBrains<a contenteditable="false" data-primary="JetBrains" data-type="indexterm" id="id411"/> family of IDEs, and others. Copilot also works in selected other environments, such as <a href="https://oreil.ly/QyEks">GitHub Codespaces</a><a contenteditable="false" data-primary="GitHub Codespaces" data-type="indexterm" id="id412"/>.</p>

<p>GitHub has also released the <a href="https://oreil.ly/6rDHq">Copilot Language Server SDK</a><a contenteditable="false" data-primary="Copilot Language Server SDK" data-type="indexterm" id="id413"/>, which can be used to integrate GitHub Copilot into any editor or IDE. So, expect to see more applications integrated with Copilot in the future.</p>

<div data-type="note" epub:type="note">
<h1>About Codespaces</h1>

<p>GitHub Codespaces utilize virtual machines (VMs) running in the cloud that provide a full-featured and customizable development environment for GitHub users. Their interface is similar to that of VS Code; they can be tailored with the same extensions used in VS Code in a browser or connected to several IDEs. GitHub provides them as an optional service.</p>
</div>

<p>When writing code in an editor and using Copilot to suggest coding completions, several pieces of information are automatically scanned to gather context about what you’re working on:</p>

<dl>
	<dt>Current file</dt>
	<dd>The current file<a contenteditable="false" data-primary="current file" data-type="indexterm" id="id414"/> that a user is editing is one key source of context for Copilot.</dd>
	<dt>Name of the currently active file</dt>
	<dd>When named descriptively, this can provide Copilot with clues about what the code is intended to do, such as <em>TestConfig.go</em>.</dd>
	<dt>Content before and after the current cursor position</dt>
	<dd>Copilot can draw context from the code and comments immediately before and after the cursor position in the file. This can help it decide what to fill in and/or understand gaps in the code.</dd>
	<dt>Comments</dt>
	<dd><a contenteditable="false" data-primary="comments" data-type="indexterm" id="id415"/>Like human pair programmers or reviewers, Copilot can use comments to understand what code is doing and the intent of code that has yet to be written. This is one of the primary ways to provide context for Copilot—the more precise and detailed the comments, the more likely the code that Copilot suggests will be relevant.</dd>
	<dt>Other open files in the editor</dt>
	<dd>Copilot uses the code being developed in any open files as context. This is key to gathering information about the current task and augmenting information in the model. For example, one strategy for dealing with deprecated features stored in the LLM is to open a file in the editor with the replacement approach for the deprecated feature. From this example, Copilot can interpret preferred alternatives for coding instead of relying on the deprecated approach used to train the LLM.</dd>
	<dt>Local index</dt>
	<dd><a contenteditable="false" data-primary="local index" data-type="indexterm" id="id416"/>Copilot automatically parses most files in a project opened in IDEs like VS Code and builds an advanced local <em>index</em> for the project. (See the following sidebar for more info.)</dd>
</dl>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id417">
<h1>Indexing</h1>

<p>In the context of Copilot, <em>indexing<a contenteditable="false" data-primary="indexing" data-type="indexterm" id="id418"/></em> refers to a process of scanning and organizing the codebase to create a structure that can be searched quickly and accurately. This enables Copilot to provide more accurate and context-aware coding suggestions and responses than it could without the index.</p>

<p>A <em>local index </em>is created and updated automatically as changes are made and stored on the user’s machine. When used in GitHub (<a data-type="xref" href="ch09.html#ch09">Chapter 9</a>), Copilot creates a <em>remote index<a contenteditable="false" data-primary="remote index" data-type="indexterm" id="id419"/></em> paired to the repository there.</p>
</div></aside>

<p>If you are using the chat interface, it will usually be pre-populated with a file, selection, or terminal command as context, depending on what you were most recently working on. However, you can explicitly change that before submitting your prompt. (More on this in <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>.)</p>

<p class="pagebreak-before">So, when you’re using one of the interfaces with Copilot installed and activated, Copilot gathers context from these sources as you enter code (<a data-type="xref" href="#gathering-context-fro">Figure 1-2</a>).</p>

<figure><div id="gathering-context-fro" class="figure"><img alt="" src="assets/lghc_0102.png" width="1257" height="1296"/>
<h6><span class="label">Figure 1-2. </span>Gathering context from the IDE environment</h6>
</div></figure>

<p class="pagebreak-before">That context is processed and ultimately sent to GitHub, synthesized into a prompt (<a data-type="xref" href="#prompt-synthesized">Figure 1-3</a>).</p>

<figure><div id="prompt-synthesized" class="figure"><img alt="" src="assets/lghc_0103.png" width="1255" height="1160"/>
<h6><span class="label">Figure 1-3. </span>Synthesizing the prompt</h6>
</div></figure>

<p>The prompt is then passed through GitHub to the LLM, and possible completions or answers are returned. Once results are generated from the prompt to the LLM, GitHub’s Copilot systems perform additional processing on the result (more on that later). After that, the response is returned to the IDE, where you can evaluate it and choose how to proceed. See <a data-type="xref" href="#flow-from-prompt-to-s">Figure 1-4</a> for the flow for code completion.</p>

<p>This process continues and repeats with the user/Copilot interactions. In this way, Copilot acts as an assistant to help you with whatever use case you are working on, whether crafting boilerplate code, searching for a sophisticated algorithm, generating data or queries, writing unit tests, or learning a new programming language.</p>

<figure><div id="flow-from-prompt-to-s" class="figure"><img alt="" src="assets/lghc_0104.png" width="1442" height="1111"/>
<h6><span class="label">Figure 1-4. </span>Flow from the prompt to suggestions</h6>
</div></figure>

<p>You’ll see more of how the flow happens as we discuss how to use Copilot throughout the remaining chapters. But at this point, it’s worth understanding some of the usage considerations when using Copilot to help you produce software<a contenteditable="false" data-primary="" data-startref="xi_GitHubCopilothowitworks1476" data-type="indexterm" id="id420"/><a contenteditable="false" data-primary="" data-startref="xi_highlevelflow11064" data-type="indexterm" id="id421"/>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Usage Considerations"><div class="sect1" id="id122">
<h1>Usage Considerations</h1>

<p><a contenteditable="false" data-primary="GitHub Copilot" data-secondary="usage considerations" data-type="indexterm" id="xi_GitHubCopilotusageconsiderations11674"/>Now that you know what Copilot is and how it works, here’s a key point to understand: Copilot, like any AI, can give incorrect or incomplete answers. It can be wrong, or it can give you unexpected results. This is not common, but you should keep some important things in mind when using it so you can be aware. In this section, we’ll look at the following considerations:</p>

<ul class="pagebreak-before two-col">
	<li>Timeliness</li>
	<li>Relevance</li>
	<li>Completeness</li>
	<li>Accuracy</li>
	<li>Privacy</li>
	<li>Security</li>
</ul>

<p>And by the way, these aren’t unique to Copilot. They can apply to any current AI tool assisting you with a task.</p>

<section data-type="sect2" data-pdf-bookmark="Timeliness"><div class="sect2" id="id6">
<h2>Timeliness</h2>

<p><em>Timeliness<a contenteditable="false" data-primary="timeliness" data-type="indexterm" id="xi_timeliness118318"/></em> here refers to the currency of Copilot’s suggestions. This may seem like an odd choice to start with, but it can intersect with all of the others.</p>

<p class="fix_tracking">Copilot relies on models trained initially at a point in time, so its data is based on what was current in the training data at that point. For example, if the model Copilot uses was trained two years ago, it does not necessarily know about changes since then.</p>

<p>Your everyday use of Copilot can produce outdated suggestions and answers. Results could contain deprecated code that no longer works with your compiler or interpreter. You could get a suggestion that references a version of a dependency with a known vulnerability or a response that might include an outdated approach.</p>

<p>You might ask the chat interface in Copilot, “Is <em>X</em> deprecated?” and get an answer that <em>X</em> is <em>not</em> deprecated when, in fact, it is. Copilot is answering as of the point in time when the model it is using was trained. Or you might ask, “What is the current version of <em>X</em>?” and get a result from two years ago. I’m sure you can see how this could cause issues. Results can also vary significantly depending on the model you’ve chosen (from the ones that Copilot supports) for the current interaction<a contenteditable="false" data-primary="" data-startref="xi_timeliness118318" data-type="indexterm" id="id422"/>.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id423">
<h1>Getting Current Version Info</h1>

<p class="fix_tracking"><a contenteditable="false" data-primary="current version" data-type="indexterm" id="id424"/>Say you ask Copilot through the chat interface, “What is the current version of <em>X</em>?” In most cases, the response will vary depending on the model being used. In some cases, the response will include “as of the date of training” or something similar. In other cases, Copilot will recommend that you consult the documentation for the latest information.</p>

<p>You can’t expect a model to know what the latest version is, so asking it isn’t usually useful. The question can <em>sometimes</em> be useful, to give you an idea of which version was current when the model was trained, but the correctness and detail of that response will vary by model.</p>
</div></aside>

<p><a data-type="xref" href="ch07.html#ch07">Chapter 7</a> discusses techniques for providing Copilot with more up-to-date context for deprecated items within your environment, increasing the likelihood of returning more up-to-date responses.</p>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Relevance"><div class="sect2" id="id7">
<h2 class="less_space">Relevance</h2>

<p><a contenteditable="false" data-primary="relevance" data-type="indexterm" id="id425"/>Copilot’s suggestions and chat responses are based on LLMs trained on large sets of code. If you’re using the default OpenAI models, that codebase<a contenteditable="false" data-primary="codebase" data-type="indexterm" id="id426"/> is the public code hosted on GitHub. GitHub arguably has the most comprehensive collection of repositories for open source software. This includes code written in today’s most popular programming languages, such as Python, Go, and JavaScript.</p>

<p>Given the training, it stands to reason that Copilot will be most effective when you’re working in one of the more common programming languages or frameworks represented in the codebase used for training. The more a language or framework is represented in that collection (GitHub repositories for the OpenAI models), the more references Copilot can learn from. Think of it like the subjects you spent more time studying in school—those are the ones you know the most about.</p>

<p>If you’re working in a less represented language or framework, the suggestions may not be as useful. That doesn’t imply you can’t get relevant suggestions and answers, but you may find them less helpful in answering your exact query.</p>

<p>A key factor beyond Copilot’s control is the amount of context it has to work with. For example, if your code consists of a function named <code translate="no">ParseData</code> or you supply a generic or ambiguous prompt, such as “Create a function to parse data,” without additional context, the results returned from Copilot are likely to also be generic.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Completeness"><div class="sect2" id="id8">
<h2>Completeness</h2>

<p>Gene<a contenteditable="false" data-primary="completeness" data-type="indexterm" id="id427"/>rative AI can sometimes return incomplete or unusable suggestions. This rarely happens in the chat interface, but it’s not uncommon for Copilot’s code completion to return a set of suggestions that are only partial solutions.</p>

<p>The same caveat discussed at the end of the previous section on relevancy applies here. If your code or query is generic or ambiguous, Copilot may not have enough context to draw on to return a complete result.</p>

<p>In other instances, you might provide specific context to Copilot, but it suggests only a comment or the first line of a function. This is generally seen when working through the suggestion process in the IDE rather than in the chat interface. You may need to provide additional prompting or supply more context for Copilot. Sometimes you can <em>nudge </em>Copilot by giving it a hint (typing a keyword, for example), and that will be enough to make it return a more complete suggestion. At other times, Copilot may simply respond with a blank line, and accepting that response may cause it to continue generating code.</p>

<p>Copilot does offer options to get more suggestions if the immediate one isn’t a good fit, but those can be of limited utility. I’ll delve into details on those approaches in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Accuracy"><div class="sect2" id="id9">
<h2>Accuracy</h2>

<p><a contenteditable="false" data-primary="accuracy" data-type="indexterm" id="id428"/>Except in the simplest of cases, you cannot assume that any response from Copilot is entirely correct or the best answer. You should always carefully review Copilot responses. It’s not hard to find stories of AI results in other domains that made their way into official records with references that don’t exist. For example, there have been reports of court briefs that were filed referencing previous cases that didn’t happen. I know of people who have tried to use AI to plan vacation itineraries and received a promising agenda—only with hotels that didn’t exist.</p>

<p>Likewise, Copilot may return a response that is valid syntax but references constructs or variables that do not exist in the code. This is a coding form of AI <em>hallucination</em>: the AI presents information that is incorrect, made up, or otherwise not grounded in reality as a valid solution or suggestion. This is rare but can still occur. Sometimes this can be because Copilot needs to create suggestions around elements that don’t exist yet. For example, if you ask Copilot how to open and write to a file without specifying the name, it may use a filename that has no meaning in your code within its example.</p>

<p>Regardless of the circumstances, the user is always responsible for reviewing Copilot’s responses for accuracy. This should be no different from reviewing a human’s contributions to your code; you want to ensure they are correct and do no harm.</p>

<div data-type="note" epub:type="note">
<h1>Prompts and Accuracy</h1>

<p><a contenteditable="false" data-primary="prompts" data-secondary="accuracy and" data-type="indexterm" id="id429"/>The results from Copilot can often be improved by developing a better prompt for the AI. We’ll cover more about prompting throughout the book.</p>
</div>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Privacy"><div class="sect2" id="id10">
<h2>Privacy</h2>

<p><a contenteditable="false" data-primary="privacy" data-type="indexterm" id="xi_privacy12454"/>Another aspect of working with Copilot is data privacy. As previously noted, several information sources (including open files and current files) are read, and information is collected and transferred through Copilot to factor into the prompt for the LLM. That means some data is going across the web and being processed outside your control. This may seem like a potential security risk. However, Copilot includes options when signing up to specify whether or not you want to allow GitHub to include your context information as part of its data to help Copilot get better. (See the bottom part of <a data-type="xref" href="#options-at-signup-for">Figure 1-5</a>.) If you do not, while the information will be gathered, it will not be retained. It will be collected to construct the prompt and then discarded.</p>

<div data-type="tip">
<h1>Copilot Trust Center</h1>

<p><a contenteditable="false" data-primary="GitHub Trust Center" data-type="indexterm" id="id430"/><a contenteditable="false" data-primary="Trust Center (GitHub)" data-type="indexterm" id="id431"/>GitHub has a <a href="https://oreil.ly/0GM3-">Trust Center</a> to help with any privacy-related content issues or concerns.</p>
</div>

<figure><div id="options-at-signup-for" class="figure"><img alt="" src="assets/lghc_0105.png" width="844" height="272"/>
<h6><span class="label">Figure 1-5. </span>Options at sign-up for data privacy</h6>
</div></figure>

<p>Copilot intersects with user data in three areas: user engagement, prompts, and suggestions. Here’s a summary:</p>

<dl>
	<dt>User engagement</dt>
	<dd><a contenteditable="false" data-primary="user engagement" data-type="indexterm" id="id432"/>This is usage data about how you interact with Copilot (telemetry). It can include whether you accept or dismiss suggestions from Copilot, how you interact with the chat UI, and metrics such as latency and error messages.</dd>
	<dt>Prompts</dt>
	<dd><a contenteditable="false" data-primary="prompts" data-type="indexterm" id="id433"/>As previously discussed, the context information taken from your environment, or a chat query passed back to GitHub.</dd>
	<dt>Suggestions</dt>
	<dd><a contenteditable="false" data-primary="suggestions" data-type="indexterm" id="id434"/>The suggested code completions returned by Copilot and/or the responses to chat queries.</dd>
</dl>

<p>User engagement data is tracked by default and could include anonymized data, although there are nuances depending on the particular Copilot plan you’re using. (See the <a href="https://oreil.ly/rC8Rm">Trust Center</a> documentation for more information.) Mechanisms exist to encrypt data in transit and at rest. GitHub has controls to strictly limit who can access data on their side<a contenteditable="false" data-primary="" data-startref="xi_GitHubCopilotusageconsiderations11674" data-type="indexterm" id="id435"/><a contenteditable="false" data-primary="" data-startref="xi_privacy12454" data-type="indexterm" id="id436"/>.</p>

<div data-type="note" epub:type="note">
<h1>GitHub Repositories and Legal Concerns</h1>

<p><a contenteditable="false" data-primary="GitHub Codespaces" data-type="indexterm" id="xi_GitHubCodespacesrepositories12734"/><a contenteditable="false" data-primary="repositories" data-secondary="GitHub" data-type="indexterm" id="xi_repositoriesGitHub12734"/>The legality of using the <em>public</em> repositories on GitHub to train some LLMs has been questioned in public opinion and in courts. We will leave those considerations for others to sort out, and we won’t focus on, or comment on, those aspects of the initial training process in this book.</p>
</div>

<p>One other concern is often raised about Copilot when using a model trained on licensed repositories: Copilot could generate suggestions that closely match content from that codebase. The implication is that users could end up unwittingly violating licensing terms and intellectual property rights by having the duplicated code included in their work. Copilot includes an option for individuals and administrators to block public code matches if those are generated as part of the AI’s process. (See the top part of <a data-type="xref" href="#options-at-signup-for">Figure 1-5</a>.) If that option is selected, Copilot will alert you to the situation and filter out matches from the public code base.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id437">
<h1>Why Allow Matching Content?</h1>

<p><em>Matching content<a contenteditable="false" data-primary="matching content" data-type="indexterm" id="id438"/></em> refers to exact or near-exact matches between code in GitHub repositories and code suggested by Copilot. You may wonder what value there would be in having an option to allow matching content. In actuality, there may not be much. However, if you were generally researching how to do something and either did not intend to use it if there was a match, or use it under the terms of the license if it represented the best approach, that might be an acceptable use case.</p>
</div></aside>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Security"><div class="sect2" id="id11">
<h2>Security</h2>

<p><a contenteditable="false" data-primary="security" data-type="indexterm" id="xi_security12884"/>Last but certainly not least is the area of security in the results that Copilot returns. Security is an ever-present concern in any product or application used today. Addressing that concern starts with secure coding practices.</p>

<p>I stated earlier that once Copilot receives potential results from the LLM, GitHub performs some additional processing on them. This processing includes running algorithms to quickly look for possible vulnerabilities. GitHub does not run a security scanning application against the result, which would take too long. Instead, it quickly scans for patterns indicating vulnerabilities and/or insecure coding practices. If those are identified, the proposed suggestion is flagged.</p>

<p>Even with these measures, there is no guarantee that something hasn’t slipped through. Since the processing isn’t the same as running full scans with an application focused on finding vulnerabilities, the results from Copilot should still be subject to whatever other security checks you would use for any code.</p>

<p><em>The clear and ever-present requirement when using generative AI is that you must always review and assess any suggestions it returns. You should not assume that it completely and correctly interpreted the context. And, in all but the simplest of cases, you cannot assume that the result is perfect.</em></p>

<p>To state this another way, while Copilot is often referred to as an <em>AI pair programmer<a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="pair programmer" data-type="indexterm" id="id439"/></em>, it does not have the same understanding and level of familiarity with your code as an actual human pair programmer would. Instead, it is best to think of Copilot as a skilled programmer new to the project. A programmer in that position can create useful code based on what they can observe and what has been shared with them, but they can’t possess all of the larger context, project history, or backstory. As a result, you must be diligent in ensuring that the code they produce is accurate, secure, and suitable to merge. Copilot’s answers and suggestions should be treated the same way.</p>

<p class="fix_tracking">And, as when working with a new programmer on the team, the more details you provide (whether code to use as context or specific directions), the better the result will usually be. Giving Copilot more coding examples to draw on and more specifics in your prompt in the chat can go a long way towards getting a better result from the AI.</p>

<p>Another consideration may come up as you start to work with or consider using an assistant like Copilot: why not just use ChatGPT or a similar chatbot to produce code? The answer is that you certainly can. However, the two approaches and interfaces have key differences. The following section provides a quick comparison, using ChatGPT to represent other generalized AI applications that can create code<a contenteditable="false" data-primary="" data-startref="xi_GitHubCodespacesrepositories12734" data-type="indexterm" id="id440"/><a contenteditable="false" data-primary="" data-startref="xi_repositoriesGitHub12734" data-type="indexterm" id="id441"/><a contenteditable="false" data-primary="" data-startref="xi_security12884" data-type="indexterm" id="id442"/>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Copilot Versus ChatGPT"><div class="sect1" id="id12">
<h1>Copilot Versus ChatGPT</h1>

<p><a contenteditable="false" data-primary="GitHub Copilot" data-secondary="ChatGPT versus" data-type="indexterm" id="xi_GitHubCopilotChatGPTversus13074"/><a contenteditable="false" data-primary="ChatGPT" data-type="indexterm" id="xi_ChatGPTGitHubCopilotversus13074"/>You might wonder how Copilot or similar coding assistants differ from ChatGPT or similar chatbots, given both may use the same underlying models to produce responses. The general distinction is that Copilot is focused only on the coding domain and provides functionality to specifically help with that. ChatGPT, on the other hand, is targeted more broadly across any domain and doesn’t provide the same level of integration. <a data-type="xref" href="#comparison-of-copilot10">Table 1-1</a> highlights differences in several more specific categories.</p>

<table class="border" id="comparison-of-copilot10">
	<caption><span class="label">Table 1-1. </span>Comparison of Copilot to ChatGPT</caption>
	<thead>
		<tr>
			<th scope="row">Category</th>
			<th scope="col">GitHub Copilot</th>
			<th scope="col">ChatGPT</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th scope="row">Primary function</th>
			<td>Understanding and generating code or code-related prompts</td>
			<td>Understanding and generating any natural language</td>
		</tr>
		<tr>
			<th scope="row">Primary user interface</th>
			<td>Code editors, chat</td>
			<td>Chat</td>
		</tr>
		<tr>
			<th scope="row">Developer</th>
			<td>GitHub with OpenAI</td>
			<td>OpenAI</td>
		</tr>
		<tr>
			<th scope="row">Primary use cases</th>
			<td>Writing and augmenting code and code documentation</td>
			<td>Conversational responses with text generation</td>
		</tr>
		<tr>
			<th scope="row">Pricing model</th>
			<td>Subscription based with usage tracking for premium models</td>
			<td>Usage based and subscription based</td>
		</tr>
		<tr>
			<th scope="row">Training data</th>
			<td>Code repos, documentation</td>
			<td>Diverse, broad text content</td>
		</tr>
		<tr>
			<th scope="row">Public APIs</th>
			<td>Limited to telemetry, monitoring, and license management</td>
			<td>Broad API surface for interaction</td>
		</tr>
	</tbody>
</table>

<p>In general, you can think of Copilot as a very domain-specific implementation of generative AI. This is as opposed to the broader (domain-less) implementation and function of ChatGPT and other general chat tools. ChatGPT can certainly be used for generating code, but it lacks the integration with development environments, coding focus, and GitHub support and features that Copilot has.</p>

<p>Although we’ve been discussing Copilot as a single application, it actually has five configurations. Let’s finish up this introductory chapter by helping explain the plans available for you to choose from<a contenteditable="false" data-primary="" data-startref="xi_GitHubCopilotChatGPTversus13074" data-type="indexterm" id="id443"/><a contenteditable="false" data-primary="" data-startref="xi_ChatGPTGitHubCopilotversus13074" data-type="indexterm" id="id444"/>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Copilot Plans"><div class="sect1" id="id13">
<h1>Copilot Plans</h1>

<p><a contenteditable="false" data-primary="GitHub Copilot" data-secondary="plans" data-type="indexterm" id="xi_GitHubCopilotplans13654"/>Copilot comes in five plans at the time of this writing: <em>Free<a contenteditable="false" data-primary="Free plan" data-type="indexterm" id="id445"/></em>, <em>Pro<a contenteditable="false" data-primary="Pro plan" data-type="indexterm" id="id446"/></em>, <em>Pro+<a contenteditable="false" data-primary="Pro+ plan" data-type="indexterm" id="id447"/></em>, <em>Business<a contenteditable="false" data-primary="Business plan" data-type="indexterm" id="id448"/></em>, and <em>Enterprise<a contenteditable="false" data-primary="Enterprise plan" data-type="indexterm" id="id449"/></em>. To understand the differences between them, you need to understand some common terms:</p>

<dl>
	<dt>Code completions</dt>
	<dd><a contenteditable="false" data-primary="code" data-secondary="completions" data-type="indexterm" id="id450"/>AI-suggested code for completing code being worked on in your IDE.</dd>
	<dt>Chat request</dt>
	<dd><a contenteditable="false" data-primary="chat request" data-type="indexterm" id="id451"/>A prompt, which can be a direction or a question, that you pass to Copilot through a chat interface.</dd>
	<dt>Agent mode</dt>
	<dd><a contenteditable="false" data-primary="Agent mode" data-type="indexterm" id="id452"/>An option in Copilot to have it act on a prompt by independently planning, executing, and iterating across files to suggest changes needed to accomplish a task.</dd>
	<dt>Agent mode request</dt>
	<dd><a contenteditable="false" data-primary="Agent mode" data-secondary="requests" data-type="indexterm" id="id453"/>A request made to Copilot to accomplish a task while it is in Agent mode.</dd>
	<dt>Model access</dt>
	<dd><a contenteditable="false" data-primary="models" data-secondary="accessing" data-type="indexterm" id="id454"/>The LLMs that Copilot is allowed to access from the set of all LLMs it works with; a list of models currently available is included in the <a data-type="link" href="https://oreil.ly/icFQK">Copilot <span class="keep-together">documentation</span></a>.</dd>
	<dt>Premium requests</dt>
	<dd><a contenteditable="false" data-primary="premium requests" data-type="indexterm" id="id455"/>Interactions that use advanced AI models with operations such as Copilot Chat, Agent mode, code review, or extensions. These consume more compute resources and are counted separately from standard code completions.</dd>
</dl>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id456">
<h1>Understanding Premium Requests</h1>

<p><a contenteditable="false" data-primary="premium requests" data-type="indexterm" id="id457"/>If you’re using an advanced model, some Copilot features require more processing power. Those are considered <em>premium requests</em>. Essentially any type of model interaction can be a premium request, depending on the plan and model.</p>

<p>If you’re on the free plan, each of your requests counts as a premium. If you are on a paid plan, requests using the default base model (GPT-4o as of this writing) do not count as premium. Requests using any of the other models do.</p>

<p>It is important to note that there is not always a one-to-one request-to-premium-request ratio. A single request made to some models can count as less than one premium request or more than one premium request, depending on the model. The current model multipliers<a contenteditable="false" data-primary="models" data-secondary="multipliers" data-type="indexterm" id="id458"/> can be found in the <a data-type="link" href="https://oreil.ly/ahzPJ">Copilot documentation</a>.</p>

<p>As an example, if you are on the Pro plan (at the time of this writing) and you do 20 chat interactions with the o1 model selected, you will have used 200 (20 × 10) of your 300 allocated premium requests for the month. (The number of premium requests per plan is shown in <a data-type="xref" href="#comparison-of-github">Table 1-2</a>.)</p>

<p>If you run out of premium requests and want more on a paid plan, you can purchase additional ones for $.04/premium request.</p>
</div></aside>

<p>With those terms in mind, <a data-type="xref" href="#comparison-of-github">Table 1-2</a> explains the available plans and the key differences between them<a contenteditable="false" data-primary="Free plan" data-type="indexterm" id="id459"/><a contenteditable="false" data-primary="Pro plan" data-type="indexterm" id="id460"/><a contenteditable="false" data-primary="Pro+ plan" data-type="indexterm" id="id461"/><a contenteditable="false" data-primary="Business plan" data-type="indexterm" id="id462"/><a contenteditable="false" data-primary="Enterprise plan" data-type="indexterm" id="id463"/>.</p>

<table class="border" id="comparison-of-github">
	<caption><span class="label">Table 1-2. </span>Comparison of GitHub Copilot plans</caption>
	<thead>
		<tr>
			<th scope="row"> </th>
			<th scope="col">Free</th>
			<th scope="col">Pro</th>
			<th scope="col">Pro+</th>
			<th scope="col">Business</th>
			<th scope="col">Enterprise</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th scope="row">Target users</th>
			<td>Individual developers looking to explore Copilot</td>
			<td>Individual developers who want unlimited access to Copilot but don’t need to use all models</td>
			<td>Individual developers who want maximum flexibility and access to all models</td>
			<td>Organizations or enterprises that need unlimited access to core Copilot functionality and business management features but not all models</td>
			<td>Organizations or enterprises that need unlimited access to core Copilot functionality and business management features with maximum flexibility and access to all models</td>
		</tr>
		<tr>
			<th scope="row">Coding completions, chat requests, and Agent mode requests</th>
			<td>
			<p>50 chat requests or Agent mode requests/month (counted as premium)</p>

			<p>2,000 code completion requests/month</p>
			</td>
			<td>
			<p>Unlimited</p>
			</td>
			<td>
			<p>Unlimited</p>
			</td>
			<td>
			<p>Unlimited</p>
			</td>
			<td>
			<p>Unlimited</p>
			</td>
		</tr>
		<tr>
			<th scope="row">Model access</th>
			<td>Access to a small subset of models</td>
			<td>Access to more models</td>
			<td>Access to all models</td>
			<td>Access to more models</td>
			<td>Access to all models</td>
		</tr>
		<tr>
			<th scope="row">Premium requests</th>
			<td>50 premium requests/month</td>
			<td>300 premium requests/month</td>
			<td>1,500 premium requests/month</td>
			<td>300 premium requests/month</td>
			<td>1,000 premium requests/month</td>
		</tr>
		<tr>
			<th scope="row">Additional features</th>
			<td>Limited code review for selections in VS Code</td>
			<td>
			<ul>
				<li>Code review</li>
				<li>Pull request summaries</li>
			</ul>
			</td>
			<td>
			<ul>
				<li>Code review</li>
				<li>Pull request summaries</li>
			</ul>
			</td>
			<td>
			<ul>
				<li>Code review</li>
				<li>Pull request summaries</li>
				<li>User management and metrics</li>
				<li>Data privacy</li>
				<li>IP indemnity</li>
			</ul>
			</td>
			<td>
			<ul>
				<li>Code review</li>
				<li>Pull request summaries</li>
				<li>User management and metrics</li>
				<li>Data privacy</li>
				<li>IP indemnity</li>
			</ul>
			</td>
		</tr>
		<tr>
			<th scope="row">Administration</th>
			<td>Individual</td>
			<td>Individual</td>
			<td>Individual</td>
			<td>Enterprise</td>
			<td>Enterprise</td>
		</tr>
		<tr>
			<th scope="row">Cost</th>
			<td>Free</td>
			<td>$10/month or $100/year (free trial available for 30 days)</td>
			<td>$39/month or $390/year</td>
			<td>$19/month/user</td>
			<td>$39/month/user</td>
		</tr>
	</tbody>
</table>

<div data-type="note" epub:type="note">
<h1>Latest Info</h1>

<p>The information in <a data-type="xref" href="#comparison-of-github">Table 1-2</a> is accurate as of the time of this writing. Consult <a href="https://oreil.ly/ptoVy"> the Copilot features page</a> for the latest information.</p>
</div>

<p>Of course, cost<a contenteditable="false" data-primary="cost" data-type="indexterm" id="id464"/> is a significant factor. If you are an individual user who only uses Copilot on a limited basis in your IDE and doesn’t need the extra features, the Free plan may make sense. If you’re an individual user who wants to use Copilot on a regular basis and can benefit from the additional features, the Pro or Pro+ plans can provide a good match.</p>

<p class="pagebreak-before">At a corporate or community level, if you need or want the extra ability to easily assign and manage licenses across multiple users, as well as additional administrative oversight, the Business subscription can provide that. And if, as a business or community, you you want to take full advantage of advanced features and have maximum access to models, then the Enterprise plan is your best option.</p>

<div data-type="note" epub:type="note">
<h1>Mixing Plans</h1>

<p>It is possible to mix plan types within an enterprise at the organization level. See the <a href="https://oreil.ly/BZ1p6">documentation</a>.</p>
</div>

<p>Regardless of the plan you choose, the steps are similar:</p>

<ul>
	<li>Sign up and register for license(s).</li>
	<li>Establish a payment process.</li>
	<li>Install Copilot via an extension or whatever process you use to add functionality in your IDE.</li>
</ul>

<p>At an organization level, once the plan is set up, organization admins can add users and manage licenses as shown in <a data-type="xref" href="#managing-a-copilot-or">Figure 1-6</a>.</p>

<figure><div id="managing-a-copilot-or" class="figure"><img alt="" src="assets/lghc_0106.png" width="1659" height="959"/>
<h6><span class="label">Figure 1-6. </span>Managing a Copilot Business plan</h6>
</div></figure>

<p>Once you gain access to a Copilot subscription, you can install it into whichever IDE you use. <a href="https://oreil.ly/kF4rn">The GitHub Copilot documentation</a><a contenteditable="false" data-primary="GitHub Copilot" data-secondary="documentation" data-type="indexterm" id="id465"/> provides links for installing the GitHub Copilot extension in your chosen IDE. As of this writing, the currently supported IDEs include the following<a contenteditable="false" data-primary="Azure Data Studio" data-type="indexterm" id="id466"/><a contenteditable="false" data-primary="Eclipse" data-type="indexterm" id="id467"/><a contenteditable="false" data-primary="JetBrains" data-type="indexterm" id="id468"/><a contenteditable="false" data-primary="Vim/Neovim" data-type="indexterm" id="id469"/><a contenteditable="false" data-primary="Visual Studio" data-type="indexterm" id="id470"/><a contenteditable="false" data-primary="VS Code (Visual Studio Code)" data-type="indexterm" id="id471"/><a contenteditable="false" data-primary="Xcode" data-type="indexterm" id="id472"/>:</p>

<ul class="two-col">
	<li>
	<p><a href="https://oreil.ly/uUNGn">Azure Data Studio</a></p>
	</li>
	<li>
	<p><a href="https://oreil.ly/Mqdq2">Eclipse</a></p>
	</li>
	<li>
	<p><a href="https://oreil.ly/dlYdh">JetBrains IDEs</a></p>
	</li>
	<li>
	<p><a href="https://oreil.ly/rA6oI">Vim/Neovim</a></p>
	</li>
	<li>
	<p><a href="https://oreil.ly/qYbh_">Visual Studio</a></p>
	</li>
	<li>
	<p><a href="https://oreil.ly/GYc9X">Visual Studio Code</a></p>
	</li>
	<li>
	<p><a href="https://oreil.ly/MGeCb">Xcode</a></p>
	</li>
</ul>

<div data-type="note" epub:type="note" class="less_space">
<h1>GitHub Copilot Language Server</h1>

<p>GitHub also provides the <a href="https://oreil.ly/008MF">Copilot Language Server SDK</a><a contenteditable="false" data-primary="Copilot Language Server SDK" data-type="indexterm" id="id473"/>. This SDK allows integrating Copilot with any editor or IDE that can use the Language Server Protocol<a contenteditable="false" data-primary="LSP (Language Server Protocol)" data-type="indexterm" id="id474"/> (LSP) standard. So expect to see more integrations being developed<a contenteditable="false" data-primary="" data-startref="xi_GitHubCopilotplans13654" data-type="indexterm" id="id475"/>.</p>
</div>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="id375">
<h1>Conclusion</h1>

<p>I hope you’re starting to have a better sense of what GitHub Copilot is all about and how it potentially can be used. I also hope you’re finding yourself intrigued to learn and understand more about it.</p>

<p>In this chapter, I’ve provided an overview of what Copilot is, how it works, some key considerations to keep in mind when using it, and how to understand the plans it provides. This paints a picture of how Copilot fits in with the current use and potential of AI to help you in a given domain. In this case, that domain is creating software, and more generally, coding.</p>

<p>There are a few key points to take away from this text. One is that AI can greatly simplify and support your efforts as a coder. A second is that context is king when it comes to helping Copilot provide you with the best results. And a third, and arguably the most important one, is that you still have the ultimate responsibility to review and assess any suggestions and answers from the AI. Copilot is great at what it does, but it is only as good as the context we give it and the capabilities and training data of the model it is using. And as with human coders, those variables factor in to how complete, relevant, and accurate (or not) any result is.</p>

<p>There are a number of standard ways of leveraging Copilot to complete code. In the next chapter, you’ll look at how to use and work with Copilot code completions in the IDE interfaces where you are coding. Understanding those will help get you to the next level of using the tool, completing the foundation you need for the rest of <span class="keep-together">the book</span>, and getting the most out of Copilot.</p>
</div></section>
</div></section></div></div></body></html>