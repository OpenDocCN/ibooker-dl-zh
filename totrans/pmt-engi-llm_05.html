<html><head></head><body><div id="book-content" class="calibre2"><div id="sbo-rt-content" class="calibre3"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Designing LLM Applications" class="calibre6"><div class="preface" id="ch04_designing_llm_applications_1728407230643376">
<h1 class="calibre5"><span class="firstname">Chapter 4. </span>Designing LLM Applications</h1>

<p class="subtitle">The previous two chapters laid the foundations for the remainder of the book. <a data-type="xref" href="ch02.html#ch02_understanding_llms_1728407258904677" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Chapter 2</a> showed in detail how LLMs function, and we demonstrated that at the end of the day, they are effectively document completion models that predict content one token at a time. <a data-type="xref" href="ch03.html#ch03a_moving_toward_chat_1728432131625250" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Chapter 3</a> explained how the chat API is built upon the LLMs of <a data-type="xref" href="ch02.html#ch02_understanding_llms_1728407258904677" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Chapter 2</a>. With some syntactic sugar at the API level and a healthy dose of fine-tuning, the document completion model is used to complete conversations between the user and an imagined assistant. When you get down to it, the chat model is really still a document completion model—it’s just that the documents it completes are all conversation transcripts.</p>

<p class="subtitle">From this point forward in the book, you’ll learn everything you need to know about how to build LLM applications to solve problems on behalf of your company and your users. This chapter serves as a gateway to that content. In this chapter, we’ll dive into the<a contenteditable="false" data-primary="application design" data-secondary="role of LLM applications" data-type="indexterm" id="id473" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> LLM <em class="hyperlink">application</em>, which you’ll see is actually a transformation layer between the user’s problem domain and the model’s text domain. Furthermore, the LLM application is a transformation layer with a purpose—solving problems!</p>

<section data-type="sect1" data-pdf-bookmark="The Anatomy of the Loop" class="calibre6"><div class="preface" id="ch04_the_anatomy_of_the_loop_1728407230643696">
<h1 class="calibre5">The Anatomy of the Loop</h1>

<p class="subtitle">In <a data-type="xref" href="#ch04_figure_1_1728407230608910" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 4-1</a>, the LLM application<a contenteditable="false" data-primary="application design" data-secondary="“loop” of interaction" data-secondary-sortas="loop&quot; of interaction" data-type="indexterm" id="ADloop04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="LLM-application loops" data-type="indexterm" id="loops04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="“loop” of interaction" data-primary-sortas="loop&quot; of interaction" data-type="indexterm" id="loopof04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="the “loop” of interaction" data-type="indexterm" id="theloop04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> is represented as a <em class="hyperlink">loop</em>, meaning an interaction back and forth between the user and the model. The domains of the model and the user are often quite different. The user may be doing any number of things, such as writing an email and looking for just the right wording to communicate their point. Or they may be doing something complicated, such as organizing group travel, booking travel tickets, and procuring lodging. Perhaps the user isn’t directly in contact with the LLM application; for instance, they could have set up a recurring analysis that the LLM application performs periodically as new data becomes available. The point is that the user can be doing a great variety of things.</p>

<p class="subtitle">The model, on the other hand, does only one thing—it completes documents. But this capability affords you a great deal of flexibility when building the LLM application. The ability to complete documents gives the model the ability to write emails, code, stories, documentation, and (in principle) anything else that a human might write. As we showed in the previous chapter, a chat app is an LLM application that completes<a contenteditable="false" data-primary="transcript documents" data-type="indexterm" id="id474" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">transcript</em> documents, and tool execution is simply going one step farther and completing a specialized transcript document that includes a function calling syntax. With their ability to complete text, engage in chat, and execute tools, LLMs can be applied to an almost unlimited number of use cases.</p>

<figure class="calibre22"><div id="ch04_figure_1_1728407230608910" class="figure"><img src="assets/pefl_0401.png" class="calibre23"/>
<h6 class="calibre24"><span class="firstname">Figure 4-1. </span>LLM-based applications implement the loop, which conveys information from the user domain to the LLM’s text domain and then back</h6>
</div></figure>

<p class="subtitle">The loop implements the transformation between the user domain and the model domain. It takes the user’s problem and converts it into the document or transcript that the model must complete. Once the model has responded, the loop transforms the model output back into the user domain in the form of a solution to the user’s problem (or at least a step in the right direction).</p>

<p class="subtitle">The LLM application may involve just one iteration of the loop. For instance, if the user is writing an email and wants to convert a bulleted list of points into prose, then you need only one iteration through this loop—once the model returns the prose, the job of the application is complete. The user can run the application again if they want, but in each case, the loop retains no state from the previous run.</p>

<p class="subtitle">Alternatively, the LLM application may run the loop several times in a row, as is the case for a chat assistant. Or, the LLM application may run iteratively, refer to a vast amount of state, and modify the loop as the problem changes shape. A travel planning app is a good example of this. Initially, the application would help brainstorm travel ideas; then, it would move on to making the actual travel arrangements; and finally, it would set up reminders and travel tips.</p>

<p class="subtitle">In the following sections, we’ll take you for one trip around the loop of <a data-type="xref" href="#ch04_figure_1_1728407230608910" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 4-1</a>. We will discuss the user’s problem domain, convert that problem to the model domain, collect the completion, and convert it back into a solution for the user.<a contenteditable="false" data-primary="" data-startref="loops04" data-type="indexterm" id="id475" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="ADloop04" data-type="indexterm" id="id476" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="loopof04" data-type="indexterm" id="id477" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-startref="theloop04" data-type="indexterm" id="id478" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/></p>

<section data-type="sect2" data-pdf-bookmark="The User’s Problem" class="calibre6"><div class="preface" id="ch04_the_user_s_problem_1728407230643824">
<h2 class="calibre19">The User’s Problem</h2>

<p class="subtitle">The<a contenteditable="false" data-primary="application design" data-secondary="user's problem domain" data-type="indexterm" id="id479" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="user's problem domain" data-type="indexterm" id="id480" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> loop starts with the user and the problem they are trying to solve. <a data-type="xref" href="#ch04_table_1_1728407230620664" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Table 4-1</a> illustrates how the user’s problem domain can vary among several dimensions and can range from simple to complex. These dimensions include the following:</p>

<ul class="stafflist">
	<li class="calibre9">
	<p class="calibre26">The medium in which the problem is conveyed (with text being the most natural for LLMs)</p>
	</li>
	<li class="calibre9">
	<p class="calibre26">The level of abstraction (with higher abstraction requiring more complex <span class="firstname">reasoning</span>)</p>
	</li>
	<li class="calibre9">
	<p class="calibre26">The context information required (with most domains requiring retrieval of additional information besides what is supplied by the user)</p>
	</li>
	<li class="calibre9">
	<p class="calibre26">How stateful the problem is (with more complex problem domains requiring memory of past interactions and user preferences)</p>
	</li>
</ul>

<p class="subtitle">As you can see in <a data-type="xref" href="#ch04_table_1_1728407230620664" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Table 4-1</a>, user problem domains have various levels of complexity in several dimensions. For example, a proofreading application would be<a contenteditable="false" data-primary="dimensions of complexity" data-type="indexterm" id="id481" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="complexity, dimensions of" data-type="indexterm" id="id482" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> low complexity in all dimensions, while a travel planning assistant would be quite complex. When you’re building an LLM application, you’ll deal with all these forms of complexity in different ways. We’ll give you a glimpse into these approaches in this chapter and then greater detail on them throughout the rest of this book.</p>

<table id="ch04_table_1_1728407230620664" class="calibre27">
	<caption class="calibre28"><span class="firstname">Table 4-1. </span>Three problem domains (in the columns) in four dimensions of complexity (in the rows)</caption>
	<thead class="calibre29">
		<tr class="calibre30">
			<th class="calibre31"> </th>
			<th class="calibre31" colspan="3"><em class="hyperlink">Increasing complexity ➜</em></th>
		</tr>
		<tr class="calibre50">
			<th class="calibre31"> </th>
			<th class="calibre31">Proofreading</th>
			<th class="calibre31">IT support assistance</th>
			<th class="calibre31">Travel planning</th>
		</tr>
	</thead>
	<tbody class="calibre32">
		<tr class="calibre30">
			<td class="calibre33"><strong class="calibre51"><em class="calibre52">Medium of the problem</em></strong></td>
			<td class="calibre33">Text</td>
			<td class="calibre33">Voice over the phone</td>
			<td class="calibre33">Complex interactions on the website, text input from the user, and interactions with APIs.</td>
		</tr>
		<tr class="calibre34">
			<td class="calibre33"><strong class="calibre51"><em class="calibre52">Level of abstraction</em></strong></td>
			<td class="calibre33">The problem is concrete, well-defined, and small.</td>
			<td class="calibre33">A large abstract problem space and a large solution space, but constrained by available documentation</td>
			<td class="calibre33">The problem involves understanding the user’s subjective tastes and objective constraints in order to coordinate a complex solution.</td>
		</tr>
		<tr class="calibre30">
			<td class="calibre33"><strong class="calibre51"><em class="calibre52">Context required</em></strong></td>
			<td class="calibre33">Nothing more than the text submitted by the user.</td>
			<td class="calibre33">Searchable access to technical documentation and example support transcripts</td>
			<td class="calibre33">Access to calendars, airlines APIs, recent news articles, government travel recommendations, Wikipedia, etc.</td>
		</tr>
		<tr class="calibre34">
			<td class="calibre33"><strong class="calibre51"><em class="calibre52">Statefulness</em></strong></td>
			<td class="calibre33">No statefulness—every call to the API contains a distinct problem statement.</td>
			<td class="calibre33">Must track the conversation history and solutions attempted</td>
			<td class="calibre33">Must track interaction across weeks of planning, different mediums of interaction, and aborted branches of planning.</td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Converting the User’s Problem to the Model Domain" class="calibre6"><div class="preface" id="ch04_converting_the_user_s_problem_to_the_model_domain_1728407230643923">
<h2 class="calibre19">Converting the User’s Problem to the Model Domain</h2>

<p class="subtitle">The<a contenteditable="false" data-primary="application design" data-secondary="converting user's problem to model domain" data-type="indexterm" id="ADmodel04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="model domain" data-type="indexterm" id="model04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> next stop on the loop from <a data-type="xref" href="#ch04_figure_1_1728407230608910" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 4-1</a> is inside the application, where the user’s problem is converted into the domain of the model. The crux of prompt engineering lies in this step. The goal is to create a prompt so that its completion contains information that can be used to address the user’s problem. Crafting just the right prompt is quite a tall order, and the application must satisfy the following<a contenteditable="false" data-primary="prompt engineering" data-secondary="goals for successful" data-type="indexterm" id="PEgoals04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> criteria simultaneously:</p>

<ol class="stafflist">
	<li class="calibre25">
	<p class="calibre26">The prompt must closely resemble content from the training set.</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">The prompt must include all the information relevant to addressing the user’s problem.</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">The prompt must lead the model to generate a completion that addresses the problem.</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">The completion must have a reasonable end point so that generation comes to a natural stop.</p>
	</li>
</ol>

<p class="subtitle">Let’s dig into each of these criteria. First and foremost, the prompt must closely resemble documents from the training set. We call this the<a contenteditable="false" data-primary="Red Riding Hood principle" data-type="indexterm" id="id483" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="Little Red Riding Hood principle" data-type="indexterm" id="id484" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">Little Red Riding Hood principle</em>. You remember that story, right? A naive girl dressed in fashionable red attire walks along a forest path to visit her ailing grandmother. Despite her mother’s stern warnings, the girl strays from the path and has an encounter with a wolf (big and bad), and then the story really goes south—much gore...<em class="hyperlink">much gore</em>. It’s really crazy that we tell this story to children.</p>

<p class="subtitle">But for our purposes, the point is simple: don’t stray far from the path upon which the model was trained. The more realistic and familiar you make the prompt document and the more similar it is to documents from the training set, the more likely it is that the completion will be predictable and stable. The Little Red Riding Hood principle is one that we will revisit several times in this book. For now, suffice to say that you should always mimic common patterns found in training data.</p>

<div data-type="tip" class="calibre16"><h6 class="calibre17">Tip</h6>
<p class="subtitle">Most <a contenteditable="false" data-primary="OpenAI GPT APIs" data-secondary="details of training" data-type="indexterm" id="id485" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="training" data-type="indexterm" id="id486" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="pre-training process" data-type="indexterm" id="id487" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/>of the best LLMs are tight-lipped about their training data, and for good reason. If you know exactly how their training documents are formatted, then you have a leg up on manipulating the prompt and, say, finding a new<a contenteditable="false" data-primary="jailbreaking" data-type="indexterm" id="id488" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> jailbreaking strategy. However, if you want to see what kinds of documents the models are familiar with, then the easiest thing to do is—<em class="hyperlink">just ask</em>. As an example, try this request: <code class="calibre15"><strong class="calibre53">"What types of formal documents are useful for specifying financial information about a company?"</strong></code> You should see a large selection of documents to pattern your request after. Next, ask the model to generate an example document and see if it’s what you need.</p>
</div>

<p class="subtitle">Fortunately, there are endless types of documents and motifs to draw from. For completion models, see if you can make the prompt resemble computer programs, news articles, tweets, markdown documents, communication transcripts, etc. For chat models, the overall document is decided for you—for OpenAI, this is a ChatML document that starts with an instructive system message followed by back-and-forth exchanges between the user and the assistant character. But you can still use the Little Red Riding Hood principle by including common motifs within the user messages. For instance, make use of markdown syntax to help the model understand the structure of the content. Use a<a contenteditable="false" data-primary="hash sign (#)" data-type="indexterm" id="id489" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="# (hash sign)" data-type="indexterm" id="id490" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> hash sign (<code class="calibre15">#)</code> to delimit sections, backticks (<code class="calibre15">```)</code> to<a contenteditable="false" data-primary="backticks (```)" data-type="indexterm" id="id491" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="``` (backticks)" data-type="indexterm" id="id492" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="triple backticks (```)" data-type="indexterm" id="id493" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> delimit code, an<a contenteditable="false" data-primary="asterisk (*)" data-type="indexterm" id="id494" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="* (asterisk)" data-type="indexterm" id="id495" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> asterisk (<code class="calibre15">*)</code> to indicate items in a list, etc.</p>

<p class="subtitle">Now, let’s look at the second criterion: the prompt must include all the information relevant to addressing the user’s problem. As you convert the user’s problem into the model’s domain, you must collect all of the information relevant to solving the user’s problem and incorporate it into the prompt. Sometimes, the user directly supplies you with all of the information that you need—in the proofreading example, the user’s raw text is sufficient. But at the other extreme, the travel planning application requires that you pull in user preferences, information from user calendars, airline ticket availability, recent news about the destination, government travel recommendations, etc.</p>

<p class="subtitle">Finding all the <em class="hyperlink">possible</em> content is one challenge, and finding the <em class="hyperlink">best</em> content is the next challenge. If you saturate the prompt with too much loosely relevant content, then the language model will get distracted and generate irrelevant completions. Finally, the content must be arranged in a well-formatted, logical document so that it makes sense—lest you stray off the path on the way to Grandmother’s house.</p>

<p class="subtitle">The third criterion to consider is that the prompt must condition the model to generate a completion that is actually helpful. If the LLM continues after the prompt by merely jabbering on about the user’s problem, then you’re not helping them at all. You must therefore carefully consider how to set up the prompt so that it points to a solution. When working with completion models, this can be surprisingly tricky. You will need to let the model know that it’s time to create the solution (see the homework example that follows). For chat models, this is much easier because the model has been fine-tuned to automatically produce a helpful message from the assistant that addresses the user problem. Thus, you don’t need any trickery to pull an answer out of the model.</p>

<p class="subtitle">Finally, you must ensure that the model actually stops! Here again, the situation is different for completion versus chat models. With chat, everything is easy—the model is fine-tuned to come to a stop after the helpful assistant message (though you might need to instruct the assistant to limit how chatty it is). With completion models, you have to be more careful. One option is to create an expectation in the instructional text that the solution should <em class="hyperlink">not</em> go on forever; it should reach a solution and stop. An alternative is to create the expectation that some specific thing will follow and that it will begin with very specific and easily identifiable opening text. If such a pattern exists, then we can use the<a contenteditable="false" data-primary="stop parameter" data-type="indexterm" id="id496" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <code class="calibre15">stop</code> parameter to halt generation at the moment the opening text is produced. Both of these patterns are seen in the example covered next.</p>

<aside data-type="sidebar" epub:type="sidebar" class="calibre35"><div class="sidebar" id="ch04_so_a_funny_thing_happened_1728407230644115">
<h1 class="calibre36">So a Funny Thing Happened...</h1>

<p class="subtitle">At GitHub, in the early days of the chat models, we made a funny mistake. The models are fine-tuned to end assistant messages with the special <code class="calibre15">&lt;|im_end|&gt;</code> token and then halt generation. This is great—it means you don’t have to do anything special to ensure that the model will stop. But we had configured this particular model incorrectly, causing it to suppress the <code class="calibre15">&lt;|im_end|&gt;</code> token. Amusingly, we ended up with a model that literally didn’t know how to shut up. It would begin with a very intelligible answer from the assistant, and then, it would end with a salutation, “Hope you have a nice day!” But then, since it <em class="hyperlink">literally</em> couldn’t stop, it had to think of something to say next. So it continued, “Hope you have a wonderful day!” and “Hope you have a festive day!” and so on, and so on, until it had found all the synonyms available for <em class="hyperlink">wonderful</em> and was finally forced to stop at the token limit.</p>
</div></aside>

<section data-type="sect3" data-pdf-bookmark="Example: Converting the user’s problem into a homework problem" class="calibre6"><div class="preface" id="ch04_example_converting_the_user_s_problem_into_a_home_1728407230644292">
<h3 class="calibre45">Example: Converting the user’s problem into a homework problem</h3>

<p class="subtitle">Let’s dig into an example to demonstrate the preceding concepts. <a data-type="xref" href="#ch04_table_2_1728407230620704" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Table 4-2</a> shows an example prompt for an application that makes travel recommendations based on a user’s requested location. The plain text is part of the boilerplate used to structure the prompt and condition it to provide a solution, and the italicized text is the information specific to the user’s current request. This example uses a completion API because it makes it easier to see each of the preceding criteria in action. (Note that building an actual travel app would be very complicated indeed! We chose this very simplified example because it demonstrates the ideas discussed previously. We talk about more realistic applications in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#ch08_01_conversational_agency_1728429579285372" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#ch09_llm_workflows_1728407155661595" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">9</a>.)</p>

<table id="ch04_table_2_1728407230620704" class="calibre27">
	<caption class="calibre28"><span class="firstname">Table 4-2. </span>An example prompt for a travel recommendation application</caption>
	<tbody class="calibre32">
		<tr class="calibre30">
			<td class="calibre33">Prompt</td>
			<td class="calibre33">
			<pre data-type="programlisting" class="calibre49">
# Leisure, Travel, and Tourism Studies 101 - Homework Assignment

Provide answers for the following three problems. Each answer should 
be concise, no more than a sentence or two.

## Problem 1
What are the top three golf destinations to recommend to customers? 
Provide the answer as a short sentence.

## Solution 1
St. Andrews, Scotland; Pebble Beach, California; and Augusta, Georgia, 
USA (Augusta National Golf Club) are great destinations for golfing.

## Problem 2
Let's say a customer approaches you to help them with <em class="calibre54">travel plans 
for Pyongyang, North Korea.</em>

You check the State Department recommendations, and they advise 
<em class="calibre54">"Do not travel to North Korea due to the continuing serious risk 
of arrest and long-term detention of US nationals. Exercise increased 
caution in travel to North Korea due to the critical threat of wrongful
detention."</em>
    
You check the recent news and see these headlines:
  - <em class="calibre54">"North Korea fires ballistic missile, Japan says"</em>
  - <em class="calibre54">"Five-day COVID-19 lockdown imposed in Pyongyang"</em>
  - <em class="calibre54">"Yoon renews efforts to address dire North Korean human rights"</em>
  
Please provide the customer with a short recommendation for travel to 
their desired destination. What would you tell the customer?

## Solution 2</pre>
			</td>
		</tr>
		<tr class="calibre34">
			<td class="calibre33">Completion</td>
			<td class="calibre33">
			<pre data-type="programlisting" class="calibre49">
Perhaps North Korea isn't a great destination right now. 
But I bet we could find some nice place to visit in South Korea.</pre>
			</td>
		</tr>
	</tbody>
</table>

<p class="subtitle">First, notice how the prompt obeys the<a contenteditable="false" data-primary="Little Red Riding Hood principle" data-type="indexterm" id="id497" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="Red Riding Hood principle" data-type="indexterm" id="id498" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> Little Red Riding Hood principle—this is a homework problem, a type of document that you are likely to find regularly in training data. Moreover, the document is formatted in Markdown, a common markup language. This will encourage the model to format the document in a predictable way, with section headings and syntax indicating bold or italicized words. At the most basic level, the document uses proper grammar. This is important, as sloppy grammar will encourage the model to generate text in a similar, sloppy style. Clearly, we are solidly on the path to Grandmother’s house.</p>

<p class="subtitle">Next, take a look at how the prompt incorporates the context that the LLM will need to understand the problem; this context appears in italics in <a data-type="xref" href="#ch04_table_2_1728407230620704" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Table 4-2</a>. First is the actual user problem. Probably, the user has just selected North Korea from a drop-down menu on the travel website; they may have even selected it by mistake. Nevertheless, it is added to the prompt as the first bold text snippet. The subsequent scraps of bold text are pulled from other relevant resources: State Department travel recommendations and recent news article headings. For our example, this is enough information to make a travel recommendation.</p>

<p class="subtitle">There are several ways in which this prompt leads the model toward a definite solution, rather than toward further elaboration of the problem. In the first line, we condition the model toward the type of response we hope to see—something within the domain of leisure, travel, and tourism. Next, we include an example problem. This has nothing to do with the user’s current request, but it establishes a pattern for the model: the problem will begin with <code class="calibre15">## Problem N </code>and will be followed by a solution starting with <code class="calibre15">## Solution N</code>.</p>

<p class="subtitle">Problem 1 also encourages the use of a certain voice for the subsequent answers—concise and polite. The fact that solution 1 is a short sentence further encourages the continuation of this pattern in the<a contenteditable="false" data-primary="completions" data-secondary="patterns in" data-type="indexterm" id="id499" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> completion. With this pattern in place, problem 2 is the actual user problem. We set up the problem, insert the context, and make the ask: <code class="calibre15">What would you tell the customer?</code> With the text <code class="calibre15">## Solution 2</code>, we then indicate that the problem statement is over and it’s time for the answer. If we had omitted this, then the model would likely have continued elaborating upon the problem by confabulating more information about North Korea.</p>

<p class="subtitle">The last task is to insist upon a firm stop. Since every new section of markdown begins with ##, we have a pattern that we can capitalize upon. If the model begins to confabulate a third problem, then we can cut off the model completion by specifying stop text, which tells the model to halt generation as soon as this text is produced. In this case, a reasonable choice for stop text is <code class="calibre15">\n#</code>, which indicates that the model has completed the current solution and is beginning a new section, possibly the start of a confabulated problem 3.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Chat models versus completion models" class="calibre6"><div class="preface" id="ch04_chat_models_versus_completion_models_1728407230644376">
<h3 class="calibre45">Chat models versus completion models</h3>

<p class="subtitle">In<a contenteditable="false" data-primary="completion models" data-secondary="versus chat models" data-secondary-sortas="chat models" data-type="indexterm" id="id500" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="chat models" data-secondary="versus completion models" data-secondary-sortas="completion models" data-type="indexterm" id="id501" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> the preceding example, we’ve relied on a completion model to demonstrate the criteria for converting between the user domain and the model domain. With the introduction of chat models, much of this is simplified. The chat APIs ensure that the input into the models will closely resemble the fine-tuning data because the messages will be internally formed into a transcript document (criterion 1 from the beginning of this section). The model is highly conditioned to provide a response that addresses the user’s problem (criterion 3), and the model will always stop at a reasonable <span class="firstname">point—</span>at the end of the assistant’s message (criterion 4).</p>

<p class="subtitle">But this doesn’t mean that you, as the prompt engineer, are off the hook! You’re fully responsible for including all the relevant information for addressing the user’s problem (criterion 2). You must craft the text within the chat so that it resembles characteristics of documents in training (criterion 1). Most importantly, you must shape the transcript, system message, and function definitions so that the model can successfully address the problem and come to a stopping point (criteria 3 and 4).</p>

<aside data-type="sidebar" epub:type="sidebar" class="calibre35"><div class="sidebar" id="ch04_now_you_try_1728407230644450">
<h1 class="calibre36">Now, You Try!</h1>

<p class="subtitle">Using a completion model such as gpt-3.5-turbo-instruct, start with the preceding prompt and see what happens as you modify pieces of the prompt in these ways:</p>

<ol class="stafflist">
	<li class="calibre25">
	<p class="calibre26">What if you leave off <code class="calibre15">## Solution 2</code> or even the question that precedes it? Does the model continue to elaborate on the problem statement? Even if the model completes the problem statement, why is it still important to keep the question and the solution heading?</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">Problem 1 serves as an example. If you change the solution 1 text, does it modify the text generated for solution 2? Try increasing or decreasing solution 1’s length significantly. Try making it talk like a pirate. Try making it rude. How do those modifications affect solution 2?</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">Try keeping the same country but replacing the negative context with increasingly positive remarks. Does the model still recommend against travel to North Korea? Why might this be?</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">If you omit the stop word, then does the model confabulate a third problem? If not, then what if you add one more new line character? Can you introduce one character to make it confabulate a fourth problem?</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">Are there any reasons that using a homework problem might be problematic? Try a different format, such as a transcript of a travel agency help hotline.<a contenteditable="false" data-primary="" data-startref="ADmodel04" data-type="indexterm" id="id502" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="model04" data-type="indexterm" id="id503" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="PEgoals04" data-type="indexterm" id="id504" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/></p>
	</li>
</ol>
</div></aside>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Using the LLM to Complete the Prompt" class="calibre6"><div class="preface" id="ch04_using_the_llm_to_complete_the_prompt_1728407230644525">
<h2 class="calibre19">Using the LLM to Complete the Prompt</h2>

<p class="subtitle">Referring back<a contenteditable="false" data-primary="application design" data-secondary="using LLMs to complete prompts" data-type="indexterm" id="id505" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> to <a data-type="xref" href="#ch04_figure_1_1728407230608910" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 4-1</a>, in the next stage of the LLM-application loop, you submit the prompt to the model and retrieve the completion. If you’ve played with only one particular model, such as ChatGPT, you might be under the impression that there are no decisions to make here—just send the model a prompt and wait for the completion, just as we showed in the example. However, all models are <em class="hyperlink">not</em> alike!</p>

<p class="subtitle">You’ll<a contenteditable="false" data-primary="application design" data-secondary="determining model size" data-type="indexterm" id="id506" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="model selection" data-secondary="model size" data-type="indexterm" id="id507" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> have to decide how big your model should be. Typically, the larger the model is, the higher quality its completions will be. But there are some very important trade-offs, such as cost. At the time of writing this book, running GPT-4 can be <em class="hyperlink">20 times</em> more expensive than running gpt-3.5-turbo. Is the quality improvement worth the order-of-magnitude increase in price? Sometimes, it is!</p>

<p class="subtitle">Also<a contenteditable="false" data-primary="application design" data-secondary="latency" data-type="indexterm" id="id508" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="latency" data-secondary="model size and" data-type="indexterm" id="id509" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> of importance is the latency. Bigger models require more computation, and more computation might require more time than your users can spare. In the early days of GitHub Copilot, we decided to use an OpenAI model called Codex, which is small, <em class="hyperlink">sufficiently </em>smart, and lightning fast. If we had used GPT-4, then users would have rarely been inclined to wait for the completion, no matter how good it was.</p>

<p class="subtitle">Finally, you should consider whether or not you can gain better performance through<a contenteditable="false" data-primary="application design" data-secondary="fine-tuning" data-type="indexterm" id="id510" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> fine-tuning. At GitHub, we’re experimenting with fine-tuning Codex models to provide higher quality results for less common languages. In general, fine-tuning can be useful when you want the model to provide information that is unavailable in the public datasets that the model was originally trained on, or when you want the model to exhibit behavior that is different from the behavior of the original model. The process of fine-tuning is beyond the scope of this book, but we’re confident that fine-tuning models will become simpler and more commonplace, so it’s definitely a tool you should have in your belt.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Transforming Back to User Domain" class="calibre6"><div class="preface" id="ch04_transforming_back_to_user_domain_1728407230644630">
<h2 class="calibre19">Transforming Back to User Domain</h2>

<p class="subtitle">Let’s<a contenteditable="false" data-primary="application design" data-secondary="transforming back to user domain" data-type="indexterm" id="id511" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> dig into the final phase of the loop from <a data-type="xref" href="#ch04_figure_1_1728407230608910" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 4-1</a>. The LLM completion is a blob of text. If you’re making a simple chat app of some sort, then maybe you’re done—just send the text back to the client and present it directly to the user. But more often, you will need to transform the text or harvest information from it to make it useful to the end user.</p>

<p class="subtitle">With the original completion models, this often meant asking the model to present specific data with a very specific format and then to parse that information out and present it back to the user. For instance, you might have asked the model to read a document and then generate tabular information that would have been extracted and represented back to the user.</p>

<p class="subtitle">However, since the appearance of<a contenteditable="false" data-primary="function-calling models" data-type="indexterm" id="id512" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> function-calling models, converting model output into information that’s useful to the user has become quite a bit easier. For these models, the prompt engineer lays out the user’s problem, gives the model a list of functions, and then asks the model to generate text. The generated text then represents a function call.</p>

<p class="subtitle">For instance, in a travel app, you might provide the model with functions that can look up airline flights and a description of a user’s travel goals. The model might then generate a function call requesting tickets for a particular date with the user’s requested origin and destination. An LLM application can use this to call the actual airline’s API, retrieve available flights, and present them to the user—back in the user’s domain.</p>

<p class="subtitle">You can go further by giving the model functions that actually create a change in the real world. For instance, you can provide the model with functions that actually purchase tickets. When the model generates a function call to purchase tickets, the application can double-check with the user that this is OK and then complete the transaction. Thus, you have translated from the model domain—text representing a function call—to the user domain in the form of an actual purchase on the user’s behalf. We will go into more detail about this in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#ch08_01_conversational_agency_1728429579285372" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#ch09_llm_workflows_1728407155661595" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">9</a>.</p>

<p class="subtitle">Finally, when transforming back to the user domain, you may change the medium of communication entirely. The model generates in text, but if the user is speaking to an automated tech support system over their phone, then the model completions will need to be converted into speech. If the user is using an application with a complicated UI, then the model completions might represent events that modify elements of the UI.</p>

<p class="subtitle">And even if the user’s domain is text, it might still be necessary to modify the presentation of the model completions. For instance, Copilot code completion is represented as a grayed-out code snippet in the IDE, which the user can accept by pressing Tab. But when you use Copilot chat to ask for a code change, the results are presented as a red/green text diff.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Zooming In to the Feedforward Pass" class="calibre6"><div class="preface" id="ch04_zooming_in_to_the_feedforward_pass_1728407230644716">
<h1 class="calibre5">Zooming In to the Feedforward Pass</h1>

<p class="subtitle">Let’s spend some more time examining the<a contenteditable="false" data-primary="LLM-application loops" data-type="indexterm" id="llmapploops04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="application design" data-secondary="“loop” of interaction" data-secondary-sortas="loop&quot; of interaction" data-type="indexterm" id="ADloops04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="“loop” of interaction" data-primary-sortas="loop&quot; of interaction" data-type="indexterm" id="loopofinter04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="the “loop” of interaction" data-type="indexterm" id="theloopofint04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> LLM-application loop from <a data-type="xref" href="#ch04_figure_1_1728407230608910" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 4-1</a>—specifically, the<a contenteditable="false" data-primary="application design" data-secondary="feedforward pass" data-type="indexterm" id="ADfeed04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="feedforward pass" data-type="indexterm" id="feed04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">feedforward pass</em>, which is the part of the loop where you convert the user problem into the domain of the model. Almost all of the remaining chapters in this book will go into great detail about just <em class="hyperlink">how</em> we achieve high-quality completions. But before we get into the nitty-gritty, let’s lay down some foundational ideas that we’ll build on in coming chapters.</p>

<section data-type="sect2" data-pdf-bookmark="Building the Basic Feedforward Pass" class="calibre6"><div class="preface" id="ch04_building_the_basic_feedforward_pass_1728407230644803">
<h2 class="calibre19">Building the Basic Feedforward Pass</h2>

<p class="subtitle">The feedforward pass is composed of several basic steps that allow you to translate the user’s problem into the text domain (see <a data-type="xref" href="#fig-4-2" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 4-2</a>). The middle chapters of this book will cover these steps in detail.</p>

<figure class="calibre22"><div id="fig-4-2" class="figure"><img alt="A diagram of a application process  Description automatically generated" src="assets/pefl_0402.png" class="calibre23"/>
<h6 class="calibre24"><span class="firstname">Figure 4-2. </span>Typical basic steps for translating the user’s problem into the domain of the LLM</h6>
</div></figure>

<section data-type="sect3" data-pdf-bookmark="Context retrieval" class="calibre6"><div class="preface" id="ch04_context_retrieval_1728407230644876">
<h3 class="calibre45">Context retrieval</h3>

<p class="subtitle">The<a contenteditable="false" data-primary="context" data-secondary="retrieving" data-type="indexterm" id="id513" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> first thing you do to build the feedforward pass is create or retrieve the raw text that serves as the context information for the prompt. One way to think through this problem is to consider context in terms of how <em class="hyperlink">direct</em> or <em class="hyperlink">indirect</em> it is.</p>

<p class="subtitle">The<a contenteditable="false" data-primary="direct context" data-type="indexterm" id="id514" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="context" data-secondary="direct context" data-type="indexterm" id="id515" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">most</em> <em class="hyperlink">direct</em> context comes straight from the user as they describe their problem. If you’re building a tech support assistant, this is the text that the user types directly into the help box; with GitHub Copilot, this is the code block that the user is editing right now.</p>

<p class="subtitle">Indirect context<a contenteditable="false" data-primary="indirect context" data-type="indexterm" id="id516" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="context" data-secondary="indirect context" data-type="indexterm" id="id517" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> comes from relevant sources nearby. If you’re building a tech support app, for example, you might search documentation for excerpts that address the user’s problem. For Copilot, the indirect context comes largely from other open tabs in the developer’s IDE because these files often include snippets relevant to the user’s current problem. The least direct context corresponds to the boilerplate text that is used to shape the response of the model. For a tech support app, this could be the message at the top of the prompt that says, “This is an IT support request. We do whatever it takes to help users solve their problems.”</p>

<p class="subtitle">Boilerplate text at the top of the prompt is used to introduce the general problem. Later in the prompt, it acts as a glue to connect the bits of direct context in such a way that it makes sense to the model. For instance, the nonbolded text in <a data-type="xref" href="#ch04_table_2_1728407230620704" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Table 4-2</a> is boilerplate. The boilerplate at the top of the table introduces the travel problem, and the boilerplate farther down allows us to incorporate information directly from the user regarding travel plans as well as relevant information pulled from news and government sources.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Snippetizing context" class="calibre6"><div class="preface" id="ch04_snippetizing_context_1728407230644946">
<h3 class="calibre45">Snippetizing context</h3>

<p class="subtitle">Once<a contenteditable="false" data-primary="snippetizing context" data-type="indexterm" id="id518" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="context" data-secondary="snippetizing context" data-type="indexterm" id="id519" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> the relevant context has been retrieved, it must be snippetized and prioritized. <em class="hyperlink">Snippetizing</em> means breaking down the context into the chunks most relevant for the prompt. For instance, if your IT support application issues a documentation search and returns with pages of results, then you must extract only the most relevant passages; otherwise, we may exceed the prompt’s token budget.</p>

<p class="subtitle">Sometimes, snippetizing means creating text snippets by converting context information from a different format. For instance, if the tech support application is a phone assistant, then you need to transcribe the user’s request from voice to text. If your context retrieval calls out to a JSON API, then it might be important to format the response as natural language so that the model will not incorporate JSON fragments into its response.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Scoring and prioritizing snippets" class="calibre6"><div class="preface" id="ch04_scoring_and_prioritizing_snippets_1728407230645019">
<h3 class="calibre45">Scoring and prioritizing snippets</h3>

<p class="subtitle">The<a contenteditable="false" data-primary="scoring snippets" data-type="indexterm" id="id520" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> token window of the original GPT-3.5 models was a measly 4,096 tokens, so running out of space was once a pressing concern in any LLM application. Now, with token windows upward of 100,000 tokens, it’s less likely that you’ll run out of space in your prompt. However, it’s still important to keep your prompts as trim as possible because long blobs of irrelevant text will confuse the model and lead to worse completions.</p>

<p class="subtitle">To<a contenteditable="false" data-primary="prioritizing snippets" data-type="indexterm" id="id521" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> pick the best content, once you’ve gathered a set of snippets, you should assign each snippet either a priority or a score corresponding to how important that snippet will be for the prompt. We have very specific definitions of scores and priorities. <em class="hyperlink">Priorities</em> can be thought of as integers that establish tiers of snippets based upon how important they are and how they function in the prompt. When assembling the prompt, you’ll make sure that all snippets from a higher tier are utilized before dipping into the snippets from the next tier. <em class="hyperlink">Scores</em>, on the other hand, can be thought of as floating-point values that emphasize the shades of difference between snippets. Some snippets within the same priority tier are more relevant than others and should be used first.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Prompt assembly" class="calibre6"><div class="preface" id="ch04_prompt_assembly_1728407230645088">
<h3 class="calibre45">Prompt assembly</h3>

<p class="subtitle">In<a contenteditable="false" data-primary="prompt assembly" data-secondary="goals for successful" data-type="indexterm" id="id522" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> the last step, all of this snippet fodder gets assembled into the final prompt. You have many goals during this step: you must clearly convey the user’s problem and pack the prompt as full of the best supporting context as possible—and you must <em class="hyperlink">make sure</em> not to exceed the token budget, because all you’ll get back from the model in that case is an error message.</p>

<p class="subtitle">It’s at this point where accounting comes heavily into play. You must make sure that all your boilerplate instructions fit in the prompt context, make sure that the user’s request fits, and then collect as much supporting context as possible. Sometimes, during this step, you might want to make a last-minute effort to shorten the context. For instance, if you know that a full code file is relevant to the user’s answer but doesn’t fit, you have an option during this step to elide (remove) less relevant lines of code until the document fits. If you have a long document, you can also employ summarization.</p>

<p class="subtitle">In addition to making sure all the pieces fit, you must ensure they are assembled into their proper order. Then, the final prompt document should read like a document you might find in the training data (leading Little Red Riding Hood on the path directly to Grandma’s house).</p>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Exploring the Complexity of the Loop" class="calibre6"><div class="preface" id="ch04_exploring_the_complexity_of_the_loop_1728407230645166">
<h2 class="calibre19">Exploring the Complexity of the Loop</h2>

<p class="subtitle">The<a contenteditable="false" data-primary="application design" data-secondary="exploring loop complexity" data-type="indexterm" id="ADcomplex04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="complexity, dimensions of" data-type="indexterm" id="id523" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="dimensions of complexity" data-type="indexterm" id="id524" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> previous section focused on the simplest type of LLM application—one that does all of its work in a single request to the model and then returns the completion to the user. Such a simple application is important to understand because it serves as the starting point. It presents basic principles upon which applications of increasing complexity are built. As applications get more complex, there are several dimensions along which this complexity comes into play:</p>

<ul class="stafflist">
	<li class="calibre9">
	<p class="calibre26">More application state</p>
	</li>
	<li class="calibre9">
	<p class="calibre26">More external content</p>
	</li>
	<li class="calibre9">
	<p class="calibre26">More complex reasoning</p>
	</li>
	<li class="calibre9">
	<p class="calibre26">More complex interaction with the world outside of the model</p>
	</li>
</ul>

<section data-type="sect3" data-pdf-bookmark="Persisting application state" class="calibre6"><div class="preface" id="ch04_persisting_application_state_1728407230645243">
<h3 class="calibre45">Persisting application state</h3>

<p class="subtitle">The<a contenteditable="false" data-primary="application state" data-type="indexterm" id="id525" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="persistence" data-type="indexterm" id="id526" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="state" data-type="indexterm" id="id527" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> feedforward application from the previous section holds no persistent state. It simply takes the user’s input, adds on some <em class="hyperlink">hopefully</em> relevant context, passes it on to the model, and then passes the model’s response back to the user. In this simple world, if the user makes another request, the application has no recollection of the previous exchange. Copilot code completion is an application that works exactly this way.</p>

<p class="subtitle">More complex LLM applications usually require state to be maintained between requests. For instance, even the most basic chat application must maintain a record of the conversation. During the middle of a chat session, when the user submits a new message to the application, the application looks up this conversation thread in a database and uses the previous exchanges as further context for the next prompt.</p>

<p class="subtitle">If a user’s interactions are long running, then you may need to abridge the history to fit it into the prompt. The easiest way to accomplish this is by just truncating the conversation and cutting off the earlier exchanges. This won’t always work, though! Sometimes, the content is too important to cut, so another approach is to summarize earlier parts of the conversation.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="External context" class="calibre6"><div class="preface" id="ch04_external_context_1728407230645312">
<h3 class="calibre45">External context</h3>

<p class="subtitle">LLMs—even the best ones—don’t have <em class="hyperlink">all</em> the<a contenteditable="false" data-primary="external context" data-type="indexterm" id="id528" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="context" data-secondary="external context" data-type="indexterm" id="id529" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> answers. How could they? They’ve been trained only on publicly available data, and they have no clue about recent events and information that is hidden behind a corporate, government, or personal privacy wall. If you ask a model about information that it does not possess, then <em class="hyperlink">ideally</em>, it will apologize and explain that it doesn’t have access to that information. This doesn’t lead to user satisfaction, but it’s infinitely better than the alternative—the model confidently<a contenteditable="false" data-primary="hallucinations" data-secondary="preventing with RAG" data-type="indexterm" id="id530" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> hallucinating an answer and telling the user something that is completely false.</p>

<p class="subtitle">For this reason, many LLM applications employ<a contenteditable="false" data-primary="retrieval-augmented generation (RAG)" data-secondary="definition of term" data-type="indexterm" id="id531" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> retrieval augmented generation (RAG). With RAG, you augment the prompt with context drawn from sources that were unavailable to the model during training. This could be anything from your corporate documentation to your user’s medical records to recent news events and recently published papers.</p>

<p class="subtitle">This information is indexed into a search engine of some sort. Lots of people have been using embedding models to convert documents (or document fragments) into vectors that can be stored in a vector store (like Pinecone). However, you shouldn’t turn up your nose at good old-fashioned search indexes (such as Elasticsearch) because they tend to be relatively simple to manage and much easier to debug with when you don’t seem to be finding the documents that you’re looking for.</p>

<p class="subtitle">Actually retrieving the context usually follows a spectrum of possible approaches. The simplest is to directly use the user’s request as the search query. However, if your user’s request is a long run-on paragraph, then it might have extraneous content that causes spurious matches to come back from the index. In this case, you can ask the LLM what it thinks a good search will be and just use its response text to search the index. Finally, if your application is in some sort of long chat with a user, it might not at all be apparent when it’s worth even searching for something; you can’t retrieve documents for every comment they have because they might still be talking about documents related to their last comment. In this case, you can introduce a <em class="hyperlink">search tool</em> to the assistant and let the assistant choose when to make a search and what search terms to use. (We’ll introduce tool usage just a bit further on.)</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Increasing reasoning depth" class="calibre6"><div class="preface" id="ch04_increasing_reasoning_depth_1728407230645385">
<h3 class="calibre45">Increasing reasoning depth</h3>

<p class="subtitle">As<a contenteditable="false" data-primary="reasoning depth" data-type="indexterm" id="id532" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> we covered in <a data-type="xref" href="ch01.html#ch01_1_introduction_to_prompt_engineering_1728408393615260" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Chapter 1</a>, the really spectacular thing about the larger LLMs starting with GPT-2 was that they began to generalize much more broadly than their predecessors. The paper entitled <a href="https://oreil.ly/MEw4b" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">“Language Models are Unsupervised Multitask Learners”</a> makes just this point—GPT-2, trained on millions of web pages, was able to beat benchmarks in several categories that had until that point required very specialized model training.</p>

<p class="subtitle">For instance, to get GPT-2 to summarize text, you could append the<a contenteditable="false" data-primary="TL;DR" data-type="indexterm" id="id533" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> string <code class="calibre15"><strong class="calibre53">TL;DR</strong></code> to the end of the text, et voilà! And to get GPT-2 to translate text from English to French, you could just provide it with one example translation and then subsequently provide the English sentence to be translated. The model would pick up on the pattern and translate accordingly. It was as if the model were actually in some way <em class="hyperlink">reasoning</em> about the text in the prompt. In subsequent years, we’ve found ways to elicit more sophisticated patterns of reasoning from the LLMs. One simple but effective approach is to insist that the model show its step-by-step thought process <em class="hyperlink">before</em> providing the answer to the problem. This is called<a contenteditable="false" data-primary="chain-of-thought prompting" data-secondary="definition of term" data-type="indexterm" id="id534" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">chain-of-thought</em> prompting. The intuition behind this is that, unlike humans, LLMs have no internal monologue, so they can’t really think <em class="hyperlink">about</em> a problem before answering.</p>

<p class="subtitle">Instead, each token is mechanically generated as a function of every token that preceded it. Therefore, if you want to have the model “think” about a problem before answering, the thinking must be done “out loud” in the completion. Afterward, when subsequent tokens are calculated, the model will predict tokens that are as consistent as possible with the preceding tokens and therefore consistent with their “thought process.” This often leads to much better-reasoned answers.</p>

<p class="subtitle">As LLM applications require more complicated work to be completed, the prompt engineer must find clever ways to break the problem down and elicit the right step-by-step thinking for each component to drive the model to a better solution.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Tool usage" class="calibre6"><div class="preface" id="ch04_tool_usage_1728407230645456">
<h3 class="calibre45">Tool usage</h3>

<p class="subtitle">By<a contenteditable="false" data-primary="tool loop" data-type="indexterm" id="id535" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> themselves, LLMs act in a closed world—they know nothing about the outside world and have no ability to effect change in the outside world. This constraint seriously limits the utility of LLM applications. In response to this weakness, most frontier LLMs are now able to interact with the world through <em class="hyperlink">tools</em>.</p>

<p class="subtitle">Take a look at the <em class="hyperlink"> tool loop</em> in <a data-type="xref" href="#ch04_figure_3_1728407230608987" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 4-3</a>. The idea is simple. In the prompt, you make the model aware of one or more tools that it has access to. The tools will look like functions including a name, several arguments, and descriptions for the name and arguments. During a conversation, the model can choose to execute these tools—basically by calling one of the functions with an appropriate set of arguments.</p>

<figure class="calibre22"><div id="ch04_figure_3_1728407230608987" class="figure"><img src="assets/pefl_0403.png" class="calibre23"/>
<h6 class="calibre24"><span class="firstname">Figure 4-3. </span>A more complicated application loop that includes an internal tool loop</h6>
</div></figure>

<p class="subtitle">Note that LLM-applications can become quite complex. Conversations are stateful, and the context must be preserved from one request to the next. Information from external APIs is used to augment the data, and the tool execution loop may iterate several times back and forth between the application and the model before information can be returned to the user<em class="hyperlink">.</em></p>

<p class="subtitle">Naturally, the model has no ability to actually execute code, so it is the responsibility of the LLM application to intercept this function call from the model and execute a real-world API and the appended information from the response to the prompt. Because of this, on the next turn, the model can use that information to reason about the problem at hand.</p>

<p class="subtitle">One of the earlier papers to consider tool usage was <a href="https://arxiv.org/abs/2210.03629" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">“ReAct: Synergizing Reasoning and Acting in Language Models”</a> (2022). It<a contenteditable="false" data-primary="search tool" data-type="indexterm" id="id536" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="lookup tool" data-type="indexterm" id="id537" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="finish tool" data-type="indexterm" id="id538" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> introduced three tools: <code class="calibre15">search</code>, <code class="calibre15">lookup</code>, and <code class="calibre15">finish</code>, which, respectively, allowed the model to search through Wikipedia, look up relevant blocks of text within a Wikipedia page, and return the answer to the user. This shows how tool usage can overlap with RAG—namely, if you provide the model with search tools, it will be able to make its own determination of when it needs external information and how to <span class="firstname">find it</span>.</p>

<p class="subtitle">Search, though, is a read-only behavior. Similarly, tools connected to external APIs that check the temperature, determine if you have any new emails, or retrieve recent LinkedIn posts are all read-only. Where things get really interesting is when we allow them to write changes out into the real world. Since tools give models access to any real-world API imaginable, you’ll be able to create LLM-based assistants that can write code and create pull-requests, help you plan travel and reserve airfare and lodging, and so much more. Naturally, <em class="hyperlink">with great power comes great </em><em class="hyperlink">responsibility</em>. Models are probabilistic and <em class="hyperlink">often</em> make mistakes, so don’t let the LLM application book a trip to Greece just because the user said they would love to visit someday!<a contenteditable="false" data-primary="" data-startref="ADfeed04" data-type="indexterm" id="id539" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="feed04" data-type="indexterm" id="id540" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="ADloops04" data-type="indexterm" id="id541" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="llmapploops04" data-type="indexterm" id="id542" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="ADcomplex04" data-type="indexterm" id="id543" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="loopofinter04" data-type="indexterm" id="id544" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="theloopofint04" data-type="indexterm" id="id545" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/></p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Evaluating LLM Application Quality" class="calibre6"><div class="preface" id="ch04_evaluating_llm_application_quality_1728407230645530">
<h1 class="calibre5">Evaluating LLM Application Quality</h1>

<p class="subtitle">Again, we<a contenteditable="false" data-primary="application design" data-secondary="evaluating application quality" data-type="indexterm" id="ADquality04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="quality" data-secondary="of applications" data-secondary-sortas="applications" data-type="indexterm" id="qualeval04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="evaluation" data-secondary="challenges of and tips for" data-type="indexterm" id="evalqual04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> say that LLMs are probabilistic and <em class="hyperlink">often</em> make mistakes. Therefore, when designing and productionizing an LLM application, it is imperative that you constantly evaluate application quality. Before you ship a new LLM-based feature, take time to prototype the functionality and gather some quantitative metrics about how the model will react. And then, once a feature ships, your application should be recording telemetry so that you can keep an eye on both the model’s and the users’ behavior so that you can quickly ascertain any degradation in the quality of the application.</p>

<section data-type="sect2" data-pdf-bookmark="Offline Evaluation" class="calibre6"><div class="preface" id="ch04_offline_evaluation_1728407230645601">
<h2 class="calibre19">Offline Evaluation</h2>

<p class="subtitle"><em class="hyperlink">Offline evaluation</em> is<a contenteditable="false" data-primary="offline evaluation" data-secondary="challenges of and tips for" data-type="indexterm" id="id546" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="evaluation" data-secondary="of application quality" data-secondary-sortas="application quality" data-type="indexterm" id="Eappqual04" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="evaluation" data-secondary="offline evaluation" data-type="indexterm" id="id547" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> all about trying new ideas for your LLM application <em class="hyperlink">before</em> exposing your users to an untested new experience. If anything, offline evaluation is even more complex than online evaluation, which we described later in this section. Since, before shipping a feature to production, you don’t have any customers to tell you “good” or “bad,” you have to figure out some simulated proxy for this evaluation.</p>

<p class="subtitle">Sometimes, you get lucky. For example, with Copilot code completions, a good proxy for user satisfaction is whether or not the code is functional and complete. In the case of code, this is actually quite easy to measure—if you can delete fragments of working code and then generate a completion that still passes the tests, then the code works and your users will likely be happy with similar completions in production. This is exactly how we evaluated changes prior to shipping them—we grabbed a few hundred repos, made sure their tests ran, surgically deleted and generated fragments of code, and then saw whether or not the tests still ran.</p>

<p class="subtitle">Often, you won’t be this lucky. How do you evaluate a scheduling assistant that is expected to create real-world interactions, and how do you evaluate a general chat application that engages users in open-ended dialogue? One emerging approach is to make an LLM act as a judge, much like a human judge, and review chat transcripts and determine which variant is best. The judgment can be an answer to a basic question like “Which version is better?” However, for a more nuanced score, you can give the judge a checklist of criteria to review for each variant.</p>

<p class="subtitle">However you choose to evaluate your LLM application, always try to engage as much of the application as possible in the evaluation. It might be easier to fake the context-gathering step of the application and test only the prompt assembly and prompt boilerplate; sometimes, mocking the context is even unavoidable. But often, the context-gathering steps become more important in building a quality LLM application. If you sidestep context gathering or any other aspect of your application, it will be at the peril of application quality assurance, and you might be in for a nasty surprise when the new feature goes into production.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Online Evaluation" class="calibre6"><div class="preface" id="ch04_online_evaluation_1728407230645670">
<h2 class="calibre19">Online Evaluation</h2>

<p class="subtitle">With<a contenteditable="false" data-primary="online evaluation" data-secondary="implicit indicators of quality" data-type="indexterm" id="id548" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="evaluation" data-secondary="online evaluation" data-type="indexterm" id="id549" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> online evaluation, you’re looking for user feedback on whether the application provides a good experience. Feedback doesn’t have to involve filling out long forms, though. The lifeblood of online evaluation is telemetry data—so measure <em class="hyperlink">everything</em>.</p>

<p class="subtitle">One obvious way to assess quality is to ask users directly. In ChatGPT and other chat-based LLM experiences, you’ve probably seen the little thumbs-up or thumbs-down buttons next to each assistant message. While this seems to be a clear metric for quality, you have to account for bias. It might be that only the really angry users ever vote—and they always vote thumbs-down. And besides this, proportionally speaking, not much traffic gets any interaction with the up/down buttons. So unless your application is really high traffic, you might not get enough data from up/down buttons.</p>

<p class="subtitle">Clearly, we<a contenteditable="false" data-primary="quality" data-secondary="implicit indicators of" data-type="indexterm" id="id550" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> have to get more creative with our measurements—so you must consider <em class="hyperlink">implicit</em> indicators of quality. For GitHub Copilot code completions, we measure how often completions are accepted and we check to see if users are going back and modifying our completions after accepting them. For your own applications, you’ll probably find your own ways of implicitly measuring quality. Be cautious about how you interpret implicit feedback. If you are building an LLM-based scheduling assistant and users are interacting and quickly leaving, then it might be because they are accomplishing their tasks efficiently (Yay!), but it could also be that users are frustrated and are abandoning the experience altogether.</p>

<p class="subtitle">Measure something that matters—something that demonstrates a productivity boost for your customers. Copilot chose the<a contenteditable="false" data-primary="acceptance rate metric" data-type="indexterm" id="id551" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> acceptance rate as the key metric <a href="https://oreil.ly/Do5qI" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">because it correlated most highly with the user’s productivity gains</a>. For a scheduling assistant, rather than measuring session length, which is ambiguous, look for successfully created calendar events and also keep track of how often users change the details of the events after the fact.<a contenteditable="false" data-primary="" data-startref="qualeval04" data-type="indexterm" id="id552" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="ADquality04" data-type="indexterm" id="id553" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="evalqual04" data-type="indexterm" id="id554" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="Eappqual04" data-type="indexterm" id="id555" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Conclusion" class="calibre6"><div class="preface" id="ch04_conclusion_1728407230645739">
<h1 class="calibre5">Conclusion</h1>

<p class="subtitle">After you learned about how an LLM works in the previous chapters, in this chapter, you learned that the LLM application is effectively a transformation layer between the user’s problem domain and the document domain where the LLM does its work. We zoomed in on the feedforward part of the loop, and you learned about how the prompt is formed by collecting context related to the user’s problem, extracting the most important parts, and assembling them into the boilerplate text of the prompt document. We then zoomed out and looked at how complex prompt engineering can become as it requires state management, integration with external context, increasingly sophisticated reasoning, and interaction with external tools.</p>

<p class="subtitle">In this chapter, we’ve touched on every topic in the domain of LLM application development—but only at a very high level. In the next chapters, we’ll dig deeply into all of the topics introduced in this chapter. You’ll learn more about <em class="hyperlink">where</em> to pull context from, <em class="hyperlink">how</em> to create snippets and prioritize them, and <em class="hyperlink">how</em> to build a prompt that is effective in addressing the user’s needs. Then, in later chapters, we’ll dig into more advanced applications and go into detail about how you can use these basic concepts to create conversational agency and complicated workflows.</p>
</div></section>
</div></section></div></div></body></html>