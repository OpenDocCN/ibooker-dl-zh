<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div class="readable-text" id="p1">
<h1 class="readable-text-h"><span class="calibre22"><span class="calibre22">11</span></span> <span class="calibre22">Creating an authorship identification program</span></h1>
</div>
<div class="readable-text">
<h3 class="introduction-header">This chapter covers</h3>
<ul class="calibre24">
<li class="readable-text1" id="p2">Writing an authorship identification program using top-down design</li>
<li class="readable-text1" id="p3">Learning about refactoring code and why you would do it</li>
</ul>
</div>
<div class="readable-text" id="p4">
<p class="calibre15">In chapter 7, we learned about problem decomposition and top-down design when we wrote our Spelling Suggestions program. Here, we’re going to take top-down design to the next level and solve a much larger problem. We’re still doing the same thing as in chapter 7: dividing a problem into subproblems, and further dividing those subproblems into sub-subproblems as needed. And, just like before, we’re looking to design functions with a small number of parameters that return a meaningful and useful result to their caller. It’s also a good sign if we’re able to design functions that are called by multiple other functions—that helps reduce code repetition!</p>
</div>
<div class="readable-text" id="p5">
<p class="calibre15">We’re including this chapter because we wanted to provide a more authentic example than the Spelling Suggestions problem we solved in chapter 7. We hope our example here is motivating and feels like a real problem that you could imagine yourself wanting to solve. </p>
</div>
<div class="readable-text" id="p6">
<p class="calibre15">In this chapter, we’re going to write a program that tries to identify the unknown author of a mystery book. It’ll be an example of a program that uses artificial intelligence (AI) to make a prediction. We couldn’t resist the opportunity to include an AI example in a book about programming with AI!</p>
</div>
<div class="readable-text" id="p7">
<h2 class="readable-text-h1" id="sigil_toc_id_161"><span class="calibre22">11.1</span> Authorship identification</h2>
</div>
<div class="readable-text" id="p8">
<p class="calibre15">This problem is based on an assignment created by our colleague Michelle Craig [1]. Let’s start by taking a look at these two book excerpts:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p9"> <em class="calibre18">Excerpt 1</em>—I have not yet described to you the most singular part. About six years ago—to be exact, upon the 4<sup class="calibre34">th </sup>of May 1882—an advertisement appeared in the Times asking for the address of Miss Mary Morstan and stating that it would be to her advantage to come forward. There was no name or address appended. I had at that time just entered the family of Mrs. Cecil Forrester in the capacity of governess. By her advice I published my address in the advertisement column. The same day there arrived through the post a small card-board box addressed to me, which I found to contain a very large and lustrous pearl. No word of writing was enclosed. Since then, every year upon the same date there has always appeared a similar box, containing a similar pearl, without any clue as to the sender. They have been pronounced by an expert to be of a rare variety and of considerable value. You can see for yourselves that they are very handsome. </li>
<li class="readable-text1" id="p10"> <em class="calibre18">Excerpt 2</em>—It was the Dover Road that lay on a Friday night late in November, before the first of the persons with whom this history has business. The Dover Road lay, as to him, beyond the Dover mail, as it lumbered up Shooter’s Hill. He walked up hill in the mire by the side of the mail, as the rest of the passengers did; not because they had the least relish for walking exercise, under the circumstances, but because the hill, and the harness, and the mud, and the mail, were all so heavy, that the horses had three times already come to a stop, besides once drawing the coach across the road, with the mutinous intent of taking it back to Blackheath. Reins and whip and coachman and guard, however, in combination, had read that article of war which forbade a purpose otherwise strongly in favour of the argument, that some brute animals are endued with Reason; and the team had capitulated and returned to their duty. </li>
</ul>
<div class="readable-text" id="p11">
<p class="calibre15">Suppose we asked you whether these two excerpts were likely written by the same author. One reasonable assumption you might make is that different authors write differently, and that these differences would show up in metrics that we could calculate about their texts.</p>
</div>
<div class="readable-text" id="p12">
<p class="calibre15">For example, whoever wrote the first excerpt seems to use quite a few short sentences in terms of number of words compared to the second excerpt. We find short sentences like “There was no name or address appended” and “No word of writing was enclosed” in the first excerpt; those kinds of sentences are absent from the second. Similarly, the sentences from the first excerpt seem to be less complex than those in the second; look at all of those commas and semicolons in the second excerpt.</p>
</div>
<div class="readable-text" id="p13">
<p class="calibre15">This analysis may lead you to believe that these texts are written by different authors, and, indeed, they are. The first is written by Sir Arthur Conan Doyle, and the second by Charles Dickens.</p>
</div>
<div class="readable-text" id="p14">
<p class="calibre15">To be fair, we’ve absolutely cherry-picked these two excerpts. Doyle does use some long, complex sentences. Dickens does use some short ones. But, on average, at least for the two books that we took these excerpts from, Doyle does write shorter sentences than Dickens. More generally, if we look at two books written by different authors, we might expect to find some quantifiable differences on average.</p>
</div>
<div class="readable-text" id="p15">
<p class="calibre15">Suppose that we have a bunch of books whose authors we know. We have one written by Doyle, one written by Dickens, and so on. Then, along comes a mystery book. Oh no! We don’t know who wrote it! Is it a lost Sherlock Holmes story from Doyle? A lost <em class="calibre18">Oliver Twist</em> sequel from Dickens? We want to find out who that unknown author is, and to do that, we’ll turn to a basic AI technique.</p>
</div>
<div class="readable-text" id="p16">
<p class="calibre15">Our strategy will be to come up with a <em class="calibre18">signature</em> for each author, using one of the books we know they wrote. We’ll refer to these signatures as <em class="calibre18">known signatures</em>. Each of these signatures will capture metrics about the book text, such as the average number of words per sentence and the average sentence complexity. Then, we’ll come up with a signature for the mystery book with an unknown author. We’ll call this the <em class="calibre18">unknown signature</em>. We’ll look through all the known signatures, comparing each one to our unknown signature. We’ll use whichever is the closest as our guess for the unknown author.</p>
</div>
<div class="readable-text" id="p17">
<p class="calibre15">Of course, we have no idea if the unknown author is really one of the authors whose signatures we have. It could be a completely new author, for example. Even if the unknown author <em class="calibre18">is </em>one of the authors whose signature we have, we still might end up guessing wrong. After all, maybe the same author writes books in different styles (giving their books very different signatures), or we simply fail to capture what is most salient about how each of our authors writes. Indeed, we’re not after an industry-strength author identification program in this chapter. Still, considering the difficulty of this task, we think it’s impressive how well the approach that we’ll show you here works.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p18">
<h5 class="callout-container-h">Machine learning </h5>
</div>
<div class="readable-text" id="p19">
<p class="calibre15">Authorship identification, as we’re doing here, is a <em class="calibre18">machine learning</em><em class="calibre18"> </em>(ML) task. ML is a branch of AI designed to help computers “learn” from data in order to make predictions. There are various forms of ML; the one we’re using here is called supervised learning. In supervised learning, we have access to training data, which consists of objects and their known categories (or labels). In our case, our objects are book texts, and the category for each book is the author who wrote it. We can train (i.e., learn) on the training set by calculating features—average number of words per sentence, average sentence complexity, and so on—for each book. Later, when we’re provided a book whose author we don’t know, we can use what we learned in the training to make our prediction (or guess).</p>
</div>
</div>
<div class="readable-text" id="p20">
<h2 class="readable-text-h1" id="sigil_toc_id_162"><span class="calibre22">11.2</span> Authorship identification using top-down design</h2>
</div>
<div class="readable-text" id="p21">
<p class="calibre15">Alright, we want to “write a program to determine the author of a book.” This seems like a daunting task, and it would be if we were trying to do this in one shot, using a single function. But just like in our Spelling Suggestions example in chapter 7, we’re not going to do that. We’re going to systematically break this problem down into subproblems that we can solve.</p>
</div>
<div class="readable-text" id="p22">
<p class="calibre15">In chapter 7, we solved the Spelling Suggestions problem by using the model of reading input, processing that input, and producing an output result. We can think about our authorship identification program as following that model as well: </p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p23"> <em class="calibre18">Input step</em> —For the input step, we need to ask the user for the filename of the mystery book. </li>
<li class="readable-text1" id="p24"> <em class="calibre18">Process step</em> —For the process step, we need to figure out the signature for the mystery book (that’s the unknown signature), as well as the signature for each of the books whose author we know (those are the known signatures). Creating the signature for each book is commonly called the training phase in ML. We also need to compare the unknown signature to each known signature to figure out which known signature is closest. These comparisons are the prediction phase in ML. </li>
<li class="readable-text1" id="p25"> <em class="calibre18">Output step</em> —For the output step, we need to report to the user the unknown signature that’s closest to the known signature. </li>
</ul>
<div class="readable-text" id="p26">
<p class="calibre15">That is, to solve our overall authorship identification problem, we need to solve these three subproblems. We’re starting our top-down design!</p>
</div>
<div class="readable-text" id="p27">
<p class="calibre15">We’ll name our top-level function <code class="calibre25">make_guess</code>. In it, we’ll solve each of the three subproblems we identified.</p>
</div>
<div class="readable-text" id="p28">
<p class="calibre15">For the input step, we’re simply asking the user for a filename. That’s something we can do in a small number of lines of code, so we probably don’t need a separate function for that. The output step seems similar: assuming that we already know which known signature is closest, we can just report that to the user. By contrast, the process step looks like a lot of work, and we’ll certainly want to break that subproblem down further. That’s what we’ll do next.</p>
</div>
<div class="readable-text" id="p29">
<h2 class="readable-text-h1" id="sigil_toc_id_163"><span class="calibre22">11.3</span> Breaking down the process subproblem</h2>
</div>
<div class="readable-text" id="p30">
<p class="calibre15">We’ll name our overall process function <code class="calibre25">process_data</code>. It will take the mystery book filename and the name of a directory of known-author books as parameters and return the name of the closest known signature.</p>
</div>
<div class="readable-text" id="p31">
<p class="calibre15">Looking at our description for the process step, it seems that we have three subproblems to solve here:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p32"> <em class="calibre18">Figure out the signature for the mystery book.</em> That’s our unknown signature. We’ll name this function <code class="calibre25">make_signature</code>. </li>
<li class="readable-text1" id="p33"> <em class="calibre18">Figure out the signature for each of the books whose author we know.</em> These are our known signatures. We’ll name this function <code class="calibre25">get_all_signatures</code>. </li>
<li class="readable-text1" id="p34"> <em class="calibre18">Compare the unknown signature to each known signature to figure out which known signature is closest.</em> Because close signatures will have small differences, we’ll name this function <code class="calibre25">lowest_score</code>. </li>
</ul>
<div class="readable-text" id="p35">
<p class="calibre15">We’ll work on our top-down design for each of these subproblems in turn. Figure 11.1 shows a diagram of what we have so far.<span/></p>
</div>
<div class="browsable-container" id="p36">
<img alt="figure" src="../Images/11-1.png" class="calibre91"/>
<h5 class="figure-container-h"><span>Figure 11.1</span> Functions diagram with the three subtasks of <code class="calibre25">process_data</code></h5>
</div>
<div class="readable-text" id="p37">
<h3 class="readable-text-h2" id="sigil_toc_id_164"><span class="calibre22">11.3.1</span> Figuring out the signature for the mystery book</h3>
</div>
<div class="readable-text" id="p38">
<p class="calibre15">The function for this task, <code class="calibre25">make_signature</code>, will take the text for our book as a parameter and return the book’s signature. At this point, we need to decide on the features that we’ll use to determine the signature for each book. Let’s break this down by thinking back to the previous example passages. We noticed there are differences in the authors’ passages based on the complexity and length of sentences. You may have also suspected that the authors may differ in the length of words used and ways they use words (e.g., some authors may be more repetitive than others). As such, we’ll want some features to be based on the structure of the author’s sentences, and we’ll want others based on the words that the author uses. We’ll look at each of these in detail.</p>
</div>
<div class="readable-text" id="p39">
<h4 class="readable-text-h3">Features related to the structure of the author’s sentences</h4>
</div>
<div class="readable-text" id="p40">
<p class="calibre15">In our earlier Doyle versus Dickens example, we talked about using the average number of words per sentence as one feature. We can calculate this by dividing the total number of words by the total number of sentences. For example, consider the following text:</p>
</div>
<div class="readable-text" id="p41">
<blockquote class="calibre2">
<div class="readable-text">
     The same day there arrived through the post a small card-board box addressed to me, which I found to contain a very large and lustrous pearl. No word of writing was enclosed.
    </div>
</blockquote>
</div>
<div class="readable-text" id="p42">
<p class="calibre15">If you count the words and sentences, you should find that there are 32 words (card-board counts as one word) and two sentences, so we’ll calculate the average words per sentence as 32/2 = 16. This will be the<strong class="calibre17"> </strong><em class="calibre18">average number of words per sentence</em><strong class="calibre17"> </strong>feature.</p>
</div>
<div class="readable-text" id="p43">
<p class="calibre15">We also noticed that the complexity of sentences may vary between authors (i.e., some authors have sentences with many more commas and semicolons compared to other authors), so it makes sense to use that as another feature. More complex sentences have more phrases, which are coherent pieces of sentences. Breaking a sentence into its component phrases is a tough challenge in its own right, and although we could try to do it more accurately, we’ll settle here for a simpler rule of thumb. Namely, we’ll say that a phrase is separated from other phrases in the sentence by a comma, semicolon, or colon. Looking at the previous text again, we find that there are three phrases. The first sentence has two phrases: “The same day there arrived through the post a small card-board box addressed to me” and “which I found to contain a very large and lustrous pearl.” The second sentence has no commas, semicolons, or colons, so it has only one phrase. As there are three phrases and two sentences, we’d say that the sentence complexity for this text is 3/2 = 1.5. This will be the <em class="calibre18">average sentence complexity</em> feature.</p>
</div>
<div class="readable-text" id="p44">
<p class="calibre15">We hope that these sentence-level features intuitively make sense as things we could use to differentiate how authors write. Next, let’s start looking at the ways that authors may differ in their use of words.</p>
</div>
<div class="readable-text" id="p45">
<h4 class="readable-text-h3">Features related to the author’s word selection</h4>
</div>
<div class="readable-text" id="p46">
<p class="calibre15">You can probably think of your own metrics for word-level features, but we’ll use three here that in our experience work well. First, it’s likely that some authors use shorter words on average than other authors. To that end, we’ll use the average word length, which is just the average number of letters per word. Let’s consider this sample text that we created:</p>
</div>
<div class="readable-text" id="p47">
<blockquote class="calibre2">
<div class="readable-text">
     A pearl! Pearl! Lustrous pearl! Rare. What a nice find.
    </div>
</blockquote>
</div>
<div class="readable-text" id="p48">
<p class="calibre15">If you count the letters and words, you should find that there are 41 letters and 10 words. (Don’t count punctuation as letters here.) So, we’ll calculate the average word length as 41/10 = 4.1. This will be the <em class="calibre18">average word length</em> feature.</p>
</div>
<div class="readable-text" id="p49">
<p class="calibre15">Second, it may be that some authors use words more repetitively than others. To capture this, we’ll take the number of different words that the author uses and divide it by the total number of words. For our previous sample text, there are only seven different words used: <em class="calibre18">a</em>, <em class="calibre18">pearl</em>, <em class="calibre18">lustrous</em>, <em class="calibre18">rare</em>, <em class="calibre18">what</em>, <em class="calibre18">nice</em>, and <em class="calibre18">find</em>. There are 10 words in all, so our calculation for this metric would be 7/10 = 0.7. This will be the<strong class="calibre17"> </strong><em class="calibre18">different words divided by total words</em><strong class="calibre17"> </strong>feature.</p>
</div>
<div class="readable-text" id="p50">
<p class="calibre15">Third, it may be that some authors tend to use many words a single time, whereas other authors tend to use words multiple times. To calculate this one, we’ll take the number of words used exactly once and divide it by the total number of words. For our sample text, there are five words that are used exactly once: <em class="calibre18">lustrous</em>, <em class="calibre18">rare</em>, <em class="calibre18">what</em>, <em class="calibre18">nice</em>, and <em class="calibre18">find</em>. There are 10 words in all, so our calculation for this metric would be 5/10 = 0.5. This will be the <em class="calibre18">number of words used exactly once divided by total words</em><strong class="calibre17"> </strong>feature.</p>
</div>
<div class="readable-text" id="p51">
<p class="calibre15">In all, we have five features that will make up each signature. We’ll need to store those numbers together in a single value, so we’ll end up using a list of five numbers for each signature.</p>
</div>
<div class="readable-text" id="p52">
<p class="calibre15">Let’s dig into how we’ll implement each of these features, starting with the word-level ones and proceeding to the sentence-level ones. We’ll go in this order:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p53"> Average word length </li>
<li class="readable-text1" id="p54"> Different words divided by total words </li>
<li class="readable-text1" id="p55"> Words used exactly once divided by total words </li>
<li class="readable-text1" id="p56"> Average number of words per sentence </li>
<li class="readable-text1" id="p57"> Average sentence complexity </li>
</ul>
<div class="readable-text" id="p58">
<p class="calibre15">For each one, we’ll ultimately end up writing a function. We have an updated diagram with function names for each of these five new functions that will help us implement <code class="calibre25">make_signature</code> in figure 11.2. Do we need to further break down these problems, or are they OK as is? Let’s see!<span/></p>
</div>
<div class="browsable-container" id="p59">
<img alt="figure" src="../Images/11-2.png" class="calibre92"/>
<h5 class="figure-container-h"><span>Figure 11.2</span> Functions diagram with the additional five subtasks of <code class="calibre25">make_signature</code></h5>
</div>
<div class="readable-text" id="p60">
<h4 class="readable-text-h3">Average word length</h4>
</div>
<div class="readable-text" id="p61">
<p class="calibre15">The function for this task, <code class="calibre25">average_word_length</code>, will take the text of the book as a parameter and return the average word length. We might start solving this task by using the split method on the text. As a reminder, the <code class="calibre25">split</code> method is used to split a string into a list of its pieces. By default, <code class="calibre25">split</code> will split around spaces. The book text is a string, and if we split around spaces, we’ll get its words! That’s exactly what we need here. We can then loop through that list of words, counting up the number of letters and number of words. </p>
</div>
<div class="readable-text" id="p62">
<p class="calibre15">That’s a good start, but we need to be a little more careful here because we don’t want to end up counting nonletters as letters. For example, “pearl” has five letters. But so does “pearl.” or “pearl!!” or “(pearl)”. Aha—this sounds like a subtask to us! Namely, we can divide out the subtask of cleaning up a word into its own function to be used by <code class="calibre25">average_word_length</code>. We’ll call that cleanup function <code class="calibre25">clean_word</code>. </p>
</div>
<div class="readable-text" id="p63">
<p class="calibre15">There’s another benefit to having our <code class="calibre25">clean_word</code> function, and that’s to help us identify when a “word” is actually not a word. For example, suppose one of our “words” in the text is . . . . When we pass this to <code class="calibre25">clean_word</code>, we’ll get an empty string back. That signifies that this in fact isn’t a word at all, so we won’t count it as such. </p>
</div>
<div class="readable-text" id="p64">
<h4 class="readable-text-h3">Different words divided by total words</h4>
</div>
<div class="readable-text" id="p65">
<p class="calibre15">The function for this task, <code class="calibre25">different_to_total</code>, will take the text of the book as a parameter and will return the number of different words used divided by the total number of words.</p>
</div>
<div class="readable-text" id="p66">
<p class="calibre15">As with <code class="calibre25">average_word_length</code>, we need to be careful to count only letters, not punctuation. But wait—we just talked about a <code class="calibre25">clean_word</code> function that we needed for <code class="calibre25">average_word_length</code>. We can use that function here as well! In fact, we’ll use <code class="calibre25">clean_ word</code> in most of our five feature tasks. This is the sign of a useful general-purpose function! Our top-down design is going well. We can see how the <code class="calibre25">clean_word</code> function will be called by both functions in our updated function diagram in figure 11.3.<span/></p>
</div>
<div class="browsable-container" id="p67">
<img alt="figure" src="../Images/11-3.png" class="calibre93"/>
<h5 class="figure-container-h"><span>Figure 11.3</span> Functions diagram with two functions, both using our <code class="calibre25">clean_word</code> function to help</h5>
</div>
<div class="readable-text" id="p68">
<p class="calibre15">There’s one extra complication here, though, and it involves words like <em class="calibre18">pearl</em>, <em class="calibre18">Pearl</em>, and <em class="calibre18">PEARL</em>. We want to consider those to be the same words, but if we simply use string comparisons, they will be treated as different words. One solution here is to split this off into another subproblem to convert a string to all lowercase. We could also think of this as another part of cleaning up a word, right along with removing the punctuation. We’ll go with this second option. What we’ll do, then, is make our <code class="calibre25">clean_word</code> function not only remove punctuation but also convert the word to lowercase.</p>
</div>
<div class="readable-text" id="p69">
<p class="calibre15">You might wonder whether we need to split off another subtask here, one that determines the number of different words. You could do that, and it wouldn’t be a mistake to do so. However, if we persevere without doing that, we’ll see that the function remains quite manageable without this additional subtask. Practice and experience over time will help you anticipate when a task needs to be further broken down.</p>
</div>
<div class="readable-text" id="p70">
<h4 class="readable-text-h3">Words used exactly once divided by total words </h4>
</div>
<div class="readable-text" id="p71">
<p class="calibre15">The function for this task, <code class="calibre25">exactly_once_to_total</code>, will take the text of the book as a parameter and will return the number of words used exactly once divided by the total number of words. We’re going to need our <code class="calibre25">clean_word</code> function here as well for reasons similar to why we needed it in the prior two tasks: to make sure we’re working only with letters, not punctuation. Again, while we could split out a subtask to determine the number of words that are used exactly once, we’ll find that it doesn’t take much Python code to do this, so we’ll just leave this task alone without splitting it further.</p>
</div>
<div class="readable-text" id="p72">
<h4 class="readable-text-h3">Average number of words per sentence</h4>
</div>
<div class="readable-text" id="p73">
<p class="calibre15">The function for this task, <code class="calibre25">average_sentence_length</code>, will take the text of the book as a parameter and will return the average number of words per sentence. To split our text into words for the previous three tasks, we can use the string split method. How do we split our text into sentences? Is there a string method for that?</p>
</div>
<div class="readable-text" id="p74">
<p class="calibre15">Unfortunately, there isn’t. For that reason, it will be helpful to split out a task to break our text string into sentences. We’ll call the function for that subtask <code class="calibre25">get_ sentences</code>. The <code class="calibre25">get_sentences</code> function will take the text of the book as a parameter and will return a list of sentences from the text.</p>
</div>
<div class="readable-text" id="p75">
<p class="calibre15">What’s a sentence? We’ll define a sentence as text that is separated by a period (.), question mark (?), or exclamation point (!). This rule, while convenient and simple, is going to make mistakes. For example, how many sentences are in this text?</p>
</div>
<div class="readable-text" id="p76">
<blockquote class="calibre2">
<div class="readable-text">
     I had at that time just entered the family of Mrs. Cecil Forrester in the capacity of governess.
    </div>
</blockquote>
</div>
<div class="readable-text" id="p77">
<p class="calibre15">The answer is one. Our program, though, is going to pull out two sentences, not one. It’ll get tricked by the word <em class="calibre18">Mrs.</em>, which has a period at the end. If you continue with authorship identification past this chapter, you could work on making your rules more robust or, use sophisticated natural language processing (NLP) software to do even better. For our purposes, however, we’ll be content with this rule that sometimes gets sentences wrong because most of the time we’ll get them right. If we’re only wrong once in a while, the errors won’t have an appreciable effect on our metric.</p>
</div>
<div class="readable-text" id="p78">
<h4 class="readable-text-h3">Average sentence complexity</h4>
</div>
<div class="readable-text" id="p79">
<p class="calibre15">We’ll name the function for this task <code class="calibre25">average_sentence_complexity</code>. It will take the text of a sentence as a parameter and return a measure of the sentence complexity.</p>
</div>
<div class="readable-text" id="p80">
<p class="calibre15">As we discussed previously, we’re interested in quantifying sentence complexity using the number of phrases in a sentence. Much as we used punctuation to separate sentences from each other, we’ll use different punctuation to separate phrases from each other. Namely, we’ll say that a phrase is separated by a comma (,), semicolon (;), or colon (:).</p>
</div>
<div class="readable-text" id="p81">
<p class="calibre15">It would be nice to have a subtask to break a sentence into its phrases, just like we had a subtask to break text into its sentences. Let’s make that happen! We’ll call the function for that subtask <code class="calibre25">get_phrases</code>. The <code class="calibre25">get_phrases</code> function will take a sentence of the book as a parameter and return a list of phrases from the sentence.</p>
</div>
<div class="readable-text" id="p82">
<p class="calibre15">Let’s pause for a moment and think about what we’re doing with our <code class="calibre25">get_sentences</code> and <code class="calibre25">get_phrases</code> functions. They’re both quite similar, come to think of it. All that distinguishes them is the characters that they use to make the splits. <code class="calibre25">get_sentences</code> cares about periods, question marks, and exclamation points, whereas <code class="calibre25">get_phrases</code> cares about commas, semicolons, and colons. We see an opportunity for a parent task that would simplify both of these tasks!</p>
</div>
<div class="readable-text" id="p83">
<p class="calibre15">Namely, imagine that we had a <code class="calibre25">split_string</code> function that took two parameters, the text and a string of separator characters, and it returned a list of pieces of text separated by any of the separators. We could then call it with <code class="calibre25">'.?!'</code> to split into sentences and <code class="calibre25">',;:'</code> to split into phrases. That would make both <code class="calibre25">get_sentences</code> and <code class="calibre25">get_phrases</code> easier to implement and reduce code duplication. This is a win!</p>
</div>
<div class="readable-text" id="p84">
<p class="calibre15">At this point, we’ve fully fleshed out the functions necessary to support the higher-level function <code class="calibre25">make_signature</code>, as reflected in figure 11.4. We’ll next turn to the <code class="calibre25">get_all_signatures</code> function.<span/></p>
</div>
<div class="browsable-container" id="p85">
<img alt="figure" src="../Images/11-4.png" class="calibre94"/>
<h5 class="figure-container-h"><span>Figure 11.4</span> Functions diagram with all the supporting functions for the <code class="calibre25">make_signature</code> function complete</h5>
</div>
<div class="readable-text" id="p86">
<h4 class="readable-text-h3">Figuring out each known signature</h4>
</div>
<div class="readable-text" id="p87">
<p class="calibre15">We just worked hard to break down our <code class="calibre25">make_signature</code> function into five main tasks, one for each feature of our signatures. We designed that function to determine the unknown signature—the signature for the mystery text whose author we’re trying to identify.</p>
</div>
<div class="readable-text" id="p88">
<p class="calibre15">Our next task is to figure out the signature for each of the books for which we know the author. In the resources for this book, under the ch11 folder, you’ll find a directory called <code class="calibre25">known_authors</code>. In there, you’ll find several files, each named as an author. Each file contains a book written by that author. For example, if you open Arthur_Conan_Doyle.txt, you’ll find the text of the book <em class="calibre18">A Study in Scarlet</em> by Arthur Conan Doyle. We need to determine the signature for each of these files.</p>
</div>
<div class="readable-text" id="p89">
<p class="calibre15">Amazingly, we have far less work to do to solve this problem than it may seem. That’s because we can use that same <code class="calibre25">make_signature</code> function, the one we designed to determine the signature of the mystery book, to also determine the signature for any known book!</p>
</div>
<div class="readable-text" id="p90">
<p class="calibre15">We’ll name the function for this task <code class="calibre25">get_all_signatures</code>. It wouldn’t make sense for this function to take the text of one book as a parameter because it’s supposed to be able to get the signature for all of our known books. Rather, it will take a directory of known books as a parameter. Its behavior will be to loop through the files in that directory, calculating the signature for each one.</p>
</div>
<div class="readable-text" id="p91">
<p class="calibre15">We need the function to tell us which signature goes with which book. In other words, we need it to associate each book with its corresponding signature. This kind of association is precisely why Python has dictionaries! We’ll therefore have this function return a dictionary, where the keys are names of files, and the values are the corresponding signature. Our function diagram didn’t need any <em class="calibre18">new</em> functions to support the <code class="calibre25">get_all_signatures</code> function, so our updated diagram in figure 11.5 just shows how <code class="calibre25">get_all_signatures</code> calls <code class="calibre25">make_signature</code>.<span/></p>
</div>
<div class="browsable-container" id="p92">
<img alt="figure" src="../Images/11-5.png" class="calibre94"/>
<h5 class="figure-container-h"><span>Figure 11.5</span> Functions diagram updated for <code class="calibre25">get_all_signatures</code> to call <code class="calibre25">make_signature</code></h5>
</div>
<div class="readable-text" id="p93">
<h4 class="readable-text-h3">Finding closest known signature</h4>
</div>
<div class="readable-text" id="p94">
<p class="calibre15">Let’s recap what we’ve designed so far:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p95"> We’ve designed our <code class="calibre25">make_signature</code> function to get us the unknown signature for the mystery book. </li>
<li class="readable-text1" id="p96"> We’ve designed our <code class="calibre25">get_all_signatures</code> function to get us all of our known signatures. </li>
</ul>
<div class="readable-text" id="p97">
<p class="calibre15">Now, we need to design a function that tells us which of those known signatures is best; that is, which known signature is closest to our unknown signature. Each of our signatures will be a list of five numbers giving the quantity for each of our five features. The order of these numbers will be the same order we used before: average word length, different words divided by total words, words used exactly once divided by total words, average number of words per sentence, and average sentence complexity.</p>
</div>
<div class="readable-text" id="p98">
<p class="calibre15">Suppose that we have two signatures. The first one is <code class="calibre25">[4.6,</code> <code class="calibre25">0.1,</code> <code class="calibre25">0.05,</code> <code class="calibre25">10,</code> <code class="calibre25">2]</code>which means that the average word length for that book is 4.6, the different words divided by total words is 0.1, and so on. The second signature is <code class="calibre25">[4.3,</code> <code class="calibre25">0.1,</code> <code class="calibre25">0.04,</code> <code class="calibre25">16,</code> <code class="calibre25">4]</code>.</p>
</div>
<div class="readable-text" id="p99">
<p class="calibre15">There are many ways to get an overall score giving the difference between signatures. The one we’ll use will give us a difference score for each feature, and then we’ll add up those scores to get our overall score.</p>
</div>
<div class="readable-text" id="p100">
<p class="calibre15">Let’s look at the values of each signature for the first feature: 4.6 and 4.3. If we subtract those, we get a difference of 4.6 – 4.3 = 0.3. We could use 0.3 as our answer for this feature, but it turns out to work better if we <em class="calibre18">weight </em>each difference using a different weight. Each weight gives the importance of that feature. We’ll use some weights<em class="calibre18"> </em>(<code class="calibre25">[11,</code> <code class="calibre25">33,</code> <code class="calibre25">50,</code> <code class="calibre25">0.4,</code> <code class="calibre25">4]</code>) that in our experience have proven to work well. You might wonder where the heck these weights come from. But note that there’s no magic about them: in working with our students over the years, we’ve just found that these weights seem to work out. This would be only a starting point for a stronger authorship identification program. When doing this type of research, people routinely <em class="calibre18">tune </em>their training, which means to adjust weights to obtain stronger results.</p>
</div>
<div class="readable-text" id="p101">
<p class="calibre15">When we say that we’re using weights of <code class="calibre25">[11,</code> <code class="calibre25">33,</code> <code class="calibre25">50,</code> <code class="calibre25">0.4,</code> <code class="calibre25">4]</code>, it means that we’ll multiply the difference on the first feature by 11, the difference on the second feature by 33, and so on. So, rather than getting a difference of 0.3 for the first feature, we’ll get 0.3 × 11 = 3.3.</p>
</div>
<div class="readable-text" id="p102">
<p class="calibre15">We need to be careful with features like the fourth one, where the difference is negative. We don’t want to start with 10 – 16 = –6 because that’s a negative number, and that would <em class="calibre18">undo </em>some of the positive difference from other features. Instead, we need to first make this number positive and then multiply it by its weight. Removing the negative sign from a number is known as taking the absolute value, and the absolute value is denoted as <code class="calibre25">abs</code>. The full calculation for this fourth feature, then, is abs(10 – 16) × 0.4 = 2.4.</p>
</div>
<div class="readable-text" id="p103">
<p class="calibre15">Table 11.1 gives the calculation for each feature. If we add up all five scores, we get an overall score of 14.2.</p>
</div>
<div class="browsable-container" id="p104">
<h5 class="browsable-container-h"><span>Table 11.1</span> Calculating the difference between two signatures</h5>
<table class="calibre36">
<thead class="calibre37">
<tr class="calibre38">
<th class="calibre39">
<div class="readable-text">
         Feature Number 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Value of Feature in Signature 1 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Value of Feature in Signature 2 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Weight of Feature 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Contribution of Feature 
       </div></th>
</tr>
</thead>
<tbody class="calibre40">
<tr class="calibre38">
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  4.6 <br class="calibre1"/></td>
<td class="calibre41">  4.3 <br class="calibre1"/></td>
<td class="calibre41">  11 <br class="calibre1"/></td>
<td class="calibre41">  abs(4.6 – 4.3) × 11 = 3.3 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  2 <br class="calibre1"/></td>
<td class="calibre41">  0.1 <br class="calibre1"/></td>
<td class="calibre41">  0.1 <br class="calibre1"/></td>
<td class="calibre41">  33 <br class="calibre1"/></td>
<td class="calibre41">  abs(0.1 – 0.1) × 33 = 0 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  3 <br class="calibre1"/></td>
<td class="calibre41">  0.05 <br class="calibre1"/></td>
<td class="calibre41">  0.04 <br class="calibre1"/></td>
<td class="calibre41">  50 <br class="calibre1"/></td>
<td class="calibre41">  abs(0.05 – 0.04) × 50 = .5 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  4 <br class="calibre1"/></td>
<td class="calibre41">  10 <br class="calibre1"/></td>
<td class="calibre41">  16 <br class="calibre1"/></td>
<td class="calibre41">  0.4 <br class="calibre1"/></td>
<td class="calibre41">  abs(10 – 16) × 0.4 = 2.4 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  5 <br class="calibre1"/></td>
<td class="calibre41">  2 <br class="calibre1"/></td>
<td class="calibre41">  4 <br class="calibre1"/></td>
<td class="calibre41">  4 <br class="calibre1"/></td>
<td class="calibre41">  abs(2 – 4) × 4 = 8 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Sum <br class="calibre1"/></td>
<td class="calibre41"/>
<td class="calibre41"/>
<td class="calibre41"/>
<td class="calibre41">  14.2 <br class="calibre1"/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p105">
<p class="calibre15">Remember where we are in the top-down design: we need a function that tells us which known signature is best. Well, now we know how to compare two signatures and get the score for that comparison. We’ll want to make that comparison between the unknown signature and each known signature to determine which known signature is best. The lower the score, the closer the signatures; the higher the score, the more different the signatures are. As such, we’ll want to ultimately choose the signature with the lowest comparison score.</p>
</div>
<div class="readable-text" id="p106">
<p class="calibre15">We’ll name the function for this task <code class="calibre25">lowest_score</code>. It will take three parameters: a dictionary mapping author names to their known signatures, an unknown signature, and a list of weights. The function will return the signature that has the lowest comparison score with our unknown signature.</p>
</div>
<div class="readable-text" id="p107">
<p class="calibre15">Think about the work that this function will need to do. It needs to loop through the known signatures. We can do that with a <code class="calibre25">for</code> loop—no need for a subtask there. It will need to compare the unknown signature to the current known signature. Oh! That’s a subtask right there, embodying the scoring mechanism that we outlined in table 11.1. We’ll name the function for that subtask <code class="calibre25">get_score</code>. Our <code class="calibre25">get_score</code> function will take two signatures to compare and the list of weights and return the score for the comparison between these two signatures.</p>
</div>
<div class="readable-text" id="p108">
<h2 class="readable-text-h1" id="sigil_toc_id_165"><span class="calibre22">11.4</span> Summary of our top-down design</h2>
</div>
<div class="readable-text" id="p109">
<p class="calibre15">We did it! We’ve broken down our original big problem into several smaller problems that are amenable to being implemented as a function.</p>
</div>
<div class="readable-text" id="p110">
<p class="calibre15">Figure 11.6 depicts all the work that we’ve done during the process of decomposing the problem. Remember, we started with a <code class="calibre25">make_guess</code> function, which will solve the overall problem. To help us with <code class="calibre25">make_guess</code>, we created a <code class="calibre25">process_data</code> function that will do some of the work for <code class="calibre25">make_guess</code>. To help <code class="calibre25">process_data</code>, we created three more functions, <code class="calibre25">make_signature</code>, <code class="calibre25">get_all_signatures</code>, and <code class="calibre25">lowest_score</code>, that each have their own helper functions, and so forth. Having sketched out the functions we’ll need to solve our problem, our next step will be to implement them. <span/></p>
</div>
<div class="browsable-container" id="p111">
<img alt="figure" src="../Images/11-6.png" class="calibre94"/>
<h5 class="figure-container-h"><span>Figure 11.6</span> Full functions diagram for <code class="calibre25">make_guess</code></h5>
</div>
<div class="readable-text" id="p112">
<h2 class="readable-text-h1" id="sigil_toc_id_166"><span class="calibre22">11.5</span> Implementing our functions</h2>
</div>
<div class="readable-text" id="p113">
<p class="calibre15">Now we’re ready to ask Copilot to implement each function that we need. We designed our functions by starting from the top—the biggest problem—and working down to smaller problems. But remember from chapter 7 that this isn’t the order that we implement the functions; instead, we implement the functions in the opposite order, from bottom to top (or right to left in figure 11.6). </p>
</div>
<div class="readable-text" id="p114">
<p class="calibre15">Just as in our example in chapter 7, we’re not going to focus much on testing, prompt engineering, debugging, or code reading. We do encourage you to run doctest on the docstring tests that we’ve provided, and further encourage you to add additional tests for each function. </p>
</div>
<div class="readable-text" id="p115">
<h3 class="readable-text-h2" id="sigil_toc_id_167"><span class="calibre22">11.5.1</span> clean_word</h3>
</div>
<div class="readable-text" id="p116">
<p class="calibre15">We’ll start with our <code class="calibre25">clean_word</code> function. As usual, we provide the function header (the <code class="calibre25">def</code> line) and docstring, and we let Copilot fill in the code. We also provide some annotations to briefly illustrate how the code works. </p>
</div>
<div class="readable-text" id="p117">
<p class="calibre15">Remember that we want our <code class="calibre25">clean_word</code> function to remove punctuation that might show up around the word and to convert the word to lowercase. But we don’t want to mess with punctuation in the middle of the word, such as the “-” in <em class="calibre18">card-board</em>. We’ve written the docstring to make clear what we want.</p>
</div>
<div class="browsable-container" id="p118">
<h5 class="listing-container-h"><span>Listing 11.1</span> Clean words for analysis </h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def clean_word(word):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word is a string.</strong>

<strong class="calibre17">    Return a version of word in which all letters have been</strong>
<strong class="calibre17">    converted to lowercase, and punctuation characters have been</strong>
<strong class="calibre17">    stripped from both ends. Inner punctuation is left untouched.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; clean_word('Pearl!')</strong>
<strong class="calibre17">    'pearl'</strong>
<strong class="calibre17">    &gt;&gt;&gt; clean_word('card-board')</strong>
<strong class="calibre17">    'card-board'</strong>
<strong class="calibre17">    '''</strong>
    word = word.lower()               <span/> #1
    word = word.strip(string.punctuation)  <span/> #2
    return word</pre>
<div class="code-annotations-overlay-container">
     #1 Converts the word to lowercase
     <br class="calibre1"/>#2 Uses the string module to strip punctuation from ends
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p119">
<p class="calibre15">When working on our password functions in chapter 3, we saw Copilot using the string module, and we see Copilot doing that again here. We know from our work in chapter 3 that this won’t work unless we import string first, so add</p>
</div>
<div class="browsable-container" id="p120">
<div class="readable-text">
<pre class="code-area">import string</pre>
</div>
</div>
<div class="readable-text" id="p121">
<p class="calibre15">above this function as we’ve done in the following listing.</p>
</div>
<div class="browsable-container" id="p122">
<h5 class="listing-container-h"><span>Listing 11.2</span> Clean words for analysis, complete</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import string</strong>
<strong class="calibre17">def clean_word(word):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word is a string.</strong>

<strong class="calibre17">    Return a version of word in which all letters have been</strong>
<strong class="calibre17">    converted to lowercase, and punctuation characters have </strong>
<strong class="calibre17">    been stripped from both ends. Inner punctuation is left</strong>
<strong class="calibre17">    untouched.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; clean_word('Pearl!')</strong>
<strong class="calibre17">    'pearl'</strong>
<strong class="calibre17">    &gt;&gt;&gt; clean_word('card-board')</strong>
<strong class="calibre17">    'card-board'</strong>
<strong class="calibre17">    '''</strong>
    word = word.lower() 
    word = word.strip(string.punctuation) 
    return word</pre>
</div>
</div>
<div class="readable-text" id="p123">
<p class="calibre15">This completes the <code class="calibre25">clean_word</code> function, so we can mark this as complete in our functions diagram in figure 11.7.<span/></p>
</div>
<div class="browsable-container" id="p124">
<img alt="figure" src="../Images/11-7.png" class="calibre94"/>
<h5 class="figure-container-h"><span>Figure 11.7</span> Full functions diagram with <code class="calibre25">clean_word</code> now finished</h5>
</div>
<div class="readable-text" id="p125">
<h3 class="readable-text-h2" id="sigil_toc_id_168"><span class="calibre22">11.5.2</span> average_word_length</h3>
</div>
<div class="readable-text" id="p126">
<p class="calibre15">Now let’s tackle the first of our five signature feature functions: <code class="calibre25">average_word_length</code>. It needs to determine the average number of letters per word, but we don’t want to count surrounding punctuation as letters nor include words that don’t have any letters. We want to use our <code class="calibre25">clean_word</code> function here, as shown in the following listing. As always, we’ve written the docstring in a way that we hope directs Copilot to make these decisions. </p>
</div>
<div class="browsable-container" id="p127">
<h5 class="listing-container-h"><span>Listing 11.3</span> Average word length </h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def average_word_length(text):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    text is a string of text.</strong>

<strong class="calibre17">    Return the average word length of the words in text.</strong>
<strong class="calibre17">    Do not count empty words as words.</strong>
<strong class="calibre17">    Do not include surrounding punctuation.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; average_word_length('A pearl! Pearl! Lustrous pearl! \</strong>
<strong class="calibre17">Rare. What a nice find.')</strong>
<strong class="calibre17">    4.1</strong>
<strong class="calibre17">    '''</strong>
    words = text.split()       <span/> #1
    total = 0                     <span/> #2
    count = 0               <span/> #3
    for word in words:       <span/> #4
        word = clean_word(word)      <span/> #5
        if word != '':             <span/> #6
            total += len(word)    <span/> #7
            count += 1           <span/> #8
    return total / count       <span/> #9</pre>
<div class="code-annotations-overlay-container">
     #1 Splits string into its words
     <br class="calibre1"/>#2 total will count the total number of letters across all words. 
     <br class="calibre1"/>#3 count will count the number of words.
     <br class="calibre1"/>#4 Loops through each word
     <br class="calibre1"/>#5 Copilot calls clean_word for us!
     <br class="calibre1"/>#6 Considers this word only if it isn’t empty
     <br class="calibre1"/>#7 Adds number of letters in word
     <br class="calibre1"/>#8 Adds 1 to count this word
     <br class="calibre1"/>#9 Returns number of letters divided by number of words
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p128">
<p class="calibre15">You’ll notice in the doctest here that we’ve split our string over two lines, ending the first line with a \ character. The reason we did this is that the string wouldn’t otherwise fit on one line in the book. We also needed to keep the second line without any indentation; otherwise, doctest would use that indentation as spaces in the string. On your computer, you can type the string on a single line and not worry about the \ or lack of indentation.</p>
</div>
<div class="readable-text" id="p129">
<p class="calibre15">We can now mark <code class="calibre25">average_word_length</code> as done in our updated figure (figure 11.8). Although satisfying, marking these off in the figure one by one might be a bit too much noise, so we’ll revisit the figure only periodically going forward.<span/></p>
</div>
<div class="browsable-container" id="p130">
<img alt="figure" src="../Images/11-8.png" class="calibre95"/>
<h5 class="figure-container-h"><span>Figure 11.8</span> Full functions diagram with <code class="calibre25">average_word_length</code> now finished</h5>
</div>
<div class="readable-text" id="p131">
<h3 class="readable-text-h2" id="sigil_toc_id_169"><span class="calibre22">11.5.3</span> different_to_total</h3>
</div>
<div class="readable-text" id="p132">
<p class="calibre15">This is the second of our signature features. We need this one to calculate the number of different words used divided by the total number of words. Again, we don’t want surrounding punctuation or empty words. </p>
</div>
<div class="browsable-container" id="p133">
<h5 class="listing-container-h"><span>Listing 11.4</span> Different words divided by total number of words </h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def different_to_total(text):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    text is a string of text.</strong>

<strong class="calibre17">    Return the number of unique words in text</strong>
<strong class="calibre17">    divided by the total number of words in text.</strong>
<strong class="calibre17">    Do not count empty words as words.</strong>
<strong class="calibre17">    Do not include surrounding punctuation.</strong>
<strong class="calibre17">    &gt;&gt;&gt; different_to_total('A pearl! Pearl! Lustrous pearl! \</strong>
<strong class="calibre17">Rare. What a nice find.')</strong>
<strong class="calibre17">    0.7</strong>
<strong class="calibre17">    '''</strong>
    words = text.split()    <span/> #1
    total = 0                    <span/> #2
    unique = set()              <span/> #3
    for word in words:
        word = clean_word(word)    <span/> #4
        if word != '':
            total += 1
            unique.add(word)     <span/> #5
    return len(unique) / total     <span/> #6</pre>
<div class="code-annotations-overlay-container">
     #1 Splits string into its words
     <br class="calibre1"/>#2 total will count the total number of nonempty words. 
     <br class="calibre1"/>#3 A set of the unique words found
     <br class="calibre1"/>#4 Copilot again calls clean_word for us!
     <br class="calibre1"/>#5 A set is like a list but doesn’t accept duplicates.
     <br class="calibre1"/>#6 Returns the number of different words divided by total number of words
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p134">
<p class="calibre15">This code uses a Python set, rather than a Python list, to store the unique words that it finds. A set is similar to a list except that it doesn’t accept duplicates, so if you try to add the same word multiple times, it retains only one copy of the word. That’s why we can use <code class="calibre25">len(unique)</code> in the return statement to get the total number of unique words.</p>
</div>
<div class="readable-text" id="p135">
<p class="calibre15">We don’t need to know any more about Python sets to continue here. But if you’re interested in learning more, you can ask Copilot for a code explanation and/or do a Google search for information on Python sets. </p>
</div>
<div class="readable-text" id="p136">
<h3 class="readable-text-h2" id="sigil_toc_id_170"><span class="calibre22">11.5.4</span> exactly_once_to_total</h3>
</div>
<div class="readable-text" id="p137">
<p class="calibre15">We’re ready to implement our third signature feature. This one calculates the number of words used exactly once divided by the total number of words, as shown in the following listing. We provided the prompt to Copilot and received the following function.</p>
</div>
<div class="browsable-container" id="p138">
<h5 class="listing-container-h"><span>Listing 11.5</span> Fraction of words used just once: Try 1</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def exactly_once_to_total(text):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    text is a string of text.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return the number of words that show up exactly once in text</strong>
<strong class="calibre17">    divided by the total number of words in text.</strong>
<strong class="calibre17">    Do not count empty words as words.</strong>
<strong class="calibre17">    Do not include surrounding punctuation.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; exactly_once_to_total('A pearl! Pearl! Lustrous pearl! \</strong>
<strong class="calibre17">Rare. What a nice find.')</strong>
<strong class="calibre17">    0.5</strong>
<strong class="calibre17">    '''</strong>
    words = text.split()
    unique = set()
    total = 0
    for word in words:
        word = clean_word(word)
        if word != '':
            if word not in unique:
                unique.add(word)
            else:
                unique.remove(word)  <span/> #1
            total += 1
    return len(unique) / total</pre>
<div class="code-annotations-overlay-container">
     #1 Removing a word from the unique set?
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p139">
<p class="calibre15">When we skim that code, it looks like <code class="calibre25">unique</code> is a set that keeps track of the unique words. At the end, we divide that number of unique words by the total number of words.</p>
</div>
<div class="readable-text" id="p140">
<p class="calibre15">However, run our test case using doctest, and you’ll see that our code fails the test. We need the result to be 0.5, but our code is unfortunately giving us 0.6. Our code is wrong. We need to stay vigilant!</p>
</div>
<div class="readable-text" id="p141">
<p class="calibre15">Let’s review the code to see why it was wrong. Imagine that a word is used three times in a text. The first time our code finds it, the code will add it to <code class="calibre25">unique</code>. The second time, it will <em class="calibre18">remove </em>it from <code class="calibre25">unique</code>. That’s fine so far because the word isn’t being used exactly once anymore, so it shouldn’t be in there. But then the third time, it will add that word back to<em class="calibre18"> </em><code class="calibre25">unique</code>! So, our code is going to count some words as being used exactly once when in fact they were used more than once. We looked through the list that appears when you press Ctrl-Enter and found this alternate version, which is correct, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p142">
<h5 class="listing-container-h"><span>Listing 11.6</span> Fraction of words used just once: Try 2</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def exactly_once_to_total(text):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    text is a string of text.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return the number of words that show up exactly once in text</strong>
<strong class="calibre17">    divided by the total number of words in text.</strong>
<strong class="calibre17">    Do not count empty words as words.</strong>
<strong class="calibre17">    Do not include surrounding punctuation.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; exactly_once_to_total('A pearl! Pearl! Lustrous pearl! \</strong>
<strong class="calibre17">Rare. What a nice find.')</strong>
<strong class="calibre17">    0.5</strong>
<strong class="calibre17">    '''</strong>
    words = text.split()
    total = 0
    unique = set()            <span/> #1
    once = set()            <span/> #2
    for word in words:
        word = clean_word(word)
        if word != '':
            total += 1
            if word in unique:    <span/> #3
                once.discard(word)    <span/> #4
            else:
                unique.add(word)    <span/> #5
                once.add(word)       <span/> #6
    return len(once) / total       <span/> #7</pre>
<div class="code-annotations-overlay-container">
     #1 Keeps track of all words we’ve seen
     <br class="calibre1"/>#2 Keeps track of words used exactly once—what we ultimately care about
     <br class="calibre1"/>#3 We’re seeing the word again.
     <br class="calibre1"/>#4 So the word has to be removed from once.
     <br class="calibre1"/>#5 We’ve now seen this word.
     <br class="calibre1"/>#6 So far, the word is used exactly once.
     <br class="calibre1"/>#7 Returns the number of words used exactly once divided by the total number of words
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p143">
<p class="calibre15">This code is tricky! To understand it, start by focusing on the <code class="calibre25">else</code> code. That’s the code that runs the first time we see each word. That word gets added to both the <code class="calibre25">unique</code> and <code class="calibre25">once</code> sets. It’s the <code class="calibre25">once</code> set that’s going to keep track for us of the words used exactly once.</p>
</div>
<div class="readable-text" id="p144">
<p class="calibre15">Now imagine that we see a word for a second time. The <code class="calibre25">if</code> code is going to run when this happens because the word is already in <code class="calibre25">unique</code> (we added it there the first time we saw this word). Now, because we’ve seen the word more than once, we need it gone from the <code class="calibre25">once</code> set. That’s exactly what the <code class="calibre25">if</code> code does: it uses <code class="calibre25">once.discard(word)</code> to remove the word from <code class="calibre25">once</code>.</p>
</div>
<div class="readable-text" id="p145">
<p class="calibre15">To summarize, the first time we see a word, it gets added to <code class="calibre25">once</code>. When we see it again, it gets removed from <code class="calibre25">once</code> with no way to ever have that word added back to <code class="calibre25">once</code>. The <code class="calibre25">once</code> set is correctly tracking the words used exactly once.</p>
</div>
<div class="readable-text" id="p146">
<h3 class="readable-text-h2" id="sigil_toc_id_171"><span class="calibre22">11.5.5</span> split_string</h3>
</div>
<div class="readable-text" id="p147">
<p class="calibre15">We’ve finished our three word-level signature feature functions. Before we can move on to our two sentence-level signature feature functions, we need to write <code class="calibre25">get_ sentences</code>. But to write <code class="calibre25">get_sentences</code>, we first need <code class="calibre25">split_string</code>, which is what we’ll work on now.</p>
</div>
<div class="readable-text" id="p148">
<p class="calibre15">Our <code class="calibre25">split_string</code> function is supposed to be able to split a string around any number of separators. It inherently has nothing to do with sentences or phrases. We’ve included one docstring test to highlight this fact: even though we’re going to use it to split sentences and phrases, it’s more general than that. Look at the following listing.</p>
</div>
<div class="browsable-container" id="p149">
<h5 class="listing-container-h"><span>Listing 11.7</span> Split a string around separators </h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def split_string(text, separators):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    text is a string of text.</strong>
<strong class="calibre17">    separators is a string of separator characters.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Split the text into a list using any of the one-character</strong>
<strong class="calibre17">    separators and return the result.</strong>
<strong class="calibre17">    Remove spaces from beginning and end</strong>
<strong class="calibre17">    of a string before adding it to the list.</strong>
<strong class="calibre17">    Do not include empty strings in the list.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; split_string('one*two[three', '*[')</strong>
<strong class="calibre17">    ['one', 'two', 'three']</strong>
<strong class="calibre17">    &gt;&gt;&gt; split_string('A pearl! Pearl! Lustrous pearl! Rare. \</strong>
<strong class="calibre17">What a nice find.', '.?!')    </strong>
<strong class="calibre17">    ['A pearl', 'Pearl', 'Lustrous pearl', 'Rare', \</strong>
<strong class="calibre17">'What a nice find']</strong>
<strong class="calibre17">    '''</strong>
    words = []       <span/> #1
    word = ''            <strong class="calibre17">   </strong><span/><strong class="calibre17"/> #2
    for char in text:
        if char in separators:   <span/> #3
            word = word.strip()     <span/> #4
            if word != '':         <span/> #5
                words.append(word)     <span/> #6
            word = ''                <span/> #7
        else:
            word += char          <span/> #8
    word = word.strip()     <span/> #9
    if word != '':          <strong class="calibre17"/>
        words.append(word)  <strong class="calibre17"/> #9
    return words #9</pre>
<div class="code-annotations-overlay-container">
     #1 A better variable name would be all_strings. 
     <br class="calibre1"/>#2 A better variable name would be current_string.
     <br class="calibre1"/>#3 Current string ends here. 
     <br class="calibre1"/>#4 Removes any space from beginning and end of current string
     <br class="calibre1"/>#5 If the current string isn’t empty . . . 
     <br class="calibre1"/>#6 . . . saves this as one of the split strings.
     <br class="calibre1"/>#7 Clears the current string to get ready for the next one
     <br class="calibre1"/>#8 Adds to the current string (don’t split yet)
     <br class="calibre1"/>#9 Handles the final split string by adding if not empty
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p150">
<p class="calibre15">You might be curious about the code after the <code class="calibre25">for</code> loop and before the <code class="calibre25">return</code> statement. It seems to be duplicating some of the code from within the <code class="calibre25">for</code> loop, so what’s it doing there? This code is there because the loop only adds a split string to our list of strings when it finds one of the separator characters. If the text doesn’t end with a separator character, the loop won’t add the final split string. The code below the loop ensures that this final split string isn’t lost.</p>
</div>
<div class="readable-text" id="p151">
<p class="calibre15">It’s been a little while since we updated our diagram with functions we’ve completed. Time for an update! This also serves as a reminder that we’re finishing functions from the bottom up (right-to-left in the diagram). As such, figure 11.9 has our functions completed so far.<span/></p>
</div>
<div class="browsable-container" id="p152">
<img alt="figure" src="../Images/11-9.png" class="calibre95"/>
<h5 class="figure-container-h"><span>Figure 11.9</span> Full functions diagram updated with <code class="calibre25">different_to_total</code>, <code class="calibre25">exactly_once_to_total</code>, and <code class="calibre25">split_string</code> now finished</h5>
</div>
<div class="readable-text" id="p153">
<h3 class="readable-text-h2" id="sigil_toc_id_172"><span class="calibre22">11.5.6</span> get_sentences</h3>
</div>
<div class="readable-text" id="p154">
<p class="calibre15">In our top-down design, we kicked most of the work for <code class="calibre25">get_sentences</code> off to the <code class="calibre25">split_string</code> function. Therefore, what we’re hoping for is that Copilot implements <code class="calibre25">get_sentences</code> by making a suitable call to <code class="calibre25">split_string</code>.</p>
</div>
<div class="readable-text" id="p155">
<p class="calibre15">We don’t want our sentences to have any space at the beginning or end, and we don’t want any empty sentences. We initially had these requirements in the docstring, but even without them Copilot correctly calls <code class="calibre25">split_string</code>, and that function handles these edge cases anyway.</p>
</div>
<div class="browsable-container" id="p156">
<h5 class="listing-container-h"><span>Listing 11.8</span> Return list of sentences in text</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def get_sentences(text):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    text is a string of text.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return a list of the sentences from text.</strong>
<strong class="calibre17">    Sentences are separated by a '.', '?' or '!'.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; get_sentences('A pearl! Pearl! Lustrous pearl! Rare. \</strong>
<strong class="calibre17">What a nice find.')</strong>
<strong class="calibre17">    ['A pearl', 'Pearl', 'Lustrous pearl', 'Rare', \</strong>
<strong class="calibre17">'What a nice find']</strong>
<strong class="calibre17">    '''</strong>
    return split_string(text, '.?!')    <span/> #1</pre>
<div class="code-annotations-overlay-container">
     #1 Calls split_string with the sentence separator characters
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p157">
<h3 class="readable-text-h2" id="sigil_toc_id_173"><span class="calibre22">11.5.7</span> average_sentence_length</h3>
</div>
<div class="readable-text" id="p158">
<p class="calibre15">Now that we have <code class="calibre25">get_sentences</code>, we can proceed with <code class="calibre25">average_sentence_length</code>, our fourth signature feature. This one calculates the average number of words per sentence. We provided the prompt to Copilot and received the function shown in the following listing. </p>
</div>
<div class="browsable-container" id="p159">
<h5 class="listing-container-h"><span>Listing 11.9</span> Average number of words per sentence</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def average_sentence_length(text):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    text is a string of text.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return the average number of words per sentence in text.</strong>
<strong class="calibre17">    Do not count empty words as words.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; average_sentence_length('A pearl! Pearl! Lustrous pearl! \</strong>
<strong class="calibre17">Rare. What a nice find.')</strong>
<strong class="calibre17">    2.0</strong>
<strong class="calibre17">    '''</strong>
    sentences = get_sentences(text)   <span/> #1
    total = 0
    for sentence in sentences:       <span/> #2
        words = sentence.split()    <span/> #3
        for word in words:      <span/> #4
            if word != '':
                total += 1
    return total / len(sentences)    <span/> #5</pre>
<div class="code-annotations-overlay-container">
     #1 Gets a list of sentences
     <br class="calibre1"/>#2 Loops through the sentences
     <br class="calibre1"/>#3 Breaks current sentence into its words
     <br class="calibre1"/>#4 Loops through sentence’s words
     <br class="calibre1"/>#5 Returns number of words divided by number of sentences
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p160">
<h3 class="readable-text-h2" id="sigil_toc_id_174"><span class="calibre22">11.5.8</span> get_phrases</h3>
</div>
<div class="readable-text" id="p161">
<p class="calibre15">Much liked we needed <code class="calibre25">get_sentences</code> before we could implement <code class="calibre25">average_sentence_ length</code>, we need <code class="calibre25">get_phrases</code> before we can implement <code class="calibre25">average_sentence_complexity</code>.</p>
</div>
<div class="readable-text" id="p162">
<p class="calibre15">As with <code class="calibre25">get_sentences</code>, we expect Copilot to call <code class="calibre25">split_string</code> to get the phrases. That is what it has done for us here, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p163">
<h5 class="listing-container-h"><span>Listing 11.10</span> Return list of phrases from a sentence</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def get_phrases(sentence):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    sentence is a sentence string.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return a list of the phrases from sentence.</strong>
<strong class="calibre17">    Phrases are separated by a ',', ';' or ':'.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; get_phrases('Lustrous pearl, Rare, What a nice find')</strong>
<strong class="calibre17">    ['Lustrous pearl', 'Rare', 'What a nice find']</strong>
<strong class="calibre17">    '''</strong>
    return split_string(sentence, ',;:')   <span/> #1</pre>
<div class="code-annotations-overlay-container">
     #1 Calls split_string with the phrase separator characters
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p164">
<h3 class="readable-text-h2" id="sigil_toc_id_175"><span class="calibre22">11.5.9</span> average_sentence_complexity</h3>
</div>
<div class="readable-text" id="p165">
<p class="calibre15">With <code class="calibre25">get_phrases</code> completed, we can now prompt for an implementation of <code class="calibre25">average_ sentence_complexity</code>. The code is shown in the following listing.</p>
</div>
<div class="browsable-container" id="p166">
<h5 class="listing-container-h"><span>Listing 11.11</span> Average number of phrases per sentence</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def average_sentence_complexity(text):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    text is a string of text.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return the average number of phrases per sentence in text.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; average_sentence_complexity('A pearl! Pearl! Lustrous \</strong>
<strong class="calibre17">pearl! Rare. What a nice find.')</strong>
<strong class="calibre17">    1.0</strong>
<strong class="calibre17">    &gt;&gt;&gt; average_sentence_complexity('A pearl! Pearl! Lustrous \</strong>
<strong class="calibre17">pearl! Rare, what a nice find.')</strong>
<strong class="calibre17">    1.25                           </strong><span/><strong class="calibre17"/> #1
<strong class="calibre17">    '''</strong>
    sentences = get_sentences(text)    <span/> #2
    total = 0
    for sentence in sentences:              <span/> #3
        phrases = get_phrases(sentence)      <span/> #4
        total += len(phrases)            <span/> #5
    return total / len(sentences)     <span/> #6</pre>
<div class="code-annotations-overlay-container">
     #1 We changed a period to a comma to make this 5/4 = 1.25.
     <br class="calibre1"/>#2 Gets a list of sentences
     <br class="calibre1"/>#3 Loops through the sentences
     <br class="calibre1"/>#4 Gets a list of phrases in the current sentence
     <br class="calibre1"/>#5 Adds the number of phrases in the current sentence
     <br class="calibre1"/>#6 Returns the number of phrases divided by the number of sentences
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p167">
<p class="calibre15">We’re really coming along now! We’ve finished all the functions needed to create <code class="calibre25">make_signature</code>, as shown in figure 11.10.<span/></p>
</div>
<div class="browsable-container" id="p168">
<img alt="figure" src="../Images/11-10.png" class="calibre95"/>
<h5 class="figure-container-h"><span>Figure 11.10</span> Full functions diagram updated to show that we’re now ready to write <code class="calibre25">make_signature</code></h5>
</div>
<div class="readable-text" id="p169">
<h3 class="readable-text-h2" id="sigil_toc_id_176"><span class="calibre22">11.5.10</span> make_signature</h3>
</div>
<div class="readable-text" id="p170">
<p class="calibre15">We’ve written nine functions to this point, and while they’re all important, we may feel a little unsatisfied right now because we’re not even dealing with text signatures yet. We’ve got some functions that clean words, split strings in various ways, and calculate individual features of signatures, but no function to make a full signature.</p>
</div>
<div class="readable-text" id="p171">
<p class="calibre15">That changes now because we’re finally ready to implement <code class="calibre25">make_signature</code> to give us the signature for a text. This function will take the text of a book and return a list of five numbers, each of which is the result of calling one of our five feature functions.</p>
</div>
<div class="browsable-container" id="p172">
<h5 class="listing-container-h"><span>Listing 11.12</span> Numeric signature for the text</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def make_signature(text):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    The signature for text is a list of five elements:</strong>
<strong class="calibre17">    average word length, different words divided by total words, </strong>
<strong class="calibre17">    words used exactly once divided by total words,</strong>
<strong class="calibre17">    average sentence length, and average sentence complexity.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return the signature for text.    </strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; make_signature('A pearl! Pearl! Lustrous pearl! \</strong>
<strong class="calibre17">Rare, what a nice find.')</strong>
<strong class="calibre17">    [4.1, 0.7, 0.5, 2.5, 1.25]</strong>
<strong class="calibre17">    '''</strong>
    return [average_word_length(text),           <span/> #1
            different_to_total(text),            <strong class="calibre17"/> #1
            exactly_once_to_total(text),         <strong class="calibre17"/> #1
            average_sentence_length(text),        #1
            average_sentence_complexity(text)]   <strong class="calibre17"/> #1</pre>
<div class="code-annotations-overlay-container">
     #1 Each of our five feature functions is called.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p173">
<p class="calibre15">Notice that this function can be implemented as nothing more than a call to each of our five feature functions. It’s important to pause now to think about just how messy this function would have been without having done a solid top-down design first. The code for all five of the functions that we’re calling here would have had to be in a single function, with all of their own variables and calculations mingled together into a real mess. Lucky for us, we’re using top-down design! Our function is therefore easier for us to read and easier to convince ourselves that it’s doing the right thing. </p>
</div>
<div class="readable-text" id="p174">
<h3 class="readable-text-h2" id="sigil_toc_id_177"><span class="calibre22">11.5.11</span> get_all_signatures </h3>
</div>
<div class="readable-text" id="p175">
<p class="calibre15">Our <code class="calibre25">process_data</code> function has three subtasks for us to implement. We just finished with the first one (<code class="calibre25">make_signature</code>), so now we’ll move on to its second subtask, which is our <code class="calibre25">get_all_signatures</code> function.</p>
</div>
<div class="readable-text" id="p176">
<p class="calibre15">From now on, we’ll assume that your working directory has your code and that it also has the subdirectory of books that we’ve provided. We need this function to return the signature for each file in our directory of known authors. We’re hoping for Copilot to call <code class="calibre25">make_signature</code> here to make this function far simpler than it otherwise would be.</p>
</div>
<div class="readable-text" id="p177">
<p class="calibre15">Copilot did do that for us, but the code we got still had two problems. Our initial code is shown in the following listing.</p>
</div>
<div class="browsable-container" id="p178">
<h5 class="listing-container-h"><span>Listing 11.13</span> Obtain all signatures from known authors: Try 1</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def get_all_signatures(known_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    known_dir is the name of a directory of books.</strong>
<strong class="calibre17">    For each file in directory known_dir, determine its signature.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return a dictionary where each key is</strong>
<strong class="calibre17">    the name of a file, and the value is its signature.</strong>
<strong class="calibre17">    '''</strong>
    signatures = {}                                <span/> #1
    for filename in os.listdir(known_dir):            <span/> #2
        with open(os.path.join(known_dir,          <span/> #3
                               filename)) as f:    <strong class="calibre17"/> #3
            text = f.read()                           <span/> #4
            signatures[filename] = make_signature(text)  <span/> #5
    return signatures</pre>
<div class="code-annotations-overlay-container">
     #1 Our dictionary, initially empty, maps filenames to signatures.
     <br class="calibre1"/>#2 Loops through each file in the known authors directory
     <br class="calibre1"/>#3 Opens the current file
     <br class="calibre1"/>#4 Reads all text from the file
     <br class="calibre1"/>#5 Makes the signature for text and stores it in the dictionary
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p179">
<p class="calibre15">Try running this function from the Python prompt as</p>
</div>
<div class="browsable-container" id="p180">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; get_all_signatures('known_authors')</pre>
</div>
</div>
<div class="readable-text" id="p181">
<p class="calibre15">and you’ll get the following error:</p>
</div>
<div class="browsable-container" id="p182">
<div class="readable-text">
<pre class="code-area">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\repos\book_code\ch11\authorship.py", line 207, 
  in get_all_signatures
    for filename in os.listdir(known_dir):
                    ^^
NameError: name 'os' is not defined</pre>
</div>
</div>
<div class="readable-text" id="p183">
<p class="calibre15">The error is telling us that the function is trying to use a module named os, but we don’t have this module available. This module is built-in to Python, and we know what to do in this case: import it! That is, we need to add</p>
</div>
<div class="browsable-container" id="p184">
<div class="readable-text">
<pre class="code-area">import os</pre>
</div>
</div>
<div class="readable-text" id="p185">
<p class="calibre15">above this function. After that, we still get an error:</p>
</div>
<div class="browsable-container" id="p186">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; get_all_signatures('known_authors')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\repos\book_code\ch11\authorship.py", line 209, 
  in get_all_signatures
    text = f.read()
           ^^^^^^^^
  File "…\Lib\encodings\cp1252.py", line 23, in decode
    return codecs.charmap_decode(input,self.errors,decoding_table)[0]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
UnicodeDecodeError: 'charmap' codec can't decode byte 0x9d in 
position 2913: character maps to &lt;undefined&gt;</pre>
</div>
</div>
<div class="readable-text" id="p187">
<p class="calibre15">You might be wondering what a <code class="calibre25">UnicodeDecodeError</code> is. You could google it or ask ChatGPT if you’re interested in a technical explanation. What we need to know is that each file that we open is encoded in a specific way, and Python has chosen the wrong encoding to try to read this file.</p>
</div>
<div class="readable-text" id="p188">
<p class="calibre15">We can, however, direct Copilot to fix it by adding a comment near the top of our function. (When you encounter errors like these, you can try placing a comment directly above the erroneous code that was generated. Then, once you delete the incorrect code, Copilot can often generate new code that is correct.) Once we do that, all is well, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p189">
<h5 class="listing-container-h"><span>Listing 11.14</span> Obtain all signatures from known authors: Try 2</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import os</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">def get_all_signatures(known_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    known_dir is the name of a directory of books.</strong>
<strong class="calibre17">    For each file in directory known_dir, determine its signature.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return a dictionary where each key is</strong>
<strong class="calibre17">    the name of a file, and the value is its signature.</strong>
<strong class="calibre17">    '''</strong>
    signatures = {}
<strong class="calibre17">    # Fix UnicodeDecodeError                          </strong><span/><strong class="calibre17"/> #1
    for filename in os.listdir(known_dir):
        with open(os.path.join(known_dir, filename), 
                  encoding='utf-8') as f:
            text = f.read()
            signatures[filename] = make_signature(text)
    return signatures</pre>
<div class="code-annotations-overlay-container">
     #1 This prompt tells Copilot to fix the error we saw previously.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p190">
<p class="calibre15">Now, if you run this function, you should see a dictionary of authors and their signatures, like this:</p>
</div>
<div class="browsable-container" id="p191">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; get_all_signatures('known_authors')
{'Arthur_Conan_Doyle.txt': [4.3745884086670195, 
0.1547122890234636, 0.09005503235165442, 
15.48943661971831, 2.082394366197183], 
'Charles_Dickens.txt': [4.229579999566339, 
0.0796743207788547, 0.041821158307855766, 
17.286386709736963, 2.698477157360406], 
'Frances_Hodgson_Burnett.txt': [4.230464334694739, 
0.08356818832607418, 0.04201769324672584, 
13.881251286272896, 1.9267338958633464], 
'Jane_Austen.txt': [4.492473405509028, 
0.06848572461149259, 0.03249477538065084, 
17.507478923035084, 2.607560511286375], 
'Mark_Twain.txt': [4.372851190055795, 
0.1350377851543188, 0.07780210466840878, 
14.395167731629392, 2.16194089456869]}</pre>
</div>
</div>
<div class="readable-text" id="p192">
<p class="calibre15">For simplicity, we haven’t added a test in the docstring for this function. If we did, however, we would create a fake, small book, along the lines of what we did in our second example in chapter 6. We’d like to proceed here with our overall purpose of function decomposition, though, so we’ll leave that exercise to you if you’d like to pursue that. As shown in figure 11.11, we’ve gotten two <code class="calibre25">process_data</code> subtasks out of the way. Let’s keep going!<span/></p>
</div>
<div class="browsable-container" id="p193">
<img alt="figure" src="../Images/11-11.png" class="calibre95"/>
<h5 class="figure-container-h"><span>Figure 11.11</span> Full functions diagram updated to show that <code class="calibre25">make_signature</code> and <code class="calibre25">get_all_signatures</code> are finished</h5>
</div>
<div class="readable-text" id="p194">
<h3 class="readable-text-h2" id="sigil_toc_id_178"><span class="calibre22">11.5.12</span> get_score</h3>
</div>
<div class="readable-text" id="p195">
<p class="calibre15">Let’s implement <code class="calibre25">get_score</code>, where we need to encode the way that we compare signatures. Remember the whole thing where we find the difference on each feature, multiply it by a weight, and then add everything together into an overall score? That’s what we want <code class="calibre25">get_score</code> to do. </p>
</div>
<div class="readable-text" id="p196">
<p class="calibre15">It would be a challenge to explain this formula in the docstring. And we’re not even sure that it should go there: a docstring is supposed to explain how someone can use your function, not how it works internally. And, arguably, users of our function won’t care about this specific formula anyway. What we can do is use a general docstring, without our specific formula, and see what Copilot does with it. Here we go in the following listing.</p>
</div>
<div class="browsable-container" id="p197">
<h5 class="listing-container-h"><span>Listing 11.15</span> Compare two signatures</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def get_score(signature1, signature2, weights):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    signature1 and signature2 are signatures.</strong>
<strong class="calibre17">    weights is a list of five weights.</strong>
<strong class="calibre17">        </strong>
<strong class="calibre17">    Return the score for signature1 and signature2.</strong>
<strong class="calibre17">        </strong>
<strong class="calibre17">    &gt;&gt;&gt; get_score([4.6, 0.1, 0.05, 10, 2],\</strong>
<strong class="calibre17">                  [4.3, 0.1, 0.04, 16, 4],\</strong>
<strong class="calibre17">                  [11, 33, 50, 0.4, 4])      </strong><span/><strong class="calibre17"/> #1
<strong class="calibre17">    14.2</strong>
<strong class="calibre17">    '''</strong>
    score = 0
    for i in range(len(signature1)):               <span/> #2
        score += abs(signature1[i] - signature2[i]) \  <span/> #3
                 * weights[i]                           #3
    return score</pre>
<div class="code-annotations-overlay-container">
     #1 These weights, [11, 33, 50, 0.4, 4], worked well for us.
     <br class="calibre1"/>#2 Loops through each signature index
     <br class="calibre1"/>#3 Adds the weighted difference to score
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p198">
<p class="calibre15">Copilot has implemented exactly the formula that we wanted. Now, before we start thinking that Copilot mind-melded us or anything like that, remember that the formula we’ve used here is a very common metric for comparing signatures. Many students and other programmers over the years have implemented authorship identification using this very formula. Copilot is just giving that back to us because it occurs so often in its training data. If Copilot happened to give us a different formula, we could have tried to describe what we want in a comment or, failing that, changed the code ourselves to get what we want.</p>
</div>
<div class="readable-text" id="p199">
<h3 class="readable-text-h2" id="sigil_toc_id_179"><span class="calibre22">11.5.13</span> lowest_score</h3>
</div>
<div class="readable-text" id="p200">
<p class="calibre15">Our <code class="calibre25">lowest_score</code> function will finally wrap up everything we need to implement <code class="calibre25">process_data</code>. The <code class="calibre25">get_score</code> function that we just implemented gives us the score between any two signatures. Our <code class="calibre25">lowest_score</code> function is going to call <code class="calibre25">get_score</code> once for each known signature to compare the unknown signature to each known signature. It will then return the known signature that has the lowest score with the unknown signature, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p201">
<h5 class="listing-container-h"><span>Listing 11.16</span> Closest known signature </h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def lowest_score(signatures_dict, unknown_signature, weights):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    signatures_dict is a dictionary mapping keys to signatures.</strong>
<strong class="calibre17">    unknown_signature is a signature.</strong>
<strong class="calibre17">    weights is a list of five weights.</strong>
<strong class="calibre17">    Return the key whose signature value has the lowest </strong>
<strong class="calibre17">    score with unknown_signature.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; d = {'Dan': [1, 1, 1, 1, 1],\     </strong><span/><strong class="calibre17"/> #1
<strong class="calibre17">             'Leo': [3, 3, 3, 3, 3]}      </strong> #1
<strong class="calibre17">    &gt;&gt;&gt; unknown = [1, 0.8, 0.9, 1.3, 1.4]</strong>
<strong class="calibre17">    &gt;&gt;&gt; weights = [11, 33, 50, 0.4, 4]</strong>
<strong class="calibre17">    &gt;&gt;&gt; lowest_score(d, unknown, weights)    </strong><span/><strong class="calibre17"/> #2
<strong class="calibre17">    'Dan'</strong>
<strong class="calibre17">    '''</strong>
    lowest = None
    for key in signatures_dict:          <strong class="calibre17">              </strong><span/><strong class="calibre17"/> #3
        score = get_score(signatures_dict[key],          <span/> #4
                          unknown_signature, weights) <strong class="calibre17">   </strong>
        if lowest is None or score &lt; lowest[1]:     <span/> #5
            lowest = (key, score)      <span/> #6
    return lowest[0]  <span/> #7</pre>
<div class="code-annotations-overlay-container">
     #1 Using variables in the doctest to make the test itself easier to read
     <br class="calibre1"/>#2 This line is easier to read because we’re using our variables.
     <br class="calibre1"/>#3 Loops through each author name
     <br class="calibre1"/>#4 Gets a score for comparing this known signature to the unknown signature
     <br class="calibre1"/>#5 If this is the first comparison or we’ve found a lower score . . . 
     <br class="calibre1"/>#6 . . . this stores both the best key and score for that key.
     <br class="calibre1"/>#7 lowest[0] is the best key.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p202">
<p class="calibre15">The first parameter, <code class="calibre25">signatures_dict</code>, is a dictionary that maps names of authors to their known signatures. That will ultimately come from the <code class="calibre25">get_all_signatures</code> function. The second parameter, <code class="calibre25">unknown_signature</code>, will ultimately come from calling <code class="calibre25">make_signature</code> on the mystery book. The third parameter, <code class="calibre25">weights</code>, will be hard-coded by us when we call this function.</p>
</div>
<div class="readable-text" id="p203">
<h3 class="readable-text-h2" id="sigil_toc_id_180"><span class="calibre22">11.5.14</span> process_data</h3>
</div>
<div class="readable-text" id="p204">
<p class="calibre15">Only two functions to go! One of them is <code class="calibre25">process_data</code>—it feels like it took us forever, but we’re finally ready for it. </p>
</div>
<div class="readable-text" id="p205">
<p class="calibre15">Our <code class="calibre25">process_data</code> function is going to take two parameters in the following listing: the filename of a mystery book and the directory of known-author books. It will return the author that we think wrote the mystery book.</p>
</div>
<div class="browsable-container" id="p206">
<h5 class="listing-container-h"><span>Listing 11.17</span> Signature closest to the mystery author</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def process_data(mystery_filename, known_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    mystery_filename is the filename of a mystery book whose </strong>
<strong class="calibre17">                     author we want to know.</strong>
<strong class="calibre17">    known_dir is the name of a directory of books.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return the name of the signature closest to </strong>
<strong class="calibre17">    the signature of the text of mystery_filename.</strong>
<strong class="calibre17">    '''</strong>
    signatures = get_all_signatures(known_dir)          <span/> #1
    with open(mystery_filename, encoding='utf-8') as f:   <span/> #2
        text = f.read()                               <span/> #3
        unknown_signature = make_signature(text)        <span/> #4
    return lowest_score(signatures, unknown_signature,   <span/> #5
                        [11, 33, 50, 0.4, 4])             #5</pre>
<div class="code-annotations-overlay-container">
     #1 Gets all the known signatures
     <br class="calibre1"/>#2 Copilot uses our prior work to get the encoding right this time. 
     <br class="calibre1"/>#3 Reads text of the mystery book
     <br class="calibre1"/>#4 Gets the unknown signature
     <br class="calibre1"/>#5 Returns the signature with the lowest comparison score
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p207">
<p class="calibre15">Again, notice how much we’re relying on our earlier functions. This massively useful <code class="calibre25">process_data</code> function is now really nothing more than a carefully sequenced list of function calls.</p>
</div>
<div class="readable-text" id="p208">
<p class="calibre15">In the book resources for this chapter, we’ve included a few unknown author files, for example, unknown1.txt and unknown2.txt. Those should be in your current working directory along with your code (and the subdirectory of known author files).</p>
</div>
<div class="readable-text" id="p209">
<p class="calibre15">Let’s call <code class="calibre25">process_data</code> to guess who wrote <code class="calibre25">'unknown1.txt'</code>:</p>
</div>
<div class="browsable-container" id="p210">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; process_data('unknown1.txt', 'known_authors')
'Arthur_Conan_Doyle.txt'</pre>
</div>
</div>
<div class="readable-text" id="p211">
<p class="calibre15">Our program guesses that Arthur Conan Doyle wrote unknown1.txt. And if you peek at the text of unknown1.txt by opening the file, you’ll see that our guess is right. The book is called <em class="calibre18">The Sign of the Four</em>, which is a well-known Arthur Conan Doyle book.</p>
</div>
<div class="readable-text" id="p212">
<h3 class="readable-text-h2" id="sigil_toc_id_181"><span class="calibre22">11.5.15</span> make_guess</h3>
</div>
<div class="readable-text" id="p213">
<p class="calibre15">To guess the author of a book, we currently need to type the Python code to run <code class="calibre25">process_data</code>. That’s not very friendly to users; it would be nice if we could run the program and have it ask us which mystery book file we want to work with.</p>
</div>
<div class="readable-text" id="p214">
<p class="calibre15">We’ll put that finishing touch on our program by implementing <code class="calibre25">make_guess</code>, our top-most function! This function will ask the user for a filename of a mystery book, get the best guess using <code class="calibre25">process_data</code>, and tell the user about that guess, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p215">
<h5 class="listing-container-h"><span>Listing 11.18</span> Interacts with user and guesses text’s author</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def make_guess(known_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    Ask user for a filename.</strong>
<strong class="calibre17">    Get all known signatures from known_dir,</strong>
<strong class="calibre17">    and print the name of the one that has the lowest score </strong>
<strong class="calibre17">    with the user's filename.</strong>
<strong class="calibre17">    '''</strong>
    filename = input('Enter filename: ')      <span/> #1
    print(process_data(filename, known_dir))    <span/> #2</pre>
<div class="code-annotations-overlay-container">
     #1 Asks the user for the filename of the mystery book
     <br class="calibre1"/>#2 Calls process_data to do all the work and report our guess
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p216">
<p class="calibre15">This completes all the functions from our diagram! Figure 11.12 shows that we’ve checked off every function from the bottom to the very top of our diagram.<span/></p>
</div>
<div class="browsable-container" id="p217">
<img alt="figure" src="../Images/11-12.png" class="calibre95"/>
<h5 class="figure-container-h"><span>Figure 11.12</span> All the required functions for <code class="calibre25">make_guess</code> are now complete!</h5>
</div>
<div class="readable-text" id="p218">
<p class="calibre15">If you have all of our code in your Python file, you’ll be able to run it to guess the author of a mystery book after you add the following line of code at the bottom of that file:</p>
</div>
<div class="browsable-container" id="p219">
<div class="readable-text">
<pre class="code-area">make_guess('known_authors')</pre>
</div>
</div>
<div class="readable-text" id="p220">
<p class="calibre15">For example, here’s what happens when we run our program and type <code class="calibre25">unknown1.txt</code> as the unknown book:</p>
</div>
<div class="browsable-container" id="p221">
<div class="readable-text">
<pre class="code-area">Enter filename: unknown1.txt       
Arthur_Conan_Doyle.txt</pre>
</div>
</div>
<div class="readable-text" id="p222">
<p class="calibre15">It correctly tells us that unknown1.txt is written by Arthur Conan Doyle! Try running it for each of the other unknown book files that we’ve provided. How many of those does it guess correctly? Which ones does it get wrong?</p>
</div>
<div class="readable-text" id="p223">
<p class="calibre15">Congratulations! You’ve completed your first real-world top-down design. And look at what we’ve managed to accomplish—an authorship identification program that any beginning programmer should be proud of. Your program uses AI to learn how individual authors write (do they use shorter or longer words on average, shorter or longer sentences on average, etc.?) by using the text of books in its training data. It then applies that learning to make a prediction on a mystery book by determining which author the mystery book most closely emulates—very cool! We managed to solve a very difficult problem, and we did it by breaking down the problem and letting Copilot write the code for each of the subproblems.</p>
</div>
<div class="readable-text" id="p224">
<h2 class="readable-text-h1" id="sigil_toc_id_182"><span class="calibre22">11.6</span> Going further</h2>
</div>
<div class="readable-text" id="p225">
<p class="calibre15">After people do a top-down design, they often see opportunities to refactor their code, which means making the code cleaner or better organized without changing its behavior. It’s possible to refactor our program in several ways. For example, you might notice that many of our signature feature functions split the string into words and then ignore empty words. This task (returning a list of nonempty words from a string) could be split off into its own subtask function, which would further simplify any function that calls it.</p>
</div>
<div class="readable-text" id="p226">
<p class="calibre15">We might also decide that weights should be passed to <code class="calibre25">process_data</code>, rather than hard-coding the weights in that function. The weights would then be hard-coded in <code class="calibre25">make_guess</code>, moving the decision higher in the function hierarchy and therefore making it easier to find and change if needed.</p>
</div>
<div class="readable-text" id="p227">
<p class="calibre15">It’s also possible to improve the program in terms of its features or efficiency. For features, right now, our program simply prints its best guess for the mystery book author. But we don’t know anything about that guess. Was there a second author that was very close to the one that was guessed? If so, we might want to know that. More generally, we might want to know the top few guesses rather than just the top guess. That way, we have useful information about who the author might be even if the top guess happens to be wrong. These are additional features that we could add to our program.</p>
</div>
<div class="readable-text" id="p228">
<p class="calibre15">For efficiency, let’s think about that <code class="calibre25">get_all_signatures</code> function again. That function does a lot of work! If we have five books in our known directory, then it will read each of the five files and calculate each signature. Big deal, right? It’s only five files, and computers are really fast. But imagine if we had 100 files or 10,000 files. It may be acceptable to do all that work as a one-time-only thing, but that’s not what our program does. In fact, every time we run the program to get a guess for the author of a mystery book, it runs that <code class="calibre25">get_all_signatures</code> function, which means re-creating those signatures every single time. That’s a huge amount of wasted effort; it would be nice if we could just store those signatures somewhere, never having to calculate them again. Indeed, if we were to redesign the code for efficiency, a first step would be to ensure that the signature for a known text is only computed once and reused thereafter.</p>
</div>
<div class="readable-text" id="p229">
<p class="calibre15">That’s exactly what tools like Copilot do! OpenAI trained GitHub Copilot just once on a huge corpus of code. That took thousands or millions of computer hours. But now that the training is done, it can keep writing code for us without having to train from scratch every time. The idea of doing the training once and then using that training for many subsequent predictions is a common paradigm throughout all of ML.</p>
</div>
<div class="readable-text" id="p230">
<h2 class="readable-text-h1" id="sigil_toc_id_183"><span class="calibre22">11.7</span> Exercises</h2>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p231"> Which of the following isn’t a step in the AI-based authorship identification process described in this chapter? 
    <ol class="calibre48">
<li class="calibre30"> Calculating the average word length of the mystery book </li>
<li class="calibre30"> Comparing the mystery book’s signature to known signatures </li>
<li class="calibre30"> Asking the user for the filename of the mystery book </li>
<li class="calibre30"> Finding the total number of pages in the mystery book </li>
</ol></li>
<li class="readable-text1" id="p232"> Build a classifier that can distinguish between spam and non-spam (ham) emails based on email content. Use features like word frequency, presence of certain keywords, and email length. Here are the steps you’ll need to take: 
    <ol class="calibre48">
<li class="calibre30"> Collect a dataset of spam and non-spam emails. You can find publicly available datasets online, such as the Enron spam dataset. </li>
<li class="calibre30"> Preprocess the emails (remove stop words, punctuation, etc.). </li>
<li class="calibre30"> Extract features (e.g., word counts, presence of certain words). </li>
<li class="calibre30"> Train a classifier using our labeled data (supervised learning). A simple and effective choice for the classifier is the Naïve Bayes classifier (feel free to use a Python library to help you). </li>
<li class="calibre30"> Test the classifier with a separate set of emails to check its accuracy. </li>
</ol></li>
<li class="readable-text1" id="p233"> In this exercise, you’ll create a simple text generation program using n-grams. N-grams are contiguous sequences of <em class="calibre18">n</em> items from a given sample of text or speech. You’ll use these n-grams to generate new text that mimics the style of the input text. The key idea is to build a model that is trained to know which words commonly follow other words (i.e., “cat eats” makes sense, “tissue eats” does not) and then, among the possible choices, randomly select the next one. Feel free to look up n-grams for more information. Here are the steps you’ll need to take: 
    <ol class="calibre48">
<li class="calibre30"> Choose input text that you can load into Python. You can use something like: “Pride and Prejudice” by Jane Austen. </li>
<li class="calibre30"> Preprocess the text by converting it to lowercase and removing punctuation. </li>
<li class="calibre30"> Create n-grams from the input text. An n-gram is a contiguous sequence of <em class="calibre18">n</em> items from a given text. For simplicity, we’ll use bigrams (<em class="calibre18">n</em> = 2) in this example. </li>
<li class="calibre30"> Use the generated n-grams to produce new text. Start with a random n-gram, and keep adding new words based on the n-gram model until the desired length is reached. </li>
</ol></li>
</ol>
<div class="readable-text" id="p234">
<h2 class="readable-text-h1" id="sigil_toc_id_184">Summary</h2>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p235"> Top-down design becomes more and more critical as the complexity of our programs increase. </li>
<li class="readable-text1" id="p236"> Author identification is the process of guessing the author of a mystery book. </li>
<li class="readable-text1" id="p237"> We can use features about words (e.g., average word length) and sentences (e.g., average number of words per sentence) to characterize how each known author writes. </li>
<li class="readable-text1" id="p238"> Machine learning is an important area of computer science that investigates how machines can learn from data and make predictions. </li>
<li class="readable-text1" id="p239"> In supervised learning, we have some training data in the form of objects (e.g., books) and their categories (who wrote each book). We can learn from that data to make predictions about new objects. </li>
<li class="readable-text1" id="p240"> A signature consists of a list of features, one signature per object. </li>
<li class="readable-text1" id="p241"> Refactoring code means to improve the design of the code (e.g., by reducing code repetition). </li>
</ul>
</div></body></html>