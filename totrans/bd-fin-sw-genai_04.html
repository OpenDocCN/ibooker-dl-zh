<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">3</span> </span><span class="chapter-title-text">Getting started with Docker</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header"><span class="CharOverride-2">This chapter covers</span><span class="CharOverride-2"/></h3>
<ul>
<li class="readable-text" id="p2"><span class="CharOverride-3">Creating containers for our project components using Docker and Docker Compose</span></li>
<li class="readable-text" id="p3"><span class="CharOverride-3">Optimizing Docker containers and images for enhanced security and maintenance</span></li>
<li class="readable-text" id="p4"><span class="CharOverride-3">Implementing general Docker maintenance to ensure our containers and images do not eat up disk space</span></li>
<li class="readable-text" id="p5"><span class="CharOverride-3">Using health checks to ensure the system is up and running</span></li>
</ul>
</div>
<div class="readable-text" id="p6">
<p>In the last chapter (or sprint, if we are thinking in Agile terms), we created a functional (albeit basic) ACH parser. We also experimented with generative AI tools to help us work faster and more efficiently. We have made some progress exploring tools and getting our bearing with ACH processing. Enjoy that feeling because there will surely be days when we log off the computer feeling completely drained.</p>
</div>
<div class="readable-text intended-text" id="p7">
<p>At this point, we have been given project requirements and a general framework of what a final project should contain. Of course, there are different approaches that we might take when working on a project, each having its pros and cons. While we may end up favoring one approach over others, there are always factors to consider when tackling a project, such as</p>
</div>
<ul>
<li class="readable-text" id="p8">How does the size and complexity of the project compare to our team’s experience and knowledge?</li>
<li class="readable-text" id="p9">Have the project requirements been well defined, or is the business/customer still feeling the project out? How do the requirements compare to the time allotted for the project?</li>
<li class="readable-text" id="p10">What is our risk tolerance for items such as bugs, delays, new technologies, and similar?</li>
<li class="readable-text" id="p11">Do we have existing infrastructure for the project, such as testing environments and automated builds? If not, will we need to factor in building that infrastructure, or will that come later?</li>
</ul>
<div class="readable-text" id="p12">
<p>While the previous points may seem more pertinent when having more of a leadership role (technical lead, architect, etc.), it is beneficial to have everyone thinking about them because different perspectives are always useful. We just need to be careful that our feedback comes across as constructive and not as an attack on our co-workers (and we should be careful about when it is obvious any feedback will be ignored). Let us get back to our project at hand. </p>
</div>
<div class="readable-text" id="p13">
<h2 class="readable-text-h2"><span class="num-string">3.1</span> Where to begin</h2>
</div>
<div class="readable-text" id="p14">
<p>First, you may not have any choice in what you are able to work on. The business needs may dictate that you work on these pieces in this order. However, assuming you have a choice on where to start, what would you pick? You could start with a piece that you are comfortable with—perhaps you are a strong Python programmer, so you want to finish working on the ACH parser.</p>
</div>
<div class="readable-text intended-text" id="p15">
<p>Or, maybe you should pick the thing you know the least. Maybe you have never worked with Next.js before, and you want to ensure you have enough time to devote to that part because you feel the other pieces won’t take much time. </p>
</div>
<div class="readable-text intended-text" id="p16">
<p>We like to get started with the whole project! Well, not the whole project, but we like to see if we can get all the pieces talking to each other in some form. Even if it is the equivalent of a bunch of “Hello, World!” programs and components, at least we have the pieces together, and then we can pick them up, start building them, and let them evolve. It is really up to you—you could just as easily jump around to other chapters and get the various components up and running. This chapter focuses on getting a Docker setup and then putting our basic project components in place. Subsequent chapters will build on these components, but for now, we want to create an environment that looks similar to the one in figure 3.1.</p>
</div>
<div class="readable-text" id="p17">
<p>As you can see, this environment will provide us with a UI container running Node and Next.js, an API container powered by FastAPI, and a database container running PostgreSQL. Running these inside Docker also allows the introduction of other </p>
</div>
<div class="browsable-container figure-container" id="p18">
<img alt="A diagram of a computer program  Description automatically generated" height="695" src="../Images/CH03_F01_Kardell.png" style="width: 100%; max-width: max-content;" width="859"/>
<h5 class="figure-container-h5"><span class="">Figure 3.1</span><span class=""> </span><span class="">An overview of our ACH system</span></h5>
</div>
<div class="readable-text" id="p19">
<p>components that we will explore in other chapters. While this project takes a more service-oriented approach to architecture, this general approach of using Docker to break our software down paves the way for other architecture patterns. The goal is not to make you an expert in Docker (check out <em>Docker in Action</em> [2019, Manning] by Jeff Nickoloff and Stephen Kuenzli if you want to become an expert) but rather to show you how to use it to explore different technologies and software without having to install and configure it on a host machine. It really helps you stay more organized.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p20">
<h5 class="callout-container-h5 readable-text-h5">Is the monolith dead?</h5>
</div>
<div class="readable-text" id="p21">
<p>Since we are using containers, and you may have heard about Microservices and how they are the latest and greatest, you might be tempted to run back to your company looking for any monolithic software and start insisting that they are doing it wrong. We would advise against that. Just because something is new does not necessarily mean it is better. Monolithic architecture can have its drawbacks, but there is no silver bullet when it comes to technology. Change for the sake of change is not only unnecessary—it can be detrimental to the software. </p>
</div>
<div class="readable-text" id="p22">
<p>Therefore, we suggest that if it is not broken, do not fix it. If there is monolithic software running at your company, it may continue to run for long after you have left the company. Only after identifying problems with the architecture should you look for alternatives.</p>
</div>
<div class="readable-text" id="p23">
<p>Monolithic architecture can also be very useful in developing proof of concepts, as you can bundle and deploy everything in one easy package. We believe everything has its time and place, so while we encourage forward thinking and engineering, remember that part of Agile is looking to deliver the right product at the right time. It just may not be the right time to explore moving to containers.</p>
</div>
</div>
<div class="readable-text" id="p24">
<h2 class="readable-text-h2"><span class="num-string">3.2</span> Creating a docker-compose.yml file</h2>
</div>
<div class="readable-text" id="p25">
<p>If you have never worked with Docker before, you are in for a real treat. Docker allows us to create and distribute various containers. A container is sort of a mini-VM that you build in a declarative fashion and can be pulled in by others. If you are a Java programmer, think of your pom.xml and Maven, where you can basically describe your project and provide that file to someone else, so they can use it to have Maven pull the necessary files. Containers are similar, except they work on a larger scale. In figure 3.1, we showed a solution that has multiple containers running Nginx, FastAPI, and PostgreSQL. When working with a multicontainer application, we want to be able to manage everything from a centralized location, and that is where Docker Compose comes into play. We can declare a docker-compose.yml file and configure all the applications, containers, and services in one location.</p>
</div>
<div class="readable-text intended-text" id="p26">
<p>If you are new to Docker, you might try to use Copilot, but our attempt did not yield any meaningful results. We tried to use the following command with Copilot:</p>
</div>
<div class="callout-container sidebar-container prompt-response-sidebar">
<div class="browsable-container listing-container" id="p27">
<img alt="" class="_idGenObjectAttribute-2 prompt-head-image" height="32" src="../Images/Prompt-Icon.png" width="33"/>
<div class="code-area-container">
<pre class="code-area">	# Create a sample docker compose layout for Nginx, CloudBeaver,</pre>
</div>
</div>
</div>
<div class="readable-text" id="p28">
<p>The results of that prompt are shown in the following listing. Unfortunately, it did not produce any actual executable code.</p>
</div>
<div class="browsable-container listing-container" id="p29">
<h5 class="listing-container-h5 browsable-container-h5">Listing 3.1<span class="CharOverride-5"> </span>Failed attempt at a Docker setup</h5>
<div class="code-area-container">
<pre class="code-area"># Create a sample docker compose layout for 
<span class="CharOverride-6">➥</span> nginx, cloudbeaver, postgres, and fastapi
# This is a sample docker compose file for a fastapi project
# It is not meant to be used in production
# It is meant to be used as a starting point for a fastapi project</pre>
</div>
</div>
<div class="readable-text" id="p30">
<p>We had much better results asking ChatGPT directly, as shown in the next listing, as it provided an actual compose file.</p>
</div>
<div class="browsable-container listing-container" id="p31">
<h5 class="listing-container-h5 browsable-container-h5">Listing 3.2<span class="CharOverride-7"> </span>docker-compose.yml generated by ChatGPT</h5>
<div class="code-area-container">
<pre class="code-area">version: '3.7'   #1

services:
  nginx:
    image: nginx:latest
    container_name: nginx_container
    ports:
      - "80:80"
    volumes:
      - ./nginx:/etc/nginx/conf.d
    depends_on:
      - web

  web:
    build:
      context: .
      dockerfile: Dockerfile.fastapi    #2
    container_name: fastapi_container
    volumes:
      - ./app:/app
    expose:
      - "8000"
    depends_on:
      - db

  db:
    image: postgres:latest
    container_name: postgres_container
    <span>environment:</span>
<span>      POSTGRES_USER: user             </span>#3
<span>      POSTGRES_PASSWORD: password     </span> #3
<span>      POSTGRES_DB: sample_db          </span>
<span>    volumes:</span>
<span>      </span><span>- postgres_data:/var/lib/postgresql/data</span>

<span>  </span><span>cloudbeaver:</span>
<span>    image: cloudbeaver:latest</span>
<span>    container_name: cloudbeaver_container</span>
<span>    ports:</span>
<span>      </span>- "8080:8080"
    depends_on:
      - db

volumes:
  postgres_data:</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">The version tag is obsolete, but even 3.7 was outdated when ChatGPT provided this answer; this is an example of the need to verify responses.</span>
<br/>#2 
     <span class="CharOverride-8">ChatGPT gives us a nonstandard name of Dockerfile.fastapi; instead, we should use Dockerfile with no extension or fastapi.Dockerfile (see </span>
<a href="https://mng.bz/xKoB"><span class="CharOverride-8">https://mng</span></a>
<a href="https://mng.bz/xKoB"><span class="CharOverride-8">.bz/xKoB</span></a>
<span class="CharOverride-8">); this is another example of the need to verify responses.</span>
<br/>#3 
     <span class="CharOverride-8">These environment variables allow configuration for the Postgres database.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p32">
<p>These were good starts, but we need to back up a step so that we can break the code down and get something even shorter. Because we relied too heavily on generative AI, we started larger than we normally would, and that is a good lesson for us to take away. We spoke about the need for quick feedback loops and short cycles. It is never a good idea to change too much code in one session because when verifying our changes, we are unsure what actually addressed our problem. Therefore, asking generative AI to build four or five containers without a good understanding of what needs to happen was a bad idea.</p>
</div>
<div class="readable-text intended-text" id="p33">
<p>Now that we have gotten a dose of reality and taken a step back, let us pick a single container to get up and running. </p>
</div>
<div class="readable-text" id="p34">
<h3 class="readable-text-h3"><span class="num-string">3.2.1</span> Creating a CloudBeaver container</h3>
</div>
<div class="readable-text" id="p35">
<p>We will start by building out a CloudBeaver container. CloudBeaver is a database management tool that supports multiple databases through a simple web-based user interface. There is no shortage of database management interfaces. You may also want to check out pgAdmin (<a href="https://www.pgadmin.org/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/www.pgadmin.org/</span></a>) since we are working with a Postgres database or DataGrip by JetBrains (<a href="https://www.jetbrains.com/datagrip/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/www.jetbrains.com/datagrip/</span></a>) since we’ll be using other JetBrains IDEs in this project. We do not have any vested interest in any particular product but are hoping to share what we have seen in use in FinTech.</p>
</div>
<div class="readable-text intended-text" id="p36">
<p>We are installing CloudBeaver because we want another way to view and manage our database other than just using code. Your company probably has a preferred tool, and you can feel free to use it. However, CloudBeaver is simple to get up and running. </p>
</div>
<div class="readable-text intended-text" id="p37">
<p>So, why are we setting up a database management tool before our database? That is a good question. Because CloudBeaver is a web interface, we will be able to confirm the container is up and running simply by opening a browser and navigating to a URL. So, CloudBeaver provides a quick and simple way to get started and verify our progress. Another option is to use our IDE, as IDEs often provide integration (or a plugin) to browse the database. Of course, using our IDE gets away from Docker, and we are looking to explore different containers with Docker.</p>
</div>
<div class="readable-text intended-text" id="p38">
<p>With that in mind, let’s get started by prompting ChatGPT:</p>
</div>
<div class="readable-text prompt" id="p39">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Create just a basic Cloudbeaver service in Docker Compose.</p>
</div>
<div class="readable-text" id="p40">
<p>We receive the following output.</p>
</div>
<div class="browsable-container listing-container" id="p41">
<h5 class="listing-container-h5 browsable-container-h5">Listing 3.3<span class="CharOverride-5"> </span>Sample CloudBeaver container output from ChatGPT</h5>
<div class="code-area-container">
<pre class="code-area">version: '3.1'      #1
services:
  cloudbeaver:
    image: dbeaver/cloudbeaver:latest
    container_name: cloudbeaver
    ports:
      - "8080:8978"</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">The version tag is obsolete, but even 3.</span>
<span class="CharOverride-9">1</span>
<span class="CharOverride-8"> was outdated when ChatGPT provided this answer; this is an example of the need to verify ChatGPT responses.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p42">
<p>The output looks plausible, but we see the version number is <code>3.1</code>. The latest Docker compose version was <code>3.8</code>, but now the <code>version</code> tag has been marked as obsolete by the project. While we can still specify it for the time being, using it will show a warning message. If it were ever to become an error, that would certainly pose a problem. So, we tell ChatGPT:</p>
</div>
<div class="readable-text prompt" id="p43">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Update the basic setup to remove the Docker Compose version as it is now obsolete. </p>
</div>
<div class="readable-text" id="p44">
<p>With that, our file is updated. The ability to update output from our conversation is a powerful aspect of generative AI that we should keep in mind. Of course, we could have simply removed it from the produced file; however, we hope that our updated prompt will feed back into the system, and we will eventually stop getting the <code>version</code> tag as part of generated files.</p>
</div>
<div class="readable-text intended-text" id="p45">
<p>We can copy and paste the output from listing 3.3 into a docker-compose.yml file, navigate to the folder, and then issue the command <code>docker-compose</code> <code>up</code>. On our machine, it failed to do this because of the following error: </p>
</div>
<div class="browsable-container listing-container" id="p46">
<div class="code-area-container">
<pre class="code-area"><code>Bind for 0.0.0.0:8080 failed: port is already allocated</code><code> </code></pre>
</div>
</div>
<div class="readable-text" id="p47">
<p>This error is pretty straightforward, but remembering what you have running that might be using the port is not always straightforward. We could also update our docker-compose file to use a different port, but at this point, we can find the offending process on Windows PowerShell by using <code>netstat</code> <code>-aon</code> <code>|</code> <code>findstr</code> <code>"8080"</code> and then <code>tasklist</code> <code>|</code> <code>findstr</code> <code>PID</code> where PID are the process IDs that we just came across (which are on the right-hand side). Once you do that, you can either determine whether you want to shut down/stop whatever program you have running or adjust the port being used. In our case, another Docker container was being used, so it was safe to shut down. At this point, running <code>docker-compose</code> <code>up</code> works, and we can navigate to http://localhost:8080/ and see a web interface shown in figure 3.2.</p>
</div>
<div class="browsable-container figure-container" id="p48">
<img alt="A screenshot of a computer  Description automatically generated" height="375" src="../Images/CH03_F02_Kardell.png" style="width: 100%; max-width: max-content;" width="750"/>
<h5 class="figure-container-h5"><span class="">Figure 3.2</span><span class=""> </span><span class="">CloudBeaver welcome screen</span></h5>
</div>
<div class="readable-text" id="p49">
<h3 class="readable-text-h3"><span class="num-string">3.2.2</span> Create a PostgreSQL container</h3>
</div>
<div class="readable-text" id="p50">
<p>Things will get a little more interesting now because we get to add a database container. Eventually, the database will store our ACH files and associated data, but for now, we will keep things simple. We can also populate the database with data when the container starts, so that we can use CloudBeaver to connect to the database and view our data. We can ask ChatGPT to simply</p>
</div>
<div class="readable-text prompt" id="p51">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Update the docker-compose file to also include a <code>postgres</code> service.</p>
</div>
<div class="readable-text" id="p52">
<p>Again, that created a helpful starting point, shown in the next listing. </p>
</div>
<div class="browsable-container listing-container" id="p53">
<h5 class="listing-container-h5 browsable-container-h5">Listing 3.4<span class="CharOverride-5"> </span>Multiple containers generated by ChatGPT</h5>
<div class="code-area-container">
<pre class="code-area">version: '3.8'
services:
  cloudbeaver:
    image: dbeaver/cloudbeaver:latest
    container_name: cloudbeaver
    depends_on:
      - postgres
    ports:
      - "8080:8978"
    environment:
      - CB_DATABASE_URL=jdbc:postgresql://postgres:5432/postgres
      - CB_DATABASE_USERNAME=postgres
      - CB_DATABASE_PASSWORD=postgrespwd

  <span>postgres:</span>
<span>    image: postgres:latest</span>
<span>    container_name: postgres</span>
<span>    environment:</span>
<span>      POSTGRES_DB: postgres</span>
<span>      POSTGRES_USER: postgres</span>
<span>      </span>POSTGRES_PASSWORD: postgrespwd
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data</pre>
</div>
</div>
<div class="readable-text" id="p54">
<p>However, let’s take a step back and build a simpler file, which will serve us better at this time because we are still trying to adhere to the principle of YAGNI (“You aren’t going to need it”) as much as possible. Some purists might argue that even creating these Docker containers violates that principle. We do not strictly need any of this for our project at this point—we may not even need a database. Perhaps, we could get away with just writing to a file or keeping things in memory! That could certainly be true, but we could also look at this as the existing code because our application is built on PostgreSQL and so that is going to be a requirement regardless of whether we really need it.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p55">
<h5 class="callout-container-h5 readable-text-h5">What is YAGNI?</h5>
</div>
<div class="readable-text" id="p56">
<p>YAGNI is an acronym for “You aren’t going to need it.” It is a principle of extreme programming and ties back to our Agile principles, such as minimum viable product (MVP), by trying to enforce the idea of avoiding unnecessary work and complexity. Sometimes, when coding, it is hard to resist adding that extra function that you’re pretty sure you will need later, so you might as well code it now. Then, that code never gets used but is flagged by static code analysis for fixes and requires changes when you update some object.</p>
</div>
<div class="readable-text" id="p57">
<p>So, if nothing else, just keep the principle in mind to avoid that extra complexity.</p>
</div>
</div>
<div class="readable-text" id="p58">
<p>Let’s go back to building our container. We add a simple container with the following (you can view the whole file in the provided v2/docker folder on GitHub for this chapter):</p>
</div>
<div class="browsable-container listing-container" id="p59">
<div class="code-area-container">
<pre class="code-area">  <span>Postgres:</span>
<span>    image: postgres:latest</span>
<span>    environment:</span>
<span>      </span>POSTGRES_USER: admin
      POSTGRES_PASSWORD: secret</pre>
</div>
</div>
<div class="readable-text" id="p60">
<p>With this, we can navigate to CloudBeaver with http://localhost:8080 and set up a connection; however, we do not have any data to view. We want to be able to load some data when the container is built, so we will look into doing that now. Note that we removed the networking and volume fields from the generated Dockerfile because we are going to rely on the networking that is set up by Docker. By default, all the containers defined with our docker-compose file under services will be able to communicate with each other. Also, we are not interested in persisting data in this project (at least for now), so we removed the volumes tag. This gives us a simple starting point.</p>
</div>
<div class="readable-text intended-text" id="p61">
<p>To add some data, we will create a SQL script that executes when the container is first built. We start off by creating a <code>health_check</code> table. This table could be used to determine whether our application is in a valid state. For us, it is more of a “Hello, World!” scenario than anything meaningful.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p62">
<h5 class="callout-container-h5 readable-text-h5">Health checks</h5>
</div>
<div class="readable-text" id="p63">
<p>Because our application will be spread across a number of containers, it is often useful to create a health check. It is a common pattern to follow when using microservices. Even though we have started by initially creating a database table named <code>health_check</code>, this is just the beginning. </p>
</div>
<div class="readable-text" id="p64">
<p>Docker allows us to create a health check for the container within our setup, which we will explore later. This test can determine whether the container is “unhealthy.” When using a container orchestration tool such as Kubernetes, these health status checks can trigger alerts to admins, as well as automatically restart containers.</p>
</div>
<div class="readable-text" id="p65">
<p>Tools such as Kubernetes also have expanded these checks to differentiate between the app being unavailable because it is initializing and because something crashed. These are referred to as “readiness” and “liveness,” respectively. </p>
</div>
</div>
<div class="readable-text" id="p66">
<p>Now that we have a little more robust container, we will be working with four <code>docker-compose</code> commands:</p>
</div>
<ul>
<li class="readable-text" id="p67"><code>docker-compose</code> <code>build</code>—We use this command when we need to build the container as specified in the Dockerfile. Any updates to files/scripts that we are including in the container will require us to issue this command.</li>
<li class="readable-text" id="p68"><code>docker-compose</code> <code>up</code>—This command is used when we need to start our containers.</li>
<li class="readable-text" id="p69"><code>docker-compose</code> <code>stop</code>—We use this command when we want to stop our container and leave the data in place. While important, we will typically use the <code>down</code> argument because we will rely on our initialization scripts to populate the database and start with a fresh database each time.</li>
<li class="readable-text" id="p70"><code>docker-compose</code> <code>down</code>—This command is used when we need to stop and remove the containers. We use it to make changes to any of our initialization scripts because the initialization will not occur when the database exists.</li>
</ul>
<div class="readable-text" id="p71">
<p>We’ll require these commands as we make changes to our Dockerfiles. Usually, for development, we just chain them together as <code>docker-compose</code> <code>down</code> <code>&amp;&amp;</code> <code>docker-compose</code> <code>build</code> <code>&amp;&amp;</code> <code>docker-compose</code> <code>up</code>. You can even slim the command down to <code>docker-compose</code> <code>down</code> <code>&amp;&amp;</code> <code>docker-compose</code> <code>up</code> <code>--build</code>.</p>
</div>
<div class="readable-text" id="p72">
<p>Initially creating our containers may take a bit of time, but the process will be significantly faster when making small incremental changes. We should now be able to view our table and its data through CloudBeaver.</p>
</div>
<div class="readable-text" id="p73">
<h3 class="readable-text-h3"><span class="num-string">3.2.3</span> API container</h3>
</div>
<div class="readable-text" id="p74">
<p>Our next container expands on our container experience by building a container for our APIs. Soon, we will begin to build out specific APIs for dealing with ACH files, but for now, we will keep things very basic. We want to make use of the FastAPI framework for running our APIs in Python. </p>
</div>
<div class="readable-text intended-text" id="p75">
<p>We will create a Python container from the standard Docker Python image (an image in Docker is a standard read-only template used to create a container) and install FastAPI and some dependencies on top. In our previous containers, we worked directly in the docker-compose file to create our containers. With this container, we will create a Dockerfile that will be referenced by the docker-compose file. To store the dependencies and configuration of the image, we need to introduce a few new commands:</p>
</div>
<ul>
<li class="readable-text" id="p76"><code>FROM</code>—Specifies a base image to start building the image from. </li>
<li class="readable-text" id="p77"><code>COPY</code>—Copies directories/files from the local machine to the image. In the upcoming section, we will create a requirements.txt that will need to be copied to the image that contains FastAPI, among other things.</li>
<li class="readable-text" id="p78"><code>RUN</code>—Executes a command in the image during the build process. We will execute <code>pip</code> to install the required Python packages.</li>
<li class="readable-text" id="p79"><code>CMD</code>—Specifies a default command to run when the container starts. We will use this command to run Uvicorn, which is an Asynchronous Server Gateway Interface (ASGI) that we need to run FastAPI.</li>
</ul>
<div class="readable-text" id="p80">
<p>As mentioned, we are using the <code>FROM</code> command to declare a base image to build from. Docker will default to the latest if you do not specify anything, but you can also specify a particular image tag. Specifying a tag can be useful for various reasons, especially if you want to lock the image to a particular version. We will use the <code>latest</code> for our images because we consider this a development project that would not be immediately pushed to production.</p>
</div>
<div class="readable-text intended-text" id="p81">
<p>What do we mean by a development project? We just mean that in a production environment, more care is needed when changing the software version. You may have deprecated features, and there may be bugs or vulnerabilities that you should be aware of. These are all considerations that you need to weigh before changing the version. In this instance, we pick the latest version of Python when building our container. In a production environment, you would want to control that upgrade by running it through your test suite and ensuring no incompatibilities exist.</p>
</div>
<div class="readable-text intended-text" id="p82">
<p>These concerns about the containers’ version also extend to the application itself. This container installs FastAPI on top of the Python container, so we have a requirements.txt file to take care of that. We have chosen to just install the latest packages for this example; however, we encourage you to look at locking in a particular version and other requirements.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p83">
<h5 class="callout-container-h5 readable-text-h5">Python requirements.txt</h5>
</div>
<div class="readable-text" id="p84">
<p>Our example uses the package name without any type of versioning. However, there are better safety measures that you can take advantage of, such as</p>
</div>
<ul>
<li class="readable-text" id="p85"><em>Specifying the exact versio</em><em>n</em>—<code>package</code><em> </em><code>==</code><em> </em><code>1.0.0</code></li>
<li class="readable-text" id="p86"><em>A version rang</em><em>e</em>—<code>package&gt;=1.0.0,&lt;2.0.0</code></li>
<li class="readable-text" id="p87"><em>Exclude a versio</em><em>n</em>—<code>package!=1.0.5</code></li>
<li class="readable-text" id="p88"><em>A version combined with a Python version</em>—<code>package==1.1.0;</code><em> </em><code>python_version</code><em> </em><code>&lt;</code><em> </em><code>'3.10'</code></li>
</ul>
<div class="readable-text" id="p89">
<p>You can also install from version control systems, URLs, and local files.</p>
</div>
<div class="readable-text" id="p90">
<p>Finally, you can create a requirements.txt for your project by using <code>pip</code> <code>freeze</code> <code>&gt;</code> <code>requirements.txt</code>.</p>
</div>
</div>
<div class="readable-text" id="p91">
<p>You should be able to use the standard <code>docker-compose</code> <code>build</code> and <code>docker-compose up</code> commands to build and bring the containers online. Depending on the ports that you used (<code>8000</code> for us), you should be able to navigate to the APIs with http://localhost:8000/ and then see the output <code>{"message":"Hello</code> <code>World!"}</code>, which is still pretty cool although not doing much.</p>
</div>
<div class="readable-text" id="p92">
<h3 class="readable-text-h3"><span class="num-string">3.2.4</span> Web server container</h3>
</div>
<div class="readable-text" id="p93">
<p>The final piece of our container puzzle that we are looking into is a web interface. The plan is to provide a dashboard with which we can upload and view ACH files. Again, for now, we are just going to build a simple page to ensure everything is working. For this container, we will be building our application on top of Nginx. While a large number of existing infrastructures run Apache for a web Server, Nginx has had a slightly larger market share for the past few years.</p>
</div>
<div class="readable-text intended-text" id="p94">
<p>This container builds on some of the concepts we explored before, such as building a container using a base image. In addition, you will likely want to manage the ports from the docker-compose file. Previously, we specified ports such as <code>8000:8000</code>, which gave both the host and container ports, respectively. By default, Nginx will be listening on <code>port</code> <code>80</code>, and while we could update its configuration file to define a different port to listen on, we can take this opportunity to introduce configuring the ports in Docker. Suppose we want to be able to keep the default port for Nginx and just give a different port to the web browser. For instance, let us say we want to be able to navigate to http://localhost:3000/hello.xhtml to access our sample web page. We can do that by specifying <code>3000:80</code> and then starting our containers.</p>
</div>
<div class="readable-text intended-text" id="p95">
<p>At this point, we have set all the containers we are going to need so far, but we haven’t ensured they are talking to each other.</p>
</div>
<div class="readable-text" id="p96">
<h2 class="readable-text-h2"><span class="num-string">3.3</span> Connecting our containers</h2>
</div>
<div class="readable-text" id="p97">
<p>Now, let’s go back to getting our containers to communicate. We would like to make sure that our containers can interact. Our use case is simple to start with, but it lays the groundwork for expanding our project. We would like to be able to access a web page that uses the API layer to access our <code>health_check</code> database table. This table is not necessarily changing at this point, but we can manually adjust it and see the results. It will be a nice first step in ensuring that everything is functioning as expected.</p>
</div>
<div class="readable-text intended-text" id="p98">
<p>As mentioned earlier, ports can pose a problem, not only from a security perspective but just remembering which ports you have chosen. So, let us make a list of our containers and the ports we are using.</p>
</div>
<div class="browsable-container browsable-table-container" id="p99">
<h5 class="browsable-container-h5">Table 3.1 Container port listing</h5>
<table class="No-Table-Style _idGenTablePara-1" id="table001">
<colgroup>
<col class="_idGenTableRowColumn-1"/>
<col class="_idGenTableRowColumn-1"/>
<col class="_idGenTableRowColumn-1"/>
</colgroup>
<tbody>
<tr class="No-Table-Style _idGenTableRowColumn-2">
<td class="No-Table-Style CellOverride-1"> <p class="_TableHead"><span class="CharOverride-12">Container name</span></p> </td>
<td class="No-Table-Style CellOverride-2"> <p class="_TableHead"><span class="CharOverride-12">Host port</span></p> </td>
<td class="No-Table-Style CellOverride-3"> <p class="_TableHead"><span class="CharOverride-12">Internal port</span></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-4"> <p class="_TableBody">CloudBeaver</p> </td>
<td class="No-Table-Style CellOverride-5"> <p class="_TableBody"><code>8080</code></p> </td>
<td class="No-Table-Style CellOverride-6"> <p class="_TableBody"><code>8080</code></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-7"> <p class="_TableBody">Postgres</p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody"><code>-</code></p> </td>
<td class="No-Table-Style CellOverride-9"> <p class="_TableBody"><code>5432</code></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-7"> <p class="_TableBody">Api</p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody"><code>8000</code></p> </td>
<td class="No-Table-Style CellOverride-9"> <p class="_TableBody"><code>8000</code></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-10"> <p class="_TableBody">Web</p> </td>
<td class="No-Table-Style CellOverride-11"> <p class="_TableBody"><code>3000</code></p> </td>
<td class="No-Table-Style CellOverride-12"> <p class="_TableBody"><code>80</code></p> </td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p100">
<h3 class="readable-text-h3"><span class="num-string">3.3.1</span> Connecting to the database</h3>
</div>
<div class="readable-text" id="p101">
<p>Our first step is to have the API container connected to the database and grab the result from the table. At this point, we are only looking to get the plumbing sorted out, so we are not going to look at writing a unit test yet. We will be able to easily test this ourselves as we build out the sample. First, we will focus on updating our API layer to connect to the database and return our given status.</p>
</div>
<div class="readable-text intended-text" id="p102">
<p>We start by updating our requirements.txt to include <code>psycopg[c]</code> to support connecting to the database. </p>
</div>
<div class="browsable-container listing-container" id="p103">
<h5 class="listing-container-h5 browsable-container-h5">Listing 3.5<span class="CharOverride-5"> </span>Our updated requirements.txt</h5>
<div class="code-area-container">
<pre class="code-area">psycopg[c]
fastapi
pydantic
uvicorn</pre>
</div>
</div>
<div class="readable-text" id="p104">
<p>The <code>psycopg[c]</code> is a production appropriate approach but also requires updating our Dockerfile to include additional dependencies. You should now be able to access http://localhost:8000/health/status to view the status. If everything went okay, you should see <code>[{"id":1,"status":"OK"}]</code>. If not, you can jump down to section 3.2.2, which discusses some common problems you may encounter.</p>
</div>
<div class="readable-text intended-text" id="p105">
<p>We have a few things to think about now that we have updated this code. Our <code>health_check</code> table is currently built to have a sequential ID and a status, and we decided to return all our records in this example. You can experiment with this by going into CloudBeaver (http://localhost:8080), clicking the <code>SQL</code> command, and inserting another record with <code>INSERT</code> <code>INTO</code> <code>health_check</code> <code>VALUES(DEFAULT,</code> <code>'testing')</code>. It is not necessary to capitalize the SQL statements, but we find that doing so helps keep the code more readable when dealing with SQL intermingled with other code. After inserting the record, you will find that navigating back to the health/status endpoint will return all records. So, you should see something similar to <code>[{"id":1,"status":"OK"},{"id":2,"status":"testing"}]</code>. Later, we can review and explore ways to address this. Keep in mind that we wanted to provide the health of the current system but that we are not doing anything to update that table at this time.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p106">
<h5 class="callout-container-h5 readable-text-h5">Exposed ports and internal networks</h5>
</div>
<div class="readable-text" id="p107">
<p>When specifying our connection string, we selected <code>port</code> <code>5432</code>. You can also see that the <code>postgres</code> container is listening on <code>5432</code> as there should be a log message saying <code>listening</code> <code>on</code> <code>IPv4 address 0.0.0.0,</code> <code>port</code> <code>5432</code>. However, our list of ports shows we did not specify it, so what gives?</p>
</div>
<div class="readable-text" id="p108">
<p>Because we are using Docker Compose, one of the benefits is the creation of an internal network. This allows the containers to talk to each other as if they were on the same network. In our case, the above ports were only for the host system. If we wanted to write scripts or browse the database using tools installed on our desktop, then we could have exposed <code>port</code> <code>5432</code>. </p>
</div>
<div class="readable-text" id="p109">
<p>Why can we use CloudBeaver to view the SQL data? Well, that is because we exposed the <code>8080</code> <code>port</code> for CloudBeaver which we can browse with our web browser. So, we are communicating externally with CloudBeaver, but CloudBeaver can use the internal network to hit <code>port</code> <code>5432</code>.</p>
</div>
</div>
<div class="readable-text" id="p110">
<h3 class="readable-text-h3"><span class="num-string">3.3.2</span> Troubleshooting PostgreSQL and FastAPI</h3>
</div>
<div class="readable-text" id="p111">
<p>It is entirely likely that things did not go as expected when setting up your container or that things will not go as intended when setting up other containers. When starting the containers with <code>docker-compose</code> <code>up</code>, be sure to keep an eye on the logs as you may frequently see a meaningful error message. Also note that you may need to scroll back because an earlier container failed, and others are running after it, or an error/warning message was just lost in the shuffle. The following are some of the more common errors you may get in the scenario of a container not starting.</p>
</div>
<div class="readable-text intended-text" id="p112">
<p>We are trying to make a connection from one container to another, so you may see a message on the console similar to<span class="_Body-1-Char"> </span><code>Is</code> <code>the</code> <code>server</code> <code>running</code> <code>on</code> <code>that</code> <code>host</code> <code>and</code> <code>accepting</code> <code>TCP/IP</code> <code>connections?</code><span class="_Body-1-Char"> </span>This message could mean that the container failed to start, and since it is connecting from our FastAPI code to the database, there may be a syntax error in our code that prevented the container from starting. This error could be a typo in our code or could result from dependencies that we failed to include. If the code is syntactically correct, check the requirements.txt and Dockerfile to ensure that all requirements are being installed.</p>
</div>
<div class="readable-text intended-text" id="p113">
<p>The error <code>connection</code> <code>to</code> <code>server</code> <code>at</code> <code>"localhost"</code> <code>(::1),</code> <code>port</code> <code>5432</code> <code>failed:</code> <code>Cannot</code> <code>assign</code> <code>requested</code> <code>address</code> is another one we can run into. This error is common because many examples may refer to <code>localhost</code>, and it may be easy to mistakenly use localhost instead of the name/address of the container. You may also assume that since we are running on our computer, you can use <code>localhost</code>. Remember, though, that we are running in a container. We should specify the name of the container in our connection string rather than <code>localhost</code>.</p>
</div>
<div class="readable-text intended-text" id="p114">
<p>The error <code>psycopg.OperationalError:</code> <code>connection</code> <code>failed:</code> <code>FATAL:</code> <code>password authentication</code> <code>failed</code> <code>for</code> <code>user</code> <code>"postgres"</code> can occur when you have an invalid user or password specified. Look at the Dockerfile and docker-compose.yml to ensure you have the correct username and password. Remember that at this point, we have defined the username and password in our docker-compose file when setting up the database container, but we also had to hardcode it into our Python code.</p>
</div>
<div class="readable-text intended-text" id="p115">
<p>Another error we may encounter, especially when generative AI is helping, is a <code>NameError</code>. A <code>NameError</code> is raised when a local or global name is not found, meaning we tried to use a variable, function, or module that has either not been defined or is not accessible in the current scope. We encountered the error <code>NameError:</code> <code>name</code> <code>'status'</code> <code>is</code> <code>not</code> <code>defined</code> when working through the code ourselves because we were not paying close attention to the code generative AI suggested. The variable <code>status</code> was populated by Copilot even though that was not the name of the variable we used. So, this amounted to a simple syntax error, and we had to return the right value.</p>
</div>
<div class="readable-text" id="p116">
<h2 class="readable-text-h2"><span class="num-string">3.4</span> Calling our API</h2>
</div>
<div class="readable-text" id="p117">
<p>At this point, we should be able to confirm that the API has access to the database container. We have one more jump that we would like to make—we want to be able to create a web page that will access the API. Although we have already seen that we can access the API in our browser, we were able to get away with testing that way because our REST API was using a <code>GET</code> request, which is the same request used to retrieve web pages. Later, when using some of the other HTTP verbs such as <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>, we will not be able to test in this fashion. Furthermore, we will be looking to build the UI, so we need to ensure connectivity between the web and API containers.</p>
</div>
<div class="readable-text intended-text" id="p118">
<p>We will create a simple web page that incorporates d3.js to display our results. In our case, we do not need anything fancy, so we will just create a list of the results. If you are not familiar with HTML or d3.js, this would be a wonderful time to see whether our generative AI tool could help you get started.</p>
</div>
<div class="readable-text intended-text" id="p119">
<p>We prompted ChatGPT (GPT-40) with</p>
</div>
<div class="readable-text prompt" id="p120">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Create a simple d3.js webpage that calls an API. </p>
</div>
<div class="readable-text" id="p121">
<p>It produced an example visible in <code>chat_gpt_example.xhtml</code>. </p>
</div>
<div class="browsable-container listing-container" id="p122">
<h5 class="listing-container-h5 browsable-container-h5">Listing 3.6<span class="CharOverride-5"> </span>Sample page produced by ChatGPT</h5>
<div class="code-area-container">
<pre class="code-area">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;D3.js API Call&lt;/title&gt;
    &lt;script src="https://d3js.org/d3.v6.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;Users from JSONPlaceholder API&lt;/h2&gt;
    &lt;ul id="users"&gt;&lt;/ul&gt;

    &lt;script&gt;
        // The URL for the API endpoint
        const apiUrl = 'https://jsonplaceholder.typicode.com/users';

        // Use D3 to fetch the data from the API
        d3.json(apiUrl).then(data =&gt; {
            // Once data is fetched, populate the list
            d3.select("#users")
                .selectAll("li")
                <span>.data(data)</span>
<span>                .enter()</span>
<span>                .append("li")</span>
<span>                .text(d =&gt; `${d.name} (${d.email})`);</span>
<span>        </span>});
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
</div>
<div class="readable-text" id="p123">
<p>This response gives us a great starting point, and with a few tweaks, we have a workable solution for our initial needs. </p>
</div>
<div class="browsable-container listing-container" id="p124">
<h5 class="listing-container-h5 browsable-container-h5">Listing 3.7<span class="CharOverride-5"> </span>Updated sample page</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt; 
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 
    <strong>&lt;title&gt;Health Check&lt;/title&gt; </strong>#1
    &lt;script src=<strong>"https://d3js.org/d3.v7.min.js"</strong>&gt;&lt;/script&gt; 
&lt;/head&gt;

&lt;body&gt;
    <strong>&lt;h2&gt;Health Check&lt;/h2&gt; </strong>#2
    &lt;ul <strong>id="healthStatus"</strong>&gt;&lt;/ul&gt;  
    &lt;script&gt;
        // The URL for the API endpoint
        const apiUrl = <strong>'http://localhost:8000/health/status'</strong>; #3

        // Use D3 to fetch the data from the API
        d3.json(apiUrl).then(data =&gt; {
            // Once data is fetched, populate the list
            <strong>d3.select("#healthStatus")  </strong>#4
                .selectAll("li")  #4
                <span>.data(data) </span> #4
<span>                .enter() </span> #4
<span>                .append("li") </span> #4
<span>                </span><strong>.text(d =&gt; `${d.id} (${d.status})`); </strong> #4
<span>        </span>});
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">We start by giving our page a title and importing d3.js.</span>
<br/>#2 
     <span class="CharOverride-8">Creates a heading and updates the ID to be more meaningful for our purposes</span>
<br/>#3 
     <span class="CharOverride-8">Accesses the API endpoint for the status check</span>
<br/>#4 
     <span class="CharOverride-8">Updates the select statement and text fields (ID and text) so that we are writing out the expected data</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p125">
<p>In addition to customizing the output for our specific need, we had to bump up the version of d3.js to the current level. This is a reoccurring theme when working with generative AI; depending on the model and training data, the latest software may not always be included. It is a good idea to quickly double-check all software release levels just to confirm you are running an appropriate version. </p>
</div>
<div class="readable-text intended-text" id="p126">
<p>The most important customization that we had to make was pointing the page to the correct API URL. You can refer to the port listing we made earlier; do you have any ideas what that URL will look like? You may have been tripped up by the previous example of connecting the database and API containers where we had to specify the container name. In that example, we were internal to Docker. Now, our web page is external, so we want to access it from the outside and thus use localhost with <code>port</code> <code>8000</code>.</p>
</div>
<div class="readable-text intended-text" id="p127">
<p>Testing access gives us a CORS (cross-origin resource sharing) error: </p>
</div>
<div class="browsable-container listing-container" id="p128">
<div class="code-area-container">
<pre class="code-area">Access to fetch at 'http://localhost:8000/health/status' from origin <br/>'http://localhost:3000' has been blocked by CORS policy: No 'Access-<br/>Control-Allow-Origin' header is present on the requested resource.</pre>
</div>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p129">
<h5 class="callout-container-h5 readable-text-h5">CORS</h5>
</div>
<div class="readable-text" id="p130">
<p>CORS, which is better known as the bane of getting things done quickly, is one of the more common problems you will run into. CORS stands for cross-origin resource sharing and is a security mechanism that allows servers to specify controls over which resources are shared with external callers. </p>
</div>
<div class="readable-text" id="p131">
<p>CORS provides the idea of simple requests and preflight requests. We are not really concerned with simple requests because preflight requests are the ones that trigger CORS exceptions. To work around these exceptions, we will need to configure our server to ensure some specific headers dealing with CORS are sent back.</p>
</div>
<div class="readable-text" id="p132">
<p>The following headers need to be used:</p>
</div>
<ul>
<li class="readable-text" id="p133"><code>Access-Control-Allow-Origin</code>—Specifies which sites are allowed to access the resource. We can use a wildcard <code>*</code>, but this can pose a potential security risk. Remember, the principle of least privilege? Start with a more focused origin and only broaden it as necessary.</li>
<li class="readable-text" id="p134"><code>Access-Control-Allow-Methods</code>—Specifies which HTTP methods are allowed. Again, you can use wildcards but should only use what is necessary. In our example, we are only using <code>GET</code> so that is the only one we really need. Later, we will be using more requests, but we recommend keeping it as <code>GET</code> for now and not updating it to use HTTP methods we have not yet defined, so that CORS will complain again later as it provides good troubleshooting practice.</li>
<li class="readable-text" id="p135"><code>Access-Control-Allow-Headers</code>—Allows the server to specify what headers can be used for the request.</li>
<li class="readable-text" id="p136"><code>Access-Control-Allow-Credentials</code>—Indicates whether the browser should include credentials for requests. If you have authenticated requests or need to maintain state with cookies, or otherwise have requests that include sensitive information, set this to <code>true</code>.</li>
</ul>
</div>
<div class="readable-text" id="p137">
<p>To correct this error, our API layer needs to be updated with the following.</p>
</div>
<div class="browsable-container listing-container" id="p138">
<h5 class="listing-container-h5 browsable-container-h5">Listing 3.8<span class="CharOverride-5"> </span>Incorporating CORS into our API</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">from fastapi import FastAPI
<strong>from fastapi.middleware.cors import CORSMiddleware </strong>#1
import psycopg

DATABASE_URL = "dbname=postgres user=postgres 
<span class="CharOverride-6">➥</span> password=secret host=postgres port=5432"

app = FastAPI()

<strong>origins = [  </strong>#2
<strong>    "http://localhost:3000", </strong> #2
<strong>] </strong>

<strong>app.add_middleware( </strong>#3
<strong>    CORSMiddleware, </strong> #3
<strong>    allow_origins=origins, </strong> #3
<strong>    allow_credentials=False, </strong> #3
<strong>    allow_methods=["GET"], </strong> #3
<strong>    allow_headers=["*"], </strong> #3
<strong>) </strong> #3

def get_db():
    conn = psycopg.connect(DATABASE_URL)
    return conn</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-8">We import the CORSMiddleware from fastapi.</span>
<br/>#2 
     <span class="CharOverride-8">The origins are where we expect to receive requests from; we create this as a separate variable because we expect to update it a few times.</span>
<br/>#3 
     <span class="CharOverride-8">We pass all the parameters here; allow_methods and allow_headers are an integral part of securing our API.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p139">
<p>Notice how we tried to keep the origins and methods narrow. In other words, we limited the allowed origins and methods to only what we need for now. Resist the urge to future-proof the code by using wildcards and more methods than you currently have/need. This is because when it comes to security, we want to keep it locked down. We wanted to say “Less is more” but did not want anyone coming back to us saying that they were hacked because they had less security! We mean that less access is better!</p>
</div>
<div class="readable-text intended-text" id="p140">
<p>With the CORS updates in place, you should be able to build the containers and bring Docker back up. Hopefully, you can now navigate to http://localhost:3000/health.xhtml and see some results. You should be able to again go back into Cloud­Beaver and enter additional records in the <code>health_check</code> table, which will be displayed when you refresh the web page.</p>
</div>
<div class="readable-text" id="p141">
<h3 class="readable-text-h3"><span class="num-string">3.4.1</span> Troubleshooting our web site</h3>
</div>
<div class="readable-text" id="p142">
<p>The main problem you are likely to encounter is the error that we discussed before—the CORS error: </p>
</div>
<div class="browsable-container listing-container" id="p143">
<div class="code-area-container">
<pre class="code-area"><code>Access to fetch at 'http://localhost:8000/health/status' from origin <br/>'http://localhost:3000' has been blocked by CORS policy: No 'Access-<br/>Control-Allow-Origin' header is present on the requested resource.</code> </pre>
</div>
</div>
<div class="readable-text" id="p144">
<p>As previously mentioned, this security-related error is easy to work around if you choose to just allow everything. We would caution against this approach as you should maintain some security. Often, your APIs may have a level of redirection built in as they may go through other tools such as WSO2 API Manager (which we discuss in chapter 4). In this case, you may want to just specify that middle layer in your CORS configuration. Or, you may want to limit HTTP requests. Again, the idea is that if you do not need it, then you should not have it.</p>
</div>
<div class="readable-text intended-text" id="p145">
<p>An <code>ERR_SSL_PROTOCOL_ERROR</code> may occur if you are using HTTPS and the API was only listening on HTTP. You may see an error on your web browser console such as <code>Failed</code> <code>to</code> <code>load</code> <code>resource:</code> <code>net::ERR_SSL_PROTOCOL_ERROR</code>. For now, we are using HTTP and not HTTPS because we did not want to introduce additional complications with certificates. However, we will work on expanding this later in our project.</p>
</div>
<div class="readable-text intended-text" id="p146">
<p>You may encounter a <code>404</code> <code>error</code> from d3.js such as <code>d3.v7.min.js:2</code> <code>Uncaught</code> <code>(in promise)</code> <code>Error:</code> <code>404 Not</code> <code>Found</code>. This is usually going to be a typo in your API endpoint. Another reason could be using the wrong HTTP method (<code>GET</code> when you need <code>POST</code>), although it is more common to see a <code>405</code> <code>Method</code> <code>Not</code> <code>Allowed.</code> We have seen some frameworks use the <code>404</code> error code as well. Other problems also exist, but we start exceeding the scope of this book as they start getting into server and network configurations. So, you will need more assistance if you have eliminated these basic reasons.</p>
</div>
<div class="readable-text intended-text" id="p147">
<p>We mention this here although it could happen at any time. If Docker is not running, then you may get errors building and starting your project. Seeing an error such as <code>error</code> <code>during</code> <code>connect:</code> <code>this</code> <code>error</code> <code>may</code> <code>indicate</code> <code>that</code> <code>the</code> <code>docker</code> <code>daemon</code> <code>is</code> <code>not running</code> is an obvious message that you do not have Docker running. However, we are likely to make that mistake at least a couple of times, so it is best to address it now.</p>
</div>
<div class="readable-text" id="p148">
<h2 class="readable-text-h2"><span class="num-string">3.5</span> Container security</h2>
</div>
<div class="readable-text" id="p149">
<p>Hopefully, you have an idea of how cool working with containers can be. Yes, our application has inherited some complexity but that is a tradeoff for some of the benefits of using this type of architecture.</p>
</div>
<div class="readable-text intended-text" id="p150">
<p>We also inherit some security risk as part of this convenience. When we build a container using an image, even an official image can have risks associated with it. These come in the form of security vulnerabilities included in the package. It is important to understand these problems as they could be serious exploits in a version of the image or packages you are using. Some images are complex, and it may not be apparent what is actually included in a particular image. That is where tools such as Snyk and Docker Scout come into play. They can scan your containers and report on vulnerabilities in any of the images or included packages.</p>
</div>
<div class="readable-text intended-text" id="p151">
<p>Snyk offers a command-line-scanning tool that creates an inventory of our Docker containers (figure 3.3). We can then use their web site to view scans and fix potential problems. When new problems are discovered in one of our containers, we will be automatically alerted so that we can begin fixing them immediately (if necessary).</p>
</div>
<div class="browsable-container figure-container" id="p152">
<img alt="A screenshot of a computer  Description automatically generated" height="631" src="../Images/CH03_F03_Kardell.png" style="width: 100%; max-width: max-content;" width="802"/>
<h5 class="figure-container-h5"><span class="">Figure 3.3</span><span class=""> </span><span class="">Sample results generated by Snyk</span></h5>
</div>
<div class="readable-text" id="p153">
<p>Another aspect to pay attention to is port numbers used both within the containers and exposed to the world. We can see ports available using <code>docker</code> <code>ps</code>. When configuring containers, it may be helpful to allow ports to be set dynamically. For instance, our <code>api</code> <code>host</code> <code>port</code> could be set with <code>${API_PORT:-8080}:80</code>, which would allow us to default to <code>port</code> <code>8080</code> unless <code>API_PORT</code> has been defined, in which case that would take precedence.</p>
</div>
<div class="readable-text intended-text" id="p154">
<p>There are numerous options within Docker to help secure containers, and we will briefly touch on some and their application:</p>
</div>
<ul>
<li class="readable-text" id="p155"><code>--read-only</code>—It marks a container as read-only, which can help limit malicious activity in the event of an attacker gaining access to the container.</li>
<li class="readable-text" id="p156"><code>--memory</code> and <code>–cpu</code>—There are multiple configuration options around memory and CPU. These can configure how many resources are available to a container from the host system. Preventing a container from eating up too much of a resource is important to the overall health of the system.</li>
<li class="readable-text" id="p157"><code>--no-new-privileges</code>—It prevents the application from gaining any new privileges. This means Docker will prevent you from executing scripts and commands that would give you root privileges. The idea again is to keep malicious code and users contained.</li>
</ul>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p158">
<h5 class="callout-container-h5 readable-text-h5">The principles of least privilege and defense in depth</h5>
</div>
<div class="readable-text" id="p159">
<p>A common notion in security is known as the principle of least privilege (PoLP). We try to use minimal access or only the necessary permissions to complete our work, elevating those permissions only when necessary and then reverting to our original state. Ideally, even administrators or those with root access are not using it as their default sign-on. It is easier to grant users everything or higher permissions, but if their account is compromised, then the attacker has that same access. Perhaps, even more common is a user just making a typo or not paying attention to the system or directory they are in, and causing damage by removing unintended files. We have heard more than one story of a script being run as root that brought down the system. Or someone may be doing <code>rm *</code> in the wrong directory and crashing the system!</p>
</div>
<div class="readable-text" id="p160">
<p>“Defense in depth” or “security in layers” is another security practice that you will be implementing, regardless of your role in an organization. It simply refers to the broad range of security practices put in place to protect an organization from physical security to network security to application security. As a developer, you are likely going to be involved in the application-level security. This will also expand into data security and access management, as you will need to encrypt and mask data, as well as authenticate and authorize users to the system.</p>
</div>
</div>
<div class="readable-text" id="p161">
<p>If you are part of a large organization, the managing and security of containers may not be your area, especially if you are working in a software developer role. In a smaller company, you may be wearing multiple hats, and having some knowledge of these concepts will be useful. In our case, we are using containers to play around with our development project, and we just need to understand the CliffsNotes. However, security is a major consideration in all organizations, and understanding some of the basics will not only help you be a better developer but will also give you a different perspective when that next annoying request comes from the security team. If you want to explore Docker security further, check out the OWASP Docker Security Cheat Sheet (<a href="https://mng.bz/nR8K"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/mng.bz/nR8K</span></a>).</p>
</div>
<div class="readable-text" id="p162">
<h2 class="readable-text-h2"><span class="num-string">3.6</span> Optimizing Docker</h2>
</div>
<div class="readable-text" id="p163">
<p>Docker is great, especially if you are a developer. There are tons of Docker images that you can use to explore different technologies and tools without the need to install them on your machine (other than with the Docker image). So, you no longer need to clutter up your personal machine with a bunch of software that you later forget about. Of course, this convenience is not without some drawbacks. For instance, if you have started all the Docker projects bundled with this chapter, you may have a lot of wasted space as Docker created containers, images, and volumes for each, which is why we are just going to take a little bit of a dive into managing and optimizing Docker.</p>
</div>
<div class="readable-text intended-text" id="p164">
<p>So, why optimize? When we look at optimizing Docker, we are primarily speaking about removing unnecessary components and perhaps building them out from a different image. By reducing the components, we can usually achieve better security, faster deployment, and potentially run-time improvements. As developers, we may haphazardly pull in images with little regard for what they are built on. After all, we usually try to get to our work, but for now, let us see what things look like under the hood.</p>
</div>
<div class="readable-text" id="p165">
<h3 class="readable-text-h3"><span class="num-string">3.6.1</span> General maintenance</h3>
</div>
<div class="readable-text" id="p166">
<p>First, we run the command <code>docker image ls</code>. It will show us the images and their sizes. Here is a sample output:</p>
</div>
<div class="browsable-container listing-container" id="p167">
<div class="code-area-container">
<pre class="code-area">REPOSITORY           TAG       IMAGE ID       CREATED          SIZE
dockercompose7-web   latest    9d0257a0f9b0   56 minutes ago   187MB
postgres             latest    e872544a957a   56 minutes ago   417MB
&lt;none&gt;               &lt;none&gt;    056294c7ea5d   58 minutes ago   187MB
&lt;none&gt;               &lt;none&gt;    531ebd9cf3db   58 minutes ago   417MB
dockercompose7-api   latest    5a2bb8fc1b02   24 hours ago     1.09GB
&lt;none&gt;               &lt;none&gt;    9552a83973a9   24 hours ago     417MB
&lt;none&gt;               &lt;none&gt;    606976f59240   24 hours ago     1.09GB
&lt;none&gt;               &lt;none&gt;    237b5dd9e45d   24 hours ago     417MB
&lt;none&gt;               &lt;none&gt;    20ec806118d6   24 hours ago     187MB
&lt;none&gt;               &lt;none&gt;    361454300c20   24 hours ago     1.09GB</pre>
</div>
</div>
<div class="readable-text" id="p168">
<p>The first thing you should notice is that we have a bunch of repositories with <code>&lt;none&gt;</code>. These are known as dangling images and can appear when we are building/rebuilding our project. We may have brought some of these on ourselves simply by working in our development environment and continually building our containers as we modify our project. Another common reason is using the <code>latest</code> tag. We had previously chosen to use the <code>latest</code> tag because we always wanted the latest project. Now we could be paying a price for that decision. In our current environment, we personally are not overly concerned about this, but in a production environment, where we had a specific project we were building, we would ensure we had tagged our project to a specific level.</p>
</div>
<div class="readable-text intended-text" id="p169">
<p>To clean up these dangling images, we can issue the following <code>prune</code> command. With all the prerequisite warnings about being careful when removing things, we issue <code>docker</code> <code>image</code> <code>prune</code> and are prompted to confirm we want to continue. Then, several images are removed, and we then do <code>docker</code> <code>image</code> <code>ls</code> to see what is left:</p>
</div>
<div class="browsable-container listing-container" id="p170">
<div class="code-area-container">
<pre class="code-area">REPOSITORY           TAG       IMAGE ID       CREATED             SIZE
dockercompose7-web   latest    9d0257a0f9b0   About an hour ago   187MB
postgres             latest    e872544a957a   About an hour ago   417MB
dockercompose7-api   latest    5a2bb8fc1b02   24 hours ago        1.09GB
dockercompose6-api   latest    d53ec48f5fec   3 days ago          1.09GB
dockercompose6-web   latest    ef65a4305bf7   3 days ago          187MB
cloudbeaver          latest    9b672f480fc7   2 weeks ago         250MB</pre>
</div>
</div>
<div class="readable-text" id="p171">
<p>Then, we take a look at what is left over, and we see we have previous images out there that we presumably do not care about (<code>dockercompose6-api</code> and <code>dockercompose6-web</code>). We can confirm they are not in use by any (either running or not) containers by issuing <code>docker</code> <code>ps</code> <code>-a</code> <code>--filter ancestor=dockercompose6-api:latest</code>. This code will return the status of the container. When nothing is returned, it can be safely deleted.</p>
</div>
<div class="readable-text" id="p172">
<h3 class="readable-text-h3"><span class="num-string">3.6.2</span> Optimizing image size</h3>
</div>
<div class="readable-text" id="p173">
<p>Now that we have done some general clean-up, it may be a little easier to review our images. We can start again by taking a look at the current images with <code>docker</code> <code>image</code> <code>ls</code>:</p>
</div>
<div class="browsable-container listing-container" id="p174">
<div class="code-area-container">
<pre class="code-area">dockercompose7-web   latest    9d0257a0f9b0   About an hour ago   187MB
postgres             latest    e872544a957a   About an hour ago   417MB
dockercompose7-api   latest    5a2bb8fc1b02   24 hours ago        1.09GB
cloudbeaver          latest    9b672f480fc7   2 weeks ago         250MB</pre>
</div>
</div>
<div class="readable-text" id="p175">
<p>Our biggest image is the <code>dockercompose7-api</code> image at 1.09 GB.</p>
</div>
<div class="readable-text intended-text" id="p176">
<p>One way we can reduce image size is checking whether the particular Docker image supports Alpine Linux. Alpine Linux is a lightweight version of Linux focusing on security, which makes it a good fit for use within Docker.</p>
</div>
<div class="readable-text intended-text" id="p177">
<p>Postgres went from 417 MB to 239 MB just by switching the image, and the web went from 187 MB to 42.6 MB. Unfortunately, we cannot simply switch to Alpine for our biggest container, the API layer that currently sits at 1.09 GB. This is because we are running <code>apt-get</code> in our Dockerfile, and this is not supported by Alpine since it is not based on Debian. We can take a shortcut and use the <code>slim</code> tag. By specifying <code>slim</code> instead of <code>alpine</code>, we do not need to change our Dockerfile and end up with an image that is about half the size, at 557 MB.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p178">
<h5 class="callout-container-h5 readable-text-h5">Slim vs. alpine</h5>
</div>
<div class="readable-text" id="p179">
<p>So, what exactly is the difference between the <code>slim</code> and <code>alpine</code> tags? Both are typically smaller than a standard image, with <code>alpine</code> images typically being even smaller than <code>slim</code> images. </p>
</div>
<div class="readable-text" id="p180">
<p>As the name implies, <code>slim</code> images are minimized versions of the standard images, removing nonessential components such as documentation and development libraries but leaving the core functionality intact. Remember, these containers are specifically designed for running whatever you have put in them. They are not meant for people to be logged in and cruising around, so we do not need things such as man pages for documentation. </p>
</div>
<div class="readable-text" id="p181">
<p>In contrast, Alpine focuses on security, and it is based on the <code>musl</code> <code>libc</code> library and BusyBox. These can cause problems with other software and libraries that you may be installing. As we saw, we had to update our Dockerfile to take advantage of Alpine with some minor changes. Of course, for larger projects, more extensive testing would be needed to ensure everything is working.</p>
</div>
</div>
<div class="readable-text" id="p182">
<p>We can look into reducing the image even further if we want to pursue using Alpine for the API layer. We will need to update the Dockerfile to use the Alpine Package Keeper (<code>apk</code>) instead of <code>apt-get</code> to install the needed packages. Your mileage may vary depending on your project and what exactly needs to be installed. In this case, removing the <code>RUN</code> <code>apt-get</code> line and replacing it with</p>
</div>
<div class="browsable-container listing-container" id="p183">
<div class="code-area-container">
<pre class="code-area">RUN apk -U upgrade
RUN apk add –no-cache libpq-dev python3-dev gcc musl-dev</pre>
</div>
</div>
<div class="readable-text" id="p184">
<p>allowed us to successfully get the project up and running again. This reduced the image size for another 200 MB, bringing it down from 557 MB to 344 MB—quite a difference from the original 1GB!</p>
</div>
<div class="readable-text intended-text" id="p185">
<p>Choosing a smaller base image in your Dockerfile is one of the most straightforward ways of reducing the image size. One of the mantras of development is “Make it work, make it right, make it fast.” That approach works for containers as well. There are benefits of smaller image size, but you do not need to worry about that right at the beginning of your project. When working with a big company, there will likely be a whole team that takes care of this for you, so you may not have a lot of flexibility when it comes to building and running containers.</p>
</div>
<div class="readable-text" id="p186">
<h3 class="readable-text-h3"><span class="num-string">3.6.3</span> Optimizing build time</h3>
</div>
<div class="readable-text" id="p187">
<p>A task that can go hand in hand with optimizing image size is also working on the actual build time. Several tools are available for analyzing Docker images. Two popular tools are Docker Scout and dive, which is a command-line tool. Let us look at running the Docker Scout utility because it is readily available within Docker Desktop. This discussion also provides a good introduction to some of the metrics and terms that get thrown around when using Docker. Figure 3.4 shows the results of analyzing our API image. This screen is from the personal (free) tier of using Docker and Docker Scout. More features are available for the paid tiers (<a href="https://www.docker.com/pricing/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/www.docker.com/pricing/</span></a>).</p>
</div>
<div class="readable-text intended-text" id="p188">
<p>The layers are what we are primarily interested in when considering ways to optimize the build. In a Dockerfile, the order of instructions matters, and each instruction translates into a layer, although there is not always a one-to-one correspondence. We can see the size of each layer and the command being executed. We can also see how the filesystem is affected by each of the commands.</p>
</div>
<div class="readable-text intended-text" id="p189">
<p>One way to optimize the builds is to ensure we are managing the layers appropriately. Layers should be kept to a minimum, and any adding/removing of files should happen in the same layer. For instance, a command that may download temporary files should also be cleaned up.</p>
</div>
<div class="readable-text intended-text" id="p190">
<p>We also mentioned that the order of instructions in a Dockerfile matters because Docker uses a caching mechanism to determine if a command needs to be rerun. Therefore, items that change frequently, such as your application code, are usually near the bottom of the instructions, while less frequent changes or changes that may cause a large download are executed near the top. Doing this in reverse order is known as </p>
</div>
<div class="browsable-container figure-container" id="p191">
<img alt="A screenshot of a computer  Description automatically generated" height="492" src="../Images/CH03_F04_Kardell.png" style="width: 100%; max-width: max-content;" width="775"/>
<h5 class="figure-container-h5"><span class="">Figure 3.4</span><span class=""> </span><span class="">Analysis with Docker Scout</span></h5>
</div>
<div class="readable-text" id="p192">
<p><span class="CharOverride-11">cache busting</span> because it breaks Docker’s cache mechanism and can cause Docker to rebuild the entire image every time.</p>
</div>
<div class="readable-text intended-text" id="p193">
<p>Docker squash is another tool that can help with removing layers and other unused files. A few different versions of this utility and also an experimental command within Docker itself for this functionality can be found on the internet. </p>
</div>
<div class="readable-text intended-text" id="p194">
<p>There is also a <code>.</code>dockerignore file that functions similar to a .gitignore file (if you are familiar with Git). Otherwise, the concept is simple: we can put files or directories into these ignore files, and Docker will ignore them. So, maybe unnecessary configuration files from your IDE, other application related information, and documentation such as READMEs are all good candidates for these files.</p>
</div>
<div class="readable-text intended-text" id="p195">
<p>Finally, general application maintenance can go a long way, ensuring that dependencies are up to date and that you have minimized CSS, JavaScript, and so forth to keep the images small.</p>
</div>
<div class="readable-text" id="p196">
<h2 class="readable-text-h2"><span class="num-string">3.7</span> Removing the hardcoded username/password</h2>
</div>
<div class="readable-text" id="p197">
<p>Now that we have covered some of the maintenance aspects of working with Docker and Docker images, let us take our advice from earlier and work with the application. One thing that we had to do was specify a username and password for the PostgreSQL instance (remember the <code>POSTGRES_USER</code> and <code>POSTGRES_PASSWORD</code> from our docker<br/>-compose file). </p>
</div>
<div class="readable-text" id="p198">
<p>We were able to do this with environment variables; however, when it came to the API container, we hardcoded the values, and that is something we always want to avoid if possible.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p199">
<h5 class="callout-container-h5 readable-text-h5">Avoid magic numbers and hardcoded values</h5>
</div>
<div class="readable-text" id="p200">
<p>Magic numbers have unexplained meanings, such as when we define a log level of 1, 2, 3, 4, or 5. Which one is the highest severity? What does it mean to have a log level of 1 versus a log level of 4? That is an example of a magic number.</p>
</div>
<div class="readable-text" id="p201">
<p>We consider hardcoded values to be a superset of magic numbers as they come with a similar set of problems. Any time we start using hardcoded values such as usernames/passwords, ports, servers, and similar, it poses a problem. Not only can it be a security concern to have them stored insecurely in source control but can also pose a maintenance nightmare when they are sprinkled throughout the code, and your server moves after 10 years. Finding all those places and testing that everything was changed correctly can be a real pain.</p>
</div>
<div class="readable-text" id="p202">
<p>Even though we have yet to examine the application, we will practice good habits by removing our hardcoded values.</p>
</div>
</div>
<div class="readable-text" id="p203">
<p>Luckily, Docker comes with a way for us to make use of environment variables by applying an <code>env_file</code> directive that specifies an environment file. As a bonus, we can refer to the <code>gitignore</code> command to prevent this file from being uploaded to source control. Or maybe there is another layer of redirection where the more sensitive information (the database credentials) is referenced and stored somewhere else. If you are not storing the environment variables in source control, be sure that they are well documented somewhere so that new instances, or new employees, know how to set them up. Often, we have found ourselves having someone email us random configuration files because nobody is sure how to set up the system and what exactly is still needed!</p>
</div>
<div class="readable-text intended-text" id="p204">
<p>The first order of business is to create a file to hold our environment variables. We will need to create a file named <code>.</code>sql_server.conf. The actual name of the file is not important but should be something meaningful. The leading period (.) will often cause the operating system to hide the file and an extension “conf” is a standard for configuration files. Another common naming standard is to use .env. We often see .env files being used in companies, especially when there are source control tools such as Git, which are usually set to ignore .env files. Another example form the Docker documentation available at <a href="https://mng.bz/vK5M"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/mng.bz/vK5M</span></a> shows the use of an environment file named webapp.env when defining their webapp service.</p>
</div>
<div class="readable-text intended-text" id="p205">
<p>The main thing to remember is that the naming of the file is flexible, and neither a specific name nor leading period are required for them to work. However, we are simply establishing a convention, and that may be slightly different from the standards and conventions in place at other companies (remember the saying, “When in Rome<span class="CharOverride-14"> . . .</span>”).</p>
</div>
<div class="readable-text intended-text" id="p206">
<p>With the file created, we will move our hardcoded username and password denoted by <code>POSTGRES_USER</code> and <code>POSTGRESS_PASSWORD</code>, respectively, ending with a file that contains</p>
</div>
<div class="browsable-container listing-container" id="p207">
<div class="code-area-container">
<pre class="code-area">POSTGRES_USER=postgres
POSTGRES_PASSWORD=secret</pre>
</div>
</div>
<div class="readable-text" id="p208">
<p>We will also need to update the <code>docker-compose.yml</code> to make use of this newly created file. Note that we removed environment and replaced it with <code>env_file</code>:</p>
</div>
<div class="browsable-container listing-container" id="p209">
<div class="code-area-container">
<pre class="code-area">  postgres:
    build: 
      context: ./db
      dockerfile: Dockerfile
    env_file:
      - ./.sql_server.conf</pre>
</div>
</div>
<div class="readable-text" id="p210">
<p>Similarly, we also made a change to the API container to employ the same <code>.sql_server.conf</code> in the <code>env_file</code> directive. Before going further, we should build and bring our containers up to ensure that everything is still working. Finally, we will need to update our API container to also pull in these variables. We import the <code>os</code> module and then use <code>getenv</code> to retrieve the environment variables that were set in our .sql_server.conf file:</p>
</div>
<div class="browsable-container listing-container" id="p211">
<div class="code-area-container">
<pre class="code-area">import os
<span>…</span>
<span>POSTGRES_USER = os.getenv("POSTGRES_USER")</span>
<span>POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD")</span>
<span>…</span>
<span>DATABASE_URL = f"dbname={POSTGRES_USER} user={POSTGRES_USER}</span>
<span class="CharOverride-6">➥</span> password={POSTGRES_PASSWORD} host=postgres port=5432"</pre>
</div>
</div>
<div class="readable-text" id="p212">
<p>With those changes, we can remove, build, and bring up the containers to test. You may also want to change the values in the environment to ensure that the changes are indeed working. In addition, do not forget to sign into CloudBeaver to ensure that is working as well.</p>
</div>
<div class="readable-text intended-text" id="p213">
<p>The <code>os.getenv</code> command also allows you to specify a default value if the <code>environment</code> variable is not found. So, we could have used <code>os.getenv("POSTGRES_USER",</code> <code>"postgres"), </code>but we stayed away from a default value in this example because we wanted to ensure that our containers would not work accidentally if we had set something up incorrectly (because the Postgres user was still valid somehow). Your use cases will vary, so just keep that functionality in mind.</p>
</div>
<div class="readable-text intended-text" id="p214">
<p>We also updated the <code>DATABASE_URL</code>. Substituting the <code>POSTGRES_USER</code> for both the <code>dbname</code> and <code>user</code> in the connection string. This is just a convention in the PostgreSQL database. The <code>dbname</code> and <code>user</code> are independent of each other, but we kept our SQL script straightforward, so the table was created under the same username. You will also notice that the connection string contains hardcoded values for the host and port. We are leaving it up to you whether you would like to replace those with an environment value that will not hurt anything and may also be an opportunity for you to try out the default value in the <code>os.getenv</code> mentioned earlier.</p>
</div>
<div class="readable-text" id="p215">
<h2 class="readable-text-h2"><span class="num-string">3.8</span> Health checks</h2>
</div>
<div class="readable-text" id="p216">
<p>In our sample, we built out a simple health check endpoint. This endpoint is something that applications could use to get a status of the system or application. It can be as fine-grained as you want, checking not just the services that it may be running but also potential problems connecting to other services.</p>
</div>
<div class="readable-text intended-text" id="p217">
<p>Here we would like to take a moment to look at health checks from a purely Docker perspective as opposed to what may be done at the application level. These health checks can be used to determine whether the container is running correctly (or healthy). Containers can be in multiple statuses such as starting, healthy, or unhealthy, and the importance of knowing the state of a container is one of the benefits of using containers. Unhealthy containers will adversely affect your system and could be the result of bad application code, networking problems, or perhaps a bad update in one of the components being used in the container. Docker and Docker Compose can automatically restart containers in an attempt to resolve potential problems, or you may build a more robust logging and notification system to monitor your containers.</p>
</div>
<div class="readable-text intended-text" id="p218">
<p>We can determine the health of our containers using the <code>docker</code> <code>ps</code> command. You can run the command now; however, unless the image you are using includes a health check, you will not see starting/healthy/unhealthy next to the status; you will only see the up time. To save space, we will format the output of the <code>docker ps</code> command with the <code>format</code> argument. Running <code>docker</code> <code>ps</code> <code>--format</code> <code>'{{.Names}}</code> <code>-</code> <code>{{.Status}}'</code> from the command line shows </p>
</div>
<div class="browsable-container listing-container" id="p219">
<div class="code-area-container">
<pre class="code-area">dockercompose9-web-1 - Up 5 minutes
dockercompose9-api-1 - Up 5 minutes
dockercompose9-postgres-1 - Up 5 minutes
dockercompose9-cloudbeaver-1 - Up 5 minutes</pre>
</div>
</div>
<div class="readable-text" id="p220">
<p>First, let’s add a health check for the Postgres container. We will update the Dockerfile with </p>
</div>
<div class="browsable-container listing-container" id="p221">
<div class="code-area-container">
<pre class="code-area">HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD pg_isready -U ${POSTGRES_USER} || exit 1</pre>
</div>
</div>
<div class="readable-text" id="p222">
<p>Notice that the command takes several parameters and that the actual work is done by the <code>CMD</code>. The <code>pg_isready</code> is a Postgres command that confirms the database is up and running. It requires a user, so we are referencing the <code>environment</code> variable we defined.</p>
</div>
<div class="readable-text intended-text" id="p223">
<p>If we rebuild following the usual procedure of removing the containers, rebuilding, and bringing them back up, then running that <code>docker ps</code> command gives us</p>
</div>
<div class="browsable-container listing-container" id="p224">
<div class="code-area-container">
<pre class="code-area">dockercompose9-web-1 - Up 11 minutes
dockercompose9-api-1 - Up 11 minutes
dockercompose9-postgres-1 - Up 11 minutes (healthy)
dockercompose9-cloudbeaver-1 - Up 11 minutes</pre>
</div>
</div>
<div class="readable-text" id="p225">
<p>We can see that the Postgres container now shows as healthy. Including health checks helps us prepare our containers for a production environment where a container orchestration tool such as Docker Swarm or Kubernetes will enable our containers to be self-healing, meaning that the containers will be able to be restarted or replaced if they fail these checks. That is a bit beyond the scope of this book though. For the time being, keep in mind the power that health checks provide and the potential difference between a health check at the application level versus health checks from the Docker perspective.</p>
</div>
<div class="readable-text" id="p226">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p227">Docker and Docker Compose can manage our environment. By building out small pieces of a project into separate containers, we can start expanding each component of our project independently.</li>
<li class="readable-text" id="p228">Evaluating team experience, project size, and risk factors is vital when determining the best approach to a project.</li>
<li class="readable-text" id="p229">Generative AI tools can increase productivity but have limitations and require verification.</li>
<li class="readable-text" id="p230">Docker creates isolated environments for efficiently managing multiple services and technologies.</li>
<li class="readable-text" id="p231">Transitioning to microservices should be based on need, not trend, as monolithic architectures can still be effective.</li>
<li class="readable-text" id="p232">Dividing a project into manageable components and ensuring initial connectivity is crucial for effective development.</li>
<li class="readable-text" id="p233">Health checks in containers provide system status monitoring and enable self-healing in production environments.</li>
<li class="readable-text" id="p234">Security and efficient management are achieved by applying the principle of least privilege and using vulnerability scanning tools.</li>
<li class="readable-text" id="p235">Container optimization is important in reducing image size and build time.</li>
<li class="readable-text" id="p236">Environment variables should be used to avoid hardcoding sensitive information such as usernames and passwords.</li>
<li class="readable-text" id="p237">Adhering to best practices in storage, application optimization, and dependency management enhances Docker’s effectiveness.</li>
</ul>
</div></body></html>