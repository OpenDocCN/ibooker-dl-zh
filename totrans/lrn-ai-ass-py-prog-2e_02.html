<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div class="readable-text" id="p1">
<h1 class="readable-text-h"><span class="calibre22"><span class="calibre22">3</span></span> <span class="calibre22">Designing functions</span></h1>
</div>
<div class="readable-text">
<h3 class="introduction-header">This chapter covers</h3>
<ul class="calibre24">
<li class="readable-text1" id="p2">Functions in Python and their role in designing software</li>
<li class="readable-text1" id="p3">The standard workflow when interacting with Copilot</li>
<li class="readable-text1" id="p4">Examples of writing good functions using Copilot</li>
<li class="readable-text1" id="p5">Reasonable tasks for Copilot to solve</li>
</ul>
</div>
<div class="readable-text" id="p6">
<p class="calibre15">One of the hardest challenges for programming novices is to know what a reasonable task is to give to Copilot so that it finds a good solution. If you give Copilot too big of a task, it will often fail in spectacular ways that can be extremely difficult to fix. What, then, is a reasonable task?</p>
</div>
<div class="readable-text" id="p7">
<p class="calibre15">This question is important for our use of Copilot but goes far beyond it. Human programmers struggle with complexity too. If experienced software engineers try to write code to solve a problem that’s too complex without breaking it down into smaller, more solvable subparts, they often have trouble as well. The solution for humans has been to use something called a <em class="calibre18">function,</em> whose job is to perform one task. Functions help us organize our code and make it easier to think about and fix any bugs. There are various rules of thumb for how to write a reasonable function in terms of number of lines of code, but, fundamentally, these rules try to capture writing something that (1) performs a single task and (2) isn’t so complex that it’s hard to get right.</p>
</div>
<div class="readable-text" id="p8">
<p class="calibre15">For people who learned to program the old-fashioned way, without Copilot, they may have struggled with syntax in code that’s 5–10 lines long before being introduced to functions. At that point, it’s natural for them to understand through experience that they shouldn’t write more code in a single function than they can handle testing and debugging. Because you’re learning to work with Copilot rather than syntax directly, our job in this chapter is to teach you about functions and what are considered reasonable and unreasonable tasks to ask Copilot to solve in a single function.</p>
</div>
<div class="readable-text" id="p9">
<p class="calibre15">To help you gain perspective on functions, we’ll provide you with a number of examples in this chapter. Those examples employ the central workflow of interacting with Copilot—specifically, the cycle of writing prompts, receiving code from Copilot, and testing to see whether that code is correct. In the functions produced by Copilot, you’ll begin to see the core programming tools, such as loops, conditionals, and lists, which we’ll expand on in the next two chapters.</p>
</div>
<div class="readable-text" id="p10">
<h2 class="readable-text-h1" id="sigil_toc_id_42"><span class="calibre22">3.1</span> Functions</h2>
</div>
<div class="readable-text" id="p11">
<p class="calibre15">Before we can learn about the details of writing a function, we need some insight into their purpose in software. Functions are small tasks that help accomplish larger tasks, which, in turn, help solve larger tasks, and so forth. You probably already have a lot of intuition about breaking apart large tasks into smaller tasks. Let’s make that intuition concrete with an example.</p>
</div>
<div class="readable-text" id="p12">
<p class="calibre15">Suppose you’ve found a word search puzzle in the newspaper that you’d like to solve (see figure 3.1 for an example puzzle). In these kinds of puzzles, you’re looking for each word in the word list. The words can be found going from left to right, right to left, top to bottom, or bottom to top.<span/></p>
</div>
<div class="browsable-container" id="p13">
<img alt="figure" src="../Images/3-1.png" class="calibre43"/>
<h5 class="figure-container-h"><span>Figure 3.1</span> Example word search puzzle</h5>
</div>
<div class="readable-text" id="p14">
<p class="calibre15">At a high level, your task is “find all the words in the word search.” Unfortunately, that description of the task isn’t helpful on its own. It doesn’t tell us what steps we need to take to solve the problem.</p>
</div>
<div class="readable-text" id="p15">
<p class="calibre15">Try working on the problem right now for a couple minutes. How did you start? How did you break down the overall task to make it more achievable?</p>
</div>
<div class="readable-text" id="p16">
<p class="calibre15">One thing you might do is say, “OK, finding every word is a big task, but a smaller task is just finding the first word (CAT). Let me work on that first!” This is an example of taking a large task and breaking it into smaller tasks. To solve the entire puzzle, then, you could repeat that smaller task for each word that you need to find.</p>
</div>
<div class="readable-text" id="p17">
<p class="calibre15">Now, how would we find an individual word, such as CAT? Even this task can be broken down further to make it easier to accomplish. For example, we could break it into four tasks: search for CAT from left to right, search for CAT from right to left, search for CAT from top to bottom, and search for CAT from bottom to top. Not only are we making simpler and simpler tasks, but we’re also organizing our work into logical pieces. Most importantly, as we’ll see throughout the chapter, it’s these simpler tasks whose code we’re going to ask Copilot to write and ultimately assemble into our complete programs.</p>
</div>
<div class="readable-text" id="p18">
<p class="calibre15">Taking a large problem and dividing it into smaller tasks is called <em class="calibre18">problem decomposition, </em>which is such an important skill in software design that we’ve dedicated all of chapter 7 to it. For now, it’s essential to know when a task is too big to ask Copilot to complete it. Asking Copilot to make a new video game that’s a combination of Wordscapes meets Wordle isn’t going to work at all. However, you can get Copilot to write a function that’s important to solve a larger problem; for example, you might have a function that checks whether the word provided by the player is present in a list of valid words. Copilot can solve that problem well, and that function would help Copilot get closer to solving the larger problem.</p>
</div>
<div class="readable-text" id="p19">
<h3 class="readable-text-h2" id="sigil_toc_id_43"><span class="calibre22">3.1.1</span> The components of a function</h3>
</div>
<div class="readable-text" id="p20">
<p class="calibre15">The origin of the name <em class="calibre18">function</em> goes back to math where functions define the output of something based on an input. For example, in high school math, you probably learned to recognize the common way to write a function as follows:</p>
</div>
<div class="readable-text" id="p21">
<p class="calibre15">f(<em class="calibre18">x</em>) = <em class="calibre18">x</em><sup class="calibre34">2</sup></p>
</div>
<div class="readable-text" id="p22">
<p class="calibre15">This is a function that is given a value for the variable <em class="calibre18">x</em> and computes the square of that value. So, we can say that when <em class="calibre18">x</em> is 6, f(<em class="calibre18">x</em>) is 36. As programming functions also have expected output for a particular input, the name is apt for programming as well.</p>
</div>
<div class="readable-text" id="p23">
<p class="calibre15">As programmers, we also like to think of functions as promises or contracts. If there is a function called <code class="calibre25">larger</code>, and we’re told that it takes two numbers and gives us the larger of the two, we have faith that when we give the function the numbers 2 and 5, it will return the answer of 5. We don’t need to see how that function works to use it, any more than we need to know how the mechanics of a car works to use the brake pedal. Press the brake pedal, and the car slows down. Give the <code class="calibre25">larger</code> function two numbers, and it gives us back the larger of the two.</p>
</div>
<div class="readable-text" id="p24">
<p class="calibre15">Every function in Python has a <em class="calibre18">function header</em> (also called a <em class="calibre18">function signature</em>), which is the first line of code of the function. Given their ubiquitous nature, we’ll want to read and write function headers. The function header describes the name of the function and its inputs. In some other languages, the function header sometimes includes information about what the output looks like, but in Python, you have to find that elsewhere in the code. </p>
</div>
<div class="readable-text" id="p25">
<p class="calibre15">In chapter 2, we wrote # comments to tell Copilot what to do. We can continue to use that approach if we want Copilot to generate a function. For example, we can use comments to ask Copilot to write a function that tells us which of two numbers is larger:</p>
</div>
<div class="browsable-container" id="p26">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17"># write a function that returns the larger of two numbers</strong>
<strong class="calibre17"># input is two numbers</strong>
<strong class="calibre17"># output is the larger of the two numbers</strong>
def larger(num1, num2):         <span/> #1
    if num1 &gt; num2:       <span/> #2
        return num1        #2
    else:                  #2
        return num2        #2</pre>
<div class="code-annotations-overlay-container">
     #1 This function header defines a function called “larger” that accepts two inputs called num1 and num2.
     <br class="calibre1"/>#2 Function body
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p27">
<p class="calibre15">As with the code in the previous chapter, we just wrote the comments to prompt Copilot to give us the code. The function header has three main components: the <code class="calibre25">def</code> keyword, which tells Python that this is a function; the name of the function; and the inputs to the function. There’s also a colon at the end of the line—be sure to include that or the code won’t be valid Python code. The word <code class="calibre25">def</code> denotes that it’s creating (defining) a function. After <code class="calibre25">def</code> is the name of the function; that name should describe the behavior of the function as well as possible. The name of this function is <code class="calibre25">larger</code>. If it’s hard to name a function because it does a bunch of different things, that’s usually a clue that it’s too big of a task for a single function (more on that later). </p>
</div>
<div class="readable-text" id="p28">
<p class="calibre15">In the parentheses of the function declaration, you’ll find the parameters. <em class="calibre18">Parameters</em> are how you provide information to a function that it needs to run. A function can have any number of parameters, and some functions have no parameters. This function has two parameters named <code class="calibre25">num1</code> and <code class="calibre25">num2</code>; there are two parameters because it needs to know the two numbers it’s comparing. </p>
</div>
<div class="readable-text" id="p29">
<p class="calibre15">There can be only one output of a function; the keyword to look for when determining what the function is outputting is <em class="calibre18">return</em>. Whatever follows <code class="calibre25">return</code> is the output of the function. In this code, either <code class="calibre25">num1</code> or <code class="calibre25">num2</code> will be returned. Functions aren’t required to return anything (e.g., a function that prints a list to the screen has no reason to return anything), so if you don’t see a return statement, it isn’t necessarily a problem because the function may be doing something else (interacting with the user, for example) rather than returning something. Functions must also either return something or not return something: they can’t return something in some cases and nothing in other cases.</p>
</div>
<div class="readable-text" id="p30">
<p class="calibre15">Although we had Copilot generate this function using # comments, this approach is actually a lot of work for Copilot. It first must get the header right, including figuring out how many parameters you need. Then, it must get the actual code of the function right. In this example, Copilot also provided the code for the function (also known as the function’s body).</p>
</div>
<div class="readable-text" id="p31">
<p class="calibre15">There’s an alternate way to prompt Copilot to write the code for a function that may help it generate code more accurately and may help us better understand exactly what we want our function to do. It involves writing a docstring, and we’ll use docstrings to write functions for the majority of the book.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p32">
<h5 class="callout-container-h">Docstrings explain function behavior </h5>
</div>
<div class="readable-text" id="p33">
<p class="calibre15"><em class="calibre18">Docstrings</em> are how Python functions are described by programmers. They follow the function header and begin and end with three double quotation marks, as shown in the upcoming code function for <code class="calibre25">larger</code>. </p>
</div>
</div>
<div class="readable-text" id="p34">
<p class="calibre15">By writing the header and docstring, you’ll make it easier for Copilot to generate the right code. In the header, you’ll be the one deciding on the name of the function and providing the names of each parameter that you want the function to use. After the function header, you’ll provide a docstring that tells Copilot what the function does. Then, just as before, Copilot will generate the code for the function. Because we gave Copilot the function header, it will be able to learn from the header and is less likely to make mistakes. Here’s what the alternate approach would look like when writing that same <code class="calibre25">larger</code> function:</p>
</div>
<div class="browsable-container" id="p35">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def larger(num1, num2): </strong>
<strong class="calibre17">    """                                     </strong><span/><strong class="calibre17"/> #1
<strong class="calibre17">    num1 and num2 are two numbers.          </strong> #1
<strong class="calibre17">                                            </strong> #1
<strong class="calibre17">    Return the larger of the two numbers.   </strong> #1
<strong class="calibre17">    """                                     </strong> #1
    if num1 &gt; num2: #1
        return num1
    else:
        return num2</pre>
<div class="code-annotations-overlay-container">
     #1 Docstring description of the function
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p36">
<p class="calibre15">Notice that we wrote the function header as well as the docstring, and Copilot supplied the body of the function.</p>
</div>
<div class="readable-text" id="p37">
<h3 class="readable-text-h2" id="sigil_toc_id_44"><span class="calibre22">3.1.2</span> Using a function</h3>
</div>
<div class="readable-text" id="p38">
<p class="calibre15">Once we have a function, how do we use it? Thinking back to our f(<em class="calibre18">x</em>) = <em class="calibre18">x</em><sup class="calibre34">2</sup> analogy, how do we give the function a value of 6 for <em class="calibre18">x</em> so that it returns 36? Let’s see how to do this with code by using that <code class="calibre25">larger</code> function we just wrote. </p>
</div>
<div class="readable-text" id="p39">
<p class="calibre15">The way to use a function is to <em class="calibre18">call</em> it. Calling a function means to invoke the function on specific values of parameters. These parameter values are called arguments. Each value in Python has a <em class="calibre18">type</em>, and we need to take care to give values of the proper type. For example, that <code class="calibre25">larger</code> function is expecting two numbers; it might not work as expected if we supply inputs that aren’t numbers. When we call a function, it runs its code and returns its result. We need to capture that result so that we can use it later; otherwise, it will be lost. To capture a result, we use a <em class="calibre18">variable</em>, which is just a name that refers to a value.</p>
</div>
<div class="readable-text" id="p40">
<p class="calibre15">Here, we ask Copilot to call the function, store the result in a variable, and then print the result: </p>
</div>
<div class="browsable-container" id="p41">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17"># call the larger function with the values 3 and 5</strong>
<strong class="calibre17"># store the result in a variable called result</strong>
<strong class="calibre17"># then print result</strong>
result = larger(3, 5)     <span/> #1
print(result)</pre>
<div class="code-annotations-overlay-container">
     #1 Calls the larger function with the values 3 and 5 as inputs and stores the result
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p42">
<p class="calibre15">The code correctly calls <code class="calibre25">larger</code>. Notice that it puts the two values we want compared after the opening parenthesis. When the function finishes, it returns a value that we assign to result. Then we print the result. If you run this program, you’ll see that the output 5 gets produced because 5 is the larger of the two values that we asked about.</p>
</div>
<div class="readable-text" id="p43">
<p class="calibre15">It’s okay if you aren’t comfortable with all the details here, but what we want you to recognize is when a function is being called, as in the following:</p>
</div>
<div class="browsable-container" id="p44">
<div class="readable-text">
<pre class="code-area">larger(3, 5)</pre>
</div>
</div>
<div class="readable-text" id="p45">
<p class="calibre15">The general format for a function call is</p>
</div>
<div class="browsable-container" id="p46">
<div class="readable-text">
<pre class="code-area">function_name(argument1, argument2, argument3,... )</pre>
</div>
</div>
<div class="readable-text" id="p47">
<p class="calibre15">So, when you see those parentheses right after a name, it means there’s a function call. Calling functions as we did here will be important to our workflow with Copilot, particularly in how we test functions to see if they are working properly. We’ll also need to call functions to get work done because functions don’t do anything until we call them.</p>
</div>
<div class="readable-text" id="p48">
<h2 class="readable-text-h1" id="sigil_toc_id_45"><span class="calibre22">3.2</span> The design cycle of functions with Copilot</h2>
</div>
<div class="readable-text" id="p49">
<p class="calibre15">Let’s introduce you to the workflow we’ll use for the next few chapters. Designing functions with Copilot involves the following cycle of steps (see figure 3.2):</p>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p50"> Determine the desired behavior of the function. </li>
<li class="readable-text1" id="p51"> Write a prompt that describes the function as clearly as possible. </li>
<li class="readable-text1" id="p52"> Allow Copilot to generate the code. </li>
<li class="readable-text1" id="p53"> Read through the code to see if it seems reasonable. </li>
<li class="readable-text1" id="p54"> Test the code to see if it’s correct: 
    <ul class="calibre29">
<li class="calibre30"> If the code is correct after multiple tests, move on. </li>
<li class="calibre30"> If the code is incorrect, move to step 2, and edit the prompt.<span/> </li>
</ul></li>
</ol>
<div class="browsable-container" id="p55">
<img alt="figure" src="../Images/3-2.png" class="calibre44"/>
<h5 class="figure-container-h"><span>Figure 3.2</span> General editing cycle with Copilot. This assumes you define a reasonable function.</h5>
</div>
<div class="readable-text" id="p56">
<p class="calibre15">We won’t learn how to do step 4 until the next chapter, but we bet you can already recognize when the code is blatantly wrong. For example, Copilot might give you only comments to fill the body of the function. Comments don’t do anything—they aren’t code—so a bunch of comments with no other code is clearly not the right thing to do. Or, Copilot might just write a single line such as <code class="calibre25">return</code> <code class="calibre25">-1</code>, or, our personal favorite, <code class="calibre25">Your</code> <code class="calibre25">code</code> <code class="calibre25">here</code>. Copilot learned that one from us professors when we provide students partial code and ask them to write the rest with “Your code here.” Those are all obviously incorrect, but in the next chapter, we’ll go over how to read code so you can more quickly spot when more complicated code is incorrect and, perhaps more importantly, see where and how to fix it. In later chapters, we’ll keep expanding on this cycle to include effective debugging practices, and we’ll keep practicing how to improve prompts.</p>
</div>
<div class="readable-text" id="p57">
<h2 class="readable-text-h1" id="sigil_toc_id_46"><span class="calibre22">3.3</span> Examples of creating good functions with Copilot</h2>
</div>
<div class="readable-text" id="p58">
<p class="calibre15">In this section, we’re going to write a bunch of functions with Copilot. We think you’ll get a much better feel for functions by seeing concrete examples, and we’ll code them entirely in Copilot to help you see the cycle of function design we just described. Although our goal in this chapter isn’t to help you read code just yet, we’ll see programming features (sometimes called <em class="calibre18">constructs</em>) in the solutions that are very common in code (e.g., <code class="calibre25">if</code> statements, loops), so we’ll point those out when we see them. Then, in chapter 4, we’ll say more about how to read this code in more detail.</p>
</div>
<div class="readable-text" id="p59">
<p class="calibre15">Many of the functions we’re about to work on are unrelated to each other. For example, we’ll start with a function about stock share prices and move to functions about strong passwords. You typically wouldn’t store unrelated stuff like this in the same Python file. Because we’re just exploring different examples of good functions, feel free to store all functions in the same Python file, perhaps named function ch3.py or function_practice.py.</p>
</div>
<div class="readable-text" id="p60">
<h3 class="readable-text-h2" id="sigil_toc_id_47"><span class="calibre22">3.3.1</span> Dan’s stock pick </h3>
</div>
<div class="readable-text" id="p61">
<p class="calibre15">Dan is an investor in a stock called AAAPL. He purchased 10 shares for $15 each. Now, each of those shares is worth $17. Dan would like to know how much money he has made on the stock.</p>
</div>
<div class="readable-text" id="p62">
<p class="calibre15">Remember that we want to make our function as general as possible. If the only thing our function does is calculate this exact AAAPL situation, it wouldn’t be that useful in general. Sure, it would help Dan right now, but what about when AAAPL’s share price changes again or when he is interested in another stock entirely?</p>
</div>
<div class="readable-text" id="p63">
<p class="calibre15">A useful general function here would take three parameters, all of which are numbers. The first parameter is the number of shares purchased, the second is the share price when the shares were purchased, and the third is the current share price. Let’s call this function <code class="calibre25">money_made</code>, because it’s going to determine how much money we’ve made or lost on the stock. In general, you want to name your function as an action word or words that describe what your function is doing. With that, we have enough to write the function header:</p>
</div>
<div class="browsable-container" id="p64">
<div class="readable-text">
<pre class="code-area">def money_made(num_shares, purchase_share_price, current_share_price):</pre>
</div>
</div>
<div class="readable-text" id="p65">
<p class="calibre15">Now, we need a docstring. In the docstring, we need to explain what each parameter is for by using its name in a sentence. We also need to include what the function is supposed to do. Adding our docstring, here is the full prompt we provide to Copilot:</p>
</div>
<div class="browsable-container" id="p66">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def money_made(num_shares, purchase_share_price, current_share_price):</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    num_shares is the number of shares of a stock that we purchased.</strong>
<strong class="calibre17">    purchase_share_price is the price of each of those shares.</strong>
<strong class="calibre17">    current_share_price is the current share price.</strong>

<strong class="calibre17">    Return the amount of money we have earned on the stock.</strong>
<strong class="calibre17">    """</strong></pre>
</div>
</div>
<div class="readable-text" id="p67">
<p class="calibre15">After typing that prompt, go to the next line, and press the Tab key. Copilot will fill in the code for the function. Don’t worry that the code gets indented: the code of functions is supposed to be indented, and, in fact, it’s an error if it isn’t! Here’s what we got from Copilot:</p>
</div>
<div class="browsable-container" id="p68">
<div class="readable-text">
<pre class="code-area">    return num_shares * (current_share_price - purchase_share_price)</pre>
</div>
</div>
<div class="readable-text" id="p69">
<p class="calibre15">This code seems sensible. In the parentheses, it figures out the difference between the current price and the purchase price (the <code class="calibre25">-</code> is used for subtraction), and then it multiplies that by the number of shares that we have (the <code class="calibre25">*</code> is used for multiplication). Inspecting code like this is a useful skill, and we’ll get serious about it in the next chapter. Another useful skill is testing the function.</p>
</div>
<div class="readable-text" id="p70">
<p class="calibre15">To test the <code class="calibre25">money_made</code> function, we call it using various inputs and observe the output in each case. We could do this by asking Copilot to call the function, and then we run our program, much as we did with our <code class="calibre25">larger</code> function. We could then ask Copilot to change the function call by asking it to call the function with a different input, and then we would run our program again, repeating as many times as needed. However, we find it easier and more convenient to call the function ourselves from an interactive window. This way, we can call the function as many times as we like without going through Copilot at all and without cluttering up our program with stuff we’re going to delete anyway. </p>
</div>
<div class="readable-text" id="p71">
<p class="calibre15">To try this interactive approach, select/highlight all the code of the function, and then press Shift-Enter (you can access a similar interactive session by selecting the text, right-clicking, and choosing Run Selection/Line in the Python window, but the guidance here is if you use Shift-Enter). Figure 3.3 shows what this looks like if you select the text of the function and press Shift-Enter.<span/></p>
</div>
<div class="browsable-container" id="p73">
<img alt="figure" src="../Images/3-3.png" class="calibre45"/>
<h5 class="figure-container-h"><span>Figure 3.3</span> Running Python in an interactive session in VS Code. Note the &gt;&gt;&gt; at the bottom of the TERMINAL tab.</h5>
</div>
<div class="readable-text" id="p74">
<p class="calibre15">At the bottom of the resulting window, you’ll see three greater-than symbols &gt;&gt;&gt;. This is called a <em class="calibre18">prompt</em>, and you’re allowed to type Python code here. (This prompt has nothing to do with the kind of prompt that we use when interacting with Copilot.) It will show us right away the result of the code that we type, which is convenient and fast.</p>
</div>
<div class="readable-text" id="p75">
<p class="calibre15">To call our <code class="calibre25">money_made</code> function, we need to provide three arguments, and they will be assigned left to right to the parameters. Whatever we put first will be assigned to <code class="calibre25">num_shares</code>, whatever we put second will be assigned to <code class="calibre25">purchase_share_price</code>, and whatever we put third will be assigned to <code class="calibre25">current_share_price</code>.</p>
</div>
<div class="readable-text" id="p76">
<p class="calibre15">Let’s try this! At the prompt, type the following, and press Enter (or Shift-Enter). Don’t type the &gt;&gt;&gt;, as that’s already there; we’re including it throughout the book to make it clear where we’re typing. Figure 3.4 shows an example of running the function in the terminal at the Python prompt:</p>
</div>
<div class="browsable-container" id="p77">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; money_made(10, 15, 17)</pre>
</div>
</div>
<div class="readable-text" id="p78">
<p class="calibre15">You’ll see the following output:</p>
</div>
<div class="browsable-container" id="p79">
<div class="readable-text">
<pre class="code-area">20</pre>
</div>
</div>
<div class="readable-text" id="p80">
<p class="calibre15">Is <code class="calibre25">20</code> correct? Well, we bought 10 shares, and each of them went up $2 (from $15 to $17), so we did make $20. Looks good!<span/></p>
</div>
<div class="browsable-container" id="p81">
<img alt="figure" src="../Images/3-4.png" class="calibre46"/>
<h5 class="figure-container-h"><span>Figure 3.4</span> Calling the <code class="calibre25">money_made</code> function from the Python prompt in the VS Code terminal</h5>
</div>
<div class="readable-text" id="p82">
<p class="calibre15">We’re not done testing, though. When testing a function, you want to test it in various ways, not just once. All one test case tells you is that it happened to work with the particular input values that you provided. The more test cases we try, each testing the function in a different way, the more confident we are that our function is correct.</p>
</div>
<div class="readable-text" id="p83">
<p class="calibre15">How do we test this function in a different way? We’re looking for inputs that are somehow a different <em class="calibre18">category</em> of input. One not-so-good test right now would be to say, “What if our stock went from $15 to $18, instead of $15 to $17?” This is pretty much the same test as before, and chances are that it will work just fine.</p>
</div>
<div class="readable-text" id="p84">
<p class="calibre15">A good idea is to test what happens when the stock actually <em class="calibre18">loses </em>money. We expect to get a negative return value in this case. And it appears that our function works just fine with this category of test. Here’s our function call and the output returned to us:</p>
</div>
<div class="browsable-container" id="p85">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; money_made(10, 17, 15)
-20</pre>
</div>
</div>
<div class="readable-text" id="p86">
<p class="calibre15">What other tests can we do? Well, sometimes a stock price doesn’t change at all. We expect 0 in this case. Let’s verify it:</p>
</div>
<div class="browsable-container" id="p87">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; money_made(10, 15, 15)  
0</pre>
</div>
</div>
<div class="readable-text" id="p88">
<p class="calibre15">Looks good! Testing is a combination of science and art. How many categories of things are there to test? Are these two calls really two different categories? Have we missed any categories? You’ll improve your testing ability through practice, and we’ll spend all of chapter 6 talking about testing. For now, it looks like our <code class="calibre25">money_made</code> function is doing its job.</p>
</div>
<div class="readable-text" id="p89">
<p class="calibre15">It’s possible for a function to use variables (rather than just its parameters) in its code, and we want to show you an example of that now so that you’re ready when you see Copilot doing it. Here’s an equivalent way to write the code for our <code class="calibre25">money_made</code> function:</p>
</div>
<div class="browsable-container" id="p90">
<div class="readable-text">
<pre class="code-area">    price_difference = current_share_price - purchase_share_price
    return num_shares * price_difference</pre>
</div>
</div>
<div class="readable-text" id="p91">
<p class="calibre15">This code may even be easier to read for you: it first figures out the difference in share price, and then it multiplies that by the number of shares. We encourage you to test this version to help convince yourself that it’s still correct.</p>
</div>
<div class="readable-text" id="p92">
<h3 class="readable-text-h2" id="sigil_toc_id_48"><span class="calibre22">3.3.2</span> Leo’s password</h3>
</div>
<div class="readable-text" id="p93">
<p class="calibre15">Leo is signing up for a new social network website called ProgrammerBook. He wants to make sure that his password is strong.</p>
</div>
<div class="readable-text" id="p94">
<p class="calibre15">Leo starts with a modest definition of what it means for a password to be strong: it’s strong if it’s not the word <em class="calibre18">password</em> and not the word <em class="calibre18">qwerty</em>. Those are terrible passwords, for sure, but in reality, we have to do way better than this definition to ensure that our password is strong! A helpful function would be one that takes a proposed password and tells us whether it’s strong or not.</p>
</div>
<div class="readable-text" id="p95">
<p class="calibre15">Unlike our previous functions in this chapter, we’re not dealing with numbers here. The parameter, the password to check, is text. And the return value is supposed to indicate some yes/no result. We need new types!</p>
</div>
<div class="readable-text" id="p96">
<p class="calibre15">The Python type for text is called a <em class="calibre18">string</em>. There are zillions of possible strings because we can use a string to store whatever text we want. The Python type for a yes/no result is called a <em class="calibre18">Boolean</em> or <em class="calibre18">bool</em>. A bool has only two values: <code class="calibre25">True</code> or <code class="calibre25">False</code>.</p>
</div>
<div class="readable-text" id="p97">
<p class="calibre15">Alright! We’re ready to prompt Copilot. For functions that return bool (<code class="calibre25">True</code>/<code class="calibre25">False</code>) values, we usually name the function as <code class="calibre25">has_x</code>, <code class="calibre25">is_x</code>, or similar using some other verb that implies a true/false result:</p>
</div>
<div class="browsable-container" id="p98">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def is_strong_password(password):</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    A strong password is not the word 'password'</strong>
<strong class="calibre17">    and is not the word 'qwerty'.</strong>
<strong class="calibre17">    Return True if the password is a strong password, False if not.</strong>
<strong class="calibre17">    """</strong></pre>
</div>
</div>
<div class="readable-text" id="p99">
<p class="calibre15">In response, here’s what Copilot wrote for us:</p>
</div>
<div class="browsable-container" id="p100">
<div class="readable-text">
<pre class="code-area">    return password != 'password' and password != 'qwerty'</pre>
</div>
</div>
<div class="readable-text" id="p101">
<p class="calibre15">Look over that code for a moment. That <code class="calibre25">!=</code> operator is the “not equal” operator, and each string that doesn’t count as a strong password is in single quotation marks. We’re going to use quotation marks every time we need to specify a specific string value. Again, we’ll talk more about how to read code in the next chapter, but for now, we hope that the code makes a fuzzy sort of sense: it looks like it’s checking that the password isn’t <code class="calibre25">password</code> and isn’t <code class="calibre25">qwerty</code>, which matches our definition of a strong password.</p>
</div>
<div class="readable-text" id="p102">
<p class="calibre15">Now let’s make sure that this function does indeed work by making a few test calls. We’ll start by testing the passwords that aren’t strong. We had better get back <code class="calibre25">False</code> for each of these—and we do:</p>
</div>
<div class="browsable-container" id="p103">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; is_strong_password('password')        
False      

&gt;&gt;&gt; is_strong_password('qwerty')          
False</pre>
</div>
</div>
<div class="readable-text" id="p104">
<p class="calibre15">Good! Now, let’s try a strong password. We need to see <code class="calibre25">True</code> here:</p>
</div>
<div class="browsable-container" id="p105">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; is_strong_password('N3w Y0rk J375')    
True</pre>
</div>
</div>
<div class="readable-text" id="p106">
<p class="calibre15">Good stuff! We now see that the function sometimes returns <code class="calibre25">False</code> and other times returns <code class="calibre25">True</code>, so at least it’s not always returning <code class="calibre25">False</code>. Let’s try one more:</p>
</div>
<div class="browsable-container" id="p107">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; is_strong_password('Leo') 
True</pre>
</div>
</div>
<div class="readable-text" id="p108">
<p class="calibre15">Well, technically <code class="calibre25">True</code> is correct, but, wow, is <code class="calibre25">Leo</code> a bad password. We should really have done better with our definition of a strong password. Let’s change our prompt to give a more reasonable definition of what it means for a password to be strong. Here’s our next prompt and what Copilot gave us:</p>
</div>
<div class="browsable-container" id="p109">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def is_strong_password(password):</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    A strong password has at least one uppercase character,</strong>
<strong class="calibre17">    at least one number, and at least one special symbol.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Return True if the password is a strong password, False if not.</strong>
<strong class="calibre17">    """</strong>
    return any(char.isupper() for char in password) and \
             any(char.isdigit() for char in password) and \
             any(not char.isalnum() for char in password)</pre>
</div>
</div>
<div class="readable-text" id="p110">
<p class="calibre15">That <code class="calibre25">for</code> <code class="calibre25">char</code> <code class="calibre25">in</code> <code class="calibre25">password</code> that shows up a few times here is a way for Python to consider each character of the password. It enables something called a <em class="calibre18">loop</em>, which is a key topic that we’ll study in chapter 5.</p>
</div>
<div class="readable-text" id="p111">
<p class="calibre15">Of course, it’s possible that you didn’t get the same code from Copilot as we did. But based on the code that we got, it looks like the first piece is looking for any uppercase character, the second piece is looking for any digit, and the third is looking for something that’s not an <code class="calibre25">isalnum</code>.</p>
</div>
<div class="readable-text" id="p112">
<p class="calibre15">Maybe <code class="calibre25">isalnum</code> means “is alphanumeric.” Does that include special symbols, and, if so, which ones? Let’s test this function to see how well we’re doing:</p>
</div>
<div class="browsable-container" id="p113">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; is_strong_password('Leo')
False

&gt;&gt;&gt; is_strong_password('N3w Y0rk J37$')
True

&gt;&gt;&gt; is_strong_password('N3w Y0rk J375')
True</pre>
</div>
</div>
<div class="readable-text" id="p114">
<p class="calibre15">Uh-oh! We got the wrong answer for that third password. It looks pretty strong, but it’s not, because it lacks a special symbol. Our function returned <code class="calibre25">True</code>, but that’s the wrong return value: it was supposed to return <code class="calibre25">False</code>.</p>
</div>
<div class="readable-text" id="p115">
<p class="calibre15">The code that Copilot gave us is wrong. Maybe the code that you got worked fine, but we didn’t get so lucky, and it’s important we know how to identify (like we just did) when the code is wrong and then fix it. It’s not important to know why it’s wrong right now, but if you’re curious about why our prompt may have given us the wrong behavior, it’s because we didn’t specify what we meant by a special character, and the code it gave us counts spaces as special characters.</p>
</div>
<div class="readable-text" id="p116">
<p class="calibre15">At this point, as we begin to troubleshoot our wrong code, we have two options. One option is to press Ctrl-Enter and look through the other suggestions that Copilot gives us. Maybe one of those suggestions will have something to do with special symbols that looks different from the one that didn’t work?</p>
</div>
<div class="readable-text" id="p117">
<p class="calibre15">Indeed, on our computer here, we see such options, including this one:</p>
</div>
<div class="browsable-container" id="p118">
<div class="readable-text">
<pre class="code-area">    num_upper = 0
    num_num = 0
    num_special = 0
    for char in password:
        if char.isupper():
            num_upper += 1
        elif char.isnumeric():
            num_num += 1
        elif char in '!@#$%^&amp;*':    <span/> #1
            num_special += 1
    if num_upper &gt;= 1 and num_num &gt;= 1 and num_special &gt;= 1:
        return True
    else:
        return False</pre>
<div class="code-annotations-overlay-container">
     #1 Specific choice of special symbols
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p119">
<p class="calibre15">Test this function with strings such as <code class="calibre25">Leo</code>, <code class="calibre25">N3w</code> <code class="calibre25">Y0rk</code> <code class="calibre25">J375</code>, and <code class="calibre25">N3w</code> <code class="calibre25">Y0rk</code> <code class="calibre25">J375$</code> and you should see that the function works well.</p>
</div>
<div class="readable-text" id="p120">
<p class="calibre15">Our second option is to do some prompt engineering, which means adjusting our prompt to influence what Copilot gives us. In our original prompt, we talked about special symbols. This, in retrospect, is vague. We probably meant something more specific, such as punctuation. If we specifically talk about punctuation in our prompt, we get this interaction with Copilot:</p>
</div>
<div class="browsable-container" id="p121">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def is_strong_password(password):</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    A strong password has at least one uppercase character,</strong>
<strong class="calibre17">    at least one number, and at least one punctuation.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Return True if the password is a strong password, False if not.</strong>
<strong class="calibre17">    """</strong>
    return any(char.isupper() for char in password) and \
           any(char.isdigit() for char in password) and \
           any(char in string.punctuation for char in password)</pre>
</div>
</div>
<div class="readable-text" id="p122">
<p class="calibre15">Looks good! That last line is talking about punctuation, which is hopeful. Let’s test it here:</p>
</div>
<div class="browsable-container" id="p123">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; is_strong_password('Leo')
False

&gt;&gt;&gt; is_strong_password('N3w Y0rk J375')
 Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "ch2.py", line 44, in is_strong_password
    any(char in string.punctuation for char in password)
  File "ch2.py", line 44, in &lt;genexpr&gt;
    any(char in string.punctuation for char in password)
                ^^^^^^
NameError: name 'string' is not defined</pre>
</div>
</div>
<div class="readable-text" id="p124">
<p class="calibre15">Looking at the bottom of that error message, you’ll see that <code class="calibre25">'string'</code> isn’t defined. Copilot wants to use a module, called <code class="calibre25">string</code>, but it’s a module that needs to be imported before we can use it. This “not defined” result can happen for various types of errors related to names not being found, and oftentimes the culprit is a module that hasn’t been imported. There are a lot of modules in Python, but the <code class="calibre25">string</code> module is well known. As you work with Copilot more, you’ll learn which modules are commonly used so you know to import them. You could also do a quick internet search to ask, “Is string a Python module,” and the results would confirm that it is. What we need to do is import the module.</p>
</div>
<div class="readable-text" id="p125">
<p class="calibre15">Note that this is similar to what happened in the code that Copilot generated for us in chapter 2. Back then, Copilot was using the csv module, which is a module already installed with Python. The string module is similarly included with Python; Copilot just forgot to import it. As we discussed in chapter 2, some modules do need to be manually installed, but the string module isn’t one of them. So, we don’t need to install string; we just have to import it.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p126">
<h5 class="callout-container-h">Importing modules </h5>
</div>
<div class="readable-text" id="p127">
<p class="calibre15">There are a number of useful modules available in Python. In chapter 2, Copilot used the csv module to make it easier to deal with comma-separated values (CSV) files. But for Python code to take advantage of a module, we have to import that module. You might ask why we don’t have modules available to us without importing them, but that would massively increase the complexity of the code and what Python has to do to run code behind the scenes. Instead, the model is to include modules if you want to use them, and they aren’t included by default.</p>
</div>
</div>
<div class="readable-text" id="p128">
<p class="calibre15">Let’s add <code class="calibre25">import</code> <code class="calibre25">string</code> at the top of our code:</p>
</div>
<div class="browsable-container" id="p129">
<div class="readable-text">
<pre class="code-area">import string

<strong class="calibre17">def is_strong_password(password):</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    A strong password has at least one uppercase character,</strong>
<strong class="calibre17">    at least one number, and at least one punctuation.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Return True if the password is a strong password, False if not.</strong>
<strong class="calibre17">    """</strong>
    return any(char.isupper() for char in password) and \
           any(char.isdigit() for char in password) and \
           any(char in string.punctuation for char in password)</pre>
</div>
</div>
<div class="readable-text" id="p130">
<p class="calibre15">Now we’re in good shape:</p>
</div>
<div class="browsable-container" id="p131">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; is_strong_password('Leo')
False

&gt;&gt;&gt; is_strong_password('N3w Y0rk J375')
False

&gt;&gt;&gt; is_strong_password('N3w Y0rk J375$')
True</pre>
</div>
</div>
<div class="readable-text" id="p132">
<p class="calibre15">That last one is <code class="calibre25">True</code>. It’s a strong password because it has the <code class="calibre25">$</code> punctuation added to it. </p>
</div>
<div class="readable-text" id="p133">
<p class="calibre15">We hope that you’re now convinced of the value of testing. Sometimes, new programmers don’t test their code. They assume that the code they write is correct because it made sense to them. An interesting difference between novice and experienced programmers is that novices often assume their code is right, whereas experienced programmers assume their code is wrong until thoroughly tested and proved otherwise. Beyond this, we find that new programmers sometimes fail to test well because it’s disheartening to learn that the code is wrong. But it’s better to know now rather than later when others are using your code in a serious application. Finding errors through testing is actually a good thing.</p>
</div>
<div class="readable-text" id="p134">
<h3 class="readable-text-h2" id="sigil_toc_id_49"><span class="calibre22">3.3.3</span> Getting a strong password</h3>
</div>
<div class="readable-text" id="p135">
<p class="calibre15">Now that we have a function that tells us whether a password is strong or not, let’s write a function that obtains a strong password from the user. It will ask again and again for a password until the user types a strong one. This is the kind of code that websites use when they tell you, “Sorry, your password is too weak, try again.”</p>
</div>
<div class="readable-text" id="p136">
<p class="calibre15">What should the header for such a function look like? Well, it’s going to ask the user for a password, but we won’t have a password parameter. In fact, we won’t have any parameters at all because the function doesn’t need any information to do its job—it just has to prompt the user, and the user will type the password at the keyboard. When the function has done its work, it will return the strong password, so it will continue to return a string as the output. Let’s try this prompt:</p>
</div>
<div class="browsable-container" id="p137">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def get_strong_password():</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    Keep asking the user for a password until it’s a strong </strong>
<strong class="calibre17">    password, and return that strong password.</strong>
<strong class="calibre17">    """</strong></pre>
</div>
</div>
<div class="readable-text" id="p138">
<p class="calibre15">We get the following code from Copilot as a result:</p>
</div>
<div class="browsable-container" id="p139">
<div class="readable-text">
<pre class="code-area">    password = input("Enter a strong password: ")
    while not is_strong_password(password):           <span/> #1
        password = input("Enter a strong password: ")
    return password</pre>
<div class="code-annotations-overlay-container">
     #1 It’s calling our earlier is_strong_password function!
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p140">
<p class="calibre15">That <code class="calibre25">while</code> keyword creates another kind of loop, this one continuing as long as the entered password isn’t strong. Copilot is also smart enough to call our earlier <code class="calibre25">is_strong_password</code> function to determine what counts as a strong password. As you’ll see in future chapters, using functions as building blocks in this way is precisely how large programs are built. You’ll often notice Copilot calling your earlier functions to solve later ones, much as we observed here.</p>
</div>
<div class="readable-text" id="p141">
<p class="calibre15">Let’s test this! Highlight all the code from our two password functions, and press Shift-Enter. We’ll call the function that we want to test. Then, try typing passwords, pressing Enter after each one. You’ll notice that it keeps asking until you finally provide a strong password:</p>
</div>
<div class="browsable-container" id="p142">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; get_strong_password()
Enter a strong password: Leo
Enter a strong password: N3w Y0rk J375
Enter a strong password: N3w Y0rk J375$
'N3w Y0rk J375$'</pre>
</div>
</div>
<div class="readable-text" id="p143">
<p class="calibre15">Notice that it stops asking us for a password when we finally provide a strong password. Then, we see the string in quotes that it returned, which is, indeed, our strong password.</p>
</div>
<div class="readable-text" id="p144">
<h3 class="readable-text-h2" id="sigil_toc_id_50"><span class="calibre22">3.3.4</span> Scrabble scoring</h3>
</div>
<div class="readable-text" id="p145">
<p class="calibre15">One of Dan’s favorite board games is Scrabble. Have you played it? If not, all you need to know is that you have some tiles in your hand, each with a letter on it, and your goal is to form a word using any combination of those letters. You don’t need to form the word exclusively with your tiles—you can attach those letters to existing letters on the board to create longer words—but we’re not going to worry about that here. The important thing for us is that different letters are worth different numbers of points. For example, an <em class="calibre18">a</em> is worth only 1 point because <em class="calibre18">a</em> is such a common letter. But <em class="calibre18">q </em>and <em class="calibre18">z</em>? Those doozies are each worth 10 points because they’re so tough to use—or should we say <em class="calibre18">puzzling</em> to use. Yeah, that’s better.</p>
</div>
<div class="readable-text" id="p146">
<p class="calibre15">To calculate the score for a word, we add up the scores for each of its letters. For example, the score for <em class="calibre18">zap</em> would be 14. That’s because <em class="calibre18">z</em> is worth 10, <em class="calibre18">a</em> is worth 1, and <em class="calibre18">p</em> is worth 3.</p>
</div>
<div class="readable-text" id="p147">
<p class="calibre15">Dan would like a function that, given a word, tells him how many points that word is worth. OK, so we need a function that takes a word (which is just one parameter). Let’s try this prompt, where we’ve included the number of points that each letter is worth per official Scrabble rules:</p>
</div>
<div class="browsable-container" id="p148">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def num_points(word): </strong>
<strong class="calibre17">    """ </strong>
<strong class="calibre17">    Each letter is worth the following points: </strong>
<strong class="calibre17">    a, e, i, o, u, l, n, s, t, r: 1 point </strong>
<strong class="calibre17">    d, g: 2 points </strong>
<strong class="calibre17">    b, c, m, p: 3 points </strong>
<strong class="calibre17">    f, h, v, w, y: 4 points </strong>
<strong class="calibre17">    k: 5 points </strong>
<strong class="calibre17">    j, x: 8 points </strong>
<strong class="calibre17">    q, z: 10 points </strong>

<strong class="calibre17">    word is a word consisting of lowercase characters. </strong>
<strong class="calibre17">    Return the sum of points for each letter in word. </strong>
<strong class="calibre17">    """</strong></pre>
</div>
</div>
<div class="readable-text" id="p149">
<p class="calibre15">For this function, Copilot isn’t filling in the whole body for us with one press of the Tab key. Tab is also used to indent the code, which we also need to do here before Copilot will present us with code. So, we’re having to press Tab (sometimes once for the indentation and then again for Copilot), wait for the code to appear, then press Tab to accept that code, then press Enter again for more code to be presented, and repeat the process.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p150">
<h5 class="callout-container-h">Getting Copilot to suggest code may require pressing Tab or Enter </h5>
</div>
<div class="readable-text" id="p151">
<p class="calibre15">We find that Copilot will sometimes pause in giving suggestions until you press a key to help prompt it. As mentioned in table 2.1, if you’re giving it comments, Copilot will sometimes just want to give you more comments as suggestions. Pressing Enter another time can often trigger it to start generating code instead. Other times, pressing Tab will cause it to continue providing suggestions. Refer to table 2.1 if Copilot isn’t generating code for you.</p>
</div>
</div>
<div class="readable-text" id="p152">
<p class="calibre15">Finally, after doing that a few times, the entire code unfurls, and we get the following:</p>
</div>
<div class="browsable-container" id="p153">
<div class="readable-text">
<pre class="code-area">    points = 0
    for char in word:
        if char in "aeioulnstr":
            points += 1
        elif char in "dg":
            points += 2
        elif char in "bcmp":
            points += 3
        elif char in "fhvwy":
            points += 4
        elif char == "k":
            points += 5
        elif char in "jx":
            points += 8
        elif char in "qz":
            points += 10
    return points</pre>
</div>
</div>
<div class="readable-text" id="p154">
<p class="calibre15">Notice that all the letters of the alphabet are accounted for here, and the number of points that each category is worth is on the following line. We’ll discuss this overall kind of decision structure in the next chapter, but, at a high level, it’s walking through the word character by character and, for each character, figuring out which letter it is and adding the appropriate number of points for that letter.</p>
</div>
<div class="readable-text" id="p155">
<p class="calibre15">Let’s test this to make sure our code is performing the way we want. We know that the word <em class="calibre18">zap</em> should be worth 14 points, and it is:</p>
</div>
<div class="browsable-container" id="p156">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; num_points('zap')
14</pre>
</div>
</div>
<div class="readable-text" id="p157">
<p class="calibre15">Let’s try a couple more. In each case, calculate by hand what you expect the answer to be—that way, you’ll know if the code is doing the right thing:</p>
</div>
<div class="browsable-container" id="p158">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; num_points('pack')
12

&gt;&gt;&gt; num_points('quack') 
20</pre>
</div>
</div>
<div class="readable-text" id="p159">
<p class="calibre15">There are many ways to write correct code for a function. If you press Ctrl-Enter and look at the Copilot suggestions, you may see different types of code. It doesn’t necessarily mean that one of these types is right and the others are wrong. For example, here’s another solution for <code class="calibre25">num_points</code> that we got from the other Copilot suggestions:</p>
</div>
<div class="browsable-container" id="p160">
<div class="readable-text">
<pre class="code-area">    points = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'l': 1, 
              'n': 1, 's': 1, 't': 1, 'r': 1,
              'd': 2, 'g': 2,
              'b': 3, 'c': 3, 'm': 3, 'p': 3,
              'f': 4, 'h': 4, 'v': 4, 'w': 4, 'y': 4,
              'k': 5,
              'j': 8, 'x': 8,
              'q': 10, 'z': 10}
    return sum(points[char] for char in word)</pre>
</div>
</div>
<div class="readable-text" id="p161">
<p class="calibre15">Notice here that each letter is listed individually along with its number of points. This structure with the letters and points is called a <em class="calibre18">dictionary</em>, and again, you’ll learn about dictionaries properly in a later chapter. The point for now is just that there are often multiple, equivalently good ways for Copilot to write the code for a function. Give this one a try with some test cases before you continue!</p>
</div>
<div class="readable-text" id="p162">
<h3 class="readable-text-h2" id="sigil_toc_id_51"><span class="calibre22">3.3.5</span> The best word</h3>
</div>
<div class="readable-text" id="p163">
<p class="calibre15">Let’s continue with the Scrabble theme. Suppose that Dan has a bunch of words that he can make right now, but he doesn’t know which one will give him the most points. Should he make the word <em class="calibre18">zap</em>, <em class="calibre18">pack</em>, or <em class="calibre18">quack</em>? It would be nice if we had a function that could take a bunch of words and tell us which is the best one.</p>
</div>
<div class="readable-text" id="p164">
<p class="calibre15">How many parameters should we have in such a function? Your first instinct may be three parameters, one for each of the 3 words in our options. But that wouldn’t be very flexible. After all, what if we want to know the best of 5 words, 10 words, or 50 words? We would like our function to work no matter how many words we’re considering.</p>
</div>
<div class="readable-text" id="p165">
<p class="calibre15">The trick is to use a function with one (yes, just one!) parameter, which is a <em class="calibre18">list</em> of words. Just like numbers, strings, and dictionaries, a <code class="calibre25">list</code> is a type supported by Python. It’s incredibly useful because it allows us to collect as many values into one place as we like. We can prompt Copilot like this to get the function that we want:</p>
</div>
<div class="browsable-container" id="p166">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def best_word(word_list):</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    word_list is a list of words.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return the word worth the most points.</strong>
<strong class="calibre17">    """</strong></pre>
</div>
</div>
<div class="readable-text" id="p167">
<p class="calibre15">How will Copilot know how many points each word is worth? Well, it can call that <code class="calibre25">num_points</code> function that we wrote in the previous section! Here’s the code that Copilot gives us:</p>
</div>
<div class="browsable-container" id="p168">
<div class="readable-text">
<pre class="code-area">    best_word = ""
    best_points = 0
    for word in word_list:
        points = num_points(word)
        if points &gt; best_points:
            best_word = word
            best_points = points
    return best_word</pre>
</div>
</div>
<div class="readable-text" id="p169">
<p class="calibre15">We need to be careful to call this function correctly when testing. Using </p>
</div>
<div class="browsable-container" id="p170">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; best_word('zap', 'pack', 'quack')</pre>
</div>
</div>
<div class="readable-text" id="p171">
<p class="calibre15">won’t work because that’s passing values for three parameters, not one. The right way to call it is to put the words inside square brackets, like this (we’ll see more about lists in the next chapter):</p>
</div>
<div class="browsable-container" id="p172">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; best_word(['zap', 'pack', 'quack'])  
'quack'</pre>
</div>
</div>
<div class="readable-text" id="p173">
<p class="calibre15">But, as usual, you shouldn’t be content with just one test case. This function should work in other valid but perhaps strange cases too, such as when we have only one word in the list:</p>
</div>
<div class="browsable-container" id="p174">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; best_word(['zap'])
'zap'</pre>
</div>
</div>
<div class="readable-text" id="p175">
<p class="calibre15">However, we wouldn’t test this function on a list that has no words in it. What would it even make sense to do in that case? Regardless of what the function does, it’d be hard to say one way or the other whether it was doing the correct thing in a situation where there really is no correct behavior!</p>
</div>
<div class="readable-text" id="p176">
<h2 class="readable-text-h1" id="sigil_toc_id_52"><span class="calibre22">3.4</span> Benefits of functions</h2>
</div>
<div class="readable-text" id="p177">
<p class="calibre15">Now that you’ve seen a number of functions, we hope you’re starting to get a feel for how functions are used in software. We already mentioned that functions are critical in performing problem decomposition. Beyond problem decomposition, functions are valuable in software for a number of other reasons, including the following:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p178"> <em class="calibre18"/><em class="calibre18">Cognitive load —</em>You may have heard of cognitive load [1] before. It’s the amount of information your brain can handle at any given time and still be effective. If you’re given four random words and asked to repeat them back, you might be able to do that. If you’re given the same task with 20 words, most of us would fail because it’s too much information to handle at once. Similarly, if you’ve ever been on a road trip with your family and are trying to optimize the travel time, combined with stops for the kids, lunch breaks, bathroom stops, gas station stops, good locations for hotels, and so on, you might have felt your head swimming to manage all those constraints at once. That point when you can’t handle it all at once is when you’ve exceeded your own brain’s processing power. Programmers have the same problem. If they are trying to do too much at once or solve too complex a problem in one piece of code, they struggle to do it correctly. Functions are designed to help programmers avoid doing too much work at once. </li>
<li class="readable-text1" id="p179"> <em class="calibre18"/><em class="calibre18">Avoid repetition —</em>Programmers (and, we’d argue, humans in general) aren’t very excited about solving the same problem over and over. If I write a function that can correctly compute the area of a circle once, I don’t need to write that code ever again. That means if I have two sections of my code that need to compute the area of a circle, I’d write one function that computes the area of the circle, and then I’d have my code call that function in each of those two places. </li>
<li class="readable-text1" id="p180"> <em class="calibre18">Improve </em><em class="calibre18"/><em class="calibre18">testing —</em>It’s a lot harder to test a section of code that does multiple things compared to code that does one thing. Programmers use a variety of testing techniques, but a key technique is known as <em class="calibre18">unit testing</em>. Every function takes some input and produces some output. For a function that computes the area of a circle, for example, the input would be the circle’s radius, and the output would be its area. Unit tests give a function an input and then compare that input to the desired result. For the area-of-a-circle function, we might test it by giving it varying inputs (e.g., some small positive numbers, some large positive numbers, and 0) and compare the result of the function against the values we know to be correct. If the answers from the function match what we expect, we have a higher degree of confidence that the code is correct. If the code produces a mistake, we won’t have much code to check to find and fix the problem. But if a function does more than one task, it vastly complicates the testing process because you need to test each task and the interaction of those tasks. </li>
<li class="readable-text1" id="p181"> <em class="calibre18"/><em class="calibre18">Improve reliability —</em>When we write code as experienced software engineers, we know we make mistakes. We also know Copilot makes mistakes. If you imagine you’re an amazing programmer and each line of code you write is 95% likely to be correct, how many lines of code do you think you can write before at least one of those lines is likely to be incorrect? The answer is only 14. We think 95% correctness per line is probably a high bar for even experienced programmers and is likely a higher bar than what Copilot produces. By keeping the tasks small, tasks solvable in 12–20 lines of code, we reduce the likelihood that there’s an error in the code. If combined with good testing as noted previously, we can feel even more confident that the code is correct. Last, nothing is worse than code that has multiple mistakes that interact together, and the likelihood of multiple mistakes grows the more code you write. Both of us have been on multi-hour debugging expeditions because our code had more than one mistake, and we both became a lot better at frequent testing of short pieces of code as a result! </li>
<li class="readable-text1" id="p182"> <em class="calibre18"/><em class="calibre18">Improve code readability —</em>In this book, we mostly use Copilot to write code from scratch, but that’s not the only way to use Copilot. If you have a larger piece of software that you or your coworkers are all editing and using, Copilot can jump in to help write code for that too. It’s in everyone’s interest to understand the code, whether most of it is written by humans or by Copilot. That way, we can find bugs more easily, determine what code to start modifying when we want to add new features, and understand at a high level what would be easy or difficult to achieve with our overall program design. Having tasks broken down into functions helps us understand what each part of the code is doing so we can gain better insight into how it all works together. It also helps divide up the work and responsibility for ensuring the code is correct. </li>
</ul>
<div class="readable-text" id="p183">
<p class="calibre15">These benefits are huge for programmers. Programming languages haven’t always had functions. But even before they did, programmers did their best to use other features to mimic functions. They were ugly hacks (google “goto statements” if you’re interested), and all programmers are happy that we have proper functions now.</p>
</div>
<div class="readable-text" id="p184">
<p class="calibre15">You may be asking, “I see how these advantages matter to humans, but how do they affect Copilot?” In general, we believe all the principles that apply to humans apply to Copilot, albeit sometimes for different reasons. Copilot may not have cognitive load, but it’s going to do better when we ask it to solve problems similar to what’s been done by humans before. Because humans write functions to solve tasks, Copilot will mimic that and write functions as well. Once we’ve written and tested a function, whether by hand or by Copilot, we don’t want to write it again. Knowing how to test if your program is working properly is just as essential for code produced by humans as it is by Copilot. Copilot is as likely to make mistakes when it generates code, so we want to catch those mistakes quickly, just as we do with human-written code. Even if you only work on your own code and never have anyone else read it, you’ll often have to go back years later to edit what you’ve written. Having done this ourselves, we can attest that it’s important for your code to be readable for your future self!</p>
</div>
<div class="readable-text" id="p185">
<h2 class="readable-text-h1" id="sigil_toc_id_53"><span class="calibre22">3.5</span> Roles of functions</h2>
</div>
<div class="readable-text" id="p186">
<p class="calibre15">Functions are used in many different roles in programming. At a high level, programs are functions that (often) call other functions. Critically, all programs, including Python programs, originate with a single function (named <code class="calibre25">main</code> in languages such as Java, C, and C++). Python’s <code class="calibre25">main</code> function is essentially the first line of code that isn’t in a function. But if every program starts with a single function and trying to solve a large problem with a single function is a mistake, how does that work? Well, <code class="calibre25">main</code> will call other functions, which, in turn, will call other functions, and so forth. The code will still execute (mostly) sequentially in each function, so it may start in <code class="calibre25">main</code> but then move to another function, and so on.</p>
</div>
<div class="readable-text" id="p187">
<p class="calibre15">As an example, let’s use the code in the following listing. We wrote this code, not Copilot, because no one would ever want to write this code for anything useful outside of teaching. It’s just for demonstrating how function calls work.</p>
</div>
<div class="browsable-container" id="p188">
<h5 class="listing-container-h"><span>Listing 3.1</span> Code to demonstrate how Python handles function calls</h5>
<div class="readable-text">
<pre class="code-area">def funct1():
    print("there")
    funct2()
    print("friend")
    funct3()
    print("")

def funct2():
    print("my")

def funct3():
    print(".")

def funct4():
    print("well")
print("Hi")     <span/> #1
funct1()
print("I'm")
funct4()
funct3()
print("")
print("Bye.")</pre>
<div class="code-annotations-overlay-container">
     #1 This is the start of the program. We’ll call this “main” after the main function in other languages.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p189">
<p class="calibre15">If we ran this program, the output would be (we’ll explain why next):</p>
</div>
<div class="browsable-container" id="p190">
<div class="readable-text">
<pre class="code-area">Hi
there
my
friend
.

I'm
well
.

Bye.</pre>
</div>
</div>
<div class="readable-text" id="p191">
<p class="calibre15">In figure 3.5, we provide a diagram of how the code in listing 3.1 would be executed by the computer. We’ve intentionally provided an example that has many function calls to tie together what we just learned. Again, this is <em class="calibre18">not</em> practical code; it’s just for learning purposes. Let’s trace through the code execution together. It may be easier to refer to figure 3.5 than listing 3.1 as you follow along, but either will work.<span/></p>
</div>
<div class="browsable-container" id="p192">
<img alt="figure" src="../Images/3-5.png" class="calibre47"/>
<h5 class="figure-container-h"><span>Figure 3.5</span> Flow of function execution in our example from listing 3.1</h5>
</div>
<div class="readable-text" id="p193">
<p class="calibre15">The program will start execution with the first line in the Python code that isn’t a function ( <code class="calibre25">print("Hi")</code>). Although Python doesn’t have a <code class="calibre25">main</code> function per se, we’ll refer to the block of code after the functions as <code class="calibre25">main</code> to help with this explanation. Code executes sequentially unless it encounters commands that tell it to execute code somewhere else. So, after executing <code class="calibre25">print("Hi")</code>, it will go to the next line, which is the call to <code class="calibre25">funct1</code>: <code class="calibre25">funct1()</code>. The call to <code class="calibre25">funct1</code> changes where the code is executing to the start of that function, which is the following statement: <code class="calibre25">print("there")</code>. The next line of <code class="calibre25">funct1</code> calls <code class="calibre25">funct2</code>, so the program will execute the first line of <code class="calibre25">funct2</code>: <code class="calibre25">print("my")</code>. What gets interesting is what happens when <code class="calibre25">funct2</code> finishes. There are no more lines of code to execute, so it automatically moves execution back to the first line following the call to <code class="calibre25">funct2</code> in <code class="calibre25">funct1</code>. (If the function call is in the middle of another statement, that statement resumes execution, but for this example, the function calls are each on their own line.) You may be curious why it goes to the next line after the call to <code class="calibre25">funct2</code> rather than back to the call of <code class="calibre25">funct2</code>. The problem is if it returned back to the call to <code class="calibre25">funct2</code>, it would be trapped calling <code class="calibre25">funct2</code> forever. As a result, functions always return back to the next piece of code to execute (in this example, the next line) after they are called.</p>
</div>
<div class="readable-text" id="p194">
<p class="calibre15">Continuing this example, the next line of the code executed will be the line that prints <code class="calibre25">friend</code>. The next line calls <code class="calibre25">funct3</code>, which prints a period (.) and then returns back to its caller.</p>
</div>
<div class="readable-text" id="p195">
<p class="calibre15">So, we’re back in <code class="calibre25">funct1</code>, on the line <code class="calibre25">print("")</code>. Printing an empty piece of text causes a new line. Now <code class="calibre25">funct1</code> is finished, so it transfers execution back to the next line in <code class="calibre25">main</code> after it was called. We suspect you’re getting the idea by now, so let’s move a bit more quickly: </p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p196"> <code class="calibre25">main</code> next prints <code class="calibre25">I'm</code> and then calls <code class="calibre25">funct4</code>. </li>
<li class="readable-text1" id="p197"> <code class="calibre25">funct4</code> prints <code class="calibre25">well</code> and then returns to <code class="calibre25">main</code> where the next line of code calls <code class="calibre25">funct3</code>. </li>
<li class="readable-text1" id="p198"> <code class="calibre25">funct3</code> prints a period (.) and then returns to <code class="calibre25">main</code>. Notice that <code class="calibre25">funct3</code> was called both by <code class="calibre25">funct1</code> and by <code class="calibre25">main</code>, but that’s okay because functions remember how to return to the function that called them. In fact, having multiple functions calling the same function is a sign that the function being called multiple times is a good function because of its reuse. </li>
<li class="readable-text1" id="p199"> After <code class="calibre25">funct3</code> returns to main, it will print <code class="calibre25">""</code>, which causes a new line to be started, and then it prints the word <code class="calibre25">Bye</code>. </li>
</ul>
<div class="readable-text" id="p200">
<p class="calibre15">That was a long example, but we provided it to give you an idea of how functions execute and how programs consist of defining and calling functions. In any software you use, think about the specific tasks that it performs: the programmers probably wrote one or more functions for each one. The button in a text editor that changes the text to bold probably calls a function to change the text to bold. That function might change the editor’s internal idea of the text (the editor likely stores your text in a different format than how you view it), and then it might call another function that updates the user’s (your) view of the text.</p>
</div>
<div class="readable-text" id="p201">
<p class="calibre15">We’d also like to use this example to discuss the different roles that functions play. A <em class="calibre18">helper</em> function is a function whose job is to make another function’s job easier. In a sense, every function that isn’t <code class="calibre25">main</code> is a helper function. The best helper functions are those that carry out some small, well-defined part of some other task, such as our <code class="calibre25">is_strong_password</code> function in section 3.3.2 serving as a helper function for our <code class="calibre25">get_strong_password</code> function in section 3.3.3.</p>
</div>
<div class="readable-text" id="p202">
<p class="calibre15">Some functions simply call a bunch of other functions without doing any of their own work. There aren’t any of these in our example. However, if you removed the three <code class="calibre25">print</code> statements from <code class="calibre25">funct1</code>, it becomes this type of coordinating function. Others may call helper function(s) and then do some work on their own. <code class="calibre25">funct1</code> is a great example of a function that calls other functions but also does work on its own. </p>
</div>
<div class="readable-text" id="p203">
<p class="calibre15">Another type of function—which we call a <em class="calibre18">leaf</em> function—stands on its own without calling other functions for help (except perhaps functions that already come with Python). Why leaf? If you imagine all the function calls as a big tree, these functions are the leaves of the tree because they have nothing coming out of them. <code class="calibre25">funct2</code>, <code class="calibre25">funct3</code>, and <code class="calibre25">funct4</code> are all leaf functions in our example. We’re primarily concerned with leaf functions in this chapter, but you’ll see examples of other kinds of functions here and especially in later chapters.</p>
</div>
<div class="readable-text" id="p204">
<h2 class="readable-text-h1" id="sigil_toc_id_54"><span class="calibre22">3.6</span> What’s a reasonable task for a function?</h2>
</div>
<div class="readable-text" id="p205">
<p class="calibre15">There’s no clear rule for what makes a good function, but there are some intuitions and recommendations we can share. Make no mistake, though—identifying good functions is a skill that takes time and practice. To help you with this, we gave you some examples of good functions in section 3.3. In this section, we’ll outline our recommendations and provide you with some additional good and bad examples to help build that intuition. </p>
</div>
<div class="readable-text" id="p206">
<h3 class="readable-text-h2" id="sigil_toc_id_55"><span class="calibre22">3.6.1</span> Attributes of good functions</h3>
</div>
<div class="readable-text" id="p207">
<p class="calibre15">Here are some guidelines that we believe will help you see what makes a good function:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p208"> <em class="calibre18">One clear </em><em class="calibre18"/><em class="calibre18">task to perform —</em>A leaf function might be something like “compute the volume of a sphere,” “find the largest number in a list,” or “check to see if a list contains a specific value.” Nonleaf functions can achieve broader goals, like “update the game graphics” or “collect and sanitize input from the user.” Nonleaf functions should still have a particular goal in mind, but they are designed knowing that they will likely call other functions to achieve their goal. </li>
<li class="readable-text1" id="p209"> <em class="calibre18"/><em class="calibre18">Clearly defined behavior —</em>The task “find the largest number in a list” is clearly defined. If I gave you a list of numbers and asked you for the largest number, you know what you should do. In contrast, the task “find the best word in the list” is poorly defined as stated. You need more information: What is the “best” word? Is it the longest, the one that uses the fewest vowels, or the one that doesn’t share any of the same letters as “Leo” or “Dan”? You get the point; subjective tasks aren’t great for computers. Instead, we could write the function “find the word in the list that has the most characters” because what is expected is well defined. Often, programmers can’t put all the particulars of a function just in the name, so they fill in the details in the docstring to clarify its use. If you find yourself having to write more than a few sentences to describe the function’s behavior, the task is probably too much for a single function. </li>
<li class="readable-text1" id="p210"> <em class="calibre18"/><em class="calibre18">Short in number of lines of code —</em>We’ve heard different rules over the years for the length of functions, informed by different company style guidelines. The lengths we’ve heard vary from 12 to 20 lines of Python code as the maximum number of lines. In these rules, the number of lines is being used as a proxy for code complexity, and it’s not a bad rule of thumb. As programmers ourselves, we both apply similar rules to our code to ensure the complexity doesn’t get out of hand. With Copilot, we can use this as a guide as well. If you ask Copilot for a function, and it gives you back 50 lines of code, this probably isn’t a good function name or task. As we discussed earlier, that many lines of code are likely to have errors anyway. </li>
<li class="readable-text1" id="p211"> <em class="calibre18"/><em class="calibre18">General value over specific use —</em>A function that returns the number of values in a list that are greater than 1 might be a specific need for a part of your program, but there’s a way to make this better. The function should be rewritten to return the number of values in the list that are greater than another parameter. The new function would work for your use case (give the function 1 for the second parameter) and for any value other than 1. We strive to have functions be as simple but as powerful as possible. This is why we wrote our function in section 3.3.1 to work for any stock, not just AAAPL. </li>
<li class="readable-text1" id="p212"> <em class="calibre18"/><em class="calibre18">Clear input and output —</em>You generally don’t want a lot of parameters. That doesn’t mean you can’t have a lot of input, though. A single parameter could be a list of items, as in our <code class="calibre25">best_word</code> function in section 3.3.5. It does mean that you want to find ways to keep the number of inputs to a minimum. You can only return one thing, but again, you can return a list so you aren’t as limited as it may appear. But if you find yourself writing a function that sometimes returns a list, sometimes returns a single value, and sometimes returns nothing, that’s probably not a good function. </li>
</ul>
<div class="readable-text" id="p213">
<h3 class="readable-text-h2" id="sigil_toc_id_56"><span class="calibre22">3.6.2</span> Examples of good (and bad) leaf functions</h3>
</div>
<div class="readable-text" id="p214">
<p class="calibre15">Here are examples of good leaf functions (the function is on the left in italics, and the goal of that function is described on the right):</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p215"> <em class="calibre18">Compute the volume of a sphere —</em>Given the sphere’s radius, return its volume. </li>
<li class="readable-text1" id="p216"> <em class="calibre18">Find the largest number in a list —</em>Given a list, return the largest value. </li>
<li class="readable-text1" id="p217"> <em class="calibre18">Check whether a list contains a specific value —</em>Given a list and a value, return True if the list contains the value and False if it does not. </li>
<li class="readable-text1" id="p218"> <em class="calibre18">Print the state of the checkers game —</em>Given a 2D list representing the game board, output the game board to the screen in text. </li>
<li class="readable-text1" id="p219"> <em class="calibre18">Insert a value in a list —</em>Given a list, a new value, and a location in the list, return a new list that is the old list with the new value inserted at the desired location. </li>
</ul>
<div class="readable-text" id="p220">
<p class="calibre15">Here are examples of bad leaf functions and our reasons for why they are bad:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p221"> <em class="calibre18">Request a user’s tax information and return the amount they owe this year —</em>Perhaps in some countries this wouldn’t be too bad, but we can’t imagine this as a single function in either the United States or Canada given the complexity of the tax rules! </li>
<li class="readable-text1" id="p222"> <em class="calibre18">Identify the largest value in the list and remove that value from the list —</em>This might not seem so bad, but it’s really doing two things. The first is to find the largest value in the list. The second is to remove a value from the list. We’d recommend two leaf functions, one that finds the largest and one that removes the value from the list. However, this might make a good nonleaf function if your program needs to perform this task frequently. </li>
<li class="readable-text1" id="p223"> (Thinking of our dataset from chapter 2.) <em class="calibre18">Return the names of the quarterbacks with more than 4,000 yards of passing in the dataset —</em>This has too much specificity. Without a doubt, the number 4,000 should be a parameter. But it’s likely better to make a function that takes as input the position (quarterback, running back), the statistic (passing yards, games played), and the cutoff that we care about (4,000, 8,000) as parameters. This new function provides far more capability than the original, allowing a user to call the function to determine not only the names of particular quarterbacks who threw for more than 4,000 yards but also, for example, running backs who had more than 12 rushing touchdowns. </li>
<li class="readable-text1" id="p224"> <em class="calibre18">Determine the best movie of all time —</em>This function is too vague. Best movie by what definition? What movies should be considered? A better version of this might be a function that determines the highest-rated movie by users given at least a minimum number of ratings. This function would likely be part of a larger program where the function would have data from a movie database (say, IMDB) and minimum number of user ratings as inputs. The output of the function would be the highest-rated movie that has at least as many ratings as specified. </li>
<li class="readable-text1" id="p225"> <em class="calibre18">Play Call of Duty —</em>This might be the <code class="calibre25">main</code> function in the large code base for the Call of Duty game, but it’s definitely not a leaf function. </li>
</ul>
<div class="readable-text" id="p226">
<p class="calibre15">Overall, in this chapter, you’ve learned about functions in Python and how you can use Copilot to help write them. You’ve also learned about the characteristics of good functions and how important it is to make sure your functions are solving tasks that can be managed well by Copilot. </p>
</div>
<div class="readable-text" id="p227">
<p class="calibre15">Our next steps in this book all revolve around understanding whether the code produced by Copilot is correct and how to fix it when it isn’t. In the next chapter, we’ll start by explaining the basics of being able to read the code produced by Copilot because this gives us the first sanity check for whether Copilot is doing what we think it should be. Then, in later chapters, we’ll dig deeper into how to carefully test the code and what to do when it’s wrong.</p>
</div>
<div class="readable-text" id="p228">
<h2 class="readable-text-h1" id="sigil_toc_id_57"><span class="calibre22">3.7</span> Exercises</h2>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p229"> Review the following function descriptions, and determine if each is a leaf function. Provide reasons for your answers based on the complexity of the tasks the functions perform and whether they are likely to require calling additional custom functions. 
    <ol class="calibre48">
<li class="calibre30"> <em class="calibre18">Scrape data.</em> Given a list of URLs, scrape data from each page, parse the content to extract specific information, and save the extracted data to a database. </li>
<li class="calibre30"> <em class="calibre18">Process customer orders. </em>Given a list of customer orders, process each order by checking inventory, calculating total price with discounts and taxes, updating inventory, and generating an order summary. </li>
<li class="calibre30"> <em class="calibre18">Find the largest number in a list.</em> Given a list, return the largest value. </li>
<li class="calibre30"> <em class="calibre18">Check whether a list contains a specific value.</em> Given a list and a value, return <code class="calibre25">True</code> if the list contains the value, and <code class="calibre25">False</code> if it does not. </li>
<li class="calibre30"> <em class="calibre18">Generate student report cards.</em> Given a list of students and their grades, calculate the final grades, assign letter grades, determine class rank, and generate a formatted report card for each student. </li>
</ol></li>
<li class="readable-text1" id="p230"> Review the cycle of designing functions with Copilot as outlined in this chapter. This cycle includes steps from determining the function’s behavior to testing the generated code. Based on general programming practices, identify which of the following steps is <em class="calibre18">not</em> included in the cycle described but is commonly part of a software development process: 
    <ol class="calibre48">
<li class="calibre30"> Verifying the logical correctness of the generated code by running unit tests </li>
<li class="calibre30"> Editing the function’s code manually to simplify complex logic after Copilot generation </li>
<li class="calibre30"> Conducting performance benchmarks on the generated code to ensure efficiency </li>
<li class="calibre30"> Consulting documentation or external resources to refine the function’s prompt </li>
</ol></li>
<li class="readable-text1" id="p231"> Based on the problem description provided, write a clear and concise prompt for Copilot that specifies the task to be completed. Ensure your prompt includes all necessary details such as expected inputs, the processing to be performed, and the expected output: 
    <ol class="calibre48">
<li class="calibre30"> In a quaint little town, there was a humble shopkeeper who, every so often, would delight his customers with discounts on his goods. To streamline this process, he sought to create a magical formula. This formula would take the original price of any item in his store and the special discount he wished to offer. With these two pieces of information, the formula would then reveal the final price the customer needed to pay after the discount was woven into the original tag, making both the shopkeeper and his customers very happy with the ease of their transactions. </li>
</ol></li>
</ol>
<div class="readable-text" id="p232">
<p class="calibre15">Can you think of two or three input examples to verify the correctness of the function generated by Copilot based on your prompts? Include some scenarios to ensure the function handles different types of input correctly and calculates the correct output.</p>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p233"><span class="faux-ol-li-counter">4. </span> Review the function description and the provided test cases for calculating the total cost of a meal, including tax and tip. Based on the scenario and typical requirements of such a function, can you think of inputs where the function doesn’t work correctly? Explain why handling this input is necessary to ensure the function’s reliability and correctness across all potential use cases. <br class="calibre1"/>Problem description: Create a function that calculates the total cost of a meal, including tax and tip. The function should take three inputs: the base price of the meal, the tax rate as a percentage, and the tip rate as a percentage. The function should calculate and return the total cost of the meal. <br class="calibre1"/>Test cases:
    <ol class="calibre48">
<li class="calibre30"> <em class="calibre18">Standard Case</em>—Calculate the total price of a $50 meal with a 10% tax and a 15% tip: 
      <ul class="calibre49">
<li class="calibre30">Input: <code class="calibre25">base_price = 50</code>, <code class="calibre25">tax_rate = 10</code>, <code class="calibre25">tip_rate = 15</code></li>
<li class="calibre30">Expected output: $62.50 (calculated as $50 + $5 tax + $7.50 tip)</li>
</ul> </li>
<li class="calibre30"> <em class="calibre18">Zero Tip Case</em>—Calculate the total price of a $30 meal with a 5% tax and no tip: 
      <ul class="calibre49">
<li class="calibre30">Input: <code class="calibre25">base_price = 30</code>, <code class="calibre25">tax_rate = 5</code>, <code class="calibre25">tip_rate = 0</code></li>
<li class="calibre30">Expected output: $31.50 (calculated as $30 + $1.50 tax + $0 tip)</li>
</ul> </li>
<li class="calibre30"> <em class="calibre18">High Tax and Tip Case</em>—Calculate the total price of a $100 meal with a 20% tax and a 25% tip: 
      <ul class="calibre49">
<li class="calibre30">Input: <code class="calibre25">base_price = 100</code>, <code class="calibre25">tax_rate = 20</code>, <code class="calibre25">tip_rate = 25</code></li>
<li class="calibre30">Expected output: $145 (calculated as $100 + $20 tax + $25 tip)</li>
</ul> </li>
</ol></li>
</ol>
<ol class="faux-ol-li">
<li class="readable-text3" id="p236"><span class="faux-ol-li-counter">5. </span> Review the initial prompt provided to Copilot and the resulting Python function. The code doesn’t fulfill the requirements as it only converts from Fahrenheit to Celsius and lacks the capability to convert in both directions based on a user-specified mode. How would you improve the prompt to ensure that the generated code meets the full requirements of the problem description? </li>
</ol>
<div class="browsable-container" id="p237">
<div class="readable-text">
<pre class="code-area"><code class="calibre25"><em class="calibre18">Prompt: Write a Python function to convert temperature between Fahrenheit and Celsius.</em></code>

def convert_temperature(temp):
    celsius = (temp - 32) * 5.0/9.0
    return celsius</pre>
</div>
</div>
<div class="readable-text" id="p238">
<h2 class="readable-text-h1" id="sigil_toc_id_58">Summary</h2>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p239"> Problem decomposition involves breaking a large problem into smaller tasks. </li>
<li class="readable-text1" id="p240"> We use functions to perform problem decomposition in our programs. </li>
<li class="readable-text1" id="p241"> Each function must solve one small, well-defined task. </li>
<li class="readable-text1" id="p242"> A function header or signature is the first line of code of the function. </li>
<li class="readable-text1" id="p243"> Parameters are used to provide information to functions. </li>
<li class="readable-text1" id="p244"> The function header indicates the name of the function and names of its parameters. </li>
<li class="readable-text1" id="p245"> We use <code class="calibre25">return</code> to pass a value from a function to its caller. </li>
<li class="readable-text1" id="p246"> A docstring uses the names of each function parameter to describe the purpose of the function. </li>
<li class="readable-text1" id="p247"> To ask Copilot to write a function, we provide it the function header and docstring. </li>
<li class="readable-text1" id="p248"> We get a function to do its work by calling it with values (also called arguments) for its parameters. </li>
<li class="readable-text1" id="p249"> To test whether a function is correct, we call it with different types of inputs. </li>
<li class="readable-text1" id="p250"> A variable is a name that refers to a value. </li>
<li class="readable-text1" id="p251"> Every Python value has a type, such as a number, text (string), true/false value (bool), or collection of values (list or dictionary). </li>
<li class="readable-text1" id="p252"> Prompt engineering involves modifying our prompt for Copilot to influence the code that we get back. </li>
<li class="readable-text1" id="p253"> We need to ensure that we import any module (e.g., string) our code is using. </li>
<li class="readable-text1" id="p254"> Functions reduce duplication, make it easier to test our code, and reduce the likelihood of bugs. </li>
<li class="readable-text1" id="p255"> Unit testing involves checking that the function does what we expect on a variety of different inputs. </li>
<li class="readable-text1" id="p256"> A helper function is a small function written to make it easier to write a bigger function. </li>
<li class="readable-text1" id="p257"> A leaf function doesn’t call any other function to do its job. </li>
</ul>
</div></body></html>