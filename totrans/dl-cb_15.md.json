["```py\n15.1 Song Classification\n15.2 Index Local MP3s\n15.3 Spotify Playlists\n15.4 Train a Music Recommender\n```", "```py\nwget http://opihi.cs.uvic.ca/sound/genres.tar.gz\ntar xzf genres.tar.gz\n```", "```py\n>ls ~/genres\nblues  classical  country  disco  hiphop  jazz  metal  pop  reggae  rock\n```", "```py\ndef load_songs(song_folder):\n    song_specs = []\n    idx_to_genre = []\n    genre_to_idx = {}\n    genres = []\n    for genre in os.listdir(song_folder):\n        genre_to_idx[genre] = len(genre_to_idx)\n        idx_to_genre.append(genre)\n        genre_folder = os.path.join(song_folder, genre)\n        for song in os.listdir(genre_folder):\n            if song.endswith('.au'):\n                signal, sr = librosa.load(\n                    os.path.join(genre_folder, song))\n                melspec = librosa.feature.melspectrogram(\n                    signal, sr=sr).T[:1280,]\n                song_specs.append(melspec)\n                genres.append(genre_to_idx[genre])\n    return song_specs, genres, genre_to_idx, idx_to_genre\n```", "```py\ndef show_spectogram(show_genre):\n    show_genre = genre_to_idx[show_genre]\n    specs = []\n    for spec, genre in zip(song_specs, genres):\n        if show_genre == genre:\n            specs.append(spec)\n            if len(specs) == 25:\n                break\n    if not specs:\n        return 'not found!'\n    x = np.concatenate(specs, axis=1)\n    x = (x - x.min()) / (x.max() - x.min())\n    plt.imshow((x *20).clip(0, 1.0))\n\nshow_spectogram('classical')\n```", "```py\nshow_spectogram('metal')\n```", "```py\ninputs = Input(input_shape)\nx = inputs\nfor layers in range(3):\nx = Conv1D(128, 3, activation='relu')(x)\nx = BatchNormalization()(x)\nx = MaxPooling1D(pool_size=6, strides=2)(x)\nx = GlobalMaxPooling1D()(x)\n```", "```py\nfor fc in range(2):\nx = Dense(256, activation='relu')(x)\n    x = Dropout(0.5)(x)\n\n    outputs = Dense(10, activation='softmax')(x)\n```", "```py\ndef split_10(x, y):\n    s = x.shape\n    s = (s[0] * 10, s[1] // 10, s[2])\n    return x.reshape(s), np.repeat(y, 10, axis=0)\n\ngenres_one_hot = keras.utils.to_categorical(\n    genres, num_classes=len(genre_to_idx))\n\nx_train, x_test, y_train, y_test = train_test_split(\n    np.array(song_specs), np.array(genres_one_hot),\n    test_size=0.1, stratify=genres)\n\nx_test, y_test = split_10(x_test, y_test)\nx_train, y_train = split_10(x_train, y_train)\n```", "```py\ndef unsplit(values):\n    chunks = np.split(values, 100)\n    return np.array([np.argmax(chunk) % 10 for chunk in chunks])\n\npredictions = unsplit(model.predict(x_test))\ntruth = unsplit(y_test)\naccuracy_score(predictions, truth)\n```", "```py\ncm = confusion_matrix(pred_values, np.argmax(y_test, axis=1))\nprint(cm)\n```", "```py\n[[65 13  0  6  5  1  4  5  2  1]\n [13 54  1  3  4  0 20  1  0  9]\n [ 5  2 99  0  0  0 12 33  0  2]\n [ 0  0  0 74 29  1  8  0 18 10]\n [ 0  0  0  2 55  0  0  1  2  0]\n [ 1  0  0  1  0 95  0  0  0  6]\n [ 8 17  0  2  5  2 45  0  1  4]\n [ 4  4  0  1  2  0 10 60  1  4]\n [ 0  1  0  1  0  1  0  0 64  5]\n [ 4  9  0 10  0  0  1  0 12 59]]\n```", "```py\nplt.imshow(cm.T, interpolation='nearest', cmap='gray')\nplt.xticks(np.arange(0, len(idx_to_genre)), idx_to_genre)\nplt.yticks(np.arange(0, len(idx_to_genre)), idx_to_genre)\n\nplt.show()\n```", "```py\nMUSIC_ROOT = _</path/to/music>_\nmp3s = []\nfor root, subdirs, files in os.walk(MUSIC_ROOT):\n    for fn in files:\n        if fn.endswith('.mp3'):\n            mp3s.append(os.path.join(root, fn))\n```", "```py\ndef process_mp3(path):\n    tag = TinyTag.get(path)\n    signal, sr = librosa.load(path,\n                              res_type='kaiser_fast',\n                              offset=30,\n                              duration=30)\n    melspec = librosa.feature.melspectrogram(signal, sr=sr).T[:1280,]\n        if len(melspec) != 1280:\n            return None\n    return {'path': path,\n            'melspecs': np.asarray(np.split(melspec, 10)),\n            'tag': tag}\n\nsongs = [process_mp3(path) for path in tqdm(mp3s)]\nsongs = [song for song in songs if song]\n```", "```py\ninputs = []\nfor song in songs:\n    inputs.extend(song['melspecs'])\ninputs = np.array(inputs)\n```", "```py\ncnn_model = load_model('zoo/15/song_classify.h5')\nvectorize_model = Model(inputs=cnn_model.input,\n                        outputs=cnn_model.layers[-4].output)\nvectors = vectorize_model.predict(inputs)\n```", "```py\nnbrs = NearestNeighbors(n_neighbors=10, algorithm='ball_tree').fit(vectors)\ndef most_similar_songs(song_idx):\n    distances, indices = nbrs.kneighbors(\n        vectors[song_idx * 10: song_idx * 10 + 10])\n    c = Counter()\n    for row in indices:\n        for idx in row[1:]:\n            c[idx // 10] += 1\n    return c.most_common()\n```", "```py\nsong_idx = 7\nprint(songs[song_idx]['path'])\n\nprint('---')\nfor idx, score in most_similar_songs(song_idx)[:5]:\n    print(songs[idx]['path'], score)\nprint('')\n```", "```py\n00 shocking blue - Venus (yes the.mp3\n---\n00 shocking blue - Venus (yes the.mp3 20\nThe Shocking Blue/Have A Nice Day_ Vol 1/00 Venus.mp3 12\nThe Byrds/00 Eve of Destruction.mp3 12\nGoldfinger _ Weezer _ NoFx _ L/00 AWESOME.mp3 6\n```", "```py\nCLIENT_ID = '<*`your client id`*>'\nCLIENT_SECRET = '<*`your secret`*>'\nUSER_ID = '<*`your user id`*>'\n\n```", "```py\nuri = 'http://127.0.0.1:8000/callback'\ntoken = util.prompt_for_user_token(USER_ID, '',\n                                   client_id=CLIENT_ID,\n                                   client_secret=CLIENT_SECRET,\n                                   redirect_uri=uri)\nsession = spotipy.Spotify(auth=token)\n```", "```py\ndef find_playlists(session, w, max_count=5000):\n    try:\n        res = session.search(w, limit=50, type='playlist')\n        while res:\n            for playlist in res['playlists']['items']:\n                yield playlist\n                max_count -= 1\n                if max_count == 0:\n                    raise StopIteration\n            tries = 3\n            while tries > 0:\n                try:\n                    res = session.next(res['playlists'])\n                    tries = 0\n                except SpotifyException as e:\n                    tries -= 1\n                    time.sleep(0.2)\n                    if tries == 0:\n                        raise\n    except SpotifyException as e:\n        status = e.http_status\n        if status == 404:\n            raise StopIteration\n        raise\n```", "```py\nwhile len(playlists) < 100000:\n    for word, _ in word_counts.most_common():\n        if not word in words_seen:\n            words_seen.add(word)\n            print('word>', word)\n            for playlist in find_playlists(session, word):\n                if playlist['id'] in playlists:\n                    dupes += 1\n                elif playlist['name'] and playlist['owner']:\n                    playlists[playlist['id']] = {\n                      'owner': playlist['owner']['id'],\n                      'name': playlist['name'],\n                      'id': playlist['id'],\n                    }\n                    count += 1\n                    for token in tokenize(playlist['name'],\n                                          lowercase=True):\n                        word_counts[token] += 1\n            break\n```", "```py\ndef track_yielder(session, playlist):\n    res = session.user_playlist_tracks(playlist['owner'], playlist['id'],\n          fields='items(track(id, name, artists(name, id), duration_ms)),next')\n    while res:\n        for track in res['items']:\n            yield track['track']['id']\n            res = session.next(res)\n            if not res or  not res.get('items'):\n                raise StopIteration\n```", "```py\nconn = sqlite3.connect('data/songs.db')\nc = conn.cursor()\nc.execute('CREATE TABLE songs '\n          '(id text primary key, name text, artist text)')\nc.execute('CREATE INDEX name_idx on songs(name)')\n\ntracks_seen = set()\nwith open('data/playlists.ndjson', 'w') as fout_playlists:\n    with open('data/songs_ids.txt', 'w') as fout_song_ids:\n        for playlist in tqdm.tqdm(playlists.values()):\n            fout_playlists.write(json.dumps(playlist) + '\\n')\n            track_ids = []\n            for track in track_yielder(session, playlist):\n                track_id = track['id']\n                if not track_id:\n                    continue\n                if not track_id in tracks_seen:\n                    c.execute(\"INSERT INTO songs VALUES (?, ?, ?)\",\n                              (track['id'], track['name'],\n                               track['artists'][0]['name']))\n                track_ids.append(track_id)\n            fout_song_ids.write(' '.join(track_ids) + '\\n')\n            conn.commit()\nconn.commit()\n```", "```py\nclass WordSplitter(object):\n    def __init__(self, filename):\n        self.filename = filename\n\n    def __iter__(self):\n        with open(self.filename) as fin:\n            for line in fin:\n                yield line.split()\n```", "```py\nmodel = gensim.models.Word2Vec(model_input, min_count=4)\n```", "```py\nwith open('zoo/15/songs.word2vec', 'wb') as fout:\n    model.save(fout)\n```", "```py\nconn = sqlite3.connect('data/songs.db')\ndef find_song(song_name, limit=10):\n    c = conn.cursor()\n    c.execute(\"SELECT * FROM songs WHERE UPPER(name) LIKE '%\"\n              + song_name + \"%'\")\n    res = sorted((x + (model.wv.vocab[x[0]].count,)\n                  for x in c.fetchall() if x[0] in model.wv.vocab),\n                 key=itemgetter(-1), reverse=True)\n    return [*res][:limit]\n\nfor t in find_song('the eye of the tiger'):\n    print(*t)\n```", "```py\n2ZqGzZWWZXEyPxJy6N9QhG The eye of the tiger Chiara Mastroianni 39\n4rr0ol3zvLiEBmep7HaHtx The Eye Of The Tiger Survivor 37\n0R85QWa6KRzB8p44XXE7ky The Eye of the Tiger Gloria Gaynor 29\n3GxdO4rTwVfRvLRIZFXJVu The Eye of the Tiger Gloria Gaynor 19\n1W602jfZkdAsbabmJEYfFi The Eye of the Tiger Gloria Gaynor 5\n6g197iis9V2HP7gvc5ZpGy I Got the Eye of the Tiger Circus Roar 5\n00VQxzTLqwqBBE0BuCVeer The Eye Of The Tiger Gloria Gaynor 5\n28FwycRDU81YOiGgIcxcPq The Eye of the Tiger Gloria Gaynor 5\n62UagxK6LuPbqUmlygGjcU It's the Eye of the Tiger Be Cult 4\n6lUHKc9qrIHvkknXIrBq6d The Eye Of The Tiger Survivor 4\n```", "```py\nsimilar = dict(model.most_similar([song_id]))\n```", "```py\nsong_ids = ', '.join((\"'%s'\" % x) for x in similar.keys())\nc.execute(\"SELECT * FROM songs WHERE id in (%s)\" % song_ids)\nres = sorted((rec + (similar[rec[0]],) for rec in c.fetchall()),\n             key=itemgetter(-1),\n             reverse=True)\n```", "```py\nGirls Just Wanna Have Fun Cyndi Lauper 0.9735351204872131\nEnola Gay - Orchestral Manoeuvres In The Dark 0.9719518423080444\nYou're My Heart, You're My Soul Modern Talking 0.9589041471481323\nGold - 2003 Remastered Version Spandau Ballet 0.9566971659660339\nDolce Vita Ryan Paris 0.9553133249282837\nKarma Chameleon - 2002 Remastered Version Culture Club 0.9531201720237732\nBette Davis Eyes Kim Carnes 0.9499865770339966\nWalking On Sunshine Katrina & The Waves 0.9481900930404663\nManeater Daryl Hall & John Oates 0.9481032490730286\nDon't You Want Me The Human League 0.9471924901008606\n```"]