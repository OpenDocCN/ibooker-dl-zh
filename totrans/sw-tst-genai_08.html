<html><head></head><body>
<div class="calibre1" id="sbo-rt-content"><h1 class="tochead" id="heading_id_2">7 <a id="idTextAnchor000"/><a id="idTextAnchor001"/><a id="idTextAnchor002"/>Accelerating and improving UI automation using AI</h1>
<p class="co-summary-head"><a id="marker-133"/>This chapter covers</p>
<ul class="calibre5">
<li class="co-summary-bullet">How to create UI automation rapidly using GitHub Copilot and ChatGPT</li>
<li class="co-summary-bullet">How to improve UI automation rapidly using GitHub Copilot and ChatGPT</li>
</ul>
<p class="body">If there is one area in the software testing industry that has garnered the most attention regarding the use of AI tools, it’s UI automation. As large language models (LLMs) began capturing attention, people in the testing world quickly focused on how UI automated checks could be easily generated through tools such as Copilot and ChatGPT. The possibilities and ideas around using AI tools for UI automation have been expanding rapidly. But although the enthusiasm for these tools is significant, and tool vendors and automators alike rush to use AI, we must be mindful of where and how AI can be of use.<a id="idIndexMarker000"/></p>
<p class="body">Success with AI in creating automation is as much about knowing <i class="fm-italics">when</i> to use AI tooling as it is about knowing <i class="fm-italics">how</i> to use it. For this reason, this chapter focuses on how to break down the process of creating and maintaining automated checks and discover where AI tools can speed up our processes, while ensuring that we still deliver valuable automation.</p>
<h2 class="fm-head" id="heading_id_3">7.1 Rapidly creating UI automation</h2>
<p class="body">Head to ChatGPT and ask it to generate a Selenium test in Java that automates a login page, and it will happily oblige. This might seem like an effective path to take, but let’s take a look at a brief example of this process and see what happens. For the prompt, we can use<a id="idIndexMarker001"/><a id="marker-134"/><a id="idIndexMarker002"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">Assuming the role of a test automator, create an automated test using Selenium and Java that automates and validates the log in process for an application</p>
</td>
</tr>
</tbody>
</table>
<p class="body">It will return a code example such as</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
 
public class LoginTest {
    public static void main(String[] args) {
        // Set the path to the chromedriver executable
        System.setProperty("webdriver.chrome.driver", "path/to/
        <span class="fm-code-continuation-arrow">➥</span> chromedriver");
 
        // Create an instance of ChromeDriver
        WebDriver driver = new ChromeDriver();
 
        // Open the application login page
        driver.get("https://example.com/login");
 
        // Find the username and password input fields
        WebElement usernameField =
        <span class="fm-code-continuation-arrow">➥</span> driver.findElement(By.id("username"));
        WebElement passwordField =
        <span class="fm-code-continuation-arrow">➥</span> driver.findElement(By.id("password"));
 
        // Enter the username and password
        usernameField.sendKeys("your-username");
        passwordField.sendKeys("your-password");
 
        // Submit the login form
        driver.findElement(By.id("login-button")).click();
 
        // Wait for the page to load
        // You can use an explicit wait here to ensure the page is 
        <span class="fm-code-continuation-arrow">➥</span> fully loaded
 
        // Verify the login success by checking for a specific 
        <span class="fm-code-continuation-arrow">➥</span> element on the next page
        WebElement welcomeMessage = driver.findElement(By.xpath("//
        <span class="fm-code-continuation-arrow">➥</span> h1[contains(text(),'Welcome')]"));
        if (welcomeMessage.isDisplayed()) {
            System.out.println("Login successful!");
        } else {
            System.out.println("Login failed!");
        }
 
        // Close the browser
        driver.quit();
    }
}</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">The code looks correct and would likely compile. But if we were to bring this code into our automation framework, we should ask ourselves, “How much of this would we need to change to make it work with our product under test?” Chances are we would need to</p>
<ul class="calibre5">
<li class="fm-list-bullet">
<p class="list">Remove the <code class="fm-code-in-text">Driver</code> instantiation to use our own driver factory.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Point the check to the correct application by updating <code class="fm-code-in-text">driver.get</code>.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Move the <code class="fm-code-in-text">findElements</code> methods to relevant Page objects.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Update the selectors so that they are using the ones that align with our product.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Update the assertion to meet our assumptions.</p>
</li>
</ul>
<p class="body"><a id="marker-135"/>Before we know it, we’ve ended up replacing nearly all the code suggested by ChatGPT, which doesn’t feel like an efficient use of our time. This is because although tools such as ChatGPT and Copilot can rapidly generate code on demand, they lack the context of our systems. That is, if we ask these tools to create our automated checks with little input provided, the result will be code that requires extensive rework. Instead, we want to take a more symbiotic approach, using AI tools in targeted ways to help us with specific tasks in creating automated UI checks.</p>
<p class="body">Consider the visualization in figure 7.1, which breaks down the various components included in a common automated check that works on the UI layer.</p>
<p class="body">As we can see, there are many moving parts—from the framework itself, which handles the dependencies and reporting of automated checks, to the various activities that an automated check carries out to create state, interact with a UI, and assert against expectations. Each of these parts can be guided using AI, so, rather than attempting to rely on an AI to create everything at once, we focus on specific tasks throughout building and maintaining of our automated check and use LLMs to speed up the process.</p>
<div class="fm-sidebar-block">
<p class="fm-sidebar-title">AI compared to record and playback tools</p>
<p class="fm-sidebar-text">A valid question to ask is how the use of AI differs from record and playback tools and their ability to record our actions and convert them into code. If we were to use LLMs to generate automated checks, then the difference wouldn’t be great. In fact, record and playback tools would likely be better because they are interacting with the system and implicitly learning about the product’s context and rules during recording.</p>
<p class="fm-sidebar-text">However, one limitation of record and playback is when they encounter more complex frameworks that will be arranged using approaches such as Page Object and Screenplay patterns to make them more maintainable. Record and playback tools tend to output resulting code as a script run by itself, separate from others. When that script needs to be integrated into the framework, we will likely need to rework and reorganize our initial script dramatically, which brings us back to the initial problem—slow progress in creating automated UI checks.</p>
<p class="fm-sidebar-text">What this chapter proposes is that we use LLMs in very specific situations, targeting specific actions. If we want to rapidly create Page objects, then an LLM can help us with that task—its output can be quickly plugged into a wider framework with minimum rework.</p>
</div>
<div class="figure">
<p class="figure1"><img alt="" class="calibre29" src="../../OEBPS/Images/CH07_F01_Winteringham2.png"/></p>
<p class="figurecaption">Figure 7.1 A visual representation of the component parts of an automated UI check</p>
</div>
<p class="body"><a id="marker-136"/>To demonstrate this process, let’s take a look at how we can use tools such as Copilot and ChatGPT in our automation workflow, selecting specific actions that AI tools can assist with, by building an automated check for the website <a class="url" href="https://automationintesting.online">https://automationintesting.online</a>, which is a mock bed-and-breakfast booking site that can be used to practice various testing and automation activities.</p>
<p class="body">In this example, we check whether a message is shown in the admin section of the website. To do this, we’ll need to codify the following steps:</p>
<ol class="calibre18">
<li class="fm-list-bullet">
<p class="list">Launch a browser.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Head to <a class="url" href="https://automationintesting.online">automationintesting.online</a>.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Complete the Contact Us form on the home page.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Head to the Admin section of the site and log in.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Load the Message section and confirm that the created message appears.</p>
</li>
</ol>
<p class="body">This process is summarized in figure 7.2.</p>
<div class="figure">
<p class="figure1"><img alt="" class="calibre30" src="../../OEBPS/Images/CH07_F02_Winteringham2.png"/></p>
<p class="figurecaption">Figure 7.2 Visual representation of the automated UI check that will be created</p>
</div>
<p class="body">Although the example itself is nothing spectacular, what we’ll learn is that we can accelerate our work using AI tools as we complete each step—so let’s begin. For reference, you can review the code that was generated for this example on GitHub (<a class="url" href="https://mng.bz/4pXB">https://mng.bz/4pXB</a>).</p>
<div class="fm-sidebar-block">
<p class="fm-sidebar-title">Setting up Copilot</p>
<p class="fm-sidebar-text">This chapter assumes that you have installed and configured the Copilot plugin within your IDE. If you haven’t already completed the setup process, you can find installation instructions in appendix B.<a id="marker-137"/><a id="idIndexMarker003"/></p>
</div>
<div class="fm-sidebar-block">
<p class="fm-sidebar-title">Activity 7.1</p>
<p class="fm-sidebar-text">Follow the steps in this chapter to see whether you can generate a similar automated check. As always, remember that the output that comes from ChatGPT and Copilot may differ from what has been captured in the following example.</p>
</div>
<h3 class="fm-head1" id="heading_id_4">7.1.1 Setting up a project</h3>
<p class="body">We’ll carry out the example in this section in Java. This is a useful language to demonstrate the value of using AI tools, because Java is known for its reliance on boilerplate code (a great place in which LLMs can help build for us). For our first step, we need to create a new Maven project and, once the project is created, add the following dependencies into our <code class="fm-code-in-text">pom.xml</code> file:<a id="idIndexMarker004"/><a id="idIndexMarker005"/></p>
<pre class="programlisting">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
        &lt;version&gt;5.9.2&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
        &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
        &lt;version&gt;4.9.1&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.github.bonigarcia&lt;/groupId&gt;
        &lt;artifactId&gt;webdrivermanager&lt;/artifactId&gt;
        &lt;version&gt;5.5.3&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre>
<p class="body">Now we have everything we need to start developing our automated check.</p>
<p class="body">With our dependencies in place, we can create the necessary packages—<code class="fm-code-in-text">com.example</code> and our <code class="fm-code-in-text">Test</code> class—which we’ll name <code class="fm-code-in-text">MessageTest</code>. From here, we can begin to use Copilot to build our automated check, but we need to prompt Copilot with some information to begin the process. So first we add in a <code class="fm-code-in-text">WebDriver</code> variable inside our <code class="fm-code-in-text">MessageTest</code> class <a id="marker-138"/><a id="idIndexMarker006"/></p>
<pre class="programlisting">private static WebDriver driver;</pre>
<p class="body">followed by the code comment:</p>
<pre class="programlisting">// Use WebDriverManager to download the driver binaries
// and start the browser server for us.</pre>
<p class="body">The combination of code and comment acts sufficiently as a prompt to trigger the following response from Copilot:</p>
<pre class="programlisting">public static void setupClass() {
    WebDriverManager.chromedriver().setup();
}</pre>
<p class="body">This is a good start, but it’s missing the driver instantiation and <code class="fm-code-in-text">BeforeAll</code> hook, which we can add to the next line below the <code class="fm-code-in-text">WebDriverManager</code> call:<a id="idIndexMarker007"/><a id="idIndexMarker008"/></p>
<pre class="programlisting">driver = new ChromeDriver();</pre>
<p class="body">which gives us the following Before hook:</p>
<pre class="programlisting">@BeforeAll
public static void setupClass() {
    WebDriverManager.chromedriver().setup();
 
    driver = new ChromeDriver();
}</pre>
<div class="fm-sidebar-block">
<p class="fm-sidebar-title">To tweak or not to tweak prompts: Making the efficient choice</p>
<p class="fm-sidebar-text">Another observation about working with prompts to generate desired output is that it can be tempting to want to tweak a prompt multiple times to produce the right output, which can be time consuming. In the previous example, the code comment was likely not clear enough for Copilot to produce the complete code snippet we required. The options then are to improve the prompt or add the missing sections of code that are required. In this context, adding the required code made sense. I knew what I required, and spending time tweaking the prompt would have been wasteful. However, if my knowledge of what I wanted was shallower, then I might have chosen to tweak the prompt further. Efficiency is created by being aware of what is the right choice to make at a given time.</p>
</div>
<p class="body"><a id="marker-139"/>We have our <code class="fm-code-in-text">BeforeAll</code> hook in place, so next we want to create a teardown hook, which we can do by adding the annotation<a id="idIndexMarker009"/></p>
<pre class="programlisting">@AfterAll</pre>
<p class="body">prompting Copilot to return</p>
<pre class="programlisting">public static void teardown() {
    driver.quit();
}</pre>
<p class="body">Our second prompt is arguably more accurate than the first one because we are beginning to flesh out the context in which Copilot can be prompted. The more we add to our codebase, the more potential Copilot has to accurately add in what we want. Finally, to verify that everything is working, let’s add in a bare-bones <code class="fm-code-in-text">@Test</code> to ensure that everything is running:<a id="idIndexMarker010"/></p>
<pre class="programlisting">@Test
public void testMessageIsCreated() {
    driver.get("https://automationintesting.online");
}</pre>
<p class="body">So far, so good. We’ve set up our project and our initial test with the support of Copilot. We’ve also observed that, initially, Copilot is lacking details to help recommend the correct lines of code. But as we develop, we’ll start to observe its accuracy improve. This is a great start—now let’s see how tools such as ChatGPT can help speed up our work even more.</p>
<h3 class="fm-head1" id="heading_id_5">7.1.2 Creating our initial check with ChatGPT support</h3>
<p class="body">With the framework in place, we can turn our attention to completing the Contact Us form on the home page. To help contextualize what we’ll be working with, see figure 7.3.<a id="idIndexMarker011"/><a id="idIndexMarker012"/><a id="marker-140"/></p>
<div class="figure">
<p class="figure1"><img alt="" class="calibre31" src="../../OEBPS/Images/CH07_F03_Winteringham2.png"/></p>
<p class="figurecaption">Figure 7.3 The Contact Us form on the website under test</p>
</div>
<p class="body">The figure shows multiple form fields to complete and a Submit button, all of which we will need to codify in our automated check. To do this, we’ll need to create a Page object that captures each of the elements, which we’ll use in our check to populate and submit the form. This process is a laborious one (and one that I personally find to be time consuming and boring, which are the types of emotional triggers explored in chapter 1). So, how can we speed up the process of creating Page objects? We could use Copilot to help us author our classes, but the process of identifying each CSS selector for each element has the potential to take up a lot of time. Instead, let’s take a look at how we could use a prompt in ChatGPT to rapidly create our Page object for us.</p>
<p class="body">First, let’s take a look at a prompt that can be used to trigger ChatGPT to generate our Page object (you can copy and paste the prompt into ChatGPT: <a class="url" href="https://mng.bz/QVpm">https://mng.bz/QVpm</a>). We set out instructions with the delimiter tactic:</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">You are an expert Java Developer. Convert the HTML delimited by three hashes into a Java Selenium Page object using the <code class="fm-code-in-text1">PageFactory</code> library and <code class="fm-code-in-text1">@FindBy</code> annotations. <a id="idIndexMarker013"/><a id="idIndexMarker014"/></p>
</td>
</tr>
</tbody>
</table>
<p class="body">We provide HTML in the delimited section:</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">###
&lt;Enter HTML here&gt;
###</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">Breaking down the prompt, we can observe that it takes this form:</p>
<ul class="calibre5">
<li class="fm-list-bullet">
<p class="list">Clear instructions at the start, informing ChatGPT of what we want to achieve</p>
</li>
<li class="fm-list-bullet">
<p class="list">A list of constraints that specifies clear instructions for what we expect from ChatGPT, stating which libraries and methods we’d like to explicitly use when creating our Page object</p>
</li>
</ul>
<p class="body">To create the Page object, we take the prompt we have just explored and add the HTML from our Contact form to the bottom before pasting it into ChatGPT. Again, feel free to use the already created prompt available on GitHub at <a class="url" href="https://mng.bz/QVpm">https://mng.bz/QVpm</a>:<a id="marker-141"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">&lt;form&gt;
  &lt;div class="input-group mb-3"&gt;
    &lt;div class="input-group-prepend"&gt;
      &lt;span class="input-group-text" id="basic-addon1"&gt;
        &lt;span class="fa fa-id-card"&gt;&lt;/span&gt;
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;input type="text" data-testid="ContactName"
    <span class="fm-code-continuation-arrow">➥</span>class="form-control" placeholder="Name" aria-label="Name"
    <span class="fm-code-continuation-arrow">➥</span>id="name" aria-describedby="basic-addon1"&gt;
  &lt;/div&gt;
  &lt;div class="input-group mb-3"&gt;
    &lt;div class="input-group-prepend"&gt;
      &lt;span class="input-group-text" id="basic-addon1"&gt;
        &lt;span class="fa fa-envelope"&gt;&lt;/span&gt;
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;input type="text" data-testid="ContactEmail"
    <span class="fm-code-continuation-arrow">➥</span>class="form-control" placeholder="Email" aria-label="Email"
    <span class="fm-code-continuation-arrow">➥</span>id="email" aria-describedby="basic-addon1"&gt;
  &lt;/div&gt;
  &lt;div class="input-group mb-3"&gt;
    &lt;div class="input-group-prepend"&gt;
      &lt;span class="input-group-text" id="basic-addon1"&gt;
        &lt;span class="fa fa-phone"&gt;&lt;/span&gt;
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;input type="text" data-testid="ContactPhone"
    <span class="fm-code-continuation-arrow">➥</span>class="form-control" placeholder="Phone" aria-label="Phone"
    <span class="fm-code-continuation-arrow">➥</span>id="phone" aria-describedby="basic-addon1"&gt;
  &lt;/div&gt;
  &lt;div class="input-group mb-3"&gt;
    &lt;div class="input-group-prepend"&gt;
      &lt;span class="input-group-text" id="basic-addon1"&gt;
        &lt;span class="fa fa-envelope"&gt;&lt;/span&gt;
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;input type="text" data-testid="ContactSubject"
    <span class="fm-code-continuation-arrow">➥</span>class="form-control" placeholder="Subject" aria-label="Subject"
    <span class="fm-code-continuation-arrow">➥</span>id="subject" aria-describedby="basic-addon1"&gt;
  &lt;/div&gt;
  &lt;div class="input-group"&gt;
    &lt;div class="input-group-prepend"&gt;
      &lt;span class="input-group-text"&gt;Message&lt;/span&gt;
    &lt;/div&gt;
    &lt;textarea data-testid="ContactDescription" class="form-control"
    <span class="fm-code-continuation-arrow">➥</span>aria-label="Description" id="description" rows="5"&gt;&lt;/textarea&gt;
  &lt;/div&gt;
  &lt;br&gt;
  &lt;button type="button" class="btn btn-outline-primary float-right"
  <span class="fm-code-continuation-arrow">➥</span>id="submitContact"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">Entering this prompt into ChatGPT yields the following code for our Page object:<a id="marker-142"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;
 
public class ContactFormPage {
 
    // WebDriver instance
    private WebDriver driver;
 
    // Constructor to initialize the PageFactory
    public ContactFormPage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }
 
    // WebElements for the form fields
    @FindBy(id = "name")
    private WebElement nameInput;
 
    @FindBy(id = "email")
    private WebElement emailInput;
 
    @FindBy(id = "phone")
    private WebElement phoneInput;
 
    @FindBy(id = "subject")
    private WebElement subjectInput;
 
    @FindBy(id = "description")
    private WebElement descriptionTextarea;
 
    @FindBy(id = "submitContact")
    private WebElement submitButton;
 
    // Methods to interact with the form
    public void enterName(String name) {
        nameInput.sendKeys(name);
    }
 
    public void enterEmail(String email) {
        emailInput.sendKeys(email);
    }
 
    public void enterPhone(String phone) {
        phoneInput.sendKeys(phone);
    }
 
    public void enterSubject(String subject) {
        subjectInput.sendKeys(subject);
    }
 
    public void enterDescription(String description) {
        descriptionTextarea.sendKeys(description);
    }
 
    public void clickSubmitButton() {
        submitButton.click();
    }
}</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">ChatGPT has not only successfully created a class that includes all the necessary methods required to complete and submit the contact form, but this was also done rapidly after a single prompt. In this example, the class was quite small, but regular Page objects can be pretty large. The time taken to write and maintain Page objects is compounded by the amount we require. So, by using ChatGPT to rapidly generate our code for us, we can continue developing our automated check faster.</p>
<div class="fm-sidebar-block">
<p class="fm-sidebar-title">Testability and AI tools</p>
<p class="fm-sidebar-text">Even with AI tools, the testability of a product influences a tool’s effectiveness. The way in which the HTML for the Contact Us form has been created can be said to have a high <i class="fm-italics">testability.</i> The HTML is semantically correct, and it contains clear, stable HTML attributes in the <code class="fm-code-in-text1">input</code> and <code class="fm-code-in-text1">textarea</code> elements that ChatGPT can predict to put into the created class. If, however, the HTML we are working with requires us to identify more complex selectors, perhaps due to autogenerated IDs or a lack of HTML elements, then the performance of our prompt may not be as effective, requiring us to update and tweak our Page object to better suit our needs.<a id="idIndexMarker015"/><a id="idIndexMarker016"/><a id="marker-143"/><a id="idIndexMarker017"/></p>
</div>
<p class="body">With our Page object created, we can head back to <code class="fm-code-in-text">MessageTest</code> and tab through Copilot’s suggestions to create our necessary Contact Us form-filling code:</p>
<pre class="programlisting">ContactFormPage contactFormPage = new ContactFormPage(driver);
contactFormPage.enterName("John Smith");
contactFormPage.enterEmail("test@email.com");
contactFormPage.enterPhone("0123456789");
contactFormPage.enterSubject("Testing");
contactFormPage.enterDescription("This is a test message");
contactFormPage.clickSubmitButton();</pre>
<p class="body">Copilot has read our object and helped us map out filling in the form. But although it can read the methods that exist in <code class="fm-code-in-text">ContactFormPage</code> and predict what’s next, it lacks context on validation rules for each form field, which affects the test data it creates. Unlike in the previous chapter, in which test data was accurately set based on expectations, the data returned is generic and will cause problems. For example, the validation rule set for the Phone Number field requires 11 or more digits to be entered, so our predicted test data would cause our automated test to fail. Therefore, let’s update the <code class="fm-code-in-text">enterPhone</code> parameter with data that will pass the phone number validation:<a id="idIndexMarker018"/></p>
<pre class="programlisting">contactFormPage.enterPhone("07123456789");</pre>
<p class="body">With our message created, we now want to log in, which can be achieved by following a pattern similar to the one we have just followed. First, we create the necessary code to head to the Admin page:</p>
<pre class="programlisting">driver.get("https://automationintesting.online/#/admin/");</pre>
<p class="body">Then, returning to our current chat with ChatGPT, we can reuse our earlier prompt to create a Page object for the admin login page, this time simply referring to the original prompt and providing it with new HTML to generate our class:<a id="marker-144"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">Follow the previous prompt again, but this time use the following HTML:</p>
<pre class="programlisting">&lt;div class="col-sm-4"&gt;
    &lt;div class="form-group"&gt;
        &lt;input data-testid="username" type="text"
        <span class="fm-code-continuation-arrow">➥</span>style="border: 1px solid grey;" class="form-control"
        <span class="fm-code-continuation-arrow">➥</span>id="username"
        <span class="fm-code-continuation-arrow">➥</span>placeholder="Username"&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        &lt;input data-testid="password" type="password"
        <span class="fm-code-continuation-arrow">➥</span>style="border: 1px solid grey;" class="form-control"
        <span class="fm-code-continuation-arrow">➥</span>id="password"
        <span class="fm-code-continuation-arrow">➥</span>placeholder="Password"&gt;
    &lt;/div&gt;
    &lt;button type="submit" data-testid="submit" id="doLogin"
    <span class="fm-code-continuation-arrow">➥</span>class="btn btn-primary float-right"&gt;Login&lt;/button&gt;
&lt;/div&gt;</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">This yields the following <code class="fm-code-in-text">LoginPage</code> code to add to our project:<a id="idIndexMarker019"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;
 
public class LoginPage {
 
    // WebDriver instance
    private WebDriver driver;
 
    // Constructor to initialize the PageFactory
    public LoginPage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }
 
    // WebElements for the form fields
    @FindBy(id = "username")
    private WebElement usernameInput;
 
    @FindBy(id = "password")
    private WebElement passwordInput;
 
    @FindBy(id = "doLogin")
    private WebElement loginButton;
 
    // Methods to interact with the form
    public void enterUsername(String username) {
        usernameInput.sendKeys(username);
    }
 
    public void enterPassword(String password) {
        passwordInput.sendKeys(password);
    }
 
    public void clickLoginButton() {
        loginButton.click();
    }
}</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">Next, we create the <code class="fm-code-in-text">LoginPage</code> class in our code, fixing our missing imports, and then return to <code class="fm-code-in-text">MessageTest</code> and use Copilot to create our login step by tabbing through suggestions to produce the following:<a id="marker-145"/><a id="idIndexMarker020"/></p>
<pre class="programlisting">LoginPage loginPage = new LoginPage(driver);
loginPage.enterUsername("admin");
loginPage.enterPassword("password");
loginPage.clickLoginButton();</pre>
<p class="body">Finally, we can execute one more loop of using ChatGPT and Copilot to complete our automated test by first adding the necessary code to navigate to the message page:</p>
<pre class="programlisting">driver.get("https://automationintesting.online/#/admin/messages");</pre>
<p class="body">Then we create our final Page object, this time tweaking our prompt to ChatGPT to create a method that returns a count of messages:</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">Follow the prompt again, this time I require a method that returns me the count of messages:</p>
<pre class="programlisting">&lt;div class="messages"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-sm-2 rowHeader"&gt;
            &lt;p&gt;Name&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-9 rowHeader"&gt;
            &lt;p&gt;Subject&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-1"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row detail read-false" id="message0"&gt;
        &lt;div class="col-sm-2" data-testid="message0"&gt;
            &lt;p&gt;James Dean&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-9" data-testid="messageDescription0"&gt;
            &lt;p&gt;Booking enquiry&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-1"&gt;
            &lt;span data-testid="DeleteMessage0" class="fa fa-remove roomDelete"&gt;&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">It returns the following <code class="fm-code-in-text">MessagePage</code> class:<a id="idIndexMarker021"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;
 
import java.util.List;
 
public class MessagePage {
 
    @FindBy(className = "detail")
    private List&lt;WebElement&gt; messageList;
 
    public MessagePage(WebDriver driver) {
        PageFactory.initElements(driver, this);
    }
 
    public int getMessageCount() {
        return messageList.size();
    }
}</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">Like before, we create a <code class="fm-code-in-text">MessagePage</code> class in our codebase, fix our imports, and return to <code class="fm-code-in-text">MessageTest</code> to let Copilot predict the following code to complete our automated check:<a id="idIndexMarker022"/></p>
<pre class="programlisting">MessagePage messagePage = new MessagePage(driver);
assert messagePage.getMessageCount() == 1;</pre>
<h3 class="fm-head1" id="heading_id_6">7.1.3 Filling in gaps from generated code</h3>
<p class="body"><a id="marker-146"/>This completes our automated check, but if we were to run this code, it would likely result in the failure of the automated check. The failure occurs because, to get the message count, we must wait for the count to load, which is missing from our automated check. Although this failure differs from the incorrect test data being added by Copilot we experienced earlier, the reason for our current problem is similar. ChatGPT predicts the code we require based on what the prompt is asking and the HTML provided. It lacks the ability to understand what parts of our system may require waits in place to prevent an automated check from failing. However, we can resolve this problem by returning to ChatGPT and submitting the prompt:<a id="idIndexMarker023"/><a id="idIndexMarker024"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">Can you improve the <code class="fm-code-in-text1">MessagePage</code> class and have it wait for the message list to load</p>
</td>
</tr>
</tbody>
</table>
<p class="body">ChatGPT responds with an updated version of <code class="fm-code-in-text">MessagePage</code>:</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">private WebDriver driver;
private WebDriverWait wait;
 
@FindBy(className = "detail")
private List&lt;WebElement&gt; messageList;
 
public MessagePage(WebDriver driver) {
    this.driver = driver;
    // Adjust the timeout as needed
    this.wait = new WebDriverWait(driver, 10); 
    PageFactory.initElements(driver, this);
}
 
public int getMessageCount() {
    wait.until(ExpectedConditions.visibilityOfElementLocated(
      By.className("detail")));
 
    return messageList.size();
}</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">This is a step forward in improving our automated check, but it also demonstrates again how ChatGPT is trained on older versions of libraries and APIs. If we copy this code over to our check, we’ll see that <code class="fm-code-in-text">WebDriverWait</code> makes errors because it no longer takes integers—a change that came in after ChatGPT was trained on Selenium material. So, we need to update <code class="fm-code-in-text">WebDriverWait</code> to take a <code class="fm-code-in-text">Duration</code> parameter instead:<a id="idIndexMarker025"/><a id="idIndexMarker026"/><a id="marker-147"/></p>
<pre class="programlisting">this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));</pre>
<p class="body">Finally, to improve the feedback we get from our automated test, we update the assertion suggested by Copilot to a more informative one:</p>
<pre class="programlisting">assertEquals(1, messagePage.getMessageCount());</pre>
<p class="body">With all this in place, assuming there are no extra messages on the platform, we can run the check and see it pass. The key behavior to observe is how we used Copilot and ChatGPT to rapidly build our automated check. Instead of sending a prompt to ChatGPT such as</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">Create an automated test for a contact us form and check if the message has been created</p>
</td>
</tr>
</tbody>
</table>
<p class="body">which would result in quite a generic output requiring a lot of modification, we worked through each step of our automated check using Copilot and ChatGPT to rapidly create parts of the check, switching between tools to help us solve specific problems. If we return to our area-of-effect model, this approach is summarized in figure 7.4.</p>
<p class="body">The model shows us that if we are able to identify the specific actions that occur in an automated check—like determining what state a check requires or what assertions to make—then we can use an LLM effectively with said actions. As demonstrated in the example, ChatGPT and Copilot (and other LLM tools) are incredibly fast at predicting and generating code for our automation. However, they lack access to the context of the product we’re automating. Problems such as incorrect test data and missing waits require us to lead the creation of automation, with AI tools offering support where we need it most.</p>
<div class="figure">
<p class="figure1"><img alt="" class="calibre32" src="../../OEBPS/Images/CH07_F04_Winteringham2.png"/></p>
<p class="figurecaption">Figure 7.4 Area-of-effect model showing the skills an individual and tooling bring to the development of automated checks</p>
</div>
<div class="fm-sidebar-block">
<p class="fm-sidebar-title">Activity 7.2</p>
<p class="fm-sidebar-text">Use Copilot and ChatGPT to create your own automated check with <a class="url" href="https://automationintesting.online">https://automationintesting.online</a>. This time, create an automated check that does the following:</p>
<ul class="calibre5">
<li class="fm-list-bullet1">
<p class="list-s">Logs in to the admin section of the site</p>
</li>
<li class="fm-list-bullet1">
<p class="list-s">Creates a new room</p>
</li>
<li class="fm-list-bullet1">
<p class="list-s">Asserts that the room appears on the home page</p>
</li>
</ul>
<p class="fm-sidebar-text">Use the prompts shared in the example to generate your own Page objects, or build your own prompts that might be more effective.</p>
</div>
<h2 class="fm-head" id="heading_id_7">7.2 Improving existing UI automation<a id="marker-148"/></h2>
<p class="body">Our initial example demonstrated how we can work with LLM tools to rapidly create new automated checks, but what about existing checks? Working with automation means handling automated checks that fail due to flakiness or rapid changes within the product under test. How can LLM tools help us improve our automation rapidly, while ensuring they still deliver value? Let’s go back to the automated check we have just created and see how the patterns of use for LLMs can help us make more robust automated checks.<a id="idIndexMarker027"/><a id="idIndexMarker028"/></p>
<h3 class="fm-head1" id="heading_id_8">7.2.1 Updating state management to use an appropriate layer</h3>
<p class="body">If we assess what our automated check is focused on, we can see that the goal is to check whether messages can be seen in the Admin panel. What this means for our state management is that we don’t need to create our message through the UI. It’s slow and potentially brittle. So, let’s instead take a look at how we can create the message with an API call so that we can improve our automated check and learn how to use LLMs to build API calls.<a id="idIndexMarker029"/><a id="idIndexMarker030"/><a id="idIndexMarker031"/></p>
<p class="body">Our goal is to capture the HTTP request sent when creating a message via the Contact Us page and codify that into our automated test. So, our first step is to capture the HTTP request as a <code class="fm-code-in-text">curl</code> command by following these steps:<a id="idIndexMarker032"/><a id="marker-149"/></p>
<ol class="calibre18">
<li class="fm-list-bullet">
<p class="list">Open up Dev Tools within our browser.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Select the Network tab.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Manually send a message via the Contact Us form in the UI.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Locate the HTTP request on the Network tab and then copy the request to a <code class="fm-code-in-text">curl</code> command (right-click the request in Dev Tools).<a id="idIndexMarker033"/></p>
</li>
</ol>
<p class="body">With our command located, we can once again build a prompt that will convert our <code class="fm-code-in-text">curl</code> request into the required Java code using the following prompt. We first set out instructions for prompt and use delimiter tactic:<a id="idIndexMarker034"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">Convert the following <code class="fm-code-in-text1">curl</code> request delimited by triple hashes into Java using the following rules:<a id="idIndexMarker035"/></p>
<p class="body-table-list-a">   1.  The request is encapsulated in a method</p>
<p class="body-table-list-a">   2.  The method will use spring framework to send the HTTP request</p>
<p class="body-table-list-a">   3.  The HTTP response doesn’t need parsing</p>
<p class="body-table-list-a">   4.  The method will take a POJO that represents the HTTP payload as a parameter</p>
</td>
</tr>
</tbody>
</table>
<p class="body">We provide the <code class="fm-code-in-text">curl</code> request in the delimited section:<a id="idIndexMarker036"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">###
curl 'https://automationintesting.online/message/' -X POST -H
<span class="fm-code-continuation-arrow">➥</span>'Accept: application/json' -H 'Content-Type: application/json'
<span class="fm-code-continuation-arrow">➥</span>--data-raw '{"name":"Mark","email":"test@test.com",
<span class="fm-code-continuation-arrow">➥</span> "phone":"071234567890","subject":"This is a test message",
<span class="fm-code-continuation-arrow">➥</span> "description":"This allows me to create a message rapidly"}'
###</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">Similar to the prompt we used to create Page objects, this prompt sets out what we want ChatGPT to do in the initial sentence before adding specific instructions to help ChatGPT predict the correct code we require—for example, stating that the method wants the body payload parameter to come in the format of a POJO (Plain Old Java Object), ensuring that ChatGPT generates a solution that utilizes Java classes to construct our payload, rather than a JSON object stored within a large String that would be hard to parse and maintain. Passing the prompt in with the <code class="fm-code-in-text">curl</code> request added to the bottom of the prompt will yield the following code:<a id="marker-150"/><a id="idIndexMarker037"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.RequestEntity;
import org.springframework.web.client.RestTemplate;
 
public class HttpRequestSender {
    public void sendRequest(MessagePayload payload) {
        // Create a RestTemplate instance
        RestTemplate restTemplate = new RestTemplate();
 
        // Set the request URL
        String url = "https://automationintesting.online/message/";
 
        // Set the request headers
        HttpHeaders headers = new HttpHeaders();
        headers.set(HttpHeaders.ACCEPT,
        <span class="fm-code-continuation-arrow">➥</span>MediaType.APPLICATION_JSON_VALUE);
        headers.set(HttpHeaders.CONTENT_TYPE,
        <span class="fm-code-continuation-arrow">➥</span>MediaType.APPLICATION_JSON_VALUE);
 
        // Create the request entity with the payload and headers
        RequestEntity&lt;MessagePayload&gt; requestEntity = new 
        <span class="fm-code-continuation-arrow">➥</span>RequestEntity&lt;&gt;(
                payload,
                headers,
                HttpMethod.POST,
                URI.create(url)
        );
 
        // Send the HTTP request
        restTemplate.exchange(requestEntity, Void.class);
    }
}</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">This predicted code requires new dependencies to be added to our project, which we can request from ChatGPT with the following prompt:</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">What dependencies are required for this method?</p>
</td>
</tr>
</tbody>
</table>
<p class="body">which results in ChatGPT returning</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">We can then add the dependency into our <code class="fm-code-in-text">pom.xml</code>, ensuring that we are using the latest versions, followed by copying the HTTP request code into our framework in a new package named <code class="fm-code-in-text">requests</code>. I opted to rename the class from <code class="fm-code-in-text">HttpRequestSender</code> to <code class="fm-code-in-text">MessageRequest</code>.<a id="idIndexMarker038"/><a id="idIndexMarker039"/><a id="idIndexMarker040"/><a id="idIndexMarker041"/></p>
<p class="body">This gives us the required code to send a request, but because we informed ChatGPT that <code class="fm-code-in-text">sendRequest</code> would take a POJO parameter for the body of our request, we next need ChatGPT to create the code to build our POJO. To do this, we return to our existing chat with ChatGPT and add the following prompt:<a id="marker-151"/><a id="idIndexMarker042"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">Create me a POJO for <code class="fm-code-in-text1">MessagePayload</code> including constructors and getter and setter methods</p>
</td>
</tr>
</tbody>
</table>
<p class="body">The prompt makes it clear that we require constructors and getter/setter methods because these will be necessary for creating and sending our HTTP request. Sending the prompt to ChatGPT yields the following code:<a id="idIndexMarker043"/></p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<pre class="programlisting">public class MessagePayload {
    private String name;
    private String email;
    private String phone;
    private String subject;
    private String description;
 
    public MessagePayload() {
    }
 
    public MessagePayload(String name, String email, String phone,
 String subject, String description) {
        this.name = name;
        this.email = email;
        this.phone = phone;
        this.subject = subject;
        this.description = description;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public String getEmail() {
        return email;
    }
 
    public void setEmail(String email) {
        this.email = email;
    }
 
    public String getPhone() {
        return phone;
    }
 
    public void setPhone(String phone) {
        this.phone = phone;
    }
 
    public String getSubject() {
        return subject;
    }
 
    public void setSubject(String subject) {
        this.subject = subject;
    }
 
    public String getDescription() {
        return description;
    }
 
    public void setDescription(String description) {
        this.description = description;
    }
}</pre>
</td>
</tr>
</tbody>
</table>
<p class="body">Because we provided the <code class="fm-code-in-text">curl</code> request in the initial prompt, ChatGPT can predict what the code for our POJO should look like to create a message to send via HTTP, which can then be copied over to a <code class="fm-code-in-text">MessagePayload</code> class in the <code class="fm-code-in-text">requests</code> package of our project.<a id="idIndexMarker044"/><a id="idIndexMarker045"/><a id="marker-152"/><a id="idIndexMarker046"/></p>
<p class="body">With our classes in place to create a message payload and send a request to the <code class="fm-code-in-text">POST /message/</code> endpoint, we can then return to our <code class="fm-code-in-text">MessageTest</code> and use Copilot to improve our check. First, we remove the following section of our check:<a id="idIndexMarker047"/></p>
<pre class="programlisting">driver.get("https://automationintesting.online");
 
ContactFormPage contactFormPage = new ContactFormPage(driver);
contactFormPage.enterName("John Smith");
contactFormPage.enterEmail("test@email.com");
contactFormPage.enterPhone("07123456789");
contactFormPage.enterSubject("Testing");
contactFormPage.enterDescription("This is a test message");
contactFormPage.clickSubmitButton();</pre>
<p class="body">and start typing <code class="fm-code-in-text">MessagePayload</code> to trigger Copilot to add the following code as a replacement:<a id="idIndexMarker048"/></p>
<pre class="programlisting">MessagePayload messagePayload = new MessagePayload();
messagePayload.setName("Test User");
messagePayload.setEmail("test@email.com");
messagePayload.setPhone("0123456789");
messagePayload.setSubject("Test Subject");
messagePayload.setDescription("Test Description");
 
MessageRequest messageRequest = new MessageRequest();
messageRequest.sendRequest(messagePayload);</pre>
<p class="body">Similar to when we used Copilot to generate code for creating a message in the UI, running the automated check for the first time will result in a failure. The check will run and then receive a 400-status code because the predicted test data didn’t match the validation rules again. Therefore, to ensure that our message matches the necessary validation rules, we need to update the following methods with correct test data:</p>
<pre class="programlisting">messagePayload.setPhone("074123456789");
messagePayload.setDescription("Test Description that is larger");</pre>
<p class="body">Once these test data parameters are updated, we should now see the automated check pass again.</p>
<p class="body">This example demonstrates that we can use LLM tools to help us update specific aspects of our automated checks to make them more robust, but it requires us to have a good analytical eye for which areas of our checks require improvement. This is because we have knowledge of both our automated checks and our system under test, which is lacking in the tools we’ve used so far. For example, if we were to give ChatGPT the prompt</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-MW.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table">Suggest ways in which this automated test can be improved to make it less flakey</p>
</td>
</tr>
</tbody>
</table>
<p class="body">and then add our automated check code to the prompt, these would be the returned suggestions (in summary):</p>
<table border="0" class="contenttable-0-table" width="100%">
<colgroup class="contenttable-0-colgroup">
<col class="contenttable-0-col" span="1" width="7%"/>
<col class="contenttable-0-col" span="1" width="93%"/>
</colgroup>
<tbody class="contenttable-0-tbody">
<tr class="contenttable-0-tr">
<td class="contenttable-0-td">
<div class="figure2">
<p class="figure1"><img alt="" class="calibre7" height="40" src="../../OEBPS/Images/logo-openai.png" width="40"/></p>
</div>
</td>
<td class="contenttable-0-td">
<p class="body-table-list-a">   •   Add explicit waits</p>
<p class="body-table-list-a">   •   Use stable locators</p>
<p class="body-table-list-a">   •   Handle asynchronous operations</p>
<p class="body-table-list-a">   •   Isolate the test</p>
<p class="body-table-list-a">   •   Retry failed actions</p>
<p class="body-table-list-a">   •   Check for error conditions</p>
<p class="body-table-list-a">   •   Review and update the test environment</p>
</td>
</tr>
</tbody>
</table>
<p class="body"><a id="marker-153"/>These are all legitimate considerations, but they are generic problems and don’t necessarily give us enough information to solve specific problems. So instead, we frame the process of improvement, looking to tools to help us rapidly generate the necessary code.</p>
<div class="fm-sidebar-block">
<p class="fm-sidebar-title">Activity 7.3</p>
<p class="fm-sidebar-text">Using ChatGPT and Copilot, try turning the login process into an API call as well. For this exercise, you will need to create the code to<a id="idIndexMarker049"/></p>
<ul class="calibre5">
<li class="fm-list-bullet1">
<p class="list-s">Send credentials to <code class="fm-code-in-text1">POST /auth/login</code></p>
</li>
<li class="fm-list-bullet1">
<p class="list-s">Extract the <code class="fm-code-in-text1">token</code> value from the HTTP response<a id="idIndexMarker050"/></p>
</li>
<li class="fm-list-bullet1">
<p class="list-s">Store the <code class="fm-code-in-text1">token</code> value as a cookie in the browser before heading to the message page<a id="idIndexMarker051"/><a id="idIndexMarker052"/></p>
</li>
</ul>
</div>
<h3 class="fm-head1" id="heading_id_9">7.2.2 Getting into the groove with AI tools</h3>
<p class="body">This chapter demonstrated that regardless of whether we are building UI automation, API automation, or something entirely different, the pattern of success with AI is always the same. Our deep understanding of the design and structure of automated checks informs us when and where to use AI tools to help us with specific tasks to create and maintain valuable automation. The marketing around AI automation would have us believe that our role in creating automated checks is limited when AI is involved. But if we want automation that helps us create high-quality products, then our best course of action is to build a relationship with AI tools that places our skillset at the core of the work.<a id="idIndexMarker053"/><a id="idIndexMarker054"/><a id="marker-154"/></p>
<h2 class="fm-head" id="heading_id_10">Summary</h2>
<ul class="calibre5">
<li class="fm-list-bullet">
<p class="list">Attempting to generate a whole automated UI test using only a tool such as ChatGPT will likely require a lot of rework. Instead, we want to use AI tools selectively at specific points of the UI automation process.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Starting a new project with a tool such as Copilot can yield varying results.</p>
</li>
<li class="fm-list-bullet">
<p class="list">The more detail we add to our project, the more accurate Copilot will be.</p>
</li>
<li class="fm-list-bullet">
<p class="list">With the right type of prompt, we can rapidly generate Page objects in ChatGPT by providing it with HTML and instructions to convert it.</p>
</li>
<li class="fm-list-bullet">
<p class="list">We can rapidly generate automated checks by combining ChatGPT and Copilot (or similar tools).</p>
</li>
<li class="fm-list-bullet">
<p class="list">The output of AI tools is not 100% accurate, because it lacks context—for example, with test data or using up-to-date methods from libraries.</p>
</li>
<li class="fm-list-bullet">
<p class="list">Success with AI tools when creating automated checks comes from using AI tools to complete specific tasks within the creation process.</p>
</li>
<li class="fm-list-bullet">
<p class="list">We lead the creation process, identifying when AI tools can help us speed it up.</p>
</li>
<li class="fm-list-bullet">
<p class="list">If we are able to identify improvements to specific elements of an automated check, we can employ AI tools to make the improvements faster.</p>
</li>
<li class="fm-list-bullet">
<p class="list">If we ask LLMs to evaluate our checks and offer improvements, we get generic answers in return.</p>
</li>
<li class="fm-list-bullet">
<p class="list">We can use the same process of using AI tools on specific tasks within our automated checks to maintain them.</p>
</li>
</ul>
</div></body></html>