- en: 'Chapter 6\. The “Hello World” of TinyML: Deploying to Microcontrollers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。TinyML的“Hello World”：部署到微控制器
- en: 'Now it’s time to get our hands dirty. Over the course of this chapter, we will
    deploy the code to three different devices:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候动手了。在本章的过程中，我们将代码部署到三种不同的设备上：
- en: '[Arduino Nano 33 BLE Sense](https://oreil.ly/6qlMD)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Arduino Nano 33 BLE Sense](https://oreil.ly/6qlMD)'
- en: '[SparkFun Edge](https://oreil.ly/-hoL-)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SparkFun Edge](https://oreil.ly/-hoL-)'
- en: '[ST Microelectronics STM32F746G Discovery kit](https://oreil.ly/cvm4J)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ST Microelectronics STM32F746G Discovery kit](https://oreil.ly/cvm4J)'
- en: We’ll walk through the build and deployment process for each one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个讨论每个设备的构建和部署过程。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: TensorFlow Lite regularly adds support for new devices, so if the device you’d
    like to use isn’t listed here, it’s worth checking the example’s [*README.md*](https://oreil.ly/ez0ef).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow Lite定期添加对新设备的支持，因此如果您想使用的设备未在此处列出，值得查看示例的[*README.md*](https://oreil.ly/ez0ef)。
- en: You can also check there for updated deployment instructions if you run into
    trouble following these steps.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在按照这些步骤时遇到问题，您也可以在那里查看更新的部署说明。
- en: Every device has its own unique output capabilities, ranging from a bank of
    LEDs to a full LCD display, so the example contains a custom implementation of
    `HandleOutput()` for each one. We’ll also walk through each of these and talk
    about how its logic works. Even if you don’t have all of the devices, reading
    through this code should be interesting, so we strongly recommend taking a look.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都有自己独特的输出能力，从一组LED到完整的LCD显示器，因此示例包含每个设备的`HandleOutput()`的自定义实现。我们还将逐个讨论这些，并谈谈它们的逻辑如何工作。即使您没有所有这些设备，阅读这段代码也应该很有趣，因此我们强烈建议您查看一下。
- en: What Exactly Is a Microcontroller?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微控制器？
- en: Depending on your past experience, you might not be familiar with how microcontrollers
    interact with other electronic components. Because we’re about to start playing
    with hardware, it’s worth introducing some ideas before we move along.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的过去经验，您可能不熟悉微控制器如何与其他电子组件交互。因为我们即将开始玩硬件，所以在继续之前介绍一些概念是值得的。
- en: On a microcontroller board like the Arduino, SparkFun Edge, or STM32F746G Discovery
    kit, the actual microcontroller is just one of many electronic components attached
    to the circuit board. [Figure 6-1](#sparkfun_edge_microcontroller) shows the microcontroller
    on the SparkFun Edge.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Arduino、SparkFun Edge或STM32F746G Discovery kit这样的微控制器板上，实际的微控制器只是连接到电路板的许多电子组件之一。[图6-1](#sparkfun_edge_microcontroller)显示了SparkFun
    Edge上的微控制器。
- en: '![Image of SparkFun Edge board with its microcontroller highlighted](Images/timl_0601.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![突出显示其微控制器的SparkFun Edge板的图像](Images/timl_0601.png)'
- en: Figure 6-1\. The SparkFun Edge board with its microcontroller highlighted
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1。SparkFun Edge板上突出显示其微控制器
- en: The microcontroller is connected to the circuit board it lives on using *pins*.
    A typical microcontroller has dozens of pins, and they serve all sorts of purposes.
    Some provide power to the microcontroller; others connect it to various important
    components. Some pins are set aside for the input and output of digital signals
    by programs running on the microcontroller. These are called *GPIO* pins, which
    stands for general-purpose input/output. They can act as inputs, determining whether
    a voltage is being applied to them, or outputs, sourcing current that can power
    or communicate with other components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器使用*引脚*连接到其所在的电路板。典型的微控制器有数十个引脚，它们有各种用途。一些引脚为微控制器提供电源；其他连接到各种重要组件。一些引脚专门用于由运行在微控制器上的程序输入和输出数字信号。这些被称为*GPIO*引脚，代表通用输入/输出。它们可以作为输入，确定是否向其施加电压，或作为输出，提供可以为其他组件供电或通信的电流。
- en: GPIO pins are digital. This means that in output mode, they are like switches
    that can either be fully on, or fully off. In input mode, they can detect whether
    the voltage applied to them by another component is either above or below a certain
    threshold.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚是数字的。这意味着在输出模式下，它们就像开关，可以完全打开或完全关闭。在输入模式下，它们可以检测由其他组件施加在它们上的电压是高于还是低于某个阈值。
- en: In addition to GPIOs, some microcontrollers have analog input pins, which can
    measure the exact level of voltage that is being applied to them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了GPIO，一些微控制器还具有模拟输入引脚，可以测量施加在它们上的电压的确切水平。
- en: By calling special functions, the program running on a microcontroller can control
    whether a given pin is in input or output mode. Other functions are used to switch
    an output pin on or off, or to read the current state of an input pin.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用特殊函数，运行在微控制器上的程序可以控制特定引脚是输入模式还是输出模式。其他函数用于打开或关闭输出引脚，或读取输入引脚的当前状态。
- en: 'Now that you know a bit more about microcontrollers, let’s take a closer look
    at our first device: the Arduino.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对微控制器有了更多了解，让我们更仔细地看看我们的第一个设备：Arduino。
- en: Arduino
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino
- en: There are a huge variety of [Arduino](https://www.arduino.cc/) boards, all with
    different capabilities. Not all of them will run TensorFlow Lite for Microcontrollers.
    The board we recommend for this book is the [Arduino Nano 33 BLE Sense](https://oreil.ly/9g1bJ).
    In addition to being compatible with TensorFlow Lite, it also includes a microphone
    and an accelerometer (which we use in later chapters). We recommend buying the
    version of the board with headers, which makes it easier to connect other components
    without soldering.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的[Arduino](https://www.arduino.cc/)板，具有不同的功能。并非所有板都能运行TensorFlow Lite for
    Microcontrollers。我们推荐本书使用的板是[Arduino Nano 33 BLE Sense](https://oreil.ly/9g1bJ)。除了与TensorFlow
    Lite兼容外，它还包括麦克风和加速度计（我们将在后面的章节中使用）。我们建议购买带有引脚排针的板，这样可以更容易地连接其他组件而无需焊接。
- en: Most Arduino boards come with a built-in LED, and this is what we’ll be using
    to visually output our sine values. [Figure 6-2](#arduino_nano_sense_led) shows
    an Arduino Nano 33 BLE Sense board with the LED highlighted.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Arduino板都带有内置LED，这就是我们将用来可视化输出正弦值的内容。[图6-2](#arduino_nano_sense_led)显示了一个Arduino
    Nano 33 BLE Sense板，其中突出显示了LED。
- en: '![Image of the Arduino Nano 33 BLE Sense board with the LED highlighted](Images/timl_0602.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![突出显示的Arduino Nano 33 BLE Sense板上的LED的图像](Images/timl_0602.png)'
- en: Figure 6-2\. The Arduino Nano 33 BLE Sense board with the LED highlighted
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2。Arduino Nano 33 BLE Sense板上突出显示的LED
- en: Handling Output on Arduino
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Arduino上处理输出
- en: Because we have only one LED to work with, we need to think creatively. One
    option is to vary the brightness of the LED based on the most recently predicted
    sine value. Given that the value ranges from –1 to 1, we could represent 0 with
    an LED that is fully off, –1 and 1 with a fully lit LED, and any intermediate
    values with a partially dimmed LED. As the program runs inferences in a loop,
    the LED will fade repeatedly on and off.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只有一个LED可供使用，所以我们需要进行创造性思考。一种选择是根据最近预测的正弦值来改变LED的亮度。鉴于该值范围为-1到1，我们可以用完全关闭的LED表示0，用完全亮起的LED表示-1和1，用部分调暗的LED表示任何中间值。当程序在循环中运行推断时，LED将重复地变暗和变亮。
- en: We can vary the number of inferences we perform across a full sine wave cycle
    using the `kInferencesPerCycle` constant. Because one inference takes a set amount
    of time, tweaking `kInferencesPerCycle`, defined in *constants.cc*, will adjust
    how fast the LED fades.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kInferencesPerCycle`常量在完整正弦波周期内执行的推断数量。由于一个推断需要一定的时间，调整*constants.cc*中定义的`kInferencesPerCycle`将调整LED变暗的速度。
- en: There’s an Arduino-specific version of this file in [*hello_world/arduino/constants.cc*](https://oreil.ly/YNsvq).
    The file has been given the same name as *hello_world/constants.cc*, so it will
    be used instead of the original implementation when the application is built for
    Arduino.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*hello_world/arduino/constants.cc*](https://oreil.ly/YNsvq)中有一个特定于Arduino的版本的此文件。该文件与*hello_world/constants.cc*具有相同的名称，因此在为Arduino构建应用程序时将使用它来代替原始实现。
- en: To dim our built-in LED, we can use a technique called *pulse width modulation*
    (PWM). If we switch an output pin on and off extremely rapidly, the pin’s output
    voltage becomes a factor of the ratio between time spent in the off and on states.
    If the pin spends 50% of the time in each state, its output voltage will be 50%
    of its maximum. If it spends 75% in the on state and 25% in the off state, its
    voltage will be 75% of its maximum.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调暗我们的内置LED，我们可以使用一种称为*脉宽调制*（PWM）的技术。如果我们非常快速地打开和关闭一个输出引脚，那么引脚的输出电压将成为处于关闭和打开状态之间所花时间比率的因素。如果引脚在每种状态中花费的时间占50%，则其输出电压将是其最大值的50%。如果它在打开状态花费75%的时间，关闭状态花费25%的时间，则其电压将是其最大值的75%。
- en: 'PWM is only available on certain pins of certain Arduino devices, but it’s
    very easy to use: we just call a function that sets our desired output level for
    the pin.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PWM仅在某些Arduino设备的某些引脚上可用，但使用起来非常简单：我们只需调用一个设置所需输出电平的函数。
- en: The code that implements output handling for Arduino is in [*hello_world/arduino/output_handler.cc*](https://oreil.ly/OpLMB),
    which is used instead of the original file, *hello_world/output_handler.cc*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用于Arduino输出处理的代码位于[*hello_world/arduino/output_handler.cc*](https://oreil.ly/OpLMB)中，该代码用于替代原始文件*hello_world/output_handler.cc*。
- en: 'Let’s walk through the source:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下源代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we include some header files. Our *output_handler.h* specifies the interface
    for this file. *Arduino.h* provides the interface for the Arduino platform; we
    use this to control the board. Because we need access to `kInferencesPerCycle`,
    we also include *constants.h*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含一些头文件。我们的*output_handler.h*指定了此文件的接口。*Arduino.h*提供了Arduino平台的接口；我们使用它来控制板。因为我们需要访问`kInferencesPerCycle`，所以我们还包括*constants.h*。
- en: 'Next, we define the function and instruct it what to do the first time it runs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义函数并指示它第一次运行时要执行的操作：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In C++, a variable declared as `static` within a function will hold its value
    across multiple runs of the function. Here, we use the `is_initialized` variable
    to track whether the code in the following `if (!is_initialized)` block has ever
    been run before.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，函数内声明为`static`的变量将在函数的多次运行中保持其值。在这里，我们使用`is_initialized`变量来跟踪以下`if (!is_initialized)`块中的代码是否曾经运行过。
- en: 'The initialization block calls Arduino’s [`pinMode()`](https://oreil.ly/6Kxep)
    function, which indicates to the microcontroller whether a given pin should be
    in input or output mode. This is necessary before using a pin. The function is
    called with two constants defined by the Arduino platform: `LED_BUILTIN` and `OUTPUT`.
    `LED_BUILTIN` represents the pin connected to the board’s built-in LED, and `OUTPUT`
    represents output mode.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化块调用Arduino的[`pinMode()`](https://oreil.ly/6Kxep)函数，该函数指示微控制器给定的引脚应该处于输入模式还是输出模式。在使用引脚之前，这是必要的。该函数使用Arduino平台定义的两个常量调用：`LED_BUILTIN`和`OUTPUT`。`LED_BUILTIN`表示连接到板上内置LED的引脚，`OUTPUT`表示输出模式。
- en: After configuring the built-in LED’s pin to output mode, set `is_initialized`
    to `true` so that this block code will not run again.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将内置LED的引脚配置为输出模式后，将`is_initialized`设置为`true`，以便此代码块不会再次运行。
- en: 'Next up, we calculate the desired brightness of the LED:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算LED的期望亮度：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Arduino allows us to set the level of a PWM output as a number from 0 to
    255, where 0 means fully off and 255 means fully on. Our `y_value` is a number
    between –1 and 1\. The preceding code maps `y_value` to the range 0 to 255 so
    that when `y = -1` the LED is fully off, when `y = 0` the LED is half lit, and
    when `y = 1` the LED is fully lit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino允许我们将PWM输出的电平设置为0到255之间的数字，其中0表示完全关闭，255表示完全打开。我们的`y_value`是-1到1之间的数字。前面的代码将`y_value`映射到0到255的范围，因此当`y
    = -1`时，LED完全关闭，当`y = 0`时，LED亮度为一半，当`y = 1`时，LED完全亮起。
- en: 'The next step is to actually set the LED’s brightness:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实际设置LED的亮度：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Arduino platform’s [`analogWrite()`](https://oreil.ly/nNseR) function takes
    a pin number (we provide `LED_BUILTIN`) and a value between 0 and 255\. We provide
    our `brightness`, calculated in the previous line. When this function is called,
    the LED will be lit at that level.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino平台的[`analogWrite()`](https://oreil.ly/nNseR)函数接受一个介于0和255之间的值的引脚号（我们提供`LED_BUILTIN`）和我们在前一行中计算的`brightness`。当调用此函数时，LED将以该亮度点亮。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, on some models of Arduino boards, the pin that the built-in LED
    is connected to is not capable of PWM. This means our calls to `analogWrite()`
    won’t vary its brightness. Instead, the LED will be switched on if the value passed
    into `analogWrite()` is above 127, and switched off if it is 126 or below. This
    means the LED will flash on and off instead of fading. Not quite as cool, but
    it still demonstrates our sine wave prediction.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在某些型号的Arduino板上，内置LED连接的引脚不支持PWM。这意味着我们对`analogWrite()`的调用不会改变其亮度。相反，如果传递给`analogWrite()`的值大于127，则LED将打开，如果小于等于126，则LED将关闭。这意味着LED将闪烁而不是渐变。虽然不够酷，但仍然展示了我们的正弦波预测。
- en: 'Finally, we use the `ErrorReporter` instance to log the brightness value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`ErrorReporter`实例记录亮度值：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the Arduino platform, the `ErrorReporter` is set up to log data via a serial
    port. Serial is a very common way for microcontrollers to communicate with host
    computers, and it’s often used for debugging. It’s a communication protocol in
    which data is communicated one bit at a time by switching an output pin on and
    off. We can use it to send and receive anything, from raw binary data to text
    and numbers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino平台上，`ErrorReporter`被设置为通过串行端口记录数据。串行是微控制器与主机计算机通信的一种非常常见的方式，通常用于调试。这是一种通信协议，其中数据通过开关输出引脚一次一个位来传输。我们可以使用它发送和接收任何内容，从原始二进制数据到文本和数字。
- en: The Arduino IDE contains tools for capturing and displaying data received through
    a serial port. One of the tools, the Serial Plotter, can display a graph of values
    it receives via serial. By outputting a stream of brightness values from our code,
    we’ll be able to see them graphed. [Figure 6-3](#serial_plotter) shows this in
    action.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino IDE包含用于捕获和显示通过串行端口接收的数据的工具。其中一个工具是串行绘图器，可以显示通过串行接收的值的图形。通过从我们的代码输出一系列亮度值，我们将能够看到它们的图形。[图
    6-3](#serial_plotter)展示了这一过程。
- en: '![Screenshot of the Arduino IDE''s Serial Plotter](Images/timl_0603.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino IDE的串行绘图器截图](Images/timl_0603.png)'
- en: Figure 6-3\. The Arduino IDE’s Serial Plotter
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. Arduino IDE的串行绘图器
- en: We provide instructions on how to use the Serial Plotter later in this section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节后面提供如何使用串行绘图器的说明。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering how the `ErrorReporter` is able to output data via Arduino’s
    serial interface. You can find the code implementation in [*micro/arduino/debug_log.cc*](https://oreil.ly/fkF8H).
    It replaces the original implementation at [*micro/debug_log.cc*](https://oreil.ly/nxXgJ).
    Just like how *output_handler.cc* is overwritten, we can provide platform-specific
    implementations of any source file in TensorFlow Lite for Microcontrollers by
    adding them to a directory with the platform’s name.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道`ErrorReporter`如何通过Arduino的串行接口输出数据。您可以在[*micro/arduino/debug_log.cc*](https://oreil.ly/fkF8H)中找到代码实现。它替换了[*micro/debug_log.cc*](https://oreil.ly/nxXgJ)中的原始实现。就像*output_handler.cc*被覆盖一样，我们可以通过将它们添加到以平台名称命名的目录中，为TensorFlow
    Lite for Microcontrollers中的任何源文件提供特定于平台的实现。
- en: Running the Example
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: Our next task is to build the project for Arduino and deploy it to a device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务是为Arduino构建项目并将其部署到设备上。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There’s always a chance that the build process might have changed since this
    book was written, so check [*README.md*](https://oreil.ly/s2mj1) for the latest
    instructions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 建议检查[*README.md*](https://oreil.ly/s2mj1)以获取最新的指导，因为自本书编写以来构建过程可能已经发生变化。
- en: 'Here’s everything that we’ll need:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的一切如下：
- en: A supported Arduino board (we recommend the Arduino Nano 33 BLE Sense)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的Arduino板（我们推荐Arduino Nano 33 BLE Sense）
- en: The appropriate USB cable
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的USB电缆
- en: The [Arduino IDE](https://oreil.ly/c-rv6) (you’ll need to download and install
    this before continuing)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Arduino IDE](https://oreil.ly/c-rv6)（您需要下载并安装此软件才能继续）'
- en: The projects in this book are available as example code in the TensorFlow Lite
    Arduino library, which you can easily install via the Arduino IDE and select Manage
    Libraries from the Tools menu. In the window that appears, search for and install
    the library named *Arduino_TensorFlowLite*. You should be able to use the latest
    version, but if you run into issues, the version that was tested with this book
    is `1.14-ALPHA`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的项目作为TensorFlow Lite Arduino库中的示例代码可用，您可以通过Arduino IDE轻松安装，并从工具菜单中选择管理库。在弹出的窗口中，搜索并安装名为*Arduino_TensorFlowLite*的库。您应该能够使用最新版本，但如果遇到问题，本书测试过的版本是`1.14-ALPHA`。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also install the library from a *.zip* file, which you can either [download](https://oreil.ly/blgB8)
    from the TensorFlow Lite team or generate yourself using the TensorFlow Lite for
    Microcontrollers Makefile. If you’d prefer to do this, see [Appendix A](app01.xhtml#appendix_arduino_library_zip).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从*.zip*文件安装库，您可以从TensorFlow Lite团队[下载](https://oreil.ly/blgB8)，或者使用TensorFlow
    Lite for Microcontrollers Makefile自动生成。如果您更喜欢这样做，请参见[附录 A](app01.xhtml#appendix_arduino_library_zip)。
- en: After you’ve installed the library, the `hello_world` example will show up in
    the File menu under Examples→Arduino_TensorFlowLite, as shown in [Figure 6-4](#arduino_examples_hello_world).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完库后，`hello_world`示例将显示在文件菜单下的Examples→Arduino_TensorFlowLite中，如[图 6-4](#arduino_examples_hello_world)所示。
- en: Click “hello_world” to load the example. It will appear as a new window, with
    a tab for each of the source files. The file in the first tab, *hello_world*,
    is equivalent to the *main_functions.cc* we walked through earlier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“hello_world”加载示例。它将显示为一个新窗口，每个源文件都有一个选项卡。第一个选项卡中的文件*hello_world*相当于我们之前讨论过的*main_functions.cc*。
- en: '![Screenshot of the ''Examples'' menu](Images/timl_0604.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![“示例”菜单的截图](Images/timl_0604.png)'
- en: Figure 6-4\. The Examples menu
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 示例菜单
- en: To run the example, plug in your Arduino device via USB. Make sure the correct
    device type is selected from the Board drop-down list in the Tools menu, as shown
    in [Figure 6-5](#arduino_board_dropdown).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请通过USB连接您的Arduino设备。确保在工具菜单中从板下拉列表中选择正确的设备类型，如[图 6-5](#arduino_board_dropdown)所示。
- en: '![Screenshot of the ''Board'' dropdown](Images/timl_0605.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![“板”下拉菜单的截图](Images/timl_0605.png)'
- en: Figure 6-5\. The Board drop-down list
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-5。板下拉列表
- en: If your device’s name doesn’t appear in the list, you’ll need to install its
    support package. To do this, click Boards Manager. In the window that appears,
    search for your device and install the latest version of the corresponding support
    package.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备名称未出现在列表中，则需要安装其支持包。要执行此操作，请单击“Boards Manager”。在出现的窗口中，搜索您的设备并安装相应支持包的最新版本。
- en: Next, make sure the device’s port is selected in the Port drop-down list, also
    in the Tools menu, as shown in [Figure 6-6](#arduino_port_dropdown).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请确保在“端口”下拉列表中选择了设备的端口，也在工具菜单中，如[图6-6](#arduino_port_dropdown)所示。
- en: '![Screenshot of the ''Port'' dropdown](Images/timl_0606.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![“端口”下拉列表的屏幕截图](Images/timl_0606.png)'
- en: Figure 6-6\. The Port drop-down list
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-6。端口下拉列表
- en: Finally, in the Arduino window, click the upload button (highlighted in white
    in [Figure 6-7](#arduino_upload_button)) to compile and upload the code to your
    Arduino device.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Arduino窗口中，单击上传按钮（在[图6-7](#arduino_upload_button)中用白色突出显示）来编译并将代码上传到您的Arduino设备。
- en: '![Screenshot of the upload button, which has an arrow icon](Images/timl_0607.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![具有箭头图标的上传按钮的屏幕截图](Images/timl_0607.png)'
- en: Figure 6-7\. The upload button, a right-facing arrow
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-7。上传按钮，一个右箭头
- en: After the upload has successfully completed you should see the LED on your Arduino
    board begin either fading in and out or flashing on and off, depending on whether
    the pin it is attached to supports PWM.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上传成功完成后，您应该看到Arduino板上的LED开始淡入淡出或闪烁，具体取决于其连接的引脚是否支持PWM。
- en: 'Congratulations: you’re running ML on-device!'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜：您正在设备上运行ML！
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Different models of Arduino boards have different hardware, and will run inference
    at varying speeds. If your LED is either flickering or stays fully on, you might
    need to increase the number of inferences per cycle. You can do this via the `kInferencesPerCycle`
    constant in *arduino_constants.cpp*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不同型号的Arduino板具有不同的硬件，并且将以不同的速度运行推断。如果您的LED要么闪烁要么保持完全开启，您可能需要增加每个周期的推断次数。您可以通过*arduino_constants.cpp*中的`kInferencesPerCycle`常量来实现这一点。
- en: '[“Making Your Own Changes”](#hello_world_arduino_making_your_own_changes) shows
    you how to edit the example’s code.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[“进行您自己的更改”](#hello_world_arduino_making_your_own_changes)向您展示如何编辑示例代码。'
- en: You can also view the brightness value plotted on a graph. To do this, open
    the Arduino IDE’s Serial Plotter by selecting it in the Tools menu, as shown in
    [Figure 6-8](#serial_plotter_menu).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看绘制在图表上的亮度值。要执行此操作，请在工具菜单中选择Arduino IDE的串行绘图器，如[图6-8](#serial_plotter_menu)所示。
- en: '![Screenshot of the Serial Plotter menu option](Images/timl_0608.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![串行绘图器菜单选项的屏幕截图](Images/timl_0608.png)'
- en: Figure 6-8\. The Serial Plotter menu option
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-8。串行绘图器菜单选项
- en: The plotter shows the value as it changes over time, as demonstrated in [Figure 6-9](#serial_plotter_2).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图器显示随时间变化的值，如[图6-9](#serial_plotter_2)所示。
- en: '![Screenshot of the Arduino IDE''s Serial Plotter](Images/timl_0603.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino IDE的串行图绘屏幕截图](Images/timl_0603.png)'
- en: Figure 6-9\. The Serial Plotter graphing the value
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-9。串行绘图器绘制值
- en: To view the raw data that is received from the Arduino’s serial port, open the
    Serial Monitor from the Tools menu. You’ll see a stream of numbers flying past,
    like in [Figure 6-10](#serial_monitor).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看从Arduino串行端口接收的原始数据，请从工具菜单中打开串行监视器。您将看到一系列数字飞过，就像[图6-10](#serial_monitor)中所示。
- en: '![Screenshot of the Arduino IDE''s Serial Monitor](Images/timl_0610.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino IDE的串行监视器的屏幕截图](Images/timl_0610.png)'
- en: Figure 6-10\. The Serial Monitor displaying raw data
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-10。显示原始数据的串行监视器
- en: Making Your Own Changes
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行您自己的更改
- en: Now that you’ve deployed the application, it might be fun to play around and
    make some changes to the code. You can edit the source files in the Arduino IDE.
    When you save, you’ll be prompted to resave the example in a new location. When
    you’re done making changes, you can click the upload button in the Arduino IDE
    to build and deploy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经部署了应用程序，可能会很有趣地玩耍并对代码进行一些更改。您可以在Arduino IDE中编辑源文件。保存时，您将被提示在新位置重新保存示例。完成更改后，您可以在Arduino
    IDE中单击上传按钮来构建和部署。
- en: 'To get started making changes, here are a few experiments you could try:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始进行更改，您可以尝试以下几个实验：
- en: Make the LED blink slower or faster by adjusting the number of inferences per
    cycle.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调整每个周期的推断次数来使LED闪烁速度变慢或变快。
- en: Modify *output_handler.cc* to log a text-based animation to the serial port.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改*output_handler.cc*以将基于文本的动画记录到串行端口。
- en: Use the sine wave to control other components, like additional LEDs or sound
    generators.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正弦波来控制其他组件，如额外的LED或声音发生器。
- en: SparkFun Edge
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SparkFun Edge
- en: The [SparkFun Edge](https://oreil.ly/-hoL-) development board was designed specifically
    as a platform for experimenting with machine learning on tiny devices. It has
    a power-efficient Ambiq Apollo 3 microcontroller with an Arm Cortex M4 processor
    core.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[SparkFun Edge](https://oreil.ly/-hoL-)开发板专门设计为在微型设备上进行机器学习实验的平台。它具有功耗高效的Ambiq
    Apollo 3微控制器，带有Arm Cortex M4处理器核心。'
- en: It features a bank of four LEDs, as shown in [Figure 6-11](#sparkfun_edge_leds).
    We use these to visually output our sine values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有四个LED的一组，如[图6-11](#sparkfun_edge_leds)所示。我们使用这些LED来直观输出我们的正弦值。
- en: '![Photo of the SparkFun Edge highlighting its four LEDs](Images/timl_0611.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![突出显示其四个LED的SparkFun Edge的照片](Images/timl_0611.png)'
- en: Figure 6-11\. The SparkFun Edge’s four LEDs
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-11。SparkFun Edge的四个LED
- en: Handling Output on SparkFun Edge
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在SparkFun Edge上处理输出
- en: We can use the board’s bank of LEDs to make a simple animation, because nothing
    says cutting-edge AI like [blinkenlights](https://oreil.ly/T90fy).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用板上的一组LED制作一个简单的动画，因为没有什么比[blinkenlights](https://oreil.ly/T90fy)更能展示尖端人工智能了。
- en: 'The LEDs (red, green, blue, and yellow) are physically lined up in the following
    order:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: LED（红色、绿色、蓝色和黄色）在以下顺序中物理排列：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following table represents how we will light the LEDs for different `y`
    values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格表示我们将如何为不同的`y`值点亮LED：
- en: '| Range | LEDs lit |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 点亮的LED |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0.75 <= y <= 1` | `[ 0 0 1 1 ]` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `0.75 <= y <= 1` | `[ 0 0 1 1 ]` |'
- en: '| `0 < y < 0.75` | `[ 0 0 1 0 ]` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `0 < y < 0.75` | `[ 0 0 1 0 ]` |'
- en: '| `y = 0` | `[ 0 0 0 0 ]` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `y = 0` | `[ 0 0 0 0 ]` |'
- en: '| `-0.75 < y < 0` | `[ 0 1 0 0 ]` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `-0.75 < y < 0` | `[ 0 1 0 0 ]` |'
- en: '| `-1 <= y <= 0.75` | `[ 1 1 0 0 ]` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `-1 <= y <= 0.75` | `[ 1 1 0 0 ]` |'
- en: Each inference takes a certain amount of time, so tweaking `kInferencesPerCycle`,
    defined in *constants.cc*, will adjust how fast the LEDs cycle.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每次推断需要一定的时间，所以调整`kInferencesPerCycle`，在*constants.cc*中定义，将调整LED循环的速度。
- en: '[Figure 6-12](#sparkfun_edge_gif_still) shows a still from an [animated *.gif*](https://oreil.ly/cXdPY)
    of the program running.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-12](#sparkfun_edge_gif_still)显示了程序运行的一个静态图像，来自一个动画*.gif*。'
- en: '![A still from the animation of the SparkFun Edge''s LEDs](Images/timl_0612.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![来自SparkFun Edge LED动画的静态图像](Images/timl_0612.png)'
- en: Figure 6-12\. A still from the animation of the SparkFun Edge’s LEDs
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-12。来自SparkFun Edge LED动画的静态图像
- en: The code that implements output handling for the SparkFun Edge is in [*hello_world/sparkfun_edge/output_handler.cc*](https://oreil.ly/tegLK),
    which is used instead of the original file, *hello_world/output_handler.cc*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实现SparkFun Edge的输出处理的代码在[*hello_world/sparkfun_edge/output_handler.cc*](https://oreil.ly/tegLK)中，用于替代原始文件*hello_world/output_handler.cc*。
- en: 'Let’s start walking through it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始逐步进行：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we include some header files. Our *output_handler.h* specifies the interface
    for this file. The other file, *am_bsp.h,* comes from something called the *Ambiq
    Apollo3 SDK*. Ambiq is the manufacturer of the SparkFun Edge’s microcontroller,
    which is called the Apollo3\. The SDK (short for *software development kit*) is
    a collection of source files that define constants and functions that can be used
    to control the microcontroller’s features.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含一些头文件。我们的*output_handler.h*指定了此文件的接口。另一个文件*am_bsp.h*来自一个叫做*Ambiq Apollo3
    SDK*的东西。Ambiq是SparkFun Edge微控制器的制造商，称为Apollo3。SDK（软件开发工具包）是一组源文件，定义了可以用来控制微控制器功能的常量和函数。
- en: Because we are planning to control the board’s LEDs, we need to be able to switch
    the microcontroller’s pins on and off. This is what we use the SDK for.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们计划控制板上的LED，所以我们需要能够打开和关闭微控制器的引脚。这就是我们使用SDK的原因。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Makefile will automatically download the SDK when we eventually build the
    project. If you’re curious, you can read more about it or download the code to
    explore on [SparkFun’s website](https://oreil.ly/RHHqI).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最终构建项目时，Makefile将自动下载SDK。如果你感兴趣，可以在[SparkFun的网站](https://oreil.ly/RHHqI)上阅读更多关于它的信息或下载代码进行探索。
- en: 'Next, we define the `HandleOutput()` function and indicate what to do on its
    first run:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`HandleOutput()`函数，并指示在其第一次运行时要执行的操作：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Phew, that’s a lot of setup! We’re using the `am_hal_gpio_pinconfig()` function,
    provided by *am_bsp.h*, to configure the pins connected to the board’s built-in
    LEDs, putting them into output mode (represented by the `g_AM_HAL_GPIO_OUTPUT_12`
    constant). The pin number of each LED is represented by a constant, such as `AM_BSP_GPIO_LED_RED`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这是很多的设置！我们使用`am_hal_gpio_pinconfig()`函数，由*am_bsp.h*提供，来配置连接到板上内置LED的引脚，将它们设置为输出模式（由`g_AM_HAL_GPIO_OUTPUT_12`常量表示）。每个LED的引脚号由一个常量表示，比如`AM_BSP_GPIO_LED_RED`。
- en: 'We then clear all of the outputs using `am_hal_gpio_output_clear()`, so the
    LEDs are all switched off. As in the Arduino implementation, we use a `static`
    variable named `is_initialized` to ensure the code in this block is run only once.
    Next, we determine which LEDs should be lit if the `y` value is negative:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`am_hal_gpio_output_clear()`清除所有输出，以便所有LED都关闭。与Arduino实现一样，我们使用名为`is_initialized`的`static`变量，以确保此块中的代码仅运行一次。接下来，我们确定如果`y`值为负时应点亮哪些LED：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, in case the `y` value only just became negative, we clear the two LEDs
    that are used to indicate positive values. Next, we call `am_hal_gpio_output_set()`
    to switch on the blue LED, which will always be lit if the value is negative.
    Finally, if the value is less than –0.75, we switch on the red LED. Otherwise,
    we switch it off.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果`y`值刚刚变为负数，我们清除用于指示正值的两个LED。接下来，我们调用`am_hal_gpio_output_set()`来打开蓝色LED，如果值为负数，它将始终点亮。最后，如果值小于-0.75，我们打开红色LED。否则，我们关闭它。
- en: 'Next up, we do the same thing but for positive values of `y`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们做同样的事情，但是对于`y`的正值：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That’s just about it for the LEDs. The last thing we do is log the current
    output values to anyone who is listening on the serial port:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: LED就是这样。我们最后要做的是将当前的输出值记录到串口上正在监听的人：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Our `ErrorReporter` is able to output data via the SparkFun Edge’s serial interface
    due to a custom implementation of [*micro/sparkfun_edge/debug_log.cc*](https://oreil.ly/ufEv9)
    that replaces the original implementation at [*mmicro/debug_log.cc*](https://oreil.ly/ACaFt).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ErrorReporter`能够通过SparkFun Edge的串行接口输出数据，这是由于[*micro/sparkfun_edge/debug_log.cc*](https://oreil.ly/ufEv9)的自定义实现取代了[*mmicro/debug_log.cc*](https://oreil.ly/ACaFt)中的原始实现。
- en: Running the Example
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: Now we can build the sample code and deploy it to the SparkFun Edge.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建示例代码并将其部署到SparkFun Edge上。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There’s always a chance that the build process might have changed since this
    book was written, so check [*README.md*](https://oreil.ly/EcPZ8) for the latest
    instructions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程可能会有变化，因为这本书写作时，所以请查看[*README.md*](https://oreil.ly/EcPZ8)获取最新的指导。
- en: 'To build and deploy our code, we’ll need the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和部署我们的代码，我们需要以下内容：
- en: A SparkFun Edge board
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SparkFun Edge板
- en: A USB programmer (we recommend the SparkFun Serial Basic Breakout, which is
    available in [micro-B USB](https://oreil.ly/A6oDw) and [USB-C](https://oreil.ly/3REjg)
    variants)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个USB编程器（我们推荐SparkFun Serial Basic Breakout，可在[micro-B USB](https://oreil.ly/A6oDw)和[USB-C](https://oreil.ly/3REjg)变体中获得）
- en: A matching USB cable
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根匹配的USB电缆
- en: Python 3 and some dependencies
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3和一些依赖项
- en: 'To begin, open a terminal, clone the TensorFlow repository, and then change
    into its directory:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个终端，克隆TensorFlow存储库，然后切换到其目录：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we’re going to build the binary and run some commands that get it ready
    for downloading to the device. To avoid some typing, you can copy and paste these
    commands from [*README.md*](https://oreil.ly/PYmUu).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建二进制文件，并运行一些命令，使其准备好下载到设备中。为了避免一些打字错误，您可以从[*README.md*](https://oreil.ly/PYmUu)中复制并粘贴这些命令。
- en: Build the binary
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建二进制文件
- en: 'The following command downloads all the required dependencies and then compiles
    a binary for the SparkFun Edge:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令下载所有必需的依赖项，然后为SparkFun Edge编译一个二进制文件：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A binary is a file that contains the program in a form that can be run directly
    by the SparkFun Edge hardware.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件是包含程序的文件，可以直接由SparkFun Edge硬件运行。
- en: 'The binary will be created as a *.bin* file, in the following location:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件将被创建为*.bin*文件，位置如下：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To check that the file exists, you can use the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查文件是否存在，您可以使用以下命令：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you run that command, you should see `Binary was successfully created` printed
    to the console.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行该命令，您应该看到`二进制文件已成功创建`打印到控制台。
- en: If you see `Binary is missing`, there was a problem with the build process.
    If so, it’s likely that you can find some clues to what went wrong in the output
    of the `make` command.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看到`二进制文件丢失`，则构建过程中出现问题。如果是这样，很可能您可以在`make`命令的输出中找到一些出错的线索。
- en: Sign the binary
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对二进制文件进行签名
- en: The binary must be signed with cryptographic keys to be deployed to the device.
    Let’s now run some commands that will sign the binary so it can be flashed to
    the SparkFun Edge. The scripts used here come from the Ambiq SDK, which is downloaded
    when the Makefile is run.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用加密密钥对二进制文件进行签名，以便部署到设备上。现在让我们运行一些命令，对二进制文件进行签名，以便将其刷写到SparkFun Edge。这里使用的脚本来自Ambiq
    SDK，在运行Makefile时下载。
- en: 'Enter the following command to set up some dummy cryptographic keys that you
    can use for development:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令设置一些虚拟的加密密钥，供开发使用：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, run the following command to create a signed binary. Substitute `python3`
    with `python` if necessary:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令创建一个已签名的二进制文件。如有必要，将`python3`替换为`python`：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This creates the file *main_nonsecure_ota.bin*. Now run this command to create
    a final version of the file that you can use to flash your device with the script
    you will use in the next step:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建文件*main_nonsecure_ota.bin*。现在运行以下命令以创建文件的最终版本，您可以使用该文件通过下一步中将使用的脚本刷写设备：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should now have a file called *main_nonsecure_wire.bin* in the directory
    where you ran the commands. This is the file you’ll be flashing to the device.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在运行命令的目录中有一个名为*main_nonsecure_wire.bin*的文件。这是您将要刷写到设备上的文件。
- en: Flash the binary
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刷写二进制文件
- en: The SparkFun Edge stores the program it is currently running in its 1 megabyte
    of flash memory. If you want the board to run a new program, you need to send
    it to the board, which will store it in flash memory, overwriting any program
    that was previously saved.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: SparkFun Edge将当前运行的程序存储在其1兆字节的闪存中。如果要让板运行新程序，您需要将其发送到板上，板将其存储在闪存中，覆盖先前保存的任何程序。
- en: This process is called *flashing*. Let’s walk through the steps.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程称为*刷写*。让我们一步步走过这些步骤。
- en: Attach the programmer to the board
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将编程器连接到板上
- en: To download new programs to the board, you’ll use the SparkFun USB-C Serial
    Basic serial programmer. This device allows your computer to communicate with
    the microcontroller via USB.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新程序下载到板上，您将使用SparkFun USB-C串行基本串行编程器。该设备允许您的计算机通过USB与微控制器通信。
- en: 'To attach this device to your board, perform the following steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此设备连接到您的板上，请执行以下步骤：
- en: On the side of the SparkFun Edge, locate the six-pin header.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SparkFun Edge的一侧，找到六针排针。
- en: Plug the SparkFun USB-C Serial Basic into these pins, ensuring that the pins
    labeled BLK and GRN on each device are lined up correctly.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SparkFun USB-C串行基本插入这些引脚，确保每个设备上标有BLK和GRN的引脚正确对齐。
- en: You can see the correct arrangement in [Figure 6-13](#sparkfun_edge_serial_basic).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图6-13](#sparkfun_edge_serial_basic)中看到正确的排列方式。
- en: '![A photo showing how the SparkFun Edge and USB-C Serial Basic should be connected](Images/timl_0613.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![显示SparkFun Edge和USB-C串行基本连接方式的照片](Images/timl_0613.png)'
- en: Figure 6-13\. Connecting the SparkFun Edge and USB-C Serial Basic (courtesy
    of SparkFun)
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-13\. 连接SparkFun Edge和USB-C串行基本（由SparkFun提供）
- en: Attach the programmer to your computer
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将编程器连接到计算机
- en: Next, connect the board to your computer via USB. To program the board, you
    need to determine the name that your computer gives the device. The best way of
    doing this is to list all of the computer’s devices before and after attaching
    it and then look to see which device is new.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过USB将板连接到计算机。要对板进行编程，您需要确定计算机给设备的名称。最好的方法是在连接设备之前和之后列出计算机的所有设备，然后查看哪个设备是新的。
- en: Warning
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Some people have reported issues with their operating system’s default drivers
    for the programmer, so we strongly recommend installing the [driver](https://oreil.ly/Wkxaf)
    before you continue.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人报告了使用编程器的操作系统默认驱动程序出现问题，因此我们强烈建议在继续之前安装[驱动程序](https://oreil.ly/Wkxaf)。
- en: 'Before attaching the device via USB, run the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过USB连接设备之前，请运行以下命令：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should output a list of attached devices that looks something like the
    following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出一个类似以下内容的附加设备列表：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, connect the programmer to your computer’s USB port and run the command
    again:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将编程器连接到计算机的USB端口，并再次运行命令：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see an extra item in the output, as in the example that follows.
    Your new item might have a different name. This new item is the name of the device:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在输出中看到一个额外的项目，如下例所示。您的新项目可能有不同的名称。这个新项目是设备的名称：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This name will be used to refer to the device. However, it can change depending
    on which USB port the programmer is attached to, so if you disconnect the board
    from your computer and then reattach it, you might need to look up its name again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称将用于引用设备。但是，它可能会根据编程器连接到的USB端口而改变，因此如果您从计算机断开板然后重新连接，可能需要再次查找其名称。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Some users have reported two devices appearing in the list. If you see two devices,
    the correct one to use begins with the letters “wch”; for example, “/dev/wchusbserial-14410.”
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用户报告列表中出现了两个设备。如果看到两个设备，正确的设备名称应以“wch”开头；例如，“/dev/wchusbserial-14410”。
- en: 'After you’ve identified the device name, put it in a shell variable for later
    use:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 确定设备名称后，将其放入一个shell变量以供以后使用：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a variable that you can use when running commands that require the device
    name, later in the process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个变量，您可以在后续过程中运行需要设备名称的命令时使用。
- en: Run the script to flash your board
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行脚本以刷写您的板子
- en: To flash the board, you need to put it into a special “bootloader” state that
    prepares it to receive the new binary. You can then run a script to send the binary
    to the board.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要刷写板子，您需要将其放入特殊的“引导加载程序”状态，以准备接收新的二进制文件。然后可以运行脚本将二进制文件发送到板子上。
- en: 'First create an environment variable to specify the baud rate, which is the
    speed at which data will be sent to the device:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个环境变量来指定波特率，即数据发送到设备的速度：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now paste the command that follows into your terminal—but *do not press Enter
    yet*!. The `${DEVICENAME}` and `${BAUD_RATE}` in the command will be replaced
    with the values you set in the previous sections. Remember to substitute `python3`
    with `python` if necessary:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下命令粘贴到您的终端中——但*不要按Enter键*！命令中的`${DEVICENAME}`和`${BAUD_RATE}`将被替换为您在前面部分设置的值。如果需要，请记得将`python3`替换为`python`：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, you’ll reset the board into its bootloader state and flash the board.
    On the board, locate the buttons marked `RST` and `14`, as shown in [Figure 6-14](#sparkfun_edge_buttons).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将重置板子到引导加载程序状态并刷写板子。在板子上，找到标记为`RST`和`14`的按钮，如[图6-14](#sparkfun_edge_buttons)所示。
- en: '![A photo showing the SparkFun Edge''s buttons](Images/timl_0614.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![显示SparkFun Edge按钮的照片](Images/timl_0614.png)'
- en: Figure 6-14\. The SparkFun Edge’s buttons
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-14。SparkFun Edge的按钮
- en: 'Perform the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Ensure that your board is connected to the programmer and that the entire thing
    is connected to your computer via USB.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的板子连接到编程器，并且整个设备通过USB连接到计算机。
- en: On the board, press and hold the button marked `14`. *Continue holding it.*
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在板子上，按住标记为`14`的按钮。*继续按住它*。
- en: While still holding the button marked `14`, press the button marked `RST` to
    reset the board.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续按住标记为`14`的按钮的同时，按下标记为`RST`的按钮重置板子。
- en: Press Enter on your computer to run the script. *Continue holding button `14`.*
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算机上按Enter键运行脚本。*继续按住按钮`14`*。
- en: 'You should now see something like the following appearing on your screen:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在屏幕上看到类似以下内容的东西：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Keep holding button `14` until you see `Sending Data Packet of length 8180`.
    You can release the button after seeing this (but it’s okay if you keep holding
    it).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 继续按住按钮`14`，直到看到`发送数据包长度为8180`。在看到这个之后可以释放按钮（但如果您继续按住也没关系）。
- en: 'The program will continue to print lines on the terminal. Eventually you will
    see something like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将继续在终端上打印行。最终您会看到类似以下内容的东西：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This indicates a successful flashing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明刷写成功。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If the program output ends with an error, check whether `Sending Reset Command.`
    was printed. If so, flashing was likely successful despite the error. Otherwise,
    flashing might have failed. Try running through these steps again (you can skip
    over setting the environment variables).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序输出以错误结束，请检查是否打印了`发送复位命令`。如果是，则刷写可能成功，尽管有错误。否则，刷写可能失败。尝试再次运行这些步骤（您可以跳过设置环境变量）。
- en: Testing the Program
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试程序
- en: The binary should now be deployed to the device. Press the button marked `RST`
    to reboot the board. You should see the device’s four LEDs flashing in sequence.
    Nice work!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该已经将二进制文件部署到设备上。按下标记为`RST`的按钮重新启动板子。您应该看到设备的四个LED按顺序闪烁。干得好！
- en: Viewing Debug Data
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看调试数据
- en: 'Debug information is logged by the board while the program is running. To view
    it, we can monitor the board’s serial port output using a baud rate of 115200\.
    On macOS and Linux, the following command should work:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行时，板子会记录调试信息。要查看它，我们可以使用波特率115200监视板子的串行端口输出。在macOS和Linux上，以下命令应该有效：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see a lot of output flying past! To stop the scrolling, press Ctrl-A,
    immediately followed by Esc. You can then use the arrow keys to explore the output,
    which will contain the results of running inference on various `x` values:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到大量的输出飞过！要停止滚动，请按下Ctrl-A，紧接着按Esc。然后您可以使用箭头键浏览输出，其中包含对各种`x`值运行推断的结果：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To stop viewing the debug output with `screen`, press Ctrl-A, immediately followed
    by the K key, and then press the Y key.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止使用`screen`查看调试输出，请按下Ctrl-A，紧接着按下K键，然后按下Y键。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The program `screen` is a helpful utility program for connecting to other computers.
    In this case, we’re using it to listen to the data the SparkFun Edge board is
    logging via its serial port. If you’re using Windows, you could try using the
    program [`CoolTerm`](https://oreil.ly/sPWQP) to do the same thing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 程序`screen`是一个有用的连接到其他计算机的实用程序程序。在这种情况下，我们使用它来监听SparkFun Edge板通过其串行端口记录的数据。如果您使用Windows，可以尝试使用程序[`CoolTerm`](https://oreil.ly/sPWQP)来做同样的事情。
- en: Making Your Own Changes
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行您自己的更改
- en: Now that you’ve deployed the basic application, try playing around and making
    some changes. You can find the application’s code in the *tensorflow/lite/micro/examples/hello_world*
    folder. Just edit and save, and then repeat the previous instructions to deploy
    your modified code to the device.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经部署了基本应用程序，请尝试玩耍并进行一些更改。您可以在*tensorflow/lite/micro/examples/hello_world*文件夹中找到应用程序的代码。只需编辑并保存，然后重复之前的说明以将修改后的代码部署到设备上。
- en: 'Here are a few things you could try:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以尝试的一些事情：
- en: Make the LED blink slower or faster by adjusting the number of inferences per
    cycle.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调整每个周期的推断次数使LED的闪烁速度变慢或变快。
- en: Modify *output_handler.cc* to log a text-based animation to the serial port.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改*output_handler.cc*以将基于文本的动画记录到串行端口。
- en: Use the sine wave to control other components, like additional LEDs or sound
    generators.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正弦波来控制其他组件，如额外的LED或声音发生器。
- en: ST Microelectronics STM32F746G Discovery Kit
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ST Microelectronics STM32F746G Discovery Kit
- en: The [STM32F746G](https://oreil.ly/cvm4J) is a microcontroller development board
    with a relatively powerful Arm Cortex-M7 processor core.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[STM32F746G](https://oreil.ly/cvm4J)是一个带有相对强大的Arm Cortex-M7处理器核心的微控制器开发板。'
- en: This board runs Arm’s [Mbed OS](https://os.mbed.com), an embedded operating
    system designed to make it easier to build and deploy embedded applications. This
    means that we can use many of the instructions in this section to build for other
    Mbed devices.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这块板运行Arm的[Mbed OS](https://os.mbed.com)，这是一个专为构建和部署嵌入式应用程序而设计的嵌入式操作系统。这意味着我们可以使用本节中的许多指令来为其他Mbed设备构建。
- en: The STM32F746G comes with an attached LCD screen, which will allow us to build
    a much more elaborate visual display.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F746G配备了一个附加的LCD屏幕，这将使我们能够构建一个更加复杂的视觉显示。
- en: Handling Output on STM32F746G
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在STM32F746G上处理输出
- en: Now that we have an entire LCD to play with, we can draw a nice animation. Let’s
    use the *x*-axis of the screen to represent number of inferences, and the *y*-axis
    to represent the current value of our prediction.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个整个LCD可以玩耍，我们可以绘制一个漂亮的动画。让我们使用屏幕的*x*轴表示推断的数量，*y*轴表示我们预测的当前值。
- en: We’ll draw a dot where this value should be, and it will move around the screen
    as we loop through the input range of 0 to 2π. [Figure 6-15](#stm_hello_world_animation)
    presents a wireframe of this.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个值应该的地方绘制一个点，当我们循环遍历0到2π的输入范围时，它将在屏幕上移动。[图6-15](#stm_hello_world_animation)展示了这个的线框图。
- en: Each inference takes a certain amount of time, so tweaking `kInferencesPerCycle`,
    defined in *constants.cc*, will adjust the speed and smoothness of the dot’s motion.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每个推断需要一定的时间，因此调整`kInferencesPerCycle`，在*constants.cc*中定义，将调整点的运动速度和平滑度。
- en: '[Figure 6-16](#STM32F746_hello_world) shows a still from an [animated *.gif*](https://oreil.ly/1EM7C)
    of the program running.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-16](#STM32F746_hello_world)显示了程序运行的[动画*.gif*](https://oreil.ly/1EM7C)的静止画面。'
- en: '![Illustration of the animation we''ll draw on the LCD display](Images/timl_0615.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![我们将在LCD显示屏上绘制的动画的插图](Images/timl_0615.png)'
- en: Figure 6-15\. The animation we’ll draw on the LCD display
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-15。我们将在LCD显示屏上绘制的动画
- en: '[Figure 6-16](#STM32F746_hello_world) shows a still from an [animated *.gif*](https://oreil.ly/1EM7C)
    of the program running.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-16](#STM32F746_hello_world)显示了程序运行的[动画*.gif*](https://oreil.ly/1EM7C)的静止画面。'
- en: '![The STM32F746G Discovery kit, which has an LCD display](Images/timl_0616.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![STM32F746G Discovery kit，带有LCD显示屏](Images/timl_0616.png)'
- en: Figure 6-16\. The code running on an STM32F746G Discovery kit, which has an
    LCD display
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-16。在STM32F746G Discovery kit上运行的代码，带有LCD显示屏
- en: The code that implements output handling for the STM32F746G is in [*hello_world/disco_f746ng/output_handler.cc*](https://oreil.ly/bj4iL),
    which is used instead of the original file, *hello_world/output_handler.cc*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 实现STM32F746G的输出处理的代码位于[*hello_world/disco_f746ng/output_handler.cc*](https://oreil.ly/bj4iL)中，该文件用于替代原始文件*hello_world/output_handler.cc*。
- en: 'Let’s walk through it:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we have some header files. Our *output_handler.h* specifies the interface
    for this file. *LCD_DISCO_F74NG.h*, supplied by the board’s manufacturer, declares
    the interface we will use to control its LCD screen. We also include *constants.h*,
    since we need access to `kInferencesPerCycle` and `kXrange`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一些头文件。我们的*output_handler.h*指定了这个文件的接口。由开发板制造商提供的*LCD_DISCO_F74NG.h*声明了我们将用来控制其LCD屏幕的接口。我们还包括*constants.h*，因为我们需要访问`kInferencesPerCycle`和`kXrange`。
- en: 'Next, we set up a ton of variables. First comes an instance of `LCD_DISCO_F746NG`,
    which is defined in *LCD_DISCO_F74NG.h* and provides methods that we can use to
    control the LCD:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了大量变量。首先是`LCD_DISCO_F746NG`的一个实例，它在*LCD_DISCO_F74NG.h*中定义，并提供了我们可以用来控制LCD的方法：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Details on the `LCD_DISCO_F746NG` classes are available on the [Mbed site](https://oreil.ly/yiPHS).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`LCD_DISCO_F746NG`类的详细信息可在[Mbed网站](https://oreil.ly/yiPHS)上找到。
- en: 'Next, we define some constants that control the look and feel of our visuals:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一些控制视觉外观和感觉的常量：
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The colors are provided as hex values, like `0xFFF4B400`. They are in the format
    `AARRGGBB`, where `AA` represents the alpha value (or opacity, with `FF` being
    fully opaque), and `RR`, `GG`, and `BB` represent the amounts of red, green, and
    blue.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色以十六进制值提供，如`0xFFF4B400`。它们的格式为`AARRGGBB`，其中`AA`表示alpha值（或不透明度，`FF`表示完全不透明），`RR`、`GG`和`BB`表示红色、绿色和蓝色的量。
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: With some practice, you can learn to read the color from the hex value. `0xFFF4B400`
    is fully opaque and has a lot of red and a fair amount of green, which makes it
    a nice orange-yellow.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过练习，您可以学会从十六进制值中读取颜色。`0xFFF4B400`是完全不透明的，有很多红色和一定量的绿色，这使得它成为一个漂亮的橙黄色。
- en: You can also look up the values with a quick Google search.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过快速的谷歌搜索查找这些值。
- en: 'We then declare a few more variables that define the shape and size of our
    animation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明了一些变量，定义了动画的形状和大小：
- en: '[PRE32]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After the variables, we define the `HandleOutput()` function and tell it what
    to do on its first run:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量之后，我们定义了`HandleOutput()`函数，并告诉它在第一次运行时要做什么：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There’s a lot in there! First, we use methods belonging to `lcd` to set a background
    and foreground color. The oddly named `lcd.SetTextColor()` sets the color of anything
    we draw, not just text:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 里面有很多内容！首先，我们使用属于`lcd`的方法来设置背景和前景颜色。奇怪命名的`lcd.SetTextColor()`设置我们绘制的任何东西的颜色，不仅仅是文本：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we calculate how much of the screen we can actually draw to, so that
    we know where to plot our circle. If we got this wrong, we might try to draw past
    the edge of the screen, with unexpected results:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算实际可以绘制到屏幕的部分，以便知道在哪里绘制我们的圆。如果我们搞错了，我们可能会尝试绘制超出屏幕边缘，导致意想不到的结果：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After that, we determine the location of the middle of the screen, below which
    our negative `y` values will be drawn. We also calculate how many pixels of screen
    width represent one unit of our `x` value. Note how we use `static_cast` to ensure
    that we get a floating-point result:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们确定屏幕中间的位置，我们将在其下方绘制负`y`值。我们还计算屏幕宽度中表示一个单位`x`值的像素数。请注意我们如何使用`static_cast`确保获得浮点结果：
- en: '[PRE36]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we did before, use a `static` variable named `is_initialized` to ensure that
    the code in this block is run only once.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，使用名为`is_initialized`的`static`变量确保此块中的代码仅运行一次。
- en: 'After initialization is complete, we can start with our output. First, we clear
    any previous drawing:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，我们可以开始输出。首先，清除任何先前的绘图：
- en: '[PRE37]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we use `x_value` to calculate where along the display’s *x*-axis we should
    draw our dot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`x_value`来计算我们应该在显示器的*x*轴上绘制点的位置：
- en: '[PRE38]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We then do the same for our `y` value. This is a little more complex because
    we want to plot positive values above the `midpoint` and negative values below:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对`y`值执行相同的操作。这有点复杂，因为我们希望在`midpoint`上方绘制正值，在下方绘制负值：
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As soon as we’ve determined its position, we can go ahead and draw the dot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了它的位置，我们就可以继续绘制点：
- en: '[PRE40]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we use our `ErrorReporter` to log the `x` and `y` values to the serial
    port:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用我们的`ErrorReporter`将`x`和`y`值记录到串行端口：
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-289
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `ErrorReporter` can output data via the STM32F746G’s serial interface due
    to a custom implementation, [*micro/disco_f746ng/debug_log.cc*](https://oreil.ly/eL1ft),
    that replaces the original implementation at [*micro/debug_log.cc*](https://oreil.ly/HpJ-t).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自定义实现，`ErrorReporter`可以通过STM32F746G的串行接口输出数据，[*micro/disco_f746ng/debug_log.cc*](https://oreil.ly/eL1ft)，取代了[*micro/debug_log.cc*](https://oreil.ly/HpJ-t)中的原始实现。
- en: Running the Example
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: Next up, let’s build the project! The STM32F746G runs Arm’s Mbed OS, so we’ll
    be using the Mbed toolchain to deploy our application to the device.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建项目！STM32F746G运行Arm的Mbed OS，因此我们将使用Mbed工具链将我们的应用程序部署到设备上。
- en: Tip
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There’s always a chance that the build process might have changed since this
    book was written, so check [*README.md*](https://oreil.ly/WuhIz) for the latest
    instructions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 建议检查[*README.md*](https://oreil.ly/WuhIz)以获取最新说明，因为构建过程可能会有所变化。
- en: 'Before we begin, we’ll need the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要以下内容：
- en: An STM32F746G Discovery kit board
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个STM32F746G Discovery kit板
- en: A mini-USB cable
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迷你USB电缆
- en: The Arm Mbed CLI (follow the [Mbed setup guide](https://oreil.ly/TkRwd))
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arm Mbed CLI（请参阅[Mbed设置指南](https://oreil.ly/TkRwd)）
- en: Python 3 and `pip`
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3和`pip`
- en: Like the Arduino IDE, Mbed requires source files to be structured in a certain
    way. The TensorFlow Lite for Microcontrollers Makefile knows how to do this for
    us, and can generate a directory suitable for Mbed.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与Arduino IDE类似，Mbed要求源文件以特定方式结构化。 TensorFlow Lite for Microcontrollers Makefile知道如何为我们做到这一点，并且可以生成适用于Mbed的目录。
- en: 'To do so, run the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这样做，请运行以下命令：
- en: '[PRE42]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This results in the creation of a new directory:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致创建一个新目录：
- en: '[PRE43]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This directory contains all of the example’s dependencies structured in the
    correct way for Mbed to be able to build it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录包含所有示例的依赖项，以适合Mbed构建。
- en: 'First, change into the directory so that your can run some commands in there:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，切换到目录，以便您可以在其中运行一些命令：
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now you’ll use Mbed to download the dependencies and build the project.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将使用Mbed下载依赖项并构建项目。
- en: 'To get started, use the following command to specify to Mbed that the current
    directory is the root of an Mbed project:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请使用以下命令指定Mbed当前目录是Mbed项目的根目录：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, instruct Mbed to download the dependencies and prepare to build:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，指示Mbed下载依赖项并准备构建：
- en: '[PRE46]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By default, Mbed will build the project using C++98\. However, TensorFlow Lite
    requires C++11\. Run the following Python snippet to modify the Mbed configuration
    files so that it uses C++11\. You can just type or paste it into the command line:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Mbed将使用C++98构建项目。但是，TensorFlow Lite需要C++11。运行以下Python片段修改Mbed配置文件，以便使用C++11。您可以直接在命令行中键入或粘贴：
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, run the following command to compile:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行以下命令进行编译：
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should result in a binary at the following path:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在以下路径生成一个二进制文件：
- en: '[PRE49]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'One of the nice things about using Mbed-enabled boards like the STM32F746G
    is that deployment is really easy. To deploy, just plug in your STM board and
    copy the file to it. On macOS, you can do this with the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mbed启动的一个好处是，像STM32F746G这样的Mbed启用板的部署非常简单。要部署，只需将STM板插入并将文件复制到其中。在macOS上，您可以使用以下命令执行此操作：
- en: '[PRE50]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Alternately, just find the `DIS_F746NG` volume in your file browser and drag
    the file over. Copying the file will initiate the flashing process. When this
    is complete, you should see an animation on the device’s screen.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，只需在文件浏览器中找到`DIS_F746NG`卷并将文件拖放过去。复制文件将启动闪存过程。完成后，您应该在设备屏幕上看到动画。
- en: In addition to this animation, debug information is logged by the board while
    the program is running. To view it, establish a serial connection to the board
    using a baud rate of 9600.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个动画之外，当程序运行时，板上还会记录调试信息。要查看它，请使用波特率为9600的串行连接与板建立串行连接。
- en: 'On macOS and Linux, the device should be listed when you issue the following
    command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS和Linux上，当您发出以下命令时，设备应该会列出：
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It will look something like the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来会像下面这样：
- en: '[PRE52]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After you’ve identified the device, use the following command to connect to
    it, replacing <*`/dev/tty.devicename`*> with the name of your device as it appears
    in */dev*:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 确定设备后，请使用以下命令连接到设备，将<*`/dev/tty.devicename`*>替换为设备名称，该名称显示在*/dev*中：
- en: '[PRE53]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You will see a lot of output flying past. To stop the scrolling, press Ctrl-A,
    immediately followed by Esc. You can then use the arrow keys to explore the output,
    which will contain the results of running inference on various `x` values:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到很多输出飞过。要停止滚动，请按Ctrl-A，然后立即按Esc。然后，您可以使用箭头键浏览输出，其中包含在各种`x`值上运行推断的结果：
- en: '[PRE54]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: To stop viewing the debug output with `screen`, press Ctrl-A, immediately followed
    by the K key, then hit the Y key.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止使用`screen`查看调试输出，请按Ctrl-A，紧接着按K键，然后按Y键。
- en: Making Your Own Changes
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行您自己的更改
- en: Now that you’ve deployed the application, it could be fun to play around and
    make some changes! You can find the application’s code in the *tensorflow/lite/micro/tools/make/gen/mbed_cortex-m4/prj/hello_world/mbed*
    folder. Just edit and save, and then repeat the previous instructions to deploy
    your modified code to the device.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经部署了应用程序，可以尝试玩耍并进行一些更改！您可以在*tensorflow/lite/micro/tools/make/gen/mbed_cortex-m4/prj/hello_world/mbed*文件夹中找到应用程序的代码。只需编辑并保存，然后重复之前的说明以将修改后的代码部署到设备上。
- en: 'Here are a few things you could try:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以尝试的一些事情：
- en: Make the dot move slower or faster by adjusting the number of inferences per
    cycle.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调整每个周期的推理次数来使点移动更慢或更快。
- en: Modify *output_handler.cc* to log a text-based animation to the serial port.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改*output_handler.cc*以将基于文本的动画记录到串行端口。
- en: Use the sine wave to control other components, like LEDs or sound generators.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正弦波来控制其他组件，比如LED或声音发生器。
- en: Wrapping Up
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Over the past three chapters, we’ve gone through the full end-to-end journey
    of training a model, converting it for TensorFlow Lite, writing an application
    around it, and deploying it to a tiny device. In the coming chapters, we’ll explore
    some more sophisticated and exciting examples that put embedded machine learning
    to work.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的三章中，我们已经经历了训练模型、将其转换为TensorFlow Lite、围绕其编写应用程序并将其部署到微型设备的完整端到端旅程。在接下来的章节中，我们将探索一些更复杂和令人兴奋的示例，将嵌入式机器学习投入实际应用。
- en: First up, we’ll build an application that recognizes spoken commands using a
    tiny, 18 KB model.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建一个使用微小的、18 KB模型识别口头命令的应用程序。
