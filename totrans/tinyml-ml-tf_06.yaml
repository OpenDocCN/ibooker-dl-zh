- en: 'Chapter 6\. The “Hello World” of TinyML: Deploying to Microcontrollers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it’s time to get our hands dirty. Over the course of this chapter, we will
    deploy the code to three different devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Arduino Nano 33 BLE Sense](https://oreil.ly/6qlMD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SparkFun Edge](https://oreil.ly/-hoL-)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ST Microelectronics STM32F746G Discovery kit](https://oreil.ly/cvm4J)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll walk through the build and deployment process for each one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TensorFlow Lite regularly adds support for new devices, so if the device you’d
    like to use isn’t listed here, it’s worth checking the example’s [*README.md*](https://oreil.ly/ez0ef).
  prefs: []
  type: TYPE_NORMAL
- en: You can also check there for updated deployment instructions if you run into
    trouble following these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Every device has its own unique output capabilities, ranging from a bank of
    LEDs to a full LCD display, so the example contains a custom implementation of
    `HandleOutput()` for each one. We’ll also walk through each of these and talk
    about how its logic works. Even if you don’t have all of the devices, reading
    through this code should be interesting, so we strongly recommend taking a look.
  prefs: []
  type: TYPE_NORMAL
- en: What Exactly Is a Microcontroller?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your past experience, you might not be familiar with how microcontrollers
    interact with other electronic components. Because we’re about to start playing
    with hardware, it’s worth introducing some ideas before we move along.
  prefs: []
  type: TYPE_NORMAL
- en: On a microcontroller board like the Arduino, SparkFun Edge, or STM32F746G Discovery
    kit, the actual microcontroller is just one of many electronic components attached
    to the circuit board. [Figure 6-1](#sparkfun_edge_microcontroller) shows the microcontroller
    on the SparkFun Edge.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of SparkFun Edge board with its microcontroller highlighted](Images/timl_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. The SparkFun Edge board with its microcontroller highlighted
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The microcontroller is connected to the circuit board it lives on using *pins*.
    A typical microcontroller has dozens of pins, and they serve all sorts of purposes.
    Some provide power to the microcontroller; others connect it to various important
    components. Some pins are set aside for the input and output of digital signals
    by programs running on the microcontroller. These are called *GPIO* pins, which
    stands for general-purpose input/output. They can act as inputs, determining whether
    a voltage is being applied to them, or outputs, sourcing current that can power
    or communicate with other components.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO pins are digital. This means that in output mode, they are like switches
    that can either be fully on, or fully off. In input mode, they can detect whether
    the voltage applied to them by another component is either above or below a certain
    threshold.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to GPIOs, some microcontrollers have analog input pins, which can
    measure the exact level of voltage that is being applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: By calling special functions, the program running on a microcontroller can control
    whether a given pin is in input or output mode. Other functions are used to switch
    an output pin on or off, or to read the current state of an input pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know a bit more about microcontrollers, let’s take a closer look
    at our first device: the Arduino.'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a huge variety of [Arduino](https://www.arduino.cc/) boards, all with
    different capabilities. Not all of them will run TensorFlow Lite for Microcontrollers.
    The board we recommend for this book is the [Arduino Nano 33 BLE Sense](https://oreil.ly/9g1bJ).
    In addition to being compatible with TensorFlow Lite, it also includes a microphone
    and an accelerometer (which we use in later chapters). We recommend buying the
    version of the board with headers, which makes it easier to connect other components
    without soldering.
  prefs: []
  type: TYPE_NORMAL
- en: Most Arduino boards come with a built-in LED, and this is what we’ll be using
    to visually output our sine values. [Figure 6-2](#arduino_nano_sense_led) shows
    an Arduino Nano 33 BLE Sense board with the LED highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of the Arduino Nano 33 BLE Sense board with the LED highlighted](Images/timl_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. The Arduino Nano 33 BLE Sense board with the LED highlighted
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Handling Output on Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we have only one LED to work with, we need to think creatively. One
    option is to vary the brightness of the LED based on the most recently predicted
    sine value. Given that the value ranges from –1 to 1, we could represent 0 with
    an LED that is fully off, –1 and 1 with a fully lit LED, and any intermediate
    values with a partially dimmed LED. As the program runs inferences in a loop,
    the LED will fade repeatedly on and off.
  prefs: []
  type: TYPE_NORMAL
- en: We can vary the number of inferences we perform across a full sine wave cycle
    using the `kInferencesPerCycle` constant. Because one inference takes a set amount
    of time, tweaking `kInferencesPerCycle`, defined in *constants.cc*, will adjust
    how fast the LED fades.
  prefs: []
  type: TYPE_NORMAL
- en: There’s an Arduino-specific version of this file in [*hello_world/arduino/constants.cc*](https://oreil.ly/YNsvq).
    The file has been given the same name as *hello_world/constants.cc*, so it will
    be used instead of the original implementation when the application is built for
    Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: To dim our built-in LED, we can use a technique called *pulse width modulation*
    (PWM). If we switch an output pin on and off extremely rapidly, the pin’s output
    voltage becomes a factor of the ratio between time spent in the off and on states.
    If the pin spends 50% of the time in each state, its output voltage will be 50%
    of its maximum. If it spends 75% in the on state and 25% in the off state, its
    voltage will be 75% of its maximum.
  prefs: []
  type: TYPE_NORMAL
- en: 'PWM is only available on certain pins of certain Arduino devices, but it’s
    very easy to use: we just call a function that sets our desired output level for
    the pin.'
  prefs: []
  type: TYPE_NORMAL
- en: The code that implements output handling for Arduino is in [*hello_world/arduino/output_handler.cc*](https://oreil.ly/OpLMB),
    which is used instead of the original file, *hello_world/output_handler.cc*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we include some header files. Our *output_handler.h* specifies the interface
    for this file. *Arduino.h* provides the interface for the Arduino platform; we
    use this to control the board. Because we need access to `kInferencesPerCycle`,
    we also include *constants.h*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the function and instruct it what to do the first time it runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In C++, a variable declared as `static` within a function will hold its value
    across multiple runs of the function. Here, we use the `is_initialized` variable
    to track whether the code in the following `if (!is_initialized)` block has ever
    been run before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initialization block calls Arduino’s [`pinMode()`](https://oreil.ly/6Kxep)
    function, which indicates to the microcontroller whether a given pin should be
    in input or output mode. This is necessary before using a pin. The function is
    called with two constants defined by the Arduino platform: `LED_BUILTIN` and `OUTPUT`.
    `LED_BUILTIN` represents the pin connected to the board’s built-in LED, and `OUTPUT`
    represents output mode.'
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the built-in LED’s pin to output mode, set `is_initialized`
    to `true` so that this block code will not run again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we calculate the desired brightness of the LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Arduino allows us to set the level of a PWM output as a number from 0 to
    255, where 0 means fully off and 255 means fully on. Our `y_value` is a number
    between –1 and 1\. The preceding code maps `y_value` to the range 0 to 255 so
    that when `y = -1` the LED is fully off, when `y = 0` the LED is half lit, and
    when `y = 1` the LED is fully lit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to actually set the LED’s brightness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Arduino platform’s [`analogWrite()`](https://oreil.ly/nNseR) function takes
    a pin number (we provide `LED_BUILTIN`) and a value between 0 and 255\. We provide
    our `brightness`, calculated in the previous line. When this function is called,
    the LED will be lit at that level.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unfortunately, on some models of Arduino boards, the pin that the built-in LED
    is connected to is not capable of PWM. This means our calls to `analogWrite()`
    won’t vary its brightness. Instead, the LED will be switched on if the value passed
    into `analogWrite()` is above 127, and switched off if it is 126 or below. This
    means the LED will flash on and off instead of fading. Not quite as cool, but
    it still demonstrates our sine wave prediction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use the `ErrorReporter` instance to log the brightness value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: On the Arduino platform, the `ErrorReporter` is set up to log data via a serial
    port. Serial is a very common way for microcontrollers to communicate with host
    computers, and it’s often used for debugging. It’s a communication protocol in
    which data is communicated one bit at a time by switching an output pin on and
    off. We can use it to send and receive anything, from raw binary data to text
    and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IDE contains tools for capturing and displaying data received through
    a serial port. One of the tools, the Serial Plotter, can display a graph of values
    it receives via serial. By outputting a stream of brightness values from our code,
    we’ll be able to see them graphed. [Figure 6-3](#serial_plotter) shows this in
    action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Arduino IDE''s Serial Plotter](Images/timl_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. The Arduino IDE’s Serial Plotter
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We provide instructions on how to use the Serial Plotter later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might be wondering how the `ErrorReporter` is able to output data via Arduino’s
    serial interface. You can find the code implementation in [*micro/arduino/debug_log.cc*](https://oreil.ly/fkF8H).
    It replaces the original implementation at [*micro/debug_log.cc*](https://oreil.ly/nxXgJ).
    Just like how *output_handler.cc* is overwritten, we can provide platform-specific
    implementations of any source file in TensorFlow Lite for Microcontrollers by
    adding them to a directory with the platform’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next task is to build the project for Arduino and deploy it to a device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s always a chance that the build process might have changed since this
    book was written, so check [*README.md*](https://oreil.ly/s2mj1) for the latest
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s everything that we’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: A supported Arduino board (we recommend the Arduino Nano 33 BLE Sense)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The appropriate USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Arduino IDE](https://oreil.ly/c-rv6) (you’ll need to download and install
    this before continuing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The projects in this book are available as example code in the TensorFlow Lite
    Arduino library, which you can easily install via the Arduino IDE and select Manage
    Libraries from the Tools menu. In the window that appears, search for and install
    the library named *Arduino_TensorFlowLite*. You should be able to use the latest
    version, but if you run into issues, the version that was tested with this book
    is `1.14-ALPHA`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also install the library from a *.zip* file, which you can either [download](https://oreil.ly/blgB8)
    from the TensorFlow Lite team or generate yourself using the TensorFlow Lite for
    Microcontrollers Makefile. If you’d prefer to do this, see [Appendix A](app01.xhtml#appendix_arduino_library_zip).
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve installed the library, the `hello_world` example will show up in
    the File menu under Examples→Arduino_TensorFlowLite, as shown in [Figure 6-4](#arduino_examples_hello_world).
  prefs: []
  type: TYPE_NORMAL
- en: Click “hello_world” to load the example. It will appear as a new window, with
    a tab for each of the source files. The file in the first tab, *hello_world*,
    is equivalent to the *main_functions.cc* we walked through earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the ''Examples'' menu](Images/timl_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. The Examples menu
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To run the example, plug in your Arduino device via USB. Make sure the correct
    device type is selected from the Board drop-down list in the Tools menu, as shown
    in [Figure 6-5](#arduino_board_dropdown).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the ''Board'' dropdown](Images/timl_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. The Board drop-down list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If your device’s name doesn’t appear in the list, you’ll need to install its
    support package. To do this, click Boards Manager. In the window that appears,
    search for your device and install the latest version of the corresponding support
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Next, make sure the device’s port is selected in the Port drop-down list, also
    in the Tools menu, as shown in [Figure 6-6](#arduino_port_dropdown).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the ''Port'' dropdown](Images/timl_0606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6\. The Port drop-down list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, in the Arduino window, click the upload button (highlighted in white
    in [Figure 6-7](#arduino_upload_button)) to compile and upload the code to your
    Arduino device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the upload button, which has an arrow icon](Images/timl_0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7\. The upload button, a right-facing arrow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After the upload has successfully completed you should see the LED on your Arduino
    board begin either fading in and out or flashing on and off, depending on whether
    the pin it is attached to supports PWM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations: you’re running ML on-device!'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Different models of Arduino boards have different hardware, and will run inference
    at varying speeds. If your LED is either flickering or stays fully on, you might
    need to increase the number of inferences per cycle. You can do this via the `kInferencesPerCycle`
    constant in *arduino_constants.cpp*.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Making Your Own Changes”](#hello_world_arduino_making_your_own_changes) shows
    you how to edit the example’s code.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also view the brightness value plotted on a graph. To do this, open
    the Arduino IDE’s Serial Plotter by selecting it in the Tools menu, as shown in
    [Figure 6-8](#serial_plotter_menu).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Serial Plotter menu option](Images/timl_0608.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-8\. The Serial Plotter menu option
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The plotter shows the value as it changes over time, as demonstrated in [Figure 6-9](#serial_plotter_2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Arduino IDE''s Serial Plotter](Images/timl_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-9\. The Serial Plotter graphing the value
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To view the raw data that is received from the Arduino’s serial port, open the
    Serial Monitor from the Tools menu. You’ll see a stream of numbers flying past,
    like in [Figure 6-10](#serial_monitor).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Arduino IDE''s Serial Monitor](Images/timl_0610.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-10\. The Serial Monitor displaying raw data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Making Your Own Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve deployed the application, it might be fun to play around and
    make some changes to the code. You can edit the source files in the Arduino IDE.
    When you save, you’ll be prompted to resave the example in a new location. When
    you’re done making changes, you can click the upload button in the Arduino IDE
    to build and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started making changes, here are a few experiments you could try:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the LED blink slower or faster by adjusting the number of inferences per
    cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify *output_handler.cc* to log a text-based animation to the serial port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the sine wave to control other components, like additional LEDs or sound
    generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SparkFun Edge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [SparkFun Edge](https://oreil.ly/-hoL-) development board was designed specifically
    as a platform for experimenting with machine learning on tiny devices. It has
    a power-efficient Ambiq Apollo 3 microcontroller with an Arm Cortex M4 processor
    core.
  prefs: []
  type: TYPE_NORMAL
- en: It features a bank of four LEDs, as shown in [Figure 6-11](#sparkfun_edge_leds).
    We use these to visually output our sine values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the SparkFun Edge highlighting its four LEDs](Images/timl_0611.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-11\. The SparkFun Edge’s four LEDs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Handling Output on SparkFun Edge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the board’s bank of LEDs to make a simple animation, because nothing
    says cutting-edge AI like [blinkenlights](https://oreil.ly/T90fy).
  prefs: []
  type: TYPE_NORMAL
- en: 'The LEDs (red, green, blue, and yellow) are physically lined up in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table represents how we will light the LEDs for different `y`
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Range | LEDs lit |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0.75 <= y <= 1` | `[ 0 0 1 1 ]` |'
  prefs: []
  type: TYPE_TB
- en: '| `0 < y < 0.75` | `[ 0 0 1 0 ]` |'
  prefs: []
  type: TYPE_TB
- en: '| `y = 0` | `[ 0 0 0 0 ]` |'
  prefs: []
  type: TYPE_TB
- en: '| `-0.75 < y < 0` | `[ 0 1 0 0 ]` |'
  prefs: []
  type: TYPE_TB
- en: '| `-1 <= y <= 0.75` | `[ 1 1 0 0 ]` |'
  prefs: []
  type: TYPE_TB
- en: Each inference takes a certain amount of time, so tweaking `kInferencesPerCycle`,
    defined in *constants.cc*, will adjust how fast the LEDs cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-12](#sparkfun_edge_gif_still) shows a still from an [animated *.gif*](https://oreil.ly/cXdPY)
    of the program running.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A still from the animation of the SparkFun Edge''s LEDs](Images/timl_0612.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-12\. A still from the animation of the SparkFun Edge’s LEDs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The code that implements output handling for the SparkFun Edge is in [*hello_world/sparkfun_edge/output_handler.cc*](https://oreil.ly/tegLK),
    which is used instead of the original file, *hello_world/output_handler.cc*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start walking through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we include some header files. Our *output_handler.h* specifies the interface
    for this file. The other file, *am_bsp.h,* comes from something called the *Ambiq
    Apollo3 SDK*. Ambiq is the manufacturer of the SparkFun Edge’s microcontroller,
    which is called the Apollo3\. The SDK (short for *software development kit*) is
    a collection of source files that define constants and functions that can be used
    to control the microcontroller’s features.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are planning to control the board’s LEDs, we need to be able to switch
    the microcontroller’s pins on and off. This is what we use the SDK for.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Makefile will automatically download the SDK when we eventually build the
    project. If you’re curious, you can read more about it or download the code to
    explore on [SparkFun’s website](https://oreil.ly/RHHqI).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the `HandleOutput()` function and indicate what to do on its
    first run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Phew, that’s a lot of setup! We’re using the `am_hal_gpio_pinconfig()` function,
    provided by *am_bsp.h*, to configure the pins connected to the board’s built-in
    LEDs, putting them into output mode (represented by the `g_AM_HAL_GPIO_OUTPUT_12`
    constant). The pin number of each LED is represented by a constant, such as `AM_BSP_GPIO_LED_RED`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then clear all of the outputs using `am_hal_gpio_output_clear()`, so the
    LEDs are all switched off. As in the Arduino implementation, we use a `static`
    variable named `is_initialized` to ensure the code in this block is run only once.
    Next, we determine which LEDs should be lit if the `y` value is negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, in case the `y` value only just became negative, we clear the two LEDs
    that are used to indicate positive values. Next, we call `am_hal_gpio_output_set()`
    to switch on the blue LED, which will always be lit if the value is negative.
    Finally, if the value is less than –0.75, we switch on the red LED. Otherwise,
    we switch it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we do the same thing but for positive values of `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s just about it for the LEDs. The last thing we do is log the current
    output values to anyone who is listening on the serial port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Our `ErrorReporter` is able to output data via the SparkFun Edge’s serial interface
    due to a custom implementation of [*micro/sparkfun_edge/debug_log.cc*](https://oreil.ly/ufEv9)
    that replaces the original implementation at [*mmicro/debug_log.cc*](https://oreil.ly/ACaFt).
  prefs: []
  type: TYPE_NORMAL
- en: Running the Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can build the sample code and deploy it to the SparkFun Edge.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s always a chance that the build process might have changed since this
    book was written, so check [*README.md*](https://oreil.ly/EcPZ8) for the latest
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and deploy our code, we’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A SparkFun Edge board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB programmer (we recommend the SparkFun Serial Basic Breakout, which is
    available in [micro-B USB](https://oreil.ly/A6oDw) and [USB-C](https://oreil.ly/3REjg)
    variants)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matching USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3 and some dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To begin, open a terminal, clone the TensorFlow repository, and then change
    into its directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’re going to build the binary and run some commands that get it ready
    for downloading to the device. To avoid some typing, you can copy and paste these
    commands from [*README.md*](https://oreil.ly/PYmUu).
  prefs: []
  type: TYPE_NORMAL
- en: Build the binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command downloads all the required dependencies and then compiles
    a binary for the SparkFun Edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A binary is a file that contains the program in a form that can be run directly
    by the SparkFun Edge hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary will be created as a *.bin* file, in the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that the file exists, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you run that command, you should see `Binary was successfully created` printed
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: If you see `Binary is missing`, there was a problem with the build process.
    If so, it’s likely that you can find some clues to what went wrong in the output
    of the `make` command.
  prefs: []
  type: TYPE_NORMAL
- en: Sign the binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary must be signed with cryptographic keys to be deployed to the device.
    Let’s now run some commands that will sign the binary so it can be flashed to
    the SparkFun Edge. The scripts used here come from the Ambiq SDK, which is downloaded
    when the Makefile is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to set up some dummy cryptographic keys that you
    can use for development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following command to create a signed binary. Substitute `python3`
    with `python` if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the file *main_nonsecure_ota.bin*. Now run this command to create
    a final version of the file that you can use to flash your device with the script
    you will use in the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You should now have a file called *main_nonsecure_wire.bin* in the directory
    where you ran the commands. This is the file you’ll be flashing to the device.
  prefs: []
  type: TYPE_NORMAL
- en: Flash the binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SparkFun Edge stores the program it is currently running in its 1 megabyte
    of flash memory. If you want the board to run a new program, you need to send
    it to the board, which will store it in flash memory, overwriting any program
    that was previously saved.
  prefs: []
  type: TYPE_NORMAL
- en: This process is called *flashing*. Let’s walk through the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Attach the programmer to the board
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To download new programs to the board, you’ll use the SparkFun USB-C Serial
    Basic serial programmer. This device allows your computer to communicate with
    the microcontroller via USB.
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach this device to your board, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On the side of the SparkFun Edge, locate the six-pin header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the SparkFun USB-C Serial Basic into these pins, ensuring that the pins
    labeled BLK and GRN on each device are lined up correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see the correct arrangement in [Figure 6-13](#sparkfun_edge_serial_basic).
  prefs: []
  type: TYPE_NORMAL
- en: '![A photo showing how the SparkFun Edge and USB-C Serial Basic should be connected](Images/timl_0613.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-13\. Connecting the SparkFun Edge and USB-C Serial Basic (courtesy
    of SparkFun)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Attach the programmer to your computer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, connect the board to your computer via USB. To program the board, you
    need to determine the name that your computer gives the device. The best way of
    doing this is to list all of the computer’s devices before and after attaching
    it and then look to see which device is new.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some people have reported issues with their operating system’s default drivers
    for the programmer, so we strongly recommend installing the [driver](https://oreil.ly/Wkxaf)
    before you continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before attaching the device via USB, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output a list of attached devices that looks something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, connect the programmer to your computer’s USB port and run the command
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an extra item in the output, as in the example that follows.
    Your new item might have a different name. This new item is the name of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This name will be used to refer to the device. However, it can change depending
    on which USB port the programmer is attached to, so if you disconnect the board
    from your computer and then reattach it, you might need to look up its name again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some users have reported two devices appearing in the list. If you see two devices,
    the correct one to use begins with the letters “wch”; for example, “/dev/wchusbserial-14410.”
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve identified the device name, put it in a shell variable for later
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a variable that you can use when running commands that require the device
    name, later in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script to flash your board
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To flash the board, you need to put it into a special “bootloader” state that
    prepares it to receive the new binary. You can then run a script to send the binary
    to the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'First create an environment variable to specify the baud rate, which is the
    speed at which data will be sent to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now paste the command that follows into your terminal—but *do not press Enter
    yet*!. The `${DEVICENAME}` and `${BAUD_RATE}` in the command will be replaced
    with the values you set in the previous sections. Remember to substitute `python3`
    with `python` if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll reset the board into its bootloader state and flash the board.
    On the board, locate the buttons marked `RST` and `14`, as shown in [Figure 6-14](#sparkfun_edge_buttons).
  prefs: []
  type: TYPE_NORMAL
- en: '![A photo showing the SparkFun Edge''s buttons](Images/timl_0614.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-14\. The SparkFun Edge’s buttons
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that your board is connected to the programmer and that the entire thing
    is connected to your computer via USB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the board, press and hold the button marked `14`. *Continue holding it.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While still holding the button marked `14`, press the button marked `RST` to
    reset the board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Enter on your computer to run the script. *Continue holding button `14`.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now see something like the following appearing on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Keep holding button `14` until you see `Sending Data Packet of length 8180`.
    You can release the button after seeing this (but it’s okay if you keep holding
    it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The program will continue to print lines on the terminal. Eventually you will
    see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This indicates a successful flashing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the program output ends with an error, check whether `Sending Reset Command.`
    was printed. If so, flashing was likely successful despite the error. Otherwise,
    flashing might have failed. Try running through these steps again (you can skip
    over setting the environment variables).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The binary should now be deployed to the device. Press the button marked `RST`
    to reboot the board. You should see the device’s four LEDs flashing in sequence.
    Nice work!
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Debug Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Debug information is logged by the board while the program is running. To view
    it, we can monitor the board’s serial port output using a baud rate of 115200\.
    On macOS and Linux, the following command should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a lot of output flying past! To stop the scrolling, press Ctrl-A,
    immediately followed by Esc. You can then use the arrow keys to explore the output,
    which will contain the results of running inference on various `x` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To stop viewing the debug output with `screen`, press Ctrl-A, immediately followed
    by the K key, and then press the Y key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The program `screen` is a helpful utility program for connecting to other computers.
    In this case, we’re using it to listen to the data the SparkFun Edge board is
    logging via its serial port. If you’re using Windows, you could try using the
    program [`CoolTerm`](https://oreil.ly/sPWQP) to do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Making Your Own Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve deployed the basic application, try playing around and making
    some changes. You can find the application’s code in the *tensorflow/lite/micro/examples/hello_world*
    folder. Just edit and save, and then repeat the previous instructions to deploy
    your modified code to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few things you could try:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the LED blink slower or faster by adjusting the number of inferences per
    cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify *output_handler.cc* to log a text-based animation to the serial port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the sine wave to control other components, like additional LEDs or sound
    generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ST Microelectronics STM32F746G Discovery Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [STM32F746G](https://oreil.ly/cvm4J) is a microcontroller development board
    with a relatively powerful Arm Cortex-M7 processor core.
  prefs: []
  type: TYPE_NORMAL
- en: This board runs Arm’s [Mbed OS](https://os.mbed.com), an embedded operating
    system designed to make it easier to build and deploy embedded applications. This
    means that we can use many of the instructions in this section to build for other
    Mbed devices.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F746G comes with an attached LCD screen, which will allow us to build
    a much more elaborate visual display.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Output on STM32F746G
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have an entire LCD to play with, we can draw a nice animation. Let’s
    use the *x*-axis of the screen to represent number of inferences, and the *y*-axis
    to represent the current value of our prediction.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll draw a dot where this value should be, and it will move around the screen
    as we loop through the input range of 0 to 2π. [Figure 6-15](#stm_hello_world_animation)
    presents a wireframe of this.
  prefs: []
  type: TYPE_NORMAL
- en: Each inference takes a certain amount of time, so tweaking `kInferencesPerCycle`,
    defined in *constants.cc*, will adjust the speed and smoothness of the dot’s motion.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-16](#STM32F746_hello_world) shows a still from an [animated *.gif*](https://oreil.ly/1EM7C)
    of the program running.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Illustration of the animation we''ll draw on the LCD display](Images/timl_0615.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-15\. The animation we’ll draw on the LCD display
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 6-16](#STM32F746_hello_world) shows a still from an [animated *.gif*](https://oreil.ly/1EM7C)
    of the program running.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The STM32F746G Discovery kit, which has an LCD display](Images/timl_0616.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-16\. The code running on an STM32F746G Discovery kit, which has an
    LCD display
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The code that implements output handling for the STM32F746G is in [*hello_world/disco_f746ng/output_handler.cc*](https://oreil.ly/bj4iL),
    which is used instead of the original file, *hello_world/output_handler.cc*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we have some header files. Our *output_handler.h* specifies the interface
    for this file. *LCD_DISCO_F74NG.h*, supplied by the board’s manufacturer, declares
    the interface we will use to control its LCD screen. We also include *constants.h*,
    since we need access to `kInferencesPerCycle` and `kXrange`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set up a ton of variables. First comes an instance of `LCD_DISCO_F746NG`,
    which is defined in *LCD_DISCO_F74NG.h* and provides methods that we can use to
    control the LCD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Details on the `LCD_DISCO_F746NG` classes are available on the [Mbed site](https://oreil.ly/yiPHS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define some constants that control the look and feel of our visuals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The colors are provided as hex values, like `0xFFF4B400`. They are in the format
    `AARRGGBB`, where `AA` represents the alpha value (or opacity, with `FF` being
    fully opaque), and `RR`, `GG`, and `BB` represent the amounts of red, green, and
    blue.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With some practice, you can learn to read the color from the hex value. `0xFFF4B400`
    is fully opaque and has a lot of red and a fair amount of green, which makes it
    a nice orange-yellow.
  prefs: []
  type: TYPE_NORMAL
- en: You can also look up the values with a quick Google search.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then declare a few more variables that define the shape and size of our
    animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After the variables, we define the `HandleOutput()` function and tell it what
    to do on its first run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a lot in there! First, we use methods belonging to `lcd` to set a background
    and foreground color. The oddly named `lcd.SetTextColor()` sets the color of anything
    we draw, not just text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we calculate how much of the screen we can actually draw to, so that
    we know where to plot our circle. If we got this wrong, we might try to draw past
    the edge of the screen, with unexpected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we determine the location of the middle of the screen, below which
    our negative `y` values will be drawn. We also calculate how many pixels of screen
    width represent one unit of our `x` value. Note how we use `static_cast` to ensure
    that we get a floating-point result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we did before, use a `static` variable named `is_initialized` to ensure that
    the code in this block is run only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'After initialization is complete, we can start with our output. First, we clear
    any previous drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use `x_value` to calculate where along the display’s *x*-axis we should
    draw our dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We then do the same for our `y` value. This is a little more complex because
    we want to plot positive values above the `midpoint` and negative values below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we’ve determined its position, we can go ahead and draw the dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use our `ErrorReporter` to log the `x` and `y` values to the serial
    port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `ErrorReporter` can output data via the STM32F746G’s serial interface due
    to a custom implementation, [*micro/disco_f746ng/debug_log.cc*](https://oreil.ly/eL1ft),
    that replaces the original implementation at [*micro/debug_log.cc*](https://oreil.ly/HpJ-t).
  prefs: []
  type: TYPE_NORMAL
- en: Running the Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next up, let’s build the project! The STM32F746G runs Arm’s Mbed OS, so we’ll
    be using the Mbed toolchain to deploy our application to the device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s always a chance that the build process might have changed since this
    book was written, so check [*README.md*](https://oreil.ly/WuhIz) for the latest
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, we’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An STM32F746G Discovery kit board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mini-USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arm Mbed CLI (follow the [Mbed setup guide](https://oreil.ly/TkRwd))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3 and `pip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the Arduino IDE, Mbed requires source files to be structured in a certain
    way. The TensorFlow Lite for Microcontrollers Makefile knows how to do this for
    us, and can generate a directory suitable for Mbed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the creation of a new directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This directory contains all of the example’s dependencies structured in the
    correct way for Mbed to be able to build it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, change into the directory so that your can run some commands in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now you’ll use Mbed to download the dependencies and build the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, use the following command to specify to Mbed that the current
    directory is the root of an Mbed project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, instruct Mbed to download the dependencies and prepare to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Mbed will build the project using C++98\. However, TensorFlow Lite
    requires C++11\. Run the following Python snippet to modify the Mbed configuration
    files so that it uses C++11\. You can just type or paste it into the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the following command to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in a binary at the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the nice things about using Mbed-enabled boards like the STM32F746G
    is that deployment is really easy. To deploy, just plug in your STM board and
    copy the file to it. On macOS, you can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Alternately, just find the `DIS_F746NG` volume in your file browser and drag
    the file over. Copying the file will initiate the flashing process. When this
    is complete, you should see an animation on the device’s screen.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this animation, debug information is logged by the board while
    the program is running. To view it, establish a serial connection to the board
    using a baud rate of 9600.
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS and Linux, the device should be listed when you issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve identified the device, use the following command to connect to
    it, replacing <*`/dev/tty.devicename`*> with the name of your device as it appears
    in */dev*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a lot of output flying past. To stop the scrolling, press Ctrl-A,
    immediately followed by Esc. You can then use the arrow keys to explore the output,
    which will contain the results of running inference on various `x` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: To stop viewing the debug output with `screen`, press Ctrl-A, immediately followed
    by the K key, then hit the Y key.
  prefs: []
  type: TYPE_NORMAL
- en: Making Your Own Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve deployed the application, it could be fun to play around and
    make some changes! You can find the application’s code in the *tensorflow/lite/micro/tools/make/gen/mbed_cortex-m4/prj/hello_world/mbed*
    folder. Just edit and save, and then repeat the previous instructions to deploy
    your modified code to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few things you could try:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the dot move slower or faster by adjusting the number of inferences per
    cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify *output_handler.cc* to log a text-based animation to the serial port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the sine wave to control other components, like LEDs or sound generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past three chapters, we’ve gone through the full end-to-end journey
    of training a model, converting it for TensorFlow Lite, writing an application
    around it, and deploying it to a tiny device. In the coming chapters, we’ll explore
    some more sophisticated and exciting examples that put embedded machine learning
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: First up, we’ll build an application that recognizes spoken commands using a
    tiny, 18 KB model.
  prefs: []
  type: TYPE_NORMAL
