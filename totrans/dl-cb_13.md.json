["```py\n13.1 Quick Draw Cat Autoencoder\n13.2 Variational Autoencoder\n```", "```py\nBASE_PATH = 'https://storage.googleapis.com/quickdraw_dataset/full/binary/\npath = get_file('cat', BASE_PATH + 'cat.bin')\n```", "```py\nx = []\nwith open(path, 'rb') as f:\n    while True:\n        img = PIL.Image.new('L', (32, 32), 'white')\n        draw = ImageDraw.Draw(img)\n        header = f.read(15)\n        if len(header) != 15:\n            break\n```", "```py\n            strokes, = unpack('H', f.read(2))\n            for i in range(strokes):\n                n_points, = unpack('H', f.read(2))\n                fmt = str(n_points) + 'B'\n                read_scaled = lambda: (p // 8 for\n                                       p in unpack(fmt, f.read(n_points)))\n                points = [*zip(read_scaled(), read_scaled())]\n                draw.line(points, fill=0, width=2)\n            img = img_to_array(img)\n            x.append(img)\n```", "```py\ndef create_autoencoder():\n    input_img = Input(shape=(32, 32, 1))\n\n    channels = 2\n    x = input_img\n    for i in range(4):\n        channels *= 2\n        left = Conv2D(channels, (3, 3),\n                      activation='relu', padding='same')(x)\n        right = Conv2D(channels, (2, 2),\n                       activation='relu', padding='same')(x)\n        conc = Concatenate()([left, right])\n        x = MaxPooling2D((2, 2), padding='same')(conc)\n\n    x = Dense(channels)(x)\n\n    for i in range(4):\n        x = Conv2D(channels, (3, 3), activation='relu', padding='same')(x)\n        x = UpSampling2D((2, 2))(x)\n        channels //= 2\n    decoded = Conv2D(1, (3, 3), activation='sigmoid', padding='same')(x)\n\n    autoencoder = Model(input_img, decoded)\n    autoencoder.compile(optimizer='adadelta', loss='binary_crossentropy')\n    return autoencoder\n\nautoencoder = create_autoencoder()\nautoencoder.summary()\n```", "```py\nautoencoder.fit(x_train, x_train,\n                epochs=100,\n                batch_size=128,\n                validation_data=(x_test, x_test))\n```", "```py\ncols = 25\nidx = np.random.randint(x_test.shape[0], size=cols)\nsample = x_test[idx]\ndecoded_imgs = autoencoder.predict(sample)\n```", "```py\ndef decode_img(tile):\n    tile = tile.reshape(tile.shape[:-1])\n    tile = np.clip(tile * 400, 0, 255)\n    return PIL.Image.fromarray(tile)\n\noverview = PIL.Image.new('RGB', (cols * 32, 64 + 20), (128, 128, 128))\nfor idx in range(cols):\n    overview.paste(decode_img(sample[idx]), (idx * 32, 5))\n    overview.paste(decode_img(decoded_imgs[idx]), (idx * 32, 42))\nf = BytesIO()\noverview.save(f, 'png')\ndisplay(Image(data=f.getvalue()))\n```", "```py\ndef prepare(images, labels):\n    images = images.astype('float32') / 255\n    n, w, h = images.shape\n    return images.reshape((n, w * h)), to_categorical(labels)\n\ntrain, test = mnist.load_data()\nx_train, y_train = prepare(*train)\nx_test, y_test = prepare(*test)\nimg_width, img_height = train[0].shape[1:]\n```", "```py\npixels = Input(shape=(num_pixels,))\nencoder_hidden = Dense(512, activation='relu')(pixels)\nz_mean = Dense(latent_space_depth,\n               activation='linear')(encoder_hidden)\nz_log_var = Dense(latent_space_depth,\n                  activation='linear')(encoder_hidden)\nz = Lambda(sample_z, output_shape=(latent_space_depth,))(\n        [z_mean, z_log_var])\ndecoder_hidden = Dense(512, activation='relu')\nreconstruct_pixels = Dense(num_pixels, activation='sigmoid')\nhidden = decoder_hidden(z)\noutputs = reconstruct_pixels(hidden)\nauto_encoder = Model(pixels, outputs)\n```", "```py\ndef sample_z(args):\n    z_mean, z_log_var = args\n    eps = K.random_normal(shape=(batch_size, latent_space_depth),\n                         mean=0., stddev=1.)\n    return z_mean + K.exp(z_log_var / 2) * eps\n```", "```py\ndef reconstruction_loss(y_true, y_pred):\n    return K.sum(K.binary_crossentropy(y_true, y_pred), axis=-1)\n```", "```py\ndef KL_loss(y_true, y_pred):\n    return 0.5 * K.sum(K.exp(z_log_var) +\n                       K.square(z_mean) - 1 - z_log_var,\n                       axis=1)\n```", "```py\ndef total_loss(y_true, y_pred):\n    return (KL_loss(y_true, y_pred) +\n            reconstruction_loss(y_true, y_pred))\n```", "```py\nauto_encoder.compile(optimizer=Adam(lr=0.001),\n                     loss=total_loss,\n                     metrics=[KL_loss, reconstruction_loss])\n```", "```py\ncvae.fit(x_train, x_train, verbose = 1, batch_size=batch_size, epochs=50,\n         validation_data = (x_test, x_test))\n```", "```py\ndecoder_in = Input(shape=(latent_space_depth,))\ndecoder_hidden = decoder_hidden(decoder_in)\ndecoder_out = reconstruct_pixels(decoder_hidden)\ndecoder = Model(decoder_in, decoder_out)\n```", "```py\nrandom_number = np.asarray([[np.random.normal()\n                            for _ in range(latent_space_depth)]])\ndef decode_img(a):\n    a = np.clip(a * 256, 0, 255).astype('uint8')\n    return PIL.Image.fromarray(a)\n\ndecode_img(decoder.predict(random_number)\n               .reshape(img_width, img_height)).resize((56, 56))\n```", "```py\nnum_cells = 10\noverview = PIL.Image.new('RGB',\n                         (num_cells * (img_width + 4) + 8,\n                          num_cells * (img_height + 4) + 8),\n                         (128, 128, 128))\nvec = np.zeros((1, latent_space_depth))\nfor x in range(num_cells):\n    vec[:, 0] = (x * 3) / (num_cells - 1) - 1.5\n    for y in range(num_cells):\n        vec[:, 1] = (y * 3) / (num_cells - 1) - 1.5\n        decoded = decoder.predict(vec)\n        img = decode_img(decoded.reshape(img_width, img_height))\n        overview.paste(img, (x * (img_width + 4) + 6,\n                             y * (img_height + 4) + 6))\noverview\n```", "```py\npixels = Input(shape=(num_pixels,))\nlabel = Input(shape=(num_labels,), name='label')\ninputs = concat([pixels, label], name='inputs')\n\nencoder_hidden = Dense(512, activation='relu',\n                       name='encoder_hidden')(inputs)\nz_mean = Dense(latent_space_depth,\n               activation='linear')(encoder_hidden)\nz_log_var = Dense(latent_space_depth,\n                  activation='linear')(encoder_hidden)\nz = Lambda(sample_z,\n           output_shape=(latent_space_depth, ))([z_mean, z_log_var])\nzc = concat([z, label])\n\ndecoder_hidden = Dense(512, activation='relu')\nreconstruct_pixels = Dense(num_pixels, activation='sigmoid')\ndecoder_in = Input(shape=(latent_space_depth + num_labels,))\nhidden = decoder_hidden(decoder_in)\ndecoder_out = reconstruct_pixels(hidden)\ndecoder = Model(decoder_in, decoder_out)\n\nhidden = decoder_hidden(zc)\noutputs = reconstruct_pixels(hidden)\ncond_auto_encoder = Model([pixels, label], outputs)\n```", "```py\ncond_auto_encoder.fit([x_train, y_train], x_train, verbose=1,\n                      batch_size=batch_size, epochs=50,\n                      validation_data = ([x_test, y_test], x_test))\n```", "```py\nnumber_4 = np.zeros((1, latent_space_depth + y_train.shape[1]))\nnumber_4[:, 4 + latent_space_depth] = 1\ndecode_img(cond_decoder.predict(number_4).reshape(img_width, img_height))\n```", "```py\nnumber_8_3 = np.zeros((1, latent_space_depth + y_train.shape[1]))\nnumber_8_3[:, 8 + latent_space_depth] = 0.5\nnumber_8_3[:, 3 + latent_space_depth] = 0.5\ndecode_img(cond_decoder.predict(number_8_3).reshape(\n    img_width, img_height))\n```", "```py\nnum_cells = 10\noverview = PIL.Image.new('RGB',\n                         (num_cells * (img_width + 4) + 8,\n                          num_cells * (img_height + 4) + 8),\n                         (128, 128, 128))\nimg_it = 0\nvec = np.zeros((1, latent_space_depth + y_train.shape[1]))\nfor x in range(num_cells):\n    vec = np.zeros((1, latent_space_depth + y_train.shape[1]))\n    vec[:, x + latent_space_depth] = 1\n    for y in range(num_cells):\n        vec[:, 1] = 3 * y / (num_cells - 1) - 1.5\n        decoded = cond_decoder.predict(vec)\n        img = decode_img(decoded.reshape(img_width, img_height))\n        overview.paste(img, (x * (img_width + 4) + 6,\n                             y * (img_height + 4) + 6))\noverview\n```"]