<html><head></head><body>

  <div class="readable-text" id="p1"> 
   <h1 class=" readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">4</span> </span> <span class="chapter-title-text">Association rules</span></h1> 
  </div> 
  <div class="introduction-summary"> 
   <h3 class="introduction-header">This chapter covers</h3> 
   <ul> 
    <li class="readable-text" id="p2">Association rules</li> 
    <li class="readable-text" id="p3">Different types of algorithms for association rules </li> 
    <li class="readable-text" id="p4">Implementation of different algorithms for association rules</li> 
    <li class="readable-text" id="p5">Sequence learning using SPADE</li> 
   </ul> 
  </div> 
  <div class="readable-text" id="p6"> 
   <blockquote>
    <div>
     The power of association is stronger than the power of beauty; therefore, the power of association is the power of beauty.  
     <div class=" quote-cite">
       —John Ruskin 
     </div>
    </div>
   </blockquote> 
  </div> 
  <div class="readable-text" id="p7"> 
   <p>Congratulations on finishing the first part of the book! You explored the basics of unsupervised learning and algorithms like k-means clustering, hierarchical clustering, DBSCAN, principal component analysis, and others. It is expected that you have covered the mathematical concepts in the first part and created the Python codes to solve the exercise given at the end of each chapter. </p> 
  </div> 
  <div class="readable-text intended-text" id="p8"> 
   <p>Welcome to the second part of the book where we use the concepts learned in the first part and explore slightly more complex topics. We start with association rules in this chapter. </p> 
  </div> 
  <div class="readable-text intended-text" id="p9"> 
   <p>Next time you visit a nearby grocery store, look around inside the store and notice the arrangements of various items. You would find shelves with items like milk, eggs, bread, sugar, washing powder, soaps, fruits, vegetables, cookies, and various other items neatly stacked. Have you ever wondered about the logic of these arrangements and how these items are laid out? Why are certain products kept near each other while others are quite far from one another? Obviously, the arrangement cannot be done in a random manner, and there has to be scientific reasoning behind it. Or do you wonder: How does Netflix recommend movies to you based on your movie history like a sequence? We are going to find the answers to these questions in this chapter. Like always, we study the concepts first. We go through the mathematical logic for different algorithms, the pros and cons of each, and practical implementations using Python. A business case study is provided at the end of the chapter to complement the knowledge. Welcome to the fourth chapter and all the very best!</p> 
  </div> 
  <div class="readable-text" id="p10"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.1</span> Technical toolkit</h2> 
  </div> 
  <div class="readable-text" id="p11"> 
   <p>We will continue to use the same version of Python and Jupyter Notebook we have used so far. The codes and datasets used in this chapter have been checked in at the same Github location. </p> 
  </div> 
  <div class="readable-text intended-text" id="p12"> 
   <p>You will need to install a few Python libraries for this chapter, including <code>apyori</code>, <code>pyECLAT</code>, <code>fpgrowth_py</code>, and<span class="code-char"> </span><code>pyspade</code>. Along with this, you will need <code>numpy</code> and <code>pandas</code>. Using libraries, we can implement the algorithms very quickly. Otherwise, coding these algorithms from scratch is quite a time-consuming and painstaking task.</p> 
  </div> 
  <div class="readable-text intended-text" id="p13"> 
   <p>Let’s get started with association rules.</p> 
  </div> 
  <div class="readable-text" id="p14"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.2</span> Association rule overview</h2> 
  </div> 
  <div class="readable-text" id="p15"> 
   <p>You might have heard the famous “beer and diaper story.” As per this anecdote, customers (mostly young men) in a supermarket who buy diapers also buy beer in the same invoice. In other words, young men who are buying diapers for their babies have quite a high probability of buying beer in the same transaction. We will not comment on the authenticity of the story, but <em>association rule learning</em> can be attributed as the logic derived from this story.</p> 
  </div> 
  <div class="readable-text intended-text" id="p16"> 
   <p>Formally put, association rules can be used to find compelling relationships between the variables that are present in the datasets. We can use association rules for measuring the correlations and co-occurrences between the variables in a dataset. In the example given here (assuming the story is true), one could analyze the daily customer transactions. And if a relationship emerges between beer and diapers, it is a very strong insight for the supermarket, which can allow it to customize their placements of beer and diapers or tailor the marketing strategy or even alter the prices. </p> 
  </div> 
  <div class="readable-text intended-text" id="p17"> 
   <p>We can understand by a different example in a supermarket. Assume that by analyzing five invoices generated in a supermarket, we get the data as shown in table 4.1. In this example, in invoice number 1001 milk is purchased and thus has a value of 1, whereas cheese is not purchased and thus is 0.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p18"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.1</span> Examples of invoices generated in a supermarket</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Invoice number 
       </div> </th> 
      <th> 
       <div>
         Milk 
       </div> </th> 
      <th> 
       <div>
         Eggs 
       </div> </th> 
      <th> 
       <div>
         Bread 
       </div> </th> 
      <th> 
       <div>
         Cheese 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  0 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  1 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  0 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  1 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1005 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  1 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p19"> 
   <p>So, in invoice number 1001, milk, eggs, and bread are purchased while in invoice number 1002, only cheese is purchased. Here we can see that whenever milk and eggs are purchased together, bread is always purchased in the same invoice. It is an important discovery indeed.</p> 
  </div> 
  <div class="readable-text intended-text" id="p20"> 
   <p>Now scale up this understanding to thousands of transactions made in a day. It will lead to very strong relationships that human eyes are generally oblivious to, but association rule algorithms can uncover them for us. This can lead to better product placements, better prices on the products, and much more optimized marketing spending. Such patterns will enhance the customer experience and prove quite handy to improve overall customer satisfaction.</p> 
  </div> 
  <div class="readable-text intended-text" id="p21"> 
   <p>We can visualize association rules as shown in figure 4.1. Here there are some incoming variables represented as nodes 1, 2, 3, 4, etc. These nodes are related to each other as shown by the arrows. This relationship between them gives rise to rules A and B. If we relate back to the beer/diaper story we mentioned at the start of this section, rule A can be that when a young male customer buys diapers, they also often buy beer, while rule B can be that when milk and eggs are purchased, often bread is bought too.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p22">  
   <img alt="figure" src="../Images/CH04_F01_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.1</span> An association rule can be visualized as the relationship between various variables in the dataset. These variables are linked to each other, and significant relationships are established between them.</h5>
  </div> 
  <div class="readable-text intended-text" id="p23"> 
   <p>The example of the supermarket is sometimes referred to as <em>market basket analysis. </em>But association rules are applicable not only in grocery retail. Their utility has been proven in other sectors like bioinformatics, the medical industry, intrusion detection, etc. They can be utilized by Netflix or Spotify to analyze historical user behavior and then recommend the content the user most likely is going to like. Web developers can analyze the historical clicks and usages of the customers on their websites. By identifying the patterns, they can find out what users tend to click and which features will maximize their engagement. Medical practitioners can use association rules to better diagnose patients. The doctors can compare the probability of the symptoms in relationship with other symptoms and provide more accurate diagnoses. The use cases occur across multiple business domains and business functions.</p> 
  </div> 
  <div class="readable-text" id="p24"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.3</span> The building blocks of association rules</h2> 
  </div> 
  <div class="readable-text" id="p25"> 
   <p>We covered the definition of an association rule in the last section. Now let’s understand the mathematical concept behind association rules. Assume that we have the following datasets in a retail store:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p26"> Let X = {x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>, x<sub>4</sub>, x<sub>5</sub> …., x<sub><em>n</em></sub>} are the <em>n</em> items available in the retail store. For example, they can be milk, eggs, bread, cheese, apples, and so on. </li> 
   <li class="readable-text" id="p27"> Let Y = {y<sub>1</sub>, y<sub>2</sub>, y<sub>3</sub>, y<sub>4</sub>, y<sub>5</sub> …., y<sub><em>m</em></sub>} are the <em>m</em> transactions generated in that retail store. Each transaction could have all or some items from the retail store. </li> 
  </ul> 
  <div class="readable-text" id="p28"> 
   <p>Obviously, each item in the transaction will be bought from the retail store only. In other words, every item in transactions in set Y will be a subset of items in set X. At the same time, each item would have a unique identifier attached to it, and each transaction would have a unique invoice number attached to it.</p> 
  </div> 
  <div class="readable-text intended-text" id="p29"> 
   <p>Now we are interested in analyzing the patterns and discovering the relationships. This will be used to generate any rule or insight. So let’s define the meaning of the rule first.</p> 
  </div> 
  <div class="readable-text intended-text" id="p30"> 
   <p>Assume that we find a rule that whenever items in list P are bought, items in list Q are also bought. This rule can be written as follows:</p> 
  </div> 
  <ol> 
   <li class="readable-text" id="p31"> The rule is P -&gt; Q. It means that whenever items defined in P are bought, it leads to a purchase in Q too. </li> 
   <li class="readable-text" id="p32"> Items in P will be a subset of X or P <span class="regular-symbol">Í</span> X. </li> 
   <li class="readable-text" id="p33"> Similarly, items in Q will be a subset of X or Q <span class="regular-symbol">Í</span> X. </li> 
   <li class="readable-text" id="p34"> P and Q cannot have any common element or P <span class="regular-symbol">Ç</span> Q = 0 </li> 
  </ol> 
  <div class="readable-text" id="p35"> 
   <p>Now let’s understand these mathematical concepts with a real-world example. Assume that X = {milk, bananas, eggs, cheese, apples, bread, salt, sugar, cookies, butter, cold drinks, water}. These are the total items available in the retail shop. </p> 
  </div> 
  <div class="readable-text intended-text" id="p36"> 
   <p>Y = {1001, 1002, 1003, 1004, 1005} are the five invoices generated in that retail store. The respective items purchased in each of these invoices are given in figure 4.2.<span class="aframe-location"/> Note how for each invoice, we have 0 and 1 associated for each of the items. These invoices are just for illustration purposes. In the actual invoices, the number of items can be much more. Using this dataset, let’s assume we create two rules that {milk, bananas} -&gt; {eggs} and {milk, bananas} -&gt; {bread}. </p> 
  </div> 
  <div class="browsable-container figure-container" id="p37">  
   <img alt="figure" src="../Images/CH04_F02_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.2</span> Example of five invoices generated in a retail store</h5>
  </div> 
  <div class="readable-text intended-text" id="p38"> 
   <p>The first rule means that whenever milk and bananas are bought together, eggs are also purchased in the same transaction. The second rule means that whenever milk and bananas are bought together, bread is also bought in the same transaction. By analyzing the dataset, we can clearly see that rule 1 is always true whereas rule 2 is not. </p> 
  </div> 
  <div class="readable-text print-book-callout" id="p39"> 
   <p><span class="print-book-callout-head">NOTE </span> The items on the left side of a rule are called the <em>antecedent</em> or the LHS and the ones on the right side of a rule are called the <em>consequents</em> or the RHS. </p> 
  </div> 
  <div class="readable-text" id="p40"> 
   <p>In the real world, for any such rule to have significance, the same pattern must repeat itself across several hundreds and thousands of transactions. Only then would we conclude that the rule is indeed true and can be generalized across the entire database. </p> 
  </div> 
  <div class="readable-text intended-text" id="p41"> 
   <p>At the same time, there can be many such rules. In a retail shop where thousands of invoices are generated daily, there can be hundreds of such rules. How can we find out which rules are significant and which are not? This can be understood using the concepts of <em>support, confidence, lift, </em>and<em> conviction,</em> which we will study in the next section. </p> 
  </div> 
  <div class="readable-text" id="p42"> 
   <h3 class=" readable-text-h3"><span class="num-string">4.3.1</span> Support, confidence, lift, and conviction</h3> 
  </div> 
  <div class="readable-text" id="p43"> 
   <p>We identified the meaning of a rule in an association rule in the last section. We also understand that there can be hundreds of rules based on the transactional dataset. In this section, we will explore how we can measure the effectiveness of such rules and shortlist the most interesting ones. This can be achieved using the concepts of support, confidence, lift, and conviction.</p> 
  </div> 
  <div class="readable-text intended-text" id="p44"> 
   <p>Recall in the last section we discussed the generalization of a rule. Support, confidence, lift, and conviction allow us to measure the level of generalization. In simple terms, using these four parameters, we can determine how useful the rule can be in our pragmatic real-world business. After all, if a rule is not useful or is not powerful enough, it is not required to be implemented. Support, confidence, lift, and conviction are the parameters to check the efficacy of the rule. We look at these concepts in detail next.</p> 
  </div> 
  <div class="readable-text intended-text" id="p45"> 
   <p>We will use the dataset in table 4.2 to understand the concepts of support, confidence, lift, and conviction. The first invoice, 1001, has milk, eggs, and bread while cheese is not purchased. Again, for the sake of this example, we have taken only four items in total.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p46"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.2</span> Dataset to understand the concept of support, confidence, lift, and conviction</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Invoice Number 
       </div> </th> 
      <th> 
       <div>
         Milk 
       </div> </th> 
      <th> 
       <div>
         Eggs 
       </div> </th> 
      <th> 
       <div>
         Bread 
       </div> </th> 
      <th> 
       <div>
         Cheese 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  0 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  0 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  1 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1005 <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  0 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p47"> 
   <p>Here, for an invoice, 1 represents if an item is present in that invoice while 0 shows that the item was not purchased in that particular invoice. For example, invoice number 1001 has milk, eggs, and bread while 1002 has eggs, bread, and cheese.</p> 
  </div> 
  <div class="readable-text" id="p48"> 
   <h4 class=" readable-text-h4">Support</h4> 
  </div> 
  <div class="readable-text" id="p49"> 
   <p>Support measures the frequency percentage of the items in the datasets. In simpler terms, it measures the percentage of transactions in which the items are occurring in the dataset. </p> 
  </div> 
  <div class="readable-text intended-text" id="p50"> 
   <p>Support can be denoted as follows:<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p51"> 
   <img alt="figure" src="../Images/verdhan-ch4-eqs-0x.png"/> 
  </div> 
  <div class="readable-text" id="p52"> 
   <p>Refer to table 4.2. Say we are interested in the rule {milk, eggs} -&gt; {bread}. In such a scenario, there are two transactions in which all three items (milk, eggs, and bread) are present. The total number of transactions is five. This means that the support for the rule is 2/5, which is 0.4 or 40%.</p> 
  </div> 
  <div class="readable-text intended-text" id="p53"> 
   <p>Now say we are interested in the rule {bread, eggs} -&gt; {cheese}. In such a scenario, there is only one transaction in which all three items are present. The total number of transactions is five. This means that the support for the rule is 1/5, which is 0.2 or 20%.</p> 
  </div> 
  <div class="readable-text print-book-callout" id="p54"> 
   <p><span class="print-book-callout-head">NOTE </span> The higher the support for a rule, the better it is. Generally, we put a minimum threshold to get support. A minimum threshold is generally determined in consultation with the business stakeholders. </p> 
  </div> 
  <div class="readable-text" id="p55"> 
   <h4 class=" readable-text-h4">Confidence</h4> 
  </div> 
  <div class="readable-text" id="p56"> 
   <p>Confidence measures how often the rule is true; that is, it measures the percentage of transactions that contain antecedents that also contain consequents. </p> 
  </div> 
  <div class="readable-text intended-text" id="p57"> 
   <p>So if we wish to measure the confidence of the rule A -&gt; B:<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p58"> 
   <img alt="figure" src="../Images/verdhan-ch4-eqs-1x.png"/> 
  </div> 
  <div class="readable-text" id="p59"> 
   <p>Here, the numerator is supported when both <em>A</em> and <em>B</em> are present in the transaction, while the denominator refers to the support only for <em>A</em>. </p> 
  </div> 
  <div class="readable-text intended-text" id="p60"> 
   <p>Refer to table 4.2. Again, say we are interested in the rule {milk, eggs} -&gt; {bread}. In such a scenario, there are two transactions in which both milk and eggs are present. Hence, the support is 2/5 = 0.4. It is the denominator. There are two transactions in which all three (milk, eggs, bread) are present. Hence, support is 2/5 = 0.4, which is the numerator. Putting in the preceding equation, the confidence for the rule {milk, eggs} -&gt; {bread} is 0.4/0.4 = 1.</p> 
  </div> 
  <div class="readable-text intended-text" id="p61"> 
   <p>Now say we are interested in the rule {eggs, bread} -&gt; {cheese}. In such a scenario, there are four transactions in which (eggs, bread) are present. The total number of transactions is five. This means that the support is 4/5, which is 0.8. There is only one transaction in which all three items (eggs, bread, cheese) are present. So the support is 1/5 = 0.2. Hence the confidence for the rule {eggs, bread} -&gt; {cheese} is 0.2/0.8 = 0.25.</p> 
  </div> 
  <div class="readable-text print-book-callout" id="p62"> 
   <p><span class="print-book-callout-head">NOTE </span> The higher the confidence in the rule, the better it is. Like support, we put a minimum threshold on confidence.</p> 
  </div> 
  <div class="readable-text" id="p63"> 
   <p>Sometimes this is also referred to as the <em>conditional probability</em> of <em>A</em> on <em>B</em>. It can be understood as the probability of <em>B</em> occurring provided <em>A</em> has already occurred and can be written as <em>P</em>(<em>A</em>|<em>B</em>). So, in the preceding examples, the probability of cheese to be bought provided eggs, bread is already bought is 25% while the probability of bread to be purchased, provided milk, eggs are already purchased is 100%.</p> 
  </div> 
  <div class="readable-text" id="p64"> 
   <h4 class=" readable-text-h4">Lift and conviction</h4> 
  </div> 
  <div class="readable-text" id="p65"> 
   <p>Lift is a very important measurement criterium for a rule. Lift for a rule <em>A</em> -&gt; <em>B</em> can be defined as<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p66"> 
   <img alt="figure" src="../Images/verdhan-ch4-eqs-2x.png"/> 
  </div> 
  <div class="readable-text" id="p67"> 
   <p>Here the numerator is supported when both <em>A</em> and <em>B</em> are present in the transaction, while the denominator refers to the support for <em>A</em> multiplied by the support for <em>B</em>.</p> 
  </div> 
  <div class="readable-text intended-text" id="p68"> 
   <p>Again, refer to table 4.2 and say we are interested in the rule {milk, eggs} -&gt; {bread}. In such a scenario, there are two transactions in which all three (milk, eggs, bread) are present. Hence, support is again 2/5 = 0.4, which is the numerator. There are two transactions in which only (milk, eggs) are present, so the support is 2/5 = 0.4. There are four transactions in which bread is present, hence the support is 4/5 = 0.8. Putting in the preceding equation, the lift for the rule {milk, eggs} -&gt; {bread} is 0.4/(0.4 x 0.8) = 1.25.</p> 
  </div> 
  <div class="readable-text intended-text" id="p69"> 
   <p>Then say we are interested in the rule {eggs, bread} -&gt; {cheese}. In such a scenario, there is only one transaction in which (eggs, bread, cheese) are present. The total number of transactions is five. This means that the support is 1/5, which is 0.2. There are two transactions in which (cheese) is present. So the support is 2/5 = 0.4. There are four transactions in which (eggs, bread) are present, so the support is 4/5 = 0.8. Putting in the preceding equation, the lift for the rule {eggs, bread} -&gt; {cheese} is 0.2/(0.4 x 0.8) = 0.625.</p> 
  </div> 
  <div class="readable-text intended-text" id="p70"> 
   <p>If the value of the lift is <em>equal to 1</em>, it means that the antecedent and precedent are independent of each other, and no rule can be drawn from it.</p> 
  </div> 
  <div class="readable-text intended-text" id="p71"> 
   <p>If the value of lift is <em>greater than 1</em>, it means that the antecedent and precedent are dependent on each other. This rule can be used for predicting the antecedent in future transactions. This is the insight we want to draw from the dataset.</p> 
  </div> 
  <div class="readable-text intended-text" id="p72"> 
   <p>If the value of lift is <em>less than 1</em>, it means that the antecedent and precedent are substitutes of each other. The presence of one can have a negative effect on the other. It is also an important insight that can be used by the business teams for strategic planning. </p> 
  </div> 
  <div class="readable-text intended-text" id="p73"> 
   <p>While we evaluate any rule using the lift, it is imperative that we apply domain knowledge to it. For example, if we evaluate the rule {eggs, bread} -&gt; {cheese} and if we find that eggs, bread can be a substitute for cheese, we know that it is not true in real life. Hence, in such a scenario we cannot make any decision for this role. We must use domain knowledge to draw any conclusions for this rule. </p> 
  </div> 
  <div class="readable-text intended-text" id="p74"> 
   <p>At the same time, rule {milk, eggs} -&gt; {bread} might be a rule that can be true many times. For many customers, when they purchase milk and eggs together, it is highly likely that bread will be purchased in the same transaction. Hence this rule makes much more sense for such customers. The objective is to have a strong business logic to either support or disapprove a rule identified using the algorithm.</p> 
  </div> 
  <div class="readable-text intended-text" id="p75"> 
   <p>Conviction is another important parameter, which is given by the following formula:<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p76"> 
   <img alt="figure" src="../Images/verdhan-ch4-eqs-3x.png"/> 
  </div> 
  <div class="readable-text" id="p77"> 
   <p>Refer to table 4.2. Again, say we are interested in the rule {eggs, bread} -&gt; {cheese}. In such a scenario, there is only one transaction in which (cheese) is present. The total number of transactions is five. So, it means that the support is 1/5, which is 0.2 and will be used in the numerator. We have already calculated the confidence as 0.625. Putting back in the formula, we can calculate conviction as (1 – 0.2)/(1 – 0.625) = 2.13 </p> 
  </div> 
  <div class="readable-text intended-text" id="p78"> 
   <p>We can interpret the conviction as: the rule {eggs, bread} -&gt; {cheese} would be incorrect 2.13 times more often if the association between {eggs, bread, cheese} was purely chosen at random.</p> 
  </div> 
  <div class="readable-text intended-text" id="p79"> 
   <p>In most of the business scenarios, lift is the measurement criteria used. There are other measurement parameters, too, like leverage, collective strength, etc. But most of the time, confidence, support, lift, and conviction are used to measure the effectiveness of any rule.</p> 
  </div> 
  <div class="callout-container sidebar-container"> 
   <div class="readable-text" id="p80"> 
    <h5 class=" callout-container-h5 readable-text-h5">Exercise 4.1</h5> 
   </div> 
   <div class="readable-text" id="p81"> 
    <p>Answer these questions to check your understanding:</p> 
   </div> 
   <ol> 
    <li class="readable-text" id="p82"> Support measures how often the rule is present in the dataset. True or False? </li> 
    <li class="readable-text" id="p83"> If the lift is greater than 1, it means that the two items are independent of each other. True or False? </li> 
    <li class="readable-text" id="p84"> The lower the value of confidence, the better the rule. True or False? </li> 
   </ol> 
  </div> 
  <div class="readable-text" id="p85"> 
   <p>While we evaluate any rule while analyzing the dataset, most of the time, we set a threshold for the confidence, support, lift, and conviction. It allows us to reduce the number of rules and filter out the irrelevant ones. In other words, we are interested in only the rules that are very frequent. We will study this in more detail when we create a Python solution for a dataset.</p> 
  </div> 
  <div class="readable-text" id="p86"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.4</span> Apriori algorithm</h2> 
  </div> 
  <div class="readable-text" id="p87"> 
   <p>The Apriori algorithm is one of the most popular algorithms used for association rules. It was proposed by Agrawal and Shrikant in 1994. The link to the paper is given at the end of the chapter. </p> 
  </div> 
  <div class="readable-text intended-text" id="p88"> 
   <p>Apriori is used to understand and analyze the frequent items in a transactional database. It utilizes a “bottom-up” approach where the first candidates are generated based on the frequency of the subsets. Let us understand the entire process by means of an example. We will use the same dataset we have discussed earlier (see table 4.2). The process used in the Apriori algorithm will look like figure 4.3.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p89">  
   <img alt="figure" src="../Images/CH04_F03_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.3</span> The Apriori algorithm process</h5>
  </div> 
  <div class="readable-text" id="p90"> 
   <p>Let us say we wish to analyze the relationship of bread with all the other items in the dataset. In this case, level 1 is bread, and we find its frequency of occurrence. </p> 
  </div> 
  <div class="readable-text intended-text" id="p91"> 
   <p>Then we move to the next layer, which is layer 2. Now we find the relationship of bread with each of the other items: milk, eggs, and cheese, which are at layer 2. Here again we find the respective frequencies of occurrence for all the possible combinations, which are {bread, milk}, {bread, eggs}, and {bread, cheese}. See figure 4.4.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p92">  
   <img alt="figure" src="../Images/CH04_F04_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.4</span> We have bread at level 1 while the other items (milk, eggs, and cheese) are kept at level 2. Bread is kept at level 1 since we wish to analyze the relationship of bread with all the other items.</h5>
  </div> 
  <div class="readable-text" id="p93"> 
   <p>After layer 2 has been analyzed, we move to the third layer and fourth layer and so on. This process continues until we reach the last layer wherein all the items have been exhausted. </p> 
  </div> 
  <div class="readable-text intended-text" id="p94"> 
   <p>As a result of this process, we can calculate the support for all the possible combinations. For example, we would know the support for </p> 
  </div> 
  <div class="readable-text list-body-item" id="p95"> 
   <p>{bread} -&gt; {milk}, </p> 
  </div> 
  <div class="readable-text list-body-item" id="p96"> 
   <p>{bread} -&gt; {eggs}, and </p> 
  </div> 
  <div class="readable-text list-body-item" id="p97"> 
   <p>{bread} -&gt; {cheese}. </p> 
  </div> 
  <div class="readable-text" id="p98"> 
   <p>For the next level, we would also get the support for </p> 
  </div> 
  <div class="readable-text list-body-item" id="p99"> 
   <p>{bread, milk} -&gt; {eggs},</p> 
  </div> 
  <div class="readable-text list-body-item" id="p100"> 
   <p>{bread, eggs} -&gt; {milk},</p> 
  </div> 
  <div class="readable-text list-body-item" id="p101"> 
   <p>{bread, milk} -&gt; {cheese},</p> 
  </div> 
  <div class="readable-text list-body-item" id="p102"> 
   <p>{bread, cheese} -&gt; {milk},</p> 
  </div> 
  <div class="readable-text list-body-item" id="p103"> 
   <p>{bread, cheese} -&gt; {eggs}, and </p> 
  </div> 
  <div class="readable-text list-body-item" id="p104"> 
   <p>{bread, eggs} -&gt; {cheese}.</p> 
  </div> 
  <div class="readable-text" id="p105"> 
   <p>Now, using the same process, all the possible combinations for the next level are calculated. For example, {bread, eggs, milk} -&gt; {cheese}, {bread, eggs, cheese} -&gt; {milk}, and so on.</p> 
  </div> 
  <div class="readable-text intended-text" id="p106"> 
   <p>When all the item sets have been exhausted, the process will stop. The complete architecture can look like figure 4.5.</p> 
  </div> 
  <div class="readable-text intended-text" id="p107"> 
   <p>Now we can easily understand that the possible number of combinations is quite high, which is one of the challenges with Apriori. But Apriori is quite a powerful algorithm and is very popular too. Now it’s time to implement Apriori using Python. <span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p108">  
   <img alt="figure" src="../Images/CH04_F05_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.5</span> The complete architecture for the Apriori algorithm. Here we would have calculated support for all the possible combinations. The relationships between all the items are explored, and because of this entire database scan, the speed of Apriori gets hampered.</h5>
  </div> 
  <div class="readable-text" id="p109"> 
   <h3 class=" readable-text-h3"><span class="num-string">4.4.1</span> Python implementation </h3> 
  </div> 
  <div class="readable-text" id="p110"> 
   <p>We will now proceed with Python implementation of the Apriori algorithm. The dataset and Python Jupyter Notebook are checked in at the GitHub repository. You might have to install <code>apyori</code>. </p> 
  </div> 
  <div class="readable-text intended-text" id="p111"> 
   <p>To install the libraries, simply do the following:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p112"> 
   <div class="code-area-container"> 
    <pre class="code-area">import sys
!{sys.executable} -m pip install apyori</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p113"> 
   <p>The steps are as follows:</p> 
  </div> 
  <ol> 
   <li class="readable-text" id="p114"> Import the necessary libraries for the use case. We are importing <code>numpy</code> and <code>pandas</code>. For implementing Apriori, we have a library called <code>apyori</code>, which is also imported: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p115"> 
   <div class="code-area-container"> 
    <pre class="code-area">import numpy as np
import pandas as pd
from apyori import apriori</pre>  
   </div> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p116"><span class="faux-ol-li-counter">2. </span> Import the dataset <code>store_data.csv</code> file: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p117"> 
   <div class="code-area-container"> 
    <pre class="code-area">store_dataset = pd.read_csv('store_data.csv')</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p118"> 
   <p>You are also advised to have a look at the dataset by opening the .csv file. It will look like the screenshot in figure 4.6. The first 25 rows are shown in the screenshot. Each row represents an invoice. <span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p119">  
   <img alt="figure" src="../Images/CH04_F06_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.6</span> Screenshot of the .csv file</h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p120"><span class="faux-ol-li-counter">3. </span> Next we perform some basic checks on the data by the <code>.info</code> and<code>.head</code> commands (see figure 4.7):  </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p121"> 
   <div class="code-area-container"> 
    <pre class="code-area">store_dataset.info()<span class="aframe-location"/></pre>  
   </div> 
  </div> 
  <div class="browsable-container figure-container" id="p122"> 
   <img alt="figure" src="../Images/CH04_UN01_Verdhan.png"/> 
  </div> 
  <div class="browsable-container listing-container" id="p123"> 
   <div class="code-area-container"> 
    <pre class="code-area">store_dataset.head()<span class="aframe-location"/></pre>  
   </div> 
  </div> 
  <div class="browsable-container figure-container" id="p124">  
   <img alt="figure" src="../Images/CH04_F07_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.7</span> Output for <code>.info</code> and <code>.head</code> commands </h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p125"><span class="faux-ol-li-counter">4. </span> Here we can see that the first transaction has been considered the header by the code. Hence, we would import the data again, but this time we would specify that headers are equal to <code>None</code>: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p126"> 
   <div class="code-area-container"> 
    <pre class="code-area">store_dataset = pd.read_csv('store_data.csv', header=None)</pre>  
   </div> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p127"><span class="faux-ol-li-counter">5. </span> Let’s look at the head again (see figure 4.8). This time it looks correct: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p128"> 
   <div class="code-area-container"> 
    <pre class="code-area">store_dataset.head()<span class="aframe-location"/></pre>  
   </div> 
  </div> 
  <div class="browsable-container figure-container" id="p129">  
   <img alt="figure" src="../Images/CH04_F08_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.8</span> Correct results for <code>.head()</code></h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p130"><span class="faux-ol-li-counter">6. </span> The library we are using for the code accepts the dataset as a list of lists. The entire dataset must be a big list while each transaction is an inner list in the big list. So, to achieve it, we first convert our <code>store_dataset</code> dataframe into a list: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p131"> 
   <div class="code-area-container"> 
    <pre class="code-area">all_records = []
for i in range(0, 7501):
    all_records.append([str(store_dataset.values[i,j]) for j in range(0, 20)])</pre>  
   </div> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p132"><span class="faux-ol-li-counter">7. </span> Next, we implement the Apriori algorithm. </li> 
  </ol> 
  <div class="readable-text" id="p133"> 
   <p>For the algorithm, we are working on the <code>all_records</code> list we created in step 6. The minimum support specified is 0.5 or 50%, the minimum confidence is 25%, the minimum lift is 4, and the minimum length of the rule is 2.</p> 
  </div> 
  <div class="readable-text intended-text" id="p134"> 
   <p>The output of this step is the <code>apriori_rules</code> class object. This object is then converted into a list that we can understand. Finally, we print this list:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p135"> 
   <div class="code-area-container"> 
    <pre class="code-area">apriori_rules = apriori(all_records, min_support=0.5, min_confidence=0.25, min_lift=4, min_length=2)
apriori_rules = list(apriori_rules)
print(len(apriori_rules))</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p136"> 
   <p>The output of the code will be 0. This means that no such rules exist that satisfy the condition we have set for the rules.</p> 
  </div> 
  <div class="readable-text intended-text" id="p137"> 
   <p>We again try to execute the same code, albeit by reducing the minimum support to 25%:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p138"> 
   <div class="code-area-container"> 
    <pre class="code-area">apriori_rules = apriori(all_records, min_support=0.25, min_confidence=0.25,
min_lift=4, min_length=2)
apriori_rules = list(apriori_rules)
print(len(apriori_rules))</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p139"> 
   <p>Again, no rules are generated and the output is 0. Even reducing the minimum support to 10% does not lead to any rules:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p140"> 
   <div class="code-area-container"> 
    <pre class="code-area">apriori_rules = apriori(all_records, min_support=0.1, min_confidence=0.25,
min_lift=4, min_length=2)
apriori_rules = list(apriori_rules)
print(len(apriori_rules))</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p141"> 
   <p>Now we reduce the minimum lift to 2. This time we get 200 as the output. This means that there are 200 such rules that fulfill the criteria:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p142"> 
   <div class="code-area-container"> 
    <pre class="code-area">apriori_rules = apriori(all_records, min_support=0.25, min_confidence=0.25,
min_lift=2, min_length=2)
apriori_rules = list(apriori_rules)
print(len(apriori_rules))</pre>  
   </div> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p143"><span class="faux-ol-li-counter">8. </span> Let’s look at the first rule (see figure 4.9): </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p144"> 
   <div class="code-area-container"> 
    <pre class="code-area">print(apriori_rules[0])<span class="aframe-location"/></pre>  
   </div> 
  </div> 
  <div class="browsable-container figure-container" id="p145">  
   <img alt="figure" src="../Images/CH04_F09_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.9</span> Output from <code>print(apriori_rules[0])</code></h5>
  </div> 
  <div class="readable-text" id="p146"> 
   <p>The rule explains the relationship between almonds and burgers. The support is .005, and the confidence is 0.25. Lift, which is 2.92, indicates that this rule is quite strong.</p> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p147"><span class="faux-ol-li-counter">9. </span> We will now look at all the rules in detail. For that, loop through the rules and extract information from each of the iterations. Each of the rules has the items constituting the rule and respective values for support, confidence, lift, and conviction. We have shown an example in step 8. Now, in step 9, we are just extracting that information for all the rules using a <code>for</code> loop: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p148"> 
   <div class="code-area-container"> 
    <pre class="code-area">for rule in apriori_rules:
    item_pair = rule[0] 
    items = [x for x in item_pair]
    print("The apriori rule is: " + items[0] + " -&gt; " + items[1])

    print("The support for the rule is: " + str(rule[1]))

    print("The confidence for the rule is: " + str(rule[2][0][2]))
    print("The lift for the rule is: " + str(rule[2][0][3]))
    print("************************")</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p149"> 
   <p>The output for this step is shown in figure 4.10. Here we can observe each rule is listed along with the respective values of support, confidence, lift, and conviction.</p> 
  </div> 
  <div class="browsable-container figure-container" id="p150">  
   <img alt="figure" src="../Images/CH04_F10_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.10</span> Output for step 9</h5>
  </div> 
  <div class="readable-text" id="p151"> 
   <p>We can interpret the rules easily. For example, the rule almonds -&gt; burgers has a lift of 2.92 with a confidence of 25.49% and support of 0.51%. This concludes our implementation using Python. This example can be extended to any other real-world business dataset.</p> 
  </div> 
  <div class="readable-text print-book-callout" id="p152"> 
   <p><span class="print-book-callout-head">NOTE </span> Not all the rules generated are not worth using. We will examine how to get the best rules from all the rules generated when we deal with the case study in the last section of the chapter.</p> 
  </div> 
  <div class="readable-text" id="p153"> 
   <p>The Apriori algorithm is a robust and very insightful algorithm. But, like any other solution, it has a few shortcomings.</p> 
  </div> 
  <div class="readable-text" id="p154"> 
   <h3 class=" readable-text-h3"><span class="num-string">4.4.2</span> Challenges with the Apriori algorithm</h3> 
  </div> 
  <div class="readable-text" id="p155"> 
   <p>As we have seen, the number of subsets generated in the Apriori algorithm is quite high (see figure 4.5). It is very tedious to generate candidates’ item sets, and hence it becomes quite cumbersome to analyze the dataset. Apriori scans the entire dataset multiple times, and hence it requires the database to be loaded in the memory. We can safely deduce that it requires a lot of time to make the computations. This problem is magnified when we are dealing with a very large dataset. In fact, for real-world problems where millions of transactions are generated, quite a huge number of candidate item sets are generated, and it is very time-consuming to use Apriori on the entire dataset.</p> 
  </div> 
  <div class="readable-text intended-text" id="p156"> 
   <p>Due to this very reason, generally, a minimum value of support is set to reduce the number of possible rules. In the previous example, we can calculate the support for level 1 combinations, as shown in table 4.3. Here, if we set the minimum value of support as 0.5, only one rule will be shortlisted. Support is calculated for each of the combination of the items. For example, for milk and bread, the number of transactions is 2, while the total number of transactions is 5. So the support is 2/5, which is 0.4.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p157"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.3</span> Support for level 1 combinations</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Combination 
       </div> </th> 
      <th> 
       <div>
         Number of transactions 
       </div> </th> 
      <th> 
       <div>
         Total transactions 
       </div> </th> 
      <th> 
       <div>
         Support 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Milk, Eggs <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  0.4 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Milk, Bread <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  0.4 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Milk, Cheese <br/> </td> 
      <td>  0 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  0 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Eggs, Bread <br/> </td> 
      <td>  4 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  0.8 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Eggs, Cheese <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  0.4 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Bread, Cheese <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  0.2 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p158"> 
   <p>Setting up a minimum value of support is hence an intelligent tactic to make the rules much more manageable. It reduces the time and generates rules that are much more significant. After all, the rules generated from the analysis should be generalizable enough so that they can be implemented across the entire database.</p> 
  </div> 
  <div class="callout-container sidebar-container"> 
   <div class="readable-text" id="p159"> 
    <h5 class=" callout-container-h5 readable-text-h5">Exercise 4.2</h5> 
   </div> 
   <div class="readable-text" id="p160"> 
    <p>Answer these questions to check your understanding:</p> 
   </div> 
   <ol> 
    <li class="readable-text" id="p161"> The Apriori algorithm scans the database only once. True or False? </li> 
    <li class="readable-text" id="p162"> If bananas are present in 5 transactions out of a total of 12 transactions, it means the support for bananas is 5/12. True or False? </li> 
   </ol> 
  </div> 
  <div class="readable-text" id="p163"> 
   <p>But the Apriori algorithm is indeed a great solution. It is still highly popular and generally one of the very first algorithms brought up whenever association rules are discussed. </p> 
  </div> 
  <div class="readable-text print-book-callout" id="p164"> 
   <p><span class="print-book-callout-head">NOTE </span> Data preparation is one of the key steps and quite a challenge. We will explore this challenge during the case study in section 4.8. </p> 
  </div> 
  <div class="readable-text" id="p165"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.5</span> Equivalence class clustering and bottom-up lattice traversal </h2> 
  </div> 
  <div class="readable-text" id="p166"> 
   <p>We will now study the equivalence class clustering and bottom-up lattice traversal algorithm (ECLAT), which sometimes is considered better than Apriori in terms of speed and ease of implementation. ECLAT uses a depth-first search approach. This means that ECLAT performs the search in a vertical fashion throughout the dataset. It starts at the root node and then goes one level deep and continues until it reaches the first terminal note. Let’s say the terminal node is at level <em>X</em>. Once the terminal node is reached, the algorithm then takes a step back and reaches level (<em>X</em> – 1) and continues until it finds a terminal node again. Let’s understand this process by means of a tree diagram, as shown in figure 4.11.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p167">  
   <img alt="figure" src="../Images/CH04_F11_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.11</span> Tree diagram to understand the process of the ECLAT algorithm. It starts with 1 and ends at 16.</h5>
  </div> 
  <div class="readable-text" id="p168"> 
   <p>ECLAT will take the following steps:</p> 
  </div> 
  <ol> 
   <li class="readable-text" id="p169"> The algorithm starts at the root node 1. </li> 
   <li class="readable-text" id="p170"> It then goes one level deep to root node 2. </li> 
   <li class="readable-text" id="p171"> It will then continue one more level deep until it reaches terminal node 11. </li> 
   <li class="readable-text" id="p172"> Once it reaches terminal node 11, it then takes a step back and goes to node 5. </li> 
   <li class="readable-text" id="p173"> The algorithm then searches if there is any node available that can be used. At node 5 we can see that there is no such node available. </li> 
   <li class="readable-text" id="p174"> Hence, the algorithm again takes a step back and reaches node 2. </li> 
   <li class="readable-text" id="p175"> At node 2, the algorithm explores again. It finds that it is possible to go to node 6. </li> 
   <li class="readable-text" id="p176"> So, the algorithm goes to node 6 and starts exploring again until it reaches terminal node 12. </li> 
   <li class="readable-text" id="p177"> This process continues until all the combinations have been exhausted. </li> 
  </ol> 
  <div class="readable-text" id="p178"> 
   <p>Obviously, the speed of computation depends on the total number of distinct items present in the dataset. This is because the number of distinct items defines the width of the tree. The items purchased in each of the transactions would define the relationship between each node. </p> 
  </div> 
  <div class="readable-text intended-text" id="p179"> 
   <p>During the execution time of ECLAT, each item (either individually or in a pair) is analyzed. Let us use the same example we have used for Apriori to understand ECLAT better. Refer to table 4.2.</p> 
  </div> 
  <div class="readable-text intended-text" id="p180"> 
   <p>ECLAT will undergo the following steps to analyze the dataset: </p> 
  </div> 
  <ol> 
   <li class="readable-text" id="p181"> In the first run, ECLAT will find the invoice numbers for all single items. In other words, it will find the invoice numbers for all the items individually. It is shown in table 4.4, wherein milk is present in invoice numbers 1001 and 1003, while eggs are present in all five invoices. </li> 
  </ol> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p182"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.4</span> Respective invoices in which each item is present </h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Item 
       </div> </th> 
      <th> 
       <div>
         Invoice numbers 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Milk <br/> </td> 
      <td>  1001, 1003 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Eggs <br/> </td> 
      <td>  1001, 1002, 1003, 1004, 1005 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Bread <br/> </td> 
      <td>  1001, 1002, 1003, 1005 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Cheese <br/> </td> 
      <td>  1002, 1004 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p183"><span class="faux-ol-li-counter">2. </span> In the next step, all the two-item datasets are explored as shown in table 4.5. For example, milk and eggs are present in invoice numbers 1001 and 1003, while milk and cheese are not present in any invoice. </li> 
  </ol> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p184"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.5</span> Two-item datasets</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Item 
       </div> </th> 
      <th> 
       <div>
         Invoice numbers 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Milk, Eggs <br/> </td> 
      <td>  1001 ,1003 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Milk, Bread <br/> </td> 
      <td>  1001, 1003 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Milk, Cheese <br/> </td> 
      <td>  — <br/> </td> 
     </tr> 
     <tr> 
      <td>  Eggs, Bread <br/> </td> 
      <td>  1001, 1002, 1003, 1005 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Eggs, Cheese <br/> </td> 
      <td>  1002, 1004 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Bread, Cheese <br/> </td> 
      <td>  1002 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p185"><span class="faux-ol-li-counter">3. </span> In the next step, all three-item datasets are explored, as shown in table 4.6. Here we have two combinations only. </li> 
  </ol> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p186"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.6</span> Three-item datasets</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Item 
       </div> </th> 
      <th> 
       <div>
         Invoice numbers 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Milk, Eggs, Bread <br/> </td> 
      <td>  1001, 1003 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Eggs, Bread, Cheese <br/> </td> 
      <td>  1002 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p187"><span class="faux-ol-li-counter">4. </span> There are no invoices present in our dataset that contain four items. </li> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p188"><span class="faux-ol-li-counter">5. </span> Now, depending on the threshold we set for the value of the support count, we can choose the rules. So, if we want the minimum number of transactions in which the rule should be true to be three, then only one rule qualifies, which is {eggs, bread}. If we decide the threshold for the minimum number of transactions is two, then rules like {milk, eggs, bread}, {milk, eggs}, {milk, bread}, {eggs, bread}, and {eggs, cheese} qualify as the rules. </li> 
  </ol> 
  <div class="readable-text" id="p189"> 
   <p>We will now create a Python solution for ECLAT.</p> 
  </div> 
  <div class="readable-text" id="p190"> 
   <h3 class=" readable-text-h3"><span class="num-string">4.5.1</span> Python implementation </h3> 
  </div> 
  <div class="readable-text" id="p191"> 
   <p>We will now work on the execution of ECLAT using Python. We use the <code>pyECLAT</code> library here. The dataset looks like figure 4.12. <span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p192">  
   <img alt="figure" src="../Images/CH04_F12_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.12</span> ECLAT for the <code>pyECLAT</code> library using Python</h5>
  </div> 
  <div class="readable-text" id="p193"> 
   <p>The steps are as follows:</p> 
  </div> 
  <ol> 
   <li class="readable-text" id="p194"> Import the libraries: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p195"> 
   <div class="code-area-container"> 
    <pre class="code-area">import numpy as np
import pandas as pd
from pyECLAT import ECLAT</pre>  
   </div> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p196"><span class="faux-ol-li-counter">2. </span> Import the dataset: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p197"> 
   <div class="code-area-container"> 
    <pre class="code-area">data_frame = pd.read_csv('Data_ECLAT.csv', header = None)</pre>  
   </div> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p198"><span class="faux-ol-li-counter">3. </span> Generate an ECLAT instance: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p199"> 
   <div class="code-area-container"> 
    <pre class="code-area">eclat = ECLAT(data=data_frame)</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p200"> 
   <p>There are some properties of ECLAT instance <code>eclat</code> generated in the last step like <code>eclat.df_bin</code>, which is a binary dataframe, and <code>eclat.uniq_</code>, which is a list of all the unique items.</p> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p201"><span class="faux-ol-li-counter">4. </span> Fit the model. We give a minimum support of 0.02 here. After that, we print the support: </li> 
  </ol> 
  <div class="browsable-container listing-container" id="p202"> 
   <div class="code-area-container"> 
    <pre class="code-area">get_ECLAT_indexes, get_ECLAT_supports = eclat.fit(min_support=0.02,
                                                     min_combination=1,
                                                     max_combination=3,
separator=' &amp; ')
get_ECLAT_supports</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p203"> 
   <p>The output is shown in figure 4.13.<span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p204">  
   <img alt="figure" src="../Images/CH04_F13_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.13</span> Output for step 4</h5>
  </div> 
  <div class="readable-text" id="p205"> 
   <p>We can interpret the results provided based on the support. For each of the items and combination of items, we are getting the value of the support. For example, for french fries and eggs, the value of support is 3.43%.</p> 
  </div> 
  <div class="readable-text intended-text" id="p206"> 
   <p>ECLAT has some advantages over the Apriori algorithm. Since it uses a depth-search approach, it is faster than Apriori and requires less memory to compute. It does not scan the dataset iteratively, and that makes it even faster than Apriori. We will compare these algorithms once more after we have studied the last algorithm.</p> 
  </div> 
  <div class="readable-text" id="p207"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.6</span> F-P algorithm</h2> 
  </div> 
  <div class="readable-text" id="p208"> 
   <p>The F-P algorithm is the third algorithm we discuss in this chapter. It is an improvement over the Apriori algorithm. Recall in Apriori we face the challenges of time-consuming and costly computations. F-P resolves these problems by representing the database in the form of a tree called a <em>frequent pattern tree </em>or<em> FP tree</em>. Because of this frequent pattern, there is no need to generate the candidates as done in the Apriori algorithm. Let’s discuss F-P in detail now.</p> 
  </div> 
  <div class="readable-text intended-text" id="p209"> 
   <p>An F-P tree is a tree-shaped structure, and it mines the most frequent items in the datasets. This is visualized in figure 4.14. <span class="aframe-location"/></p> 
  </div> 
  <div class="browsable-container figure-container" id="p210">  
   <img alt="figure" src="../Images/CH04_F14_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.14</span> An F-P algorithm can be depicted in a tree-diagram structure. Each node represents a unique item. The root node is <code>NULL</code>.</h5>
  </div> 
  <div class="readable-text" id="p211"> 
   <p>Each node represents a unique item in the dataset. The root node of the tree is generally kept as <code>NULL</code>. The other nodes in the tree are the items in the dataset. The nodes are connected with each other if they are in the same invoice. We will study the entire process in a step-by-step fashion.</p> 
  </div> 
  <div class="readable-text intended-text" id="p212"> 
   <p>Assume we are using the dataset shown in table 4.7. So we have the unique items as Apples, Milk, Eggs, Cheese, and Bread. There are nine transactions, and the respective items in each of the transactions are shown in table 4.7. </p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p213"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.7</span> Dataset to understand the F-P algorithm</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Transactions 
       </div> </th> 
      <th> 
       <div>
         Item sets 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  T1 <br/> </td> 
      <td>  Apples, Milk, Eggs <br/> </td> 
     </tr> 
     <tr> 
      <td>  T2 <br/> </td> 
      <td>  Milk, Cheese <br/> </td> 
     </tr> 
     <tr> 
      <td>  T3 <br/> </td> 
      <td>  Milk, Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  T4 <br/> </td> 
      <td>  Apples, Milk, Cheese <br/> </td> 
     </tr> 
     <tr> 
      <td>  T5 <br/> </td> 
      <td>  Apples, Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  T6 <br/> </td> 
      <td>  Milk, Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  T7 <br/> </td> 
      <td>  Apples, Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  T8 <br/> </td> 
      <td>  Apples, Milk, Bread, Eggs <br/> </td> 
     </tr> 
     <tr> 
      <td>  T9 <br/> </td> 
      <td>  Apples, Milk, Bread <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p214"> 
   <p>Let’s apply the F-P algorithm on this dataset now. The steps are as follows:</p> 
  </div> 
  <ol> 
   <li class="readable-text" id="p215"> Like Apriori, the entire dataset is scanned first. Occurrences for each of the items is counted, and a frequency is generated. The results are suggested in table 4.8. We have arranged the items in descending order of the frequency or the respective support count in the entire dataset. For example, apples have been purchased in six transactions. </li> 
  </ol> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p216"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.8</span> Respective frequency for each of the item sets </h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Item 
       </div> </th> 
      <th> 
       <div>
         Frequency or support count 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Milk <br/> </td> 
      <td>  7 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Apples <br/> </td> 
      <td>  6 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Bread <br/> </td> 
      <td>  6 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Cheese <br/> </td> 
      <td>  2 <br/> </td> 
     </tr> 
     <tr> 
      <td>  Eggs <br/> </td> 
      <td>  2 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text print-book-callout" id="p217"> 
   <p>If two items have exactly same frequency, either can be ordered first. In the example here, Bread and Apples have the same frequency. So we can keep either Bread or Apples as the first one.</p> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p218"><span class="faux-ol-li-counter">2. </span> Start the construction of the F-P tree. We start with creating the root node, which is generally the <code>NULL</code> node, in figure 4.15.<span class="aframe-location"/> </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p219">  
   <img alt="figure" src="../Images/CH04_F15_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.15</span> The root node for the tree is generally kept NULL.</h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p220"><span class="faux-ol-li-counter">3. </span> Analyze the first transaction, T1. Here we have Apples, Milk, and Eggs in the first transaction. Out of these three, Milk has the highest support count, which is 7. So a connection is extended from the root node to Milk, and we denote it as Milk:1 (see figure 4.16).<span class="aframe-location"/> </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p221">  
   <img alt="figure" src="../Images/CH04_F16_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.16</span> Connection from the root node to Milk. Milk has the highest support; hence we have chosen Milk.</h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p222"><span class="faux-ol-li-counter">4. </span> Now look at the other items in T1. Apples has a support count of 6 and Eggs have a support count of 2. So we will extend the connection from Milk to Apples and name it Apples:1 and then from Apples to Eggs and call it Eggs:1 (see figure 4.17). </li> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p223"><span class="faux-ol-li-counter">5. </span> Look at T2 now. It has Milk and Cheese. Milk is already connected to the root node. So the count for Milk becomes 2, and it becomes Milk:2. Next, we will create a branch from Milk to Cheese and name it Cheese:1. The addition is shown in figure 4.18. </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p224">  
   <img alt="figure" src="../Images/CH04_F17_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.17</span> Step 4 of the process where we have finished all the items in T1. All the items—Milk, Apples, and Eggs—are now connected. </h5>
  </div> 
  <div class="browsable-container figure-container" id="p225">  
   <img alt="figure" src="../Images/CH04_F18_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.18</span> Step 5 of the process where we started to analyze T2. Milk is already connected, so its count increases by 2 while Cheese gets added to the tree. </h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p226"><span class="faux-ol-li-counter">6. </span> Consider T3. T3 has Milk and Bread. So, similar to step 5, the count for Milk is 3, and it becomes Milk:3. And, similar to step 5, we add another connection from Milk to Bread and call it Bread:1. The updated tree is shown in figure 4.19.<span class="aframe-location"/> </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p227">  
   <img alt="figure" src="../Images/CH04_F19_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.19</span> In step 6, T3 is analyzed. Milk’s count increased by 1 more and becomes 3, while Bread is added as a new connection.</h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p228"><span class="faux-ol-li-counter">7. </span> In T4, we have Apples, Milk, and Cheese. The count for Milk becomes 4; for Apples it is now 2. Then we create a branch from Apples to Cheese, calling it Cheese:1 (see figure 4.20).<span class="aframe-location"/> </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p229">  
   <img alt="figure" src="../Images/CH04_F20_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.20</span> In step 7 of the process, T4 is being analyzed. The count of Milk becomes 4, for Apples it increases to 2, and a new branch from Apples to Cheese is added.</h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p230"><span class="faux-ol-li-counter">8. </span> We find in T5 that we have Apples and Bread. Both are not directly connected to the root node and have an equal frequency of 6. So we can take either to be connected to the root node. The figure gets updated to figure 4.21. </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p231">  
   <img alt="figure" src="../Images/CH04_F21_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.21</span> After analyzing T5, the diagram changes, as shown here. We have Apples and Bread, which get added to the tree.</h5>
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p232"><span class="faux-ol-li-counter">9. </span> This process continues until we exhaust all the transactions, resulting in the final figure as shown in figure 4.22. <span class="aframe-location"/> </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p233">  
   <img alt="figure" src="../Images/CH04_F22_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.22</span> The final tree once we have exhausted all the possible combinations </h5>
  </div> 
  <div class="readable-text" id="p234"> 
   <p>Great job so far! But there are more steps after this. So far, we have created only the tree. Now we need to generate the dataset as shown in table 4.9. This is the output we wish to generate.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p235"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.9</span> Table for the F-P algorithm</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Items 
       </div> </th> 
      <th> 
       <div>
         Conditional pattern base 
       </div> </th> 
      <th> 
       <div>
         Conditional F-P tree 
       </div> </th> 
      <th> 
       <div>
         Frequent pattern generated 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Cheese <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  Bread <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  Eggs <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  Apples <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p236"> 
   <p>You might be wondering why there are only four items listed. Since Milk has directly originated from the root node and there is no other way to reach it, we need not have a separate row for Milk.</p> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p237"><span class="faux-ol-li-counter">10. </span> Before continuing, we must fix the minimum support count as 2 for any rule to be acceptable. We do this for simplicity’s sake as the dataset is quite small. </li> 
  </ol> 
  <div class="readable-text print-book-callout" id="p238"> 
   <p><span class="print-book-callout-head">NOTE </span> For real-life business problems, you are advised to test with multiple and even much higher values for the support counts; otherwise, the number of rules generated can be very high. </p> 
  </div> 
  <div class="readable-text" id="p239"> 
   <p>Let’s start with Cheese as the first item. We can reach cheese through {NULL-Milk-Cheese} and {NULL-Milk-Apples-Cheese}. For both paths, the count of Cheese is 1. Hence, (if we ignore NULL) our conditional pattern base is {Milk-Cheese} or {Milk:1} and {Milk-Apples:Cheese} or {Milk-Apples:1}. The complete conditional pattern base becomes {{Milk:1}, {Milk-Apples:1}}. This information is added to the second column of table 4.10. </p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p240"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.10</span> Step 10 of the process where we have filled the first cell for Cheese </h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Items 
       </div> </th> 
      <th> 
       <div>
         Conditional pattern base 
       </div> </th> 
      <th> 
       <div>
         Conditional F-P tree 
       </div> </th> 
      <th> 
       <div>
         Frequent pattern generated 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Cheese <br/> </td> 
      <td>  {{Milk:1}, {Milk-Apples:1}} <br/> </td> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  Bread <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  Eggs <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  Apples <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p241"><span class="faux-ol-li-counter">11. </span> Now if we add the two values in a conditional pattern base, we would get Milk as 2 and Apples as 1. Since we have set up a threshold for the frequency count of 2, we will ignore the count of Apples. The value for the conditional F-P tree, which is the third column in the table, becomes {Milk:2}. Now we simply add the original item to this, which becomes the frequent patten generated or column 4. See table 4.11. </li> 
  </ol> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p242"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.11</span> Step 11 of the process where we have finished the details for the item Cheese</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Items 
       </div> </th> 
      <th> 
       <div>
         Conditional pattern base 
       </div> </th> 
      <th> 
       <div>
         Conditional F-P tree 
       </div> </th> 
      <th> 
       <div>
         Frequent pattern generated 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Cheese <br/> </td> 
      <td>  {{Milk:1}, {Milk-Apples:1}} <br/> </td> 
      <td>  {Milk:2} <br/> </td> 
      <td>  {Milk-Cheese:2} <br/> </td> 
     </tr> 
     <tr> 
      <td>  Bread <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  Eggs <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  Apples <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p243"><span class="faux-ol-li-counter">12. </span> In a similar fashion, all the other cells are filled in the table, resulting in the final table (table 4.12). </li> 
  </ol> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p244"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.12</span> Final table after we have analyzed all the combinations for the items </h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Items 
       </div> </th> 
      <th> 
       <div>
         Conditional pattern base 
       </div> </th> 
      <th> 
       <div>
         Conditional F-P tree 
       </div> </th> 
      <th> 
       <div>
         Frequent pattern generated 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  Cheese <br/> </td> 
      <td>  {{Milk:1}, {Milk-Apples:1}} <br/> </td> 
      <td>  {Milk:2} <br/> </td> 
      <td>  {Milk-Cheese:2} <br/> </td> 
     </tr> 
     <tr> 
      <td>  Bread <br/> </td> 
      <td>  {{Milk-Apples:2}, {Milk:2}, {Apples:2}} <br/> </td> 
      <td>  {{Milk:4, Apples:2}, {Apples:2}} <br/> </td> 
      <td>  {{Milk-Bread:4}, {Apples-Bread:4}, {Milk-Apples-Bread:2}} <br/> </td> 
     </tr> 
     <tr> 
      <td>  Eggs <br/> </td> 
      <td>  {{Milk-Apples:1}, {Milk-Apples-Bread:1}} <br/> </td> 
      <td>  {Milk:2, Apples:2} <br/> </td> 
      <td>  {{Milk-Eggs:2}, {Milk-Apples:2}, {Milk-Apples:2}} <br/> </td> 
     </tr> 
     <tr> 
      <td>  Apples <br/> </td> 
      <td>  {Milk:4} <br/> </td> 
      <td>  {Milk:4} <br/> </td> 
      <td>  {Milk-Apples:4} <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p245"> 
   <p>It is a complex process indeed. But once the steps are clear, it is straightforward. </p> 
  </div> 
  <div class="readable-text intended-text" id="p246"> 
   <p>As a result of this exercise, we have received the final set of rules as depicted in the final column Frequent Pattern Generated.</p> 
  </div> 
  <div class="readable-text print-book-callout" id="p247"> 
   <p><span class="print-book-callout-head">NOTE </span> Notice that none of the rules are similar to each other.</p> 
  </div> 
  <div class="readable-text" id="p248"> 
   <p>We will use the final column, Frequent Pattern Generated, as the rules for our dataset. </p> 
  </div> 
  <div class="readable-text intended-text" id="p249"> 
   <p>The Python implementation for the F-P growth algorithm is quite simple and is easy to compute using the libraries. In the interest of space, we have uploaded the Jupyter notebook to the GitHub repository of the chapter. </p> 
  </div> 
  <div class="readable-text intended-text" id="p250"> 
   <p>We will now explore another interesting topic: sequence rule mining. It is a very powerful solution that allows a business to tailor its marketing strategies and product recommendations to the customers.</p> 
  </div> 
  <div class="readable-text" id="p251"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.7</span> Sequence rule mining </h2> 
  </div> 
  <div class="readable-text" id="p252"> 
   <p>Consider this: Netflix has a transactional database of all the movies ordered by customers over time. If it analyzes and finds that 65% of customers who viewed a war movie <em>X</em> also viewed a romantic comedy <em>Y</em> in the following month, then this is very insightful and actionable information. It will allow Netflix to recommend its offerings to customers and customize its marketing strategy. </p> 
  </div> 
  <div class="readable-text intended-text" id="p253"> 
   <p>So far in the chapter, we have covered three algorithms for association rules. But all the data points were limited to the same dataset, and there was no sequencing involved. Sequential pattern mining allows us to analyze a dataset that has a sequence of events happening. By analyzing the dataset, we can find statistically relevant patterns, which allows us to decipher the entire sequence of events. Obviously, the sequence of events is in a particular order, which is a very important property to be considered during sequence rule mining. </p> 
  </div> 
  <div class="readable-text print-book-callout" id="p254"> 
   <p><span class="print-book-callout-head">NOTE </span> Sequence rule mining is different from time-series analysis. To learn more about time-series analysis, refer to the appendix.</p> 
  </div> 
  <div class="readable-text" id="p255"> 
   <p>Sequence rule mining is utilized across multiple domains and functions. It can be used in biology to extract information during DNA sequencing, or it can be used to understand the online search pattern of a user. Sequence rule mining would help us understand what the user is going to search next. During the discussion of association rules, we used the transactions in which milk, bread, and eggs were purchased in the same transaction. Sequence rule mining is an extension to that wherein we analyze consecutive transactions and try to decipher the sequence present, if any. </p> 
  </div> 
  <div class="readable-text intended-text" id="p256"> 
   <p>While studying the Sequential Pattern Discovery Using Equivalence classes (SPADE) algorithm, we cover the mathematical concepts that form the base of the algorithm. These concepts are a little tricky and might require more than one reading to grasp. </p> 
  </div> 
  <div class="readable-text" id="p257"> 
   <h3 class=" readable-text-h3"><span class="num-string">4.7.1</span> Sequential Pattern Discovery Using Equivalence</h3> 
  </div> 
  <div class="readable-text" id="p258"> 
   <p>We now explore sequence rule mining using SPADE. It was suggested by Mohammed J. Zaki; the link to the paper is at the end of this chapter.</p> 
  </div> 
  <div class="readable-text intended-text" id="p259"> 
   <p>So we wish to analyze a sequence of events. For example, a customer bought a mobile phone and a charger. After a week, they bought earphones, and after two weeks, they bought a mobile phone cover and screen guard. So, in each of the transactions, there were items purchased. And each transaction can be called an event. Let’s understand it in more detail.</p> 
  </div> 
  <div class="readable-text intended-text" id="p260"> 
   <p>Let us assume we have the complete list of items for the discussion. <span class="regular-symbol">I</span>t will contain items like i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>, i<sub>4</sub>, i<sub>5</sub>, and so on. So we can write <em>I</em> = {i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>, i<sub>4</sub>, i<sub>5</sub>………, i<sub><em>n</em></sub>} where we have <em>n</em> distinct items in total.</p> 
  </div> 
  <div class="readable-text intended-text" id="p261"> 
   <p>Items can be anything. If we consider the same example of a grocery store, items can be milk, eggs, cheese, bread, and so on.</p> 
  </div> 
  <div class="readable-text intended-text" id="p262"> 
   <p>An event will be a collection of items in the same transaction. An event can contain items like (i<sub>1</sub>, i<sub>5</sub>, i<sub>4</sub>, i<sub>8</sub>). For example, an event can contain items bought in the same transaction (milk, sugar, cheese, bread). We will denote an event by ⍺.</p> 
  </div> 
  <div class="readable-text intended-text" id="p263"> 
   <p>Next, let’s understand a sequence. A sequence is nothing but events in an order. In other words, ⍺<sub>1</sub> -&gt; ⍺<sub>2</sub> -&gt; ⍺<sub>3</sub> -&gt; ⍺<sub>4</sub> can be termed a sequence of events. For example, (Milk, Cheese) -&gt; (Bread, Eggs) -&gt; (Cheese, Bread, Sugar) -&gt; (Milk, Bread) is a sequence of transactions. It means that in the first transaction, milk and cheese were bought. In the following transaction, bread and eggs were bought, and so on. </p> 
  </div> 
  <div class="readable-text intended-text" id="p264"> 
   <p>A sequence with <em>k</em> items is a k-item sequence. For example, sequence (Milk, Bread) -&gt; (Eggs) contains three items. Now let’s explore the SPADE algorithm step by step. </p> 
  </div> 
  <div class="readable-text intended-text" id="p265"> 
   <p>Let’s say we have the following sequences generated. In the first sequence, ID 1001, Milk is bought in the very first transaction. In the second one, Milk, Eggs, and Bread are bought. They are followed by Milk and Bread. In the fourth one, only Sugar is purchased. In the fifth and final transaction of sequence 1001, Bread and Apples are purchased; this is applicable to all the respective sequences. For example, in sequence ID 1001, we have multiple events. In the first purchase, Milk is bought. Then (Milk, Eggs, Bread) are bought and so on. See table 4.13.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p266"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.13</span> The dataset for sequence mining </h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Sequence 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  &lt;(Milk) (Milk, Eggs, Bread) (Milk, Bread) (Sugar) (Bread, Apples)&gt; <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  &lt;(Milk, Sugar) (Bread) (Eggs, Bread) (Milk, Cheese)&gt; <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  &lt;(Cheese, Apples) (Milk, Eggs) (Sugar, Apples) (Bread) (Eggs)&gt; <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  &lt;(Cheese, Bananas) (Milk, Apples) (Bread) (Eggs) (Bread)&gt; <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p267"> 
   <p>Table 4.13 can be converted into a vertical data format as shown in table 4.14. In this step, we calculate the frequencies for one-sequence items, which are sequences with only one item. For this, only a single database scan is required. We simply have the sequence ID and element ID for each of the items.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p268"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.14</span> Vertical format for table 4.13 </h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Element ID 
       </div> </th> 
      <th> 
       <div>
         Items 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  Milk <br/> </td> 
     </tr> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  Milk, Eggs, Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  3 <br/> </td> 
      <td>  Milk, Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  4 <br/> </td> 
      <td>  Sugar <br/> </td> 
     </tr> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  Bread, Apples <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  Milk, Sugar <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  3 <br/> </td> 
      <td>  Eggs, Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  4 <br/> </td> 
      <td>  Milk, Cheese <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  Cheese, Apples <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  Milk, Eggs <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  3 <br/> </td> 
      <td>  Sugar, Apples <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  4 <br/> </td> 
      <td>  Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  Eggs <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  Cheese, Bananas <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  Milk, Apples <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  3 <br/> </td> 
      <td>  Bread <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  4 <br/> </td> 
      <td>  Eggs <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  5 <br/> </td> 
      <td>  Bread <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p269"> 
   <p>Table 4.14 is nothing but a vertical tabular representation of table 4.13. For example, in sequence ID 1001, at the element ID 1 we have Milk. For sequence ID 1001, at the element ID 2 we have Milk, Eggs, Bread, and so on. </p> 
  </div> 
  <div class="readable-text intended-text" id="p270"> 
   <p>For the purpose of explanation, we are considering only two items—0 Milk and Eggs—and the support threshold of 2. </p> 
  </div> 
  <div class="readable-text intended-text" id="p271"> 
   <p>Then, in the next step, we will break it down for each of the items. For example, Milk appears in sequence ID 1001 and element ID 1, sequence ID 1001 and element ID 2, sequence ID 1001 and element ID 3, sequence ID 1002 and element ID 1, and so on. It results in a table like table 4.15 where we have shown Milk and Eggs. It needs to be applied to all the items in the dataset. </p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p272"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.15</span> Respective sequence IDs for Milk and Eggs</h5> 
   <table> 
    <thead> 
     <tr> 
      <th colspan="2"> 
       <div>
         Milk 
       </div> </th> 
      <th colspan="2"> 
       <div>
         Eggs 
       </div> </th> 
     </tr> 
     <tr> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Element ID 
       </div> </th> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Element ID 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1001 <br/> </td> 
      <td>  2 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  1002 <br/> </td> 
      <td>  3 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  3 <br/> </td> 
      <td>  1003 <br/> </td> 
      <td>  2 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  1003 <br/> </td> 
      <td>  5 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  4 <br/> </td> 
      <td>  1004 <br/> </td> 
      <td>  4 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  2 <br/> </td> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  2 <br/> </td> 
      <td/> 
      <td/> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p273"> 
   <p>Now we wish to count two sequences or those with two-item sequences. We can have two sequences: either Milk -&gt; Eggs or Eggs -&gt; Milk. Let’s first take Milk -&gt; Eggs.</p> 
  </div> 
  <div class="readable-text intended-text" id="p274"> 
   <p>For Milk -&gt; Eggs, we need to have Milk in front of Eggs. For the same sequence ID, if the element ID of Milk is less than the element ID of Eggs, then it is an eligible sequence. In the preceding example, for sequence ID 1001, the element ID of Milk is 1, while the element ID of Eggs is 2. So we can add that as the first eligible pair, as shown in the first row of table 4.16. The same is true for sequence ID 1002. In table 4.15, row 4, we have sequence ID 1002. The element ID of Milk is 1, while that of Eggs in row 2 is 3. Again, the element ID of Milk is lesser than the element ID of Eggs, so it becomes the second entry, and the process continues. The key point is to have the same sequence ID while comparing the respective element IDs of Milk and Eggs.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p275"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.16</span> Sequence for Milk and Eggs</h5> 
   <table> 
    <thead> 
     <tr> 
      <th colspan="3"> 
       <div>
         Milk and Eggs 
       </div> </th> 
     </tr> 
     <tr> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Element ID (Milk) 
       </div> </th> 
      <th> 
       <div>
         Element ID (Eggs) 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  2 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  3 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  5 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  4 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p276"> 
   <p>By using the same logic, we can create the table for Eggs -&gt; Milk, which is shown in table 4.17. Again, the key point is to have the same sequence ID while comparing the respective element IDs of Milk and Eggs.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p277"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.17</span> Sequence for Eggs and Milk</h5> 
   <table> 
    <thead> 
     <tr> 
      <th colspan="3"> 
       <div>
         Eggs and Milk 
       </div> </th> 
     </tr> 
     <tr> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Element ID (Eggs) 
       </div> </th> 
      <th> 
       <div>
         Element ID (Milk) 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  3 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  3 <br/> </td> 
      <td>  4 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p278"> 
   <p>This can be done for each of the possible combinations. We now move to creating three-item sequences, and we will create Milk, Eggs -&gt; Milk. For this purpose, we have to join the two tables. See table 4.18.</p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p279"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.18</span> Combining the sequence Milk -&gt; Eggs and Eggs -&gt; Milk to join the tables</h5> 
   <table> 
    <thead> 
     <tr> 
      <th colspan="3"> 
       <div>
         Milk and Eggs 
       </div> </th> 
      <th/> 
      <th colspan="3"> 
       <div>
         Eggs and Milk 
       </div> </th> 
     </tr> 
     <tr> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Element ID (Milk) 
       </div> </th> 
      <th> 
       <div>
         Element ID 
       </div> 
       <div>
         (Eggs) 
       </div> </th> 
      <th/> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Element ID (Eggs) 
       </div> </th> 
      <th> 
       <div>
         Element ID (Milk) 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  2 <br/> </td> 
      <td/> 
      <td>  1001 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  3 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  3 <br/> </td> 
      <td/> 
      <td>  1002 <br/> </td> 
      <td>  3 <br/> </td> 
      <td>  4 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  5 <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  4 <br/> </td> 
      <td/> 
      <td/> 
      <td/> 
      <td/> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p280"> 
   <p>The logic of joining is matching the sequence ID and the element ID. We have highlighted the matching ones in red and green, respectively, although this will not show up in the printed book. For sequence ID 1001, the element ID of Eggs in the left table matches the element ID of Eggs in the right table, and that becomes the first entry of table 4.19, which shows the results. Similarly, for sequence ID 1002, element ID 3 matches. </p> 
  </div> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p281"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.19</span> Final table after we have analyzed all the combinations for the items </h5> 
   <table> 
    <thead> 
     <tr> 
      <th colspan="4"> 
       <div>
         Milk, Eggs -&gt; Milk 
       </div> </th> 
     </tr> 
     <tr> 
      <th> 
       <div>
         Sequence ID 
       </div> </th> 
      <th> 
       <div>
         Element ID (Milk) 
       </div> </th> 
      <th> 
       <div>
         Element ID (Eggs) 
       </div> </th> 
      <th> 
       <div>
         Element ID (Milk) 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  2 <br/> </td> 
      <td>  3 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  1 <br/> </td> 
      <td>  3 <br/> </td> 
      <td>  4 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p282"> 
   <p>This process continues. The algorithm stops when no frequent sequences can be found. </p> 
  </div> 
  <div class="readable-text intended-text" id="p283"> 
   <p>We will now implement SPADE on a dataset using Python. We use the <code>pyspade</code> library, and thus we have to load the dataset and call the function. It generates the result for us. The support is kept as 0.6 here, and then we print the results (see figure 4.23): </p> 
  </div> 
  <div class="browsable-container listing-container" id="p284"> 
   <div class="code-area-container"> 
    <pre class="code-area">from pycspade.helpers import spade, print_result
spade_result = spade(filename='SPADE_dataset.txt', support=0.6, parse=True)
print_result(spade_result)<span class="aframe-location"/></pre>  
   </div> 
  </div> 
  <div class="browsable-container figure-container" id="p285">  
   <img alt="figure" src="../Images/CH04_F24_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.23</span> SPADE implemented on the <code>pyspade</code> library using Python </h5>
  </div> 
  <div class="readable-text" id="p286"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.8</span> Case study for association rules</h2> 
  </div> 
  <div class="readable-text" id="p287"> 
   <p>Association rule mining is quite a helpful and powerful solution. Next, we are going to solve an actual case study using association rules. Recall that, at the start of the chapter, we suggested you study the pattern of a grocery store. What is the logic of such arrangements in the store? </p> 
  </div> 
  <div class="readable-text intended-text" id="p288"> 
   <p>Consider this: you are working for a grocery retailer like Walmart, Tesco, Spar, Marks &amp; Spencer’s, etc., and you are planning the visual layout of a new store. Obviously, it is imperative that retail stores utilize the space in the store wisely and to the maximum capacity. At the same time, it is vital that the movement of the customers is not hindered. Customers should have access to all the items on display and be able to navigate easily. You might have experienced some stores where you feel choked and bombarded with displays while others are neatly stacked. </p> 
  </div> 
  <div class="readable-text intended-text" id="p289"> 
   <p>How do we solve this problem? There can be multiple solutions. Some retailers might wish to group the items based on their categories. For example, they might want to keep all the baking products on one shelf or use some other condition. We are studying the machine learning example here. </p> 
  </div> 
  <div class="readable-text intended-text" id="p290"> 
   <p>Using market basket analysis, we can generate the rules that indicate the respective relationships between various items. We can predict which items are frequently bought together, and they can be kept together in the store. For example, if we know that milk and bread are bought together, then bread can be kept near the milk counter. The customer purchasing milk can locate bread easily and continue with their purchase. </p> 
  </div> 
  <div class="readable-text intended-text" id="p291"> 
   <p>But it is not as easy as it sounds. Let us solve this case step by step:</p> 
  </div> 
  <ol> 
   <li class="readable-text" id="p292"> <em>Business problem definition</em><em> </em>—The very first step is defining the business problem, which is clear to us. We wish to discover the relationships between various items so that the arrangement in the store can be made better. Here, <em>planograms</em> come into the picture. Planograms help the retailer plan the utilization of the space in the store in a wise manner so that the customer can also navigate and access the products easily. It can be considered a visual layout of the store. An example is shown in figure 4.24.<span class="aframe-location"/> </li> 
  </ol> 
  <div class="browsable-container figure-container" id="p293">  
   <img alt="figure" src="../Images/CH04_F25_Verdhan.png"/> 
   <h5 class=" figure-container-h5"><span class="num-string">Figure 4.24</span> An example of a planogram. Planograms are very useful for visual merchandising.</h5>
  </div> 
  <div class="readable-text list-body-item" id="p294"> 
   <p>In the figure, we can see that there are specific areas for each item category. Association rules are quite insightful to help generate directions for planograms.</p> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p295"><span class="faux-ol-li-counter">2. </span> <em>Data discovery</em><em> </em>—The next step is data discovery, wherein the historical transactions are scouted and loaded into a database. Typically, a transaction can look like table 4.20. Note it is quite a challenge to convert this data format into one that can be consumed by the association rule algorithms. </li> 
  </ol> 
  <div class="browsable-container browsable-table-container framemaker-table-container" id="p296"> 
   <h5 class=" browsable-container-h5"><span class="num-string">Table 4.20</span> Example of invoices generated in a real-world retail store</h5> 
   <table> 
    <thead> 
     <tr> 
      <th> 
       <div>
         Invoice number 
       </div> </th> 
      <th> 
       <div>
         Date 
       </div> </th> 
      <th> 
       <div>
         Items 
       </div> </th> 
      <th> 
       <div>
         Amount 
       </div> </th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>  1001 <br/> </td> 
      <td>  01-Jun-21 <br/> </td> 
      <td>  Milk, Eggs, Cheese, Bread <br/> </td> 
      <td>  $10 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1002 <br/> </td> 
      <td>  01-Jun-21 <br/> </td> 
      <td>  Bread, Bananas, Apples, Butter <br/> </td> 
      <td>  $15 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1003 <br/> </td> 
      <td>  01-Jun-21 <br/> </td> 
      <td>  Butter, Carrots, Cheese, Eggs, Bread, Milk, Bananas <br/> </td> 
      <td>  $19 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1004 <br/> </td> 
      <td>  01-Jun-21 <br/> </td> 
      <td>  Milk <br/> </td> 
      <td>  $1 <br/> </td> 
     </tr> 
     <tr> 
      <td>  1005 <br/> </td> 
      <td>  01-Jun-21 <br/> </td> 
      <td>  Bread <br/> </td> 
      <td>  $0.80 <br/> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p297"><span class="faux-ol-li-counter">3. </span> <em>Data preparation</em><em> </em>—This step perhaps is the most difficult step. As we have seen, association rules model creation is a very simple task. We have libraries that can do the heavy lifting for us. But the dataset expected by them is in a particular format. This is a tedious task; it is quite time-consuming and requires a lot of data preprocessing skills. </li> 
  </ol> 
  <div class="readable-text list-body-item" id="p298"> 
   <p>There are a few considerations you should keep in mind while preparing the dataset:</p> 
  </div> 
  <ul> 
   <li class=" buletless-item" style="list-style-type: none;"> 
    <ul> 
     <li class="readable-text" id="p299"> Sometimes we get NULL or blank values during the data preparation phase. Missing values in the datasets can lead to problems while computing. In other machine learning solutions, we would advise to treat the missing values. In the case of association rules, we suggest ignoring the respective transactions and not considering them in the final dataset. </li> 
     <li class="readable-text" id="p300"> Many times, we get junk values in the data. Special characters like !@%^&amp;*()_ are found in the datasets. This can be attributed to incorrect entries in the system. Hence, data cleaning is required. We cover the data preprocessing step in detail in chapter 11, wherein we deal with NULL values and junk values. </li> 
     <li class="readable-text" id="p301"> Converting a table into a format that can be understood and consumed by the association rule learning algorithms is an imperative but arduous step. Go through the concept of SQL pivoting to understand the concept better. </li> 
    </ul> </li> 
  </ul> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p302"><span class="faux-ol-li-counter">4. </span> <em>Model preparation</em><em> </em>—Perhaps the easiest of the steps is modeling. We have already solved Python solutions for different algorithms, so you should be quite comfortable with it. </li> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p303"><span class="faux-ol-li-counter">5. </span> <em>Model interpretation</em><em> </em>—Creating the model might be easy, but interpretation of the rules is not. Sometimes, you have rules like #NA -&gt; (Milk, Cheese). Such a rule is obviously not usable and does not make any sense. It indicates that the data preparation was not correct and some junk values are still present in the dataset. Another example is (Some items) -&gt; (Packaging material); this is perhaps the most obvious rule but, again, not usable. This rule indicates that whenever shopping is done, packaging material is also purchased. That’s obvious, right? A final example is (Potatoes, Tomatoes) -&gt; (Onions). This kind of rule might look correct, but it is a common-sense fact that the retailer would already know. Obviously, most of the customers who are buying vegetables will buy potatoes, tomatoes, and onions together. Such rules might not add much value to the business. </li> 
  </ol> 
  <div class="readable-text list-body-item" id="p304"> 
   <p>The threshold for support, confidence, lift, and conviction allows us to filter out the most important rules. We can sort the rules in the descending order of the lift and then remove the most obvious ones.</p> 
  </div> 
  <div class="readable-text list-body-item" id="p305"> 
   <p>It is of vital importance that business stakeholders and subject matter experts are involved at every step. In this case study, the operations team, visual merchandising team, product teams, and marketing teams are the key players, which should be closely aligned at each step.</p> 
  </div> 
  <ol class=" faux-ol-li" style="list-style: none;"> 
   <li class="readable-text faux-li has-faux-ol-li-counter" id="p306"><span class="faux-ol-li-counter">6. </span> <em>Improving the planogram</em><em> </em>—Once the rules are generated and accepted, then we can use them to improve the planogram for the retail space. The retailer can use them to improve the marketing strategy and improve product promotions. For example, if a rule like (A, B) -&gt; (C) is accepted, the retailer might wish to create a bundle of the products and sell them as a single entity. It will increase the average number of items purchased in the same transaction for the business. </li> 
  </ol> 
  <div class="readable-text" id="p307"> 
   <p>This case study can be extended to any other domain or business function. For example, the same steps can be used if we wish to examine user’s movement across web pages. Web developers can analyze the historical clicks and usages of the customers on their websites. By identifying the patterns, they can find out what users tend to click and which features will maximize their engagement. Medical practitioners can use association rules to better diagnose patients. The doctors can compare the probability of the symptoms in relationship with other symptoms and provide a more accurate diagnosis.</p> 
  </div> 
  <div class="readable-text" id="p308"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.9</span> Concluding thoughts</h2> 
  </div> 
  <div class="readable-text" id="p309"> 
   <p>There are some assumptions and limitations in the association rules and sequence rules we have studied:</p> 
  </div> 
  <ul> 
   <li class="readable-text" id="p310"> The respective significance of an item is ignored while we generate the rules. For example, if a customer purchased five cans of milk and 1 kg of apples in a transaction, it is treated similarly to an invoice in which one can of milk and 5 kg of apples are purchased. Hence, we should bear in mind that the respective <em>weight</em> of an item is not being considered. </li> 
   <li class="readable-text" id="p311"> The cost of an item indicates the perceived value of a product. Some products that are costly are more important, and hence, if they are purchased by the customer, more revenue can be generated. While analyzing the invoices, we ignore the cost associated with an item. </li> 
   <li class="readable-text" id="p312"> While analyzing the sequence, we have not considered the respective time periods between the two transactions. For example, if between T1 and T2 there were 10 days while between T2 and T3 there were 40 days, both are considered as the same. </li> 
   <li class="readable-text" id="p313"> In all the analyses, we have considered different categories as the same. Perishable items and nonperishable items are treated in a similar fashion. For example, fresh milk with a shelf life of two to three days is treated similarly to washing powder, which has a much longer shelf life. </li> 
   <li class="readable-text" id="p314"> Many times, we receive noninteresting rules after analysis. These results are from common sense (Potatoes, Tomatoes) -&gt; (Onion). Such rules are not of much use. We face such a problem a lot of the time. </li> 
   <li class="readable-text" id="p315"> While noninteresting rules are a challenge, a huge number of discovered rules are again one of the problems. We get hundreds of rules, and it becomes difficult to understand and analyze each one of them. Here the thresholding becomes handy. </li> 
   <li class="readable-text" id="p316"> The time and memory requirements for computations are huge. The algorithms require scanning the datasets many times, and hence it is quite a time-consuming exercise. </li> 
   <li class="readable-text" id="p317"> The rules generated are dependent on the dataset that has been used for analysis. For example, if we analyze the dataset generated during summers only, we cannot use the rules for winters as consumers’ preferences change between different weather conditions. Moreover, we should refresh the algorithms over time since with the passage of time, the macro- and micro-economic factors change and hence the algorithms should be refreshed too. </li> 
  </ul> 
  <div class="readable-text" id="p318"> 
   <p>There are some other algorithms that are also of interest. For association rules, we can have multirelation association rules, k-optimal pattern discovery, approximate frequent datasets, generalized association rules, high-order pattern discovery, etc. For sequence mining, we have Generalized Sequence Pattern, FreeSpan, PrefixSpan, mining associated patterns, etc. These algorithms are quite interesting and can be studied for knowledge enhancement.</p> 
  </div> 
  <div class="readable-text intended-text" id="p319"> 
   <p>Association rules and sequence mining are quite interesting topics. Various business domains and functions are increasingly using association rules to understand the pattern of events. These insights allow the teams to make sound and scientific decisions to improve the customer experience and overall engagement. In this chapter, we have explored association rules and sequence mining. These were studied using Apriori, F-P, and ECLAT algorithms, and for sequence mining we used SPADE.</p> 
  </div> 
  <div class="readable-text" id="p320"> 
   <h2 class=" readable-text-h2"><span class="num-string">4.10</span> Practical next steps and suggested readings</h2> 
  </div> 
  <div class="readable-text" id="p321"> 
   <p>The following provides suggestions for what to do next and offers some helpful reading:</p> 
  </div> 
  <ul> 
   <li class="readable-text buletless-item" id="p322"> Go through these research papers for the association rules algorithm: 
    <ul> 
     <li> Fast Discovery of Association Rules: <a href="https://mng.bz/eyqv">https://mng.bz/eyqv</a> </li> 
     <li> Fast Algorithms for Mining Association Rules: <a href="https://mng.bz/64GZ">https://mng.bz/64GZ</a> </li> 
     <li> Efficient Analysis of Pattern and Association Rule Mining Approaches: <a href="https://arxiv.org/pdf/1402.2892.pdf">https://arxiv.org/pdf/1402.2892.pdf</a> </li> 
     <li> A Review of Association Rule Mining Techniques with Respect to their Privacy-Preserving Capabilities: <a href="https://mng.bz/0Q0N">https://mng.bz/0Q0N</a> </li> 
    </ul> </li> 
   <li class="readable-text buletless-item" id="p323"> For sequence mining, go through these research papers: 
    <ul> 
     <li> SPADE: An Efficient Algorithm for Mining Frequent Sequences: <a href="https://mng.bz/9YG7">https://mng.bz/9YG7</a> </li> 
     <li> Sequential Mining: Patterns and Algorithm Analysis: <a href="https://arxiv.org/pdf/1311.0350.pdf">https://arxiv.org/pdf/1311.0350.pdf</a> </li> 
     <li> Sequential Pattern Mining Algorithm Based on Interestingness: <a href="https://ieeexplore.ieee.org/document/8567170">https://ieeexplore.ieee.org/document/8567170</a> </li> 
     <li> A New Approach for Problem of Sequential Pattern Mining: <a href="https://mng.bz/jpxr">https://mng.bz/jpxr</a> </li> 
    </ul> </li> 
  </ul> 
  <div class="readable-text" id="p324"> 
   <h2 class=" readable-text-h2">Summary </h2> 
  </div> 
  <ul> 
   <li class="readable-text" id="p325"> Association rule learning identifies relationships between variables in datasets, like the beer and diaper example. </li> 
   <li class="readable-text" id="p326"> Through data analysis, such associations can inform marketing strategies, product placement, and pricing in supermarkets. </li> 
   <li class="readable-text" id="p327"> Market basket analysis in retail uses association rules to find buying patterns and is applicable in other industries like bioinformatics. </li> 
   <li class="readable-text" id="p328"> Association rules consist of antecedents leading to consequents, denoted as P -&gt; Q, with no common elements between them. </li> 
   <li class="readable-text" id="p329"> Rule significance depends on support (frequency), confidence (accuracy), lift (dependence measurement), and conviction. </li> 
   <li class="readable-text" id="p330"> High support, confidence, lift, and conviction indicate stronger, more useful rules. </li> 
   <li class="readable-text" id="p331"> The Apriori algorithm generates item sets for association rules using a “bottom-up” approach but faces challenges with large datasets. </li> 
   <li class="readable-text" id="p332"> The ECLAT algorithm uses a depth-first search for faster, memory-efficient computation of frequent item sets. </li> 
   <li class="readable-text" id="p333"> The F-P growth algorithm improves on Apriori by using a frequent pattern tree to eliminate candidate generation. </li> 
   <li class="readable-text" id="p334"> Sequence rule mining helps explain user behavior over time, distinct from time-series analysis. </li> 
   <li class="readable-text" id="p335"> The SPADE algorithm analyzes sequences of events and dependencies over time for sequence rule mining. </li> 
   <li class="readable-text" id="p336"> Python implementations of the Apriori, ECLAT, F-P growth, and SPADE algorithms are achievable with appropriate libraries. </li> 
   <li class="readable-text" id="p337"> Evaluation metrics and threshold settings for support, confidence, and lift are crucial for efficient rule generation. </li> 
   <li class="readable-text" id="p338"> Sequence rule mining has applications in marketing, bioinformatics, and user interaction analysis, allowing for actionable insights. </li> 
  </ul>
 </body></html>