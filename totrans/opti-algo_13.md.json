["```py\nimport numpy as np\nimport pandas as pd\nfrom collections import defaultdict\nfrom haversine import haversine\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport random\nfrom tqdm import tqdm\n\ncities = {\n    'New York City': (40.72, -74.00),\n    'Philadelphia': (39.95, -75.17),       \n    'Baltimore': (39.28, -76.62),\n    'Charlotte': (35.23, -80.85),\n    'Memphis': (35.12, -89.97),\n    'Jacksonville': (30.32, -81.70),\n    'Houston': (29.77, -95.38),\n    'Austin': (30.27, -97.77),\n    'San Antonio': (29.53, -98.47),\n    'Fort Worth': (32.75, -97.33),\n    'Dallas': (32.78, -96.80),\n    'San Diego': (32.78, -117.15),\n    'Los Angeles': (34.05, -118.25),\n    'San Jose': (37.30, -121.87),\n    'San Francisco': (37.78, -122.42),    \n    'Indianapolis': (39.78, -86.15),\n    'Phoenix': (33.45, -112.07),       \n    'Columbus': (39.98, -82.98), \n    'Chicago': (41.88, -87.63),\n    'Detroit': (42.33, -83.05)\n}                                                                        ①\n\ndistance_matrix = defaultdict(dict)                                      ②\nfor ka, va in cities.items():                                            ②\n    for kb, vb in cities.items():                                        ②\n        distance_matrix[ka][kb] = 0.0 if kb == ka else haversine((va[0], ②\n➥  va[1]), (vb[0], vb[1]))                                              ②\n                                                                         ②\ndistances = pd.DataFrame(distance_matrix)                                ③\ncity_names=list(distances.columns)                                       ④\ncity_indices = {city: idx for idx, city in enumerate(city_names)}\ncity_count = len(city_names)\n\ndef cost_function(path):                                                 ⑤\n    distance = 0\n    for i in range(len(path) - 1):\n        city1, city2 = city_names[path[i]], city_names[path[i + 1]]\n        distance += haversine(cities[city1], cities[city2])\n    return distance\n```", "```py\ndef ant_tour(pheromones): \n    paths = np.empty((ants, city_count), dtype=int)                ①\n    for ant in range(ants):\n        path = [city_indices['New York City']]                     ②\n        unvisited_cities = set(range(city_count))                  ③\n        unvisited_cities.remove(path[0])                           ④\n\n        while unvisited_cities:                                    ⑤\n            current_city = path[-1]\n            probabilities = []\n\n            for city in unvisited_cities:                          ⑥\n                tau = pheromones[current_city, city] \n                eta = (1 / distances[current_city, city])\n                probabilities.append((tau** alpha)*(eta ** beta))\n\n            probabilities /= sum(probabilities)                    ⑦\n            next_city = np.random.choice(list(unvisited_cities),   ⑧\np=probabilities) \n            unvisited_cities.remove(next_city)                     ⑨\n            unvisited_cities.remove(next_city)                     ⑩\n            path.append(next_city)                                 ⑪\n\n        paths[ant] = path\n\n    return paths\n```", "```py\ndef update_pheromones(paths, pheromones):\n    delta_pheromones = np.zeros_like(pheromones)                    ①\n\n    for i in range(ants):                                           ②\n        for j in range(city_count - 1):\n            city1_idx, city2_idx = paths[i, j], paths[i, j + 1]     ③\n            delta_pheromones[city1_idx, city2_idx] += Q / cost_     ④\nfunction(paths[i]) \n\n    return (1 - evaporation_rate) * pheromones + delta_pheromones   ⑤\n```", "```py\ndef run_ACO(distances, ants, iterations, alpha, beta, evaporation_rate, Q):\n    pheromones = np.ones((city_count, city_count))                          ①\n    best_path = None\n    best_distance = float('inf')\n\n    for _ in tqdm(range(iterations), desc=\"Running ACO\", unit=\"iteration\"):\n        paths =ant_tour(pheromones, distances)                              ②\n\n        distances_paths = np.array([cost_function(path) for path in paths]) ③\n        min_idx = distances_paths.argmin()\n        min_distance = distances_paths[min_idx]\n\n        if min_distance < best_distance:                                    ④\n            best_distance = min_distance\n            best_path = paths[min_idx]\n\n        pheromones = update_pheromones(paths, pheromones)                   ⑤\n\n    return best_path, best_distance                                         ⑥\n```", "```py\nants = 30                        ①\niterations = 100                 ①\nalpha = 1                        ①\nbeta = 0.9                       ①\nevaporation_rate = 0.5           ①\nQ = 100                          ①\n\nbest_path, best_distance = run_ACO(distances.values, ants, iterations, alpha, beta,\n➥ evaporation_rate, Q)          ②\n```", "```py\nRoute: New York City → Philadelphia → Baltimore → Detroit → Chicago → Indianapolis → Columbus → Charlotte → Jacksonville → Memphis → Fort Worth → Dallas → Houston → Austin → San Antonio → Phoenix → San Diego → Los Angeles → San Jose → San Francisco\nRoute length: 7937.115\n```", "```py\nimport acopy\nimport networkx as nx\n\nG=nx.Graph()\n\nfor ka, va in cities.items():\n    for kb, vb in cities.items():\n        G.add_weighted_edges_from({(ka,kb, distance_matrix[ka][kb])})\nG.remove_edges_from(nx.selfloop_edges(G))\n```", "```py\nevaporation_rate = 0.5                                                  ①\niterations = 100                                                        ①\nQ = 100                                                                 ①\n\nsolver = acopy.Solver(rho=evaporation_rate, q=Q)                        ②\n\ncolony = acopy.Colony(alpha=1, beta=0.9)                                ③\n\nfor n_iter in range(iterations):                                        ④\n    tour = solver.solve(G, colony, limit=4)\n    path_indices = ['New York City']                                    ⑤\n    for edge in tour.path:\n        next_city = edge[0] if edge[1] == path_indices[-1] else edge[1] ⑥\n        if next_city not in path_indices:                               ⑥\n            path_indices.append(next_city)                              ⑥\n\ntour.path=path_indices                                                  ⑦\n```", "```py\nbest_path = tour.path\nbest_distance = tour.cost\nRoute = \" → \".join(best_path)\nprint(\"Route:\", Route)\nprint(\"Route length:\", np.round(best_distance, 3))\n```", "```py\nRoute: New York City → Columbus → Detroit → Philadelphia → Baltimore → Charlotte → Jacksonville → Memphis → Houston → Dallas → Fort Worth → Austin → San Antonio → Phoenix → San Diego → Los Angeles → San Jose → San Francisco → Chicago → Indianapolis\nRoute length: 11058.541 \n```", "```py\nInitialization Phase: population of candidate solutions (food sources) are initialized \nREPEAT\n   Forager Bee Phase: Each forager bee goes to a food source in her memory and determines a closest source, then evaluates its nectar amount and dances in the hive\n   Onlooker Bee Phase: Each onlooker bee watches the dance of forager bees and chooses one of their sources depending on the dances, and then goes to that source. After choosing a neighbor around that, she evaluates its nectar amount.\n   Scout Bee Phase: Abandoned food sources are determined and are replaced with the new food sources discovered by scout bees.\n   Memorize the best food source (solution) achieved so far.\nUNTIL (termination criteria are met)\n```", "```py\nimport numpy as np\nimport random\nimport matplotlib.pyplot as plt\n\ndef rosenbrock_function(cand_soln):\n    return (1 - cand_soln[0]) ** 2 + 100 * (cand_soln[1] - cand_soln[0] ** 2) ** 2\n```", "```py\nclass Bee:\n    def __init__(self, position, fitness):\n        self.position = position\n        self.fitness = fitness\n        self.counter = 0\n```", "```py\ndef generate_bee(dimensions):\n    position = np.array([random.uniform(-5, 5) for _ in range(dimensions)])\n    fitness = rosenbrock_function(position)\n    return Bee(position, fitness)\n```", "```py\ndef update_position(bee, partner, dimensions):\n    index = random.randrange(dimensions)             ①\n    phi = random.uniform(-1, 1)\n    new_position = bee.position.copy()\n    new_position[index] += phi * (bee.position[index] - partner.position[index])\n    new_position = np.clip(new_position, -5, 5)      ②\n    new_fitness = rosenbrock_function(new_position)\n    if new_fitness < bee.fitness:\n        bee.position = new_position\n        bee.fitness = new_fitness\n        bee.counter = 0\n    else:\n        bee.counter += 1\n```", "```py\ndef abc_algorithm(dimensions, num_bees, max_iter, max_trials):\n\n    bees = [generate_bee(dimensions) for _ in range(num_bees)]               ①\n    best_bee = min(bees, key=lambda bee: bee.fitness)                        ②\n\n    for _ in range(max_iter):\n        for i in range(num_bees // 2):                                       ③\n            employed_bee = bees[i]\n            partner_bee = random.choice(bees)\n            update_position(employed_bee, partner_bee, dimensions)\n\n        total_fitness = sum(1 / (1 + bee.fitness) if bee.fitness >= 0 else 1 ④\n➥ + abs(bee.fitness) for bee in bees)                                       ④\n        probabilities = [(1 / (1 + bee.fitness)) / total_fitness if bee.     ④\n➥ fitness >= 0 else (1 + abs(bee.fitness)) / total_fitness for bee in bees] ④\n\n        for i in range(num_bees // 2, num_bees):                             ⑤\n            onlooker_bee = random.choices(bees, weights=probabilities)[0]\n            partner_bee = min(bees[:num_bees // 2], key=lambda bee: bee.fitness)\n            update_position(onlooker_bee, partner_bee, dimensions)\n\n        for bee in bees:                                                     ⑥\n            if bee.counter > max_trials:                                     ⑦\n                new_bee = generate_bee(dimensions)\n                bee.position = new_bee.position\n                bee.fitness = new_bee.fitness\n                bee.counter = 0\n\n        best_iter_bee = min(bees, key=lambda bee: bee.fitness)               ⑧\n        if best_iter_bee.fitness < best_bee.fitness:                         ⑧\n            best_bee = best_iter_bee                                         ⑧\n\n    return best_bee                                                          ⑨\n```", "```py\ndimensions = 2                                                         ①\nnum_bees = 50                                                          ②\nmax_iter = 1000                                                        ③\nmax_trials = 100                                                       ④\n\nbest_bee = abc_algorithm(dimensions, num_bees, max_iter, max_trials)   ⑤\nprint(f\"Best solution: {best_bee.position}\")                           ⑥\nprint(f\"Best fitness: {best_bee.fitness}\")                             ⑥\n```", "```py\nBest solution: [0.99766117 0.99542949]\nBest fitness: 6.50385257086524e-06\n```", "```py\nfrom mealpy.swarm_based.ABC import OriginalABC                        ①\n\nproblem_dict = {\n    \"fit_func\": rosenbrock_function,\n    \"lb\": [-5, -5],\n    \"ub\": [5, 5],\n    \"minmax\": \"min\",\n}                                                                     ②\n\nepoch = 200                                                           ③\npop_size = 50                                                         ④\nn_limits = 15                                                         ⑤\n\nmodel = OriginalABC(epoch, pop_size, n_limits)                        ⑥\n\nbest_position_mealpy, best_fitness_mealpy = model.solve(problem_dict) ⑦\n\nprint(f\"Best solution: {best_position_mealpy}\")                       ⑧\nprint(f\"Best fitness: {best_fitness_mealpy}\")                         ⑧\n```", "```py\nBest solution: [1.07313697 1.04914444]\nCost at best solution: 0.0009197449137428784 \n```"]