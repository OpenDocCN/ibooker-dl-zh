<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div class="readable-text" id="p1"> 
   <h1 class=" readable-text-h1" id="ch__tables"> <span class="chapter-title-numbering"><span class="num-string">5</span></span> <span class="title-text"> Analyzing structured data</span> </h1> 
  </div> 
  <div class="introduction-summary"> 
   <h3 class="introduction-header">This chapter covers</h3> 
   <ul> 
    <li id="p2">Translating questions to queries</li> 
    <li id="p3">Building natural language interfaces</li> 
    <li id="p4">Analyzing data tables</li> 
    <li id="p5">Analyzing graph data</li> 
   </ul> 
  </div> 
  <div class="readable-text" id="p6"> 
   <p>A significant percentage of the world’s information is stored as structured data. Structured data essentially means data stored in a standardized format. For example, data tables (e.g., think of the data you would find in an Excel spreadsheet) and data describing entities and their relationships as graphs (such as a data set describing a social network) are popular types of structured data.</p> 
  </div> 
  <div class="readable-text" id="p7"> 
   <p>Tools for processing structured data have been available for many decades. After all, structured data has a standardized format optimized to make it easy for computers to process. So why do we need large language models for that? The problem with existing tools for processing structured data is their interface. Typically, each tool (or, at the very least, each category of tools for specific types of structured data) supports its own formal query language.</p> 
  </div> 
  <div class="readable-text" id="p8"> 
   <p>Using this language, users can often perform a wide range of analysis operations on structured data. But learning such query languages takes time! Wouldn’t it be nice if all those systems could be queried using a single language, ideally in natural language (e.g., plain English)?</p> 
  </div> 
  <div class="readable-text" id="p9"> 
   <p>This is where language models come into play. Large language models can translate questions in natural language into a wide range of formal languages. So we can use them as a universal interface to various data-analysis tools supporting a wide range of structured data types. In this chapter, we will build natural language query interfaces for different types of structured data. Such interfaces enable us (or others) to analyze data by typing questions in natural language. The system then translates our questions into formal queries, executes them, and presents us with results.</p> 
  </div> 
  <div class="readable-text" id="p10"> 
   <h2 class=" readable-text-h2" id="chapter-outline"><span class="num-string browsable-reference-id">5.1</span> Chapter outline</h2> 
  </div> 
  <div class="readable-text" id="p11"> 
   <p>In this chapter, we will be creating several natural language query interfaces. In general, a natural language query interface answers questions about data formulated in natural language. This chapter considers different types of structured data. First, we will create natural language interfaces that answer questions about tabular data. After that, we will create one that answers questions about graphs.</p> 
  </div> 
  <div class="readable-text" id="p12"> 
   <p>The principle is the same in both cases. We assume that data is processed using a data type–specific tool for data processing. For instance, for tabular data, we will use a relational database management system (RDBMS). To analyze graphs, we will use a system for managing graph data. Then we will use the large language model to translate questions in natural language into the query language supported by the specific tool. For instance, for an RDBMS, this is typically the Structured Query Language (SQL). Graph database management systems support a variety of graph data–specific query languages. We will use the Cypher query language (a language describing analysis operations on graph data). We will discuss both languages in more detail in the following sections.</p> 
  </div> 
  <div class="readable-text" id="p13"> 
   <p>To translate questions into formal queries, the language model needs access to the question (of course), some information about the target language (e.g., do we want to write SQL or Cypher queries?), and some information about the structure of the data we are trying to query. For instance, the structure of tabular data is characterized by the names of tables, the headers of the columns that appear in those tables (hopefully providing some hints on the semantics of data stored within them), and the data types of each column (are we storing integer values or strings?), among other things. By providing the language model with all of these pieces of information, including them in the prompt, the model should be able to produce a formal query that captures the semantics of our question.</p> 
  </div> 
  <div class="readable-text" id="p14"> 
   <p>We can process that query using a specialized tool to produce a query result. Assuming the query translation was correct, this result will represent an answer to the original question. Figure <a href="#fig__NLQIoverview">5.1</a> illustrates the whole process.</p> 
  </div> 
  <div class="browsable-container figure-container" id="p15">  
   <img alt="figure" src="../Images/CH05_F01_Trummer.png" width="883" height="575"/> 
   <h5 class=" figure-container-h5" id="fig__NLQIoverview"><span class="num-string">Figure <span class="browsable-reference-id">5.1</span></span> A natural language query interface translates questions in natural language into formal queries, taking into account the data structure. Formal queries are then processed on data by a specia- lized tool, generating a query result.</h5>
  </div> 
  <div class="callout-container sidebar-container"> 
   <div class="readable-text" id="p16"> 
    <h5 class=" callout-container-h5 readable-text-h5">Why do we need external tools?</h5> 
   </div> 
   <div class="readable-text" id="p17"> 
    <p> We have seen that language models can solve a variety of tasks. So why not simply use language models to analyze structured data directly? Why do we rely on external tools to do so and use the language model merely as a translator?</p> 
   </div> 
   <div class="readable-text" id="p18"> 
    <p>The primary reason is efficiency. Using large language models is expensive, and, at least for large data sets, the size of the data can easily exceed the maximum input size of the language model. Hence, relying on existing tools that can deal with large structured data sets seems like a better idea.</p> 
   </div> 
  </div> 
  <div class="readable-text print-book-callout" id="p19"> 
   <p> <span class="print-book-callout-head">Warning</span> In the following sections, we use language models to write commands for data processing. Although language models work astonishingly well in many cases, never rely on them to generate correct results in every single scenario. In some cases, language models may write incorrect queries. Other times, they may write commands to change or delete your data or alter your system setup. Always keep a backup of important data before enabling data access via language models. </p> 
  </div> 
  <div class="readable-text" id="p20"> 
   <h2 class=" readable-text-h2" id="a-natural-language-query-interface-for-analyzing-game-sales"><span class="num-string browsable-reference-id">5.2</span> A natural language query interface for analyzing game sales</h2> 
  </div> 
  <div class="readable-text" id="p21"> 
   <p>We’re back at Banana, where you realize that your boss happens to be a computer games enthusiast. Your boss not only likes to spend the evenings playing but also loves analyzing data about computer games. Having recently obtained a data set about computer game sales, your boss is seeking to extract interesting statistics. SQL is the language of choice for analyzing tabular data, but your boss does not feel comfortable writing SQL queries. Knowing about your expertise with regard to language models and data analysis, your boss asks whether it would be possible to build an interface that translates questions about computer games into corresponding SQL queries. After thinking about it, you realize that this could be a fun project that can be realized easily with language models. Let’s get started!</p> 
  </div> 
  <div class="readable-text" id="p22"> 
   <h3 class=" readable-text-h3" id="sec__createsqlitedb"><span class="num-string browsable-reference-id">5.2.1</span> Setting up an SQLite database</h3> 
  </div> 
  <div class="readable-text" id="p23"> 
   <p>Before we can analyze tabular data using SQL queries, we first must load that data into an RDBMS, a tool for processing data tables efficiently. In this subsection, we’ll see how to load data about computer games into SQLite, a popular RDBMS.</p> 
  </div> 
  <div class="readable-text" id="p24"> 
   <p>As a first step, make sure SQLite is installed. We will be using SQLite version 3 in this section. You can check whether SQLite 3 is installed by typing the following in your terminal:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p25"> 
   <div class="code-area-container"> 
    <pre class="code-area">sqlite3 --version</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p26"> 
   <p>If you receive a message like this one, no further installation is necessary:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p27"> 
   <div class="code-area-container"> 
    <pre class="code-area">3.33.0 2020-08-14 13:23:32 fca8...</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p28"> 
   <p>If you see an error message, go to <a href="http://www.sqlite.org/download.html">www.sqlite.org/download.html</a>. Select the version that is consistent with your operating system, download all the relevant files, and follow the instructions to install SQLite. In case of problems, click the SQLite Installation item in the chapter 5 section of the book’s companion website. You will find detailed instructions for how to install SQLite on different platforms. Afterward, run the previous command to ensure that SQLite is installed properly.</p> 
  </div> 
  <div class="readable-text" id="p29"> 
   <p>Next, we want to create a relational database using SQLite. A relational database is essentially a collection of data tables. You can think of each data table as a simple spreadsheet. We have named table columns associated with a data type and (possibly many) table rows that contain values for each of the columns. For instance, table <a href="#tab__videogames">5.1</a> contains information about video games, and each row represents one game. The table has four columns: <code>Name</code>, <code>Platform</code>, <code>Year</code>, and <code>Genre</code>. Three of the columns (<code>Name</code>, <code>Platform</code>, and <code>Genre</code>) contain strings (i.e., text). The column <code>Year</code> contains numbers (representing the year in which a game was released).</p> 
  </div> 
  <div class="browsable-container browsable-table-container" id="p30"> 
   <h5 class=" browsable-container-h5" id="tab__videogames"><span class="num-string">Table <span class="browsable-reference-id">5.1</span></span> Sample of data table. Each table row describes one video game.</h5> 
   <table> 
    <tbody> 
     <tr class="odd"> 
      <td style="text-align: center;"><strong>Name</strong></td> 
      <td style="text-align: center;"><strong>Platform</strong></td> 
      <td style="text-align: center;"><strong>Year</strong></td> 
      <td style="text-align: center;"><strong>Genre</strong></td> 
     </tr> 
     <tr class="even"> 
      <td style="text-align: center;">Wii Sports</td> 
      <td style="text-align: center;">Wii</td> 
      <td style="text-align: center;">2006</td> 
      <td style="text-align: center;">Sports</td> 
     </tr> 
     <tr class="odd"> 
      <td style="text-align: center;">Super Mario Bros.</td> 
      <td style="text-align: center;">NES</td> 
      <td style="text-align: center;">1985</td> 
      <td style="text-align: center;">Platform</td> 
     </tr> 
     <tr class="even"> 
      <td style="text-align: center;">Mario Kart Wii</td> 
      <td style="text-align: center;">Wii</td> 
      <td style="text-align: center;">2008</td> 
      <td style="text-align: center;">Racing</td> 
     </tr> 
     <tr class="odd"> 
      <td style="text-align: center;">Wii Sports Resort</td> 
      <td style="text-align: center;">Wii</td> 
      <td style="text-align: center;">2009</td> 
      <td style="text-align: center;">Sports</td> 
     </tr> 
     <tr class="even"> 
      <td style="text-align: center;">Pokemon Red/Pokemon Blue</td> 
      <td style="text-align: center;">GB</td> 
      <td style="text-align: center;">1996</td> 
      <td style="text-align: center;">Role-Playing</td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text" id="p31"> 
   <p>Table <a href="#tab__videogames">5.1</a> shows a small sample of a data set you can find on the book’s companion website (look for the Games item in the chapter 5 section). We will use that data set in the following sections to create a natural language query interface, enabling users to analyze it with natural language commands. But first, we need to load that data into the SQLite database system.</p> 
  </div> 
  <div class="readable-text print-book-callout" id="p32"> 
   <p> <span class="print-book-callout-head">Tip</span> We’ll go over all the steps required to load tabular data into SQLite. This is useful if you want to load data other than that discussed here. If you don’t want to create your own database, you can skip this section and download games.db from the book’s companion website instead. </p> 
  </div> 
  <div class="readable-text" id="p33"> 
   <p>Let’s start the SQLite command-line interface. Enter the following command in the terminal, and press Enter:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p34"> 
   <div class="code-area-container"> 
    <pre class="code-area">sqlite3 games.db</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p35"> 
   <p>This command creates a new database stored in the file games.db. At the same time, it opens the SQLite command-line interface. Now we can instruct the SQLite tool to load the data set we will use in the following sections. First we have to tell SQLite a little about the structure of the data. We want to load an extended version of table <a href="#tab__videogames">5.1</a> containing additional columns. Run the following command to describe the structure of the data:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p36"> 
   <div class="code-area-container"> 
    <pre class="code-area">CREATE TABLE games(             #1
rank int, name text, platform text,                    #2
year int, genre text, publisher text, americasales numeric, 
eusales numeric, japansales numeric, othersales numeric, 
globalsales numeric);</pre> 
    <div class="code-annotations-overlay-container">
     #1 Table name
     <br/>#2 List of table columns
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p37"> 
   <p>This command describes the structure of a single table named <code>games</code> (<strong class="cueball">1</strong>) (because it will store information about video games); in parentheses, we specify the full list of columns in the table (separated by commas) (<strong class="cueball">2</strong>). Each column is defined by the column name (e.g., <code>rank</code>, <code>name</code>, or <code>genre</code>) followed by the column type. For example, <code>int</code> means the column stores integer numbers, whereas <code>text</code> means the column stores text data. All table rows must provide values for each column of the appropriate data type.</p> 
  </div> 
  <div class="readable-text" id="p38"> 
   <p>After defining the table structure, we can load data into the table from the .csv file under Games on the book’s website. Download the file if you haven’t already. We will assume that the file is stored in the folder /Downloads/videogames.csv for the following commands. Simply replace that path with the file path on your system. Load the data using the following command (still in the SQLite interface):</p> 
  </div> 
  <div class="browsable-container listing-container" id="p39"> 
   <div class="code-area-container"> 
    <pre class="code-area">.mode csv                           #1
.import /Downloads/videogames.csv games  #2</pre> 
    <div class="code-annotations-overlay-container">
     #1 Sets CSV mode
     <br/>#2 Imports the data
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p40"> 
   <p>The first command prepares SQLite to load data from a .csv file (which applies to the file we want to load) (<strong class="cueball">1</strong>). The next command (<strong class="cueball">2</strong>) imports the data: the first parameter is the path to the file we want to load data from, and the second parameter is the name of the data table we want to load the file into. In this case, we reference the table whose structure we defined before (<code>games</code>). To test whether the data was loaded successfully (which should be the case if you don’t see an error message), run the following command in SQLite:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p41"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT count(*) FROM games;</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p42"> 
   <p>You should see the result <code>16599</code> if all the data was loaded. If you see a lower number, check for error messages in the SQLite output. You can quit the SQLite console via the command <code>.quit</code> (don’t forget to prefix your command with a dot to make it work). For the following sections, we will assume that the data has been loaded and is stored in an SQLite file called games.db.</p> 
  </div> 
  <div class="readable-text" id="p43"> 
   <h3 class=" readable-text-h3" id="sql-basics"><span class="num-string browsable-reference-id">5.2.2</span> SQL basics</h3> 
  </div> 
  <div class="readable-text" id="p44"> 
   <p>Sure, we can use the language model to translate questions to SQL queries (which are understood by SQLite). But can we trust its translations? Thinking more about it, you realize that it wouldn’t hurt to have at least some SQL basics to verify the output of the language model before presenting the interface to your boss. That’s what we’ll do in this section. A full introduction to SQL is, of course, beyond the scope of this book. Have a look at the website <a href="http://www.databaselecture.com">www.databaselecture.com</a> to get a more detailed introduction by this book’s author. We’ll discuss a few SQL basics in this section that help implement our natural language query interface.</p> 
  </div> 
  <div class="readable-text" id="p45"> 
   <p>SQL queries are used to analyze data tables. Query results may be derived from a single table or by combining data from multiple tables. In our example database, created in the last section, we have a single table. Using SQL queries, we can, for instance, count rows with certain properties (e.g., all games by the same publisher), filter data (e.g., only show games that were released in 2017), or perform various aggregate operations (e.g., for each publisher, calculate the average earnings per game).</p> 
  </div> 
  <div class="readable-text" id="p46"> 
   <p>An SQL query generally describes a table to generate (using data that is already available in the database). Most example queries in this section have the following structure:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p47"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT [Columns or Aggregates]  #1
FROM [List of tables]           #2
WHERE [List of conditions]      #3</pre> 
    <div class="code-annotations-overlay-container">
     #1 SELECT clause
     <br/>#2 FROM clause
     <br/>#3 WHERE clause
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p48"> 
   <p>The <code>FROM</code> clause (<strong class="cueball">2</strong>) (the code following the <code>FROM</code> keyword and before the <code>WHERE</code> keyword) describes the source data used for analysis. For instance, the <code>FROM</code> clause can contain a list of table names separated by commas. In our example database, we have only a single table to process (for advanced queries, the same table name may appear multiple times in the <code>FROM</code> clause, creating different copies of the same table). The queries we will encounter in the following sections will contain a single entry in the <code>FROM</code> clause: the <code>games</code> table.</p> 
  </div> 
  <div class="readable-text" id="p49"> 
   <p>The <code>WHERE</code> clause (<strong class="cueball">3</strong>) defines predicates on the tables that appear in the <code>FROM</code> clause. For instance, it may contain a condition restricting the scope to games from a certain publisher. The <code>WHERE</code> clause can contain simple conditions (i.e., conditions that can be expressed by an equality or inequality on a table column) as well as complex conditions (connecting multiple simple conditions by <code>AND</code> or <code>OR</code> operators). Those conditions are used to filter rows from the tables in the <code>FROM</code> clause. Rows that do not satisfy the condition in the <code>WHERE</code> clause are discarded and do not appear in the query result.</p> 
  </div> 
  <div class="readable-text" id="p50"> 
   <p>Finally, we specify the columns of the desired result table in the <code>SELECT</code> clause (<strong class="cueball">1</strong>). More precisely, we specify a list of column definitions separated by commas. Columns may be defined by a column name (a column that appears in one of the tables in the <code>FROM</code> clause) or by a more complex expression: for example, an arithmetic expression connecting multiple columns. Alternatively, we can specify aggregates such as <code>count(*)</code> in the <code>SELECT</code> clause (the latter aggregate counts the number of rows). The query result contains a table with the specified columns, filling them with content corresponding to the column definition.</p> 
  </div> 
  <div class="readable-text" id="p51"> 
   <p>For instance, let’s say we want to count all games published in 2017. In this case, our query result should contain a single column with a count aggregate. Also, our <code>WHERE</code> clause should contain a filter condition restricting our scope to games from 2017. Our <code>FROM</code> clause contains, of course, the name of the only table in our database (<code>games</code>). The following query generates the desired result:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p52"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT Count(*)
FROM games
WHERE year = 2017</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p53"> 
   <p>To make things a little more complex, let’s assume that we want to calculate the combined number of sales in Europe and Japan for all games released in 2017 by a specific publisher (Activision). Our desired query result contains two columns: the name of the game and the sales count. As our data table features two columns with sales in Europe and sales in Japan (<code>eusales</code> and <code>japansales</code>, as per our table definition in the previous section), we can describe the desired result column by adding them (<code>eusales + japansales</code>). Because we want to restrict our scope to games from 2017 and from Activision, we can use a complex predicate in the <code>WHERE</code> clause: <code>year = 2017 AND publisher = Activision</code>. Note the use of apostrophes around the name Activision—we need to use apostrophes to delimit strings in query conditions instead of numbers. The following query generates the desired result:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p54"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT name, eusales + japansales
FROM games
WHERE year = 2017 AND publisher = 'Activision'</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p55"> 
   <p>Optionally, when specifying aggregates, we can calculate those aggregates for different groups of rows defined by shared values in certain columns. To do so, we add a final <code>GROUP BY</code> clause to the previous query template, followed by a comma-separated list of columns used to form groups. For instance, let’s assume that we want to calculate game sales for each genre (such as strategy or action) separately. We can use the following query to return one row with aggregates for each category of games (note that we add the <code>genre</code> column in the <code>SELECT</code> clause as well to ensure that we can associate numbers with the correct genre):</p> 
  </div> 
  <div class="browsable-container listing-container" id="p56"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT genre, name, eusales + japansales
FROM games
WHERE year = 2017 AND publisher = 'Activision'
GROUP BY genre</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p57"> 
   <p>The SQL primer in this section is clearly insufficient to write your own SQL queries, except for a few simple cases. However, we don’t really want to write our own SQL queries—we want to rely on the language model instead! This introduction should enable you to understand queries generated by the language model at a high level of abstraction. And observing how the language model maps questions to queries may be a good way to get started with learning SQL yourself. In the next section, we will start by creating a simple translator, translating questions into SQL queries on the <code>games</code> database.</p> 
  </div> 
  <div class="readable-text" id="p58"> 
   <h3 class=" readable-text-h3" id="overview"><span class="num-string browsable-reference-id">5.2.3</span> Overview</h3> 
  </div> 
  <div class="readable-text" id="p59"> 
   <p>Having acquired a few SQL basics to check the output of the language model, we will now work on our text-to-SQL translator. We will use our translator via the command line. We specify a question as input and ideally want an SQL query, translating our question as output. If we run the output query in SQLite, we should get the answer to our original question. Of course, this interface is manual and not very convenient to use. Ideally, we would like it to execute queries automatically and show the corresponding results directly in our query interface. We will create such an interface in the following section. For now, we just focus on the core problem of translating questions into queries. Also, for the moment, our only goal is to translate questions about computer games. Therefore, we will hardcode the structure of the target database. Again, we will generalize that in our next project.</p> 
  </div> 
  <div class="readable-text" id="p60"> 
   <p>Internally, to translate the input question, we will first create a prompt. This prompt describes the translation task and contains all relevant details for translation (e.g., the structure of our target database). Sending this prompt to the language model should result, in most cases, in a correctly translated SQL query. We may still need to do a little work to extract this query from potentially overly verbose output generated by the language model. Let’s discuss these steps in more detail, starting with the prompts.</p> 
  </div> 
  <div class="readable-text" id="p61"> 
   <h3 class=" readable-text-h3" id="generating-prompts-for-text-to-sql-translation"><span class="num-string browsable-reference-id">5.2.4</span> Generating prompts for text-to-SQL translation</h3> 
  </div> 
  <div class="readable-text" id="p62"> 
   <p>What information do we need to convey to the language model for a successful translation? Clearly, we need to specify the question we want to translate. Also, we need to specify the target system (SQLite) and describe the structure of the target database. For the moment, we hardcode the database structure. We can simply provide the language model with the table definition (<code>create table...</code>) that we used in section <a href="#sec__createsqlitedb">5.2.1</a>. The language model will understand how this command maps to a table structure. By sending a prompt with instructions for translation to the model containing all of the previously mentioned types of information, the language model should be able to produce a corresponding SQL query.</p> 
  </div> 
  <div class="readable-text" id="p63"> 
   <p>Let’s use the following prompt template:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p64"> 
   <div class="code-area-container"> 
    <pre class="code-area">Database:                                          #1
CREATE TABLE games(rank int, name text, platform text,
year int, genre text, publisher text, americasales numeric,
eusales numeric, japansales numeric, othersales numeric,
globalsales numeric);
Translate this question into SQL query:  #2
[Question]                          #3</pre> 
    <div class="code-annotations-overlay-container">
     #1 Database description
     <br/>#2 Task description
     <br/>#3 Question to translate
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p65"> 
   <p>This prompt template contains all the pieces of information described earlier. First, it describes the target database (<strong class="cueball">1</strong>) by providing the SQL commands used to create the associated tables (in this case, a single table). Note that this is not a placeholder because, for the moment, our query interface only needs to work for one database (whose structure we hardcode in the template). Next, the prompt template contains a task description (<strong class="cueball">2</strong>): the goal is to translate questions into SQL queries. Finally, the template contains the question to translate (<strong class="cueball">3</strong>). Here, we use a placeholder (indicated by square brackets). This enables us to use the same prompt template for various questions our boss may ask about the data.</p> 
  </div> 
  <div class="readable-text" id="p66"> 
   <p>The following code generates prompts according to the previous template:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p67"> 
   <div class="code-area-container"> 
    <pre class="code-area">def create_prompt(question):
    parts = []
     #1
    parts += ['Database:']
    parts += ['create table games(rank int, name text, platform text,']
    parts += ['year int, genre text, publisher text, americasales numeric,']  
    parts += ['eusales numeric, japansales numeric, othersales numeric,'] 
    parts += ['globalsales numeric);']
     #2
    parts += ['Translate this question into SQL query:']
    parts += [question]      #3
    return '\n'.join(parts)  #4</pre> 
    <div class="code-annotations-overlay-container">
     #1 Adds the database description
     <br/>#2 Adds the task description
     <br/>#3 Adds the question to translate
     <br/>#4 Returns the concatenation
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p68"> 
   <p>Given the question to translate as input, the code adds the description of the database (<strong class="cueball">1</strong>), then instructions for translation (<strong class="cueball">2</strong>), and finally the question to translate (<strong class="cueball">3</strong>). The result is the concatenation of all the prompt parts (<strong class="cueball">4</strong>).</p> 
  </div> 
  <div class="readable-text" id="p69"> 
   <h3 class=" readable-text-h3" id="complete-code"><span class="num-string browsable-reference-id">5.2.5</span> Complete code</h3> 
  </div> 
  <div class="readable-text" id="p70"> 
   <p>The next listing contains the full code for our natural language query interface. It uses the prompt-generation function discussed earlier (<strong class="cueball">1</strong>), as well as the function invoking the language model (<strong class="cueball">2</strong>) that we already know from prior chapters.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p71"> 
   <h5 class=" listing-container-h5 browsable-container-h5" id="code__translator"><span class="num-string">Listing <span class="browsable-reference-id">5.1</span></span> Translating questions about video games into SQL queries</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">import argparse
import openai
import re
import time

client = openai.OpenAI()

def create_prompt(question):                #1
    """ Generate prompt to translate question into SQL query.
    
    Args:
        question: question about data in natural language.
    
    Returns:
        prompt for question translation.
    """
    parts = []
    parts += ['Database:']
    parts += ['create table games(rank int, name text, platform text,']
    parts += ['year int, genre text, publisher text, americasales numeric,']  
    parts += ['eusales numeric, japansales numeric, othersales numeric,'] 
    parts += ['globalsales numeric);']
    parts += ['Translate this question into SQL query:']
    parts += [question]
    return '\n'.join(parts)

def call_llm(prompt):                             #2
    """ Query large language model and return answer.
    
    Args:
        prompt: input prompt for language model.
    
    Returns:
        Answer by language model.
    """
    for nr_retries in range(1, 4):
        try:
            response = client.chat.completions.create(
                model='gpt-4o',
                messages=[
                    {'role':'user', 'content':prompt}
                    ]
                )
            return response.choices[0].message.content
        except:
            time.sleep(nr_retries * 2)
    raise Exception('Cannot query OpenAI model!')

if __name__ == '__main__':       #3

    parser = argparse.ArgumentParser()
    parser.add_argument('question', type=str, help='A question about games')
    args = parser.parse_args()

    prompt = create_prompt(args.question)  #4
    answer = call_llm(prompt)         #5
     #6
    query = re.findall('\verb|```|sql(.*)\verb|```|', answer, re.DOTALL)[0]
    
    print(f'SQL: {query}')</pre> 
    <div class="code-annotations-overlay-container">
     #1 Generates a prompt for translation
     <br/>#2 Invokes the language model
     <br/>#3 Reads a query and translates it to SQL
     <br/>#4 Generates a prompt
     <br/>#5 Generates an answer
     <br/>#6 Extracts an SQL query from the answer
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p72"> 
   <p>This listing reads a question about computer games from the command line (<strong class="cueball">3</strong>). Using the input question, it generates a prompt (<strong class="cueball">4</strong>) that instructs the language model to translate the question into an SQL query. It sends the prompt to the language model and receives its answer (<strong class="cueball">5</strong>).</p> 
  </div> 
  <div class="readable-text" id="p73"> 
   <p>The raw answer from GPT-4o typically contains explanations interleaved with the SQL query we are ultimately interested in. To get the query alone, we have to extract it from the raw answer (<strong class="cueball">6</strong>). Here, we exploit the fact that GPT-4o encloses SQL queries between the markers <code>```sql</code> and <code>```</code> (when interacting with GPT models via the ChatGPT web interface, the content between those markers is rendered as a code box). The regular expression <code>```sql(.*)```</code> matches the SQL query between the markers, using the Python function <code>re.findall</code> to return a list of matches for this regular expression (the <code>re.DOTALL</code> flag is required to ensure that the dot matches all characters, including newlines, which may appear in SQL queries). We use the first of those matches as our query (i.e., we implicitly assume that at least one match is returned and that the first match is suitable).</p> 
  </div> 
  <div class="readable-text" id="p74"> 
   <h3 class=" readable-text-h3" id="trying-it-out"><span class="num-string browsable-reference-id">5.2.6</span> Trying it out</h3> 
  </div> 
  <div class="readable-text" id="p75"> 
   <p>Okay! Time to try our text-to-SQL translator! In the terminal, switch to the directory containing the Python code. We will assume that the code is stored in a file called listing1.py (which you can download from the companion website). Run the following command:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p76"> 
   <div class="code-area-container"> 
    <pre class="code-area">python listing1.py "How many games are stored?"</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p77"> 
   <p>As a result, you should obtain the following SQL query:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p78"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT COUNT(*) FROM games;</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p79"> 
   <p>Is that query correct? Let’s find out: in the terminal, switch to the repository containing the SQLite database file (games.db). Then, open the database via the SQLite command-line interface:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p80"> 
   <div class="code-area-container"> 
    <pre class="code-area">sqlite3 games.db</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p81"> 
   <p>Now we can finally try the query generated by our text-to-SQL translator. Enter the query, and press Enter. You should see the number of games stored in the database: 16,599.</p> 
  </div> 
  <div class="readable-text" id="p82"> 
   <p>You may want to try a few other questions. For example, see whether you can count the number of games by specific publishers or games of a specific genre! Chances are, for most questions referring to this simple database, GPT-4o should be capable enough to provide an accurate translation. Your boss will be happy.</p> 
  </div> 
  <div class="readable-text" id="p83"> 
   <p>The interface we created in this section is still limited in various ways. First, you have to reexecute the program for each new question. Second, you have to manually copy and execute each translated query into the database system interface. Third, and most importantly, if you ever want to switch to a different data set, you will have to manually change your prompt template. In the next section, we’ll see how to overcome these restrictions.</p> 
  </div> 
  <div class="readable-text" id="p84"> 
   <h2 class=" readable-text-h2" id="a-general-natural-language-query-interface"><span class="num-string browsable-reference-id">5.3</span> A general natural language query interface</h2> 
  </div> 
  <div class="readable-text" id="p85"> 
   <p>Your boss is happy with the new natural language interface and regularly shares interesting insights about computer game sales with you. However, you can’t help but wonder whether this use case alone exploits the full potential of your approach. For instance, the human resources unit at Banana regularly deals with complex questions on tables storing employee information. Couldn’t we generalize our natural language interface to help them as well? In this section, we’ll generalize the natural language query interface to work with arbitrary databases without requiring any changes to the code itself. Furthermore, we will make the interface more convenient by executing the translated queries directly and avoiding restarts between different questions on the same data.</p> 
  </div> 
  <div class="readable-text" id="p86"> 
   <h3 class=" readable-text-h3" id="sub__ExecutingQueries"><span class="num-string browsable-reference-id">5.3.1</span> Executing queries</h3> 
  </div> 
  <div class="readable-text" id="p87"> 
   <p>As a first step, let’s see how we can execute translated queries directly from Python. This will avoid tediously copying queries from one interface to another. In Python, we can execute queries on an SQLite database using the <code>sqlite3</code> library.</p> 
  </div> 
  <div class="readable-text" id="p88"> 
   <p>Let’s assume that the variable <code>data_path</code> stores the path to the database file. To execute queries on that database, we must first create a connection:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p89"> 
   <div class="code-area-container"> 
    <pre class="code-area">import sqlite3

with sqlite3.connect(data_path) as connection:
    ...</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p90"> 
   <p>We can now execute SQL queries on the database via the <code>connection</code> object. Let’s assume that the SQL query we want to execute is stored in the variable <code>query</code>. After connecting to the database, we first create a cursor object (enabling querying and result retrieval) and then use it to execute the query:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p91"> 
   <div class="code-area-container"> 
    <pre class="code-area">import sqlite3

with sqlite3.connect(data_path) as connection:
    cursor = connection.cursor()
    cursor.execute(query)</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p92"> 
   <p>After execution, we can get a list of result rows by calling <code>cursor.fetchall()</code>. We’ll put everything together in a function that takes two parameters—the path to the database and a query to execute on it—as input, returning the query result in a string representation:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p93"> 
   <div class="code-area-container"> 
    <pre class="code-area">def process_query(data_path, query):
    with sqlite3.connect(data_path) as connection:  #1
        cursor = connection.cursor()           #2
        cursor.execute(query)    #3
        table_rows = cursor.fetchall()  #4
         #5
        table_strings = [str(r) for r in table_rows]
        return '\n'.join(table_strings)          #6</pre> 
    <div class="code-annotations-overlay-container">
     #1 Connects to the database
     <br/>#2 Creates the cursor
     <br/>#3 Executes a query
     <br/>#4 Retrieves the query result
     <br/>#5 Transforms to a list of strings
     <br/>#6 Concatenates result rows
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p94"> 
   <p>After connecting to the target database (<strong class="cueball">1</strong>), the function creates a cursor (<strong class="cueball">2</strong>), executes the input query (<strong class="cueball">3</strong>), and retrieves the query result (<strong class="cueball">4</strong>). After casting the result tuples into a string representation (<strong class="cueball">5</strong>), we concatenate the result rows, separated by newline symbols (<strong class="cueball">6</strong>).</p> 
  </div> 
  <div class="readable-text" id="p95"> 
   <h3 class=" readable-text-h3" id="extracting-the-database-structure"><span class="num-string browsable-reference-id">5.3.2</span> Extracting the database structure</h3> 
  </div> 
  <div class="readable-text" id="p96"> 
   <p>We want an interface that works for arbitrary SQLite databases without having to change the code. This means we need to extract the structure of the current database (information about its tables and columns) automatically.</p> 
  </div> 
  <div class="readable-text" id="p97"> 
   <p>For SQLite, we can extract the structure of a database by executing SQL queries. These queries access a special table: the <em>schema table</em>. This table is created automatically (i.e., we do not need to create it by hand). Among other things, this table contains the SQL commands used to create other tables in a database. We can use them as a concise description of the database structure, suitable as input to the language model.</p> 
  </div> 
  <div class="readable-text" id="p98"> 
   <p>We can access the schema table via the table name <code>sqlite_master</code>. This table contains a column named <code>sql</code> with information about queries used to create objects inside the database. Specifically, we are interested in SQL commands used to create tables. Those queries contain crucial information for query translation, including the names and types of the columns that belong to the table created by the query. The following query retrieves all SQL statements used to create tables in the current database:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p99"> 
   <div class="code-area-container"> 
    <pre class="code-area">select sql from sqlite_master where type = 'table';</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p100"> 
   <p>So all we need to do is execute this query from Python. Fortunately, we already know how to do that from the previous section. Given the path to a database, the following function returns a text describing the queries used to create all the tables in the database:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p101"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import sqlite3

def get_structure(data_path):
    with sqlite3.connect(data_path) as connection:  #1
        cursor = connection.cursor()          #2
        cursor.execute("select sql from sqlite_master where type =
        <span class="">↪</span> 'table';")             #3
        table_rows = cursor.fetchall()      #4
        table_ddls = [r[0] for r in table_rows]  #5
        return '\n'.join(table_ddls)        #6</pre> 
    <div class="code-annotations-overlay-container">
     #1 Connects to the database
     <br/>#2 Creates a cursor
     <br/>#3 Accesses schema table
     <br/>#4 Retrieves results
     <br/>#5 Retrieves SQL strings
     <br/>#6 Concatenates SQL strings
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p102"> 
   <p>Again, we create a connection (<strong class="cueball">1</strong>) and a corresponding cursor object (<strong class="cueball">2</strong>). Next, we issue a query to the schema table to retrieve all SQL queries used to create tables in the current database (<strong class="cueball">3</strong>). We fetch the results (<strong class="cueball">4</strong>) and extract the SQL strings from the query result (<strong class="cueball">5</strong>). Note that this part of the function differs slightly from the generic function for executing queries, discussed in the previous section. By extracting the values for the first (and, for this specific query, only) field of each row, we get rid of unnecessary delimiters between rows that would otherwise show up in our output (and, later, in our prompts). The result is the concatenation of all the result rows (<strong class="cueball">6</strong>).</p> 
  </div> 
  <div class="readable-text" id="p103"> 
   <h3 class=" readable-text-h3" id="complete-code-1"><span class="num-string browsable-reference-id">5.3.3</span> Complete code</h3> 
  </div> 
  <div class="readable-text" id="p104"> 
   <p>Listing <a href="#code__nlqi">5.2</a> shows the complete code for our generic natural language query interface (you can download it from the book’s companion website as listing 2 in the chapter 5 section). The code uses the function for extracting the database structure (<strong class="cueball">1</strong>), discussed earlier. The function for generating prompts (<strong class="cueball">2</strong>) is a slight variant of the one used for our previous database-specific query interface. Instead of a hardcoded description of the database structure, it takes a description of the database as input and inserts it into the prompt. The function for invoking the language model (<strong class="cueball">3</strong>) has not changed compared to the prior interface version. The function <code>process_query</code> (<strong class="cueball">4</strong>) was discussed in section <a href="#sub__ExecutingQueries">5.3.1</a>.</p> 
  </div> 
  <div class="browsable-container listing-container" id="p105"> 
   <h5 class=" listing-container-h5 browsable-container-h5" id="code__nlqi"><span class="num-string">Listing <span class="browsable-reference-id">5.2</span></span> Generic text-to-SQL query interface</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">import argparse
import openai
import re
import sqlite3
import time

client = openai.OpenAI()

def get_structure(data_path):               #1
    """ Extract structure from SQLite database.
    
    Args:
        data_path: path to SQLite data file.
    
    Returns:
        text description of database structure.
    """
    with sqlite3.connect(data_path) as connection:
        cursor = connection.cursor()
        cursor.execute("select sql from sqlite_master where type = 'table';")
        table_rows = cursor.fetchall()
        table_ddls = [r[0] for r in table_rows]
        return '\n'.join(table_ddls)

def create_prompt(description, question):     #2
    """ Generate prompt to translate a question into an SQL query.
    
    Args:
        description: text description of database structure.
        question: question about data in natural language.
    
    Returns:
        prompt for question translation.
    """
    parts = []
    parts += ['Database:']
    parts += [description]
    parts += ['Translate this question into SQL query:']
    parts += [question]
    return '\n'.join(parts)

def call_llm(prompt):                             #3
    """ Query large language model and return answer.
    
    Args:
        prompt: input prompt for language model.
    
    Returns:
        Answer by language model.
    """
    for nr_retries in range(1, 4):
        try:
            response = client.chat.completions.create(
                model='gpt-4o',
                messages=[
                    {'role':'user', 'content':prompt}
                    ]
                )
            return response.choices[0].message.content
        except:
            time.sleep(nr_retries * 2)
    raise Exception('Cannot query OpenAI model!')

def process_query(data_path, query):        #4
    """ Processes SQL query and returns result.
    
    Args:
        data_path: path to SQLite data file.
        query: process this query on database.
    
    Returns:
        query result.
    """
    with sqlite3.connect(data_path) as connection:
        cursor = connection.cursor()
        cursor.execute(query)
        table_rows = cursor.fetchall()
        table_strings = [str(r) for r in table_rows]
        return '\n'.join(table_strings)

if __name__ == '__main__':
    
    parser = argparse.ArgumentParser()
    parser.add_argument('dbpath', type=str, help='Path to SQLite data')
    args = parser.parse_args()

    data_structure = get_structure(args.dbpath)  #5
    
    while True:           #6
        user_input = input('Enter question:')
        if user_input == 'quit':
            break
        
        prompt = create_prompt(data_structure, user_input)
        answer = call_llm(prompt)
        query = re.findall('```sql(.*)```', answer, re.DOTALL)[0]
        print(f'SQL: {query}')

        try:                               #7
            result = process_query(args.dbpath, query)
            print(f'Result: {result}')
        except:
            print('Error processing query! Try to reformulate.')</pre> 
    <div class="code-annotations-overlay-container">
     #1 Extracts the database structure
     <br/>#2 Creates a prompt for translation
     <br/>#3 Invokes the language model
     <br/>#4 Processes a query on a database
     <br/>#5 Reads data structure
     <br/>#6 Answers questions until the user quits
     <br/>#7 Processes the query on the database
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p106"> 
   <p>After reading the command-line arguments, the natural language query interface extracts the structure of the database (<strong class="cueball">5</strong>). Next, we loop (<strong class="cueball">6</strong>) until the user terminates the interface. In each iteration, we first read input from the keyboard (leaving the loop if the user enters <code>quit</code>) and then create a prompt and invoke the language model.</p> 
  </div> 
  <div class="readable-text" id="p107"> 
   <p>After translating the input question to a query, we execute that query directly (<strong class="cueball">7</strong>). Of course, the translation may be incorrect and result in a query that does not execute on the target database. In that case, SQLite may throw an error, and we must ensure that our program does not terminate. This is why we surround the call to the query-processing function with a try-catch block.</p> 
  </div> 
  <div class="readable-text" id="p108"> 
   <h3 class=" readable-text-h3" id="trying-it-out-1"><span class="num-string browsable-reference-id">5.3.4</span> Trying it out</h3> 
  </div> 
  <div class="readable-text" id="p109"> 
   <p>Time to try our natural language query interface! Our interface now works for arbitrary databases. But we don’t have another database, so we’ll use it again on the games database. In the terminal, switch to the directory containing the games.db file, and run the following command (let’s assume the code is stored in a file named listing3.py):</p> 
  </div> 
  <div class="browsable-container listing-container" id="p110"> 
   <div class="code-area-container"> 
    <pre class="code-area">python listing3.py games.db</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p111"> 
   <p>The command will open an input box in which we can enter questions about the data. Following is an example of interaction with the natural language query interface:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p112"> 
   <div class="code-area-container"> 
    <pre class="code-area">Enter question:How many games are stored in total?
SQL: SELECT COUNT(*) FROM games;
Answer: (16599,)
Enter question:How many games did Activision create?
SQL: SELECT COUNT(*) FROM games WHERE publisher = 'Activision'
Answer: (975,)
Enter question:Name one game that was released in 2017!
SQL: SELECT name
FROM games
WHERE year = 2017
LIMIT 1
Answer: ('Phantasy Star Online 2 Episode 4: Deluxe Package',)
Enter question:How many games were released for each genre?
SQL: SELECT genre, COUNT(*) as num_games
FROM games
GROUP BY genre
Answer: ('Action', 3316)
('Adventure', 1286)
('Fighting', 848)
('Genre', 1)
('Misc', 1739)
('Platform', 886)
('Puzzle', 582)
('Racing', 1249)
('Role-Playing', 1488)
('Shooter', 1310)
('Simulation', 867)
('Sports', 2346)
('Strategy', 681)
Enter question:Which three games sold more copies in Japan than in Europe?
SQL: SELECT name
FROM games
WHERE japansales &gt; eusales
ORDER BY japansales DESC
LIMIT 3;
Answer: ('Name',)
('Pokemon Red/Pokemon Blue',)
('Pokemon Gold/Pokemon Silver',)
Enter question:Break down game sales in America by the platform!
SQL: SELECT platform, sum(americasales) AS total_sales
FROM games
GROUP BY platform
Answer: ('2600', 90.59999999999992)
('3DO', 0)
('3DS', 78.86999999999996)
('DC', 5.43)
('DS', 390.7099999999977)
('GB', 114.32000000000001)
('GBA', 187.54000000000033)
('GC', 133.46000000000004)
('GEN', 19.27)
('GG', 0)
('N64', 139.02000000000015)
('NES', 125.94000000000005)
('NG', 0)
('PC', 93.2800000000005)
('PCFX', 0)
('PS', 336.509999999998)
('PS2', 583.8399999999925)
('PS3', 392.2599999999998)
('PS4', 96.79999999999998)
('PSP', 108.98999999999975)
('PSV', 16.200000000000006)
('Platform', 0.0)
('SAT', 0.7200000000000001)
('SCD', 1)
('SNES', 61.22999999999998)
('TG16', 0)
('WS', 0)
('Wii', 507.7099999999991)
('WiiU', 38.31999999999999)
('X360', 601.0499999999992)
('XB', 186.6900000000008)
('XOne', 83.19000000000003)
Enter question:quit</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p113"> 
   <p>As you see, we can ask a wide range of questions and obtain reasonable answers. Besides the answer, the system also prints out the query. Knowing a little about SQL enables us to verify whether the query accurately translates the question.</p> 
  </div> 
  <div class="readable-text" id="p114"> 
   <h2 class=" readable-text-h2" id="a-natural-language-query-interface-for-graph-data"><span class="num-string browsable-reference-id">5.4</span> A natural language query interface for graph data</h2> 
  </div> 
  <div class="readable-text" id="p115"> 
   <p>Word spreads at Banana about your text-to-SQL interface, and multiple colleagues use it to analyze their tabular data sets. A new colleague of yours is working with large graphs, modeling connections between colleagues in Banana’s internal social network. This data is represented not as a table but as a graph, a data format particularly suitable for modeling connections between entities (in this case, people). The colleague reaches out to ask whether it would be possible to expand your interface to query such data too. Knowing that language models should, in principle, be able to handle a variety of formal query languages, you are optimistic and agree to look into it.</p> 
  </div> 
  <div class="readable-text" id="p116"> 
   <h3 class=" readable-text-h3" id="what-is-graph-data"><span class="num-string browsable-reference-id">5.4.1</span> What is graph data?</h3> 
  </div> 
  <div class="readable-text" id="p117"> 
   <p>Like relational data, graphs are a particularly popular type of structured data. A graph generally consists of a collection of nodes connected by edges. Nodes can be associated with properties, and edges are labeled. For instance, social networks are often represented as graphs. Here, nodes represent people, and edges represent friendships and relationships. Graphs are also a natural representation of road or subway networks. In this case, nodes represent cities or subway stations, whereas edges represent roads or rails connecting them.</p> 
  </div> 
  <div class="readable-text" id="p118"> 
   <p>Figure <a href="#fig__examplegraph">5.2</a> shows an example graph representing a subway network. It represents stations of the New York City subway as nodes (hence, nodes are labeled <code>Station</code>). Edges represent direct connections and are labeled with the associated subway line. Nodes are associated with a <code>name</code> property, assigning nodes to the name of the corresponding station.</p> 
  </div> 
  <div class="browsable-container figure-container" id="p119">  
   <img alt="figure" src="../Images/CH05_F02_Trummer.png" width="476" height="523"/> 
   <h5 class=" figure-container-h5" id="fig__examplegraph"><span class="num-string">Figure <span class="browsable-reference-id">5.2</span></span> An example graph representing a small part of the subway network in New York City. Nodes, drawn as circles, represent subway stations and are associated with a property, assigning them to the name of the represented subway station. Edges, drawn as arrows, represent direct connections via specific subway lines. Edges are labeled by the subway line connecting the stations.</h5>
  </div> 
  <div class="readable-text" id="p120"> 
   <p>The fact that graphs can be used to model various types of data has motivated a variety of specialized systems called <em>graph database systems</em> for graph data processing. These systems support graph-specific query languages (not SQL), enabling users to formulate complex questions about the underlying data. Graph database systems are optimized for processing large graphs efficiently.</p> 
  </div> 
  <div class="readable-text" id="p121"> 
   <p>Next, we will use language models to translate questions in natural language into queries formulated in the graph database management system. We will see that this scenario requires only small modifications compared to our approach for translating questions into SQL queries.</p> 
  </div> 
  <div class="readable-text" id="p122"> 
   <h3 class=" readable-text-h3" id="setting-up-a-neo4j-database"><span class="num-string browsable-reference-id">5.4.2</span> Setting up a Neo4j database</h3> 
  </div> 
  <div class="readable-text" id="p123"> 
   <p>We will use the Neo4j system, a database system specialized for graph data. You don’t even have to install anything on your local machine. Neo4j comes with an online demo that we will use next.</p> 
  </div> 
  <div class="readable-text" id="p124"> 
   <p>First, go to <a href="https://neo4j.com/sandbox/">https://neo4j.com/sandbox/</a> in your web browser. Click the Launch the Free Sandbox button. This should open a login form, in which you can decide to create a new account or use existing accounts (e.g., a Google account). Figure <a href="#fig__movies">5.3</a> shows the screen you should see next.</p> 
  </div> 
  <div class="browsable-container figure-container" id="p125">  
   <img alt="figure" src="../Images/CH05_F03_Trummer.png" width="1100" height="847"/> 
   <h5 class=" figure-container-h5" id="fig__movies"><span class="num-string">Figure <span class="browsable-reference-id">5.3</span></span> Select the movies database, and click Create to create a corresponding instance.</h5>
  </div> 
  <div class="readable-text" id="p126"> 
   <p>Here, we can select one of several example databases to try Neo4j. We will be using the <code>Movies</code> database. This database contains information about movies and the actors who played in them (representing movies and actors as nodes). Click the <code>Movies</code> database and then the Create button to create an instance of the database and prepare it for querying. Creating the database may take a few minutes. Afterward, you can open the <code>Movies</code> database and access the query interface.</p> 
  </div> 
  <div class="readable-text" id="p127"> 
   <p>Figure <a href="#fig__neo4jinterface">5.4</a> shows the Neo4j query interface. Click the database icon in the upper-left corner to see an overview of the database. The database contains multiple types of labels (i.e., node types), including <code>People</code> and <code>Movies</code>. It also contains relationship types such as <code>ACTED_IN</code> and <code>DIRECTED</code>, labeling the edges in our graph. For instance, these two relationship types allow us to keep track of who played in which movie (<code>ACTED_IN</code>) and who directed which movie (<code>DIRECTED</code>). Properties are associated with nodes and assign keys to values. The database overview reports on property keys such as <code>name</code> (assigning an actor to a name) and <code>title</code> (assigning movies to titles). You can enter queries in the text box at the top of the screen and submit them by clicking the button to the right of the text box.</p> 
  </div> 
  <div class="browsable-container figure-container" id="p128">  
   <img alt="figure" src="../Images/CH05_F04_Trummer.png" width="1100" height="799"/> 
   <h5 class=" figure-container-h5" id="fig__neo4jinterface"><span class="num-string">Figure <span class="browsable-reference-id">5.4</span></span> Click the database icon (upper-left corner) to access information about the current graph database, including the types of nodes and edges. </h5>
  </div> 
  <div class="readable-text" id="p129"> 
   <h3 class=" readable-text-h3" id="the-cypher-query-language"><span class="num-string browsable-reference-id">5.4.3</span> The Cypher query language</h3> 
  </div> 
  <div class="readable-text" id="p130"> 
   <p>Neo4j supports the Cypher query language. Although a full introduction to Cypher is beyond the scope of this book (instead, have a look at the Neo4j documentation, available at <a href="https://neo4j.com/docs/cypher-manual/current/introduction/">https://neo4j.com/docs/cypher-manual/current/introduction/</a>), we will quickly go over the basics. The purpose of this introduction is to enable you to understand, at least in simple cases, the semantics of the queries generated by the language model.</p> 
  </div> 
  <div class="readable-text" id="p131"> 
   <p>A simple type of Cypher query uses a <code>MATCH</code> statement describing a subgraph to find. For instance, we may simply want to find all nodes of a certain type. The query for finding the names of all the people in our Movies database is the following:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p132"> 
   <div class="code-area-container"> 
    <pre class="code-area">MATCH (p:Person)  #1
RETURN p.name     #2</pre> 
    <div class="code-annotations-overlay-container">
     #1 Pattern to match
     <br/>#2 Result to return
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p133"> 
   <p>The <code>MATCH</code> statement describes a pattern to match (<strong class="cueball">1</strong>). In this case, that pattern consists of single nodes of type <code>Person</code>. The <code>MATCH</code> statement assigns nodes or edges that appear within the pattern to variables. In this case, we introduce the variable <code>p</code> and assign it to nodes matching the pattern. The <code>RETURN</code> statement (<strong class="cueball">2</strong>) describes the query result based on matched patterns. Here, we instruct the system to return the <code>name</code> property for each node matching the pattern.</p> 
  </div> 
  <div class="readable-text" id="p134"> 
   <p>Patterns can extend beyond a single node. For instance, we may want to find the titles of all movies starring the actor Tom Cruise. In this case, the pattern we are looking for consists not of a single node but rather of two connected nodes. We are searching for a node of type <code>Movie</code> connected via an edge of type <code>ACTED_IN</code> to a node of type <code>Person</code> whose <code>name</code> property is set to “Tom Cruise.” This can be accomplished by the following Cypher query:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p135"> 
   <div class="code-area-container"> 
    <pre class="code-area"> #1
MATCH (p:Person {name: 'Tom Cruise'})-[:ACTED_IN]-&gt;(m:Movie)
RETURN m.title                                       #2</pre> 
    <div class="code-annotations-overlay-container">
     #1 Matches movies starring Tom Cruise
     <br/>#2 Returns the movie title
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p136"> 
   <p>The expression <code>(p:Person </code><span><code>name: Tom Cruise</code></span><code>)</code> (<strong class="cueball">1</strong>) matches all nodes of type <code>Person</code> whose <code>name</code> property is set to “Tom Cruise.” The expression <code>(m:Movie)</code> matches all nodes of type <code>Movie</code>. Finally, we connect those two with the expression <code>-[:ACTED_IN]-&gt;</code>. This expression represents a directed connection (hence the arrow shape) between the first node (representing Tom Cruise) and the second node (representing an arbitrary movie). The type of the connection is restricted to <code>ACTED_IN</code> (excluding, for instance, movies directed by Tom Cruise in which he did not act). Finally, note that the <code>MATCH</code> expression assigns parts of this pattern to variables again. Tom Cruise will be represented by variable <code>p</code>, and the movies he played in will be represented by variable <code>m</code>. The <code>RETURN</code> expression (<strong class="cueball">2</strong>) retrieves the <code>title</code> property of the movie node.</p> 
  </div> 
  <div class="readable-text" id="p137"> 
   <p>Finally, let’s see how Neo4j can calculate aggregates (similar to SQL):</p> 
  </div> 
  <div class="browsable-container listing-container" id="p138"> 
   <div class="code-area-container"> 
    <pre class="code-area"> #1
MATCH (p:Person {name: 'Tom Cruise'})-[:ACTED_IN]-&gt;(m:Movie) 
RETURN count(*)                                 #2</pre> 
    <div class="code-annotations-overlay-container">
     #1 Matches movies starring Tom Cruise
     <br/>#2 Returns the number of movies
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p139"> 
   <p>This query is similar to the one before and simply counts the number of movies featuring Tom Cruise as an actor (<strong class="cueball">1</strong>). The <code>RETURN</code> statement (<strong class="cueball">2</strong>) contains a corresponding aggregate. If you enter the query, you should obtain “3” as the query result (so, clearly, the example database is incomplete).</p> 
  </div> 
  <div class="readable-text" id="p140"> 
   <h3 class=" readable-text-h3" id="translating-questions-to-cypher-queries"><span class="num-string browsable-reference-id">5.4.4</span> Translating questions to Cypher queries</h3> 
  </div> 
  <div class="readable-text" id="p141"> 
   <p>We will use a similar approach to the one we used for translating questions to SQL queries. Primarily, we need to change the prompt to our language model. Instead of instructing the language model to translate to SQL, we will instruct it to translate to Cypher. Fortunately, language models like GPT-4o have been pretrained with a large and diverse set of training data. As we will see in the remainder of this section, this pretraining data must have included Cypher queries as well, and that’s why we can use language models for translation. As always, there are no absolute guarantees, and Cypher queries generated by the language model may not accurately translate our questions. However, at least for simple queries, the translation is typically correct.</p> 
  </div> 
  <div class="readable-text" id="p142"> 
   <h3 class=" readable-text-h3" id="generating-prompts"><span class="num-string browsable-reference-id">5.4.5</span> Generating prompts</h3> 
  </div> 
  <div class="readable-text" id="p143"> 
   <p>To translate questions into Cypher queries, we need to include several pieces of information in the prompt. First, this includes the question we want to translate. Second, this must include a description of the database structure. In the case of SQL, the database structure is defined, for instance, by table and column names. In the case of a Neo4j database, we want to include information about node and edge types, as well as the names of the most relevant properties. This is essentially the information shown on the left side of figure <a href="#fig__neo4jinterface">5.4</a>.</p> 
  </div> 
  <div class="readable-text" id="p144"> 
   <p>To keep things simple, we’ll focus on the example database introduced previously, containing information about movies. This means we hardcode the database structure. Of course, similar to our text-to-SQL interface, it is possible to extend the interface to handle arbitrary graph databases.</p> 
  </div> 
  <div class="readable-text" id="p145"> 
   <p>We will use the following prompt template:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p146"> 
   <div class="code-area-container"> 
    <pre class="code-area">Neo4j Database:        #1
Node labels: Movie, Person
Relationship types: ACTED_IN, DIRECTED,
FOLLOWS, PRODUCED, REVIEWED, WROTE
Property keys: born, name, rating, released
roles, summary, tagline, title
[Question]                 #2
Cypher Query:              #3</pre> 
    <div class="code-annotations-overlay-container">
     #1 Database description
     <br/>#2 Question to translate
     <br/>#3 Specification of the target language
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p147"> 
   <p>This prompt template contains a description of the database (<strong class="cueball">1</strong>). This description includes a specification of the database type (a Neo4j database), as well as a list of node labels, relationship types, and properties. Note that we hardcode the database structure in this prompt template. If using the interface on a different database, this part of the prompt must be replaced. Next, the prompt template specifies the question to translate (<strong class="cueball">2</strong>). This is a placeholder, as we want to enable users to ask various questions about the data. The prompt ends with a specification of the target language for query translation (<strong class="cueball">3</strong>). This implicitly instructs the language model to translate the question to a Cypher query.</p> 
  </div> 
  <div class="readable-text" id="p148"> 
   <p>The following piece of code instantiates this prompt template for an input question:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p149"> 
   <div class="code-area-container"> 
    <pre class="code-area">def create_prompt(question):
    parts = []
    parts += ['Neo4j Database:']
    parts += ['Node labels: Movie, Person']
    parts += ['Relationship types: ACTED_IN, DIRECTED,']  
    parts += ['FOLLOWS, PRODUCED, REVIEWED, WROTE'] 
    parts += ['Property keys: born, name, rating, released']
    parts += ['roles, summary, tagline, title']
    parts += [question]
    parts += ['Cypher Query:']
    return '\n'.join(parts)</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p150"> 
   <h3 class=" readable-text-h3" id="complete-code-2"><span class="num-string browsable-reference-id">5.4.6</span> Complete code</h3> 
  </div> 
  <div class="readable-text" id="p151"> 
   <p>The following listing uses the function for generating prompts (<strong class="cueball">1</strong>), discussed previously, and reuses the function for calling GPT-4o (<strong class="cueball">2</strong>) (with repeated retries, if necessary).</p> 
  </div> 
  <div class="browsable-container listing-container" id="p152"> 
   <h5 class=" listing-container-h5 browsable-container-h5" id="code__neo4jnlqi"><span class="num-string">Listing <span class="browsable-reference-id">5.3</span></span> Translating text questions into Cypher queries for Neo4j</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">import argparse
import openai
import re
import time

client = openai.OpenAI()

def create_prompt(question):                 #1
    """ Generate prompt to translate a question into Cypher query.
    
    Args:
        question: question about data in natural language.
    
    Returns:
        prompt for question translation.
    """
    parts = []
    parts += ['Neo4j Database:']
    parts += ['Node labels: Movie, Person']
    parts += ['Relationship types: ACTED_IN, DIRECTED,']  
    parts += ['FOLLOWS, PRODUCED, REVIEWED, WROTE'] 
    parts += ['Property keys: born, name, rating, released']
    parts += ['roles, summary, tagline, title']
    parts += [question]
    parts += ['Cypher Query:']
    return '\n'.join(parts)

def call_llm(prompt):                             #2
    """ Query large language model and return answer.
    
    Args:
        prompt: input prompt for language model.
    
    Returns:
        Answer by language model.
    """
    for nr_retries in range(1, 4):
        try:
            response = client.chat.completions.create(
                model='gpt-4o',
                messages=[
                    {'role':'user', 'content':prompt}
                    ]
                )
            return response.choices[0].message.content
        except:
            time.sleep(nr_retries * 2)
    raise Exception('Cannot query OpenAI model!')

if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('question', type=str, help='A question about movies')
    args = parser.parse_args()

    prompt = create_prompt(args.question)  #3
    answer = call_llm(prompt)         #4
    #5
    query = re.findall('```cypher(.*)```', answer, re.DOTALL)[0]
    
    print(f'Cyper Query: {query}')</pre> 
    <div class="code-annotations-overlay-container">
     #1 Generates prompts for translation
     <br/>#2 Calls the LLM
     <br/>#3 Creates a prompt
     <br/>#4 Generates an answer
     <br/>#5 Extracts Cypher queries
     <br/>
    </div> 
   </div> 
  </div> 
  <div class="readable-text" id="p153"> 
   <p>Given a question about the database as input, the code generates a corresponding prompt (<strong class="cueball">3</strong>), obtains an answer from the language model (<strong class="cueball">4</strong>), and finally extracts the Cypher query from that answer (<strong class="cueball">5</strong>). The regular expression used for extraction differs slightly because GPT includes Cypher queries using the pattern <code>‘‘‘cypher ... ‘‘‘</code>. We finally print out the extracted query.</p> 
  </div> 
  <div class="readable-text" id="p154"> 
   <h3 class=" readable-text-h3" id="trying-it-out-2"><span class="num-string browsable-reference-id">5.4.7</span> Trying it out</h3> 
  </div> 
  <div class="readable-text" id="p155"> 
   <p>You can find listing <a href="#code__neo4jnlqi">5.3</a> on the book’s companion website. Download it, and use it from the command line like so:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p156"> 
   <div class="code-area-container"> 
    <pre class="code-area">python listing3.py "How many movies are stored?"</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p157"> 
   <p>You should obtain a query such as the following as output:</p> 
  </div> 
  <div class="browsable-container listing-container" id="p158"> 
   <div class="code-area-container"> 
    <pre class="code-area">MATCH (m:Movie)
RETURN COUNT(m) AS numberOfMovies</pre>  
   </div> 
  </div> 
  <div class="readable-text" id="p159"> 
   <p>You can now enter this query into the Neo4j interface to get the corresponding result (which is 38). Try a few more queries to get a better sense of the capabilities of the language model. As you see, with just a few changes to the prompt template, we transformed our text-to-SQL interface into a text-to-Cypher interface that works well in most cases.</p> 
  </div> 
  <div class="readable-text" id="p160"> 
   <h2 class=" readable-text-h2" id="summary">Summary</h2> 
  </div> 
  <ul> 
   <li class="readable-text" id="p161">Structured data follows a standard format, making it easier to parse. Examples of structured data include tabular data and graphs.</li> 
   <li class="readable-text" id="p162">Structured data is often processed via specialized tools.</li> 
   <li class="readable-text" id="p163">Relational database management systems process tabular data and typically support SQL queries.</li> 
   <li class="readable-text" id="p164">Graph data management systems process data representing graphs.</li> 
   <li class="readable-text" id="p165">Language models translate natural language to many formal query languages.</li> 
   <li class="readable-text" id="p166">Besides a question, prompts for query translation specify the database structure.</li> 
   <li class="readable-text" id="p167">Copy your database before executing queries generated by language models.</li> 
   <li class="readable-text" id="p168">Do not blindly trust your language model to generate accurate queries.</li> 
  </ul>
 </div></div></body></html>