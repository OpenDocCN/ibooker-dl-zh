- en: Chapter 6\. Using Copilot to Document and Explain Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we all know that having good documentation with our code is essential.
    The documentation within the codebase makes it more understandable, reviewable,
    and maintainable in the long run. Documentation in the code is a crucial contributor
    to the overall quality of the code and the quality of the product built from the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: However, we also know that taking the time and effort to create good documentation
    can seem tedious and can feel like a much lower priority than the fun of making
    the code itself. So, continuing with the theme of how Copilot can help you beyond
    coding suggestions and answering questions, let’s look at how it can help automate
    this task.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at several aspects of using Copilot’s documentation
    capabilities, including generating documentation via the editor and chat interfaces.
    But we’ll also show you how to leverage Copilot to produce content for use cases
    you may not have considered, such as external documentation for APIs, functional
    documentation, and more.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also look at how to use Copilot to explain code. While this is an often
    overlooked feature of Copilot, it has tremendous potential for helping engineers
    at all levels understand code and algorithms. Some beneficial use cases include
    explaining code from an unfamiliar language or framework, checking the logic of
    your code with explanations, and leveraging Copilot to explain commands happening
    in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive in and get started by looking at how Copilot’s documentation capabilities
    can be leveraged throughout your development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers know they can use Copilot’s documentation capabilities to produce
    header documentation and comments in the body of their code. But the exact mechanisms
    to do this can be confusing. You can use shortcut functions, but these are limited
    in what they do. In the first part of this section, we’ll focus on how to most
    easily generate program documentation inline and through Copilot’s chat interface.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the basic *document my code* functionality, Copilot can be used for several
    broader documentation tasks. It can generate framework-specific documentation
    (such as for Swagger), developer-facing documentation for APIs, and even functional
    documentation. In the latter part of this section, we’ll cover those extended
    use cases where you can leverage more of the power of Copilot for different kinds
    of documentation. But let’s start with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Documentation Inline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a code listing for a function (written in Go) that creates a new Kubernetes
    service for a custom resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The most direct/shortest path to getting documentation generated for this function
    inline is to invoke the inline chat interface via the *Meta*-I key combination
    and use the shortcut command `/doc`, as shown in [Figure 6-1](#using-shortcut-doc-co).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Using the shortcut `/doc` command
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Copilot will then generate basic documentation for the function. This will
    likely consist of only comments above the function, as shown in the following
    listing and in [Figure 6-2](#generated-doc-results):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/lghc_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Generated doc results
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is useful as far as it goes—adding comments about the purpose, parameters,
    and return values of the function. What is missing is any additional comments
    or documentation in the *body* of the function. Even if we were to provide a more
    extensive command such as `add doc to my code`, Copilot will default to using
    the `/doc` command again, and we’ll get similar results. This is true currently
    regardless of which chat interface we use.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, when working directly in the editor, Copilot targets minimal, quick
    responses that don’t disrupt the flow of work and can be reviewed and accepted
    or discarded easily.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, if we want or need more substantial responses from Copilot, we can
    use the separate, dedicated chat interface. That also holds for generating documentation,
    as you’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Documentation Through Chat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we switch to the separate chat interface and give Copilot the same direction
    to add documentation to our code, we get a more extensive and detailed response
    ([Figure 6-4](#telling-copilot-to-ad)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. Telling Copilot to add documentation to the code from the main
    chat
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The complete listing, as generated with comments, is available in the [book’s
    GitHub repository](https://oreil.ly/zHnkm). A few excerpts are shared in the next
    listing. You can see that Copilot not only inserted substantially more header
    comments but also added multiple comments throughout the body of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take this a step further. Since Copilot Chat can understand natural language,
    we can submit a prompt to have documentation generated to help anyone reading
    the code. We can tell Copilot in chat to “verbosely comment the selected function
    so anyone can understand what it is doing.” The resulting change from the original
    (uncommented) function can be seen in the [GitHub repository](https://oreil.ly/jTDZV).
    Other than some wording changes, the main differences are some extra lines of
    comments for each main section that talks about how the pieces are used or managed.
    Also some comments are added at the end of lines where an identifier may need
    to be better understood. [Figure 6-5](#updated-lines-from-is) shows an excerpt
    from these changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. Updated lines from issuing a verbose comment command
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is an improvement. If we want even more, we can specifically target each
    line in the function body. Here’s a prompt we can use for that: “verbosely comment
    the function body so that anyone can easily understand what each line is doing.”'
  prefs: []
  type: TYPE_NORMAL
- en: With this prompt, we get a further verbose set of comments for the function
    body with more detailed comments for several of the elements. The full listing
    is available [online](https://oreil.ly/rZBRV), but [Figure 6-6](#more-verbose-comments)
    shows an excerpt of the differences.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6\. More verbose comments
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Comment Versus Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that we are telling Copilot to *comment* our code versus
    *document* it. Since documentation in code is done via comments, either of these
    terms can be used in this situation for prompts. Strictly speaking, when we ask
    Copilot for documentation, it may default to creating a block of comments only
    at the start of the method/function, as we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, you could combine the previous prompts into a single one to accomplish
    all the modifications. Here’s an example that seems to work well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One other nice aspect about Copilot’s documentation capabilities is that it
    can recognize when code has a documentation framework that can be used with it.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Framework-Compatible Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Different programming languages have their own documentation styles. For example,
    C# has XMLDoc, Python has pydoc, and JavaScript has JSDoc. If Copilot recognizes
    that the code is in a language that has a standard documentation tool associated
    with it, it will default to creating comments ready for that tool. This can be
    very useful for integration with the development environment and other tools and
    is often preferred to plain comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a Java class definition containing a single method that
    begins as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we tell Copilot to “document this class,” it will add an extensive set of
    comments. The full listing is available [online](https://oreil.ly/LCxOH), but
    a few excerpts are included next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The header comments above the class definition, and at its start, are generated
    in a form that is compatible with processing by the Javadoc tooling. The `/**`
    and `@param`, `@return`, and `@throw` parts are all formatting pieces that Javadoc
    would use to generate HTML documentation for the class. [Figure 6-7](#javadoc-generated-fro)
    shows an example of the generated Javadoc originating from the comments added
    by Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7\. Javadoc generated from Copilot comments
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Beyond generating documentation for the basic documentation frameworks, we
    can also use Copilot for another common need: documenting APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating Documentation for APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your project is set up for an API documentation framework like [Swagger](https://swagger.io),
    you can have Copilot generate the corresponding Swagger documentation for your
    APIs. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a simple application that manages a directory of employees
    for a company. The application is written in Java and already configured for Swagger.
    We can tell Copilot to generate print-ready Swagger documentation for the APIs,
    referencing a particular file, with the prompt “create print-ready Swagger documentation
    for the APIS in #file:EmployeeController.java.”'
  prefs: []
  type: TYPE_NORMAL
- en: print-ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used the term *print-ready* in the prompt to ensure that Copilot generates
    the actual documentation format instead of trying to regenerate the code comments.
    We could also use terms like *publish-ready* or *publishable*.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot’s response is shown in [Figure 6-8](#swagger-doc-from-code), and the
    full output is available in the book’s [GitHub repository](https://oreil.ly/Kj8Lj).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0608.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-8\. Swagger documentation from code
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A key for this to work (in addition to the `print-ready` descriptor) is being
    specific with the files that you point Copilot to via the `#file` selector (or
    multiple selectors if you need to reference more than one file). Simply pointing
    Copilot to the entire workspace with a similar prompt (such as “@workspace create
    Swagger documentation for the APIs”) will usually result in Copilot explaining
    *how to create* the Swagger documentation in your project versus dumping it out.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Functional Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copilot is also capable of creating functional documentation that is targeted
    toward external users. For an example, we can leverage the same API code that
    we used in the preceding section. In this case, our prompt might look something
    like this: “create functional documentation explaining the various public APIs
    in #file:Employee​Con⁠troller.java.”'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-9](#generated-functional) shows the start of the actual functional
    API doc generated from the prompt. Note that the output includes some prose style,
    in an easy-to-read format, but with the necessary details outlined for the API
    structure. It’s not shown here, but Copilot also outlined a set of steps first
    that it would follow for this, including *Identifying Public APIs*, *Method Signatures*,
    and *Endpoint Mapping*. The full output can be viewed in the book’s [GitHub repo](https://oreil.ly/lV7jV).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0609.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-9\. Generated functional documentation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In general, the same caveat applies for generating this kind of documentation
    as it did for generating API documentation in the previous section: indicate specific
    files for the prompt to act on as opposed to trying to ask Copilot to operate
    against the entire workspace. However, we can ask some general questions by using
    `@workspace` and get good summary documentation. For example, if we ask “@workspace
    what are the API’s parameters and what does it return?”, we get a useful summary.
    The full listing is available [online](https://oreil.ly/sXKOv), and an excerpt
    is also shown in [Figure 6-10](#querying-api-paramete).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0610.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-10\. Querying API parameters
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Extracting Summary Documentation from the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copilot can also be used to extract a high-level summary of the key documentation
    from certain types of projects. This can be extremely useful for quickly understanding
    the significant details of the codebase for a project. Referencing the Java Swagger
    project in the preceding section, we can gather key information from it with the
    prompt “@workspace extract the key documentation from the code.”
  prefs: []
  type: TYPE_NORMAL
- en: In our case, Copilot extracted data from the *pom.xml* file, the *README.md*
    file, and the relevant **.java* files. Copilot then provided key high-level details
    on the project’s structure, dependencies, Swagger configuration, and testing.
    [Figure 6-11](#key-documentation-ext) shows an excerpt, and the full listing can
    be seen [on GitHub](https://oreil.ly/wSmbs).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0611.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-11\. Key documentation extracted from code
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'That completes our survey of the various ways that Copilot can help you with
    producing documentation. Let’s move to a similar, but arguably more important,
    functionality that Copilot provides: explaining content.'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to providing documentation for what code does, Copilot is also
    able to provide explanations for content it works with and generates. This feature
    can be helpful in multiple use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code in a language new to you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding generated code and conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing code logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining what might go wrong in the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining what was done in the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining how to do something in the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll briefly dive into each one of these areas in this section. A couple of
    common points apply across all of these:'
  prefs: []
  type: TYPE_NORMAL
- en: The prompt is the key here. Getting the prompt correct for the situation and
    using it to state clearly what you want is the most important prerequisite to
    having Copilot explain something well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we will generally use *explain* as a key term in our prompt, it’s not
    always required. You can also ask *why, how*, or other types of questions as appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Code in a Language New to You
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you are a Python programmer, but you’ve just been given an assignment
    to implement a new project in Go. Copilot can assist you with creating the code
    as well as understanding the key points of working with Go. For example, you can
    give Copilot a prompt like “I’m a Python programmer. What are the most significant
    things I need to understand about how to write Go code?”
  prefs: []
  type: TYPE_NORMAL
- en: 'When asked this question while I was writing this chapter, Copilot responded
    with information about the following 12 areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Static typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages and imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, Copilot also showed brief code snippets to illustrate the points
    and finished the explanation with “Understanding these key differences will help
    you transition from Python to Go more smoothly.” You can see the entire output
    from the chat [on GitHub](https://oreil.ly/roJZB).
  prefs: []
  type: TYPE_NORMAL
- en: You can also select specific parts of your code and have Copilot explain how
    they work with the `/explain` shortcut command. You can even tell Copilot to translate
    existing code into the new language. As always, though, you should verify that
    any suggestion or response that Copilot provides is accurate and appropriate for
    your situation.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot is helpful not only in understanding the basics of a new language but
    also in highlighting conventions that the language uses and the purpose of automatically
    generated code in that language.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Generated Code and Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you are new to Kubernetes and Go and need to create a Kubernetes operator
    to manage custom resources. You would probably use the [Operator SDK](https://oreil.ly/Lfz8O)
    to generate the starting structure for your project in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SDK automatically generates utility files, including ones with cryptic
    names like *zz_generated.deepcopy.go*. One of the first things you might want
    to know is what this generated file is used for. To get the answer, you can simply
    ask Copilot, “What is the code in #file:api/v1alpha1/zz_generated.deepcopy used
    for?” Copilot’s response (excerpted in [Figure 6-12](#copilot-explaining-wh))
    provides an introduction and then a breakdown of its purpose. The entire response
    can be found [on GitHub](https://oreil.ly/I0-3j).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0612.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-12\. Copilot explaining what code is used for
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In these kinds of responses, Copilot will usually provide a summary at the end
    of the output that can be helpful to quickly get the gist of the response. In
    this case, Copilot notes, “In summary, zz_generated.deepcopy.go is an auto-generated
    file that provides necessary deep copy functions for custom resource types in
    Kubernetes, ensuring proper handling and manipulation of these resources.”
  prefs: []
  type: TYPE_NORMAL
- en: You might also wonder why the code is named the way it is. We can ask Copilot
    about the naming convention with a prompt like “Why is this file named starting
    with zz_?” Copilot provides a helpful, conversational answer with a list of reasons
    for the convention, as shown in [Figure 6-13](#copilot-explanation-f).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0613.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-13\. Copilot explanation for the zz_ naming convention
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to understanding the general conventions and main themes of a language,
    Copilot can help explain the overall logic of a set of code.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Logic Used in a Section of Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Summarizing code logic more generally can be helpful in various use cases,
    including these:'
  prefs: []
  type: TYPE_NORMAL
- en: Quickly getting a handle on code you’ve inherited or must maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about code written in a language or framework that’s new to you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking your understanding from reviewing the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having another explanation of how the code works for code reviews, pull requests,
    etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to have Copilot outline the general logic and related pieces, such
    as the main components used, in a non-language-specific way. We want Copilot’s
    explanation to be in a conversational tone, as if we were interacting with another
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual prompt you use for this can vary, but here’s an example for the
    same controller file that we’ve been referencing: “@workspace: summarize the logic
    in #file:controllers/roarapp_controller.go.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'From this prompt, Copilot provides output that starts with an overall explanation
    of what the code is intended to do: “reconciling the state of ... custom resources
    in a Kubernetes cluster.”'
  prefs: []
  type: TYPE_NORMAL
- en: Copilot then provides a summary of the key components in the file and what each
    does. These include the data structures, annotations, and functions. An excerpt
    from this output is shown in [Figure 6-14](#copilot-summarizing-t), and the complete
    output can be seen [on GitHub](https://oreil.ly/5oG3v).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0614.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-14\. Copilot summarizing the logic used in a file
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another good prompt to consider is simply swapping the keyword *workflow* for
    *logic*, as in “@workspace: summarize the workflow in #file:controllers/roarapp_controller.go.”
    This should yield a slightly simpler response but with similar information on
    the various components.'
  prefs: []
  type: TYPE_NORMAL
- en: One other interesting way to learn about, and understand, the code flips the
    traditional *explain* use case. Instead of asking Copilot to explain how or what
    code does, we can ask it about potential problems with the code.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining What Might Go Wrong with a Set of Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another approach when having Copilot explain code is to have it identify any
    potential problems with the code. This can be used for code you’ve written, are
    investigating, or have inherited, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the Kubernetes custom resource example that we’ve been using
    in this chapter, we can choose to ask Copilot what could go wrong with the code
    that implements the custom controller in the editor. The prompt we use for this
    is “@workspace: explain what might go wrong with the code in #file:controllers/roarapp_​controller.go.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using @workspace and #file'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, we can use variables like `#selection` or `#file` in the prompt string
    to focus Copilot on the context we want it to consider for its response. But in
    some cases, we may also need to use the `@workspace` identifier to ensure that
    Copilot looks at related pieces and takes into account the full picture of what
    else might affect this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copilot, in turn, provides a detailed answer listing out several areas to look
    at that include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requeue logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource cleanup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full output for this can be seen in the [GitHub repo file](https://oreil.ly/v7I75).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at different ways Copilot can explain what’s happening
    in code, let’s finish up by looking at how Copilot can help explain things in
    the context of another domain—the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Items from the Terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copilot is able to access the terminal to explain details about the last command
    via the `#terminalLastCommand` keyword. For example, assume we ran the `ps` command
    as shown here as our most recent command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted more details on what this command was doing, we could query Copilot
    with a prompt like “explain #terminalLastCommand.” As you can see in [Figure 6-15](#copilot-explaining-th),
    Copilot identifies the last command and provides an explanation of the command,
    its options, and its output.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0615.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-15\. Copilot explaining the last terminal command
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The full output can be seen [in GitHub](https://oreil.ly/yCMOO).
  prefs: []
  type: TYPE_NORMAL
- en: 'Copilot can also explain selected content from the terminal. For example, if
    we ran a `git status` command previously, we can highlight that and ask Copilot
    to explain it with the prompt “explain the commands in #terminalSelection.” Copilot
    will then provide info on that, as shown in [Figure 6-16](#explaining-a-command).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0616.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-16\. Explaining a command selected in the terminal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You don’t have to select a command to explain. You can also select any text
    displayed in the terminal, such as the output of a command. Suppose we select
    the text “Your branch is up to date with ‘origin/main’.” in the output of the
    `git status` command. Since the identifier already references any content selected
    in the terminal, we can shorten our prompt to “explain #terminalSelection.”'
  prefs: []
  type: TYPE_NORMAL
- en: Copilot will then explain the meaning of that selected phrase. [Figure 6-17](#explaining-git-status)
    shows an excerpt from the output for this prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0617.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-17\. Explaining the `git status` command as selected in terminal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also have Copilot explain *how* to do something via the terminal. That’s
    the subject of our last section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining How to Do Something in the Terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copilot can supply the process and commands to do operations in the terminal.
    As an example, we can ask Copilot how to create a new branch in our GitHub repository.
    We can utilize the `@terminal` context and prompt Copilot with: “@terminal How
    do I create a new branch for my GitHub repository?”'
  prefs: []
  type: TYPE_NORMAL
- en: In response, Copilot provides the usual conversational process description along
    with the actual commands that you can run in the terminal. [Figure 6-18](#explaining-how-to-cre)
    shows an excerpt from the output, which you can see in full on [GitHub](https://oreil.ly/0t1il).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0618.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-18\. Explaining how to create a new branch via the terminal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similar Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also achieve a similar result with a prompt that references *command
    line*, as in “How can I create a new branch in my GitHub repository using the
    command line?”
  prefs: []
  type: TYPE_NORMAL
- en: The same technique is applicable when you may not know the command to use. For
    example, if we give Copilot the query “@terminal how do I see the list of running
    processes?”, it responds with multiple approaches that can be used from the terminal,
    as shown in [Figure 6-19](#how-to-see-running-pr).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0619.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-19\. How to see running processes via the terminal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ve explored how Copilot can help you with documentation
    and explanations. At the basic level, Copilot can document your source code by
    inserting comments throughout. A shortcut `/doc` command typically provides header
    documentation. You can tell Copilot to produce more extensive comments via prompts
    that include specific directions, such as “verbosely comment.” This illustrates
    a useful working tip for Copilot: if you aren’t getting what you expect or need,
    try using a more verbose, detailed prompt. You can reject the suggested changes
    if they are not what you wanted and continue to iterate on your prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond just the basic commenting, Copilot can also generate more extensive documentation
    for particular use cases. For example, it can generate API documentation and functional
    documentation suitable (after review) for sharing with others. This can provide
    a significant time savings over having to create this type of documentation in
    a less automated way.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to its documentation capability, Copilot also can explain many aspects
    of a codebase. This functionality can be used to explain general concepts and
    principles needed to use a new language or framework and also provide explanations
    for conventions that you may not be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: But, most significantly, Copilot can explain and summarize how the logic and
    processing for a set of code works. This can be especially useful if you are trying
    to learn, or have to maintain, code that you are not familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: A less common use for the explain functionality can be to explain what might
    go wrong with a set of code. This is an easy way to have Copilot essentially *review*
    the code and look for potential gaps and problems. This can be very useful if
    you are trying to assess weaknesses in the code and make sure vulnerable sections
    are addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at the ability to use Copilot’s explain functionality with
    a terminal. This falls into two categories. The first is selecting some output
    or referencing the last terminal command with a special identifier and having
    Copilot explain the meaning. The second involves asking Copilot how to do something
    in the terminal and having it provide a conversational explanation along with
    the exact commands to run in the terminal to accomplish the task.
  prefs: []
  type: TYPE_NORMAL
- en: While we have seen how valuable and extensive Copilot’s capabilities can be,
    it’s important to remember that it can be inaccurate and provide out-of-date information
    as results. This happens because Copilot’s knowledge base is only as up-to-date
    as the recency of the data that was used to train the underlying models it leverages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at how to deal with Copilot basing suggestions
    and responses on out-of-date information and how to work around those situations.
  prefs: []
  type: TYPE_NORMAL
