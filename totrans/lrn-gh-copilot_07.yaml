- en: Chapter 6\. Using Copilot to Document and Explain Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章：使用Copilot文档和解释代码
- en: As developers, we all know that having good documentation with our code is essential.
    The documentation within the codebase makes it more understandable, reviewable,
    and maintainable in the long run. Documentation in the code is a crucial contributor
    to the overall quality of the code and the quality of the product built from the
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们都知道，拥有良好的代码文档对于我们的代码至关重要。代码库中的文档使得代码在长期内更容易理解、审查和维护。代码中的文档是代码整体质量以及由代码构建的产品质量的关键贡献者。
- en: However, we also know that taking the time and effort to create good documentation
    can seem tedious and can feel like a much lower priority than the fun of making
    the code itself. So, continuing with the theme of how Copilot can help you beyond
    coding suggestions and answering questions, let’s look at how it can help automate
    this task.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也知道，花费时间和精力来创建良好的文档可能会显得繁琐，并且可能感觉比编写代码本身更有优先级。因此，继续探讨Copilot如何在你需要编码建议和回答问题的主题之外提供帮助，让我们看看它如何帮助自动化这项任务。
- en: In this chapter, we’ll look at several aspects of using Copilot’s documentation
    capabilities, including generating documentation via the editor and chat interfaces.
    But we’ll also show you how to leverage Copilot to produce content for use cases
    you may not have considered, such as external documentation for APIs, functional
    documentation, and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用Copilot文档功能的一些方面，包括通过编辑器和聊天界面生成文档。但我们还将向您展示如何利用Copilot为可能未考虑过的用例生成内容，例如API的外部文档、功能文档等。
- en: We’ll also look at how to use Copilot to explain code. While this is an often
    overlooked feature of Copilot, it has tremendous potential for helping engineers
    at all levels understand code and algorithms. Some beneficial use cases include
    explaining code from an unfamiliar language or framework, checking the logic of
    your code with explanations, and leveraging Copilot to explain commands happening
    in the terminal.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如何使用Copilot解释代码。虽然这是Copilot经常被忽视的功能，但它对于帮助所有级别的工程师理解代码和算法具有巨大的潜力。一些有益的用例包括解释来自不熟悉语言或框架的代码、通过解释检查代码的逻辑，以及利用Copilot解释终端中发生的命令。
- en: Let’s dive in and get started by looking at how Copilot’s documentation capabilities
    can be leveraged throughout your development cycle.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨并开始了解如何在整个开发周期中利用Copilot的文档功能。
- en: Documenting Content
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录内容
- en: Many developers know they can use Copilot’s documentation capabilities to produce
    header documentation and comments in the body of their code. But the exact mechanisms
    to do this can be confusing. You can use shortcut functions, but these are limited
    in what they do. In the first part of this section, we’ll focus on how to most
    easily generate program documentation inline and through Copilot’s chat interface.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者知道他们可以使用Copilot的文档功能来生成代码中的头部文档和注释。但实现这一点的确切机制可能会令人困惑。你可以使用快捷函数，但这些功能有限。在本节的第一个部分，我们将重点介绍如何最简单地通过Copilot的聊天界面生成程序文档。
- en: Beyond the basic *document my code* functionality, Copilot can be used for several
    broader documentation tasks. It can generate framework-specific documentation
    (such as for Swagger), developer-facing documentation for APIs, and even functional
    documentation. In the latter part of this section, we’ll cover those extended
    use cases where you can leverage more of the power of Copilot for different kinds
    of documentation. But let’s start with the basics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的“文档化我的代码”功能之外，Copilot还可以用于多种更广泛的文档任务。它可以生成特定框架的文档（如Swagger），面向开发者的API文档，甚至功能文档。在本节的下半部分，我们将介绍那些可以让你利用Copilot的更多功能进行不同类型文档的扩展用例。但让我们从基础开始。
- en: Generating Documentation Inline
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在行内生成文档
- en: 'Here’s a code listing for a function (written in Go) that creates a new Kubernetes
    service for a custom resource:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个函数的代码示例（用Go语言编写），该函数为自定义资源创建一个新的Kubernetes服务：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The most direct/shortest path to getting documentation generated for this function
    inline is to invoke the inline chat interface via the *Meta*-I key combination
    and use the shortcut command `/doc`, as shown in [Figure 6-1](#using-shortcut-doc-co).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为此函数生成行内文档的最直接/最短路径是通过*Meta*-I键组合调用行内聊天界面，并使用快捷命令`/doc`，如图6-1所示。
- en: '![](assets/lghc_0601.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0601.png)'
- en: Figure 6-1\. Using the shortcut `/doc` command
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1：使用快捷键`/doc`命令
- en: 'Copilot will then generate basic documentation for the function. This will
    likely consist of only comments above the function, as shown in the following
    listing and in [Figure 6-2](#generated-doc-results):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Copilot 将为该函数生成基本的文档。这很可能只包括函数上方的注释，如以下列表和 [图 6-2](#generated-doc-results)
    中所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](assets/lghc_0602.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0602.png)'
- en: Figure 6-2\. Generated doc results
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 生成的文档结果
- en: This is useful as far as it goes—adding comments about the purpose, parameters,
    and return values of the function. What is missing is any additional comments
    or documentation in the *body* of the function. Even if we were to provide a more
    extensive command such as `add doc to my code`, Copilot will default to using
    the `/doc` command again, and we’ll get similar results. This is true currently
    regardless of which chat interface we use.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这在它所达到的范围内是有用的——添加了关于函数目的、参数和返回值的注释。所缺少的是函数 *主体* 中的任何附加注释或文档。即使我们提供了更广泛的命令，如
    `add doc to my code`，Copilot 也会默认使用 `/doc` 命令，我们将会得到类似的结果。目前，这适用于我们使用的任何聊天界面。
- en: Recall that, when working directly in the editor, Copilot targets minimal, quick
    responses that don’t disrupt the flow of work and can be reviewed and accepted
    or discarded easily.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当直接在编辑器中工作时，Copilot 旨在提供最小化、快速的回应，这些回应不会打断工作流程，并且可以轻松地审查、接受或丢弃。
- en: Typically, if we want or need more substantial responses from Copilot, we can
    use the separate, dedicated chat interface. That also holds for generating documentation,
    as you’ll see in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果我们希望或需要从 Copilot 获得更实质性的回应，我们可以使用独立的、专门的聊天界面。这同样适用于生成文档，正如你将在下一节中看到的。
- en: Generating Documentation Through Chat
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过聊天生成文档
- en: If we switch to the separate chat interface and give Copilot the same direction
    to add documentation to our code, we get a more extensive and detailed response
    ([Figure 6-4](#telling-copilot-to-ad)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到独立的聊天界面，并给 Copilot 同样的指示来添加我们的代码文档，我们会得到更广泛和详细的回应（[图 6-4](#telling-copilot-to-ad)）。
- en: '![](assets/lghc_0604.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0604.png)'
- en: Figure 6-4\. Telling Copilot to add documentation to the code from the main
    chat
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 在主聊天中告诉 Copilot 添加代码文档
- en: 'The complete listing, as generated with comments, is available in the [book’s
    GitHub repository](https://oreil.ly/zHnkm). A few excerpts are shared in the next
    listing. You can see that Copilot not only inserted substantially more header
    comments but also added multiple comments throughout the body of the function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 带有注释的完整列表可在 [本书的 GitHub 仓库](https://oreil.ly/zHnkm) 中找到。下一列表中分享了一些摘录。你可以看到，Copilot
    不仅插入了大量头部注释，还在函数体中添加了多个注释：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s take this a step further. Since Copilot Chat can understand natural language,
    we can submit a prompt to have documentation generated to help anyone reading
    the code. We can tell Copilot in chat to “verbosely comment the selected function
    so anyone can understand what it is doing.” The resulting change from the original
    (uncommented) function can be seen in the [GitHub repository](https://oreil.ly/jTDZV).
    Other than some wording changes, the main differences are some extra lines of
    comments for each main section that talks about how the pieces are used or managed.
    Also some comments are added at the end of lines where an identifier may need
    to be better understood. [Figure 6-5](#updated-lines-from-is) shows an excerpt
    from these changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步。由于 Copilot 聊天可以理解自然语言，我们可以提交一个提示来生成文档，以帮助阅读代码的任何人。我们可以在聊天中告诉 Copilot：“详细注释所选函数，以便任何人都能理解它在做什么。”从原始（未注释）函数中产生的变化可以在
    [GitHub 仓库](https://oreil.ly/jTDZV) 中看到。除了一些措辞上的变化外，主要的不同之处在于每个主要部分都增加了额外的注释行，讨论了这些部分的使用或管理方式。还有一些注释被添加到可能需要更好地理解标识符的行尾。[图
    6-5](#updated-lines-from-is) 展示了这些变化的摘录。
- en: '![](assets/lghc_0605.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0605.png)'
- en: Figure 6-5\. Updated lines from issuing a verbose comment command
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 执行详细注释命令后的更新行
- en: 'This is an improvement. If we want even more, we can specifically target each
    line in the function body. Here’s a prompt we can use for that: “verbosely comment
    the function body so that anyone can easily understand what each line is doing.”'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个改进。如果我们想要更多，我们可以具体针对函数体中的每一行。以下是我们可以用作此目的的提示：“详细注释函数体，以便任何人都能轻松理解每一行在做什么。”
- en: With this prompt, we get a further verbose set of comments for the function
    body with more detailed comments for several of the elements. The full listing
    is available [online](https://oreil.ly/rZBRV), but [Figure 6-6](#more-verbose-comments)
    shows an excerpt of the differences.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个提示，我们得到了一个更详细的函数体注释集，其中对几个元素有更详细的注释。完整的列表可在[网上](https://oreil.ly/rZBRV)找到，但[图
    6-6](#more-verbose-comments) 展示了差异的摘录。
- en: '![](assets/lghc_0606.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0606.png)'
- en: Figure 6-6\. More verbose comments
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. 更详细的注释
- en: Comment Versus Documentation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释与文档
- en: You may have noticed that we are telling Copilot to *comment* our code versus
    *document* it. Since documentation in code is done via comments, either of these
    terms can be used in this situation for prompts. Strictly speaking, when we ask
    Copilot for documentation, it may default to creating a block of comments only
    at the start of the method/function, as we saw earlier.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们正在告诉 Copilot 对我们的代码进行**注释**而不是**文档化**。由于代码中的文档是通过注释完成的，因此在这种情况下，这两个术语都可以用于提示。严格来说，当我们要求
    Copilot 提供文档时，它可能会默认只在方法/函数的开始处创建一个注释块，就像我们之前看到的那样。
- en: 'Ultimately, you could combine the previous prompts into a single one to accomplish
    all the modifications. Here’s an example that seems to work well:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可以将之前的提示合并为一个，以完成所有修改。以下是一个似乎效果很好的示例：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One other nice aspect about Copilot’s documentation capabilities is that it
    can recognize when code has a documentation framework that can be used with it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 文档功能的一个其他优点是它可以识别代码中是否有可以与其一起使用的文档框架。
- en: Generating Framework-Compatible Documentation
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成与框架兼容的文档
- en: Different programming languages have their own documentation styles. For example,
    C# has XMLDoc, Python has pydoc, and JavaScript has JSDoc. If Copilot recognizes
    that the code is in a language that has a standard documentation tool associated
    with it, it will default to creating comments ready for that tool. This can be
    very useful for integration with the development environment and other tools and
    is often preferred to plain comments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言有自己的文档风格。例如，C# 有 XMLDoc，Python 有 pydoc，JavaScript 有 JSDoc。如果 Copilot
    识别出代码是在与标准文档工具关联的语言中，它将默认创建为该工具准备的注释。这对于与开发环境和其他工具的集成非常有用，并且通常比普通注释更受欢迎。
- en: 'For example, consider a Java class definition containing a single method that
    begins as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个包含单个方法的 Java 类定义，其开始部分如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we tell Copilot to “document this class,” it will add an extensive set of
    comments. The full listing is available [online](https://oreil.ly/LCxOH), but
    a few excerpts are included next:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们告诉 Copilot “文档化这个类”，它将添加一个广泛的注释集。完整的列表可在[网上](https://oreil.ly/LCxOH)找到，但以下是一些摘录：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The header comments above the class definition, and at its start, are generated
    in a form that is compatible with processing by the Javadoc tooling. The `/**`
    and `@param`, `@return`, and `@throw` parts are all formatting pieces that Javadoc
    would use to generate HTML documentation for the class. [Figure 6-7](#javadoc-generated-fro)
    shows an example of the generated Javadoc originating from the comments added
    by Copilot.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义上方的头部注释以及其开始部分是以与 Javadoc 工具处理兼容的形式生成的。`/**` 和 `@param`、`@return` 以及 `@throw`
    这些部分都是 Javadoc 会使用来为类生成 HTML 文档的格式化元素。[图 6-7](#javadoc-generated-fro) 展示了由 Copilot
    添加的注释生成的示例 Javadoc。
- en: '![](assets/lghc_0607.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0607.png)'
- en: Figure 6-7\. Javadoc generated from Copilot comments
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 从 Copilot 注释生成的 Javadoc
- en: 'Beyond generating documentation for the basic documentation frameworks, we
    can also use Copilot for another common need: documenting APIs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成基本文档框架的文档之外，我们还可以使用 Copilot 来满足另一个常见需求：文档化 API。
- en: Generating Documentation for APIs
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 API 文档
- en: If your project is set up for an API documentation framework like [Swagger](https://swagger.io),
    you can have Copilot generate the corresponding Swagger documentation for your
    APIs. Let’s look at an example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目配置了像 [Swagger](https://swagger.io) 这样的 API 文档框架，你可以让 Copilot 为你的 API 生成相应的
    Swagger 文档。让我们看看一个例子。
- en: 'Suppose we have a simple application that manages a directory of employees
    for a company. The application is written in Java and already configured for Swagger.
    We can tell Copilot to generate print-ready Swagger documentation for the APIs,
    referencing a particular file, with the prompt “create print-ready Swagger documentation
    for the APIS in #file:EmployeeController.java.”'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们有一个简单的应用程序，用于管理一家公司的员工目录。该应用程序是用Java编写的，并且已经配置了Swagger。我们可以告诉Copilot为API生成可打印的Swagger文档，并引用特定的文件，提示为“create
    print-ready Swagger documentation for the APIS in #file:EmployeeController.java。”'
- en: print-ready
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`print-ready`'
- en: We used the term *print-ready* in the prompt to ensure that Copilot generates
    the actual documentation format instead of trying to regenerate the code comments.
    We could also use terms like *publish-ready* or *publishable*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在提示中使用术语*print-ready*以确保Copilot生成实际的文档格式，而不是尝试重新生成代码注释。我们也可以使用诸如*publish-ready*或*publishable*之类的术语。
- en: Copilot’s response is shown in [Figure 6-8](#swagger-doc-from-code), and the
    full output is available in the book’s [GitHub repository](https://oreil.ly/Kj8Lj).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot的响应如图6-8所示，完整输出可在本书的[GitHub仓库](https://oreil.ly/Kj8Lj)中找到。
- en: '![](assets/lghc_0608.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0608.png)'
- en: Figure 6-8\. Swagger documentation from code
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-8. 从代码生成的Swagger文档
- en: A key for this to work (in addition to the `print-ready` descriptor) is being
    specific with the files that you point Copilot to via the `#file` selector (or
    multiple selectors if you need to reference more than one file). Simply pointing
    Copilot to the entire workspace with a similar prompt (such as “@workspace create
    Swagger documentation for the APIs”) will usually result in Copilot explaining
    *how to create* the Swagger documentation in your project versus dumping it out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作（除了`print-ready`描述符之外）的关键是，通过`#file`选择器（或多个选择器，如果您需要引用多个文件）指定您指向Copilot的文件。简单地将Copilot指向整个工作空间并使用类似的提示（例如，“@workspace
    create Swagger documentation for the APIs”）通常会导致Copilot解释如何在您的项目中创建Swagger文档，而不是将其输出。
- en: Creating Functional Documentation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建功能文档
- en: 'Copilot is also capable of creating functional documentation that is targeted
    toward external users. For an example, we can leverage the same API code that
    we used in the preceding section. In this case, our prompt might look something
    like this: “create functional documentation explaining the various public APIs
    in #file:Employee​Con⁠troller.java.”'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'Copilot还能够创建面向外部用户的功能性文档。例如，我们可以利用前面章节中使用的相同API代码。在这种情况下，我们的提示可能看起来像这样：“create
    functional documentation explaining the various public APIs in #file:EmployeeCon⁠troller.java。”'
- en: '[Figure 6-9](#generated-functional) shows the start of the actual functional
    API doc generated from the prompt. Note that the output includes some prose style,
    in an easy-to-read format, but with the necessary details outlined for the API
    structure. It’s not shown here, but Copilot also outlined a set of steps first
    that it would follow for this, including *Identifying Public APIs*, *Method Signatures*,
    and *Endpoint Mapping*. The full output can be viewed in the book’s [GitHub repo](https://oreil.ly/lV7jV).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-9](#generated-functional)显示了从提示中生成的实际功能API文档的开始。请注意，输出包括一些散文风格，以易于阅读的格式呈现，但详细说明了API结构。这里没有显示，但Copilot还概述了它将遵循的一组步骤，包括*识别公共API*、*方法签名*和*端点映射*。完整输出可在本书的[GitHub仓库](https://oreil.ly/lV7jV)中查看。'
- en: '![](assets/lghc_0609.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0609.png)'
- en: Figure 6-9\. Generated functional documentation
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-9. 生成的功能文档
- en: 'In general, the same caveat applies for generating this kind of documentation
    as it did for generating API documentation in the previous section: indicate specific
    files for the prompt to act on as opposed to trying to ask Copilot to operate
    against the entire workspace. However, we can ask some general questions by using
    `@workspace` and get good summary documentation. For example, if we ask “@workspace
    what are the API’s parameters and what does it return?”, we get a useful summary.
    The full listing is available [online](https://oreil.ly/sXKOv), and an excerpt
    is also shown in [Figure 6-10](#querying-api-paramete).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成此类文档的注意事项与上一节生成API文档时的注意事项相同：在提示中指定特定文件以供操作，而不是尝试让Copilot针对整个工作空间操作。然而，我们可以通过使用`@workspace`来提出一些一般性问题，并获得良好的总结性文档。例如，如果我们询问“@workspace
    what are the API’s parameters and what does it return?”，我们会得到有用的总结。完整列表可在[在线](https://oreil.ly/sXKOv)找到，并在[图6-10](#querying-api-paramete)中展示了摘录。
- en: '![](assets/lghc_0610.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0610.png)'
- en: Figure 6-10\. Querying API parameters
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-10. 查询API参数
- en: Extracting Summary Documentation from the Code
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从代码中提取摘要文档
- en: Copilot can also be used to extract a high-level summary of the key documentation
    from certain types of projects. This can be extremely useful for quickly understanding
    the significant details of the codebase for a project. Referencing the Java Swagger
    project in the preceding section, we can gather key information from it with the
    prompt “@workspace extract the key documentation from the code.”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot还可以用于从某些类型的项目中提取关键文档的高级摘要。这对于快速理解项目代码库的重要细节非常有用。参考前述章节中的Java Swagger项目，我们可以通过提示“@workspace
    extract the key documentation from the code”从中收集关键信息。
- en: In our case, Copilot extracted data from the *pom.xml* file, the *README.md*
    file, and the relevant **.java* files. Copilot then provided key high-level details
    on the project’s structure, dependencies, Swagger configuration, and testing.
    [Figure 6-11](#key-documentation-ext) shows an excerpt, and the full listing can
    be seen [on GitHub](https://oreil.ly/wSmbs).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，Copilot从*pom.xml*文件、*README.md*文件以及相关的**.java**文件中提取数据。然后Copilot提供了关于项目结构、依赖关系、Swagger配置和测试的关键高级细节。[图6-11](#key-documentation-ext)展示了摘录内容，完整列表可以在[GitHub](https://oreil.ly/wSmbs)上查看。
- en: '![](assets/lghc_0611.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0611.png)'
- en: Figure 6-11\. Key documentation extracted from code
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-11\. 从代码中提取的关键文档
- en: 'That completes our survey of the various ways that Copilot can help you with
    producing documentation. Let’s move to a similar, but arguably more important,
    functionality that Copilot provides: explaining content.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对Copilot在生成文档方面各种帮助方式的调查。让我们转向Copilot提供的另一个类似但可能更为重要的功能：解释内容。
- en: Explaining Content
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释内容
- en: 'In addition to providing documentation for what code does, Copilot is also
    able to provide explanations for content it works with and generates. This feature
    can be helpful in multiple use cases:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供代码功能的文档外，Copilot还能提供它所处理和生成的内容的解释。这个功能在多个用例中可能非常有用：
- en: Understanding code in a language new to you
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解你新接触到的编程语言中的代码
- en: Understanding generated code and conventions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解生成的代码和约定
- en: Summarizing code logic
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结代码逻辑
- en: Explaining what might go wrong in the code
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释代码中可能出错的地方
- en: Explaining what was done in the terminal
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释在终端中做了什么
- en: Explaining how to do something in the terminal
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释如何在终端中做某事
- en: 'We’ll briefly dive into each one of these areas in this section. A couple of
    common points apply across all of these:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中简要探讨这些领域的每一个。以下是一些适用于所有这些领域的常见点：
- en: The prompt is the key here. Getting the prompt correct for the situation and
    using it to state clearly what you want is the most important prerequisite to
    having Copilot explain something well.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示是关键。正确地获取提示并使用它清楚地表达你的需求，是Copilot能够很好地解释某事的最重要先决条件。
- en: While we will generally use *explain* as a key term in our prompt, it’s not
    always required. You can also ask *why, how*, or other types of questions as appropriate.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们通常会在提示中使用“解释”作为关键词，但这并不是必需的。你也可以根据需要询问“为什么”、“如何”或其他类型的问题。
- en: Understanding Code in a Language New to You
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解你新接触到的编程语言中的代码
- en: Suppose you are a Python programmer, but you’ve just been given an assignment
    to implement a new project in Go. Copilot can assist you with creating the code
    as well as understanding the key points of working with Go. For example, you can
    give Copilot a prompt like “I’m a Python programmer. What are the most significant
    things I need to understand about how to write Go code?”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一名Python程序员，但你刚刚被分配了一个用Go语言实现新项目的任务。Copilot可以帮助你创建代码，以及理解使用Go语言的关键点。例如，你可以给Copilot一个提示，比如：“我是一个Python程序员。我需要了解哪些最重要的内容来编写Go代码？”
- en: 'When asked this question while I was writing this chapter, Copilot responded
    with information about the following 12 areas:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在写这一章时被问到这个问题时，Copilot提供了以下12个领域的信息：
- en: Static typing
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型
- en: Compilation
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译
- en: Syntax differences
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法差异
- en: Packages and imports
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包和导入
- en: Functions
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Error handling
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Concurrency
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Structs and methods
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体和方法
- en: Pointers
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针
- en: Standard library
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库
- en: Tooling
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具
- en: Interfaces
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: In some cases, Copilot also showed brief code snippets to illustrate the points
    and finished the explanation with “Understanding these key differences will help
    you transition from Python to Go more smoothly.” You can see the entire output
    from the chat [on GitHub](https://oreil.ly/roJZB).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Copilot还展示了简短的代码片段来阐述观点，并以“理解这些关键差异将帮助你更顺利地从Python过渡到Go”结束解释。你可以在GitHub上查看整个聊天输出[链接](https://oreil.ly/roJZB)。
- en: You can also select specific parts of your code and have Copilot explain how
    they work with the `/explain` shortcut command. You can even tell Copilot to translate
    existing code into the new language. As always, though, you should verify that
    any suggestion or response that Copilot provides is accurate and appropriate for
    your situation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择代码的特定部分，并使用`/explain`快捷命令让Copilot解释它们是如何工作的。你甚至可以告诉Copilot将现有代码翻译成新语言。然而，一如既往，你应该验证Copilot提供的任何建议或回应是否准确且适用于你的情况。
- en: Copilot is helpful not only in understanding the basics of a new language but
    also in highlighting conventions that the language uses and the purpose of automatically
    generated code in that language.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot不仅有助于理解新语言的基础，还能突出该语言使用的约定以及该语言中自动生成代码的目的。
- en: Understanding Generated Code and Conventions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解生成的代码和约定
- en: Suppose you are new to Kubernetes and Go and need to create a Kubernetes operator
    to manage custom resources. You would probably use the [Operator SDK](https://oreil.ly/Lfz8O)
    to generate the starting structure for your project in Go.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是Kubernetes和Go的新手，需要创建一个Kubernetes操作员来管理自定义资源。你可能会用[Operator SDK](https://oreil.ly/Lfz8O)来生成Go项目中起始结构。
- en: 'The SDK automatically generates utility files, including ones with cryptic
    names like *zz_generated.deepcopy.go*. One of the first things you might want
    to know is what this generated file is used for. To get the answer, you can simply
    ask Copilot, “What is the code in #file:api/v1alpha1/zz_generated.deepcopy used
    for?” Copilot’s response (excerpted in [Figure 6-12](#copilot-explaining-wh))
    provides an introduction and then a breakdown of its purpose. The entire response
    can be found [on GitHub](https://oreil.ly/I0-3j).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SDK自动生成实用文件，包括像*zz_generated.deepcopy.go*这样的神秘命名的文件。你可能首先想知道这个生成的文件是用于什么目的。为了得到答案，你可以简单地询问Copilot，“#file:api/v1alpha1/zz_generated.deepcopy中的代码是用于什么的？”Copilot的回应（如图6-12所示的部分摘录）提供了一个介绍，然后对其目的进行了分解。整个回应可以在GitHub上找到[链接](https://oreil.ly/I0-3j)。
- en: '![](assets/lghc_0612.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0612.png)'
- en: Figure 6-12\. Copilot explaining what code is used for
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-12. Copilot解释代码的用途
- en: In these kinds of responses, Copilot will usually provide a summary at the end
    of the output that can be helpful to quickly get the gist of the response. In
    this case, Copilot notes, “In summary, zz_generated.deepcopy.go is an auto-generated
    file that provides necessary deep copy functions for custom resource types in
    Kubernetes, ensuring proper handling and manipulation of these resources.”
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这类回答中，Copilot通常会在输出的末尾提供一个总结，这有助于快速抓住回答的要点。在这种情况下，Copilot指出，“总之，zz_generated.deepcopy.go是一个自动生成的文件，为Kubernetes中的自定义资源类型提供必要的深度复制函数，确保对这些资源的适当处理和操作。”
- en: You might also wonder why the code is named the way it is. We can ask Copilot
    about the naming convention with a prompt like “Why is this file named starting
    with zz_?” Copilot provides a helpful, conversational answer with a list of reasons
    for the convention, as shown in [Figure 6-13](#copilot-explanation-f).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会好奇代码为什么会被命名为这种方式。我们可以用类似“为什么这个文件以zz_开头命名？”这样的提示来询问Copilot关于命名约定。Copilot会提供一个包含原因列表的帮助性、对话式的回答，如图6-13所示。
- en: '![](assets/lghc_0613.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0613.png)'
- en: Figure 6-13\. Copilot explanation for the zz_ naming convention
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-13. Copilot对zz_命名约定的解释
- en: In addition to understanding the general conventions and main themes of a language,
    Copilot can help explain the overall logic of a set of code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理解一种语言的一般约定和主要主题外，Copilot还可以帮助解释一组代码的整体逻辑。
- en: Explaining the Logic Used in a Section of Code
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释代码某部分所使用的逻辑
- en: 'Summarizing code logic more generally can be helpful in various use cases,
    including these:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总结代码逻辑在多种用例中可能很有帮助，包括以下这些：
- en: Quickly getting a handle on code you’ve inherited or must maintain
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速掌握你继承或必须维护的代码
- en: Learning about code written in a language or framework that’s new to you
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解你新接触的语言或框架编写的代码
- en: Checking your understanding from reviewing the code
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过审查代码来检查你的理解
- en: Having another explanation of how the code works for code reviews, pull requests,
    etc.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为代码审查、拉取请求等提供另一种解释代码的方法。
- en: The goal is to have Copilot outline the general logic and related pieces, such
    as the main components used, in a non-language-specific way. We want Copilot’s
    explanation to be in a conversational tone, as if we were interacting with another
    developer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是让Copilot以一种非语言特定的方式概述一般逻辑和相关部分，例如使用的主要组件。我们希望Copilot的解释以对话的语气呈现，就像我们与另一位开发者互动一样。
- en: 'The actual prompt you use for this can vary, but here’s an example for the
    same controller file that we’ve been referencing: “@workspace: summarize the logic
    in #file:controllers/roarapp_controller.go.”'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，你使用的提示可能会有所不同，但以下是一个针对我们一直在引用的相同控制器文件的示例：“@workspace: summarize the logic
    in #file:controllers/roarapp_controller.go。”'
- en: 'From this prompt, Copilot provides output that starts with an overall explanation
    of what the code is intended to do: “reconciling the state of ... custom resources
    in a Kubernetes cluster.”'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个提示中，Copilot提供了输出，首先是对代码预期功能的整体解释：“在Kubernetes集群中协调...自定义资源的状态。”
- en: Copilot then provides a summary of the key components in the file and what each
    does. These include the data structures, annotations, and functions. An excerpt
    from this output is shown in [Figure 6-14](#copilot-summarizing-t), and the complete
    output can be seen [on GitHub](https://oreil.ly/5oG3v).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Copilot提供了文件中关键组件的总结以及每个组件的作用。这包括数据结构、注解和函数。[图6-14](#copilot-summarizing-t)展示了输出摘录，完整的输出可以在[GitHub](https://oreil.ly/5oG3v)上查看。
- en: '![](assets/lghc_0614.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0614.png)'
- en: Figure 6-14\. Copilot summarizing the logic used in a file
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '[图6-14]。Copilot总结文件中使用的逻辑'
- en: 'Another good prompt to consider is simply swapping the keyword *workflow* for
    *logic*, as in “@workspace: summarize the workflow in #file:controllers/roarapp_controller.go.”
    This should yield a slightly simpler response but with similar information on
    the various components.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个值得考虑的好提示是简单地用*逻辑*替换关键字*工作流程*，例如：“@workspace: summarize the workflow in #file:controllers/roarapp_controller.go。”这应该会产生一个稍微简单一点的响应，但包含关于各种组件的类似信息。'
- en: One other interesting way to learn about, and understand, the code flips the
    traditional *explain* use case. Instead of asking Copilot to explain how or what
    code does, we can ask it about potential problems with the code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有趣的学习和理解代码的方法是反转传统的*解释*用例。我们不是要求Copilot解释代码是如何或做什么的，而是可以询问代码可能存在的问题。
- en: Explaining What Might Go Wrong with a Set of Code
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释一组代码可能出什么问题
- en: Another approach when having Copilot explain code is to have it identify any
    potential problems with the code. This can be used for code you’ve written, are
    investigating, or have inherited, for example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当让Copilot解释代码时，另一种方法是让它识别代码中任何潜在的问题。这可以用于你编写的代码、正在调查的代码或继承的代码等。
- en: 'Going back to the Kubernetes custom resource example that we’ve been using
    in this chapter, we can choose to ask Copilot what could go wrong with the code
    that implements the custom controller in the editor. The prompt we use for this
    is “@workspace: explain what might go wrong with the code in #file:controllers/roarapp_​controller.go.”'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '回到我们在本章中使用的Kubernetes自定义资源示例，我们可以选择询问Copilot在编辑器中实现自定义控制器时，代码可能出什么问题。我们使用的提示是：“@workspace:
    explain what might go wrong with the code in #file:controllers/roarapp_​controller.go。”'
- en: 'Using @workspace and #file'
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@workspace和#file
- en: Remember, we can use variables like `#selection` or `#file` in the prompt string
    to focus Copilot on the context we want it to consider for its response. But in
    some cases, we may also need to use the `@workspace` identifier to ensure that
    Copilot looks at related pieces and takes into account the full picture of what
    else might affect this code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以在提示字符串中使用变量如`#selection`或`#file`来让Copilot关注它响应时想要考虑的上下文。但在某些情况下，我们也可能需要使用`@workspace`标识符来确保Copilot查看相关部分，并考虑可能影响此代码的全面情况。
- en: 'Copilot, in turn, provides a detailed answer listing out several areas to look
    at that include the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Copilot提供了一个详细的答案，列出了几个需要关注的区域，包括以下内容：
- en: Error handling
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Resource conflicts
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源冲突
- en: Requeue logic
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试逻辑
- en: Resource cleanup
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源清理
- en: Concurrency issues
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发问题
- en: Logging
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录日志
- en: Validation
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: RBAC permissions
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC权限
- en: The full output for this can be seen in the [GitHub repo file](https://oreil.ly/v7I75).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[GitHub仓库文件](https://oreil.ly/v7I75)中查看完整的输出。
- en: Now that we’ve looked at different ways Copilot can explain what’s happening
    in code, let’s finish up by looking at how Copilot can help explain things in
    the context of another domain—the terminal.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Copilot可以以不同方式解释代码中发生的事情的不同方法，让我们通过查看Copilot如何帮助在另一个领域——终端中解释事物来结束。
- en: Explaining Items from the Terminal
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释终端中的项目
- en: 'Copilot is able to access the terminal to explain details about the last command
    via the `#terminalLastCommand` keyword. For example, assume we ran the `ps` command
    as shown here as our most recent command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot能够通过`#terminalLastCommand`关键字访问终端来解释关于最后一个命令的详细信息。例如，假设我们运行了如图所示的`ps`命令作为我们最近的命令：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we wanted more details on what this command was doing, we could query Copilot
    with a prompt like “explain #terminalLastCommand.” As you can see in [Figure 6-15](#copilot-explaining-th),
    Copilot identifies the last command and provides an explanation of the command,
    its options, and its output.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更多关于此命令正在做什么的详细信息，我们可以用类似“解释#terminalLastCommand”的提示查询Copilot。如您在[图6-15](#copilot-explaining-th)中看到的，Copilot识别了最后一个命令，并提供了关于该命令、其选项及其输出的解释。
- en: '![](assets/lghc_0615.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0615.png)'
- en: Figure 6-15\. Copilot explaining the last terminal command
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-15\. Copilot解释最后一个终端命令
- en: The full output can be seen [in GitHub](https://oreil.ly/yCMOO).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完整输出可以在[GitHub](https://oreil.ly/yCMOO)中查看。
- en: 'Copilot can also explain selected content from the terminal. For example, if
    we ran a `git status` command previously, we can highlight that and ask Copilot
    to explain it with the prompt “explain the commands in #terminalSelection.” Copilot
    will then provide info on that, as shown in [Figure 6-16](#explaining-a-command).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot也可以解释终端中选定的内容。例如，如果我们之前运行了`git status`命令，我们可以突出显示它，并要求Copilot使用提示“解释#terminalSelection中的命令”来解释它。Copilot将提供相关信息，如图[图6-16](#explaining-a-command)所示。
- en: '![](assets/lghc_0616.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0616.png)'
- en: Figure 6-16\. Explaining a command selected in the terminal
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-16\. 解释终端中选择的命令
- en: 'You don’t have to select a command to explain. You can also select any text
    displayed in the terminal, such as the output of a command. Suppose we select
    the text “Your branch is up to date with ‘origin/main’.” in the output of the
    `git status` command. Since the identifier already references any content selected
    in the terminal, we can shorten our prompt to “explain #terminalSelection.”'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必选择一个命令来解释。您也可以选择终端中显示的任何文本，例如命令的输出。假设我们在`git status`命令的输出中选择了文本“您的分支与‘origin/main’保持最新”。由于标识符已经引用了终端中选定的任何内容，我们可以将提示缩短为“解释#terminalSelection”。
- en: Copilot will then explain the meaning of that selected phrase. [Figure 6-17](#explaining-git-status)
    shows an excerpt from the output for this prompt.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Copilot将解释所选短语的含义。[图6-17](#explaining-git-status)显示了此提示的输出摘录。
- en: '![](assets/lghc_0617.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0617.png)'
- en: Figure 6-17\. Explaining the `git status` command as selected in terminal
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-17\. 解释在终端中选择的`git status`命令
- en: You can also have Copilot explain *how* to do something via the terminal. That’s
    the subject of our last section in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以让Copilot解释如何通过终端做某事。这是我们本章最后部分的主题。
- en: Explaining How to Do Something in the Terminal
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释如何在终端中做某事
- en: 'Copilot can supply the process and commands to do operations in the terminal.
    As an example, we can ask Copilot how to create a new branch in our GitHub repository.
    We can utilize the `@terminal` context and prompt Copilot with: “@terminal How
    do I create a new branch for my GitHub repository?”'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot可以提供在终端中执行操作的流程和命令。例如，我们可以询问Copilot如何在我们的GitHub仓库中创建一个新的分支。我们可以利用`@terminal`上下文，并提示Copilot：“@terminal
    我如何为我的GitHub仓库创建一个新的分支？”
- en: In response, Copilot provides the usual conversational process description along
    with the actual commands that you can run in the terminal. [Figure 6-18](#explaining-how-to-cre)
    shows an excerpt from the output, which you can see in full on [GitHub](https://oreil.ly/0t1il).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，Copilot提供了通常的对话流程描述以及您可以在终端中运行的实际命令。[图6-18](#explaining-how-to-cre)显示了输出的一部分，您可以在[GitHub](https://oreil.ly/0t1il)中查看完整内容。
- en: '![](assets/lghc_0618.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_0618.png)'
- en: Figure 6-18\. Explaining how to create a new branch via the terminal
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-18\. 解释如何通过终端创建新分支
- en: Similar Results
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类似的结果
- en: You can also achieve a similar result with a prompt that references *command
    line*, as in “How can I create a new branch in my GitHub repository using the
    command line?”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用引用“命令行”的提示来获得类似的结果，例如“我如何使用命令行在我的GitHub仓库中创建一个新的分支？”
- en: The same technique is applicable when you may not know the command to use. For
    example, if we give Copilot the query “@terminal how do I see the list of running
    processes?”, it responds with multiple approaches that can be used from the terminal,
    as shown in [Figure 6-19](#how-to-see-running-pr).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可能不知道要使用哪个命令时，同样的技术也适用。例如，如果我们给 Copilot 查询“@terminal 我如何查看运行中的进程列表？”，它会响应多个可以从终端使用的方案，如图
    6-19 所示。
- en: '![](assets/lghc_0619.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0619.png)'
- en: Figure 6-19\. How to see running processes via the terminal
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-19\. 如何通过终端查看运行中的进程
- en: Conclusion
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this chapter, we’ve explored how Copilot can help you with documentation
    and explanations. At the basic level, Copilot can document your source code by
    inserting comments throughout. A shortcut `/doc` command typically provides header
    documentation. You can tell Copilot to produce more extensive comments via prompts
    that include specific directions, such as “verbosely comment.” This illustrates
    a useful working tip for Copilot: if you aren’t getting what you expect or need,
    try using a more verbose, detailed prompt. You can reject the suggested changes
    if they are not what you wanted and continue to iterate on your prompt.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Copilot 如何帮助您进行文档和解释。在基本层面上，Copilot 可以通过在源代码中插入注释来记录您的代码。通常，`/doc`
    命令提供标题文档。您可以通过包含特定指示的提示来告诉 Copilot 生成更广泛的注释，例如“详细注释”。这说明了 Copilot 的一个有用的工作技巧：如果您没有得到期望或需要的结果，尝试使用更详细、更冗长的提示。如果您不希望看到建议的更改，可以拒绝并继续迭代您的提示。
- en: Beyond just the basic commenting, Copilot can also generate more extensive documentation
    for particular use cases. For example, it can generate API documentation and functional
    documentation suitable (after review) for sharing with others. This can provide
    a significant time savings over having to create this type of documentation in
    a less automated way.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的注释外，Copilot 还可以为特定用例生成更广泛的文档。例如，它可以生成适合（经过审查后）与他人分享的 API 文档和功能文档。这可以显著节省在更少自动化的方式下创建此类文档所需的时间。
- en: Similar to its documentation capability, Copilot also can explain many aspects
    of a codebase. This functionality can be used to explain general concepts and
    principles needed to use a new language or framework and also provide explanations
    for conventions that you may not be familiar with.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与其文档功能类似，Copilot 还可以解释代码库的许多方面。此功能可用于解释使用新语言或框架所需的一般概念和原则，并提供对您可能不熟悉的约定的解释。
- en: But, most significantly, Copilot can explain and summarize how the logic and
    processing for a set of code works. This can be especially useful if you are trying
    to learn, or have to maintain, code that you are not familiar with.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但，最重要的是，Copilot 可以解释和总结一组代码的逻辑和处理的运作方式。如果您试图学习或必须维护您不熟悉的代码，这会特别有用。
- en: A less common use for the explain functionality can be to explain what might
    go wrong with a set of code. This is an easy way to have Copilot essentially *review*
    the code and look for potential gaps and problems. This can be very useful if
    you are trying to assess weaknesses in the code and make sure vulnerable sections
    are addressed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 解释功能的较少见用途可以用来解释一组代码可能出错的情况。这是一种让 Copilot 事实上 *审查* 代码并寻找潜在差距和问题的简单方法。如果您试图评估代码的弱点并确保易受攻击的部分得到处理，这会非常有用。
- en: Lastly, we looked at the ability to use Copilot’s explain functionality with
    a terminal. This falls into two categories. The first is selecting some output
    or referencing the last terminal command with a special identifier and having
    Copilot explain the meaning. The second involves asking Copilot how to do something
    in the terminal and having it provide a conversational explanation along with
    the exact commands to run in the terminal to accomplish the task.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了使用 Copilot 的解释功能与终端结合的能力。这可以分为两个类别。第一类是选择一些输出或使用特殊标识符引用最后一个终端命令，让 Copilot
    解释其含义。第二类是询问 Copilot 在终端中如何做某事，并让它提供对话式的解释，以及完成该任务在终端中运行的精确命令。
- en: While we have seen how valuable and extensive Copilot’s capabilities can be,
    it’s important to remember that it can be inaccurate and provide out-of-date information
    as results. This happens because Copilot’s knowledge base is only as up-to-date
    as the recency of the data that was used to train the underlying models it leverages.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经看到了 Copilot 的功能和范围是多么有价值，但重要的是要记住，它可能会不准确，并作为结果提供过时信息。这是因为 Copilot 的知识库仅与用于训练其底层模型的训练数据的最新程度相匹配。
- en: In the next chapter, we’ll look at how to deal with Copilot basing suggestions
    and responses on out-of-date information and how to work around those situations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何处理基于过时信息的 Copilot 建议和响应，以及如何应对这些情况。
