<html><head></head><body><section data-pdf-bookmark="Chapter 7. Agents II" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch07_agents_ii_1736545673023633">&#13;
<h1><span class="label">Chapter 7. </span>Agents II</h1>&#13;
&#13;
<p><a data-type="xref" href="ch06.html#ch06_agent_architecture_1736545671750341">Chapter 6</a> introduced the <em>agent</em> architecture, the most powerful of the LLM architectures we have seen up until now. It is hard to overstate the potential of this combination of chain-of-thought prompting, tool use, and looping.</p>&#13;
&#13;
<p>This chapter discusses two extensions to the agent architecture that improve performance for some use cases:</p>&#13;
&#13;
<dl>&#13;
	<dt>Reflection</dt>&#13;
	<dd>&#13;
	<p>Taking another page out of the repertoire of human thought patterns, this is about giving your LLM app the opportunity to analyze its past output and choices, together with the ability to remember reflections from past iterations.</p>&#13;
	</dd>&#13;
	<dt>Multi-agent</dt>&#13;
	<dd>&#13;
	<p>Much the same way as a team can accomplish more than a single person, there are problems that can be best tackled by teams of LLM agents.</p>&#13;
	</dd>&#13;
</dl>&#13;
&#13;
<p>Let’s start with reflection.</p>&#13;
&#13;
<section data-pdf-bookmark="Reflection" data-type="sect1"><div class="sect1" id="ch07_reflection_1736545673023763">&#13;
<h1>Reflection</h1>&#13;
&#13;
<p>One<a contenteditable="false" data-primary="agent architecture" data-secondary="reflection prompting technique" data-type="indexterm" id="AAreflection07"/><a contenteditable="false" data-primary="reflection prompting technique" data-type="indexterm" id="rpt07"/><a contenteditable="false" data-primary="prompts" data-secondary="reflection prompting technique" data-type="indexterm" id="Preflect07"/> prompting technique we haven’t covered yet is <em>reflection</em> (also<a contenteditable="false" data-primary="self-critique prompting technique" data-type="indexterm" id="id746"/> known as <em>self-critique</em>). <em>Reflection</em> is the creation of a loop between a creator prompt and a reviser prompt. This mirrors the creation process for many human-created artifacts, such as this chapter you’re reading now, which is the result of a back and forth between the authors, reviewers, and editor until all are happy with the final product.</p>&#13;
&#13;
<p>As with many of the prompting techniques we have seen so far, reflection can be combined with other techniques, such as chain-of-thought and tool calling. In this section, we’ll look at reflection in isolation.</p>&#13;
&#13;
<p>A parallel can be drawn to the modes of human thinking known as <em>System 1</em> (reactive or instinctive) and <em>System 2</em> (methodical and reflective), first introduced<a contenteditable="false" data-primary="Kahneman, Daniel" data-type="indexterm" id="id747"/> by Daniel Kahneman in the book <em>Thinking, Fast and Slow</em> (Farrar, Straus and Giroux, 2011). When applied correctly, self-critique can help LLM applications get closer to something that resembles System 2 behavior (<a data-type="xref" href="#ch07_figure_1_1736545673018473">Figure 7-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="ch07_figure_1_1736545673018473"><img alt="System 1 and System 2 thinking" src="assets/lelc_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>System 1 and System 2 thinking</h6>&#13;
</div></figure>&#13;
&#13;
<p class="fix_tracking">We’ll implement reflection as a graph with two nodes: <code>generate</code> and <code>reflect</code>. This graph will be tasked with writing three-paragraph essays, with the <code>generate</code> node writing or revising drafts of the essay, and <code>reflect</code> writing a critique to inform the next revision. We’ll run the loop a fixed number of times, but a variation on this technique would be to have the <code>reflect</code> node decide when to finish. Let’s see what it looks like:</p>&#13;
&#13;
<p><em>Python<a contenteditable="false" data-primary="Python" data-secondary="reflection prompting technique" data-type="indexterm" id="id748"/></em></p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Annotated</code><code class="p">,</code> <code class="n">TypedDict</code>&#13;
&#13;
<code class="kn">from</code> <code class="nn">langchain_core.messages</code> <code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="n">AIMessage</code><code class="p">,</code>&#13;
    <code class="n">BaseMessage</code><code class="p">,</code>&#13;
    <code class="n">HumanMessage</code><code class="p">,</code>&#13;
    <code class="n">SystemMessage</code><code class="p">,</code>&#13;
<code class="p">)</code>&#13;
<code class="kn">from</code> <code class="nn">langchain_openai</code> <code class="kn">import</code> <code class="n">ChatOpenAI</code>&#13;
&#13;
<code class="kn">from</code> <code class="nn">langgraph.graph</code> <code class="kn">import</code> <code class="n">END</code><code class="p">,</code> <code class="n">START</code><code class="p">,</code> <code class="n">StateGraph</code>&#13;
<code class="kn">from</code> <code class="nn">langgraph.graph.message</code> <code class="kn">import</code> <code class="n">add_messages</code>&#13;
&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">ChatOpenAI</code><code class="p">()</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">State</code><code class="p">(</code><code class="n">TypedDict</code><code class="p">):</code>&#13;
    <code class="n">messages</code><code class="p">:</code> <code class="n">Annotated</code><code class="p">[</code><code class="nb">list</code><code class="p">[</code><code class="n">BaseMessage</code><code class="p">],</code> <code class="n">add_messages</code><code class="p">]</code>&#13;
&#13;
<code class="n">generate_prompt</code> <code class="o">=</code> <code class="n">SystemMessage</code><code class="p">(</code>&#13;
    <code class="sd">"""You are an essay assistant tasked with writing excellent 3-paragraph </code>&#13;
<code class="sd">        essays."""</code>&#13;
    <code class="s2">"Generate the best essay possible for the user's request."</code>&#13;
    <code class="sd">"""If the user provides critique, respond with a revised version of your </code>&#13;
<code class="sd">        previous attempts."""</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">generate</code><code class="p">(</code><code class="n">state</code><code class="p">:</code> <code class="n">State</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">State</code><code class="p">:</code>&#13;
    <code class="n">answer</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">invoke</code><code class="p">([</code><code class="n">generate_prompt</code><code class="p">]</code> <code class="o">+</code> <code class="n">state</code><code class="p">[</code><code class="s2">"messages"</code><code class="p">])</code>&#13;
    <code class="k">return</code> <code class="p">{</code><code class="s2">"messages"</code><code class="p">:</code> <code class="p">[</code><code class="n">answer</code><code class="p">]}</code>&#13;
&#13;
<code class="n">reflection_prompt</code> <code class="o">=</code> <code class="n">SystemMessage</code><code class="p">(</code>&#13;
    <code class="sd">"""You are a teacher grading an essay submission. Generate critique and </code>&#13;
<code class="sd">        recommendations for the user's submission."""</code>&#13;
    <code class="sd">"""Provide detailed recommendations, including requests for length, depth, </code>&#13;
<code class="sd">        style, etc."""</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">reflect</code><code class="p">(</code><code class="n">state</code><code class="p">:</code> <code class="n">State</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">State</code><code class="p">:</code>&#13;
    <code class="c1"># Invert the messages to get the LLM to reflect on its own output</code>&#13;
    <code class="n">cls_map</code> <code class="o">=</code> <code class="p">{</code><code class="n">AIMessage</code><code class="p">:</code> <code class="n">HumanMessage</code><code class="p">,</code> <code class="n">HumanMessage</code><code class="p">:</code> <code class="n">AIMessage</code><code class="p">}</code>&#13;
    <code class="c1"># First message is the original user request. </code>&#13;
    <code class="c1"># We hold it the same for all nodes</code>&#13;
    <code class="n">translated</code> <code class="o">=</code> <code class="p">[</code><code class="n">reflection_prompt</code><code class="p">,</code> <code class="n">state</code><code class="p">[</code><code class="s2">"messages"</code><code class="p">][</code><code class="mi">0</code><code class="p">]]</code> <code class="o">+</code> <code class="p">[</code>&#13;
        <code class="n">cls_map</code><code class="p">[</code><code class="n">msg</code><code class="o">.</code><code class="vm">__class__</code><code class="p">](</code><code class="n">content</code><code class="o">=</code><code class="n">msg</code><code class="o">.</code><code class="n">content</code><code class="p">)</code> &#13;
            <code class="k">for</code> <code class="n">msg</code> <code class="ow">in</code> <code class="n">state</code><code class="p">[</code><code class="s2">"messages"</code><code class="p">][</code><code class="mi">1</code><code class="p">:]</code>&#13;
    <code class="p">]</code>&#13;
    <code class="n">answer</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">invoke</code><code class="p">(</code><code class="n">translated</code><code class="p">)</code>&#13;
    <code class="c1"># We treat the output of this as human feedback for the generator</code>&#13;
    <code class="k">return</code> <code class="p">{</code><code class="s2">"messages"</code><code class="p">:</code> <code class="p">[</code><code class="n">HumanMessage</code><code class="p">(</code><code class="n">content</code><code class="o">=</code><code class="n">answer</code><code class="o">.</code><code class="n">content</code><code class="p">)]}</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">should_continue</code><code class="p">(</code><code class="n">state</code><code class="p">:</code> <code class="n">State</code><code class="p">):</code>&#13;
    <code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="n">state</code><code class="p">[</code><code class="s2">"messages"</code><code class="p">])</code> <code class="o">&gt;</code> <code class="mi">6</code><code class="p">:</code>&#13;
        <code class="c1"># End after 3 iterations, each with 2 messages</code>&#13;
        <code class="k">return</code> <code class="n">END</code>&#13;
    <code class="k">else</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="s2">"reflect"</code>&#13;
&#13;
<code class="n">builder</code> <code class="o">=</code> <code class="n">StateGraph</code><code class="p">(</code><code class="n">State</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="s2">"generate"</code><code class="p">,</code> <code class="n">generate</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="s2">"reflect"</code><code class="p">,</code> <code class="n">reflect</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_edge</code><code class="p">(</code><code class="n">START</code><code class="p">,</code> <code class="s2">"generate"</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_conditional_edges</code><code class="p">(</code><code class="s2">"generate"</code><code class="p">,</code> <code class="n">should_continue</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_edge</code><code class="p">(</code><code class="s2">"reflect"</code><code class="p">,</code> <code class="s2">"generate"</code><code class="p">)</code>&#13;
&#13;
<code class="n">graph</code> <code class="o">=</code> <code class="n">builder</code><code class="o">.</code><code class="n">compile</code><code class="p">()</code></pre>&#13;
&#13;
<p class="pagebreak-before less_space"><em>JavaScript<a contenteditable="false" data-primary="JavaScript" data-secondary="reflection prompting technique" data-type="indexterm" id="id749"/></em></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting">&#13;
<code class="kr">import</code> <code class="p">{</code>&#13;
  <code class="nx">AIMessage</code><code class="p">,</code>&#13;
  <code class="nx">BaseMessage</code><code class="p">,</code>&#13;
  <code class="nx">SystemMessage</code><code class="p">,</code>&#13;
  <code class="nx">HumanMessage</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="nx">from</code> <code class="s2">"@langchain/core/messages"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ChatOpenAI</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@langchain/openai"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code>&#13;
  <code class="nx">StateGraph</code><code class="p">,</code>&#13;
  <code class="nx">Annotation</code><code class="p">,</code>&#13;
  <code class="nx">messagesStateReducer</code><code class="p">,</code>&#13;
  <code class="nx">START</code><code class="p">,</code>&#13;
  <code class="nx">END</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="nx">from</code> <code class="s2">"@langchain/langgraph"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">model</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ChatOpenAI</code><code class="p">();</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">annotation</code> <code class="o">=</code> <code class="nx">Annotation</code><code class="p">.</code><code class="nx">Root</code><code class="p">({</code>&#13;
  <code class="nx">messages</code><code class="o">:</code> <code class="nx">Annotation</code><code class="p">({</code> <code class="nx">reducer</code><code class="o">:</code> <code class="nx">messagesStateReducer</code><code class="p">,</code> <code class="k">default</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">[]</code> <code class="p">}),</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// fix multiline string</code>&#13;
<code class="kr">const</code> <code class="nx">generatePrompt</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SystemMessage</code><code class="p">(</code>&#13;
  <code class="sb">`You are an essay assistant tasked with writing excellent 3-paragraph essays.</code>&#13;
<code class="sb">  Generate the best essay possible for the user's request.</code>&#13;
<code class="sb">  If the user provides critique, respond with a revised version of your </code>&#13;
<code class="sb">    previous attempts.`</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="nx">async</code> <code class="kd">function</code> <code class="nx">generate</code><code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">answer</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">model</code><code class="p">.</code><code class="nx">invoke</code><code class="p">([</code><code class="nx">generatePrompt</code><code class="p">,</code> <code class="p">...</code><code class="nx">state</code><code class="p">.</code><code class="nx">messages</code><code class="p">]);</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">messages</code><code class="o">:</code> <code class="p">[</code><code class="nx">answer</code><code class="p">]</code> <code class="p">};</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">reflectionPrompt</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SystemMessage</code><code class="p">(</code>&#13;
  <code class="sb">`You are a teacher grading an essay submission. Generate critique and </code>&#13;
<code class="sb">    recommendations for the user's submission.</code>&#13;
<code class="sb">  Provide detailed recommendations, including requests for length, depth, </code>&#13;
<code class="sb">    style, etc.`</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="nx">async</code> <code class="kd">function</code> <code class="nx">reflect</code><code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Invert the messages to get the LLM to reflect on its own output</code>&#13;
  <code class="kr">const</code> <code class="nx">clsMap</code><code class="o">:</code> <code class="p">{</code> <code class="p">[</code><code class="nx">key</code><code class="o">:</code> <code class="nx">string</code><code class="p">]</code><code class="o">:</code> <code class="k">new</code> <code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">BaseMessage</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">ai</code><code class="o">:</code> <code class="nx">HumanMessage</code><code class="p">,</code>&#13;
    <code class="nx">human</code><code class="o">:</code> <code class="nx">AIMessage</code><code class="p">,</code>&#13;
  <code class="p">};</code>&#13;
  <code class="c1">// First message is the original user request. </code>&#13;
  <code class="c1">// We hold it the same for all nodes</code>&#13;
  <code class="kr">const</code> <code class="nx">translated</code> <code class="o">=</code> <code class="p">[</code>&#13;
    <code class="nx">reflectionPrompt</code><code class="p">,</code>&#13;
    <code class="nx">state</code><code class="p">.</code><code class="nx">messages</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code>&#13;
    <code class="p">...</code><code class="nx">state</code><code class="p">.</code><code class="nx">messages</code>&#13;
      <code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>&#13;
      <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">msg</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nx">clsMap</code><code class="p">[</code><code class="nx">msg</code><code class="p">.</code><code class="nx">_getType</code><code class="p">()](</code><code class="nx">msg</code><code class="p">.</code><code class="nx">content</code> <code class="nx">as</code> <code class="nx">string</code><code class="p">)),</code>&#13;
  <code class="p">];</code>&#13;
  <code class="kr">const</code> <code class="nx">answer</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">model</code><code class="p">.</code><code class="nx">invoke</code><code class="p">(</code><code class="nx">translated</code><code class="p">);</code>&#13;
  <code class="c1">// We treat the output of this as human feedback for the generator</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">messages</code><code class="o">:</code> <code class="p">[</code><code class="k">new</code> <code class="nx">HumanMessage</code><code class="p">({</code> <code class="nx">content</code><code class="o">:</code> <code class="nx">answer</code><code class="p">.</code><code class="nx">content</code> <code class="p">})]</code> <code class="p">};</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">shouldContinue</code><code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">messages</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">6</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// End after 3 iterations, each with 2 messages</code>&#13;
    <code class="k">return</code> <code class="nx">END</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="s2">"reflect"</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">builder</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StateGraph</code><code class="p">(</code><code class="nx">annotation</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"generate"</code><code class="p">,</code> <code class="nx">generate</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"reflect"</code><code class="p">,</code> <code class="nx">reflect</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addEdge</code><code class="p">(</code><code class="nx">START</code><code class="p">,</code> <code class="s2">"generate"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addConditionalEdges</code><code class="p">(</code><code class="s2">"generate"</code><code class="p">,</code> <code class="nx">shouldContinue</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addEdge</code><code class="p">(</code><code class="s2">"reflect"</code><code class="p">,</code> <code class="s2">"generate"</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">graph</code> <code class="o">=</code> <code class="nx">builder</code><code class="p">.</code><code class="nx">compile</code><code class="p">();</code></pre>&#13;
&#13;
<p>The visual representation of the graph is shown in <a data-type="xref" href="#ch07_figure_2_1736545673018506">Figure 7-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="ch07_figure_2_1736545673018506"><img alt="The Reflection architecture" src="assets/lelc_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>The reflection architecture</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice how the <code>reflect</code> node tricks the LLM into thinking it is critiquing essays written by the user. And in tandem, the <code>generate</code> node is made to think that the critique comes from the user. This subterfuge is required because dialogue-tuned LLMs are trained on pairs of human-AI messages, so a sequence of many messages from the same participant would result in poor performance.</p>&#13;
&#13;
<p>One more thing to note: you might, at first glance, expect the end to come after a revise step, but in this architecture we have a fixed number of iterations<a contenteditable="false" data-primary="generate-reflect loop" data-type="indexterm" id="id750"/> of the <code>generate-reflect</code> loop; therefore we terminate after <code>generate</code> (so that the last set of revisions requested are dealt with). A variation on this architecture would instead have the <code>reflect</code> step make the decision to end the process (once it had no more comments).</p>&#13;
&#13;
<p>Let’s see what one of the critiques looks like:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
{&#13;
    'messages': [&#13;
        HumanMessage(content='Your essay on the topicality of "The Little Prince" &#13;
            and its message in modern life is well-written and insightful. You &#13;
            have effectively highlighted the enduring relevance of the book\'s &#13;
            themes and its importance in today\'s society. However, there are a &#13;
            few areas where you could enhance your essay:\n\n1. **Depth**: &#13;
            While you touch upon the themes of cherishing simple joys, &#13;
            nurturing connections, and understanding human relationships, &#13;
            consider delving deeper into each of these themes. Provide specific &#13;
            examples from the book to support your points and explore how these &#13;
            themes manifest in contemporary life.\n\n2. **Analysis**: Consider &#13;
            analyzing how the book\'s messages can be applied to current &#13;
            societal issues or personal experiences. For instance, you could &#13;
            discuss how the Little Prince\'s perspective on materialism relates &#13;
            to consumer culture or explore how his approach to relationships &#13;
            can inform interpersonal dynamics in the digital age.\n\n3. &#13;
            **Length**: Expand on your ideas by adding more examples, &#13;
            discussing counterarguments, or exploring the cultural impact of &#13;
            "The Little Prince" in different parts of the world. This will &#13;
            enrich the depth of your analysis and provide a more comprehensive &#13;
            understanding of the book\'s relevance.\n\n4. **Style**: Your essay &#13;
            is clear and well-structured. To enhance the engagement of your &#13;
            readers, consider incorporating quotes from the book to illustrate &#13;
            key points or including anecdotes to personalize your analysis.&#13;
            \n\n5. **Conclusion**: Conclude your essay by summarizing the &#13;
            enduring significance of "The Little Prince" and how its messages &#13;
            can inspire positive change in modern society. Reflect on the &#13;
            broader implications of the book\'s themes and leave the reader &#13;
            with a lasting impression.\n\nBy expanding on your analysis, &#13;
            incorporating more examples, and deepening your exploration of the &#13;
            book\'s messages, you can create a more comprehensive and &#13;
            compelling essay on the topicality of "The Little Prince" in modern &#13;
            life. Well done on your thoughtful analysis, and keep up the good &#13;
            work!', id='70c22b1d-ec96-4dc3-9fd0-d2c6463f9e2c'),&#13;
    ],&#13;
}</pre>&#13;
&#13;
<p class="pagebreak-before less_space">And the final output:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
{&#13;
    'messages': [&#13;
        AIMessage(content='"The Little Prince" by Antoine de Saint-Exupéry &#13;
            stands as a timeless masterpiece that continues to offer profound &#13;
            insights into human relationships and values, resonating with &#13;
            readers across generations. The narrative of the Little Prince\'s &#13;
            travels and encounters with a myriad of characters serves as a rich &#13;
            tapestry of allegorical representations, ....', response_metadata=&#13;
            {'token_usage': {'completion_tokens': 420, 'prompt_tokens': 2501, &#13;
            'total_tokens': 2921}, 'model_name': 'gpt-3.5-turbo', &#13;
            'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': &#13;
            None}, id='run-2e8f9f13-f625-4820-9c8b-b64e1c23daa2-0', &#13;
            usage_metadata={'input_tokens': 2501, 'output_tokens': 420, &#13;
            'total_tokens': 2921}),&#13;
    ],&#13;
}</pre>&#13;
&#13;
<p>This simple type of reflection can sometimes improve performance by giving the LLM multiple attempts at refining its output and by letting the reflection node adopt a different persona while critiquing the output.</p>&#13;
&#13;
<p>There are several possible variations of this architecture. For one, we could combine the reflection step with the agent architecture of <a data-type="xref" href="ch06.html#ch06_agent_architecture_1736545671750341">Chapter 6</a>, adding it as the last node right before sending output to the user. This would make the critique appear to come from the user, and give the application a chance to improve its final output without direct user intervention. Obviously this approach would come at the expense of higher latency.</p>&#13;
&#13;
<p>In certain use cases, it could be helpful to ground the critique with external information. For instance, if you were writing a code-generation agent, you could have a step before <code>reflect</code> that would run the code through a linter or compiler and report any errors as input to <code>reflect</code>.</p>&#13;
&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Whenever this approach is possible, we strongly recommend giving it a try, as it’s likely to increase the quality of the final output.<a contenteditable="false" data-primary="" data-startref="AAreflection07" data-type="indexterm" id="id751"/><a contenteditable="false" data-primary="" data-startref="rpt07" data-type="indexterm" id="id752"/><a contenteditable="false" data-primary="" data-startref="Preflect07" data-type="indexterm" id="id753"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Subgraphs in LangGraph" data-type="sect1"><div class="sect1" id="ch07_subgraphs_in_langgraph_1736545673023832">&#13;
<h1>Subgraphs in LangGraph</h1>&#13;
&#13;
<p>Before<a contenteditable="false" data-primary="subgraphs" data-secondary="use cases for" data-type="indexterm" id="id754"/><a contenteditable="false" data-primary="LangGraph" data-secondary="subgraphs" data-type="indexterm" id="LGsub07"/> we dive into multi-agent architectures, let’s look at an important technical concept in LangGraph that enables it. <em>Subgraphs</em> are graphs that are used as part of another graph. Here are some use cases for subgraphs:</p>&#13;
&#13;
<ul class="pagebreak-before less_space">&#13;
	<li>&#13;
	<p>Building multi-agent systems (discussed in the next section).</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>When you want to reuse a set of nodes in multiple graphs, you can define them once in a subgraph and then use them in multiple parent graphs.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>When you want different teams to work on different parts of the graph independently, you can define each part as a subgraph, and as long as the subgraph interface (the input and output schemas) is respected, the parent graph can be built without knowing any details of the subgraph.</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>There<a contenteditable="false" data-primary="subgraphs" data-secondary="adding to parent graphs" data-type="indexterm" id="id755"/> are two ways to add subgraph nodes to a parent graph:</p>&#13;
&#13;
<dl>&#13;
	<dt>Add a node that calls the subgraph directly</dt>&#13;
	<dd>&#13;
	<p>This is useful when the parent graph and the subgraph share state keys, and you don’t need to transform state on the way in or out.</p>&#13;
	</dd>&#13;
	<dt>Add a node with a function that invokes the subgraph</dt>&#13;
	<dd>&#13;
	<p>This is useful when the parent graph and the subgraph have different state schemas, and you need to transform state before or after calling the subgraph.</p>&#13;
	</dd>&#13;
</dl>&#13;
&#13;
<p>Let’s look at each in turn.</p>&#13;
&#13;
<section data-pdf-bookmark="Calling a Subgraph Directly" data-type="sect2"><div class="sect2" id="ch07_calling_a_subgraph_directly_1736545673023898">&#13;
<h2>Calling a Subgraph Directly</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="subgraphs" data-secondary="calling subgraphs directly" data-type="indexterm" id="Sdirect07"/> simplest way to create subgraph nodes is to attach a subgraph directly as a node. When doing so, it is important that the parent graph and the subgraph share state keys, because those shared keys will be used to communicate. (If your graph and subgraph do not share any keys, see the next section.)</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you pass extra keys to the subgraph node (that is, in addition to the shared keys), they will be ignored by the subgraph node. Similarly, if you return extra keys from the subgraph, they will be ignored by the parent graph.</p>&#13;
</div>&#13;
&#13;
<p>Let’s see what it looks like in action:</p>&#13;
&#13;
<p><em>Python<a contenteditable="false" data-primary="Python" data-secondary="subgraphs" data-tertiary="calling directly" data-type="indexterm" id="id756"/></em></p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">langgraph.graph</code> <code class="kn">import</code> <code class="n">START</code><code class="p">,</code> <code class="n">StateGraph</code>&#13;
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">TypedDict</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">State</code><code class="p">(</code><code class="n">TypedDict</code><code class="p">):</code>&#13;
    <code class="n">foo</code><code class="p">:</code> <code class="nb">str</code> <code class="c1"># this key is shared with the subgraph</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">SubgraphState</code><code class="p">(</code><code class="n">TypedDict</code><code class="p">):</code>&#13;
    <code class="n">foo</code><code class="p">:</code> <code class="nb">str</code> <code class="c1"># this key is shared with the parent graph</code>&#13;
    <code class="n">bar</code><code class="p">:</code> <code class="nb">str</code>&#13;
&#13;
<code class="c1"># Define subgraph</code>&#13;
<code class="k">def</code> <code class="nf">subgraph_node</code><code class="p">(</code><code class="n">state</code><code class="p">:</code> <code class="n">SubgraphState</code><code class="p">):</code>&#13;
    <code class="c1"># note that this subgraph node can communicate with the parent graph </code>&#13;
    <code class="c1"># via the shared "foo" key</code>&#13;
    <code class="k">return</code> <code class="p">{</code><code class="s2">"foo"</code><code class="p">:</code> <code class="n">state</code><code class="p">[</code><code class="s2">"foo"</code><code class="p">]</code> <code class="o">+</code> <code class="s2">"bar"</code><code class="p">}</code>&#13;
&#13;
<code class="n">subgraph_builder</code> <code class="o">=</code> <code class="n">StateGraph</code><code class="p">(</code><code class="n">SubgraphState</code><code class="p">)</code>&#13;
<code class="n">subgraph_builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="n">subgraph_node</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="n">subgraph</code> <code class="o">=</code> <code class="n">subgraph_builder</code><code class="o">.</code><code class="n">compile</code><code class="p">()</code>&#13;
&#13;
<code class="c1"># Define parent graph</code>&#13;
<code class="n">builder</code> <code class="o">=</code> <code class="n">StateGraph</code><code class="p">(</code><code class="n">State</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="s2">"subgraph"</code><code class="p">,</code> <code class="n">subgraph</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="n">graph</code> <code class="o">=</code> <code class="n">builder</code><code class="o">.</code><code class="n">compile</code><code class="p">()</code></pre>&#13;
&#13;
<p><em>JavaScript<a contenteditable="false" data-primary="JavaScript" data-secondary="subgraphs" data-tertiary="calling directly" data-type="indexterm" id="id757"/></em></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting">&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">StateGraph</code><code class="p">,</code> <code class="nx">Annotation</code><code class="p">,</code> <code class="nx">START</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@langchain/langgraph"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">StateAnnotation</code> <code class="o">=</code> <code class="nx">Annotation</code><code class="p">.</code><code class="nx">Root</code><code class="p">({</code>&#13;
  <code class="nx">foo</code><code class="o">:</code> <code class="nx">Annotation</code><code class="p">(),</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">SubgraphStateAnnotation</code> <code class="o">=</code> <code class="nx">Annotation</code><code class="p">.</code><code class="nx">Root</code><code class="p">({</code>&#13;
  <code class="c1">// note that this key is shared with the parent graph state</code>&#13;
  <code class="nx">foo</code><code class="o">:</code> <code class="nx">Annotation</code><code class="p">(),</code> &#13;
  <code class="nx">bar</code><code class="o">:</code> <code class="nx">Annotation</code><code class="p">(),</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// Define subgraph</code>&#13;
<code class="kr">const</code> <code class="nx">subgraphNode</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// note that this subgraph node can communicate with</code>&#13;
  <code class="c1">// the parent graph via the shared "foo" key</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">foo</code><code class="o">:</code> <code class="nx">state</code><code class="p">.</code><code class="nx">foo</code> <code class="o">+</code> <code class="s2">"bar"</code> <code class="p">};</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">subgraph</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StateGraph</code><code class="p">(</code><code class="nx">SubgraphStateAnnotation</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"subgraph"</code><code class="p">,</code> <code class="nx">subgraphNode</code><code class="p">);</code>&#13;
  <code class="p">...</code>&#13;
  <code class="p">.</code><code class="nx">compile</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Define parent graph</code>&#13;
<code class="kr">const</code> <code class="nx">parentGraph</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StateGraph</code><code class="p">(</code><code class="nx">StateAnnotation</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"subgraph"</code><code class="p">,</code> <code class="nx">subgraph</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addEdge</code><code class="p">(</code><code class="nx">START</code><code class="p">,</code> <code class="s2">"subgraph"</code><code class="p">)</code>&#13;
  <code class="c1">// Additional parent graph setup would go here</code>&#13;
  <code class="p">.</code><code class="nx">compile</code><code class="p">();</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
<section data-pdf-bookmark="Calling a Subgraph with a Function" data-type="sect2"><div class="sect2" id="ch07_calling_a_subgraph_with_a_function_1736545673023962">&#13;
<h2>Calling a Subgraph with a Function</h2>&#13;
&#13;
<p>You<a contenteditable="false" data-primary="" data-startref="Sdirect07" data-type="indexterm" id="id758"/><a contenteditable="false" data-primary="subgraphs" data-secondary="calling subgraphs with functions" data-type="indexterm" id="id759"/> might want to define a subgraph with a completely different schema. In that case, you can create a node with a function that invokes the subgraph. This function will need to transform the input (parent) state to the subgraph state before invoking the subgraph and transform the results back to the parent state before returning the state update from the node.</p>&#13;
&#13;
<p>Let’s see what it looks like:</p>&#13;
&#13;
<p><em>Python<a contenteditable="false" data-primary="Python" data-secondary="subgraphs" data-tertiary="calling with functions" data-type="indexterm" id="id760"/></em></p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<code class="k">class</code> <code class="nc">State</code><code class="p">(</code><code class="n">TypedDict</code><code class="p">):</code>&#13;
    <code class="n">foo</code><code class="p">:</code> <code class="nb">str</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">SubgraphState</code><code class="p">(</code><code class="n">TypedDict</code><code class="p">):</code>&#13;
    <code class="c1"># none of these keys are shared with the parent graph state</code>&#13;
    <code class="n">bar</code><code class="p">:</code> <code class="nb">str</code>&#13;
    <code class="n">baz</code><code class="p">:</code> <code class="nb">str</code>&#13;
&#13;
<code class="c1"># Define subgraph</code>&#13;
<code class="k">def</code> <code class="nf">subgraph_node</code><code class="p">(</code><code class="n">state</code><code class="p">:</code> <code class="n">SubgraphState</code><code class="p">):</code>&#13;
    <code class="k">return</code> <code class="p">{</code><code class="s2">"bar"</code><code class="p">:</code> <code class="n">state</code><code class="p">[</code><code class="s2">"bar"</code><code class="p">]</code> <code class="o">+</code> <code class="s2">"baz"</code><code class="p">}</code>&#13;
&#13;
<code class="n">subgraph_builder</code> <code class="o">=</code> <code class="n">StateGraph</code><code class="p">(</code><code class="n">SubgraphState</code><code class="p">)</code>&#13;
<code class="n">subgraph_builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="n">subgraph_node</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="n">subgraph</code> <code class="o">=</code> <code class="n">subgraph_builder</code><code class="o">.</code><code class="n">compile</code><code class="p">()</code>&#13;
&#13;
<code class="c1"># Define parent graph</code>&#13;
<code class="k">def</code> <code class="nf">node</code><code class="p">(</code><code class="n">state</code><code class="p">:</code> <code class="n">State</code><code class="p">):</code>&#13;
    <code class="c1"># transform the state to the subgraph state</code>&#13;
    <code class="n">response</code> <code class="o">=</code> <code class="n">subgraph</code><code class="o">.</code><code class="n">invoke</code><code class="p">({</code><code class="s2">"bar"</code><code class="p">:</code> <code class="n">state</code><code class="p">[</code><code class="s2">"foo"</code><code class="p">]})</code>&#13;
    <code class="c1"># transform response back to the parent state</code>&#13;
    <code class="k">return</code> <code class="p">{</code><code class="s2">"foo"</code><code class="p">:</code> <code class="n">response</code><code class="p">[</code><code class="s2">"bar"</code><code class="p">]}</code>&#13;
&#13;
<code class="n">builder</code> <code class="o">=</code> <code class="n">StateGraph</code><code class="p">(</code><code class="n">State</code><code class="p">)</code>&#13;
<code class="c1"># note that we are using `node` function instead of a compiled subgraph</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="n">node</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="n">graph</code> <code class="o">=</code> <code class="n">builder</code><code class="o">.</code><code class="n">compile</code><code class="p">()</code></pre>&#13;
&#13;
<p><em>JavaScript<a contenteditable="false" data-primary="JavaScript" data-secondary="subgraphs" data-tertiary="calling with functions" data-type="indexterm" id="id761"/></em></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting">&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">StateGraph</code><code class="p">,</code> <code class="nx">START</code><code class="p">,</code> <code class="nx">Annotation</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@langchain/langgraph"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">StateAnnotation</code> <code class="o">=</code> <code class="nx">Annotation</code><code class="p">.</code><code class="nx">Root</code><code class="p">({</code>&#13;
  <code class="nx">foo</code><code class="o">:</code> <code class="nx">Annotation</code><code class="p">(),</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">SubgraphStateAnnotation</code> <code class="o">=</code> <code class="nx">Annotation</code><code class="p">.</code><code class="nx">Root</code><code class="p">({</code>&#13;
  <code class="c1">// note that none of these keys are shared with the parent graph state</code>&#13;
  <code class="nx">bar</code><code class="o">:</code> <code class="nx">Annotation</code><code class="p">(),</code>&#13;
  <code class="nx">baz</code><code class="o">:</code> <code class="nx">Annotation</code><code class="p">(),</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// Define subgraph</code>&#13;
<code class="kr">const</code> <code class="nx">subgraphNode</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">bar</code><code class="o">:</code> <code class="nx">state</code><code class="p">.</code><code class="nx">bar</code> <code class="o">+</code> <code class="s2">"baz"</code> <code class="p">};</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">subgraph</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StateGraph</code><code class="p">(</code><code class="nx">SubgraphStateAnnotation</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"subgraph"</code><code class="p">,</code> <code class="nx">subgraphNode</code><code class="p">);</code>&#13;
  <code class="p">...</code>&#13;
  <code class="p">.</code><code class="nx">compile</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Define parent graph</code>&#13;
<code class="kr">const</code> <code class="nx">subgraphWrapperNode</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// transform the state to the subgraph state</code>&#13;
  <code class="kr">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">subgraph</code><code class="p">.</code><code class="nx">invoke</code><code class="p">({</code>&#13;
    <code class="nx">bar</code><code class="o">:</code> <code class="nx">state</code><code class="p">.</code><code class="nx">foo</code><code class="p">,</code>&#13;
  <code class="p">});</code>&#13;
  <code class="c1">// transform response back to the parent state</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
    <code class="nx">foo</code><code class="o">:</code> <code class="nx">response</code><code class="p">.</code><code class="nx">bar</code><code class="p">,</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">parentGraph</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StateGraph</code><code class="p">(</code><code class="nx">StateAnnotation</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"subgraph"</code><code class="p">,</code> <code class="nx">subgraphWrapperNode</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addEdge</code><code class="p">(</code><code class="nx">START</code><code class="p">,</code> <code class="s2">"subgraph"</code><code class="p">)</code>&#13;
  <code class="c1">// Additional parent graph setup would go here</code>&#13;
  <code class="p">.</code><code class="nx">compile</code><code class="p">();</code></pre>&#13;
&#13;
<p>Now that we know how to use subgraphs, let’s take a look at one of the big use cases for them: multi-agent architectures.<a contenteditable="false" data-primary="" data-startref="LGsub07" data-type="indexterm" id="id762"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Multi-Agent Architectures" data-type="sect1"><div class="sect1" id="ch07_multi_agent_architectures_1736545673024024">&#13;
<h1>Multi-Agent Architectures</h1>&#13;
&#13;
<p>As<a contenteditable="false" data-primary="agent architecture" data-secondary="multi-agent architectures" data-type="indexterm" id="AAmulti07"/><a contenteditable="false" data-primary="multi-agent architectures" data-type="indexterm" id="multiagent07"/> LLM agents grow in size, scope, or complexity, several issues can show up and impact their performance, such as the following:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>The<a contenteditable="false" data-primary="tool-calling technique" data-secondary="dealing with many tools" data-type="indexterm" id="id763"/> agent is given too many tools to choose from and makes poor decisions about which tool to call next (<a data-type="xref" href="ch06.html#ch06_agent_architecture_1736545671750341">Chapter 6</a> discussed some approaches to this problem).</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>The<a contenteditable="false" data-primary="context" data-secondary="dealing with complex" data-type="indexterm" id="id764"/> context grows too complex for a single agent to keep track of; that is, the size of the prompts and the number of things they mention grows beyond the capability of the model you’re using.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>You<a contenteditable="false" data-primary="specialized subsystems" data-type="indexterm" id="id765"/><a contenteditable="false" data-primary="subsystems, specialized" data-type="indexterm" id="id766"/> want to use a specialized subsystem for a particular area, for instance, planning, research, solving math problems, and so on.</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>To tackle these problems, you might consider breaking your application into multiple smaller, independent agents<a contenteditable="false" data-primary="independent agents" data-type="indexterm" id="id767"/> and composing them into a multi-agent system. These independent agents can be as simple as a prompt and an LLM call or as complex as a ReAct agent (introduced in <a data-type="xref" href="ch06.html#ch06_agent_architecture_1736545671750341">Chapter 6</a>). <a data-type="xref" href="#ch07_figure_3_1736545673018556">Figure 7-3</a> illustrates several ways to connect agents in a multi-agent system.</p>&#13;
&#13;
<figure><div class="figure" id="ch07_figure_3_1736545673018556"><img alt="A diagram of a network  Description automatically generated" src="assets/lelc_0703.png"/>&#13;
<h6><span class="label">Figure 7-3. </span>Multiple strategies for coordinating multiple agents</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s look at <a data-type="xref" href="#ch07_figure_3_1736545673018556">Figure 7-3</a> in more detail:</p>&#13;
&#13;
<dl>&#13;
	<dt>Network</dt>&#13;
	<dd>&#13;
	<p>Each agent can communicate with every other agent. Any agent can decide which other agent is to be executed next.</p>&#13;
	</dd>&#13;
	<dt>Supervisor</dt>&#13;
	<dd>&#13;
	<p>Each<a contenteditable="false" data-primary="supervisor architecture" data-type="indexterm" id="suparch07"/> agent communicates with a single agent, called the <em>supervisor</em>. The supervisor agent makes decisions on which agent (or agents) should be called next. A special case of this architecture implements the supervisor agent as an LLM call with tools, as covered in <a data-type="xref" href="ch06.html#ch06_agent_architecture_1736545671750341">Chapter 6</a>.</p>&#13;
	</dd>&#13;
	<dt>Hierarchical</dt>&#13;
	<dd>&#13;
	<p class="fix_tracking">You can define a multi-agent system with a supervisor of supervisors. This is a generalization of the supervisor architecture and allows for more complex control flows.</p>&#13;
	</dd>&#13;
	<dt>Custom multi-agent workflow</dt>&#13;
	<dd>&#13;
	<p>Each agent communicates with only a subset of agents. Parts of the flow are deterministic, and only select agents can decide which other agents to call next.</p>&#13;
	</dd>&#13;
</dl>&#13;
&#13;
<p>The next section dives deeper into the supervisor architecture, which we think has a good balance of capability and ease of use.</p>&#13;
&#13;
<section data-pdf-bookmark="Supervisor Architecture" data-type="sect2"><div class="sect2" id="ch07_supervisor_architecture_1736545673024083">&#13;
<h2>Supervisor Architecture</h2>&#13;
&#13;
<p>In this architecture, we add each agent to the graph as a node and also add a supervisor node, which decides which agents should be called next. We use conditional edges to route execution to the appropriate agent node based on the supervisor’s decision. Refer back to <a data-type="xref" href="ch05.html#ch05_cognitive_architectures_with_langgraph_1736545670030774">Chapter 5</a> for an introduction to LangGraph, which goes over the concepts of nodes, edges, and more.</p>&#13;
&#13;
<p>Let’s first see what the supervisor node looks like:</p>&#13;
&#13;
<p><em>Python<a contenteditable="false" data-primary="Python" data-secondary="agent architecture" data-tertiary="supervisor" data-type="indexterm" id="id768"/></em></p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Literal</code>&#13;
<code class="kn">from</code> <code class="nn">langchain_openai</code> <code class="kn">import</code> <code class="n">ChatOpenAI</code>&#13;
<code class="kn">from</code> <code class="nn">pydantic</code> <code class="kn">import</code> <code class="n">BaseModel</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">SupervisorDecision</code><code class="p">(</code><code class="n">BaseModel</code><code class="p">):</code>&#13;
    <code class="nb">next</code><code class="p">:</code> <code class="n">Literal</code><code class="p">[</code><code class="s2">"researcher"</code><code class="p">,</code> <code class="s2">"coder"</code><code class="p">,</code> <code class="s2">"FINISH"</code><code class="p">]</code>&#13;
&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">ChatOpenAI</code><code class="p">(</code><code class="n">model</code><code class="o">=</code><code class="s2">"gpt-4o"</code><code class="p">,</code> <code class="n">temperature</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">with_structured_output</code><code class="p">(</code><code class="n">SupervisorDecision</code><code class="p">)</code>&#13;
&#13;
<code class="n">agents</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"researcher"</code><code class="p">,</code> <code class="s2">"coder"</code><code class="p">]</code>&#13;
&#13;
<code class="n">system_prompt_part_1</code> <code class="o">=</code> <code class="sa">f</code><code class="s2">"""You are a supervisor tasked with managing a </code>&#13;
<code class="s2">conversation between the following workers: </code><code class="si">{</code><code class="n">agents</code><code class="si">}</code><code class="s2">. Given the following user </code>&#13;
<code class="s2">request, respond with the worker to act next. Each worker will perform a</code>&#13;
<code class="s2">task and respond with their results and status. When finished,</code>&#13;
<code class="s2">respond with FINISH."""</code>&#13;
&#13;
<code class="n">system_prompt_part_2</code> <code class="o">=</code> <code class="sa">f</code><code class="s2">"""Given the conversation above, who should act next? Or </code>&#13;
<code class="s2">    should we FINISH? Select one of: </code><code class="si">{</code><code class="s1">', '</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">agents</code><code class="p">)</code><code class="si">}</code><code class="s2">, FINISH"""</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">supervisor</code><code class="p">(</code><code class="n">state</code><code class="p">):</code>&#13;
    <code class="n">messages</code> <code class="o">=</code> <code class="p">[</code>&#13;
        <code class="p">(</code><code class="s2">"system"</code><code class="p">,</code> <code class="n">system_prompt_part_1</code><code class="p">),</code>&#13;
        <code class="o">*</code><code class="n">state</code><code class="p">[</code><code class="s2">"messages"</code><code class="p">],</code>&#13;
        <code class="p">(</code><code class="s2">"system"</code><code class="p">,</code> 	<code class="n">system_prompt_part_2</code><code class="p">)</code>&#13;
    <code class="p">]</code>&#13;
    <code class="k">return</code> <code class="n">model</code><code class="o">.</code><code class="n">invoke</code><code class="p">(</code><code class="n">messages</code><code class="p">)</code></pre>&#13;
&#13;
<p><em>JavaScript<a contenteditable="false" data-primary="JavaScript" data-secondary="agent architecture" data-tertiary="supervisor" data-type="indexterm" id="id769"/></em></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting">&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ChatOpenAI</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'langchain-openai'</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">z</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'zod'</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">SupervisorDecision</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="nx">object</code><code class="p">({</code>&#13;
  <code class="nx">next</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="kr">enum</code><code class="p">([</code><code class="s1">'researcher'</code><code class="p">,</code> <code class="s1">'coder'</code><code class="p">,</code> <code class="s1">'FINISH'</code><code class="p">]),</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">model</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ChatOpenAI</code><code class="p">({</code> <code class="nx">model</code><code class="o">:</code> <code class="s1">'gpt-4o'</code><code class="p">,</code> <code class="nx">temperature</code><code class="o">:</code> <code class="mi">0</code> <code class="p">});</code>&#13;
<code class="kr">const</code> <code class="nx">modelWithStructuredOutput</code> <code class="o">=</code> <code class="nx">model</code><code class="p">.</code><code class="nx">withStructuredOutput</code><code class="p">(</code><code class="nx">SupervisorDecision</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">agents</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'researcher'</code><code class="p">,</code> <code class="s1">'coder'</code><code class="p">];</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">systemPromptPart1</code> <code class="o">=</code> <code class="sb">`You are a supervisor tasked with managing a </code>&#13;
<code class="sb">  conversation between the following workers: </code><code class="si">${</code><code class="nx">agents</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">', '</code><code class="p">)</code><code class="si">}</code><code class="sb">. Given the </code>&#13;
<code class="sb">  following user request, respond with the worker to act next. Each worker </code>&#13;
<code class="sb">  will perform a task and respond with their results and status. When </code>&#13;
<code class="sb">  finished, respond with FINISH.`</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">systemPromptPart2</code> <code class="o">=</code> <code class="sb">`Given the conversation above, who should act next? Or </code>&#13;
<code class="sb">  should we FINISH? Select one of: </code><code class="si">${</code><code class="nx">agents</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">', '</code><code class="p">)</code><code class="si">}</code><code class="sb">, FINISH`</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">supervisor</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">messages</code> <code class="o">=</code> <code class="p">[</code>&#13;
    <code class="p">{</code> <code class="nx">role</code><code class="o">:</code> <code class="s1">'system'</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="nx">systemPromptPart1</code> <code class="p">},</code>&#13;
    <code class="p">...</code><code class="nx">state</code><code class="p">.</code><code class="nx">messages</code><code class="p">,</code>&#13;
    <code class="p">{</code> <code class="nx">role</code><code class="o">:</code> <code class="s1">'system'</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="nx">systemPromptPart2</code> <code class="p">}</code>&#13;
  <code class="p">];</code>&#13;
&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">modelWithStructuredOutput</code><code class="p">.</code><code class="nx">invoke</code><code class="p">({</code> <code class="nx">messages</code> <code class="p">});</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The code in the prompt requires the names of your<a contenteditable="false" data-primary="subagents" data-type="indexterm" id="id770"/> subagents to be self-explanatory and distinct. For instance, if they were simply called <code>agent_1</code> and <code>agent_2</code>, the LLM would have no information to decide which one is appropriate for each task. If needed, you could modify the prompt to add a description of each agent, which could help the LLM in picking an agent for each query.</p>&#13;
</div>&#13;
&#13;
<p>Now let’s see how to integrate this supervisor node into a larger graph that includes two other subagents, which we will call researcher and coder. Our overall goal with this graph is to handle queries that can be answered either by the researcher by itself or the coder by itself, or even both of them in succession. This example doesn’t include implementations for either the researcher or coder—the key idea is they could be any other LangGraph graph or node:</p>&#13;
&#13;
<p><em>Python<a contenteditable="false" data-primary="Python" data-secondary="agent architecture" data-tertiary="subagents" data-type="indexterm" id="id771"/></em></p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Literal</code>&#13;
<code class="kn">from</code> <code class="nn">langchain_openai</code> <code class="kn">import</code> <code class="n">ChatOpenAI</code>&#13;
<code class="kn">from</code> <code class="nn">langgraph.graph</code> <code class="kn">import</code> <code class="n">StateGraph</code><code class="p">,</code> <code class="n">MessagesState</code><code class="p">,</code> <code class="n">START</code>&#13;
&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">ChatOpenAI</code><code class="p">()</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">AgentState</code><code class="p">(</code><code class="n">BaseModel</code><code class="p">):</code>&#13;
    <code class="nb">next</code><code class="p">:</code> <code class="n">Literal</code><code class="p">[</code><code class="s2">"researcher"</code><code class="p">,</code> <code class="s2">"coder"</code><code class="p">,</code> <code class="s2">"FINISH"</code><code class="p">]</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">researcher</code><code class="p">(</code><code class="n">state</code><code class="p">:</code> <code class="n">AgentState</code><code class="p">):</code>&#13;
    <code class="n">response</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">invoke</code><code class="p">(</code><code class="o">...</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">{</code><code class="s2">"messages"</code><code class="p">:</code> <code class="p">[</code><code class="n">response</code><code class="p">]}</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">coder</code><code class="p">(</code><code class="n">state</code><code class="p">:</code> <code class="n">AgentState</code><code class="p">):</code>&#13;
    <code class="n">response</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">invoke</code><code class="p">(</code><code class="o">...</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">{</code><code class="s2">"messages"</code><code class="p">:</code> <code class="p">[</code><code class="n">response</code><code class="p">]}</code>&#13;
&#13;
<code class="n">builder</code> <code class="o">=</code> <code class="n">StateGraph</code><code class="p">(</code><code class="n">AgentState</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="n">supervisor</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="n">researcher</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_node</code><code class="p">(</code><code class="n">coder</code><code class="p">)</code>&#13;
&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_edge</code><code class="p">(</code><code class="n">START</code><code class="p">,</code> <code class="s2">"supervisor"</code><code class="p">)</code>&#13;
<code class="c1"># route to one of the agents or exit based on the supervisor's decision</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_conditional_edges</code><code class="p">(</code><code class="s2">"supervisor"</code><code class="p">,</code> <code class="k">lambda</code> <code class="n">state</code><code class="p">:</code> <code class="n">state</code><code class="p">[</code><code class="s2">"next"</code><code class="p">])</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_edge</code><code class="p">(</code><code class="s2">"researcher"</code><code class="p">,</code> <code class="s2">"supervisor"</code><code class="p">)</code>&#13;
<code class="n">builder</code><code class="o">.</code><code class="n">add_edge</code><code class="p">(</code><code class="s2">"coder"</code><code class="p">,</code> <code class="s2">"supervisor"</code><code class="p">)</code>&#13;
&#13;
<code class="n">supervisor</code> <code class="o">=</code> <code class="n">builder</code><code class="o">.</code><code class="n">compile</code><code class="p">()</code></pre>&#13;
&#13;
<p><em>JavaScript<a contenteditable="false" data-primary="JavaScript" data-secondary="agent architecture" data-tertiary="subagents" data-type="indexterm" id="id772"/></em></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting">&#13;
<code class="kr">import</code> <code class="p">{</code>&#13;
  <code class="nx">StateGraph</code><code class="p">,</code>&#13;
  <code class="nx">Annotation</code><code class="p">,</code>&#13;
  <code class="nx">MessagesAnnotation</code><code class="p">,</code>&#13;
  <code class="nx">START</code><code class="p">,</code>&#13;
  <code class="nx">END</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="nx">from</code> <code class="s2">"@langchain/langgraph"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ChatOpenAI</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@langchain/openai"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">model</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ChatOpenAI</code><code class="p">({</code>&#13;
  <code class="nx">model</code><code class="o">:</code> <code class="s2">"gpt-4o"</code><code class="p">,</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">StateAnnotation</code> <code class="o">=</code> <code class="nx">Annotation</code><code class="p">.</code><code class="nx">Root</code><code class="p">({</code>&#13;
  <code class="p">...</code><code class="nx">MessagesAnnotation</code><code class="p">.</code><code class="nx">spec</code><code class="p">,</code>&#13;
  <code class="nx">next</code><code class="o">:</code> <code class="nx">Annotation</code><code class="p">(),</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">researcher</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">model</code><code class="p">.</code><code class="nx">invoke</code><code class="p">(...);</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">messages</code><code class="o">:</code> <code class="p">[</code><code class="nx">response</code><code class="p">]</code> <code class="p">};</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">coder</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">model</code><code class="p">.</code><code class="nx">invoke</code><code class="p">(...);</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">messages</code><code class="o">:</code> <code class="p">[</code><code class="nx">response</code><code class="p">]</code> <code class="p">};</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">graph</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StateGraph</code><code class="p">(</code><code class="nx">StateAnnotation</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"supervisor"</code><code class="p">,</code> <code class="nx">supervisor</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"researcher"</code><code class="p">,</code> <code class="nx">researcher</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addNode</code><code class="p">(</code><code class="s2">"coder"</code><code class="p">,</code> <code class="nx">coder</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addEdge</code><code class="p">(</code><code class="nx">START</code><code class="p">,</code> <code class="s2">"supervisor"</code><code class="p">)</code>&#13;
  <code class="c1">// route to one of the agents or exit based on the supervisor's decision</code>&#13;
  <code class="p">.</code><code class="nx">addConditionalEdges</code><code class="p">(</code><code class="s2">"supervisor"</code><code class="p">,</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="o">=&gt;</code> &#13;
    <code class="nx">state</code><code class="p">.</code><code class="nx">next</code> <code class="o">===</code> <code class="s1">'FINISH'</code> <code class="o">?</code> <code class="nx">END</code> <code class="o">:</code> <code class="nx">state</code><code class="p">.</code><code class="nx">next</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addEdge</code><code class="p">(</code><code class="s2">"researcher"</code><code class="p">,</code> <code class="s2">"supervisor"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">addEdge</code><code class="p">(</code><code class="s2">"coder"</code><code class="p">,</code> <code class="s2">"supervisor"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">compile</code><code class="p">();</code></pre>&#13;
&#13;
<p class="fix_tracking">A few things to notice: In this example, both subagents (researcher and coder) can see each other’s work, as all progress is recorded in the messages list. This isn’t the only way to organize this. Each of the subagents could be more complex. For instance, a subagent could be its own graph that maintains internal state and only outputs a summary of the work it did.</p>&#13;
&#13;
<p>After each agent executes, we route back to the supervisor node, which decides if there is more work to be done and which agent to delegate that to if so. This routing isn’t a hard requirement for this architecture; we could have each subagent make a decision as to whether its output should be returned directly to the user. To do that, we’d replace the hard edge between, say, researcher and supervisor, with a conditional edge (which would read some state key updated by researcher).<a contenteditable="false" data-primary="" data-startref="AAmulti07" data-type="indexterm" id="id773"/><a contenteditable="false" data-primary="" data-startref="multiagent07" data-type="indexterm" id="id774"/><a contenteditable="false" data-primary="" data-startref="suparch07" data-type="indexterm" id="id775"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="ch07_summary_1736545673024137">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter covered two important extensions to the agent architecture: reflection and multi-agent architectures. The chapter also looked at how to work with subgraphs in LangGraph, which are a key building block for multi-agent systems.</p>&#13;
&#13;
<p>These extensions add more power to the LLM agent architecture, but they shouldn’t be the first thing you reach for when creating a new agent. The best place to start is usually the straightforward architecture we discussed in <a data-type="xref" href="ch06.html#ch06_agent_architecture_1736545671750341">Chapter 6</a>.</p>&#13;
&#13;
<p><a data-type="xref" href="ch08.html#ch08_patterns_to_make_the_most_of_llms_1736545674143600">Chapter 8</a> returns to the trade-off between reliability and agency, which is the key design decision when building LLM apps today. This is especially important when using the agent or multi-agent architectures, as their power comes at the expense of reliability if left unchecked. After diving deeper into why this trade-off exists, <a data-type="xref" href="ch08.html#ch08_patterns_to_make_the_most_of_llms_1736545674143600">Chapter 8</a> will cover the most important techniques at your disposal to navigate that decision, and ultimately improve your LLM applications and agents.</p>&#13;
</div></section>&#13;
</div></section></body></html>