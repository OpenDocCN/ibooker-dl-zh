<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div class="readable-text" id="p1">
<h1 class="readable-text-h"><span class="calibre22"><span class="calibre22">6</span></span> <span class="calibre22">Testing and prompt engineering</span></h1>
</div>
<div class="readable-text">
<h3 class="introduction-header">This chapter covers</h3>
<ul class="calibre24">
<li class="readable-text1" id="p2">Understanding the importance of testing Copilot code</li>
<li class="readable-text1" id="p3">Using closed-box versus open-box testing</li>
<li class="readable-text1" id="p4">Addressing errors by Copilot by modifying prompts</li>
<li class="readable-text1" id="p5">Working through examples of testing Copilot-generated code </li>
</ul>
</div>
<div class="readable-text" id="p6">
<p class="calibre15">In chapter 3, we first started to see the importance of testing the code produced by Copilot. Testing is an essential skill for anyone writing software because it gives you confidence that the code is functioning properly. In this chapter, we’ll learn how to test our code thoroughly and how to help Copilot fix code that doesn’t work by modifying our prompts.</p>
</div>
<div class="readable-text" id="p7">
<p class="calibre15">Testing is an essential skill that you’ll need to learn how to do well on your own, so that you’re able to check that the code works correctly. Copilot can generate tests and has been improving in the quality of tests it produces, but we encourage you to hold off on using Copilot to generate tests just yet because you need to learn to do this well enough on your own to be able to verify that the tests Copilot produces are reasonable. This will be true of the next few chapters as well—problem decomposition, testing, and debugging are all skills that are essential to learn how to do on your own, before asking for Copilot’s help, as you need to know how to do it on your own to know if Copilot is doing something reasonable.</p>
</div>
<div class="readable-text" id="p8">
<h2 class="readable-text-h1" id="sigil_toc_id_77"><span class="calibre22">6.1</span> Why it’s crucial to test code</h2>
</div>
<div class="readable-text" id="p9">
<p class="calibre15">Back in chapter 3, we mentioned that you should test code to make sure it’s correct. Unfortunately, in our experience, beginning programmers seem to have an aversion to testing! Why? We think a couple of things are at play. The first is that there’s this well-documented problem nicknamed the <em class="calibre18">Superbug</em>, which is that humans, when first learning to code, think the computer can understand the intent of the code and respond accordingly [1]. Because they wrote the code and the code made sense to them, they find it hard to even imagine that the code might not work. The second problem is compounded on the first: if you think your code is right, testing can only bring you bad news. If you don’t test, you can’t find out if the code is wrong. It’s like the old saying about putting your head in the sand.</p>
</div>
<div class="readable-text" id="p10">
<p class="calibre15">Professional software engineers take a completely different approach than new programmers. They take testing extremely seriously because a mistake in the code can have significant consequences for their company. No one wants to be the person whose code causes the company to lose tons of revenue, lets hackers gain access to confidential user data, or has the self-driving car cause an accident. Given the cost of a mistake, it makes more sense to assume the code is wrong until proven otherwise. Only after testing it extensively should we trust that it’s working correctly. And, companies don’t just test the code once, they keep the tests in their system so every time someone changes code, tests are run not just on the changed code but also on any code that the changed code might affect (this is called regression testing).</p>
</div>
<div class="readable-text" id="p11">
<p class="calibre15">Companies take this so seriously that they often write their tests <em class="calibre18">before</em> writing their code in a process called test-driven development (TDD). This ensures everyone agrees on what the code should or shouldn’t do. We don’t think you (as readers) need to take this approach for the programs you’re writing with this book, but we mention it here to convey how crucial it is to test. Thinking about testing before writing code can help you understand what the code should do and that will help you write better prompts. In fact, you can include test cases directly in your prompts!</p>
</div>
<div class="readable-text" id="p12">
<p class="calibre15">Finally, let’s remember what we know about Copilot: it makes mistakes. We shouldn’t assume anything about the correctness of any code given to us by Copilot. All this is to say that any code you’re given by Copilot should be tested before you trust it.</p>
</div>
<div class="readable-text" id="p13">
<h2 class="readable-text-h1" id="sigil_toc_id_78"><span class="calibre22">6.2</span> Closed-box and open-box testing</h2>
</div>
<div class="readable-text" id="p14">
<p class="calibre15">There are two ways that software engineers commonly test their code. The first is called closed-box testing, and this approach assumes you know nothing about how the code works. As such, this kind of testing involves varying the inputs and observing the outputs. We often see closed-box testing applied to functions or entire programs. The advantage of closed-box testing is that you don’t need to look at the code to perform the tests and can therefore focus simply on the desired behavior. </p>
</div>
<div class="readable-text" id="p15">
<p class="calibre15">The second approach to testing is called open-box testing, and in this approach, we look at the code to see where the errors might occur. The advantage of open-box testing is that by looking at the particular structure of the code, we may see where the code is likely to fail and can design additional tests specific to that code. We’ll use both closed-box and open-box testing to come up with test cases that combine to strengthen our testing. A brief summary of closed-box and open-box testing appears in table 6.1. In this section, let’s look at how we might test some functions using these approaches.</p>
</div>
<div class="browsable-container" id="p16">
<h5 class="browsable-container-h"><span>Table 6.1</span> Brief overview of closed-box and open-box testing</h5>
<table class="calibre36">
<thead class="calibre37">
<tr class="calibre38">
<th class="calibre39">
<div class="readable-text">
         Closed-box testing 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Open-box testing 
       </div></th>
</tr>
</thead>
<tbody class="calibre40">
<tr class="calibre38">
<td class="calibre41">  Requires understanding the function specification to test <br class="calibre1"/></td>
<td class="calibre41">  Requires both the function specification and the code that implements the function to test <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Tests don’t require an understanding of what the code does. <br class="calibre1"/></td>
<td class="calibre41">  Tests should be tailored based on how the code was written. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Testers need not have technical expertise about the code they’re testing. <br class="calibre1"/></td>
<td class="calibre41">  Testers need to be able to understand the code sufficiently well to determine which tests may be more important. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Tests the function by varying inputs and checking against expected results <br class="calibre1"/></td>
<td class="calibre41">  Can test the function in the same way as closed-box testing but can also have more granular tests within a function <br class="calibre1"/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p17">
<h3 class="readable-text-h2" id="sigil_toc_id_79"><span class="calibre22">6.2.1</span> Closed-box testing</h3>
</div>
<div class="readable-text" id="p18">
<p class="calibre15">Let’s imagine we’re trying to test a function that takes in a list of words (strings) and returns the longest word. To be more precise, the function signature would be</p>
</div>
<div class="browsable-container" id="p19">
<div class="readable-text">
<pre class="code-area">def longest_word(words):</pre>
</div>
</div>
<div class="readable-text" id="p20">
<p class="calibre15">The expected input is a list of words. The expected output is the word in that list with the most characters. In the event that multiple words are tied for the most characters, it should return the first word of that length.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p21">
<h5 class="callout-container-h">Shorthand for expressing test cases</h5>
</div>
<div class="readable-text" id="p22">
<p class="calibre15">When writing tests for a function, the standard format is to write the function name and its input along with the desired outcome. For example, the call</p>
</div>
<div class="browsable-container" id="p23">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; longest_word(['a', 'bb', 'ccc'])
'ccc'</pre>
</div>
</div>
<div class="readable-text" id="p24">
<p class="calibre15">means that if we call the function <code class="calibre25">longest_word</code> with the input list <code class="calibre25">['a',</code> <code class="calibre25">'bb',</code> <code class="calibre25">'ccc']</code>, then the value returned from the function should be <code class="calibre25">'ccc'</code>. </p>
</div>
</div>
<div class="readable-text" id="p25">
<p class="calibre15">There are two categories for which we typically think about writing test cases:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p26"> <em class="calibre18">Common use cases—</em>These cases include some standard inputs you could imagine the function receiving and the corresponding result. </li>
<li class="readable-text1" id="p27"> <strong class="calibre17"/><em class="calibre18">Edge cases—</em>These cases are uncommon but possible cases that might break the code. These are inputs that might test some of the rules for the function in more depth or contain unexpected inputs (e.g., a list with all empty strings). </li>
</ul>
<div class="readable-text" id="p28">
<p class="calibre15">Looking back at our <code class="calibre25">longest_word</code> function signature in the previous example, let’s think about some test cases we might use to test it. Later in the chapter, we’ll see how to actually run these test cases to determine whether our code is working correctly. Let’s start with <em class="calibre18">common use cases</em>. We would likely want to include a test with just a few words where one word is longer than the others:</p>
</div>
<div class="browsable-container" id="p29">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; longest_word(['cat', 'dog', 'bird']) 
'bird'</pre>
</div>
</div>
<div class="readable-text" id="p30">
<p class="calibre15">Here’s another test with more words with the longest word appearing elsewhere in the list:</p>
</div>
<div class="browsable-container" id="p31">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; longest_word(['happy', 'birthday', 'my', 'cat']) 
'birthday'</pre>
</div>
</div>
<div class="readable-text" id="p32">
<p class="calibre15">And last, let’s have a test with just one word:</p>
</div>
<div class="browsable-container" id="p33">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; longest_word(['happy']) 
'happy'</pre>
</div>
</div>
<div class="readable-text" id="p34">
<p class="calibre15">If the program is working for these common uses, our next step would be to think about some <em class="calibre18">edge cases. </em>Let’s consider some edge cases.</p>
</div>
<div class="readable-text" id="p35">
<p class="calibre15">Say we want to check whether the function conforms to our description by returning the first word when there are multiple words of the same length. This test may be considered a common case or an edge case, depending on whom you ask:</p>
</div>
<div class="browsable-container" id="p36">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; longest_word(['cat', 'dog', 'me']) 
'cat'</pre>
</div>
</div>
<div class="readable-text" id="p37">
<p class="calibre15">What do we do if all the words in the list have no characters? A string with no characters is called an <em class="calibre18">empty string</em> and is written as just an empty pair of quotes. If all we have is a list of empty strings, then the longest word is just the empty string! So, a test with all empty strings should just give us back an empty string:</p>
</div>
<div class="browsable-container" id="p38">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; longest_word(['', ''])
''</pre>
</div>
</div>
<div class="readable-text" id="p39">
<p class="calibre15">The term <em class="calibre18">edge case</em> comes from the fact that errors often happen at the “edge” of execution, meaning either the first or last element. In many loops, mistakes can be made when the loop is starting (e.g., forgetting or mishandling the first element in the list) or at the end (e.g., forgetting the last element or going past the end of the list and trying to access an element that doesn’t exist). Especially when the code is likely to have loops processing many elements, you’ll want to watch the behavior at the start and end of the loop.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p40">
<h5 class="callout-container-h">Incorrect input testing </h5>
</div>
<div class="readable-text" id="p41">
<p class="calibre15">Another category of tests will test the function on how it responds when given incorrect input. We won’t talk about this much in our book because we’re assuming you’re correctly calling your own functions, but in production code, this kind of testing can be common. A few examples of calling this function with incorrect inputs might be to give the function a nonexisting list by using the value <code class="calibre25">None</code> instead of an actual list (e.g., <code class="calibre25">longest_word(None)</code>), to give the function an empty list (e.g., <code class="calibre25">longest_word([])</code>), to give the function a list with integers as input (e.g., <code class="calibre25">longest_word</code> <code class="calibre25">([1,2])</code>), or to provide a list of strings but have the strings contain spaces or more than single words (e.g., <code class="calibre25">longest_word(['hi</code> <code class="calibre25">there',</code> <code class="calibre25">'</code> <code class="calibre25">my</code> <code class="calibre25">',</code> <code class="calibre25">'friend'])</code>). It’s hard to say what the function should do when given incorrect input, and programmers need to decide whether they care about this in larger code bases, but we’ll ignore this category of tests in this book because we’ll assume you’ll call your own functions in ways that the functions are designed to handle.</p>
</div>
</div>
<div class="readable-text" id="p42">
<h3 class="readable-text-h2" id="sigil_toc_id_80"><span class="calibre22">6.2.2</span> How do we know which test cases to use?</h3>
</div>
<div class="readable-text" id="p43">
<p class="calibre15">In chapter 3, we discussed that good testing involves capturing different categories of function calls. One way to find these categories is by using the types of parameters and varying their values. </p>
</div>
<div class="readable-text" id="p44">
<p class="calibre15">For example, if the function takes a string or list as a parameter, it may make sense to test the case when that string or list is empty, has one element, and has multiple elements. If we’re trying to test multiple elements, we might use four elements, for example. It likely also wouldn’t make sense to test with five or six elements or more because if our code works with four elements, it’s unlikely that something could suddenly go wrong when we increase to five. Sometimes, some of these test cases may not make sense for a given function; for example, it wouldn’t make sense to ask for the longest word in a list that didn’t have any words in it, so we wouldn’t test the empty list for our <code class="calibre25">longest_word</code> function.</p>
</div>
<div class="readable-text" id="p45">
<p class="calibre15">As another example, if a function takes two numbers as parameters, it may make sense to test when one number is zero, both numbers are zero, one number is negative, both numbers are negative, and both numbers are positive. </p>
</div>
<div class="readable-text" id="p46">
<p class="calibre15">Another way to find categories is to think about the specific task of the function. For example, for our <code class="calibre25">longest_word</code> function, it’s supposed to be finding the longest word, so we should test that it’s actually doing that in a typical case. And, if multiple words are the longest, it’s supposed to return the first of those, so we should have a test case where the list has multiple words that are the longest.</p>
</div>
<div class="readable-text" id="p47">
<p class="calibre15">Finding the categories to test is a mix of science and art. We’ve given you some rules of thumb here, but what counts as useful test cases often depends on the specific functionality being tested. As is so often the case, practicing your testing skill is the best way to improve your ability to write useful tests that ultimately help you make your code better. </p>
</div>
<div class="readable-text" id="p48">
<h3 class="readable-text-h2" id="sigil_toc_id_81"><span class="calibre22">6.2.3</span> Open-box testing</h3>
</div>
<div class="readable-text" id="p49">
<p class="calibre15">The big difference between open-box testing and closed-box testing is that open-box testing examines the code to see if there are additional kinds of test cases to check. In theory, closed-box testing may be sufficient to fully test the function, but open-box testing tends to give you more ideas about where the code might be failing. Let’s say we asked for Copilot to write our <code class="calibre25">longest_word</code> function and got back the code shown in the following listing.</p>
</div>
<div class="browsable-container" id="p50">
<h5 class="listing-container-h"><span>Listing 6.1</span> Function to find the longest word (incorrect!)</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def longest_word(words):</strong>
<strong class="calibre17">    ''' </strong>
<strong class="calibre17">        words is a list of words</strong>

<strong class="calibre17">        return the word from the list with the most characters</strong>
<strong class="calibre17">        if multiple words are the longest, return the first </strong>
<strong class="calibre17">        such word        </strong>
<strong class="calibre17">    '''</strong>
    longest = ""
    for i in range(0,len(words)):
        if len(words[i]) &gt;= len(longest):    <span/> #1
            longest = words[i]
    return longest</pre>
<div class="code-annotations-overlay-container">
     #1 &gt;= is wrong. It should be &gt;.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p51">
<p class="calibre15">For this example, we intentionally introduced an error in the code to help explain the role of open-box testing. Let’s say that when you were thinking through your test cases, you forgot to test what happens when there are two words in the list of <code class="calibre25">words</code> that both have the most characters. Well, reading through this code you might spot the following <code class="calibre25">if</code> statement:</p>
</div>
<div class="browsable-container" id="p52">
<div class="readable-text">
<pre class="code-area">   if len(words[i]) &gt;= len(longest):
        longest = words[i]</pre>
</div>
</div>
<div class="readable-text" id="p53">
<p class="calibre15">When reading the <code class="calibre25">if</code> statement, you might notice that it’s going to update the longest word in the list of words when the length of the most recent element is greater than <em class="calibre18">or equal</em> to the longest word we’ve seen so far. This is a mistake; it should be <code class="calibre25">&gt;</code>, not <code class="calibre25">&gt;=</code>, but suppose you aren’t sure. This would motivate you to write a test case like the one we described previously that has multiple words, more than one of which is the longest:</p>
</div>
<div class="browsable-container" id="p54">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; longest_word(['cat', 'dog', 'me']) 
'cat'</pre>
</div>
</div>
<div class="readable-text" id="p55">
<p class="calibre15">This test will fail with the code in listing 6.1 as it would return <code class="calibre25">'dog'</code> rather than the correct answer of <code class="calibre25">'cat'</code>. The test failing is valuable information that the code in listing 6.1 is incorrect.</p>
</div>
<div class="readable-text" id="p56">
<p class="calibre15">As we’ve said, open-box testing is useful because it leads to test cases that follow the structure of the code itself. For example, if our code is using a loop, we’ll find that loop when doing open-box testing. The loop in listing 6.1 is correct, but by seeing the loop in our code, we’ll be reminded to test the edge cases to make sure it’s properly handling the first element, the last element, and an empty list. In sum, knowing how the code is processing the input often offers insight into when the program might be misfunctioning.</p>
</div>
<div class="readable-text" id="p57">
<h2 class="readable-text-h1" id="sigil_toc_id_82"><span class="calibre22">6.3</span> How to test your code</h2>
</div>
<div class="readable-text" id="p58">
<p class="calibre15">There are a number of good ways to test your code that vary from quick tests you might perform just to check if your code is working for yourself to tests that are built into a company’s regression test suite. For production code, Python programmers typically use testing tools more powerful and full-featured than what we’re about to demonstrate in this chapter. The most common of those tools is pytest, which is a module that needs to be installed before it can be used. We feel that pytest is beyond what we need here to introduce the core ideas of testing. We’ll focus on more lightweight testing to help you gain confidence that the code from Copilot works properly. We can do that either by testing at the Python prompt or using a built-in Python module called doctest.</p>
</div>
<div class="readable-text" id="p59">
<h3 class="readable-text-h2" id="sigil_toc_id_83"><span class="calibre22">6.3.1</span> Testing using the Python prompt</h3>
</div>
<div class="readable-text" id="p60">
<p class="calibre15">The first way to test is in the Python prompt through the interactive window like we have in the previous chapters. The advantage of this testing is that it can be quick to run, and you can easily add more tests as a result of output from the previous test. The tests we’ve run so far are examples of testing with the Python prompt. For example,</p>
</div>
<div class="browsable-container" id="p61">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; longest_word(['cat', 'dog', 'me']) 
'cat'</pre>
</div>
</div>
<div class="readable-text" id="p62">
<p class="calibre15">In running that test, if you expected the result to be <code class="calibre25">'cat'</code>, you’d be pleased to see that result. However, if the test shows that your code was wrong, you now have the opportunity to go back to fix it. </p>
</div>
<div class="readable-text" id="p63">
<p class="calibre15">After you fix the code, you’ll want to test the new code. Here is where you may go wrong with testing using the Python prompt alone. When you come back to test the code you just changed, you might be tempted to run <em class="calibre18">just</em> the test case that had failed previously. However, in fixing the code to correctly address the test case that had failed, you could have introduced an error that would cause the <em class="calibre18">previous</em> test cases that had already passed to now fail. What you really want then is a way to run not just your current test but all previous tests as well. </p>
</div>
<div class="readable-text" id="p64">
<h3 class="readable-text-h2" id="sigil_toc_id_84"><span class="calibre22">6.3.2</span> Testing in your Python file (we won’t be doing it this way)</h3>
</div>
<div class="readable-text" id="p65">
<p class="calibre15">It would be tempting to then put all your test cases in your Python program (outside a function, so in the equivalent of a main function) so they can all run. This solution addresses the problem with Python prompts that we just described, but it introduces a new problem. What happens when you want your Python program to perform the main task for which it was designed rather than just run tests? You could delete all the tests, but the point was running them again if so desired. You could comment them out so you can run them in the future, but that’s not a very clean solution either. What we want then is a way to run all our tests on our functions when we want to but still have the ability to run the program. The way to do this is using a module called doctest.</p>
</div>
<div class="readable-text" id="p66">
<h3 class="readable-text-h2" id="sigil_toc_id_85"><span class="calibre22">6.3.3</span> doctest</h3>
</div>
<div class="readable-text" id="p67">
<p class="calibre15">The doctest module is built in to Python. The great thing about using doctest is that we simply add our test cases to the docstring that describes the function. This beefed-up docstring serves a dual purpose. First, we can use doctest to run all those test cases whenever we’d like. Second, it can sometimes help Copilot generate better code in the first place or fix already-written code that isn’t quite working. Let’s write that <code class="calibre25">longest_word</code> function with all the test cases included and ready to be executed with doctest (see listing 6.2).</p>
</div>
<div class="browsable-container" id="p68">
<h5 class="listing-container-h"><span>Listing 6.2</span> Using doctest to test the <code class="calibre25">longest_word</code> function</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def longest_word(words): </strong>
<strong class="calibre17">    ''' </strong>
<strong class="calibre17">        words is a list of words</strong>
<strong class="calibre17">        </strong>
<strong class="calibre17">        return the word from the list with the most characters</strong>
<strong class="calibre17">        if multiple words are the longest, return the first </strong>
<strong class="calibre17">        such word        </strong>
<strong class="calibre17">        </strong>
<strong class="calibre17">    &gt;&gt;&gt; longest_word(['cat', 'dog', 'bird'])             </strong><span/> #1
<strong class="calibre17">    'bird'                                               </strong> #1
<strong class="calibre17">                                                         </strong> #1
<strong class="calibre17">    &gt;&gt;&gt; longest_word(['happy', 'birthday', 'my', 'cat']) </strong> #1
<strong class="calibre17">    'birthday'                                           </strong> #1

<strong class="calibre17">    &gt;&gt;&gt; longest_word(['happy'])                          </strong> #1
<strong class="calibre17">    'happy'                                              </strong> #1
<strong class="calibre17">                                                         </strong> #1
<strong class="calibre17">    &gt;&gt;&gt; longest_word(['cat', 'dog', 'me'])               </strong> #1
<strong class="calibre17">    'cat'                                                </strong> #1
<strong class="calibre17">                                                         </strong> #1
<strong class="calibre17">    &gt;&gt;&gt; longest_word(['', ''])                           </strong> #1
<strong class="calibre17">    ''                                                   </strong> #1
<strong class="calibre17">    ''' </strong> #1
    longest = ''                            <span/> #2
    for i in range(0,len(words)):            #2
        if len(words[i]) &gt; len(longest):     #2
            longest = words[i]               #2
    return longest                           #2
<strong class="calibre17">import doctest                  </strong><span/> #3
<strong class="calibre17">doctest.testmod(verbose=True)   </strong> #3</pre>
<div class="code-annotations-overlay-container">
     #1 Shows the test cases for doctest
     <br class="calibre1"/>#2 Shows the correct code for the function
     <br class="calibre1"/>#3 Code (in main) that calls doctest to perform the test
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p69">
<p class="calibre15">In this code, we see the docstring with our test cases provided as the prompt to Copilot. Copilot generated the correct code to implement this function. We then manually wrote the last two lines of the code to perform the testing. When run, we get the output in the following listing.</p>
</div>
<div class="browsable-container" id="p70">
<h5 class="listing-container-h"><span>Listing 6.3</span> Doctest output from running our program in listing 6.2</h5>
<div class="readable-text">
<pre class="code-area">Trying:
    longest_word(['cat', 'dog', 'bird'])  
Expecting:
    'bird'
ok             <span/> #1
Trying:
    longest_word(['happy', 'birthday', 'my', 'cat'])
Expecting:
    'birthday'
ok              <span/> #2
Trying:
    longest_word(['happy'])
Expecting:
    'happy'
ok            <span/> #3
Trying:
    longest_word(['cat', 'dog', 'me'])
Expecting:
    'cat'
ok          <span/> #4
Trying:
    longest_word(['', ''])
Expecting:
    ''
ok                  <span/> #5
1 items had no tests:         <span/> #6
    __main__                   #6
1 items passed all tests:         <span/> #7
   5 tests in __main__.longest_word
5 tests in 2 items.
5 passed and 0 failed.    <span/> #8
Test passed.</pre>
<div class="code-annotations-overlay-container">
     #1 First test in longest_word passed
     <br class="calibre1"/>#2 Second test in longest_word passed
     <br class="calibre1"/>#3 Third test in longest_word passed
     <br class="calibre1"/>#4 Fourth test in longest_word passed
     <br class="calibre1"/>#5 Fifth test in longest_word passed
     <br class="calibre1"/>#6 There are no tests in main (outside the function).
     <br class="calibre1"/>#7 longest_word passed all tests.
     <br class="calibre1"/>#8 0 failed is what you hope to see.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p71">
<p class="calibre15">From this output, we can see that each test ran and each test passed. The reason these tests ran is because of the last two lines that we added in listing 6.2:</p>
</div>
<div class="browsable-container" id="p72">
<div class="readable-text">
<pre class="code-area">import doctest
doctest.testmod(verbose=True)</pre>
</div>
</div>
<div class="readable-text" id="p73">
<p class="calibre15">In the first line, we import the doctest module. That’s the module that helps us test our code by automatically running the test cases when we run our program. In the second line, we’re calling the <code class="calibre25">testmod</code> function from the doctest module. That function call tells doctest to perform all the tests; the argument <code class="calibre25">verbose=True</code> tells doctest to give us the outcome for all tests, whether they pass or not. If we switch to <code class="calibre25">verbose=False</code>, it will only give us output if test cases fail (<code class="calibre25">verbose=False</code> is actually the default, so you can just call the function with no arguments, and it will default to not providing output unless one or more tests fail). This can be a nice feature as we can keep the doctest running and only see the output when tests fail.</p>
</div>
<div class="readable-text" id="p74">
<p class="calibre15">In this case, our code passed all the test cases. But let’s experience what happens when our code doesn’t pass. </p>
</div>
<div class="readable-text" id="p75">
<p class="calibre15">If we find a word that’s the same length as our current longest word, we should ignore it because we always want to return the first longest word if there are multiple words tied for the longest. That’s why the correct thing to do is to use <code class="calibre25">&gt;</code> in the <code class="calibre25">if</code> statement (finding a new longest word only if it’s truly longer than our current longest word) rather than <code class="calibre25">&gt;=</code>.</p>
</div>
<div class="readable-text" id="p76">
<p class="calibre15">We can break the code in listing 6.2 then by changing the <code class="calibre25">&gt;</code> to <code class="calibre25">&gt;=</code>, which will cause it to select the last word of the longest length rather than the first. Let’s change the following line from</p>
</div>
<div class="browsable-container" id="p77">
<div class="readable-text">
<pre class="code-area">if len(words[i]) &gt; len(longest):</pre>
</div>
</div>
<div class="readable-text" id="p78">
<p class="calibre15">to</p>
</div>
<div class="browsable-container" id="p79">
<div class="readable-text">
<pre class="code-area">if len(words[i]) &gt;= len(longest):</pre>
</div>
</div>
<div class="readable-text" id="p80">
<p class="calibre15">Now, the tests shouldn’t all pass. In addition, let’s change the last line to</p>
</div>
<div class="browsable-container" id="p81">
<div class="readable-text">
<pre class="code-area">doctest.testmod()</pre>
</div>
</div>
<div class="readable-text" id="p82">
<p class="calibre15">By providing no arguments to the <code class="calibre25">testmod</code> function, <code class="calibre25">verbose</code> is now set to <code class="calibre25">False</code>. When we run the code, this is the output:</p>
</div>
<div class="browsable-container" id="p83">
<div class="readable-text">
<pre class="code-area">**********************************************************************
File "c:\Users\leo\Copilot_book\Chapter6\test_longest_word.py", 
line 12, in __main__.longest_word
Failed example:
    longest_word(['cat', 'dog', 'me'])
Expected:
    'cat'
Got:
    'dog'
**********************************************************************        
1 items had failures:
   1 of   5 in __main__.longest_word
***Test Failed*** 1 failures.</pre>
</div>
</div>
<div class="readable-text" id="p84">
<p class="calibre15">Doctest conveniently tells us which test was run, what the expected output was, and what the function produced instead. This would catch the bug and allow us to go back to fix the error.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p85">
<h5 class="callout-container-h">Test cases aren’t automatically run by Copilot </h5>
</div>
<div class="readable-text" id="p86">
<p class="calibre15">We commonly hear the following question: Why doesn’t Copilot directly incorporate the test cases when generating code? For example, if we add test cases, it would be nice if Copilot could try to generate functions and only provide us with the code that would pass those test cases. Unfortunately, there are some technical challenges in doing this, and as of the time of writing, this feature isn’t yet included. So, if you add test cases, it just improves the prompt to Copilot but doesn’t guarantee that the Copilot code suggestion passes those tests.</p>
</div>
</div>
<div class="readable-text" id="p87">
<p class="calibre15">At this point, we’ve seen how to run our tests with both the Python prompt and doctest. Now that we know how to test our code, let’s think about how this modifies our code design cycle.</p>
</div>
<div class="readable-text" id="p88">
<h2 class="readable-text-h1" id="sigil_toc_id_86"><span class="calibre22">6.4</span> Revisiting the cycle of designing functions with Copilot</h2>
</div>
<div class="readable-text" id="p89">
<p class="calibre15">In chapter 3, we gave you an early version of how to design functions in figure 3.3. At that point, we didn’t know as much about examining our code (which we learned in chapters 4 and 5) or as much about how to test our code as we do now. As such, let’s create a new version of this cycle (figure 6.1) to reflect our new understanding.<span/></p>
</div>
<div class="browsable-container" id="p90">
<img alt="figure" src="../Images/6-1.png" class="calibre59"/>
<h5 class="figure-container-h"><span>Figure 6.1</span> The function design cycle with Copilot, augmented to include more about testing</h5>
</div>
<div class="readable-text" id="p91">
<p class="calibre15">The figure is a bit more complex than before, but if we examine it closely, we can see much of the original process is retained. The things that have been added or changed include the following:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p92"> When we write the prompt, we may include doctests as part of that initial prompt to help Copilot in generating the code. </li>
<li class="readable-text1" id="p93"> Having made our way through chapters 4 and 5, we’re in good shape to read the code to see whether it behaves properly, so we now have an additional step to address what happens when the initial code from Copilot looks wrong. If that occurs, we’ll use Ctrl-Enter to explore the Copilot suggestions to hopefully find a solution. If we can find such a solution, we’ll select it and move forward. If we can’t, we’ll need to revise our prompt to help Copilot generate improved suggestions. </li>
<li class="readable-text1" id="p94"> After finding code that looks like it could be correct, we’ll run doctest to see whether the code passes the doctests we included in the prompt (if we didn’t include any, it will pass automatically). If doctest passes, then we can continue adding tests and checking them until we’re happy that the code is functioning properly. If doctest fails, we’ll need to figure out how to modify the prompt to address the failed tests. Once the prompt is modified, it will hopefully help Copilot generate new code that may be capable of passing the tests that we’ve provided. </li>
</ul>
<div class="readable-text" id="p95">
<p class="calibre15">With this new workflow, we’re in a much better position not only to determine whether our code is working properly but also to fix the code if it isn’t already working. In the next chapters, we’ll give ourselves even more tools to help when the code isn’t working properly, but for now, let’s put this all together by solving a new problem and testing the Copilot solutions using the workflow we described here.</p>
</div>
<div class="readable-text" id="p96">
<h2 class="readable-text-h1" id="sigil_toc_id_87"><span class="calibre22">6.5</span> Full testing example</h2>
</div>
<div class="readable-text" id="p97">
<p class="calibre15">Let’s try a problem that we might need to solve to help students decide where to sit in in-person classes. Although we’re talking about finding empty seats in a classroom, this problem is the same as trying to find the number of empty seats in a concert hall, theater, movie theater, or office layout.</p>
</div>
<div class="readable-text" id="p98">
<p class="calibre15">Suppose we have the classroom layout as a two-dimensional list with rows of seats. Each seat either contains a space (<code class="calibre25">'</code> <code class="calibre25">'</code>) or a student (<code class="calibre25">'S'</code>) to represent an empty or occupied seat, respectively. We’re going to ask Copilot to create a function to determine which row we could add the most students to, and along the way, we’ll design the tests needed to check whether the code is working properly.</p>
</div>
<div class="readable-text" id="p99">
<h3 class="readable-text-h2" id="sigil_toc_id_88"><span class="calibre22">6.5.1</span> Finding the most students we can add to a row</h3>
</div>
<div class="readable-text" id="p100">
<p class="calibre15">We want to figure out the largest number of new students we could add in a single row in the classroom. (Equivalently, we’re looking for the largest number of empty seats in any row.) For this, let’s start with a somewhat ambiguous prompt and see how well Copilot does.</p>
</div>
<div class="browsable-container" id="p101">
<h5 class="listing-container-h"><span>Listing 6.4</span> Largest number of students we can add to a row</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def most_students(classroom):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    classroom is a list of lists</strong>
<strong class="calibre17">    Each ' ' is an empty seat</strong>
<strong class="calibre17">    Each 'S' is a student</strong>
<strong class="calibre17">    How many new students can sit in a row?    </strong><span/> #1
<strong class="calibre17">    '''</strong>
    max_students = 0
    for row in classroom:
        students = 0
        for seat in row:
            if seat == 'S':
                students += 1
            else:
                students = 0
            if students &gt; max_students:
                max_students = students
    return max_students</pre>
<div class="code-annotations-overlay-container">
     #1 This is a somewhat ambiguous part of the prompt.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p102">
<p class="calibre15">For the sake of this example, our prompt wasn’t very good. “How many new students can sit in a row?” is a reasonable starting point to give to a human, but it’s not that specific, and it’s easy to imagine Copilot struggling to interpret what we mean. Copilot might get confused about whether we’re counting the number of students or the number of empty seats in a row, or it might return the total number of available seats in the classroom rather than in a row. It turns out that our prompt confused Copilot, and the code isn’t correct, but before we dive into the code, let’s think about what tests we should run. We’ve come up with the following set of test cases:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p103"> A classroom with some number of consecutive empty seats and some number of nonconsecutive empty seats to make sure it isn’t just counting consecutive empty seats </li>
<li class="readable-text1" id="p104"> A classroom with no empty seats to make sure it returns 0 in that case </li>
<li class="readable-text1" id="p105"> A classroom with a row full of empty seats to make sure all are counted, including the first and last seats (edge case) </li>
<li class="readable-text1" id="p106"> A classroom with multiple rows with the same number of empty seats to make sure it returns just one of those values (and not, perhaps, the sum of the number of empty seats across all of these rows) </li>
</ul>
<div class="readable-text" id="p107">
<p class="calibre15">Let’s start by adding the first test case and adding the doctest code to run the test, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p108">
<h5 class="listing-container-h"><span>Listing 6.5</span> Largest number of students we can add to a row</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def most_students(classroom):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    classroom is a list of lists</strong>
<strong class="calibre17">    Each ' ' is an empty seat</strong>
<strong class="calibre17">    Each 'S' is a student</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    How many new students can sit in a row?</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; most_students([['S', ' ', 'S', 'S', 'S', 'S'], \   </strong><span/> #1
<strong class="calibre17">                       ['S', 'S', 'S', 'S', 'S', 'S'], \   </strong>
<strong class="calibre17">                       [' ', 'S', ' ', 'S', ' ', ' ']])    </strong>
<strong class="calibre17">    4</strong>
<strong class="calibre17">    '''</strong>
    max_students = 0
    for row in classroom:
        students = 0
        for seat in row:
            if seat == 'S':
                students += 1
            else:
                students = 0
            if students &gt; max_students:
                max_students = students
    return max_students

<strong class="calibre17">import doctest</strong>
<strong class="calibre17">doctest.testmod(verbose=False)</strong></pre>
<div class="code-annotations-overlay-container">
     #1 Doctest for a common case. The \ is necessary in docstring test cases if you need to do a newline.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p109">
<p class="calibre15">When we run this code, we get this output (we cleaned up the formatting of the classroom list manually to help with the readability of the answer):</p>
</div>
<div class="browsable-container" id="p110">
<div class="readable-text">
<pre class="code-area">**********************************************************************
Failed example:
    most_students([['S', ' ', 'S', 'S', 'S', 'S'],
                   ['S', 'S', 'S', 'S', 'S', 'S'], 
                   [' ', 'S', ' ', 'S', ' ', ' ']])
Expected:
    4
Got:
    6
**********************************************************************
1 items had failures:
   1 of   1 in __main__.most_students
***Test Failed*** 1 failures.</pre>
</div>
</div>
<div class="readable-text" id="p111">
<p class="calibre15">Although we’d prefer the code to work, we appreciate that the first test case found an error. The row with the most empty seats is the third row with four seats available. But the code from Copilot is incorrectly telling us the answer is six. That’s pretty odd. Even without reading the code, you might hypothesize that it’s counting either the number of seats per row or the maximum number of students seated per row. Our test case had a full row of students in the second row, so it’s hard to tell. What we can do is change the classroom to be</p>
</div>
<div class="browsable-container" id="p112">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">    &gt;&gt;&gt; most_students([['S', ' ', 'S', 'S', 'S', 'S'], \ </strong>
<strong class="calibre17">                       [' ', 'S', 'S', 'S', 'S', 'S'], \    </strong><span/> #1
<strong class="calibre17">                       [' ', 'S', ' ', 'S', ' ', ' ']])  </strong>
<strong class="calibre17">    4</strong></pre>
<div class="code-annotations-overlay-container">
     #1 We removed the first student from the second row.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p113">
<p class="calibre15">So, the second row now has five students. When we run the code again, the test again fails with the code giving us an answer of five. It seems that the code isn’t just telling us the number of seats per row. It must be doing something related to where students are sitting. Our next step is to improve the prompt and determine whether we can get better code from Copilot, but for completeness, let’s first explain what the code was really doing in the following listing.</p>
</div>
<div class="browsable-container" id="p114">
<h5 class="listing-container-h"><span>Listing 6.6</span> Walkthrough of the incorrect code from Copilot</h5>
<div class="readable-text">
<pre class="code-area"> max_students = 0   <span/> #1
    for row in classroom:    <span/> #2
        students = 0            <span/> #3
        for seat in row:          <span/> #4
            if seat == 'S':       <span/> #5
                students += 1      #5
            else:                       <strong class="calibre17"> </strong><span/> #6
                students = 0            <strong class="calibre17"> </strong> #6
            if students &gt; max_students:    <span/> #7
                max_students = students    
    return max_students</pre>
<div class="code-annotations-overlay-container">
     #1 Starts with the max_students initialized to 0
     <br class="calibre1"/>#2 For each row in the classroom
     <br class="calibre1"/>#3 Initializes the student counter to 0 for this row
     <br class="calibre1"/>#4 For each seat in the row
     <br class="calibre1"/>#5 If there is a student in the seat, increment the counter.
     <br class="calibre1"/>#6 If there is an empty seat, reset the counter.
     <br class="calibre1"/>#7 Checks to see if the student counter is bigger than seen before and, if so, makes that the new maximum seen before
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p115">
<p class="calibre15">You can see from the code description what is happening per line, but at a high level, this code is counting the number of consecutive students in each row. It does this by initializing a counter to 0 for each row and then incrementing that counter as long as it keeps seeing a student in a seat. It also resets the counter as soon as it sees an empty seat. The <code class="calibre25">if</code> statement at the end of the inner loop is a pretty standard way of keeping track of the largest of something seen before, and in this case, it’s keeping track of the largest number of consecutive students seen. That’s not at all what we wanted, and our poor prompt is partially to blame. The key piece, though, is that our test lets us know the code is incorrect. (If you spotted the error yourself in reading the code, that’s great too!) </p>
</div>
<div class="readable-text" id="p116">
<h3 class="readable-text-h2" id="sigil_toc_id_89"><span class="calibre22">6.5.2</span> Improving the prompt to find a better solution</h3>
</div>
<div class="readable-text" id="p117">
<p class="calibre15">Let’s rewrite the prompt, keep the test case, and see whether we can do better in the following listing.</p>
</div>
<div class="browsable-container" id="p118">
<h5 class="listing-container-h"><span>Listing 6.7</span> Trying again to find the largest number of students</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def most_students(classroom):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    classroom is a list of lists</strong> #1
<strong class="calibre17">    Each ' ' is an empty seat</strong> #1
<strong class="calibre17">    Each 'S' is a student</strong> #1
<strong class="calibre17">    </strong> #1
<strong class="calibre17">    Return the maximum total number of ' ' characters   </strong><span/> #1
<strong class="calibre17">    In a given row.                                     </strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; most_students([['S', ' ', 'S', 'S', 'S', 'S'], \</strong>
<strong class="calibre17">                       [' ', 'S', 'S', 'S', 'S', 'S'], \</strong>
<strong class="calibre17">                       [' ', 'S', ' ', 'S', ' ', ' ']])</strong>
<strong class="calibre17">    4</strong>
<strong class="calibre17">    '''</strong>
    max_seats = 0
    for row in classroom:
        seats = row.count(' ')     <span/> #2
        if seats &gt; max_seats:    <strong class="calibre17">         </strong><span/> #3
            max_seats = seats              #3
    return max_seats

<strong class="calibre17">import doctest</strong>
<strong class="calibre17">doctest.testmod(verbose=False)</strong></pre>
<div class="code-annotations-overlay-container">
     #1 The improved prompt says we specifically want the maximum number of ' ' characters in any given row.
     <br class="calibre1"/>#2 count is a list function that returns the number of the argument in the list. 
     <br class="calibre1"/>#3 Code to keep track of maximum seats
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p119">
<p class="calibre15">To get this solution, we had to look through the possible Copilot solutions using Ctrl-Enter. Some of the solutions now counted the consecutive occurrences of <code class="calibre25">'</code> <code class="calibre25">'</code>, whereas others, like the one in listing 6.7, passed the doctest. Oddly, the first time we tried the improved prompt, the suggested solution was correct. This is another reminder of why nondeterminism in the Copilot output makes testing so important. </p>
</div>
<div class="readable-text" id="p120">
<p class="calibre15">Let’s take a minute and look at what made this second prompt better than the first. Both prompts had</p>
</div>
<div class="browsable-container" id="p121">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def most_students(classroom):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    classroom is a list of lists</strong>
<strong class="calibre17">    Each ' ' is an empty seat</strong>
<strong class="calibre17">    Each 'S' is a student</strong></pre>
</div>
</div>
<div class="readable-text" id="p122">
<p class="calibre15">The part of the prompt that led to us receiving the wrong answer was</p>
</div>
<div class="browsable-container" id="p123">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">How many new students can sit in a row?</strong></pre>
</div>
</div>
<div class="readable-text" id="p124">
<p class="calibre15">The part of the prompt that yielded a correct answer was</p>
</div>
<div class="browsable-container" id="p125">
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">Return the maximum total number of ' ' characters in a given row. </strong></pre>
</div>
</div>
<div class="readable-text" id="p126">
<p class="calibre15">You can never really know why a large language model (LLM) like Copilot produces the answer it does, but let’s remember that it’s trained to just make predictions of next words based on the words it’s been given and words that were in its training data (i.e., lots of code in GitHub). </p>
</div>
<div class="readable-text" id="p127">
<p class="calibre15">The first prompt asks Copilot to make some inferences, some of which it does well, and some not so well. The prompt, in a sense, is asking Copilot to know what a row is in a list of lists. Thankfully, that’s really common in programming, so it had no problem there. </p>
</div>
<div class="readable-text" id="p128">
<p class="calibre15">Then, the prompt asks Copilot to make the basic logical step of inferring that an empty seat is where a <em class="calibre18">new</em> student could sit. Here is where Copilot struggled. We suspect that because we’re asking about new students sitting in a row, it wasn’t able to make the jump to realize that “new” students would require figuring out how many students you can <em class="calibre18">add</em> or, in other words, how many empty seats there are. Instead, Copilot focused on the “students °.°.°. in a row” part of the prompt and started counting students in each row. It could have also used the function name (which, admittedly, could be better; i.e., <code class="calibre25">max_empty_seats_per_row</code>) to think it needs to count the maximum number of students. That’s not what we want, but we can understand how Copilot makes this mistake.</p>
</div>
<div class="readable-text" id="p129">
<p class="calibre15">Now let’s talk about why, in response to our vague first prompt, Copilot decided to count <em class="calibre18">consecutive</em> students in a given row. Maybe counting consecutive students is a more common pattern in Copilot’s training data. Maybe it’s because “sit in a row” could be interpreted as “sit consecutively.” Or maybe it’s because when we were coding this example, we’d been working on another version of the problem that asked for consecutive empty seats, and Copilot remembered that conversation. We don’t know why Copilot gave us this answer, but we know that our prompt was too vague.</p>
</div>
<div class="readable-text" id="p130">
<p class="calibre15">In contrast, our second prompt was more specific in a few ways. First, it clearly asks for the maximum. Second, it asks for the number of spaces, or empty seats, in a row. That takes away the need for Copilot to infer that an empty seat means a spot for a new student. We also used “total” and “given row” to try to get Copilot out of its current approach to counting consecutive values, but that didn’t quite do the trick. Consequently, we ended up having to sift through Copilot answers (using Ctrl-Enter) that were sometimes looking for consecutive empty seats and sometimes finding the count of empty seats.</p>
</div>
<div class="readable-text" id="p131">
<h3 class="readable-text-h2" id="sigil_toc_id_90"><span class="calibre22">6.5.3</span> Testing the new solution</h3>
</div>
<div class="readable-text" id="p132">
<p class="calibre15">Returning to our example, because the new code passes the current test, let’s give it more tests to ensure that it’s behaving correctly. In the next test, we’ll check that the code properly returns 0 when there are no empty seats in any rows: </p>
</div>
<div class="browsable-container" id="p133">
<div class="readable-text">
<pre class="code-area">    &gt;&gt;&gt; most_students([['S', 'S', 'S'], \
                       ['S', 'S', 'S'], \
                       ['S', 'S', 'S']])
    0</pre>
</div>
</div>
<div class="readable-text" id="p134">
<p class="calibre15">The next test will ensure that the code properly counts all three empty seats in a single row (here, the second row) so there isn’t an edge case problem (e.g., it fails to count the first or last element). Admittedly, looking at the code, we can see the <code class="calibre25">count</code> function is being used, and because that function is built in to Python, we should be fairly confident this test will pass. However, it’s still safer to test it to make sure: </p>
</div>
<div class="browsable-container" id="p135">
<div class="readable-text">
<pre class="code-area">    &gt;&gt;&gt; most_students([['S', 'S', 'S'], \
                       [' ', ' ', ' '], \
                       ['S', 'S', 'S']])
    3</pre>
</div>
</div>
<div class="readable-text" id="p136">
<p class="calibre15">The last test checks to see that Copilot properly handles the case that two rows have the same number of empty seats:</p>
</div>
<div class="browsable-container" id="p137">
<div class="readable-text">
<pre class="code-area">    &gt;&gt;&gt; most_students([[' ', ' ', 'S'], \
                       ['S', ' ', ' '], \
                       ['S', 'S', 'S']])
    2</pre>
</div>
</div>
<div class="readable-text" id="p138">
<p class="calibre15">After adding these test cases, we again ran the full program, shown in the following listing, and all test cases passed.</p>
</div>
<div class="browsable-container" id="p139">
<h5 class="listing-container-h"><span>Listing 6.8</span> Full code and doctests for largest number of students</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def most_students(classroom):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    classroom is a list of lists</strong>
<strong class="calibre17">    Each ' ' is an empty seat</strong>
<strong class="calibre17">    Each 'S' is a student</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Return the maximum total number of ' ' characters in a </strong>
<strong class="calibre17">    given row. </strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; most_students([['S', ' ', 'S’, 'S', 'S', 'S'], \</strong>
<strong class="calibre17">                       [' ', 'S', 'S', 'S', 'S', 'S'], \</strong>
<strong class="calibre17">                       [' ', 'S', ' ', 'S', ' ', ' ']])</strong>
<strong class="calibre17">    4</strong>
<strong class="calibre17">    &gt;&gt;&gt; most_students([['S', 'S', 'S'], \</strong>
<strong class="calibre17">                       ['S', 'S', 'S'], \</strong>
<strong class="calibre17">                       ['S', 'S', 'S']])</strong>
<strong class="calibre17">    0</strong>
<strong class="calibre17">    &gt;&gt;&gt; most_students([['S', 'S', 'S'], \</strong>
<strong class="calibre17">                       [' ', ' ', ' '], \</strong>
<strong class="calibre17">                       ['S', 'S', 'S']])</strong>
<strong class="calibre17">    3</strong>
<strong class="calibre17">    &gt;&gt;&gt; most_students([[' ', ' ', 'S'], \</strong>
<strong class="calibre17">                       ['S', ' ', ' '], \</strong>
<strong class="calibre17">                       ['S', 'S', 'S']])</strong>
<strong class="calibre17">    2</strong>
<strong class="calibre17">    '''</strong>
    max_seats = 0
    for row in classroom:
        seats = row.count(' ')
        if seats &gt; max_seats:
            max_seats = seats
    return max_seats

<strong class="calibre17">import doctest</strong>
<strong class="calibre17">doctest.testmod(verbose=False)</strong></pre>
</div>
</div>
<div class="readable-text" id="p140">
<p class="calibre15">In this example, we saw how to write a function to solve a problem from start to finish. Copilot gave us the wrong answer, partially because of a difficult-to-interpret prompt. We figured out that it gave us the wrong answer because the code failed on our first test. We then improved the prompt and used the code reading skills we learned in the previous two chapters to pick out a solution that looked correct for our needs. The new code passed our initial basic test, so we added more test cases to see whether the code worked in more situations. After seeing it pass those additional tests, we have more evidence that the code is correct. At this point, we’ve tested the common cases and edge cases, so we’re highly confident that our current code is correct. Regarding testing, this example showed us how tests can help us find mistakes <em class="calibre18">and</em> give us more confidence that the code will function properly.</p>
</div>
<div class="readable-text" id="p141">
<h2 class="readable-text-h1" id="sigil_toc_id_91"><span class="calibre22">6.6</span> Another full testing example: Testing with files</h2>
</div>
<div class="readable-text" id="p142">
<p class="calibre15">In most cases, you’ll be able to test your code by adding examples to the docstring like we did in the previous example. However, there are times when testing can be a bit more challenging. This is true when you need to test your code against some kind of external input. An example is when we need to test code that interacts with external websites, but this is more common in advanced code than the kind of code you’ll be creating within the scope of this book. </p>
</div>
<div class="readable-text" id="p143">
<p class="calibre15">An example that <em class="calibre18">is</em> within the scope of this book is working with files. How do you write test cases when your input is a file? Python does support doing this in a way internal to the docstring here, but for continuity with what we’ve already done, we’re not going to do it that way. Instead, we’ll use external files to test our code. Let’s see how to do that by revising our NFL quarterback (QB) example from chapter 2.</p>
</div>
<div class="readable-text" id="p144">
<p class="calibre15">We could walk through an example with the entire file, but because our queries about quarterbacks were only for the first nine columns of the file, we’re going to strip off the remaining columns of the file to make things more readable. After stripping off the remaining columns, table 6.2 shows the first four rows of the file.</p>
</div>
<div class="browsable-container" id="p145">
<h5 class="browsable-container-h"><span>Table 6.2</span> The first four lines of an abridged version of the NFL dataset</h5>
<table class="calibre36">
<thead class="calibre37">
<tr class="calibre38">
<th class="calibre39">
<div class="readable-text">
         game_id 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         player_id 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         position 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         player 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         team 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         pass_cmp 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         pass_att 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         pass_yds 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         pass_td 
       </div></th>
</tr>
</thead>
<tbody class="calibre40">
<tr class="calibre38">
<td class="calibre41">  201909050chi <br class="calibre1"/></td>
<td class="calibre41">  RodgAa00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Aaron Rodgers <br class="calibre1"/></td>
<td class="calibre41">  GNB <br class="calibre1"/></td>
<td class="calibre41">  18 <br class="calibre1"/></td>
<td class="calibre41">  30 <br class="calibre1"/></td>
<td class="calibre41">  203 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909050chi <br class="calibre1"/></td>
<td class="calibre41">  JoneAa00 <br class="calibre1"/></td>
<td class="calibre41">  RB <br class="calibre1"/></td>
<td class="calibre41">  Aaron Jones <br class="calibre1"/></td>
<td class="calibre41">  GNB <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909050chi <br class="calibre1"/></td>
<td class="calibre41">  ValdMa00 <br class="calibre1"/></td>
<td class="calibre41">  WR <br class="calibre1"/></td>
<td class="calibre41">  Marquez Valdes-Scantling <br class="calibre1"/></td>
<td class="calibre41">  GNB <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p146">
<p class="calibre15">We’ll assume that each row in the dataset has just these nine columns for the remainder of the example, but we hope it’s not a big stretch to imagine how to do this for the full dataset (you’d just need to add all the additional columns in each case).</p>
</div>
<div class="readable-text" id="p147">
<p class="calibre15">Suppose we want to make a function that takes in the filename of the dataset and the name of a player as input and then outputs the total number of passing yards that player achieved in the dataset. We’ll assume that the user will be providing the data as formatted in the NFL offensive stats file in chapter 2 and in table 6.2. Before we write the prompt or function, how should we test this? Well, we have some options:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p148"> <em class="calibre18">Find tests in the larger dataset—</em>A solution is to give the full dataset to the function and multiple player names as inputs. The challenge is figuring out whether we’re correct or not. We could open the file in software such as Google Sheets or Microsoft Excel and use spreadsheet features to figure out the answer for each player. For example, we could open the file as a sheet in Excel, sort by player, find a player, and use the sum function in Excel to add up all the passing yards for that player. This isn’t a bad solution at all, but it’s also a fair bit of work, and if you put enough time into finding the answer for testing, you might have already fulfilled your needs and no longer require the Python code! In other words, figuring out the answer for the test cases might just give you the answer you wanted in the first place, making the code less valuable. Another problem is in finding all the edge cases you might want to test: Will your dataset have all the edge cases you’d want to test to write a program that will work on other datasets later? Yet another drawback of this approach is determining what you do when the function is doing something considerably more complicated than just summing a value in a bunch of rows. There, figuring out the answers for some real test values might be a great deal of work. </li>
<li class="readable-text1" id="p149"> <em class="calibre18">Create artificial dataset(s) for testing—</em>Another solution is to create artificial datasets where you know the answer to a number of possible queries. Because the dataset is artificial, you can add edge cases to see how the code performs in those cases without having to find such rare examples in the real dataset. (Sometimes the real dataset won’t include those edge cases, but you still want to test them, so the code behaves properly if you get an updated or new dataset.) </li>
</ul>
<div class="readable-text" id="p150">
<p class="calibre15">Given the advantages to creating test cases in an artificial dataset, we’re going to proceed with that approach here.</p>
</div>
<div class="readable-text" id="p151">
<h3 class="readable-text-h2" id="sigil_toc_id_92"><span class="calibre22">6.6.1</span> What tests should we run?</h3>
</div>
<div class="readable-text" id="p152">
<p class="calibre15">Let’s think through the common cases and edge cases that we would want to test. For common cases, we’d want to have a few tests:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p153"> <em class="calibre18">A player appears multiple times in different rows of the dataset (nonconsecutively), including the last row.</em> This test makes sure the code iterates over all the players before returning a result (i.e., doesn’t make the false assumption that the data is sorted by player name). </li>
<li class="readable-text1" id="p154"> <em class="calibre18">A player appears in consecutive rows of the dataset.</em> This test makes sure there isn’t some kind of error where consecutive values are somehow skipped. </li>
<li class="readable-text1" id="p155"> <em class="calibre18">A player appears just once in the dataset.</em> This test makes sure that the sum behaves properly even when it’s just summing one value. </li>
<li class="readable-text1" id="p156"> <em class="calibre18">A non-quarterback could appear in the dataset.</em> For this, we ensure the code is including all players, not just quarterbacks. </li>
<li class="readable-text1" id="p157"> <em class="calibre18">A player has 0 total passing yards in a game.</em> This checks to make sure that the code behaves properly when players don’t have any passing yards. This is a common case to test because players can get hurt and miss a game due to the injury. </li>
</ul>
<div class="readable-text" id="p158">
<p class="calibre15">For edge cases, we’d want to test a couple more things:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p159"> <em class="calibre18">The player isn’t in the dataset.</em> This is actually pretty interesting: What do we want the code to do in this case? A reasonable answer is to return that they passed for 0 yards. If we asked the dataset how many yards Lebron James (a basketball player, not a football player) passed for in the NFL from 2019 to 2022, 0 is the right answer. However, this may not be the most elegant solution for production code. For example, if we ask for the passing yards for Aron Rodgers (misspelling Aaron Rodgers), we’d rather have the code tell us he’s not in the dataset than that he passed for 0 yards, which could really confuse us when he won the league MVP twice during this time frame. To signal that the name was missing, we might return a large negative value (e.g., –9999), or we might use something called exceptions, but they are beyond the scope of this book. </li>
<li class="readable-text1" id="p160"> <em class="calibre18">A player has a negative total number of yards across all games or a player has a single game with negative yards to ensure the code is properly handling negative values.</em> If you don’t follow American football, this can happen if a player catches a ball and is tackled behind the starting point (line of scrimmage). It’s unlikely a quarterback would have negative passing yards for an entire game, but it could happen if they throw one pass for a loss (negative yards) and get hurt at the same time, causing them to not play for the rest of the game. </li>
</ul>
<div class="readable-text" id="p161">
<p class="calibre15">Now that we have an idea of what we want to test, let’s build an artificial file that captures these test cases. We could have split these tests across multiple files, which would be a reasonable choice to make as well, but an advantage of putting them all in one file is that we can keep all of our test cases together. Table 6.3 is what we built and saved as test_file.csv.</p>
</div>
<div class="browsable-container" id="p162">
<h5 class="browsable-container-h"><span>Table 6.3</span> Our file to test the NFL passing yards function</h5>
<table class="calibre36">
<thead class="calibre37">
<tr class="calibre38">
<th class="calibre39">
<div class="readable-text">
         game_id 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         player_id 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         position 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         player 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         team 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         pass_cmp 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         pass_att 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         pass_yds 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         pass_td 
       </div></th>
</tr>
</thead>
<tbody class="calibre40">
<tr class="calibre38">
<td class="calibre41">  201909050chi <br class="calibre1"/></td>
<td class="calibre41">  RodgAa00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Aaron Rodgers <br class="calibre1"/></td>
<td class="calibre41">  GNB <br class="calibre1"/></td>
<td class="calibre41">  20 <br class="calibre1"/></td>
<td class="calibre41">  30 <br class="calibre1"/></td>
<td class="calibre41">  200 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909080crd <br class="calibre1"/></td>
<td class="calibre41">  JohnKe06 <br class="calibre1"/></td>
<td class="calibre41">  RB <br class="calibre1"/></td>
<td class="calibre41">  Kerryon Johnson <br class="calibre1"/></td>
<td class="calibre41">  DET <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  5 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909080crd <br class="calibre1"/></td>
<td class="calibre41">  PortLe00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Leo Porter <br class="calibre1"/></td>
<td class="calibre41">  UCSD <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909080car <br class="calibre1"/></td>
<td class="calibre41">  GoffJa00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Jared Goff <br class="calibre1"/></td>
<td class="calibre41">  LAR <br class="calibre1"/></td>
<td class="calibre41">  20 <br class="calibre1"/></td>
<td class="calibre41">  25 <br class="calibre1"/></td>
<td class="calibre41">  200 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909050chi <br class="calibre1"/></td>
<td class="calibre41">  RodgAa00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Aaron Rodgers <br class="calibre1"/></td>
<td class="calibre41">  GNB <br class="calibre1"/></td>
<td class="calibre41">  10 <br class="calibre1"/></td>
<td class="calibre41">  15 <br class="calibre1"/></td>
<td class="calibre41">  150 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909050chi <br class="calibre1"/></td>
<td class="calibre41">  RodgAa00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Aaron Rodgers <br class="calibre1"/></td>
<td class="calibre41">  GNB <br class="calibre1"/></td>
<td class="calibre41">  25 <br class="calibre1"/></td>
<td class="calibre41">  35 <br class="calibre1"/></td>
<td class="calibre41">  300 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909080car <br class="calibre1"/></td>
<td class="calibre41">  GoffJa00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Jared Goff <br class="calibre1"/></td>
<td class="calibre41">  LAR <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  –10 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909080crd <br class="calibre1"/></td>
<td class="calibre41">  ZingDa00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Dan Zingaro <br class="calibre1"/></td>
<td class="calibre41">  UT <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  –10 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  201909050chi <br class="calibre1"/></td>
<td class="calibre41">  RodgAa00 <br class="calibre1"/></td>
<td class="calibre41">  QB <br class="calibre1"/></td>
<td class="calibre41">  Aaron Rodgers <br class="calibre1"/></td>
<td class="calibre41">  GNB <br class="calibre1"/></td>
<td class="calibre41">  15 <br class="calibre1"/></td>
<td class="calibre41">  25 <br class="calibre1"/></td>
<td class="calibre41">  150 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p163">
<p class="calibre15">Notice that the data here is entirely artificial. (These aren’t the real statistics for any player, as you can tell by the fact that Dan and Leo are now magically NFL quarterbacks.) We did keep the names of some real players as well as real <code class="calibre25">game_id</code>s and <code class="calibre25">player_id</code>s from the original dataset. It’s generally a good idea to make your artificial data be as close to real data as possible so that the tests are genuine and more apt to be representative of what will happen with real data.</p>
</div>
<div class="readable-text" id="p164">
<p class="calibre15">Let’s look at how we incorporated all the test cases in this test file (table 6.3). Aaron Rodgers occurs multiple times in the file, both consecutively and nonconsecutively, and as the last entry. Jared Goff appears multiple times, and we gave him an artificial –10 yards in a game (as an elite NFL QB, I hope he’s okay with us giving him an artificially bad single game). We kept Kerryon Johnson as a running back (RB) from the real dataset and gave him 5 passing yards to make sure the solution doesn’t filter for only QBs. Kerryon Johnson also only has one entry in the data. We added Leo Porter to the dataset and gave him 0 passing yards (he’s pretty sure he’d do anything to not get tackled by an NFL player). We also added Dan Zingaro and gave him a completed pass, but for –10 yards, covering the case that a single player’s total is negative. Table 6.4 shows what it <em class="calibre18">should</em> return per player when we run the query for each player.</p>
</div>
<div class="browsable-container" id="p165">
<h5 class="browsable-container-h"><span>Table 6.4</span> Passing yards per player in the test case</h5>
<table class="calibre36">
<thead class="calibre37">
<tr class="calibre38">
<th class="calibre39">
<div class="readable-text">
         Player 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Passing yards in the test case 
       </div></th>
</tr>
</thead>
<tbody class="calibre40">
<tr class="calibre38">
<td class="calibre41">  Aaron Rodgers <br class="calibre1"/></td>
<td class="calibre41">  800 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Kerryon Johnson <br class="calibre1"/></td>
<td class="calibre41">  5 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Leo Porter <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Jared Goff <br class="calibre1"/></td>
<td class="calibre41">  190 <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Dan Zingaro <br class="calibre1"/></td>
<td class="calibre41">  –10 <br class="calibre1"/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p166">
<h3 class="readable-text-h2" id="sigil_toc_id_93"><span class="calibre22">6.6.2</span> Creating the function</h3>
</div>
<div class="readable-text" id="p167">
<p class="calibre15">Let’s start with the function name and describe the problem in the docstring. This problem may be complicated enough that we’ll need to offer prompts within the function to help it know to open the file, process the data, and close the file, but let’s try to just describe the function first and see how Copilot does.</p>
</div>
<div class="browsable-container" id="p168">
<h5 class="listing-container-h"><span>Listing 6.9</span> Function to find total passing yards per player</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def tot_pass_yds_player(input_file, player):    </strong><span/> #1
<strong class="calibre17">    """</strong>
<strong class="calibre17">    input_file is a string that is the name of a file</strong>
<strong class="calibre17">    player is the name of a player</strong>

<strong class="calibre17">    The file is a csv file with a header row</strong>
<strong class="calibre17">    Column 4 is the player's name and column</strong>
<strong class="calibre17">    8 is the number of passing yards for that player</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    return the total number of passing yards for the player</strong>
<strong class="calibre17">    """</strong>
    import csv
    with open(input_file, 'r') as csvfile:
        reader = csv.reader(csvfile)
        next(reader)
        total = 0
        for row in reader:
            if row[3] == player:
                total += int(row[7])
        return total</pre>
<div class="code-annotations-overlay-container">
     #1 We abbreviated the function name.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p169">
<p class="calibre15">Before looking at the code produced, we want to point out that we didn’t include the test cases for this example because they likely wouldn’t help Copilot. We recommend having Copilot generate code prior to you adding test cases if your test cases will simply open and use artificial files. Each test case will just be a filename, a player, and the expected output. Copilot likely can’t read the file that corresponds to that filename and figure out that we’re summing the eighth column to get the desired result. This means that giving Copilot the test cases isn’t going to add to the quality of the prompt. In fact, the artificial nature of our data might even confuse it (e.g., in what scenario does a real NFL player have a negative total for passing yards?). </p>
</div>
<div class="readable-text" id="p170">
<p class="calibre15">Now looking at the code that Copilot gave us, we can see that it’s quite reasonable and almost identical to the code we saw in chapter 2. Given that it seems reasonable when we read it, let’s see how to test it.</p>
</div>
<div class="readable-text" id="p171">
<h3 class="readable-text-h2" id="sigil_toc_id_94"><span class="calibre22">6.6.3</span> Testing the function</h3>
</div>
<div class="readable-text" id="p172">
<p class="calibre15">To test the function, we’ll augment the docstring to include our test cases for the full piece of code, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p173">
<h5 class="listing-container-h"><span>Listing 6.10</span> Testing the function to find player passing yards</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def tot_pass_yds_player(input_file, player):</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    input_file is a string that is the name of a file</strong>
<strong class="calibre17">    player is the name of a player</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    The file is a csv file with a header row</strong>
<strong class="calibre17">    Column 4 is the player's name and column</strong>
<strong class="calibre17">    8 is the number of passing yards for that player</strong>
<strong class="calibre17">  </strong>
<strong class="calibre17">    return the total number of passing yards for the player</strong>

<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv’, 'Aaron Rodgers')</strong>
<strong class="calibre17">    800</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Kerryon Johnson')</strong>
<strong class="calibre17">    5</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Leo Porter')</strong>
<strong class="calibre17">    0</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Jared Goff')</strong>
<strong class="calibre17">    190</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Dan Zingaro')</strong>
<strong class="calibre17">    -10</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Tom Brady')</strong>
<strong class="calibre17">    0                                        </strong><span/> #1
    """
    import csv
    with open(input_file, 'r') as csvfile:
        reader = csv.reader(csvfile)
        next(reader)
        total = 0
        for row in reader:
            if row[3] == player:
                total += int(row[7])
        return total

import doctest
doctest.testmod(verbose=False)</pre>
<div class="code-annotations-overlay-container">
     #1 The additional test case for a player not in the dataset
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p174">
<p class="calibre15">We ran this code, and all the test cases passed. (We know that all test cases passed because there was no output from doctest.) We now have additional evidence that the code is functioning properly!</p>
</div>
<div class="readable-text" id="p175">
<h3 class="readable-text-h2" id="sigil_toc_id_95"><span class="calibre22">6.6.4</span> Common challenges with doctest</h3>
</div>
<div class="readable-text" id="p176">
<p class="calibre15">Let’s rewrite the previous prompt and add a really subtle error to the first test, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p177">
<h5 class="listing-container-h"><span>Listing 6.11</span> Mistake in doctest</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def tot_pass_yds_player(input_file, player):</strong>
<strong class="calibre17">    """</strong>
<strong class="calibre17">    input_file is a string that is the name of a file</strong>
<strong class="calibre17">    player is the name of a player</strong>
<strong class="calibre17">    The file is a csv file with a header row</strong>
<strong class="calibre17">    The 4th Column is the player's name and the 8th column</strong>
<strong class="calibre17">    is the number of passing yards for that player</strong>
<strong class="calibre17">  </strong>
<strong class="calibre17">    return the total number of passing yards for the player</strong>

<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Aaron Rodgers')</strong>
<strong class="calibre17">    800                                                          </strong><span/> #1
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Kerryon Johnson')</strong>
<strong class="calibre17">    5</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Leo Porter')</strong>
<strong class="calibre17">    0</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Jared Goff')</strong>
<strong class="calibre17">    190</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Dan Zingaro')</strong>
<strong class="calibre17">    -10</strong>
<strong class="calibre17">    &gt;&gt;&gt; tot_pass_yds_player('test_file.csv', 'Tom Brady')</strong>
<strong class="calibre17">    0 </strong>
    """
    import csv
    with open(input_file, 'r') as csvfile:
        reader = csv.reader(csvfile)
        next(reader)
        total = 0
        for row in reader:
            if row[3] == player:
                total += int(row[7])
        return total

import doctest
doctest.testmod(verbose=False)</pre>
<div class="code-annotations-overlay-container">
     #1 There is an extra space after the 800 that isn’t visible.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p178">
<p class="calibre15">When we ran this code, we received this error:</p>
</div>
<div class="browsable-container" id="p179">
<div class="readable-text">
<pre class="code-area">Failed example:
    tot_pass_yds_player('test_file.csv', 'Aaron Rodgers')
Expected:
    800 
Got:
    800</pre>
</div>
</div>
<div class="readable-text" id="p180">
<p class="calibre15">On first glance, this seems really odd. The test case expects 800 and it got 800, but it’s telling us it failed. Well, it turns out that we made a mistake in writing the test case and wrote “800 ” (with a space at the end) rather than “800”. This mistake causes Python to think the space is important and causes the test to fail. The bad news is that this is a really common problem working with doctest! We’ve made this mistake more often than we’d like to admit. The good news is it’s really easy to fix by just finding and deleting the space. If a test is failing but the output from doctest suggests that it should be passing, always check ends of lines for spaces or extra or missing spaces anywhere in your output compared to exactly what doctest is expecting.</p>
</div>
<div class="readable-text" id="p181">
<p class="calibre15">Given that all our test cases passed, we can feel confident returning to the larger dataset and using the function we just created. The key thing from this example is that we can, and should, create artificial files to test functions that work with files. Again, testing is all about gaining confidence that the code is working properly, and you want to be sure you test any code you write or given to you by Copilot. </p>
</div>
<div class="readable-text" id="p182">
<p class="calibre15">In this chapter as a whole, we learned about the importance of testing code, how to test code, and how to do it in two detailed examples. In our examples, we wrote and tested functions. But how do we decide which functions should be written to solve even larger problems? Well, we figure that out through a process known as problem decomposition that we’ll cover in detail in our next chapter.</p>
</div>
<div class="readable-text" id="p183">
<h2 class="readable-text-h1" id="sigil_toc_id_96"><span class="calibre22">6.7</span> Exercises</h2>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p184"> Given the following scenarios, identify whether closed-box testing or open-box testing would be more appropriate and explain why: 
    <ol class="calibre48">
<li class="calibre30"> A tester is given a function specification and needs to ensure that the function behaves correctly without looking at the implementation. </li>
<li class="calibre30"> A tester needs to debug a function by writing tests that specifically target edge cases revealed by understanding the code implementation. </li>
</ol></li>
<li class="readable-text1" id="p185"> Here is a function with some test cases. Identify which of the following test cases are common use cases and which are edge cases: </li>
</ol>
<div class="browsable-container" id="p186">
<div class="readable-text">
<pre class="code-area">def calculate_average(numbers):
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)
<strong class="calibre17"># Test cases:</strong>
calculate_average([1, 2, 3, 4, 5])
calculate_average([10, 20, 30])
calculate_average([])
calculate_average([-1, -2, -3, -4, -5])
calculate_average([1000000, 2000000, 3000000])
calculate_average([3.5, 4.5, 5.5])
calculate_average([1, 2, "a", 4])
calculate_average([0])</pre>
</div>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p187"><span class="faux-ol-li-counter">3. </span> We’re building a program to analyze website traffic. Website traffic is represented as a list of dictionaries. Each dictionary has two keys: <code class="calibre25">"weekday"</code> (a string representing the day of the week) and <code class="calibre25">"visitors"</code> (an integer representing the number of visitors on that day). The same day of the week can appear in multiple dictionaries. Our goal is to find the day of the week with the highest number of visitors. </li>
</ol>
<div class="readable-text" id="p188">
<p class="calibre15">Here’s the initial prompt we gave to an AI code-generation tool:</p>
</div>
<div class="readable-text4" id="p189">
<p class="calibre54">def busiest_day(traffic_data): # traffic_data is a list of dictionaries. # Find the busiest day.</p>
</div>
<div class="readable-text" id="p190">
<p class="calibre15">The tool generated the following code, but it doesn’t seem quite right. </p>
</div>
<div class="browsable-container" id="p191">
<div class="readable-text">
<pre class="code-area">def busiest_day(traffic_data):
  most_visitors = 0
  busiest_day = None
  for day in traffic_data:
    if day["visitors"] &gt; most_visitors:
      most_visitors = day["visitors"]
      busiest_day = day["weekday"]
  return busiest_day</pre>
</div>
</div>
<div class="readable-text" id="p192">
<p class="calibre15">Can you explain why and how you would improve the prompt to get the desired functionality?</p>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p193"><span class="faux-ol-li-counter">4. </span> Imagine you have a function (<code class="calibre25">find_highest_grossing_book(filename)</code>) that analyzes book sales data and returns information about the book with the highest total revenue. Sales data is stored in a CSV file where each line represents a sale. The columns in the CSV file are as follows: 
    <ol class="calibre48">
<li class="calibre30"> <code class="calibre25">title</code>—The title of the book sold (string) </li>
<li class="calibre30"> <code class="calibre25">author</code>—The author of the book (string) </li>
<li class="calibre30"> <code class="calibre25">price</code>—The price of the book (float) </li>
<li class="calibre30"> <code class="calibre25">quantity</code>—The number of copies sold for that particular sale (integer) </li>
</ol></li>
</ol>
<div class="readable-text" id="p194">
<p class="calibre15">Create a Python script containing the <code class="calibre25">find_highest_grossing_book</code> function (implementation not provided here). Include a docstring explaining the function’s purpose, and add test cases using the doctest module.</p>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p195"><span class="faux-ol-li-counter">5. </span> Review the provided test cases for the <code class="calibre25">is_palindrome</code> function. Identify which test cases are incorrect, and explain why. Provide the correct version of the test cases. </li>
</ol>
<div class="browsable-container" id="p196">
<div class="readable-text">
<pre class="code-area">def is_palindrome(s):
    """
    Return True if string s reads the same forward and backward.
    &gt;&gt;&gt; is_palindrome("racecar")
    True
    &gt;&gt;&gt; is_palindrome("hello")
    False
    &gt;&gt;&gt; is_palindrome("A man, a plan, a canal, Panama")
    True
    &gt;&gt;&gt; is_palindrome("")
    True
    &gt;&gt;&gt; is_palindrome("a")
    True
    &gt;&gt;&gt; is_palindrome("Noon")
    True
    """
    cleaned = ''.join(char.lower() for char in s if char.isalnum())
    return cleaned == cleaned[::-1]</pre>
</div>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p197"><span class="faux-ol-li-counter">6. </span> Analyze the test coverage of the <code class="calibre25">find_max</code> function. Are there any scenarios not covered by the existing test cases? Suggest additional test cases if necessary. </li>
</ol>
<div class="browsable-container" id="p198">
<div class="readable-text">
<pre class="code-area">def find_max(numbers):
    """ 
    Returns the maximum number from a list.
    &gt;&gt;&gt; find_max([1, 2, 3, 4, 5])
    5
    &gt;&gt;&gt; find_max([-1, -2, -3, -4, -5])
    -1 
    &gt;&gt;&gt; find_max([42])
    42
    &gt;&gt;&gt; find_max([])
    None
    """ 
    if not numbers:
        return None
    max_number = numbers[0]
    for num in numbers:
        if num &gt; max_number:
            max_number = num
    return max_number</pre>
</div>
</div>
<div class="readable-text" id="p199">
<h2 class="readable-text-h1" id="sigil_toc_id_97">Summary</h2>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p200"> Testing is a critical skill when writing software using Copilot. </li>
<li class="readable-text1" id="p201"> Closed-box and open-box testing are different approaches to ensuring the code is correct. In closed-box testing, we come up with test cases based on what we know about the problem; in open-box testing, we additionally examine the code itself. </li>
<li class="readable-text1" id="p202"> Doctest is a module that comes with Python that helps us test our code. </li>
<li class="readable-text1" id="p203"> To use doctest, we add test cases to the docstring description of a function. </li>
<li class="readable-text1" id="p204"> Creating artificial files is an effective way to test code that uses files. </li>
</ul>
</div></body></html>