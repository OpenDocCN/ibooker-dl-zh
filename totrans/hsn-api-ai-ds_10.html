<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. What Data Scientists Should Know About APIs"><div class="chapter" id="chapter_8">
<h1><span class="label">Chapter 8. </span>What Data Scientists <span class="keep-together">Should Know About APIs</span></h1>

<blockquote data-type="epigraph" epub:type="epigraph">
  <p>Working with APIs for data science is a necessary skill set for all data scientists.</p>
  <p data-type="attribution">Nate Rosidi, KDnuggets</p>
</blockquote>

<p>API expertise is critical to<a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" id="ch8know"/> being an effective data scientist. But a data scientist can’t become an expert in every API specialty—​the field of APIs is nearly as wide as the field of data science. <a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="building block approach" id="id1664"/><a data-type="indexterm" data-primary="building block approach to learning APIs" id="id1665"/>Thankfully, you don’t need to master every API specialty if you use the <em>building-block approach</em>: mastering one or two API-related skills at a time, and stacking additional skills on top of those as your skills grow. In my experience, the best way to acquire these building blocks is through hands-on coding projects that you share with the world for fast feedback. (That’s where the <em>hands-on</em> part of this book’s title comes from.)</p>

<p>The following are some of the most useful building-block skills for data scientists.</p>






<section data-type="sect1" data-pdf-bookmark="Using a Variety of API Styles"><div class="sect1" id="id86">
<h1>Using a Variety of API Styles</h1>

<p>Out in the wild, there are a few<a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="variety of API styles used" id="ch8varty"/><a data-type="indexterm" data-primary="APIs" data-secondary="architecture of" data-tertiary="architectural styles" id="ch8varty2"/><a data-type="indexterm" data-primary="architecture of APIs" data-secondary="architectural styles" id="ch8varty3"/> major API architectural styles that you may come across.  <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a> discussed why an API provider might create a REST, GraphQL, or gRPC API. As an API consumer, you need to be flexible. This section explains how you can use whatever API style is available.</p>

<p>The most common API style<a data-type="indexterm" data-primary="REST (Representational State Transfer) APIs" data-secondary="popularity of" id="id1666"/><a data-type="indexterm" data-primary="RESTful" id="id1667"/><a data-type="indexterm" data-primary="REST (Representational State Transfer) APIs" id="id1668"/> is REST or RESTful. (For simplicity, I will use the terms interchangeably in this chapter.) <a data-type="indexterm" data-primary="endpoints of APIs" data-secondary="REST APIs" id="id1669"/><a data-type="indexterm" data-primary="API endpoints" data-secondary="REST APIs" id="id1670"/><a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" data-tertiary="REST APIs" id="id1671"/><a data-type="indexterm" data-primary="GET HTTP verb" id="id1672"/><a data-type="indexterm" data-primary="POST HTTP verb" id="id1673"/><a data-type="indexterm" data-primary="architecture of APIs" data-secondary="architectural styles" data-tertiary="REST" id="id1674"/><a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" data-tertiary="REST APIs and endpoints" id="id1675"/>A REST API has multiple <em>endpoints</em>, which are combinations of HTTP verbs and URLs. <a data-type="indexterm" data-primary="REST (Representational State Transfer) APIs" data-secondary="GET request" id="id1676"/>For example, to read league information from a football API, you might use an HTTP GET verb and the URL <em><a href="https://api.sportsworldcentral.com/v0/leagues" class="bare"><em class="hyperlink">https://api.sportsworldcentral.com/v0/leagues</em></a></em>. To create a new league, you might use a POST verb with the same URL, and pass along information to it in the HTTP body.</p>

<p>A web browser is an easy<a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" data-tertiary="web browser sending" id="id1677"/> way to send a GET request to an API. For example, to query a fantasy football API for a specific football player record with a <code>player_id</code> of 1491, you could open your web browser to a fantasy sports API at <em><a href="https://api.sportsworldcentral.com/v0/players/1491" class="bare"><em class="hyperlink">https://api.sportsworldcentral.com/v0/players/1491</em></a></em> and get a result like <a data-type="xref" href="#get_request_ch8">Figure 8-1</a>. This is an HTTP GET.</p>

<figure><div id="get_request_ch8" class="figure">
<img src="assets/haad_0801.png" alt="Get request of a REST API" width="887" height="125"/>
<h6><span class="label">Figure 8-1. </span>GET request of a REST API</h6>
</div></figure>

<p>To make the same request with Python, you can use the httpx library as follows:<a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" data-tertiary="Python" id="id1678"/><a data-type="indexterm" data-primary="Python" data-secondary="HTTP verbs" id="id1679"/><a data-type="indexterm" data-primary="httpx Python library" data-secondary="httpx.get() method" id="id1680"/></p>

<pre data-type="programlisting" data-code-language="python">import httpx

rest_url = "https://api.sportsworldcentral.com/v0/players/1491"

api_response = httpx.get(rest_url)
print(api_response.json())</pre>

<p>This API returns data in JSON format,<a data-type="indexterm" data-primary="JSON" data-secondary="httpx.get() method data returned" id="id1681"/> and it contains the standard fields that are available for this API endpoint.</p>

<p>Whether you called this API from the web browser or from Python, you executed an HTTP GET verb, which is used for reading information from an API. If you wanted to call a REST API to take other actions, you might use HTTP verbs such as POST, PUT, or DELETE. You will notice that REST APIs have separate endpoints for each action. For instance, this API would have separate endpoints to get a list of players or teams. The API defines the fields in the response, and they are the same for each request.</p>

<p>Another architectural style<a data-type="indexterm" data-primary="architecture of APIs" data-secondary="architectural styles" data-tertiary="GraphQL" id="id1682"/><a data-type="indexterm" data-primary="GraphQL (Graph Query Language) APIs" id="id1683"/><a data-type="indexterm" data-primary="endpoints of APIs" data-secondary="GraphQL APIs" id="id1684"/><a data-type="indexterm" data-primary="API endpoints" data-secondary="GraphQL APIs" id="id1685"/><a data-type="indexterm" data-primary="architecture of APIs" data-secondary="architectural styles" data-tertiary="REST versus GraphQL" id="id1686"/><a data-type="indexterm" data-primary="REST (Representational State Transfer) APIs" data-secondary="GraphQL versus" id="id1687"/><a data-type="indexterm" data-primary="GraphQL (Graph Query Language) APIs" data-secondary="REST versus" id="id1688"/> that is useful for data science is GraphQL, which has several differences from REST. Where REST APIs have multiple endpoints, a GraphQL API has only one. Where REST APIs return the same fields each time an endpoint is called, GraphQL allows the consumer to define what fields they want. <a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" data-tertiary="GraphQL versus REST APIs" id="id1689"/><a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" data-tertiary="REST APIs" id="id1690"/>Where REST uses an HTTP GET when reading data, GraphQL uses an HTTP POST. Since a web browser by default sends an HTTP GET, you can’t directly call a GraphQL API in the browser. However, some GraphQL APIs provide a web interface that allows you to query the API.</p>

<p>To make a request to a GraphQL API in Python, you can send a query in a POST command using the httpx library as follows:<a data-type="indexterm" data-primary="httpx Python library" data-secondary="httpx.post() method for GraphQL" id="id1691"/></p>

<pre data-type="programlisting" data-code-language="python">import httpx

graphql_url = "https://countries.trevorblades.com"

json_query = {'query': '''
{
  country(code: "US") {
    name
    native
    currency
    languages {
      code
      name
    }
  }
}
'''}

api_response = httpx.post(graphql_url, json=json_query)
print(api_response.json())</pre>

<p>The data is returned <a data-type="indexterm" data-primary="JSON" data-secondary="httpx.post() method for GraphQL data returned" id="id1692"/> in JSON format and contains only the fields that you requested as follows:</p>
<pre data-type="programlisting">
{'data': {'country': {'name': 'United States', 'native': 'United States',
'currency': 'USD,USN,USS', 'languages': [{'code': 'en', 'name': 'English'}]}}}
</pre>

<p>(Thanks to Trevor Blades for his <a href="https://github.com/trevorblades/countries">sample GraphQL API and the example code</a>.)<a data-type="indexterm" data-primary="Blades, Trevor" id="id1693"/></p>

<p>The last API architectural style<a data-type="indexterm" data-primary="architecture of APIs" data-secondary="architectural styles" data-tertiary="gRPC" id="id1694"/><a data-type="indexterm" data-primary="gRPC APIs" id="id1695"/><a data-type="indexterm" data-primary="protocol buffers data format" id="id1696"/><a data-type="indexterm" data-primary="gRPC APIs" data-secondary="protocol buffers data format" id="id1697"/> that I will mention is gRPC, and it is quite a bit different from REST or GraphQL. gRPC enables cross-language <em>remote procedure calls</em>, which means that your program code can call an external gRPC service like a local one. Data scientists are most likely to use gRPC when calling a machine learning model, such as a large language model.</p>

<p>gRPC uses a data format called <em>protocol buffers</em> instead of JSON, and it uses HTTP/2, which is a different communications protocol from the HTTP/1 protocol that is typically used by GraphQL and REST. These two differences allow gRPC to have very fast communication and support two-way data streaming instead of the request/response communication that the other two APIs use.</p>

<p>The Python code examples<a data-type="indexterm" data-primary="gRPC APIs" data-secondary="Python quickstart guide online" id="id1698"/><a data-type="indexterm" data-primary="resources online" data-secondary="gRPC Python quickstart guide" id="id1699"/> for calling a gRPC API are a bit too complicated to show in this introductory section, but a <a href="https://oreil.ly/nhwZ1">Python quickstart</a> is available if you would like to learn more about this.<a data-type="indexterm" data-startref="ch8varty" id="id1700"/><a data-type="indexterm" data-startref="ch8varty2" id="id1701"/><a data-type="indexterm" data-startref="ch8varty3" id="id1702"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="HTTP Basics"><div class="sect1" id="http_basics">
<h1>HTTP Basics</h1>

<p class="less_space pagebreak-after">Most APIs use HTTP,<a data-type="indexterm" data-primary="HTTP" data-secondary="basics" id="id1703"/><a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="HTTP basics" id="id1704"/><a data-type="indexterm" data-primary="APIs" data-secondary="HTTP protocol used by most" data-seealso="HTTP" id="id1705"/><a data-type="indexterm" data-primary="APIs" data-secondary="URL with HTTPS" data-seealso="URL of API" id="id1706"/> so it helps to learn more about it. The first tip is pretty simple: only use APIs with <em>HTTPS</em> in the URL—this means that all the API traffic will be encrypted in transit.</p>

<p>Two more HTTP items to understand<a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" id="id1707"/> are HTTP verbs and HTTP status codes. HTTP verbs are called <em>methods</em> by the <a href="https://oreil.ly/m5TTp">official HTTP standards document</a>, which says a method “indicates the purpose for which the client has made this request and what is expected by the client as a successful result.”</p>

<p>When you call an API in a web browser,<a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" data-tertiary="REST APIs" id="id1708"/><a data-type="indexterm" data-primary="GET HTTP verb" id="id1709"/> you are using a GET method, which asks for a read-only copy of a resource or list of resources. <a data-type="xref" href="#HTTP_verb_table_ch8">Table 8-1</a> lists common HTTP verbs that are used for REST APIs.<a data-type="indexterm" data-primary="POST HTTP verb" id="id1710"/><a data-type="indexterm" data-primary="PUT HTTP verb" id="id1711"/><a data-type="indexterm" data-primary="DELETE HTTP verb" id="id1712"/></p>
<table id="HTTP_verb_table_ch8">
<caption><span class="label">Table 8-1. </span>HTTP verbs and REST API usage</caption>
<thead>
<tr>
<th>HTTP verb (method)</th>
<th>Use with APIs</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>GET</p></td>
<td><p>Read a resource or list of resources.</p></td>
<td><p>GET <em>api.sportsworldcentral.com.com/players/</em></p></td>
</tr>
<tr>
<td><p>POST</p></td>
<td><p>Create a new resource.</p></td>
<td><p>PUT <em>api.sportsworldcentral.com.com/team/</em></p></td>
</tr>
<tr>
<td><p>PUT</p></td>
<td><p>Update an existing resource.</p></td>
<td><p>PUT <em>api.sportsworldcentral.com.com/players/1234</em></p></td>
</tr>
<tr>
<td><p>DELETE</p></td>
<td><p>Remove an existing resource.</p></td>
<td><p>DELETE <em>api.sportsworldcentral.com.com/players/1234</em></p></td>
</tr>
</tbody>
</table>

<p>With the GET and DELETE requests in <a data-type="xref" href="#HTTP_verb_table_ch8">Table 8-1</a>, the information in the URL is sufficient to perform the command, but POST and PUT would need information for creating or updating the player. This is the purpose of the HTTP message body. For APIs, the body contains JSON or XML data that the API uses to perform the action. As mentioned earlier, for GraphQL APIs, you always send a POST request, and the body of the message contains the query that you are sending to the API.</p>

<p>When the request is processed<a data-type="indexterm" data-primary="HTTP" data-secondary="status codes" id="id1713"/> by the API’s server, it returns an HTTP response, which has a <em>status code</em>, a numeric code that tells you if it was able to process your request. <a data-type="indexterm" data-primary="HTTP" data-secondary="status codes" data-tertiary="200 as successful response" id="id1714"/>If all goes well, the response will have a status code of 200—meaning success—and the data you asked for if you were expecting any. Success doesn’t always occur, and <a data-type="xref" href="#HTTP_status_code_table_ch8">Table 8-2</a> lists some other status codes you may encounter when calling APIs.<a data-type="indexterm" data-primary="HTTP" data-secondary="status codes" data-tertiary="table of status codes" id="id1715"/><a data-type="indexterm" data-primary="HTTP" data-secondary="status codes" data-tertiary="404 as not found" id="id1716"/></p>
<table id="HTTP_status_code_table_ch8">
<caption><span class="label">Table 8-2. </span>HTTP status codes</caption>
<thead>
<tr>
<th>Status code</th>
<th>Typical meaning for API calls</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>2XX</p></td>
<td><p>Status codes beginning with 2 indicate success.</p></td>
</tr>
<tr>
<td><p>200 OK</p></td>
<td><p>The request was successful.</p></td>
</tr>
<tr>
<td><p>201 Created</p></td>
<td><p>A POST method successfully created a resource.</p></td>
</tr>
<tr>
<td><p>3XX</p></td>
<td><p>Status codes beginning with 3 indicate redirection.</p></td>
</tr>
<tr>
<td><p>301 or 308 Moved Permanently</p></td>
<td><p>The API address has moved permanently, so you should change your API call.</p></td>
</tr>
<tr>
<td><p>302 Moved Found</p></td>
<td><p>The API address redirected temporarily. Keep using the address you used.</p></td>
</tr>
<tr>
<td><p>4XX</p></td>
<td><p>Status codes beginning with 4 indicate client error.</p></td>
</tr>
<tr>
<td><p>400 Bad Request</p></td>
<td><p>Your request has an error or invalid request.</p></td>
</tr>
<tr>
<td><p>401 Unauthorized</p></td>
<td><p>Invalid credentials to make the API call.</p></td>
</tr>
<tr>
<td><p>404 Not Found</p></td>
<td><p>The resource doesn’t exist or the address is wrong.</p></td>
</tr>
<tr>
<td><p>5XX</p></td>
<td><p>Status codes beginning with 5 indicate server error.</p></td>
</tr>
<tr>
<td><p>500 Internal Server Error</p></td>
<td><p>Something failed unexpectedly on the server.</p></td>
</tr>
<tr>
<td><p>503 Service Unavailable</p></td>
<td><p>Temporary issue with service. Retry may be appropriate.</p></td>
</tr>
</tbody>
</table>

<p>The <a href="https://oreil.ly/rfc_1">official HTTP standards document</a> gives more detailed information about the status codes.<a data-type="indexterm" data-primary="HTTP" data-secondary="basics" data-tertiary="standards document online" id="id1717"/><a data-type="indexterm" data-primary="resources online" data-secondary="HTTP standards document" id="id1718"/><a data-type="indexterm" data-primary="HTTP" data-secondary="status codes" data-tertiary="more status codes online" id="id1719"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="How to Consume APIs Responsibly"><div class="sect1" id="id88">
<h1>How to Consume APIs Responsibly</h1>

<p>The code samples earlier<a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="responsibilities of API use" id="id1720"/> in this chapter show that APIs can be called easily with a few lines of code. This ease of use is probably one of the reasons that APIs have become so widespread in software development and data science.</p>

<p>But when using APIs for real-world analysis and applications, there are additional items you need to consider, including the following:</p>
<dl>
<dt>Follow the terms of service.</dt>
<dd>
<p>When using a new API,<a data-type="indexterm" data-primary="terms of service" data-secondary="following others’" id="id1721"/> start by reading the terms of service. This will tell you up front what expectations and requirements the API providers have for you to use their API. <a data-type="indexterm" data-primary="MyFantasyLeague API documentation" data-secondary="terms of service" id="id1722"/>For example, the <a href="https://oreil.ly/X3Jcf">MyFantasyLeague API terms of service</a> state that the APIs are free to use, but they can’t be used to cheat in your fantasy league or harvest user data. Terms of service often list the default rate limiting that is in place, for example, saying that no user should make more than 1,000 API requests per hour. This prevents one user from swamping the service, or even the API provider’s website if they are hosted on the same infrastructure. MyFantasyLeague doesn’t list specific rate limits but forbids users from overloading the service (even by accident) and requests that users cache slow-changing data locally to reduce network traffic.</p>
</dd>
<dt>Handle retries gently.</dt>
<dd>
<p>You may want to<a data-type="indexterm" data-primary="backoff and retry process" data-secondary="avoiding overwhelming the service" id="id1723"/> enable an automated retry process in cases of temporary errors that may occur on the server side. To avoid overwhelming the service (and possibly getting your access disabled), consider implementing a backoff and retry process, as discussed in <a data-type="xref" href="ch07.html#chapter_7">Chapter 7</a>.</p>
</dd>
<dt>Handle credentials safely.</dt>
<dd>
<p>Most API publishers<a data-type="indexterm" data-primary="credentials handled safely" id="id1724"/> have some method of registering users for their APIs, even if access is free. This allows them to monitor how you are using their APIs and contact you about upcoming changes to their APIs. There are a variety of API authentication methods used by API providers, such as usernames, passwords, API keys, secret keys, tokens, and others. All API credentials should be stored securely and implemented in your code using a secrets manager or environment variables. Credentials should never be stored in program code or in files that will be included in a code repository. If credentials get exposed somehow, deactivate them immediately and get new ones. <a data-type="indexterm" data-primary="credentials handled safely" data-secondary="best practices article online" id="id1725"/><a data-type="indexterm" data-primary="resources online" data-secondary="Google article on API key security" id="id1726"/><a data-type="indexterm" data-primary="“Best practices for securely using API keys” (Google)" data-primary-sortas="Best practices for securely using" id="id1727"/><a data-type="indexterm" data-primary="Google" data-secondary="article on API key security" id="id1728"/>Google includes additional tips in <a href="https://oreil.ly/E_WRf">“Best practices for securely using API keys”</a>.</p>
</dd>
<dt>Validate inputs and outputs.</dt>
<dd>
<p>As an API consumer,<a data-type="indexterm" data-primary="data validation" data-secondary="inputs and outputs" id="id1729"/><a data-type="indexterm" data-primary="SQL injection" data-secondary="handling input data" id="id1730"/> you should handle data you receive from APIs carefully, and consider risks such as <em>SQL injection</em>, which is when bad actors try to send destructive SQL commands in fields where data is expected. You should also ensure that the data you send to APIs fits data types they expect.</p>
</dd>
<dt>Log and diagnose errors.</dt>
<dd>
<p>If you consume an API<a data-type="indexterm" data-primary="using APIs" data-secondary="errors logged" id="id1731"/><a data-type="indexterm" data-primary="building APIs" data-secondary="launching your API" data-tertiary="errors logged" id="id1732"/><a data-type="indexterm" data-primary="launching your API" data-secondary="errors logged" id="id1733"/><a data-type="indexterm" data-primary="errors in your API logged" id="id1734"/><a data-type="indexterm" data-primary="logging" data-secondary="SDK logging" data-tertiary="API errors and error messages" id="id1735"/> in a recurring data pipeline, you need to handle and log errors. Your code should handle logging in an organized fashion, to track error messages and informational messages. This will be useful to debug any issues that you encounter and be able to verify previous executions of your code.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Separation of Concerns: Using SDKs or Creating API Clients"><div class="sect1" id="id89">
<h1>Separation of Concerns: Using SDKs or Creating API Clients</h1>

<p>An important principle in <a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="separation of concerns" id="id1736"/><a data-type="indexterm" data-primary="separation of concerns (SoC)" id="id1737"/>software development is <em>separation of concerns</em> (SoC), which means that a computer program should be broken up into chunks that perform a specific task. Consuming APIs responsibly may involve some fairly complicated logic, and code calling APIs should be separated from the rest of your code. For data scientists who like to build large projects in a single Jupyter Notebook, this may be a hard habit to adjust to. But the time it takes to implement will save you headaches in operation.</p>

<p>If the API provider publishes<a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="SDKs" data-seealso="SDK (software development kit)" id="id1738"/><a data-type="indexterm" data-primary="SDK (software development kit)" data-secondary="use an SDK when available" id="id1739"/><a data-type="indexterm" data-primary="SDK (software development kit)" data-secondary="use an SDK when available" data-tertiary="PyPI package repository as source" id="id1740"/><a data-type="indexterm" data-primary="PyPI Test Repository" data-secondary="source for SDKs" id="id1741"/><a data-type="indexterm" data-primary="PyPI Test Repository" data-secondary="source for SDKs" data-tertiary="code for using SDK to call API" id="id1742"/> an SDK, you should use that. SDKs can provide advanced features that are created to work with a specific API. Many times, they are published on the <a href="https://pypi.org">PyPI package repository</a> and can be installed using <code>pip</code>.</p>

<p>For example, the Python SDK<a data-type="indexterm" data-primary="SDK (software development kit)" data-secondary="publishing on PyPI Test Repository" id="id1743"/><a data-type="indexterm" data-primary="publishing SDK PyPI Test Repository" id="id1744"/><a data-type="indexterm" data-primary="PyPI Test Repository" data-secondary="publishing SDK" id="id1745"/><a data-type="indexterm" data-primary="publishing" data-secondary="SDK on PyPI Test Repository" id="id1746"/> created in <a data-type="xref" href="ch07.html#chapter_7">Chapter 7</a> for the SportsWorldCentral API could be published on PyPI. <a data-type="xref" href="#swcpy_pypi_ch8">Figure 8-2</a> shows how this SDK would look on the PyPI repository.</p>

<figure><div id="swcpy_pypi_ch8" class="figure">
<img src="assets/haad_0802.png" alt="Example SDK on PyPI" width="1825" height="1254"/>
<h6><span class="label">Figure 8-2. </span>Example SDK on PyPI</h6>
</div></figure>

<p>To use this SDK to call the API, the following Python code would be used:<a data-type="indexterm" data-primary="import statement (Python)" data-secondary="SDK from PyPI repository calling API" id="id1747"/><a data-type="indexterm" data-primary="Python" data-secondary="import statement" data-tertiary="SDK from PyPI repository calling API" id="id1748"/></p>

<pre data-type="programlisting" data-code-language="python">from pyswc import SWCClient
from pyswc import SWCConfig

config = SWCConfig()
client = SWCClient(config)
player_response = client.get_player_by_id(352)</pre>

<p>The SDK is simple to call, but it includes advanced features such as backoff and retry, data validation, error handling, and logging. This is an example of the benefits that come from using an SDK when one is available.</p>

<p>If no SDK is available, <a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="SDKs not available, build client" id="id1749"/>you can separate your own API-calling code into a standalone client. You can implement the same type of functionality that an API provider’s SDK would contain, but it is code you will need to maintain. In <a data-type="xref" href="ch09.html#chapter_9">Chapter 9</a>, you will create a Python client for the SWC API and use it in a Jupyter Notebook. You will reuse this client in <a data-type="xref" href="ch11.html#chapter_11">Chapter 11</a> to call the SWC API in a Streamlit data app. This demonstrates how separating your API-calling code into a client file saves time and effort.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="How to Build APIs"><div class="sect1" id="id90">
<h1>How to Build APIs</h1>

<p>Data scientists increasingly need<a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="how to build APIs" data-seealso="building APIs" id="id1750"/> to build APIs to share the work they are doing. For instance, you may have custom metrics you have created and you would like to make them available for other data scientists to use in their work. An API is an efficient and useful way to share this data. In addition to sharing data, you may have a statistical model or machine learning model that you would like to make available. <a data-type="indexterm" data-primary="inference endpoint" id="id1751"/>You can create an API as an <em>inference endpoint</em>, which allows users to use the model to predict outcomes based on data they submit. You will learn this in <a data-type="xref" href="ch12.html#chapter_12">Chapter 12</a>. Even if you are primarily a user of APIs rather than a builder, you can benefit by building a few APIs yourself to view from the other side of the desk. <a data-type="xref" href="part01.html#part_1">Part I</a> of this book is entirely focused on building APIs—check it out if you haven’t already!</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="How to Test APIs"><div class="sect1" id="id91">
<h1>How to Test APIs</h1>

<p>Testing APIs is critical for API <a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="how to test APIs" data-seealso="testing APIs" id="id1752"/><a data-type="indexterm" data-primary="testing APIs" id="id1753"/>producers and consumers. API producers will perform testing throughout their development, deployment, and maintenance phases of hosting an API. <a data-type="indexterm" data-primary="service level agreements (SLAs)" id="id1754"/><a data-type="indexterm" data-primary="SLAs (service level agreements)" id="id1755"/>They are responsible for ensuring that an API is reliable and  that it lives up to customer expectations and any <em>service level agreements</em> (SLAs), which are formal agreements that producers make with consumers about uptime, performance, or other aspects of API service. API consumers will need to test APIs before using them in their systems to ensure that they work as intended.</p>

<p><a href="https://oreil.ly/aET_m">Postman recommends</a> four major types of API testing:</p>
<dl>
<dt>Contract testing</dt>
<dd>
<p>Verifies the format and behavior of each endpoint</p>
</dd>
<dt>Unit testing</dt>
<dd>
<p>Confirms the behavior of an individual endpoint</p>
</dd>
<dt>End-to-end testing</dt>
<dd>
<p>Tests workflows that use multiple endpoints</p>
</dd>
<dt>Load testing</dt>
<dd>
<p>Verifies performance items such as the number of concurrent requests that can be processed at peak times and the response time for individual requests</p>
</dd>
</dl>

<p>The pytest library is a Python testing library<a data-type="indexterm" data-primary="pytest" data-secondary="about" id="id1756"/><a data-type="indexterm" data-primary="testing APIs" data-secondary="pytest" data-seealso="pytest" id="id1757"/> that is straightforward to use. Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#chapter_3">3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#chapter_4">4</a> show how to use it to test SQLAlchemy database code and FastAPI APIs. <a data-type="indexterm" data-primary="Locust load-testing library" id="id1758"/>One Python load-testing library is <a href="https://locust.io">Locust</a>. <a data-type="xref" href="#locust_test_ch8">Figure 8-3</a> shows an example Locust load test measuring the number of requests per second that an API can process with multiple concurrent users.</p>

<figure><div id="locust_test_ch8" class="figure">
<img src="assets/haad_0803.png" alt="Example Locust load test report" width="1935" height="688"/>
<h6><span class="label">Figure 8-3. </span>Example Locust load test report</h6>
</div></figure>

<p>There are additional types of testing beyond these four. <a data-type="indexterm" data-primary="Gregory, Janet" id="id1759"/><a data-type="indexterm" data-primary="Crispin, Lisa" id="id1760"/>The agile testing quadrants from Janet Gregory and Lisa Crispin provide a big-picture view of testing. Comprehensive testing includes technology-facing tests such as unit testing and performance testing and business-facing tests such as prototyping and usability tests. Don’t forget to include your API documentation and SDKs in your testing. <a data-type="indexterm" data-primary="testing APIs" data-secondary="four quadrants article online" id="id1761"/><a data-type="indexterm" data-primary="resources online" data-secondary="testing the four quadrants article" id="id1762"/><a data-type="indexterm" data-primary="“Quick Tools for Agile Testing” online" data-primary-sortas="Quick Tools for Agile Testing" id="id1763"/>To learn more about the four quadrants, read <a href="https://oreil.ly/j1ihN">“Quick Tools for Agile Testing”</a>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="API Deployment and Containerization"><div class="sect1" id="id92">
<h1>API Deployment and Containerization</h1>

<p>To share an API, you have to deploy it.<a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="API deployment and containerization" id="id1764"/> The typical deployment model for APIs is using a cloud host, although if your users are strictly internal, you may be deploying to an on-premises server. <a data-type="indexterm" data-primary="containerization" id="id1765"/>Many cloud hosts support <em>containerization</em>, which is packaging your program code into a reusable package that can be run locally or on another server or cloud provider. Docker is the most prevalent containerization software. <a data-type="xref" href="ch06.html#chapter_6">Chapter 6</a> demonstrates deploying your API to two different clouds and containerizing your API with Docker.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Using Version Control"><div class="sect1" id="id93">
<h1>Using Version Control</h1>
<blockquote>
  <p>Version control is a way of tracking what changes have been made to a codebase, and it allows multiple people to work on the same code easily. </p>
  <p data-type="attribution">Catherine Nelson, <em>
Software Engineering for Data Scientists</em> (O’Reilly, 2024)</p>
</blockquote>

<p>This item isn’t limited to <a data-type="indexterm" data-primary="Nelson, Catherine" id="id1766"/><a data-type="indexterm" data-primary="Software Engineering for Data Scientists (Nelson)" id="id1767"/><a data-type="indexterm" data-primary="using APIs" data-secondary="what data scientists should know" data-tertiary="version control" id="id1768"/><a data-type="indexterm" data-primary="version control" id="id1769"/>working with APIs—​it is a foundational skill that all data scientists will benefit from. Managing your code with version control will save hours of frustration when you’re working alone and really makes things easier when you’re working as a team. <a data-type="indexterm" data-primary="GitHub" data-secondary="version control" id="id1770"/>This part of the book continues the use of GitHub as the version control repository for your code and a place to showcase your work. You will also perform all of your development in GitHub Codespaces.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Introducing Your Part II Portfolio Project"><div class="sect1" id="id194">
<h1>Introducing Your Part II Portfolio Project</h1>

<p>In this part of the book, you will create a <a data-type="indexterm" data-primary="portfolio projects" data-secondary="analytics project introduction" id="id1771"/><a data-type="indexterm" data-primary="portfolio projects" data-secondary="Part II project introduction" id="id1772"/>portfolio project that demonstrates your ability to create analytics and other data science products that use APIs as a source. Here is an overview of the work ahead of you:</p>

<ul>
<li>
<p><a data-type="xref" href="ch09.html#chapter_9">Chapter 9</a>: Using APIs in data analytics products using Jupyter Notebooks</p>
</li>
<li>
<p><a data-type="xref" href="ch10.html#chapter_10">Chapter 10</a>: Using APIs in data pipelines using Apache Airflow</p>
</li>
<li>
<p><a data-type="xref" href="ch11.html#chapter_11">Chapter 11</a>: Using APIs in a Streamlit data application</p>
</li>
</ul>

<p>Each of these tasks will enable you to showcase your API and data science skills <span class="keep-together">differently.</span></p>
<div data-type="tip"><h6>Tip</h6>
<p>As you go through each chapter in this part, follow the instructions and create the code yourself. You’ll learn much more by doing this than reading alone. If you run into any trouble, the files in the <em>\complete</em> folder are available to check your work. If you would like to complete the chapters out of order, you can also use the 
<span class="keep-together">completed</span> files from the previous chapters as the starting point.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Getting Started with Your GitHub Codespace"><div class="sect1" id="ch08_getting_started">
<h1>Getting Started with Your GitHub Codespace</h1>

<p>As you did in <a data-type="xref" href="part01.html#part_1">Part I</a>, you will use GitHub Codespaces for all the code you develop. If you didn’t create a GitHub account yet, do that now.</p>








<section data-type="sect2" data-pdf-bookmark="Cloning the Part II Repository"><div class="sect2" id="id230">
<h2>Cloning the Part II Repository</h2>

<p>All of the Part II code examples<a data-type="indexterm" data-primary="resources online" data-secondary="chapter code" data-tertiary="Part II code" id="id1773"/><a data-type="indexterm" data-primary="GitHub" data-secondary="cloning the repository" data-tertiary="cloning Part II" id="id1774"/> are contained in  <a href="https://github.com/handsonapibook/api-book-part-two">this book’s GitHub repository</a>.</p>

<p>To clone the repository, log in to GitHub and go to the <a href="https://github.com/new/import">Import Repository page</a>. Enter the following information:<a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="URL of" id="id1775"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="URL of" data-tertiary="Part II" id="id1776"/></p>

<ul>
<li>
<p><em>The URL for your source repository</em>: <strong><code><a href="https://github.com/handsonapibook/api-book-part-two" class="bare"><em class="hyperlink">https://github.com/handsonapibook/api-book-part-two</em></a></code></strong></p>
</li>
<li>
<p><em>Your username for your source code repository</em>: Leave blank.</p>
</li>
<li>
<p><em>Your access token or password for your source code repository</em>: Leave blank.</p>
</li>
<li>
<p><em>Repository name</em>: <strong><code>analytics-project</code></strong></p>
</li>
<li>
<p><em>Public</em>: Select this so that you can share the results of the work you are doing.</p>
</li>
</ul>

<p class="less_space pagebreak-before">Click Begin Import. The import process will begin and the message “Preparing your new repository” will be displayed. After several minutes, you will receive an email notifying you that your import has finished. Follow the link to your new cloned repository.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Launching Your GitHub Codespace"><div class="sect2" id="id195">
<h2>Launching Your GitHub Codespace</h2>

<p>In your new repository, <a data-type="indexterm" data-primary="GitHub" data-secondary="cloning the repository" data-tertiary="launching your Part II Codespace" id="id1777"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="launching your Codespace" data-tertiary="Part II" id="id1778"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="launching your Codespace" id="id1779"/>click the Code button and select the Codespaces tab. Click “Create codespace on main.” You should see a page with the status “Setting up your codespace.” Your Codespace window will be opened as the setup continues. When the setup completes, your display will look similar to <a data-type="xref" href="#codespace_setup_complete_ch9">Figure 8-4</a>.</p>

<figure><div id="codespace_setup_complete_ch9" class="figure">
<img src="assets/haad_0804.png" alt="GitHub Codespace for Part 2" width="2382" height="1040"/>
<h6><span class="label">Figure 8-4. </span>GitHub Codespace for Part II</h6>
</div></figure>

<p>Your Codespace is now created with the cloned repository. This is the environment you will be using for this part of the book. Open the <a href="https://github.com/codespaces">GitHub Codespaces page</a> to make a couple of updates. <a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="renaming your Codespace" id="id1780"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="renaming your Codespace" id="id1781"/>Scroll down the page to find this new Codespace, click the ellipsis to the right of the name, and select Rename. Enter the name <strong>Part II Portfolio project codespace</strong> and click Save. You should see the message “Your codespace <em>Part II Portfolio project codespace</em> has been updated.” <a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="auto-deletion turned off" id="id1782"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="auto-deletion turned off" id="id1783"/>Click the ellipsis again and then click the ribbon next to “Auto-delete codespace” to turn off auto-deletion.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>To save screen real estate, <a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="terminal window prompt trimmed" id="id1784"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="terminal window" data-tertiary="trimming prompt directory listing" id="id1785"/><a data-type="indexterm" data-primary="terminal window of GitHub Codespace" data-secondary="trimming prompt directory listing" id="id1786"/>I have trimmed the directory listing in the terminal prompt of the Codespace used in the examples. You can do this in your Codespace by editing the <em>/home/codespace/.bashrc</em> file in VS Code. Find the <code>export PROMPT_DIRTRIM</code> statement and set it to <code>export PROMPT_DIRTRIM=1</code>. To load the values the first time, execute this terminal command: <code>source ~/.bashrc</code>.</p>
</div>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Running the SportsWorldCentral (SWC) API Locally"><div class="sect1" id="sportsworldcentral">
<h1>Running the SportsWorldCentral (SWC) API Locally</h1>

<p>As you work through the projects in Part II,<a data-type="indexterm" data-primary="SportsWorldCentral (SWC)" data-secondary="introduction to Part II" id="id1787"/><a data-type="indexterm" data-primary="using APIs" data-secondary="SWC API running in Codespace" id="id1788"/><a data-type="indexterm" data-primary="SportsWorldCentral (SWC)" data-secondary="website API" data-tertiary="API running in Codespace" id="id1789"/><a data-type="indexterm" data-primary="building APIs" data-secondary="launching your API" data-tertiary="running in Codespace" id="id1790"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="launching your API" data-tertiary="running in Codespace" id="id1791"/><a data-type="indexterm" data-primary="launching your API" data-secondary="running in Codespace" id="id1792"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="launching your API to run in Codespace" id="id1793"/><a data-type="indexterm" data-primary="Python" data-secondary="API files" data-tertiary="launching your API to run in Codespace" id="id1794"/><a data-type="indexterm" data-primary="data analytics" data-secondary="creating the Shark League Score" data-tertiary="running API in Codespace" id="id1795"/><a data-type="indexterm" data-primary="custom metrics" data-secondary="creating the Shark League Score" data-tertiary="running API in Codespace" id="id1796"/><a data-type="indexterm" data-primary="Shark League Score custom metric" data-secondary="running API in Codespace" id="id1797"/><a data-type="indexterm" data-primary="data pipelines" data-secondary="API launched in Codespaces" id="id1798"/><a data-type="indexterm" data-primary="Streamlit" data-secondary="API launched in Codespaces" id="id1799"/> you will be calling version 0.2 of the SportsWorldCentral (SWC) API, which is in the <em>/api</em> folder. Version 0.2 has a few endpoints that you did not create in <a data-type="xref" href="part01.html#part_1">Part I</a> of the book. These were created to demonstrate additional functionality in data science and AI projects. It also has additional sample data added. You will run the API in your Codespace and then call it from projects that you create in Jupyter, Airflow, and Streamlit.</p>
<table id="updated_swc_endpoints_ch8">
<caption><span class="label">Table 8-3. </span>Updated endpoints for the SWC Fantasy Football API v0.2</caption>
<thead>
<tr>
<th>Endpoint description</th>
<th>HTTP verb</th>
<th>URL</th>
<th>Update made</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Read week list</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/weeks/</em></p></td>
<td><p>New endpoint with max potential scoring</p></td>
</tr>
<tr>
<td><p>Read counts</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/counts/</em></p></td>
<td><p>Added week count</p></td>
</tr>
<tr>
<td><p>Read team list</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/teams/</em></p></td>
<td><p>Added <code>weekly_scores</code> for each team</p></td>
</tr>
<tr>
<td><p>Read league list</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/leagues/</em></p></td>
<td><p>Added league size to calculate max scoring</p></td>
</tr>
<tr>
<td><p>Read individual league</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/leagues/{league_id}</em></p></td>
<td><p>Added league size</p></td>
</tr>
</tbody>
</table>

<p>In the terminal, install the required libraries in your Codespace as shown, using the <em>requirements.txt</em> file that is provided:<a data-type="indexterm" data-primary="requirements.txt file for pip" data-secondary="Part II running SWC API locally" id="id1800"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="SWC API run locally" id="id1801"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="SWC API run locally" id="id1802"/><a data-type="indexterm" data-primary="terminal window of GitHub Codespace" data-secondary="SWC API run locally" id="id1803"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="terminal window" data-tertiary="SWC API run locally" id="id1804"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="terminal window SWC API run locally" id="id1805"/></p>

<pre data-type="programlisting" data-code-language="shell">.../analytics-project (main) $ cd api
.../api (main) $ pip3 install -r requirements.txt</pre>

<p>Verify that the FastAPI CLI was loaded so that you can run your API from the command line as shown:<a data-type="indexterm" data-primary="FastAPI" data-secondary="CLI" data-tertiary="Part II SWC API run locally" id="id1806"/></p>

<pre data-type="programlisting" data-code-language="shell">.../api (main) $ pip3 show fastapi-cli
Name: fastapi-cli
Version: 0.0.4
Summary: Run and manage FastAPI apps from the command line with FastAPI CLI.
[results truncated for space]</pre>

<p>Now launch the API from the command line as shown:<a data-type="indexterm" data-primary="FastAPI" data-secondary="launching your API" data-tertiary="running locally" id="id1807"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="CLI" data-tertiary="fastapi run" id="id1808"/></p>

<pre data-type="programlisting" data-code-language="shell">.../api (main) $ fastapi run main.py</pre>

<p>You will see several messages from the FastAPI CLI, ending with the following:</p>

<pre data-type="programlisting" data-code-language="shell">INFO:     Started server process [19192]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)</pre>

<p>You will see a dialog <a data-type="indexterm" data-primary="building APIs" data-secondary="launching your API" data-tertiary="port 8000 for application" id="id1809"/><a data-type="indexterm" data-primary="building APIs" data-secondary="launching your API" data-tertiary="port 8000 made public" id="id1810"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="launching your API" data-tertiary="port 8000 for application" id="id1811"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="launching your API" data-tertiary="port 8000 made public" id="id1812"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="launching your API to port 8000" id="id1813"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="launching your API to port 8000 made public" id="id1814"/><a data-type="indexterm" data-primary="launching your API" data-secondary="port 8000 for application" id="id1815"/><a data-type="indexterm" data-primary="launching your API" data-secondary="port 8000 for application" data-tertiary="making public" id="id1816"/><a data-type="indexterm" data-primary="port 8000 for application" id="id1817"/><a data-type="indexterm" data-primary="port 8000 for application" data-secondary="making public" id="id1818"/><a data-type="indexterm" data-primary="health check" data-secondary="launching API" data-tertiary="public port" id="id1819"/>stating “Your application running on port 8000 is available,” as shown in <a data-type="xref" href="#make_api_public_ch8">Figure 8-5</a>. Click Make Public.</p>

<figure><div id="make_api_public_ch8" class="figure">
<img src="assets/haad_0805.png" alt="Make API Public" width="568" height="91"/>
<h6><span class="label">Figure 8-5. </span>Makeing the API public</h6>
</div></figure>

<p>The API is now running in Codespaces with a public port. To view the API in the browser, click Ports in the terminal and hover your cursor over Port 8000, as shown in <a data-type="xref" href="#api_running_public_port_8">Figure 8-6</a>.</p>

<figure><div id="api_running_public_port_8" class="figure">
<img src="assets/haad_0806.png" alt="Open API on public address" width="557" height="148"/>
<h6><span class="label">Figure 8-6. </span>Open API on a public address</h6>
</div></figure>

<p>Click the globe icon. <a data-type="indexterm" data-primary="URL of API" data-secondary="Part II locally running API" id="id1820"/>The browser will show a base URL that ends in <em>app.github.dev</em> that contains the response from your API running on Codespaces. <a data-type="indexterm" data-primary="health check" data-secondary="launching API" id="id1821"/>You should see the following health check message in your web browser:</p>

<pre data-type="programlisting">{"message":"API health check successful"}</pre>

<p>Your API is running publicly in the cloud. Copy this base URL. You will use it in later chapters to connect to your API.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Later chapters in Part II will instruct you to launch your API in Codespaces. Follow these instructions to run the API. The API will need to be restarted each time you reconnect to Codespaces.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Additional Resources"><div class="sect1" id="id95">
<h1>Additional Resources</h1>

<p>To learn more about the features of REST, GraphQL, and gRPC, read <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>.</p>

<p>To learn about creating data APIs, read <a data-type="xref" href="part01.html#part_1">Part I</a> (and create a portfolio project).</p>

<p>To learn how to package API client code and create SDKs, read <a data-type="xref" href="ch07.html#chapter_7">Chapter 7</a>.<a data-type="indexterm" data-startref="ch8know" id="id1822"/></p>
</div></section>






<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Summary"><div class="sect1" id="id387">
<h1>Summary</h1>

<p>This chapter covered some of the basic topics that data scientists need to know about APIs. You learned about major API architectural styles, including REST, GraphQL, and gRPC. You learned the basics of HTTP verbs and status codes. You learned about using APIs responsibly and the benefits of an SDK. Finally, you saw the value of learning to build, test, and deploy your APIs.</p>

<p>In <a data-type="xref" href="ch09.html#chapter_9">Chapter 9</a>, you will start to dig into the details of these topics as you use APIs in data analytics.</p>
</div></section>
</div></section></div>
</div>
</body></html>