["```py\nconda create -n genaiservice python=3.11\nconda activate genaiservice\n```", "```py\n$ python3 -m venv .venv\n```", "```py`` `venv` crea il tuo ambiente virtuale nella cartella `.venv` che puoi attivare con questo comando:    ```", "```py   ```", "```py $ pip install \"fastapi[standard]\" uvicorn openai ```", "```py` ```", "```py```", "``` ```", "````` ```py```` ## Creare un semplice server web FastAPI    Una volta installate FastAPI e le sue dipendenze, sei pronto per avviare il tuo server web. Per creare un semplice server web con un endpoint in FastAPI, devi scrivere solo 15 righe di codice. Crea un file *main.py* nella radice della tua directory, come mostrato nell'[Esempio 2-1](#simple_fastapi_web_server).    ###### Nota    Per semplicità, l'[esempio 2-1](#simple_fastapi_web_server) utilizza l'API OpenAI. Per eseguire il codice, puoi ottenere una chiave API da [OpenAI](https://oreil.ly/SZsuD), che richiede una carta di credito. Tuttavia, ti assicuriamo che gli altri esempi di codice in questo libro utilizzeranno il più possibile modelli open source.    ##### Esempio 2-1\\. Codice di partenza per un semplice server web FastAPI che serve richieste GPT-4o    ```py # main.py from fastapi import FastAPI from openai import OpenAI  app = FastAPI() ![1](assets/1.png) openai_client = OpenAI(api_key=\"*`your_api_key`*\") ![2](assets/2.png)  @app.get(\"/\") def root_controller():     return {\"status\": \"healthy\"}  @app.get(\"/chat\") ![3](assets/3.png) def chat_controller(prompt: str = \"Inspire me\"): ![3](assets/3.png)     response = openai_client.chat.completions.create( ![4](assets/4.png)         model=\"gpt-4o\",         messages=[             {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},             {\"role\": \"user\", \"content\": prompt},         ],     )     statement = response.choices[0].message.content     return {\"statement\": statement} ![5](assets/5.png) ```    [![1](assets/1.png)](#co_getting_started_with_fastapi_CO1-1)      Crea un oggetto applicazione FastAPI.      [![2](assets/2.png)](#co_getting_started_with_fastapi_CO1-2)      Per utilizzare l'API OpenAI è necessaria una [chiave API](https://oreil.ly/PP0nN).      [![3](assets/3.png)](#co_getting_started_with_fastapi_CO1-3)      Utilizza il decoratore `@app.get` per creare un endpoint `GET` sul percorso `/chat`.      [![4](assets/4.png)](#co_getting_started_with_fastapi_CO1-5)      Effettua una chiamata API alla OpenAI Completions API per generare una risposta dal modello `gpt-4o`.      [![5](assets/5.png)](#co_getting_started_with_fastapi_CO1-6)      Tutti i dati restituiti dalla funzione decorata saranno restituiti quando si raggiunge l'endpoint della radice.      Ora puoi avviare il server utilizzando il comando `fastapi dev`, come mostrato qui:^([2](ch02.html#id511))    ```py $ fastapi dev >> server   Server started at http://127.0.0.1:8000 `````", "````` >> INFO   Uvicorn running on http://127.0.0.1:8000 `(`Press CTRL+C to quit`)` ```py` >> INFO   Started reloader process `[``4172``]` using WatchFiles ``` >> INFO   Started server process `[``11316``]` `` >> INFO   Waiting `for` application startup. `>> INFO   Application startup complete.` `` ```py ```` ```py`` `````", "```   ```", "``` ``Il tuo server web è ora accessibile da `http://127.0.0.1:8000` con due endpoint esposti alle rotte radice `/` e `/chat`.    Se visiti `http://127.0.0.1:8000` nel tuo browser, dovresti vedere il messaggio `{\"status\": \"healthy\"}`. Inoltre, quando visiti `http://127.0.0.1:8000/chat`, dovresti vedere un messaggio di ispirazione dal modello `gpt-4o` di OpenAI.    Congratulazioni, ora hai un servizio di IA generativa completamente funzionante.    ###### Suggerimento    Poiché hai avviato il server in un modello dev utilizzando il comando `fastapi dev`, un processo di file watcher è in ascolto per le modifiche al tuo progetto e aggiorna automaticamente il servizio quando aggiorni il codice.    Non esitare a cambiare il prompt predefinito e ad aggiornare il browser per vedere le tue modifiche in tempo reale.    L'oggetto `app`, creato dalla classe `FastAPI`, converte la tua funzione Python con un decoratore in un endpoint HTTP (Hypertext Transfer Protocol). Puoi attivare entrambi gli endpoint inviando una richiesta HTTP.    Il pacchetto `uvicorn` prende l'oggetto `app` e avvia un server web che esegue il tuo servizio FastAPI.    Oltre a ottenere un semplice server web, avrai anche una documentazione API generata automaticamente per te. La documentazione segue lo standard OpenAPI e include una specifica `openapi.json` del tuo servizio web e una pagina di documentazione Swagger costruita a partire dallo stesso file di specifica.    Puoi accedere alla pagina dei documenti autogenerati collegandoti al percorso `/docs` del tuo server tramite `http://localhost:8000/docs`; vedrai una pagina simile a quella della [Figura 2-1](#swagger_docs).  ![bgai 0201](assets/bgai_0201.png)  ###### Figura 2-1\\. Documentazione Swagger generata automaticamente dell'API    Dalla pagina dei documenti Swagger, puoi inviare richieste alla tua API per testare rapidamente un endpoint. La pagina dei documenti si occuperà anche di inviare le intestazioni, i metodi e i parametri di richiesta corretti.    Ciò che mi piace della pagina dei documenti di Swagger è che puoi iterare rapidamente su varie implementazioni utilizzando l'interfaccia utente, il che può essere più veloce della scrittura di test durante l'iterazione del design delle tue API. Tuttavia, questo non sostituisce i test tradizionali che possono controllare ogni endpoint quando si apportano modifiche. Man mano che la tua applicazione cresce, vale ancora la pena di scrivere dei test. Una volta che le firme dei tuoi endpoint sono ulteriormente stabilite, puoi scrivere i test di `pytest` per testare sistematicamente il tuo servizio web da un capo all'altro.    Oltre alla documentazione automatica, FastAPI offre anche la serializzazione automatica e la convalida dei dati. Nell'[Esempio 2-1](#simple_fastapi_web_server), abbiamo restituito un dizionario nel controller principale quando hai visitato `http://localhost:8000`. C'è un po' di magia che deve accadere affinché i dati vengano visualizzati nel browser. I dati devono prima essere serializzati da un oggetto Python come un dizionario o un elenco in una stringa JavaScript Object Notation (JSON). Successivamente, vengono trasferiti sul web e deserializzati in un oggetto JavaScript dal client del browser una volta completata la trasmissione. Questo è il modo in cui le applicazioni sul web \"parlano\" tra loro.    ###### Nota    La serializzazione è necessaria quando si utilizza HTTP per la trasmissione dei dati, poiché solo i dati testuali o binari possono essere trasferiti tramite HTTP.    Ora che hai un server FastAPI funzionante, vediamo le caratteristiche e i vantaggi di FastAPI che puoi utilizzare nel tuo progetto.`` ```", "```` ```py````", "```py```", "```py```", "```  ```", "``` ```", "```py`# Caratteristiche e vantaggi di FastAPI    Vuoi un framework web adatto che ti permetta di creare senza fatica i tuoi servizi di intelligenza artificiale generativa, senza inutili difficoltà. Questo framework dovrebbe includere tutti gli elementi essenziali per la sicurezza, l'autenticazione e le prestazioni, pur garantendoti la flessibilità necessaria per incorporare tutte le funzionalità e le integrazioni aggiuntive richieste man mano che la tua applicazione cresce in complessità.    FastAPI è in grado di soddisfare la maggior parte di questi criteri, in quanto offre diverse funzionalità e vantaggi. Tuttavia, come scoprirai più avanti in questo capitolo sui [limiti di FastAPI](#fastapi_limitations), i casi d'uso avanzati, come i carichi di lavoro AI ad alta intensità di risorse, possono richiedere framework o soluzioni web specializzate, come verrà illustrato nel [Capitolo 3](ch03.html#ch03).    Per ora, esaminiamo le caratteristiche e i vantaggi di FastAPI prima di discutere i suoi limiti nel contesto della creazione di servizi di intelligenza artificiale generativa.    ## Ispirato al modello di instradamento di Flask    Sia in Flask che in FastAPI, puoi creare qualsiasi rotta decorando una funzione con un decoratore specializzato. Puoi quindi configurare le rotte per accettare e convalidare intestazioni, cookie, corpo, percorso e parametri di query per supportare la tua implementazione.    ## Gestione delle operazioni asincrone e sincrone    Quando costruisci un servizio, questo deve essere in grado di gestire richieste multiple da parte dipiù utenti per aumentare l'efficienza d'uso man mano che la domanda aumenta. FastAPI è in grado di [gestire](https://oreil.ly/gNYMg) senza problemi [sia le funzioni sincrone che quelle asincrone nella tua applicazione](https://oreil.ly/gNYMg) per abilitare la concorrenza fin dall'inizio.    Come vedremo in dettaglio nel [Capitolo 5](ch05.html#ch05), se definisci una rotta asincrona usando `async def`, FastAPI la eseguirà sul thread principale nel ciclo dell'evento principale.D'altra parte, se definisci una rotta sincrona (non dichiarata con la parola chiave `async` ), FastAPI la eseguirà su un *thread worker* per gestire carichi di lavoro concorrenti.    ###### Avvertenze    L'esecuzione di operazioni filettate comporta un overhead aggiuntivorispetto all'esecuzione asincrona. Pertanto, avere molti percorsi sincroni può limitare la scalabilità della tuaapplicazione.    Di conseguenza, le richieste simultanee non bloccheranno il thread principale del server. Questo è particolarmente utile quando si tratta di operazioni di input/output, come le query sui database, lo scambio di dati con le unità di elaborazione grafica (GPU),^([3](ch02.html#id527)) o le richieste HTTP.    ## Supporto integrato per le attività in background    Puoi costruire percorsi in grado di gestire attività di lunga durata (ad esempio, l'invio di e-mail) senza dover ricorrere a librerie esterne (ad esempio, `celery`). FastAPI include una [funzione per le attività in background](https://oreil.ly/aO6ml)^([4](ch02.html#id530)) per lavorare con sistemi che hanno bisogno di tempo per elaborare i dati ma che non vogliono ritardare la restituzione delle risposte alle richieste.    Non tutti i compiti possono essere eseguiti entro i limiti di pazienza dei tuoi utenti. Non vuoi farli aspettare mentre il processo continua a terminare. Puoi affidare l'operazione in corso a un compito in background eseguito su un thread separato, dopo aver risposto al cliente. Come risposta, puoi far sapere ai clienti che il tuo servizio ha accettato e messo in coda la loro richiesta per elaborarla in background.    Ad esempio, nei servizi GenAI puoi utilizzare attività in background per elaborare documenti caricati di grandi dimensioni in un database vettoriale senza bloccare il server. In questo modo il server può gestire altre richieste mentre l'elaborazione dei documenti avviene in background.    Scoprirai come costruire un sistema di questo tipo nel [Capitolo 5](ch05.html#ch05).    ## Middleware personalizzato e supporto CORS    FastAPI ti permette di aggiungere [componenti middleware](https://oreil.ly/uvlLC) al router della tua app per intercettare la comunicazione tra gli endpoint delle API e i client. Ogni middleware, posizionato davanti ai tuoi endpoint, ti permette di accedere agli oggetti di richiesta e di risposta per modificarli a seconda delle necessità. Puoi aggiungere una logica su come le richieste devono essere elaborate prima di essere consegnate ai gestori delle rotte. Una volta che la risposta è stata generata, puoi eseguire operazioni sulla risposta, come la modifica delle intestazioni, le operazioni di log e l'impostazione dei cookie, prima di inviarla al client.    Un modello comune nello sviluppo di un backend è quello di utilizzare il middleware per [aggiungere intestazioni extra a una risposta](https://oreil.ly/Yfsqg), eseguire controlli di base sulle richieste in arrivo, supportare le [richieste CORS](https://oreil.ly/6u1dI), [registrare e monitorare le comunicazioni](ch03.html#middleware_monitoring) e molto altro ancora. Puoi anche sfruttare [middleware](https://oreil.ly/AJKJt) di terze parti o [personalizzati](https://oreil.ly/AJKJt).    ## Libertà di personalizzare qualsiasi livello di servizio    In alcuni casi potresti voler uscire dalle limitazioni del tuo attuale framework web. FastAPI offre una soluzione a questo problema permettendoti di definire classi personalizzate che ereditano le classi base di Starlette, il framework web sottostante. Ad esempio, puoi [sovrascrivere i gestori di eccezioni predefiniti](https://oreil.ly/qgvgO), aggiungere [middleware ASGI personalizzati](https://oreil.ly/1A8OD) o persino [creare risposte personalizzate](https://oreil.ly/jLXUf).    Con la potenza di Pydantic o degli [encoder di FastAPI](https://oreil.ly/MJmqJ), puoi anche creare senza problemi i tuoi [serializzatori personalizzati](https://oreil.ly/UnzRk) per regolare la gestione degli oggetti datetime.    Questo ti permette di implementare le funzioni secondo le tue preferenze senza dover lottare contro FastAPI.    ## Convalida e serializzazione dei dati    Per le applicazioni che gestiscono grandi quantità di dati, è importante che i dati che stai per elaborare siano puliti e in un formato noto.    Man mano che la complessità del tuo servizio cresce, vorrai eseguire la convalida e la serializzazione dei dati. In FastAPI, puoi usare Pydantic per serializzare automaticamente i tipi di dati comuni (ad esempio, liste, dizionari, primitive) quando vengono restituiti nelle rotte API. Puoi anche definire i tuoi schemi Pydantic per i dati delle richieste e delle risposte per eseguire una convalida dei dati più rigorosa.    Ad esempio, puoi convalidare la password di un utente al momento della creazione dell'account per adeguarla ai tuoi criteri di sicurezza, come mostrato nell'[esempio 2-2](#data_validation).    ##### Esempio 2-2\\. Convalida delle password degli utenti in FastAPI utilizzando uno schema Pydantic    ```", "```py    [![1](assets/1.png)](#co_getting_started_with_fastapi_CO2-1)      Definisci un modello Pydantic con una convalida dei dati personalizzata sul campo `password`.      [![2](assets/2.png)](#co_getting_started_with_fastapi_CO2-2)      Segnala a `ValueError` se uno qualsiasi dei criteri per le password non viene rispettato.      Questo ti permette di catturare, gestire e proteggere i tuoi servizi da problemi con i dati che non vengono rilevati dai controllori statici di tipo come `mypy`.    I validatori di Pydantic ti permettono anche di convalidare a runtime tipi di dati più complessi come email, URL, UUID e altro ancora. Il[Capitolo 4](ch04.html#ch04) approfondisce come eseguire la convalida dei dati con Pydantic.    ## Ricco ecosistema di plug-in    I plug-in sono pacchetti Python che si agganciano agli interni di FastAPI e alle funzionalità esistenti. Sono simili a qualsiasi altro pacchetto Python che installi e importi nei tuoi script e richiedono configurazioni minime dopo l'installazione. Integrarli significa estendere le funzionalità del tuo servizio senza dover gestire l'ordine delle integrazioni o i problemi di compatibilità. Puoi anche rimuoverli senza rompere la tua applicazione.    Tra i plug-in più noti ci sono FastAPI Filters, Auth Users, Rate Limiting e molti altri, che puoi vedere nel [repository GitHub di Awesome FastAPI](https://oreil.ly/nKbvP).    ## Documentazione automatica    Con FastAPI, la documentazione dell'interfaccia utente di Swagger viene generata automaticamente per permetterti di visualizzare e testare tutte le rotte che crei, come hai visto nella [Figura 2-1](#swagger_docs). Durante lo sviluppo, avere una pagina di documentazione interattiva ti permette di eseguire il debug e la prototipazione delle rotte in modo più semplice e veloce, fino a quando non costruisci e gestisci le tue suite di test.    Man mano che costruisci nuovi endpoint, potresti voler rivisitare la pagina `/docs` per testarli.    Puoi configurare un reindirizzamento dall'URL di base `/` all'endpoint `/docs` per facilitare un accesso più rapido alla pagina della documentazione, come mostrato nell'[Esempio 2-3](#setting_up_redirect).    ##### Esempio 2-3\\. Impostazione del reindirizzamento alla pagina dei documenti generata automaticamente    ```", "```py    [![1](assets/1.png)](#co_getting_started_with_fastapi_CO3-1)      Imposta un gestore per il gestore di base, ma non includerlo nelle specifiche OpenAPI e nella pagina della documentazione.      [![2](assets/2.png)](#co_getting_started_with_fastapi_CO3-2)      Restituisce una risposta di reindirizzamento alla pagina `/docs` con un codice di stato di reindirizzamento per i browser per eseguire il reindirizzamento.      Con l'[esempio 2-3](#setting_up_redirect), puoi accedere alla pagina `/docs` durante lo sviluppo locale ogni volta che visiti l'URL di base `/` del servizio.    In produzione, a meno che la tua API non sia pubblica, disabilita questo reindirizzamento e nascondi le rotte di `/docs` come impostazione predefinita per una maggiore sicurezza.    ###### Avvertenze    Se la tua API è accessibile pubblicamente in produzione, potresti esporre endpoint non protetti e informazioni sensibili sulla tua API. Pertanto, è [buona norma disattivare la pagina della documentazione](https://oreil.ly/Dk45G).    Invece, puoi mostrare esplicitamente la pagina `/docs` solo su alcuni ambienti selezionati.    Per le API pubbliche, puoi impostare il gestore principale `/` in modo che restituisca la versione dell'API invece di reindirizzare alla pagina `/docs`.    ## Sistema di iniezione delle dipendenze    Un altro potente componente di FastAPI è il suo [sistema di iniezione delle dipendenze](https://oreil.ly/eAIwR) basato su un modello di sviluppo chiamato *inversione del controllo*. Utilizzando questo modello, si suddivide una funzione in una serie di funzioni che vengono iniettate in altre funzioni come*dipendenze*.    Oltre ad aiutare a strutturare la logica della tua applicazione, le dipendenze possono aiutarti a ridurre le duplicazioni: ti permettono di condividere e riutilizzare la logica delle tue API, di riutilizzare le connessioni aperte al database, di applicare la sicurezza come i requisiti di autenticazione o autorizzazione e molto altro ancora.    Ad esempio, puoi specificare parametri di query comuni a tutte le rotte API (ad esempio, per la paginazione e il filtraggio), come mostrato nell'[Esempio 2-4](#dependency_pagination).    ##### Esempio 2-4\\. Ridurre la duplicazione utilizzando una dipendenza di paginazione    ```", "```py    In FastAPI, le dipendenze vengono memorizzate nella cache anche nel *contesto di una singola richiesta* per evitare calcoli duplicati. Ciò significa che una funzione di dipendenza viene eseguita solo una volta per ogni richiesta e il suo risultato viene riutilizzato per la durata della richiesta stessa, se necessario. Tuttavia, in una nuova richiesta, la funzione di dipendenza viene eseguita nuovamente.    Dover gestire le connessioni al database o controllare le credenziali dell'utente in ogni route handler è noioso e viola i principi di programmazione *Don't Repeat Yourself* (DRY). Un altro grande caso d'uso del sistema di dependency injection è quando crei una connessione al database e vuoi riutilizzarla per eseguire più richieste di fetch durante l'elaborazione di una singola richiesta.    Puoi creare delle dipendenze per le tue funzioni di route controller, come mostrato nell'[Esempio 2-5](#fastapi_dependency).    ##### Esempio 2-5\\. Iniezione di dipendenza in FastAPI    ```", "```py    [![1](assets/1.png)](#co_getting_started_with_fastapi_CO4-1)      Implementa una funzione per creare e gestire una sessione del database, che può essere utilizzata come dipendenza nei gestori delle rotte.      [![2](assets/2.png)](#co_getting_started_with_fastapi_CO4-2)      Rende la sessione di database aperta, rendendola disponibile per qualsiasi funzione che dipenda da `get_db`.      [![3](assets/3.png)](#co_getting_started_with_fastapi_CO4-3)      Chiude la sessione del database dopo che la richiesta è stata elaborata, evitando perdite di risorse.      [![4](assets/4.png)](#co_getting_started_with_fastapi_CO4-4)      Inietta la dipendenza `get_db` nel gestore della rotta per creare e riutilizzare la stessa sessione del database durante il ciclo di vita della richiesta. FastAPI esporrà automaticamente i parametri all'interno delle dipendenze sul tuo endpoint.      [![5](assets/5.png)](#co_getting_started_with_fastapi_CO4-5)      Riutilizza la sessione di database iniettata per eseguire più operazioni di database in un'unica richiesta per restituire i messaggi di un utente.      Come mostrato nell'[Esempio 2-5](#fastapi_dependency), puoi iniettare queste dipendenze in altre funzioni passandole come parametri a `Depends()` affinché FastAPI valuti e memorizzi gli output delle tue funzioni.    Qui definisci una funzione di utilità per creare una sessione del database e poi la usi come dipendenza della funzione `get_current_user_messages` per iniettare la sessione del database creata.    Questo sistema di dipendenze è solo una delle tante altre caratteristiche di FastAPI che velocizzano e facilitano il processo di creazione dei servizi di backend.    ## Eventi della durata della vita    [Gli eventi di durata di FastAPI](https://oreil.ly/Cn2DB) sono eccellenti per gestire l'inizializzazione e la pulizia del tuo servizio quando hai bisogno di impostare risorse che possono essere condivise tra le richieste.^([5](ch02.html#id554)) Durante l'avvio del server, puoi creare pool di connessioni al database o caricare modelli GenAI in memoria per riutilizzarli tra le varie richieste. Successivamente, prima dello spegnimento del server, puoi fare pulizia scaricando i modelli AI, chiudendo i pool di connessioni, eliminando gli artefatti temporanei e registrando gli eventi.    Utilizzando gli eventi lifespan, il tuo servizio FastAPI esegue operazioni di lunga durata come il caricamento del modello all'inizio, prima di servire le richieste, e lo mantiene caricato per riutilizzarlo tra le richieste. Durante lo spegnimento del server, puoi quindi terminare con grazia tutte le richieste rimanenti e in coda prima di eseguire qualsiasi operazione di pulizia.    ## Componenti di sicurezza e autenticazione    Come per qualsiasi altro framework, avrai bisogno di componenti di sicurezza e di autenticazione per proteggere il tuo servizio. FastAPI non ti vincola a un'implementazione specifica del livello di sicurezza e di autenticazione, ma ti offre un insieme di [componenti di sicurezza](https://oreil.ly/zlAgl) che ti permettono di proteggere i tuoi servizi in base alle tue esigenze.    Imparerai come implementare un livello di autenticazione da zero per i tuoi servizi GenAI nel [Capitolo 8](ch08.html#ch08).    ###### Suggerimento    Se non vuoi implementare un livello di autenticazione da zero, puoi anche rivolgerti a plugin di terze parti come [FastAPI Users](https://oreil.ly/eEtMe) che se ne occupano automaticamente per te.    Puoi anche integrarti con provider di autenticazione di terze parti per [flussi di single sign-on in FastAPI](https://oreil.ly/vIqCd) in ambienti aziendali.    ## Supporto di Web Socket bidirezionali, GraphQL e risposte personalizzate    Quando costruisci dei servizi, spesso hai bisogno di andare oltre gli*endpoint* *REST*standard.    Se stai realizzando un'applicazione di chat, potresti aver bisogno di una comunicazione client-server in tempo reale o di connessioni di lunga durata in cui i dati vengono trasmessi in una direzione. Gli endpoint WebSocket (WS) e gli eventi inviati dal server (SSE) possono aiutarti a trasmettere gli output del modello generativo ai client, come vedrai nel [Capitolo 6](ch06.html#ch06) sulla comunicazione in tempo reale con i servizi AI.    In altri casi, potresti voler utilizzare [GraphQL in FastAPI](https://oreil.ly/SL62a) per esporre endpoint che possano restituire schemi dinamici in base alla richiesta. FastAPI può utilizzare il [pacchetto`strawberry`](https://oreil.ly/wIzvi) ^([6](ch02.html#id561)) per sfruttare GraphQL nell'utilizzo di schemi dinamici per il tuo servizio API in modo che i clienti possano selezionare i campi che desiderano da una risorsa per evitare di recuperare eccessivamente i dati dal tuo servizio. Tuttavia, in questo libro non tratteremo l'utilizzo di GraphQL.    ## Integrazione moderna di Python e IDE con impostazioni predefinite ragionevoli    Poiché lo stack tecnologico di FastAPI è costruito su Python moderno (ad esempio, con annotazioni di tipo e doc-strings), tutti i linters e i formattatori IDE possono controllare e formattare in modo nativo la tua base di codice. Le impostazioni predefinite sono sufficienti anche per iniziare a importare e istanziare la classe FastAPI. Dato che tutto si lega perfettamente alle moderne funzionalità di IDE e Python, chiunque può facilmente iniziare a costruire, testare, eseguire il debug e distribuire i propri servizi FastAPI.    # Strutture del progetto FastAPI    Spesso, quando lavori a un progetto reale, ti ritroverai a costruire servizi che abbracciano più moduli, pacchetti e directory annidate. La decisione su come strutturare il tuo progetto dipende totalmente da te.    È qui che la maggior parte delle persone si trova in difficoltà e si ritrova con una base di codice troppo complessa da gestire. Finisci per sentirti frustrato, dovendo capire la base di codice e la struttura del progetto prima di potervi contribuire. A un certo punto, la complessità crescerà così tanto che avrai paura di toccare di nuovo il progetto.    Alcuni file finiranno per essere troppo grandi per essere letti con funzioni gonfiate, oppure ci saranno troppi file sparsi dappertutto. Potresti anche ritrovarti con milioni di errori di importazione o dipendenze circolari che distruggono la tua applicazione.    Imparare a strutturare applicazioni più grandi sarà ancora più importante quando si lavora con modelli di intelligenza artificiale generativa. Questi modelli hanno spesso bisogno di dipendenze e funzioni di utilità aggiuntive per essere supportati. Pertanto, dovrai aggiungere un livello di complessità per i tuoi modelli in aggiunta ai livelli di applicazioni esistenti.    ###### Suggerimento    Rispetto ai framework opinionati come Django, devi seguire delle buone pratiche per avere successo con progetti più grandi in framework non opinionati come FastAPI.    Negli ultimi anni, lavorando con FastAPI e applicazioni di scienza dei dati, ho visto molti sviluppatori creare modelli personalizzati per l'avvio di progetti FastAPI. Alcuni consigliano addirittura di seguire una struttura resa popolare dal progetto Netflix Dispatch FastAPI per le applicazioni API più grandi, che ha ispirato altri modelli.    Quando si tratta di costruire applicazioni reali, devi fare tutto il possibile per mantenere la base di codice il più strutturata possibile, a tuo vantaggio, per aiutare te e gli altri membri del tuo team a comprendere il codice in futuro.    Sai di avere una buona struttura di progetto se riesci a trovare qualsiasi funzione o componente all'interno della tua base di codice. Se inizi a dubitare dello scopo di una directory o a passare ore a cercare un pezzo di codice, allora la struttura del tuo progetto potrebbe essere poco chiara e troppo complessa da capire.    In questi casi, puoi fare riferimento ad alcune strutture di progetto comuni che sono diventate recentemente popolari nella comunità FastAPI. Ci sono diverse strutture di progetto che puoi adottare: piatta, annidata e modulare.    Diamo un'occhiata dettagliata a ciascuno di essi.    ## Struttura piatta    Una struttura piatta è quella in cui i file dell'applicazione rimangono alla radice del progetto senza directory annidate. Puoi raggruppare tutti i tuoi file in un'unica directory per una migliore organizzazione.    L'idea principale è quella di mantenere tutto il codice simile in moduli e di metterlo insieme vicino alla radice del progetto. Ad esempio, metti tutti i modelli di database in *models.py* o gli endpoint in *routes.py*.    La struttura di progetto più comune è quella piatta, grazie alla sua semplicità e facilità d'uso. Questa struttura è spesso ideale per costruire la prima versione di un servizio o un piccolo microservizio. L ['esempio 2-6](#flat_structure) mostra come potrebbe essere la struttura.    ##### Esempio 2-6\\. Struttura piatta di un progetto FastAPI    ```", "```py    Nella struttura mostrata nell'[Esempio 2-6](#flat_structure) puoi notare che ci sono pochi file che contengono il nucleo della logica dell'applicazione. Se stai costruendo un microservizio conFastAPI, per definizione vorrai mantenere una struttura piatta per semplicità.    La semplicità della struttura piatta ti permette di concentrarti sullo sviluppo piuttosto che sulla struttura. Ci sono pochi file di cui preoccuparsi. Non devi nemmeno preoccuparti dell'accoppiamento, della decomposizione o del riutilizzo perché ci sono poche righe di codice da gestire.    D'altra parte, la struttura piatta sarà difficile da mantenere man mano che il tuo progetto cresce in complessità. A questo punto, ha senso suddividere i moduli globali di Python in pacchetti a sé stanti utilizzando la struttura annidata.    ## Struttura annidata    La struttura annidata raggruppa moduli simili in pacchetti, creando di fatto una struttura annidata e una gerarchia di moduli. Sotto un pacchetto si raggruppano tutti i moduli che hanno una natura simile, indipendentemente dalla funzione che supportano. Si tratta di moduli liberamente accoppiati che contengono una logica simile per diverse entità del tuo progetto. Per esempio, il pacchetto `models` può contenere i modelli di database `users` e `profiles`.    La struttura annidata è consigliata per i progetti più grandi dalladocumentazione ufficiale di FastAPI.    Puoi vedere un progetto con struttura annidata nell'[Esempio 2-7](#nested_structure).    ##### Esempio 2-7\\. Progetto FastAPI annidato    ```", "```py    Quando aggiungi al tuo progetto modelli di intelligenza artificiale e diversi servizi e database esterni, puoi adottare una struttura annidata per gestire la crescente complessità.    L'insidia principale di questa struttura di progetto è l'accoppiamento ambiguo dei moduli: le modifiche di un modulo possono essere trasmesse a cascata ad altri moduli e può diventare difficile capire l'effetto a cascata delle nuove modifiche.Nel corso del tempo, può essere difficile mantenere e modificare il codice senza eseguire molti aggiornamenti in altri luoghi. Questo fenomeno viene definito \" *aggiornamenti a cascata\"*. Gli aggiornamenti a cascata, nel contesto dello sviluppo del software, sono quando è difficile mantenere e modificare il codice senza eseguire molti aggiornamenti in altri luoghi.    Se pensi di avere difficoltà a gestire l'accoppiamento dei moduli o ti aspetti di avere a che fare con un'applicazione di grandi dimensioni, ti consiglio di utilizzare una struttura modulare.    ## Struttura modulare    La struttura modulare, resa popolare dal progetto Netflix Dispatch FastAPI, è simile alla struttura annidata perché puoi inserire più moduli all'interno di un pacchetto e di sottopacchetti. Tuttavia, la differenza fondamentale sta nel modo in cui organizzi il progetto.    Nella struttura modulare, i moduli strettamente correlati e che si riferiscono a un dominio specifico sono raggruppati insieme. Questo approccio differisce dalla struttura annidata precedentemente menzionata. Un esempio potrebbe essere il pacchetto `users` che contiene schemi utente, servizi di database, dipendenze e router.    Per capire meglio questa differenza, guarda l'[Esempio 2-8](#modular_structure).    ##### Esempio 2-8\\. Struttura del progetto modulare FastAPI    ```", "```py    In una struttura di progetto modulare come quella mostrata nell'[Esempio 2-8](#modular_structure), riunisci componenti strettamente interconnessi tra loro in base a una funzione o a un sistema globale che implementano (ad esempio, l'autenticazione, l'elaborazione dei pagamenti, le notifiche, ecc.) o alla risorsa con cui interagiscono (ad esempio, utenti, profili, messaggi, ecc.). Questo tipo di incapsulamento elimina qualsiasi incertezza sugli accoppiamenti nel codice, migliorando la scalabilità e la manutenibilità.    Se hai bisogno di includere altre funzionalità, puoi creare un nuovo pacchetto che contenga tutto il codice necessario. Allo stesso modo, se hai bisogno di modificare o eliminare del codice, puoi facilmente determinare dove devono essere apportate le modifiche e prevedere l'impatto che avranno sulle altre parti del codice. Questo è possibile perché la struttura della base di codice è trasparente e ben incapsulata, rendendo chiaro dove sono collegati i diversi componenti.    ## Riorganizzazione progressiva del tuo progetto FastAPI    Una base di codice modulare ti permette di aggiungere e rimuovere componenti con facilità. Puoi anche riutilizzare i componenti in diverse parti del sistema per evitare ripetizioni.    Quando inizi il tuo progetto, la modularità non è così importante: puoi iniziare con uno o pochi file Python per costruire facilmente i tuoi servizi. Tuttavia, non appena introdurrai modelli di intelligenza artificiale, servizi esterni e una logica aziendale complessa, dovrai prendere in considerazione la possibilità di modulare la tua base di codice.    Puoi ottenere la modularità progettando i componenti del tuo sistema tenendo conto della riutilizzabilità e della smaltibilità. Assicurati che il design dei tuoi moduli e delle tue funzioni consenta l'utilizzo in ambienti diversi e che li collochi al posto giusto nella directory del tuo progetto. La scelta della migliore struttura di progetto è una questione di preferenze. Tuttavia, potresti chiederti: \"Quale struttura di progetto dovrei adottare per costruire servizi di IA generativa con FastAPI?\".    Ho scoperto che il modo migliore per strutturare i progetti è quello di *riorganizzarli progressivamente*, passando da una struttura piatta a una struttura modulare man mano che la complessità del servizio cresce:    1\\. Piatto      Se stai iniziando un nuovo progetto e la complessità del tuo sistema non è ancora chiara, puoi concentrarti sulla scrittura di tutto il codice FastAPI in un unico file prima di preoccuparti della struttura del progetto. Estrai quindi il codice in diversi file sotto la directory principale. Questa è la struttura iniziale che adotterai quando sperimenterai la prima versione del tuo servizio da zero.      2\\. Annidato      Man mano che il numero di file nella tua base di codice e la complessità del servizio aumentano, puoi adottare la struttura annidata. Puoi cercare i file in base ai raggruppamenti logici (modelli, router, schemi, ecc.) e non devi preoccuparti troppo degli accoppiamenti logici nel codice. Quando apporti delle modifiche, solo una manciata di file viene influenzata. A questo punto, hai un microservizio AI.      3\\. Modulare      Quando passi da un microservizio a un servizio backend completo, vorrai adottare una struttura modulare. Ora c'è un numero crescente di moduli, funzionalità e complessità. Inizierai a raggruppare il codice in pacchetti basati su *aree di interesse*. Il tuo codice ora gestisce le richieste, l'autenticazione, i sistemi esterni e così via, mentre serve un modello AI.      Ti suggerisco di ristrutturare il tuo progetto come indicato. Tuttavia, hai la flessibilità di adottare qualsiasi schema organizzativo che abbia senso per te e che ti permetta di ricordare la posizione e lo scopo dei tuoi file.    ###### Suggerimento    Ricorda, se non riesci a giustificare l'organizzazione dei file nella tua base di codice a un altro sviluppatore, è il momento di riconsiderare la struttura esistente.    Man mano che costruisci il tuo servizio GenAI, ti ritroverai inevitabilmente con una grande base di codice e un'applicazione complessa.    Pensare alla struttura della tua applicazione FastAPI di grandi dimensioni è solo il primo passo per la creazione di servizi di livello produttivo. Nel prossimo passo imparerai a conoscere un modello di progettazione software che ti aiuterà a gestire la complessità dei tuoi servizi di intelligenza artificiale. Si tratta del modello di progettazione delle applicazioni *a cipolla*, o a *strati*, di cui parleremo nel prossimo articolo.    # Pattern di progettazione dell'applicazione Onion/Layered    Se hai intenzione di costruire un servizio backend completo per l'IA generativa, ti sarà utile conoscere meglio il modello di progettazione delle applicazioni a cipolla, o a strati, che può essere implementato all'interno di strutture di progetto nidificate e modulari. Lo scopo di questo modello è quello di creare una separazione delle preoccupazioni tra le diverse parti della tua applicazione per semplificare il processo di aggiunta, rimozione e modifica delle funzionalità.    Il design pattern a cipolla ha influenzato anche i framework web in altri linguaggi, come [Nest.js](https://nestjs.com).    Il design a cipolla consiste in strati, ognuno con una responsabilità specifica e una direzione di dipendenza, come mostrato nella [Figura 2-3](#onion_design_pattern). Lo strato più interno contiene i modelli di dominio e la logica aziendale, mentre gli strati esterni contengono la gestione delle rotte (in un servizio API) o il codice di interfacciamento con l'utente (quando si servono modelli HTML).    Il modello è chiamato \"a cipolla\" perché gli strati si costruiscono l'uno sull'altro, con il modello di dominio al centro, circondato da strati di crescente astrazione che promuovono la testabilità, la manutenibilità e la flessibilità nella manutenzione dei servizi di intelligenza artificiale. Il nucleo dell'applicazione (modello di dominio e logica aziendale) si trova negli strati interni e tutti gli altri strati dipendono da esso. Questo approccio aiuta a gestire le dipendenze, a promuovere la separazione delle preoccupazioni e a facilitare unabase di codice più testabile e manutenibile.  ![bgai 0203](assets/bgai_0203.png)  ###### Figura 2-3\\. Modello di progettazione a cipolla    L'idea principale di questo pattern è il *principio* dell'*inversione delle dipendenze*, secondo il quale i moduli di alto livello non dovrebbero dipendere direttamente dall'implementazione dei moduli di basso livello, ma dichiarare ciò di cui hanno bisogno dai moduli di basso livello sfruttando il sistema di dipendenze FastAPI. Il sistema di dipendenze può quindi iniettare l'output dei moduli di basso livello per evitare l'accoppiamento tra i livelli.    Per implementare questo progetto software, devi scomporre il tuo servizio come una cipolla composta da strati sempre più profondi. Ogni strato (passando da quelli esterni a quelli interni) introduce componenti responsabili di una serie di compiti:    Router API      I router sono responsabili del raggruppamento di più controller/gestori di percorso per applicare una logica comune a più controller.    FastAPI mette a disposizione la classe `APIRouter` per aiutarti in questo senso.      Controllori/gestori di percorso      I controller sono responsabili della gestione delle *richieste* in entrata e della restituzione delle *risposte*al cliente attraverso un'esecuzione logica di servizi o provider.    Un buon progetto di controllore utilizza sempre le dipendenze per iniettare i dati o la logica necessari alla sua esecuzione. Vedi [Figura 2-4](#api_routers_controllers).  ![bgai 0204](assets/bgai_0204.png)  ###### Figura 2-4\\. Router e controller API      Servizi/fornitori      I servizi sono responsabili della combinazione o dell'orchestrazione di più operazioni interne per implementare una logica aziendale (servizi), mentre i provider implementano l'interfaccia con i sistemi esterni.    I servizi in genere utilizzano repository per l'accesso ai dati per implementare una logica aziendale complessa piuttosto che semplici operazioni di recupero e mutazione dei dati. Ogni modulo della tua applicazione può avere il proprio servizio.    I provider sono simili ai servizi ma sono specializzati nell'interazione con sistemi esterni come le API interne o di terze parti. Esempi di provider sono i client per i server di posta elettronica, i gateway di pagamento o altri microservizi.    In sostanza, sia i provider che i servizi supportano l'implementazione della logica aziendale del controller facilitando le interazioni interne ed esterne.    Ecco un esempio di come lavorano insieme all'interno di un route controller: il servizio di database `users` recupera il record di un utente via e-mail e poi utilizza queste informazioni con un gateway di pagamento e con i client del server e-mail (provider) per elaborare i pagamenti e inviare le e-mail di conferma.      Repository (adattatori di dati)      Un repository è un modello di progettazione utilizzato per implementare la logica di accesso ai dati e le operazioni di mutazione con le fonti di dati (da non confondere con unrepository Git).    I repository utilizzano la mappatura relazionale degli oggetti (ORM) o comandi SQL grezzi per eseguire query sulla tua infrastruttura come un database o un archivio di memoria per recuperare o modificare i dati.    Puoi implementare un'interfaccia astratta in questo livello per imporre una progettazione coerente in tutti i tuoi repository, utilizzando le operazioni di creazione, lettura, aggiornamento e cancellazione (CRUD). Vedi [Figura 2-5](#services_providers_repositories).  ![bgai 0205](assets/bgai_0205.png)  ###### Figura 2-5\\. Servizi, provider e repository      Schemi/modelli      Questi sono responsabili dell'applicazione della sicurezza dei tipi, della struttura e della logica di convalida dei dati che scorrono nel servizio.      Avrai anche componenti che si estendono su più livelli per supportare l'intera applicazione:    Middleware      Questo gestisce le richieste e le risposte prima e dopo il loro passaggio ai controllori dell'applicazione/gestori delle rotte (vedi [Figura 2-6](#middlewares)).  ![bgai 0206](assets/bgai_0206.png)  ###### Figura 2-6\\. Middleware      Dipendenze      Si tratta di funzioni riutilizzabili definite dall'utente che possono essere iniettate nei controllori per supportare la logica aziendale. Le dipendenze possono essere memorizzate nella cache e dipendere da altre dipendenze.      Tubi      Si tratta di funzioni di trasformazione dei dati che puoi utilizzare tra i vari livelli dell'applicazione, come ad esempio gli aggregatori di dati, i pulitori, i parser, i traduttori e così via.      Mappatori      Si tratta di mappatori di dati da uno schema a un altro, che spesso passano i dati tra i vari livelli, come ad esempio dallo schema `UserRequest` in un livello router allo schema `UserInDB` nel livello di accesso ai dati. Vedi [Figura 2-7](#models_pipes_mappers).  ![bgai 0207](assets/bgai_0207.png)  ###### Figura 2-7\\. Modelli, tubi e mappatori      Filtri di eccezione      Questi gestiscono le eccezioni in modo coerente su tutti i livelli.      Guardie      Questi proteggono i controllori da eventuali abusi. La logica di autenticazione e autorizzazione può essere implementata come dipendenza o middleware per fungere da protezione (vedi [Figura 2-8](#guards)).  ![bgai 0208](assets/bgai_0208.png)  ###### Figura 2-8\\. Protezioni      Se fai riferimento alla struttura modulare del progetto mostrata nell'[Esempio 2-8](#modular_structure), noterai vari elementi del modello di progettazione a cipolla nella struttura modulare del progetto. Seguire questo modello può aiutarti a creare un servizio di AI generativaFastAPI manutenibile, testabile e scalabile.    Nei prossimi capitoli, utilizzerai questi schemi per costruire il servizio GenAI mostrato nella [figura 2-9](#genai_service).  ![bgai 0209](assets/bgai_0209.png)  ###### Figura 2-9\\. Servizio di intelligenza artificiale generativa che costruirai con FastAPI    Successivamente, confronteremo FastAPI con altri framework.    # Confronto tra FastAPI e altri framework web di Python    La maggior parte dei framework web di Python offre strumenti per la creazione di endpoint REST, GraphQL, WebSocket e altri tipi di endpoint.    Questi framework sono di tipo \"opinionistico\", come Django (Python) e Nestjs (JavaScript), mentre altri non lo sono. Flask o FastAPI (Python) e Express (JavaScript) ti danno la possibilità di progettare il tuo servizio come preferisci.    I framework opinionati, come Django (Python) e Nestjs (JavaScript), prendono decisioni per te con determinate ipotesi su come fornirai i dati ai tuoi componenti. In effetti, forniscono una struttura ma limitano ciò che ti è permesso fare. I framework opinionati sono in genere più facili da usare.D'altra parte, i framework non opinionati come Flask o FastAPI (Python) e Express (JavaScript) sono più flessibili ma possono darti troppa libertà - molte possibilità per ottenere gli stessi risultati.    Dato che i framework non opzionali come FastAPI ti offrono una grande libertà nella costruzione dei servizi, potresti sentire un po' di stanchezza nella scelta e nell'integrazione di ogni singolo pacchetto di supporto. Ad esempio, per lavorare con un database, dovrai installare e integrare diversi pacchetti che funzionano bene insieme: uno per accedere al database, uno per migrarlo e un altro per agire come un mappatore relazionale di oggetti (ORM).    Questo rende difficile lavorare con i framework non opzionali e spesso si decide di utilizzare un framework opzionale come Django, che viene fornito con un eccellente sistema ORM strettamente integrato per interagire con i database.    Django è un framework a batteria che si presenta come \"il framework web di Python per gli sviluppatori con scadenze\" e viene fornito con un sistema ORM completamente integrato e ricco di funzionalità che si occupa delle migrazioni dei database e dell'accesso ai dati quando sei tu a fornire i modelli di dati.    Inoltre, ti fornisce un pannello di amministrazione, un sistema di autenticazione e autorizzazione degli utenti basato su credenziali e diverse funzionalità di sicurezza web, che non dovrai costruire da solo.2, è stato introdotto anche il supporto per le richieste asincrone, consentendoti di inserire la concomitanza nei tuoi servizi. Django si aspetta che tu adotti l'architettura MVC, richiedendoti di definire modelli di dati e viste. Queste viste diventano percorsi che servono file HTML templati, risposte JSON o qualsiasi altra risposta HTTP, anche senza fare affidamento su `django-rest-framework`. I livelli di controller conterranno quindi l'elaborazione dei dati e la logica aziendale.    Questo rende Django un'ottima scelta per le *applicazioni web progressive* (PWA) monolite che si distribuiscono come un unico backend con un frontend. Tuttavia, man mano che le aziende si spostano verso la creazione di team specializzati nello sviluppo di backend e frontend, i modelli di architettura a microservizi stanno diventando sempre più popolari. Con i microservizi, vuoi separare i servizi di backend da quelli di frontend, creare API invece di PWA e concentrarti sul mantenere i tuoi servizi il più snelli possibile. Utilizzando Django puoi anche costruire API, ma puoi ritrovarti con un'applicazione pesante che rallenta lo sviluppo, la distribuzione e la scalabilità dei servizi. Ecco perché i framework non open source come Flask stanno diventando sempre più popolari.^([7](ch02.html#id589))    Flask viene fornito con il minor numero di codice possibile per la creazione di server web. Rispetto a FastAPI, Flask non viene fornito con la convalida dei dati, l'auto-documentazione e un sistema di iniezione delle dipendenze. Le caratteristiche citate sono spesso necessarie per la creazione di qualsiasi servizio backend che diventi complesso o che richieda l'integrazione con database e servizi esterni.    ###### Nota    Un nuovo framework web chiamato Quart ha cercato di affrontare questo problema ed è un buon concorrente di FastAPI. Tuttavia, al momento in cui scriviamo, Quart è nuovo e, rispetto ad altri framework, non ha una grande comunità di utenti e risorse documentate che ti aiutino nel caso in cui tu sia bloccato su un problema.    Inoltre, Flask è stato rilasciato nel 2010 e implementa un protocollo di comunicazione chiamato *Web Server Gateway Interface* (WSGI) per il servizio web, il che significa che le richieste vengono elaborate in modo sincrono rispetto ad ASGI, che è di natura asincrona. Inoltre, Flask non è stato progettato per gestire un gran numero di connessioni simultanee (come farebbe un framework asincrono). Tuttavia, questo non limita il numero di richieste parallele che il server può gestire da solo. In produzione, puoi utilizzare diverse strategie (come processi worker o thread) per gestire più richieste simultaneamente. Inoltre, poiché Flask implementa WSGI, non supporta gli endpoint WebSocket, utilizzati per mantenere un canale di comunicazione persistente e bidirezionale tra un client e un server. Questo perché WSGI non supporta nativamente WebSocket. Tuttavia, puoi installare le estensioni di Flask per integrare il supporto WebSocket.    Flask, basandosi su un server WSGI, elabora ogni richiesta in modo sincrono, mentreFastAPI utilizza un ciclo di eventi per i carichi di lavoro simultanei. Pertanto, FastAPI sarà molto più veloce con le attività pesanti di input/output (I/O), ad esempio quando si comunica con un'API esterna o un archivio dati, che bloccherebbero un intero processo worker in Flask.    In sostanza, ti consiglio Django e altri framework se vuoi costruire PWA monolite, e Flask o Quart per semplici API e framework in altri linguaggi se hai più esperienza con essi.    Tuttavia, se stai costruendo un servizio backend che richiede il supporto di modelli AI, la connessione a sistemi esterni e un certo livello di complessità della logica di business, ti consiglio di considerare FastAPI come il framework web da scegliere.    # Limitazioni di FastAPI    A fronte delle caratteristiche e dei vantaggi sopra citati, ci sono anche diversi svantaggi e compromessi che devi considerare se vuoi adottare FastAPI per il tuo progetto. Tenendo conto dei casi d'uso dell'intelligenza artificiale, FastAPI è carente in diverse aree.    ## Gestione inefficiente della memoria del modello    FastAPI fornisce meccanismi integrati per la condivisione della memoria del modello tra più istanze o processi dello stesso container. Questo significa che quando si scalano i web worker orizzontalmente, è necessario caricare un'intera nuova istanza del modello nella memoria del container. Questo crea un collo di bottiglia nella memoria e aumenta i costi operativi dei servizi GenAI ad alto traffico.    ## Numero limitato di fili    C'è un limite al numero di thread che FastAPI crea all'avvio dell'applicazione nel pool di thread interno.^([8](ch02.html#id601))    Questo significa che c'è anche un limite alla scalabilità di una singola istanza diFastAPI, soprattutto con i carichi di lavoro AI che prevedono operazioni di I/O e CPU/GPU intensive.^([9](ch02.html#id602))    ## Limitato al blocco dell'interprete globale    In Python, il multithreading può produrre risultati poco intuitivi e spesso controproducenti a causa del *Global Interpreter Lock* (GIL).    FastAPI sfrutta il multithreading attraverso un pool di thread interno per gestire le richieste web simultanee che colpiscono un percorso sincrono. Tuttavia, anche con endpoint asincroni, le richieste di inferenza dell'intelligenza artificiale possono comunque bloccare il ciclo principale dell'evento, impedendo a tutte le altre richieste di essere elaborate nel thread principale del servizio web.    Questo perché i carichi di lavoro di inferenza dell'intelligenza artificiale sono ad alta intensità di CPU/GPU. Le operazioni non I/O, come servire un modello costoso o aggregare grandi quantità di dati su un worker, causeranno l'attesa di altri thread, poiché Python attualmente non utilizza più core per il threading.^([10](ch02.html#id607)) Invece, come scoprirai nel [Capitolo 5](ch05.html#ch05), per questo tipo di operazioni di calcolo costose dovrai utilizzare il multiprocessing o un pool di processi.    ## Mancanza di supporto per le richieste di inferenza per l'elaborazione dei micro-lotti    I framework di deep learning supportano la vettorizzazione in modo che le inferenze possano essere raggruppate, calcolate in modo efficiente e parallelizzate. Sfortunatamente, le richieste di predizione non possono essere raggruppate in FastAPI e di conseguenza ogni operazione di inferenza del modello ad alta intensità di calcolo può bloccare altre richieste.    Per scalare i servizi, una soluzione è quella di servire separatamente i modelli più pesanti e utilizzare FastAPI per autenticare e gestire i dati in entrata e in uscita.    ## Non è possibile suddividere in modo efficiente i carichi di lavoro dell'intelligenza artificiale tra CPU e GPU    Mentre la CPU gestisce principalmente le operazioni di trasformazione e validazione delle richieste, la GPU può eseguire e parallelizzare l'inferenza dei modelli ad alta intensità di calcolo. In alcuni framework web specializzati in ML (come BentoML), è anche possibile suddividere in modo efficiente i carichi di lavoro dell'intelligenza artificiale tra CPU e GPU.    ###### Nota    Quando si suddividono i carichi di lavoro dell'intelligenza artificiale tra CPU e GPU, le operazioni di preparazione e post-elaborazione dei dati vengono eseguite dalla CPU, mentre l'inferenza di deep learning più veloce viene eseguita dalla GPU.    Purtroppo FastAPI non è in grado di eseguire in modo efficiente questa suddivisione del carico di lavoro dell'inferenza AI tra questi dispositivi. Ciò significa che la CPU può essere bloccata dall'elaborazione delle richieste anche quando i processi di inferenza sono in esecuzione sulla GPU. Poiché questo è un grosso collo di bottiglia quando si lavora con i modelli più pesanti, sarà necessario servire i modelli più pesanti al di fuori di FastAPI per i carichi di lavoro simultanei.    Discuteremo le soluzioni a questa limitazione in modo più approfondito nel [Capitolo 5](ch05.html#ch05).    ## Conflitti di dipendenza    Quando distribuisci modelli di ML, dovrai affrontare sfide uniche rispetto alla distribuzione di applicazioni web tipiche, a causa del profondo legame del runtime del modello con le librerie native e l'hardware. Ogni ambiente di distribuzione può operare su hardware diversi e può richiedere l'uso di versioni specifiche delle librerie native e dei comandi di containerizzazione.    ## Mancanza di supporto per carichi di lavoro AI ad alta intensità di risorse    Nonostante le sue incredibili capacità, FastAPI è stato sviluppato prima dell'avvento dell'IA generativa. Di conseguenza, rimane un framework web generico con un supporto recente per il servizio di IA e i flussi di lavoro ML. Tuttavia, per alcuni casi d'uso, come il servizio di modelli complessi e ad alta intensità di risorse e con un miliardo di parametri, può valere la pena di esplorare altri framework come *BentoML*.    Nei capitoli seguenti imparerai a costruire il tuo servizio GenAI conFastAPI.    Ma prima di andare avanti, configuriamo gli strumenti Python necessari come linters, formattatori e type checkers nel tuo ambiente di sviluppo per facilitare la manutenzione del tuo progetto FastAPI mentre ci lavoriamo insieme.    # Impostazione di un ambiente Python gestito e dei tool    Per mantenere un ambiente di sviluppo stabile e riproducibile, potresti voler gestire l'ambiente e le dipendenze di Python.    Consiglio:    *   Utilizzare un file *requirements.txt* con `pip` per i progetti più semplici           *   Usare [uv](https://oreil.ly/Qxl7h) o [Conda](https://oreil.ly/Kfsc4) per i flussi di lavoro guidati da `pip`           *   Utilizzare la [poesia](https://oreil.ly/Rt04z) per progetti più complessi              Oltre alla gestione delle dipendenze, Python dispone anche di diversi pacchetti di terze parti che ti permettono di lincare e formattare la tua base di codice prima di inviarla in produzione.^([11](ch02.html#id618))    Per gli sviluppatori Python professionisti è buona norma utilizzare questi strumenti per individuare i bug durante lo sviluppo e prima di aggiungere le modifiche al repository del codice. In effetti, ti consiglio di eseguire frequentemente dei controlli sul codice con questi strumenti per evitare la comparsa di bug nei tuoi servizi.    Ecco un elenco non esaustivo di pacchetti Python che ti consiglio di integrare in qualsiasi progetto che inizi:    Linters      Questi strumenti analizzano il codice sorgente per segnalare errori di programmazione, errori stilistici e frammenti di codice inutilizzati:    *   *Autoflake*: Rimuove le importazioni e le variabili inutilizzate dal codice per migliorarne la leggibilità           *   *Flake8*: Controlli contro le proposte di miglioramento di Python (PEP) e gli stili di codice                Formattatori      Questi ti permettono di vedere meglio ciò che hai scritto:    *   *isort*: Ordina le importazioni nei moduli Python           *   *Nero*: Formatta il codice Python per renderlo più leggibile           *   *Ruff*: Il liner e il formattatore a base di Rust sono estremamente veloci e possono essere utilizzatiin sostituzione di altri strumenti come `isort`, `black`, `flake8`, ed eventualmente `bandit`^([12](ch02.html#id621))                Logger      Utilizzato nelle parti di codice più complesse per il debug e il monitoraggio dell'applicazione:    *   *Loguru*: Sostituisce il modulo logger integrato di Python                Scanner      Se vuoi avere la certezza di non aver commesso per caso un codice o una password insicuri:    *   *Bandit*: Scansione delle vulnerabilità della tua base di codice Python con controllo dei problemi di sicurezza più comuni, come i segreti hard-coded.           *   *Sicurezza*: Scanner delle vulnerabilità delle dipendenze di Python per rilevare pacchetti con vulnerabilità note o pacchetti dannosi                Controllori di tipo      Inoltre, è ottimo se vuoi essere sicuro che le modifiche apportate agli schemi non abbiano danneggiato la tua applicazione:    *   *Mypy*: Un potente controllore di tipo statico che può aiutare a individuare molti bug nel tuo codice           *   *Pylance*: Un verificatore di tipo che viene fornito con l'estensione Python di Microsoft per VS Code.                Nell'ambito del tuo ambiente di sviluppo, è utile utilizzare sistemi di controllo di versione come Git per tenere traccia delle modifiche alla base di codice, gestire le diverse versioni del tuo progetto e gestire i contributi di codice da parte di altri sviluppatori.    ###### Suggerimento    Quando usi Git, puoi anche aggiungere dei file *.gitignore* per aiutarti a gestire i file e le directory che vuoi escludere dal monitoraggio del controllo di versione.    Gli ambienti di sviluppo integrati (IDE) come VS Code o JetBrains Pycharm forniscono plug-in per l'esecuzione di questi strumenti mentre scrivi o salvi il tuo lavoro. Spesso richiedono una certa configurazione, ma una volta effettuata, la formattazione automatica e il linting saranno impostati e pronti prima di iniziare. In ogni caso, ti consiglio di avere uno script o dei ganci pre-commit che lintano, controllano e formattano il tuo codice prima di eseguire il commit sulla tua base di codice o di distribuirlo in produzione.    ###### Suggerimento    Ho preparato un [modello vuoto di FastAPI](https://oreil.ly/j8lF7) che include integrazioni con strumenti comuni che puoi utilizzare come base per i tuoi progetti.    Si tratta di nozioni fondamentali della programmazione Python e dell'ingegneria del software, che diventeranno cruciali quando inizierai a lavorare con modelli di intelligenza artificiale in grado di produrre output probabilistici, nonché con servizi e database esterni che possono cambiare schema in qualsiasi momento. Mantenere un'applicazione di intelligenza artificiale che cambia schemi e prompt in continuazione senza i suddetti strumenti può diventare un vero e proprio mal di testa molto velocemente.    # Riassunto    In questo capitolo hai imparato a conoscere il framework FastAPI, comprese le sue capacità e i suoi svantaggi rispetto ad altri framework.    Hai anche imparato come impostare il tuo progetto FastAPI da zero, insieme a una serie di strumenti che puoi utilizzare per migliorare la tua esperienza di sviluppo.    In seguito, ti sono state presentate diverse strutture di progetto che puoi adottare quando costruisci il tuo servizio FastAPI. In questo contesto, hai imparato qualcosa in più sul modello di progettazione software a cipolla/stratificato, che ti aiuta a gestire la complessità del progetto.    Infine, abbiamo parlato degli strumenti che puoi utilizzare per gestire i tuoi ambienti Python e aiutarti a mantenere la tua base di codice FastAPI man mano che cresce di complessità.    Ora dovresti essere in grado di avviare i tuoi progetti FastAPI e di gestire la complessità del progetto nel corso del tempo.    Nel prossimo capitolo imparerai a implementare le tue funzionalità GenAI in FastAPI per generare testo, immagini, audio e video. Capirai il funzionamento interno di ogni modello e il ruolo del sistema di ciclo di vita di FastAPI nel servizio dei modelli, sfruttando al contempo le GPU NVIDIA per le attività di inferenza. Infine, ti verrà presentato il sistema di attività in background di FastAPI per scaricare le operazioni di inferenza di lunga durata.    ^([1](ch02.html#id507-marker)) Gran parte della logica di convalida dei dati di Pydantic v2 è stata riscritta in Rust per migliorare notevolmente le prestazioni.    ^([2](ch02.html#id511-marker)) Il comando `fastapi dev` cerca nelle directory del tuo progetto un oggetto FastAPI `app`. Se hai problemi ad avviare il tuo server FastAPI, consulta la sua documentazione usando `fastapi dev --help`.    ^([3](ch02.html#id527-marker)) Per eseguire l'inferenza del modello    ^([4](ch02.html#id530-marker)) Provenienti dal quadro Starlette    ^([5](ch02.html#id554-marker)) I nuovi eventi di durata di FastAPI sostituiscono i deprecati eventi di avvio/spegnimento delle versioni precedenti.    ^([6](ch02.html#id561-marker)) Una dipendenza esterna    ^([7](ch02.html#id589-marker)) Come risulta chiaramente dal numero di download mensili    ^([8](ch02.html#id601-marker)) FastAPI si affida a `AnyIO` (una libreria di rete e di concorrenza asincrona) per gestire la concorrenza. `AnyIO` crea fino a 40 thread per impostazione predefinita su un pool di thread interno dinamico e rimuove quelli che non vengono utilizzati per un certo periodo.    ^([9](ch02.html#id602-marker)) A meno che non si eseguano le operazioni della GPU in un altro processo (tramite multiprocessing) e si attendano le operazioni    ^([10](ch02.html#id607-marker)) Tuttavia, secondo la [PEP 703](https://oreil.ly/_bRzj), GIL sarà presto reso opzionale in CPython.    ^([11](ch02.html#id618-marker)) Fai riferimento al [repository GitHub di Hypermodern](https://oreil.ly/6YWRN) per gli esempi di strumenti.    ^([12](ch02.html#id621-marker)) Puoi usare `ruff` per controlli più rapidi nelle pipeline CI/CD, a meno che il tuo ambiente di sviluppo o la pipeline CI/CD non siano strettamente integrati con gli altri strumenti.```", "```py`` ```"]