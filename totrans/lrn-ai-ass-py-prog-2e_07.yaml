- en: 8 Debugging and better understanding your code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 调试和更好地理解你的代码
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Determining the source of a bug
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定错误（bug）的来源
- en: Fixing errors with Copilot techniques
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Copilot技巧修复错误
- en: Debugging code with Copilot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Copilot调试代码
- en: Using the VS Code debugger to see how code is functioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VS Code调试器查看代码如何运行
- en: There will be a point in every programmer’s career when their code isn’t doing
    what they want it to do. This has likely happened to you already, and, rest assured,
    it’s a normal part of learning to program. How do we fix the code? Sometimes,
    changing the prompt or better decomposing the problem like you learned in earlier
    chapters is sufficient to fix the problem. But what do you do when you just can’t
    get Copilot to give you different or better code, nor can you figure out why the
    code you’ve been given doesn’t work properly?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在每位程序员的职业生涯中，都会有一个时刻，他们的代码无法按照预期执行。这很可能已经发生在你身上了，请放心，这是学习编程的正常部分。我们如何修复代码？有时候，改变提示或像在前面章节中学到的那样更好地分解问题，就足以解决问题。但当你无法让Copilot提供不同或更好的代码，也无法弄清楚为什么你给出的代码无法正常工作时，你该怎么办？
- en: This chapter serves two purposes. The primary goal is to learn how to find errors
    (called bugs) in the code and fix them. To find those bugs, you’ll need to fulfill
    the second goal, which is gaining a deeper understanding of how your code works
    while you’re running it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有两个目的。主要目标是学习如何找到代码中的错误（称为bug）并修复它们。为了找到这些bug，你需要实现第二个目标，即在运行代码时更深入地理解代码的工作原理。
- en: The good news is that having an error in your code is such a common occurrence
    for programmers that programming environments, such as Visual Studio Code (VS
    Code), have tools to help us uncover what’s going wrong. We’ll learn how to use
    that tool, called a debugger, in this chapter as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，代码中存在错误对程序员来说如此普遍，以至于编程环境，如Visual Studio Code（VS Code），都有工具帮助我们揭示出了什么问题。我们将在本章学习如何使用这个工具，即调试器。
- en: Like the past few chapters where we started small, we’ll learn the concepts
    behind finding and fixing errors with some small examples, and then we’ll more
    authentically showcase the process by diving into a larger example that’s similar
    to the kind of code you’re likely to write in the future.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像过去几章我们从小的例子开始一样，我们将通过一些小例子学习查找和修复错误的概念，然后我们将通过深入研究一个更大的例子来更真实地展示这个过程，这个例子与你未来可能编写的代码类似。
- en: 8.1 What causes errors (bugs)?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 什么原因导致错误（bug）？
- en: First up is a quick terminology lesson. Many decades ago, computers used relays
    or vacuum tubes rather than transistors. The story goes that Dr. Grace Hopper,
    while programming one of these early computers, experienced an error caused by
    an actual bug (a moth) in a relay. Today, we use the term bug to refer to a mistake
    in a program, though we’re not dealing with literal bugs anymore. Now, bugs are
    caused by mistakes by programmers; when we debug our code, we’re working on removing
    those bugs. (There can be bugs in the implementation of Python itself or even
    in computer hardware, but they are so rare, it’s safe to assume an error in your
    code is because of your code.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是一个快速术语课程。许多年前，计算机使用继电器或真空管而不是晶体管。据说，Grace Hopper博士在编程这些早期计算机之一时，遇到了由继电器中的实际虫子（蛾）引起的错误。今天，我们使用“bug”一词来指代程序中的错误，尽管我们不再处理真正的虫子了。现在，bug是由程序员的错误造成的；当我们调试代码时，我们正在努力移除这些bug。（Python的实现或计算机硬件中也可能存在bug，但它们非常罕见，可以安全地假设代码中的错误是因为你的代码。）
- en: 'No one intentionally causes bugs in their code if they are genuinely trying
    to solve a problem. So why do bugs happen? Well, software engineers, and Copilot,
    make mistakes. What kind of mistakes you might ask? There are two primary categories
    of bugs:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员真正试图解决问题，他们不会故意在代码中引入bug。那么，bug为什么会发生呢？好吧，软件工程师和Copilot会犯错误。你可能会问，什么样的错误？bug主要有两大类：
- en: '***Syntax errors*—These errors occur when the code doesn’t follow the Python
    syntax requirements. For example, forgetting to write a `:` at the end of the
    first line of a `for` loop is a syntax error. When you run Python, because it’s
    trying to generate machine code based on your program description, it will run
    into a mistake, not know what to do, and give you an error. Sometimes, these error
    messages are more readable than others. When people learn to program in the traditional
    way, without Copilot, these errors are really, really common. It takes a while
    to learn all the rules of Python and to make those rules a habit. Even the two
    of us still sometimes write code with syntax errors, despite decades of writing
    code. The good news is that writing code with Copilot almost entirely eliminates
    this problem! The bad news is that of the two types of bugs, syntax errors are
    the easier to find and fix.**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***语法错误*—这些错误发生在代码不符合 Python 语法要求时。例如，忘记在 `for` 循环的第一行末尾写上 `:` 就是一个语法错误。当你运行
    Python 时，因为它正在尝试根据你的程序描述生成机器代码，所以会遇到错误，不知道该怎么办，并给出错误。有时，这些错误信息比其他错误信息更易读。当人们以传统方式学习编程，没有
    Copilot 的帮助时，这些错误真的很常见。学习所有 Python 规则并使这些规则成为习惯需要一段时间。即使我们两个都写了数十年的代码，有时还是会犯语法错误。好消息是，使用
    Copilot 编写代码几乎完全消除了这个问题！坏消息是，在两种类型的错误中，语法错误更容易找到和修复。**'
- en: '***   ***Logical errors—*These errors occur when there is something logically
    wrong with the program. For example, maybe the intent of the code is to count
    how many times the exact word “Dan” appears in a list of words, but the code actually
    counts how many words in the list contain “dan” (ignoring case) anywhere in the
    word. This code would be doing the wrong thing on two counts: it would count words
    like *dan* and *DAN* as matches even though we don’t want those to be matches,
    and it would find *dan* as any part of a word rather than the full word. That
    is, it would count words like *Daniel*, *danger*, and *dan*, even though we don’t
    want to count any of these! Somewhere, the code isn’t doing what it should, and
    we have to figure out where and why. Often, finding the logical error is the hardest
    part. Once we know where the mistake is, we have to fix it, and fixing these bugs
    can range from changing a single character to completely rewriting the code. Logical
    errors can happen when a prompt isn’t well described or when Copilot, for various
    reasons, generates the wrong code.****'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '***   ***逻辑错误*—这些错误发生在程序中存在逻辑错误时。例如，也许代码的意图是计算一个单词列表中“Dan”这个单词出现的次数，但实际上代码计算的是列表中包含“dan”（忽略大小写）的单词数量。这段代码会在两个方面出错：它会将像
    *dan* 和 *DAN* 这样的单词视为匹配项，尽管我们不想将它们视为匹配项，并且它会将 *dan* 视为一个单词的任何部分而不是整个单词。也就是说，它会计算像
    *Daniel*、*danger* 和 *dan* 这样的单词，尽管我们不想计算这些单词中的任何一个！某个地方，代码没有做它应该做的事情，我们必须找出在哪里以及为什么。通常，找到逻辑错误是最困难的部分。一旦我们知道错误在哪里，我们就必须修复它，修复这些错误可能从更改单个字符到完全重写代码。逻辑错误可能发生在提示描述不佳或由于各种原因
    Copilot 生成了错误的代码时。****'
- en: '****## 8.2 How to find the bug'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '****## 8.2 如何找到错误'
- en: Finding bugs can be challenging. Fundamentally, whether you or Copilot wrote
    the code, you thought or Copilot “thought” the code was correct when it was written.
    This is why it’s often easier for a colleague to find a bug in the code rather
    than the author. The author can’t see the bug because they created it!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 找到错误可能具有挑战性。从根本上讲，无论你或 Copilot 编写了代码，你在编写代码时都认为或 Copilot “认为”代码是正确的。这就是为什么通常更容易让同事而不是作者在代码中找到错误。作者看不到错误，因为他们创造了它！
- en: Bugs aren’t new to us in this book as we’ve seen mistakes in code already, and
    we’ve found those errors by reading the code and/or testing. In previous chapters,
    we figured out the source of the bug by reading through the code. In this chapter,
    we’ll address the bugs that you identify when testing but can’t seem to figure
    out why the code is wrong. Often, you can bypass the process of figuring out why
    the code is wrong by trying other Copilot suggestions, using new prompts to fix
    the error, or asking Copilot to fix the bug for you, but in our experience, these
    techniques don’t always work. What we need then are more tools to help us figure
    out where the error is in the code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Using print statements to learn about the code behavior
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fundamentally, a logical error means that there is a mismatch between what the
    author thought the code would do and what the code actually does. A common way
    to identify that mismatch is by using `print` statements to get insight into the
    behavior of the program because they tell you what the computer is actually doing.
    A useful practice is to print variables at various points in time to see what
    the values of those variables are at those points. Let’s try this for that example
    we just gave of looking for the word *Dan* in a list of words. Here’s the wrong
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.1 Incorrect function for counting matching words
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 The method lower makes the word all lowercase letters.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'You may already see what’s wrong with the code, but let’s assume we don’t know
    what’s going on, and we’re trying to figure out where the code went wrong. Suppose
    we found out that our code is wrong by running the following test case:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We expected the answer of 1, but we got 2\. Notably, including *danger* in this
    test case helped us catch the error in the code. Where in the code did things
    go wrong? To figure that out, we could add `print` statements. When you want to
    do this, you’ll need to read the code to figure out where to put them. Looking
    at this code, printing the list at the start of the function might not be a bad
    idea depending on the bug we’re seeing, but the bug here seems to have to do with
    the count and not specifically with the list of words. Printing each word in the
    list as the first line in the `for` loop may be helpful so we can check that the
    code is processing each word. We might print `count` right before it’s returned,
    but we already have a good idea of the value returned. These are all reasonable
    ideas that will help you get closer to the bug, but it’s not where we’d start.
    To be clear, if we started with one of these other ideas, we wouldn’t be wrong;
    it might just take a few more steps before finding the bug.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Because the bug is counting too many words as *Dan* words, we’d put the `print`
    statement within the `if` statement right where `count` is incremented, as in
    the following listing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.2 Example of a print statement to find the bug
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 A print statement to show which words are being counted'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning our code with the same test case, this is what is printed now:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Aha! This would tell us that our program is counting the word *danger* when
    it shouldn’t be. We could then give Copilot a new prompt incorporating what we
    just learned to hopefully have Copilot fix the problem. Here’s the prompt we added
    in the editor, and Copilot fixed the code in the following listing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.3 Using a prompt to fix a known bug
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Prompt that causes Copilot to generate the correct code'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Code added by Copilot in response to the prompt'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Once we knew the bug, it was easier to tell Copilot how to fix it. Granted,
    this is a basic example, but the idea applies to far more complex code. The process
    is often iterative. You ask the code to print something, and what it prints aligns
    with what you think it should be doing. You then ask the code to print something
    else and check it against what you expect. You keep doing this until there’s a
    point where what the code prints doesn’t align with what you wanted it to do.
    That’s when you’ve found the bug and can give Copilot a prompt to help it give
    you better code, or if the fix is simple, you can change the code directly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity of the code, using `print` statements is often an
    effective way of debugging. We often use it as our first step in debugging.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging: An art more than a science'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The iterative process when debugging is necessary because we’re genuinely confused
    about what the code is doing and why it isn’t matching our expectations. It’s
    okay to add a bunch of `print` statements that just tell you what you thought
    was happening in the first place because each of these `print` statements tells
    you where *not* to look for the bug and is an effective process of elimination.
    Figuring out where to look for bugs takes time and practice, so don’t worry if
    you find yourself spending a fair bit of time on it when you first start.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 Using VS Code’s debugger to learn about the code behavior
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VS Code is used by novices and professionals alike, so it has tools to help
    with the process of debugging. Because it’s used by professionals, debugging tools
    have a large number of features. For the purpose of this book, we’ll focus on
    a few of the most commonly used features, but feel free to look into more resources
    on using the VS Code debugger if you’re curious ([https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: To showcase these tools, we’ll work through debugging the same function from
    the previous example (refer to listing 8.1) in a few ways. Listing 8.4 provides
    the code we’ll be working with throughout this section. Note that we’ve added
    the test of the `count_words` function to the program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.4 Incorrect `count_words` function for debugging
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 Code to call the count_words function directly'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the debugger and setting breakpoints
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use the debugger, we need to set a *breakpoint* and start the debugger. Setting
    a breakpoint tells the debugger when you want to start debugging the program as
    it executes. Once you hit the breakpoint, you’ll be able to inspect variable values
    and step through the program line by line. Breakpoints are extremely useful. For
    a large program, you wouldn’t want to step line by line through the entire program
    because that could take a great deal of time. Instead, using a breakpoint, you
    can step through just the lines of code that are most relevant to you.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: To set a breakpoint, hover your mouse cursor to the left of the code, and you’ll
    see a dot appear. Click that dot, as shown in figure 8.1, and you’ll have a breakpoint
    set. For your projects, you’ll likely want to start by creating a breakpoint at
    the start of the function’s execution and then step through it one step at a time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-1.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 Creating a breakpoint in VS Code by clicking to the left of the line
    of code
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you see a red dot to the left of the breakpoint after you move your mouse
    away, as shown in figure 8.2, that means it’s properly set.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 A breakpoint has been set on line 2 of our count_words.py file in
    VS Code.
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can have more than one breakpoint, but for this example, let’s just stick
    with the one breakpoint on line 2\. (Note that you can remove a breakpoint by
    clicking on that red dot again.) Next, we’ll start the debugger and see how it
    works with the breakpoint.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: How to step through the code line by line
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To start the debugger, choose Run > Start Debugging, as shown in figure 8.3.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 Starting the debugger in VS Code
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once the debugger is started, you should see a screen similar to figure 8.4\.
    (If this is the first time using the debugger, it may ask you to select a debug
    configuration, in which case, you’ll want to choose Python.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-4.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 The Debugging view in VS Code
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The VS Code debugger has a number of components [1]. On the left-hand side,
    the Debug Side Bar contains the Variables section, Watch section, and Call Stack
    section. Let’s briefly examine each of these sections:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The *Variables section* contains the variables that are declared within the
    current scope (e.g., within `count_words`) and their current values. For example,
    the `words` parameter is defined to be a list containing `['Dan',` `'danger',`
    `'Leo']`. You can click the arrow (>) to the left of `words` to see more details
    about that variable. This section is incredibly useful because you can examine
    the value of each variable.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *Watch section* contains any expressions you want to watch specifically.
    For example, you might add the expression: `"dan"` `in` `word.lower()` to the
    watched expressions, and you’d be able to see if it’s `True` or `False` for each
    different value of `word`. To add an expression, hover over the Watch section
    and click the + sign.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Call Stack section* contains the functions that have been called that have
    led to this line of code executing. Here, the main function (called `<module>`
    by VS Code) called the function `count_words` on line 9\. Within the function
    `count_words`, we’re presently on line 2\. You can double-check that this is true
    by looking at the line of code presently highlighted as line 2 is highlighted
    in figure 8.4\.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speaking of which, on the right-hand side, which shows our code editor, we can
    see the line `count` `=` `0` highlighted. This is the current line of code that
    hasn’t yet been executed. The reason the line hasn’t been executed yet is because
    we set our breakpoint, shown by the arrow with a dot in it, at this line of code.
    When we started the debugger, it ran the code until just before executing `count`
    `=` `0`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The Debug Toolbar (figure 8.5) is critical as it drives the process once you
    start debugging: you can advance an instruction, restart debugging, or stop debugging.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-5.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 The Debugging Toolbar
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The buttons on the toolbar, going left to right, are
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '***Continue (F5)—*This button will advance until the next time a breakpoint
    is executed. In our example, line 2 of `count_words` never executes again, so
    clicking Continue will cause the program and debugging session to run to the end.**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***   ***Step Over (F10)—*This button advances to the next line of code in
    the current function. Step Over means that if a line of code in this function
    calls another function (e.g., when `word.lower()` is called on line 4), the debugger
    will stay in the `count_words` function and will just run the called function
    (e.g., `word.lower()`) to its completion.*****   ***Step Into (F11)—*This button
    advances to the next line of code, including going into any functions that are
    called. Unlike Step Over, when you use Step Into, the debugger will go into any
    function called by the current function. For example, if you used Step Into on
    a line of code that calls another function, it would go into that function and
    continue debugging (line by line) from inside that function. By default, it doesn’t
    step into library function calls (e.g., `word.lower()` is part of the Python standard
    library) but will step into functions you’ve written.*****   ***Step Out (Shift
    + F11)—*This button will execute the code until the present function ends and
    then continue debugging from after this function’s exit.*****   ***Restart—*This
    button restarts the debugging process. It will restart the program, and the program
    will execute until its first breakpoint.*****   ***Stop—*This button stops the
    debugging process.************'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '******#### Stepping through the code line by line'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a handle on the debugger, let’s continue our example by using
    the Step Over button. Let’s click Step Over once and see how our view changes
    (figure 8.6). Step Over advanced to the next line of code, line 3\. This means
    it executed
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and is just about ready to execute
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![figure](../Images/8-6.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-6.png)'
- en: Figure 8.6 Our debugger after clicking Step Over once. The next line (line 3)
    is now highlighted.
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6 点击一次“单步执行”后的调试器。下一行（第3行）现在被突出显示。
- en: We can see from various clues in the interface that the line `count` `=` `0`
    was executed. First, in the editor on the right, we can see the `for` loop is
    highlighted, and the arrow on the left points to this line of code. On the left,
    in the Call Stack section, we can see that it’s now on line 3 of `count_words`
    `(`as shown by the line `count_words` being highlighted and the number in the
    oval on the right reading 3:1). Perhaps most importantly, on the left in the Variables
    section, we can now see the variable `count` has been added to the local variables,
    and it has a value of `0`. This last piece is pretty amazing because if you were
    trying to read through the code and trace what is happening line by line, the
    line `count` `=` `0` on line 2 would mean that a variable count is created and
    assigned a value of `0`. This is just what the VS Code debugger has told us as
    well. We hope you’re starting to see how powerful this tool can be.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从界面的各种线索中看到，执行了`count` `=` `0`这一行。首先，在右侧的编辑器中，我们可以看到`for`循环被突出显示，左侧的箭头指向这一行代码。在左侧的调用栈部分，我们可以看到它现在位于`count_words`的第三行（如`count_words`被突出显示，右侧椭圆中的数字读作3:1）。也许最重要的是，在左侧的变量部分，我们现在可以看到变量`count`已被添加到局部变量中，其值为`0`。这一点非常令人惊讶，因为如果你试图逐行阅读代码并跟踪正在发生的事情，第2行的`count`
    `=` `0`意味着创建了一个名为`count`的变量，并赋予了一个值为`0`。这正是VS Code调试器告诉我们的事情。我们希望你现在开始看到这个工具是多么强大。
- en: Let’s click Step Over one more time. Now we’re stopping just before the line
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次点击“单步执行”。现在我们在该行之前停止。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see that there is now a new variable, `word`, which has been assigned
    the value `"Dan"`, and that’s just what we’d expect: `word` was given the value
    of the first element in the list `words`. This is a good spot to point out that
    in addition to being able to read the variables values in the Variables section,
    you can also just hover your mouse over any variable that’s been declared already
    to see its value as well. Pretty neat, huh?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到现在有一个新的变量`word`，其值被赋为`"Dan"`，这正是我们所期望的：`word`被赋予了列表`words`中的第一个元素的值。这是一个很好的地方来指出，除了能够在变量部分读取变量的值之外，你还可以将鼠标悬停在已经声明的任何变量上，以查看其值。真是太棒了，不是吗？
- en: Let’s click Step Over one more time and see that the condition in the `if` statement,
    `"dan"` `in` `word.lower()`, evaluated to `True`, so we’re going to execute the
    line
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次点击“单步执行”并看到`if`语句中的条件`"dan"` `in` `word.lower()`评估为`True`，因此我们将执行该行
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we’re getting the hang of this, let’s keep clicking Step Over a few
    more times. The first time you click Step Over, it will go back to the `for` loop,
    and you can see `count` has incremented to `1`. The second time you click Step
    Over, it will stop at the `if` statement, and you can see that word is now `"danger"`.
    We could stop here and add a watch expression to see what this `if` statement
    will do. To add a watch expression, hover your mouse over the Watch section, and
    click the plus arrow that appears to the right of the word Watch. This will let
    you type anything you want. We typed `"dan"` `in` `word.lower()` and pressed Enter
    to add this watch expression, as shown in the Debug Side Bar of figure 8.7.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了这个技巧，让我们继续点击几次“单步执行”。第一次点击“单步执行”，它将回到`for`循环，你可以看到`count`已经增加到`1`。第二次点击“单步执行”，它将停在`if`语句处，你可以看到单词现在是`"danger"`。我们可以在这里停止并添加一个观察表达式来查看这个`if`语句会做什么。要添加观察表达式，将鼠标悬停在“观察”部分，然后点击出现在“观察”右侧的加号箭头。这将允许你输入任何你想要的内容。我们输入了`"dan"`
    `in` `word.lower()`并按Enter键添加了这个观察表达式，如图8.7的调试侧边栏所示。
- en: '![figure](../Images/8-7.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-7.png)'
- en: Figure 8.7 View of the debugger after adding the watch expression
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7 添加观察表达式后的调试器视图
- en: If we hadn’t already found the bug earlier in this chapter, this is where we’d
    find it. The expression `"dan"` `in` `word.lower()` evaluates to `True`, which
    means `count` will be incremented again. But we only wanted exact matches to the
    word `"Dan"` and didn’t want `"danger"` to count!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这章的早期没有找到错误，那么这就是我们会找到错误的地方。表达式`"dan"` `in` `word.lower()`评估为`True`，这意味着`count`将再次增加。但我们只想精确匹配单词`"Dan"`，不希望`"danger"`被计算在内！
- en: This is a completely reasonable way to debug a function. As we noted earlier,
    putting a breakpoint at the start of the function’s execution and then stepping
    through it one step at a time often is a great starting point for debugging. The
    only times you might struggle to use this approach is if the `for` loop ran through
    thousands of values before making a mistake. To address challenges like this,
    we might put a breakpoint in a specific spot to avoid spending a lot of time in
    the debugger. Let’s stop the debugger (click Stop in the Debug Toolbar), remove
    the breakpoint from line 2 (click the red dot to the left of the line), and try
    a different breakpoint.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Using a breakpoint to selectively debug
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This time, let’s put the breakpoint at a point in the code we want to monitor
    more closely. Based on our test case showing that two words of the list “counted”
    when we expected just one to, we should try putting our breakpoint at the line
    where `count` is incremented, as we have in figure 8.8.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 View of the code after placing our new breakpoint on line 5
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once we start the debugger, the code will run until the first time the `if`
    statement is evaluated to `True` and the line `count` `+=` `1` is ready to execute.
    Figure 8.9 offers the view of the debugger once we start it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-9.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 View of the debugger when it encounters the breakpoint (line 5) for
    the first time
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We put the breakpoint at the incrementing of `count` because we wanted to see
    what item in the list is causing `count` to increment. Examining our local variables,
    we can see that `word` is `'Dan'`, and that is when we want the `count` variable
    to be incremented. Given this is what we wanted to happen, we haven’t found our
    bug yet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Now is when we can really take advantage of our breakpoint placement. We want
    the code to execute until it comes across the breakpoint again. The way to do
    this is to click Continue in the Debug Toolbar (refer to figure 8.5). After clicking
    Continue, the debugger should appear as in figure 8.10.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-10.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 View of the debugger when it encounters the breakpoint (line 5)
    for the second time
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the Variables section, notice that the value of `count` and the value of
    `word` are highlighted. This is to tell you that because you clicked Continue,
    those two values have changed. The value in `count` increased to `1`, as expected,
    after having found the word `'Dan'`. The value in `word` updated to `'danger'`.
    Although `'danger'` is the next value in the list of words, we shouldn’t expect
    to find the code incrementing `count` for the word `'danger'`. At this point,
    we’d have found our bug. Notice how much quicker it can be to find a bug with
    a good placement of a breakpoint. But we caution that knowing the best place to
    put a breakpoint is a lot like knowing the best variables to print when debugging—it
    takes time and practice to learn how to do it well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve seen how powerful the debugger can be in VS Code. It’s
    pretty easy to set a breakpoint and start a debugging session. As the debugger
    monitors the variables in the function, you can inspect those in the Debug Side
    Bar as the code executes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 How to fix a bug (once found)
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the old way of learning to program, this would be a short section that would
    tell you to fix the bug yourself. Although that’s still an option, we have a lot
    of choices now with Copilot. These choices include asking Copilot to fix it, giving
    it a new prompt for the entire function that better describes the problem in a
    way to avoid the bug, giving Copilot a targeted prompt to fix the spot in the
    code you found that was wrong, and, if it’s a small fix, making it yourself. Let’s
    see how we could do each of these.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Asking Copilot to fix your bug via Copilot Chat
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In the following example, we’ll interact with the Copilot Chat feature. The
    Copilot Chat feature lets you interact with Copilot as you might with ChatGPT
    but is limited to questions pertaining to programming. Feel free to interact with
    ChatGPT instead (available via [https://openai.com](https://openai.com) with free
    tiers at the time of writing) in the same way as we interact with Copilot in this
    section. We’re preferential to Copilot Chat just because its interface is built
    in to the latest version of VS Code and the Copilot extension.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '*In previous chapters, we’ve mostly just asked Copilot Chat for single answers,
    whereas in this chapter and later chapters, we’ll be using Copilot Chat to have
    a conversation with the tool. When we’re having a conversation with the tool,
    we’ll work to separate out what we write (“Human”) from Copilot’s responses (“GitHub
    Copilot”). Using the Copilot Chat feature, let’s see if Copilot can help us out
    here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanI have a function, below, that is supposed to count the number of times
    the word “Dan” appears in the parameter list “words”. Instead, it seems to be
    counting the number of times the characters “dan” appear anywhere in the list.
    Can you help fix this for me?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Certainly! To count the number
    of times the word “Dan” appears in the list, you can modify the `if` statement
    to check if the whole word is equal to “Dan” (case-insensitive). Here’s the modified
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will count the number of times the word “Dan” (case-insensitive) appears
    in the list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The answer back from Copilot Chat changed the line
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: to
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although the change may look small, it has a big effect. The original line of
    code searched for the string `"dan"` anywhere in `word` (after the word has been
    made all lowercase letters by the `.lower()` method). The new line of code checks
    to see whether `word` (again, made all lowercase letters by the `.lower()` method)
    is an exact match for the string `"dan"`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: This answer from Copilot is a step closer to a correct solution as it will only
    match the whole word rather than looking for an occurrence of `dan` anywhere in
    the word. However, the call to `.lower()` makes it case-insensitive, so it would
    also match `dan` rather than how our solution earlier (listing 8.3) was case-sensitive
    (it had to be exactly `Dan`). We’d like to be case-sensitive, so we could continue
    with Copilot Chat to have Copilot fix this for us.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanCan you give me the same code but count only the word “Dan” (case-sensitive)?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure! Here’s the modified code
    that counts only the word “Dan” (case-sensitive):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code will count the number of times the word “Dan” (case-sensitive) appears
    in the list.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Copilot Chat was able to solve the problem for us when we knew
    how the code was misfunctioning. We didn’t explicitly say what line of code was
    broken, but if you knew this, you could convey that to Copilot Chat as well. One
    advantage of knowing which line was broken, like we did here, is that we could
    look to make sure the fix from Copilot changes the broken line. Let’s move on
    and examine other options for fixing the bug.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 Giving Copilot a new prompt for the whole function
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve seen us rewrite the prompt for a function a fair number of times already
    in this book. It simply involves rewriting the function prompt and seeing if Copilot
    can do better, sometimes using Ctrl-Enter to explore Copilot’s solutions. We won’t
    repeat this here because you’ve already seen it many times before (e.g., in chapter
    6, section 6.5.2).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.3 Giving Copilot a targeted prompt for part of a function
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used this technique earlier in the chapter in listing 8.3\. We’ve reproduced
    this as listing 8.5.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.5 Using a prompt to fix a known bug (relisted)
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 Prompt that causes Copilot to generate correct code'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’d figured out that the previous line
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: wasn’t doing what we wanted. So, we removed the incorrect code and specifically
    added a prompt to say exactly what we wanted Copilot to do, and it was able to
    produce the correct code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.4 Modifying the code to fix the bug yourself
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach to fixing broken code is new to this chapter. You’ve seen enough
    code at this point in the book that you can likely fix some code by yourself by
    directly modifying it. For example, suppose we wrote the following code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.6 Function to count specified numbers in a list
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve seen functions like this earlier in the book. It iterates through all
    the numbers in the list of numbers and checks if each number is bigger than or
    equal to `x` and is less than or equal to `y`. If a number is between `x` and
    `y`, it increases the `count`. At the end of the function, it returns the `count`.
    The code isn’t wrong here if the goal is to count numbers in the list that are
    between `x` and `y` (including `x` and `y`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: However, the term *between* can be a bit ambiguous. Do you want to include `x`
    and `y` or just the values between them (not including them)? Suppose that when
    you imagined this function, you wanted to not include `x` and `y.` For example,
    if the list were 2, 4, 8, and you provided `x` and `y` values of 3 and 8, you
    would want the `count` to be 1 (including 4, but not 8). You might already see
    how the function is wrong for this goal and how to fix it, but let’s pretend you
    don’t realize yet that the code doesn’t match what you want.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any function that is created either by Copilot or us, we should test
    the function. Fortunately, when writing the first test case, we included a value
    in the test case (`numbers`) that is equal to `x` (the lower bound) and equal
    to `y` (the upper bound):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Testing the code at the prompt, we found that our function returns 5 as the
    answer, but we thought the answer should be 3\. By our definition of *between*,
    we felt that only the numbers 4, 5, and 6 are between 3 and 7, so the answer should
    be 3, that is, there are three numbers between 3 and 7\. Instead, the code gave
    us the answer of 5\. So, we know it isn’t working correctly thanks to our test
    cases. Whether we go on to find the bug by inspecting the code or by using the
    debugging techniques from this chapter, we realize the statement
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: is the culprit. Here, the complete fix requires us to change the `if` statement
    from
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: to
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a change we could just make directly, without asking for Copilot’s help
    (although Copilot would likely be able to help us here as well). Listing 8.7 has
    the fixed function after the change.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.7 Function to count specified numbers (corrected)
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Changed the >= to > and <= to < manually'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Modifying our workflow in light of our new skills
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to find and fix bugs in a more deliberate manner, let’s
    revisit the workflow we last visited in chapter 6\. Note that this workflow is
    about how to design a single function, so it presumes you’ve already done the
    function decomposition described in chapter 7 to determine the appropriate functions.
    The new workflow appears in figure 8.11.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-11.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 The function design cycle with Copilot, augmented to include debugging
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although the figure is starting to get a bit complicated, most of this is what
    you saw previously in chapter 6\. The only changes here are to include debugging.
    Specifically, if you’ve already tried to revise the prompt and you still can’t
    get code that works, then it’s time to try debugging explicitly. With the tools
    you’ve gained in this chapter, you’ll likely be successful at finding some bugs
    but not all possible bugs. If you find the bug and feel you’ve successfully fixed
    it, the flowchart sends you back to testing to make sure your fix worked (and
    didn’t break any other test cases). On the off chance you can’t get the code to
    work through new prompts and just can’t seem to debug it, we’ve found that problem
    decomposition is often your best next step. In other words, if you can’t get a
    function to work no matter how hard you try, the function should probably be broken
    into multiple functions, and you’re more likely to be successful coding those
    smaller functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Applying our debugging skills to a new problem
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our new skills in place and a new workflow, let’s try tackling a more challenging
    debugging problem. Remember in chapter 6 when we tried to determine the largest
    number of empty seats in a given row in a classroom? We’re going to solve a similar
    problem here.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Instead of looking for empty seats, let’s say that we want to count the most
    students seated consecutively in a row because you’re trying to space them out
    better before an exam. You could also imagine using this to space out people more
    if they want more personal space or if there’s a pandemic. We wrote the prompt
    and a basic doctest, and Copilot generated a solution. The code appears in the
    following listing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.8 First attempt to count consecutive students in a row
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 Our prompt to Copilot'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The first test case'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The code from Copilot'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The code to run the doctest that we added'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Given this chapter is about debugging, you can probably guess the code isn’t
    working correctly. We caught this bug when we read the code Copilot gave us, but
    it’s a subtle bug that we suspect could be missed fairly easily. If you see it
    already, great job, but pretend you didn’t for the rest of the chapter. If you
    haven’t seen it, the rest of the chapter is going to be more valuable to you.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine then that we just wrote this prompt and test case. We read through
    the code, and it looks like it’s probably keeping track of the most consecutive
    students. As long as it sees a student in a seat, it increments the count. When
    there isn’t a student in the seat, it checks to see whether the count is bigger
    than any previously seen and resets the count. It seems like it’s at least on
    the right track. We included a test case, so we ran the code, and the test case
    passed. We’re feeling pretty good about the code but know we need to do more test
    cases, particularly ones to catch edge cases (remember that edge cases are uncommon
    cases that could break the code).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'We know when we work with lists, it’s good to check that the code does the
    right thing at the start and end of the list. To test the end of the list, let’s
    add a test case where the largest group of consecutive students includes the last
    seat and then rerun the code. Here’s the new test case we’re adding to the docstring:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 The longest group of consecutive students is 4.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the code again and are surprised when the test cases fail. Here’s what
    it told us (we reformatted the output for readability):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That’s odd—the code seemed to be working properly. Something about this edge
    case has uncovered the error. At this point, we’d want to generate some hypotheses
    about why the code isn’t working properly to help guide our debugging efforts.
    (If you’re truly stumped, you could take the approach of just setting a breakpoint
    at the first line of code in the function and stepping through it rather than
    trying to create a hypothesis.) Here are two hypotheses that come to mind:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The updating of `count` is skipping the last element in the list.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The updating of `max_count` is missing the last element in the list.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To simplify the debugging process, we removed the test that is passing (just
    set it aside to restore later) and are only going to run the test that is failing.
    The following listing shows our full code before we start the debugging process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.9 Code that we’ll debug to count consecutive students
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Failed test case'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the first hypothesis, that `count` isn’t updating properly
    at the end of the list and set a breakpoint at the updating of `count`. Figure
    8.12 shows the first time the debugger pauses after it’s started.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-12.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 Debugger stopping before the first update of `count`
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From the debugger, we can see that `count` is still `0`, so it hasn’t been updated
    yet. We’re in the first row of that first test case because `row` is `['S',` `'`
    `',` `'S',` `'S',` `'S',` `'S']`. The seat we’re looking at is an `'S'`, which
    is why the count is increasing. Let’s click Continue in the Debug Toolbar to see
    the next update of `count`. The state of the debugger after clicking Continue
    appears in figure 8.13.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-13.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 Debugger stopping before the second update of `count`
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A fair bit has happened, it seems, since the last update of `count` because
    `max_count` is now `1`. This must have happened when the empty space was processed
    because `max_count` was set to `1` and `count` was reset back to `0`. At this
    point, we’re at the third seat in the row with a student there, and `count` is
    ready to update. We’ll want to check that `count` keeps updating with each new
    student. We clicked Continue, and `count` increased to `1`. We clicked Continue
    again, and the `count` increased to `2`. We click Continue once more, and the
    `count` increased to `3`. At this point, we’re at the last student in the row,
    and we want to check that `count` increases to `4`. To check this, we clicked
    Step Over once, and `count` indeed updates to `4`. You can see the state of the
    debugger at this point in figure 8.14.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-14.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 Debugger stopping right after the fourth consecutive update of `count`
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Well, we have good news and bad news at this point. The good news is that `count`
    is properly updating. The bad news is that our first hypothesis was wrong, and
    we haven’t found our bug yet. We could move our breakpoint to the line where `max_
    count` is updated (line 22) and then click Restart and start over the debugging
    process for our second hypothesis, but given that `count` is `4` right now in
    our debugger, let’s just continue to trace through the code and make sure `max_count`
    gets updated. Or rather, we know it won’t be, so we want to see why.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Before clicking Step Over, we’ve got a clue already present in the debugger.
    This clue comes from the fact that the next line of code to execute is `for` `seat`
    `in` `row`. But the student we just saw was the last student in `row`. This means
    this `for` loop is just about to finish (meaning we won’t execute the body of
    the loop again, which means `max_count` can’t get updated). Let’s see whether
    that’s what happens by clicking Step Over. The state of the debugger appears in
    figure 8.15.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-15.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 Debugger stopping after finishing the first row
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We just finished processing the first row, but we never updated the `max_count`.
    The next line of code will pick the next `row`, and the line after that will set
    `count` to `0` again. We finished the loop over the row without ever updating
    `max_count` even though we found a `count` that’s bigger than the current `max_count`.
    If you don’t see the bug yet, we encourage you to step through until the next
    time `max_count` is updated, and it may be more obvious at that point.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The error in the code is that it only updates `max_count` when it encounters
    an empty seat. This means that if a row ends with a student, the code to check
    whether `max_count` should be updated will never run for that row. Examining the
    code more closely, the test to see whether `max_count` should be updated and the
    update of `max_count` should both occur either outside the `if-else` statement
    or right after `count` is updated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: This is a fix we can probably just make manually because all we need to do is
    move two lines of code to a better location. The code in listing 8.10 is the corrected
    function (without the tests or prompts).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.10 Corrected function to count consecutive students
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#1 Moved the testing of count against max_count to immediately after the updating
    of count'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This new code does pass the test that failed with the old code and the original
    test. After adding another test that makes sure the code works when the longest
    group of consecutive students appears at the start of the row, we’re more confident
    the code is now working properly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Using the debugger to better understand code
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We suspect you’re already pretty impressed by the debugger. We are too. When
    students were taught programming in the traditional manner, a lot of time was
    spent making sure students could essentially trace through code like a debugger
    would, drawing out the state of all the variables and updating them with each
    new line of execution. Indeed, there’s even a free tool on the web called Python
    Tutor [2] that creates diagrams of the state of memory that can be easier to read
    than a debugger, just to help new programmers learn how the code executes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Whether you like using the debugger or want to use a tool like Python Tutor,
    we encourage you to play with some of the code you’ve written from earlier sections
    of the book. In our personal experience working with people learning how to program,
    walking through a program line by line and watching how the state of variables
    changes can be a truly enlightening experience, and we hope you’ll appreciate
    it too.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 A caution about debugging
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From working with students, we’ve also seen that debugging can be a really frustrating
    experience for new learners [3]. When learning how to program, everyone wants
    their code to work, and finding and fixing bugs is time spent when things aren’t
    working. There are a couple of ways to help overcome this frustration. First,
    problem decomposition can go a really long way to helping you get code from Copilot
    that is right without the need for extensive debugging. Second, remember that
    everyone’s code doesn’t work sometimes, including ours. It’s just a natural part
    of the programming process and a part that can take some practice. Last, always,
    and we mean always, test every function you write. More often than not, when our
    students are really stuck debugging, it’s because there are bugs in multiple functions
    interacting as a result of not testing each function. When that happens, it’s
    exceptionally hard to find and remedy the bugs. Debugging interacting bugs is
    so frustrating that avoiding the experience is a big reason why both of us religiously
    test every function we write.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that if you test every function you write and diligently break
    down problems into small, manageable steps, you shouldn’t find yourself debugging
    that often. And, if you do, you’ll be debugging the error in one function, which
    is what essentially every programmer on the planet does. With some practice, you’ll
    get the hang of it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Exercises
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re given a Python function that is supposed to calculate the sum of all
    even numbers in a list. However, the function isn’t working correctly. When you
    call the function with the list `[1,` `2,` `3,` `4]`, it returns `4` instead of
    `6`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Identify the bug in the `sum_even_numbers` function, and explain how to fix
    it. Modify the code to correct the bug, and verify your solution with the provided
    test case.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '2\. You’re given a Python function that is supposed to find the maximum number
    in a list of numbers. However, the function isn’t working as expected. Your task
    is to determine why the function is working incorrectly, and how you can fix this
    (hint, think about the possible integer values in the input list):'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '3\. You’re given a Python function that is supposed to check if a string is
    a valid password. A valid password must meet the following criteria:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must be at least 8 characters long.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It must contain at least one uppercase letter.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It must contain at least one lowercase letter.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It must contain at least one digit.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, the function isn’t working correctly. Determine what is wrong with
    the function and fix it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '4\. You’re writing a Python function to greet users based on the time of day.
    The function takes an hour (integer between 0 and 23) as input and returns a greeting
    message (“Good morning”, “Good afternoon”, or “Good evening”):'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You’re considering using this prompt to ask Copilot to help you fix the bug:
    “I have a function to greet users based on the time of day, but it seems to classify
    noon as ‘Good evening’. Can you help me fix the logic?” The prompt mentions the
    problem but doesn’t pinpoint the exact error. See if you can edit the provided
    prompt to make it more specific and guide Copilot toward suggesting the correct
    fix.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging is an important skill that includes finding errors in code and then
    correcting them.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Print` statements can be an effective way of learning about what is happening
    in your code.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VS Code debugger is another way of learning what is happening in your code
    that provides powerful features for monitoring how variables change as the code
    executes.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once an error is uncovered, there are multiple ways to help Copilot fix the
    error for you, but if that fails, you can often fix the code directly.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our workflow of designing functions now includes debugging, and with the skill
    of debugging, you’re more apt to write the software you want.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside of debugging, the VS Code debugger can be a powerful tool in learning
    more about how the code works.***********
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
