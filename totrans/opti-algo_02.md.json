["```py\nfrom sympy import binomial\nprint(binomial(5,3))\n```", "```py\nfrom sympy.functions.combinatorial.numbers import stirling\nprint(stirling(50,4))\nprint(stirling(100,4))\n```", "```py\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\n\ndef objective_unimodal(x, y):           ①\n    return x**2.0 + y**2.0\n\ndef objective_multimodal(x, y):         ②\n    return np.sin(x) * np.cos(y)\n\ndef objective_deceptive(x, y):          ③\n    return (1-(abs((np.sin(math.pi*(x-2))*np.sin(math.pi*(y-2)))/\n➥  (math.pi*math.pi*(x-2)*(y-2))))**5)*(2+(x-7)**2+2*(y-7)**2)\n\nfig = plt.figure(figsize = (25,25))\nax = fig.add_subplot(1,3,1, projection='3d')\n\nx = np.arange(-3, 3, 0.01)\ny = np.arange(-3, 3, 0.01)\n\nX, Y = np.meshgrid(x, y)\nZ = objective_unimodal(X, Y)\nsurf = ax.plot_surface(X, Y, Z, cmap=plt.cm.cividis)\nax.set_xlabel('x', fontsize=15)\nax.set_ylabel('y', fontsize=15)\nax.set_zlabel('Z', fontsize=15)\nax.set_title(\"Unimodal/Convex function\", fontsize=18)\n\nax = fig.add_subplot(1,3,2, projection='3d')\nZ = objective_multimodal(X, Y)\nsurf = ax.plot_surface(X, Y, Z, cmap=plt.cm.cividis)\nax.set_xlabel('x', fontsize=15)\nax.set_ylabel('y', fontsize=15)\nax.set_zlabel('Z', fontsize=15)\nax.set_title(\"Multimodal function\", fontsize=18)\n\nX, Y = np.meshgrid(x, y)\nZ = objective_unimodal(X, Y)\nax = fig.add_subplot(1,3,3, projection='3d')\nZ = objective_deceptive(X, Y)\nsurf = ax.plot_surface(X, Y, Z, cmap=plt.cm.cividis, antialiased=False)\nax.set_xlabel('x', fontsize=15)\nax.set_ylabel('y', fontsize=15)\nax.set_zlabel('Z', fontsize=15)\nax.set_title(\"Deceptive function\", fontsize=18)\n\nplt.show()\n```", "```py\nfrom copy import deepcopy\nimport math\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nboard_size = 4\nboard = np.full((board_size, board_size), False)         ①\n\ndef can_attack(board, row, col):\n    if any(board[row]):                                  ②\n        return True                                      ②\n\n    offset = col - row                                   ③\n    if any(np.diagonal(board, offset)):                  ③\n        return True                                      ③\n    offset = (len(board) - 1 - col) - row                ③\n    if any(np.diagonal(np.fliplr(board), offset)):       ③\n        return True                                      ③\n\n    return False\n\nboard[0][0] = True\ncol = 1 \nstates = [deepcopy(board)]\nwhile col < board_size:\n    row = 0\n    while row < board_size:\n        if not can_attack(board, row, col):              ④\n            board[row][col] = True\n            col += 1\n            states.append(deepcopy(board))\n            break\n        row += 1\n        if row == board_size:                            ⑤\n            board = np.delete(board, 0, 1)\n            new_col = [[False]] * board_size\n            board = np.append(board, new_col, 1)\n            states.append(deepcopy(board))\n            col -= 1\n            continue\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\nfrom ortools.sat.python import cp_model                          ①\n\nboard_size = 4 \n                                                                 ②\nmodel = cp_model.CpModel()                                       ③\n\nqueens = [model.NewIntVar(0, board_size - 1, 'x%i' % i) \n➥for i in range(board_size)]                                    ④\n\nmodel.AddAllDifferent(queens)                                    ⑤\n\nmodel.AddAllDifferent(queens[i] + i for i in range(board_size))\nmodel.AddAllDifferent(queens[i] - i for i in range(board_size))\n\nsolver = cp_model.CpSolver()                                     ⑥\nsolver.parameters.enumerate_all_solutions = True                 ⑥\nsolver.Solve(model)                                              ⑥\n\nall_queens = range(board_size)                                   ⑦\nstate=[] \nfor i in all_queens:\n    for j in all_queens:\n        if solver.Value(queens[j]) == i:\n            # There is a queen in column j, row i.\n            state.append(True)\n        else:\n            state.append(None)     \n\nstates=np.array(state).reshape(-1, board_size)\nfig = plt.figure(figsize=(5,5))                                 ⑧\nmarkers = [                                                     ⑧\n    x.tolist().index(True) if True in x.tolist() else None      ⑧\n    for x in np.transpose(states)                               ⑧\n]                                                               ⑧\nres = np.add.outer(range(board_size), range(board_size)) % 2    ⑧\nplt.imshow(res, cmap=\"binary_r\")                                ⑧\nplt.xticks([])                                                  ⑧\nplt.yticks([])                                                  ⑧\nplt.plot(markers, marker=\"*\", linestyle=\"None\",                 ⑧\n➥markersize=100/board_size, color=\"y\")H                        ⑧\n```", "```py\nimport numpy as np\nimport scipy.optimize as opt\nimport matplotlib.pyplot as plt\n\ndef f(x):                                                      ①\n    return -(-20*x**2+6200*x-350000)/1000 \n\nres=opt.minimize_scalar(f, method='bounded', bounds=[0, 250])  ②\n\nprint(\"Optimal Ticket Price ($): %.2f\" % res.x)\nprint(\"Profit f(x) in K$: %.2f\" % -res.fun)\n```", "```py\nOptimal Ticket Price ($): 155.00\nProfit f(x) in K$: 130.50\n```", "```py\nimport sympy as sym\n\nx,y=sym.var('x, y', positive=True)                     ①\n\nf=155*x+(0.001*x**sym.Rational(3,2)+70)*y-1000000      ②\n\ng=x+y-10000                                            ③\n\nlamda=sym.symbols('lambda')                            ④\nLagr=f-lamda*g                                         ⑤\n\neqs = [sym.diff(Lagr, x), sym.diff(Lagr, y), g]        ⑥\n\nsol=sym.solve(eqs,[x,y,lamda], dict=True)              ⑦\n\ndef getValueOf(k, L):\n    for d in L:\n        if k in d:\n            return d[k]\n\nprofit=[f.subs(p) for p in sol]\n\nprint(\"optimal number of physical ticket sales: x = %.0f\" % getValueOf(x, sol))\nprint(\"optimal number of online ticket sales: y = %.0f\" % getValueOf(y, sol))\nprint(\"Expected profil: f(x,y) = $%.4f\" % profit[0])\n```", "```py\nfrom pulp import *\n\nmodel = LpProblem(\"Animal_Feed_Mix_Problem\", LpMinimize)                    ①\n\nx1 = LpVariable('Corn', lowBound = 0, upBound = 1, cat='Continous')         ②  \nx2 = LpVariable('Limestone', lowBound = 0, upBound = 1, cat='Continous')    ②\nx3 = LpVariable('Soybean meal', lowBound = 0, upBound = 1, cat='Continous') ②\n\nmodel += 30.5*x1 + 10.0*x2 + 90*x3, 'Cost'                                  ③\n\nmodel +=0.008 <= 0.001*x1 + 0.38*x2 + 0.002*x3 <= 0.012, 'Calcium limits'   ④\nmodel += 0.09*x1 + 0.5*x3 >=0.22, 'Minimum protein'                         ④\nmodel += 0.02*x1 + 0.08*x3 <=0.05, 'Maximum fiber'                          ④\nmodel += x1+x2+x3 == 1, 'Conservation'                                      ④\n\nmodel.solve()                                                               ⑤\n\nfor v in model.variables():                                                 ⑥\n    print(v.name, '=', round(v.varValue,2)*100, '%')                        ⑥\n                                                                            ⑥\nprint('Total cost of the mixture per kg = ',                                ⑥\n    ➥round(value(model.objective)/100, 2), '$')                            ⑥\n```", "```py\nCorn = 65.0%\nLimestone = 3.0%\nSoybean_meal = 32.0%\nTotal cost of the mixture per kg = 0.4916$\n```", "```py\nimport numpy\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom matplotlib.colors import rgb2hex\n\nwidth = 4                                                             ①\nheight = 8                                                            ①\ncontainer = numpy.full((height,width), 0)                             ①\n\nobjects = [[3,1],[3,3],[5,1],[4,2],[3,2]]                             ②\n\ndef fit(container, object, obj_index, rotate=True):                   ③\n    obj_w = object[0]                                                 ③\n    obj_h = object[1]                                                 ③\n    for i in range(height - obj_h + 1): C                             ③\n        for j in range(width - obj_w + 1):                            ③\n            placement = container[i : i + obj_h, j : j + obj_w]       ③\n            if placement.sum() == 0:                                  ③\n                container[i : i + obj_h, j : j + obj_w] = obj_index   ③\n                return True                                           ③\n        return fit(container, object[::-1], obj_index, rotate=False)  ③\n```", "```py\ndef largest_first(container, objects):\n    excluded = []\n    assigned = []\n    objects.sort(key=lambda obj: obj[0] * obj[1], reverse=True)   ①\n    for obj in objects:\n        if not fit(container, obj, objects.index(obj) + 1):\n            excluded.append(objects.index(obj) + 1)               ②\n        else:\n            assigned.append(objects.index(obj) + 1)\n    if excluded: print(f\"Items excluded: {len(excluded)}\")\n    visualize(numpy.flip(container, axis=0), assigned)            ③\n```", "```py\ndef smallest_width_first(container, objects):\n    excluded = []\n    assigned = []\n    objects.sort(key=lambda obj: (obj[0], obj[0] * obj[1]))      ①\n    for obj in objects:\n        if not fit(container, obj, objects.index(obj) + 1):\n            excluded.append(objects.index(obj) + 1)\n        else:\n            assigned.append(objects.index(obj) + 1)\n    if excluded: print(f\"Items excluded: {len(excluded)}\")\n    visualize(numpy.flip(container, axis=0), assigned)           ②\n```"]