- en: Chapter 7\. Building Web Applications with AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shifts the focus from prompting quick prototypes to developing
    complete web applications using AI assistance. Web apps typically involve a frontend
    (often written in frameworks like React, Angular, or Vue), a backend (APIs, databases,
    servers), and glue to connect everything. Vibe coding can accelerate each of these
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll walk you through an end-to-end workflow for building a web application
    with an AI pair programmer, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project and its scaffolding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the frontend UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing backend logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and validating the whole stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, I’ll highlight AI development patterns for frontends (for example,
    having AI generate React or Vue components from descriptions) and backends (writing
    routes, business logic, and database queries through natural-language prompts).
    I’ll also cover how to optimize collaboration between humans and AI in a full
    stack project, ensuring that each side contributes its strongest work. By the
    end of this chapter, you should have a clear roadmap for using AI not just for
    isolated coding tasks but for managing entire web development workflow efficiently
    and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting Up the Project: Scaffolding with AI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every web application starts with some *scaffolding*—the initial setup of build
    tools, file structure, dependencies, etc. AI can automate the creation of a lot
    of the boilerplate. Modern web frameworks often come with command-line interface
    (CLI) tools that can generate a base project, but you might still need to configure
    certain things or integrate additional libraries. An AI assistant can help by
    either guiding you through these CLI tools or setting up custom project structures
    on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to start a new application project using React
    for the frontend and Express for the backend. A pre-AI workflow for this task
    would probably look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a CLI tool or Vite to set up the React project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize an Express app (perhaps with `npm init` and installing Express).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a proxy for development or configure [Cross-Origin Resource Sharing (CORS)](https://oreil.ly/bgw1V)
    so the React frontend can talk to the Express backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maybe integrate a database like MongoDB or set up an SQLite file for simple
    usage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using an AI coding environment like Cursor or Cline, you can instead describe
    your desired setup in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a new project with a React frontend (using Vite) and an Express backend.
    The backend should serve a REST API for a to-do list and use an in-memory array
    to start. Configure the frontend to proxy API requests to the backend in development.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An advanced AI IDE can take this instruction and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create two directories (frontend and backend).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `npm create vite@latest` (if it has shell access) or template out a basic
    React app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize a basic Express server file in the backend, with an endpoint like
    */api/to-dos* (returning some sample data).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include a *package.json* in each directory with relevant scripts (like `start
    both`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up communication between frontend and backend by either configuring a proxy
    in the React development server or providing instructions for implementing CORS
    headers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within a couple of minutes, you’ll have the skeleton of a full stack web app.
    Even if the AI doesn’t do everything automatically, it might present you with
    code and the instructions you need to finalize it (for example, “Add this proxy
    setting to your React *package.json* file”). This saves a lot of mindless setup
    time and allows you to focus immediately on features.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you aren’t using an AI IDE, you can still use ChatGPT or another assistant
    step-by-step as you go; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: I want to create a new React app. What commands should I run?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The AI can guide you through steps or recommend newer alternatives like Vite
    or Next.js:'
  prefs: []
  type: TYPE_NORMAL
- en: Now set up an Express server with a /api/to-dos route.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It can generate the code for the Express server, which you copy into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: How do I connect my React app to this API during development?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It might suggest either a proxy configuration or tell you how to call the API
    (including the full URL, if not proxying).
  prefs: []
  type: TYPE_NORMAL
- en: This way, even setting up the basic plumbing becomes a conversation rather than
    a hunt through documentation. As noted in earlier chapters, *programming by intent*
    means you tell the AI what outcome you want, and it figures out the steps. Setting
    up a project is a perfect scenario for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, it’s important to assert your architectural decisions. The AI
    will follow your lead. Humans are essential for architectural and high-level decisions,
    so decide on the stack and major patterns yourself: Do you want a monorepo or
    separate repos for front and back? Will you use REST or GraphQL? Which database?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have these in mind, you can instruct the AI accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: Also set up a basic Prisma schema for the SQLite database.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: Include a GraphQL server instead of REST.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI might not perfectly execute complex setups, but it will get the bulk
    of the work done, and you can refine from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many experienced developers integrate these steps into project templates or
    use boilerplate generators, but AI offers a more flexible approach: you can customize
    on the fly using natural language. This means if your project is slightly unusual
    (maybe you need three services instead of the usual two tiers, or you want to
    preconfigure a particular library like Tailwind CSS), just ask the AI to include
    what you want.'
  prefs: []
  type: TYPE_NORMAL
- en: Frontend Development Patterns with AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the scaffolding is ready, developing the frontend of a web app is a major
    part of the effort. This section explores how you can leverage an AI pair programmer
    for your frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing components from descriptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can ask the AI to create components by describing their functionality and
    appearance; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a React component called TodoList that takes a list of to-do items and
    displays them. Each item should show its title and a checkbox to mark it complete.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The AI should produce the code as a functional component, with props and state
    as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Vue component for a login form with inputs for username and password,
    and emit an event with the form data on submit.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI will likely output the `<template>`, `<script>`, and `<style>` sections
    accordingly. You, as the developer, skip writing boilerplate and directly get
    the structure you need. It’s then easy to tweak if needed. Often the AI will even
    include basic validation or state handling, if your prompt implies that they’re
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to ensure consistency at this stage. If you generate multiple
    components in isolation, you might need to adjust them to work together. For instance,
    if the `TodoList` expects items as a certain prop shape, make sure any component
    that uses `TodoList` provides that. You can either generate components in one
    prompt (so the AI is aware of everything) or simply wire them up yourself and
    ask the AI to fix any mismatches.
  prefs: []
  type: TYPE_NORMAL
- en: Styling and layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSS and styling can be tedious. Describe the look you want and let the AI handle
    the CSS details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Style the to-do list component: use a flex column for the list, add some spacing,
    and change the text color of completed items to gray and crossed out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the login form component, center it on the page and make the input fields
    larger with rounded borders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assistant can output CSS-in-JS, plain CSS, or inline styles, depending on
    context. If you’re using a framework like Tailwind CSS, you could even ask it
    to output the appropriate classes (though keep in mind that not all models know
    Tailwind thoroughly).
  prefs: []
  type: TYPE_NORMAL
- en: 'The point is: you can iterate on design without manually fiddling with CSS
    values. This keeps your focus at a higher level of abstraction—specifying *what
    looks good* rather than writing every `margin` and `color`.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating APIs and state management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Web frontends often need to fetch data from backends and manage state with
    something like Redux, context, or simple component state. AI can help write these
    integration pieces; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Add code to fetch the to-do list from /api/to-dos when the `TodoList` component
    mounts, and store it in state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a function in the `TodoList` that, when a checkbox is toggled, sends
    a `POST` request to */api/to-dos/{id}/complete* and then updates the state accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AI can generate the `useEffect` hook in React to do the fetch or the `mounted()`
    hook in Vue. It can also stub out the HTTP calls (using `fetch` or Axios, etc.).
    You’ll want to confirm that the API endpoints and payloads match what your backend
    expects (if you’ve built the backend or have a spec for it).
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t built the backend yet, you might simultaneously be using the
    AI to create it—we’ll get to that soon. But you can work on front and back in
    parallel with AI assistance, because each can be specified and generated relatively
    independently, as long as you keep track of the interface between them.
  prefs: []
  type: TYPE_NORMAL
- en: Handling complexity with AI guidance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your frontend has complex logic, such as dynamic form validation rules,
    conditional rendering, or intricate user interactions, you can implement these
    step-by-step with AI. A good practice is to break the problem down:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a feature: when the user checks the “complete” box on a to-do, fade out
    that list item (CSS transition), then remove it from the list after 1 second.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The AI might produce the code to add a CSS class on check and use a timeout
    to remove the item, including the necessary CSS for fading out:'
  prefs: []
  type: TYPE_NORMAL
- en: The form has an optional field for ‘notes’. Only show the notes text area if
    an ‘Add notes’ checkbox is checked.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI can modify the component state and JSX to conditionally render the notes
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these can be an iterative prompt. Essentially, you describe the UX behavior
    and AI writes the code. Always test after each addition to ensure it behaves as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: Framework-specific tips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Different frameworks have different idioms:'
  prefs: []
  type: TYPE_NORMAL
- en: In React, the AI might use hooks (like `useState`, `useEffect`). Double-check
    that it’s following best practices (for instance, that the dependencies array
    in `use​Ef⁠fect` is correct).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Vue, the AI might output Options API style or Composition API style depending
    on what it has seen. If you prefer one, you should specify that (for instance,
    “Use Vue 3 Composition API”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Angular, the AI can generate components, but Angular has a steeper learning
    curve. The AI might be able to produce a template, a TypeScript class, and basic
    service injection on request, but you’ll likely need to do more manual work or
    use Angular CLI for structure, then ask AI to fill in specific parts (like form
    validation logic).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend/API Development Patterns with AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s turn to the backend. Using AI to build the server side of a web application
    follows a similar paradigm: you describe the endpoints, data models, and logic
    you want, and the AI produces code. Common backend components include route handlers,
    business logic, database interactions, and validations. AI can help with all of
    these.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing API endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose you’re building a RESTful API for your to-do list app. You might have
    endpoints like `GET /to-dos`, `POST /to-dos`, `PUT /to-dos/:id`, `DELETE /to-dos/:id`.
     You can go endpoint by endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Express app, add a `GET /api/to-dos` route that returns the list of to-dos
    (just use an array stored in memory for now).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `POST /api/to-dos` route that accepts a JSON body and adds a new to-do
    to the list. Return the new to-do with an ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The AI will write the Express route handlers accordingly, likely using something
    like `app.get(''/api/to-dos'', ...)`. If you’ve indicated that you’re using Express
    with JSON, it might include the necessary middleware if it’s not already present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As your backend grows, you can ask the AI to refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactor the Express routes into a separate router module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It might split the routes out into a separate file, which is a good practice
    for maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Database integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might use in-memory data for a prototype, but for a more complete application,
    you’ll want a database. Let’s say you choose MongoDB or PostgreSQL. You can prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integrate MongoDB into the Express app using Mongoose. Create a to-do model
    with fields: title (string), completed (boolean). Modify the GET/POST routes to
    use the database instead of an in-memory array.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI may output the Mongoose model definition and adjust the route handlers
    to query the database (like `Todo.find()` for `GET` and `Todo.create()` for `POST`).
    Similarly, for SQL, you could ask it to set up an [*object-relational mapping*
    (ORM)](https://oreil.ly/AoWDL) like Prisma or Sequelize. Keep in mind you might
    need to provide configuration details (like connection strings). The AI might
    not know your database URI; you’ll have to slot that in. But it will handle the
    generic code.
  prefs: []
  type: TYPE_NORMAL
- en: Business logic and validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your backend has specific rules (for example, that users cannot delete a
    to-do that is marked important or that list titles must be unique), you can encode
    those via AI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add validation to the `POST /api/to-dos` route: reject if the title is empty
    or longer than 100 chars, and return 400 status.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI will include checks and send proper responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add logic: when a to-do is marked complete (say via `PUT /api/to-dos/:id`),
    if all to-dos are complete, log a message ‘All done!’'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can insert that logic in the `PUT` handler.
  prefs: []
  type: TYPE_NORMAL
- en: You describe these requirements in plain terms, and the AI modifies the code
    accordingly. You still need to test that the code does what you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Using frameworks or boilerplates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many web backends use frameworks beyond raw Express (like NestJS for Node or
    Django for Python). AI can work with those, too, though you may have to break
    down more involved tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Django (Python), you might prompt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Django model for to-do with fields X, and corresponding views for list
    and create.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI might output model code and a generic view or DRF (Django REST Framework)
    serializer/viewset if it knows that context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Ruby on Rails, you can get help generating models and controllers. (At that
    point, you might just use Rails scaffolding, but the AI could supplement by adding
    validations or adjusting routes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AI models demonstrate varying levels of proficiency across different programming
    languages and technology stacks, largely determined by the prevalence of those
    technologies in their training data. While models can work with any language they’ve
    encountered during training, their effectiveness varies significantly. Popular
    languages like JavaScript, Python, and Java typically receive stronger support
    due to their abundant representation in open source repositories, documentation,
    and educational materials that form part of the training corpus.
  prefs: []
  type: TYPE_NORMAL
- en: Determining a model’s proficiency with your chosen stack requires practical
    evaluation. Start by testing the model with basic tasks in your target language,
    then progressively increase complexity to gauge its capabilities. Pay attention
    to whether the model generates idiomatic code that follows language-specific conventions,
    recognizes common frameworks and libraries without extensive explanation, and
    suggests appropriate design patterns for that ecosystem. Strong proficiency manifests
    as contextually appropriate suggestions, while weaker support often results in
    generic or outdated code patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Many AI providers publish documentation about their models’ capabilities, though
    these rarely include detailed language-specific benchmarks. The most reliable
    approach involves running small experiments with your actual technology stack.
    For instance, if you’re working with Ruby on Rails, test whether the model understands
    Rails conventions like ActiveRecord patterns or can generate proper RSpec tests.
    Similarly, for newer frameworks or less common languages, expect more variable
    results, and be prepared to provide additional context in your prompts to compensate
    for potential gaps in the model’s training.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrating multistep operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some endpoints might involve multiple steps, like creating an entry in one
    table and then another, or calling an external API. You can outline the sequence
    and let the AI draft it:'
  prefs: []
  type: TYPE_NORMAL
- en: When a new user signs up (`POST /api/users`), create a user record and also
    send a welcome email via SendGrid API.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The AI can write code to save the user (maybe using an object-relational mapper,
    or ORM) and then an HTTP request to SendGrid’s API with appropriate payload. You’d
    fill in actual API keys or tweak content, but most of the boilerplate is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a transaction: when transferring money (`POST /api/transfer`), deduct
    from account A and add to account B, ensure it’s atomic (all-or-nothing).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you’re using an ORM or database that supports transactions, the AI might
    use those features (like an SQL transaction block or an ORM’s transaction method).
    Review such code cautiously for correctness—transaction logic, especially, can
    be tricky. But the AI might know common pitfalls and include checks. For instance,
    when prompted to handle a money transfer endpoint, an AI generated the following
    code structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: async function transferMoney(fromAccountId, toAccountId, amount) {
  prefs: []
  type: TYPE_NORMAL
- en: const session = await db.startSession();
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: await session.startTransaction();
  prefs: []
  type: TYPE_NORMAL
- en: // Deduct from source account
  prefs: []
  type: TYPE_NORMAL
- en: const sourceAccount = await Account.findByIdAndUpdate(
  prefs: []
  type: TYPE_NORMAL
- en: fromAccountId,
  prefs: []
  type: TYPE_NORMAL
- en: '{ $inc: { balance: -amount } },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ session, new: true }'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: if (sourceAccount.balance < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: throw new Error('Insufficient funds');
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Add to destination account
  prefs: []
  type: TYPE_NORMAL
- en: await Account.findByIdAndUpdate(
  prefs: []
  type: TYPE_NORMAL
- en: toAccountId,
  prefs: []
  type: TYPE_NORMAL
- en: '{ $inc: { balance: amount } },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ session }'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: await session.commitTransaction();
  prefs: []
  type: TYPE_NORMAL
- en: 'return { success: true };'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (error) {'
  prefs: []
  type: TYPE_NORMAL
- en: await session.abortTransaction();
  prefs: []
  type: TYPE_NORMAL
- en: throw error;
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: session.endSession();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The AI correctly wrapped both database operations in a transaction, included
    validation for insufficient funds, and properly handled rollback on any error.
    While you’d still need to review edge cases and add appropriate logging, the fundamental
    transaction structure demonstrates understanding of atomic operations.
  prefs: []
  type: TYPE_NORMAL
- en: API documentation and testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When building APIs, you can also have the AI produce documentation. For instance,
    *“Write a brief documentation for the /api/to-dos endpoints.”* It may generate
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is handy for quick reference and also to share with frontend developers
    (if you’re working in a team). Additionally, you can use AI to write tests for
    your API endpoints, using a testing framework like Jest or Mocha for Node, or
    PyTest for a Python API. With a prompt like “Generate tests for the to-dos API
    (one test for listing, one for creating, one for validation error),” the AI will
    output test code that you can run and verify.
  prefs: []
  type: TYPE_NORMAL
- en: Database Design and Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Human knowledge of the business domain is crucial in designing a database schema,
    but AI can assist in translating that design into code (like migration scripts
    or ORM models). Also, if you’re unsure about your schema, you can brainstorm with
    the AI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say your app is expanding beyond to-do lists to become a full
    project-management tool. You need to design several tables: Projects, Tasks, Users,
    and so on. You could ask, “What data models would I need for a simple project
    management app with users, projects, and tasks? Include relationships.” The AI
    might respond with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: User (id, name, email, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project (id, name, owner_id referencing User)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task (id, description, project_id, assigned_to (User), status, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It might not be exactly what you want, but it gives you a starting point. You
    confirm or tweak these design ideas, then implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Using an ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you use an ORM like Prisma, Entity Framework, or SQLAlchemy, you can have
    the AI generate model classes or schema definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Sequelize (for Node), define models for User, Project, Task with associations:
    One User has many Projects, Project belongs to User; Project has many Tasks, Task
    belongs to Project; Task can be assigned to a User (many-to-one).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI would then write JS/TS code to define those Sequelize models and associations,
    which you can then integrate into your codebase. It might also suggest foreign
    keys or cascade rules if it’s familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you aren’t using an ORM and you’re writing raw SQL migrations, you could
    even have the AI draft migration scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Write an SQL script to create tables for users, projects, tasks with appropriate
    foreign keys.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It will output an SQL DDL script, which you can review for correctness and run.
  prefs: []
  type: TYPE_NORMAL
- en: Database Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When integrating the database in your code, you might need queries more complex
    than simple CRUD. Suppose you want to get all projects, along with their tasks
    and the user assigned to each task—that’s a join across Project, Task, User. You
    could prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: Write an SQL query to retrieve projects with their tasks and each task’s assigned
    user name.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI could produce an SQL join query for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or if you’re using an ORM:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Sequelize, fetch all projects with associated tasks and the user for each
    task.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You could expect the code to come with something to load related data, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Checking AI-Generated Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Database operations require careful verification to ensure the AI-generated
    code aligns with your actual schema and maintains data integrity. The AI cannot
    automatically know your specific table names, field names, or relationships unless
    you provide this information explicitly in your prompt. Even when models have
    conversation memory, you should include schema details in each complex database-related
    prompt to ensure accuracy. This explicit approach prevents the common issue of
    AI-generated queries that reference generic field names like `user_id` when your
    schema actually uses `userId` or `customer_ref`.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations often require human oversight. While AI models understand
    basic database concepts like primary keys and joins, they may not automatically
    suggest performance optimizations such as adding indexes on frequently queried
    fields or considering query execution plans. Review generated queries for efficiency,
    particularly for operations that will run frequently or against large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data consistency rules represent another critical area requiring explicit specification.
    When implementing delete operations, clearly define the cascading behavior you
    expect. For example, when deleting a `Project` record, you must decide whether
    the database should automatically delete associated `Task` records through cascading
    deletes or whether your application logic should handle this cleanup. Communicate
    these business rules clearly to the AI:'
  prefs: []
  type: TYPE_NORMAL
- en: When a project is deleted, configure the database to cascade delete all related
    tasks.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Or alternatively:'
  prefs: []
  type: TYPE_NORMAL
- en: When deleting a project, first check for existing tasks and prevent deletion
    if any exist.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI can implement either approach effectively when given clear direction.
    For cascade deletes, it might generate foreign key constraints with `ON DELETE
    CASCADE`.  For application-level handling, it could produce code that queries
    for related records before permitting deletion. The key lies in explicitly stating
    your data-integrity requirements rather than assuming the AI will infer the appropriate
    behavior for your specific domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Stack Integration: Marrying Frontend and Backend'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve built both your frontend and backend with AI help, the next
    challenge is integrating them into a seamless web application. This involves making
    sure that the API endpoints are called correctly from the frontend, the data flows
    properly, and the overall system is coherent.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning Frontend and Backend Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is crucial: the frontend expects to receive data in a certain shape, so
    what the backend sends should match that expectation. If you let AI work on each
    end in isolation, small mismatches can occur (maybe the backend returns `{ success:
    true, data: [...] }`, but the frontend expects to receive the array directly).
    To avoid this, you can explicitly instruct the AI on the response format to use
    when coding both sides. Alternately, once both are done, test an end-to-end call:
    for instance, open the web app and see if the list loads. If it doesn’t, check
    the browser console against the server logs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I often use the AI to adjust one side to match the other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the backend returns slightly different JSON key names than what the frontend
    expects and you notice a bug, you can say to the AI (on either side):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the code to use ‘tasks’ (plural) instead of ‘taskList’ (singular) in
    the JSON.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the frontend is sending form data as form-encoded but the backend expects
    JSON, you can ask the AI to convert that, maybe by using `JSON.stringify` on the
    frontend or adding `body-parser` on the backend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-Time Collaboration with AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AI-augmented IDEs that hold the context of the whole project, like Cline or
    Cursor, can be especially helpful during this integration phase. You could open
    the frontend and backend files side by side in your IDE-based tool and prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the frontend fetch from /api/to-dos matches the Express route’s
    expected request/response. Fix any discrepancies.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI might then harmonize the content (like adding await response.json() in
    the frontend if it was missing or adjusting the JSON structure).
  prefs: []
  type: TYPE_NORMAL
- en: State management and sync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a full stack app, consider implementing things like loading states and error
    handling on the frontend for failed API calls for a professional result. You might
    use prompts like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add loading indicators: when the React component is fetching tasks, show a
    ‘Loading...’ text until data is loaded.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Handle errors: if the API call fails (non-200 response), show an error message
    on the UI.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It will add the `isLoading` state and conditional rendering or implement a try/catch
    around `fetch` to catch errors and display a message. This kind of polish makes
    your app *feel* robust.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets and advanced integrations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your app requires real-time updates (like using WebSockets or SSE), you
    might prompt something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a WebSocket using Socket.io. When a new task is created on the server,
    broadcast it to all connected clients. Modify the frontend to listen for new tasks
    and add them to the list in real time.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is complex, but an AI might generate the server-side Socket.io setup (like
    adding `io.on('connection', ...)` and emitting an event upon creation of a new
    task), as well as client-side code to connect and listen for that event. You would
    need to integrate this carefully, but it’s quite astonishing that these descriptions
    can lead to working real-time code. If it doesn’t work perfectly off the bat,
    iterative prompting and testing can get it there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: full stack flow with AI'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To illustrate, let’s imagine you’re building a simple contact-manager web app:'
  prefs: []
  type: TYPE_NORMAL
- en: You scaffold a React frontend and a Node/Express backend, as you did earlier
    in the chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, for the frontend, prompt for a `ContactList` and a `ContactForm` component.
    Then prompt to add API calls:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In ContactList, fetch contacts from */api/contacts* on mount.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: In ContactForm, on submit, send a `POST` to */api/contacts* with the form data,
    then update the list of contacts on success.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the backend, you may want to use an in-memory array or integrate a database
    first. Then prompt for Express routes `GET /api/contacts` (to return a list) and
    `POST /api/contacts` (to add a contact to the database or memory).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try adding a contact via the UI. If it shows up in the list, great. If not,
    debug. Maybe the `POST` route didn’t return the new contact properly or the form
    code didn’t refresh the list. Identify the gap and prompt the AI to fix it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After adding a contact, the backend should return the new contact object in
    the response, and the frontend should append it to the list without requiring
    a full reload.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This might lead the AI to adjust the backend response and frontend state logic
    to push the new contact (maybe using React state update).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement edit and delete functions similarly, each time letting AI handle the
    routine parts and focusing your input on *what the feature should do*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing all this manually could easily amount to a week or two of work for a junior
    dev but could be done in a day or two with an AI codeveloper, given that a lot
    of template code and wiring is automated.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing AI-human collaboration in full stack development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working through an entire stack, it’s useful to establish a productive
    rhythm with your AI assistant. Here are some strategies to optimize your collaboration:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the AI for boilerplate; write any custom logic yourself
  prefs: []
  type: TYPE_NORMAL
- en: Identify which parts of the code are mundane and which are the unique core logic.
    Let the AI generate a CRUD API or a standard component—but if there’s a particularly
    tricky piece of logic, maybe a proprietary algorithm or a specific business rule
    that is easier to implement directly, do that part manually, then ask the AI to
    review or test it. Think of it as delegating repetitive tasks to the AI, while
    you handle the novel ones.
  prefs: []
  type: TYPE_NORMAL
- en: Use AI to tackle your to-do list one item at a time
  prefs: []
  type: TYPE_NORMAL
- en: 'As you develop, keep track of tasks (like features to add and bugs to fix).
    Then explain each task to the AI, one by one, and let it propose a solution. For
    example, let’s say you have a note that reads “Implement password hashing on user
    registration.” Try a prompt like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Add password hashing using bcrypt in the `POST /api/register` route before saving
    the user.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This targeted, systematic approach helps ensure you don’t forget anything.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt AI to improve code quality as you go
  prefs: []
  type: TYPE_NORMAL
- en: After achieving functionality, you might prompt, “Refactor this code for better
    readability” or “Optimize this function.” The AI can often make the code cleaner
    or suggest performance improvements, like an assistant doing a second pass for
    polish under your supervision. Be sure to verify that any changes still pass your
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Use AI for cross-checking
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re uncertain about your design approach, ask the AI:'
  prefs: []
  type: TYPE_NORMAL
- en: Is using an array to store contacts in memory fine or should I use a database?
    What are the pros and cons?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While you likely know the answer (use a database for persistence), it’s like
    bouncing ideas off a colleague. Sometimes the AI might mention a consideration
    you hadn’t thought of:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple server instances, an in-memory store won’t sync across
    them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use AI to coordinate with your team
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re working in a team, not everyone may be using the AI directly. In
    that case, make sure to ask the AI to document what you did. Also, it’s good to
    communicate your approach to the team: “I used an AI to generate these controllers
    quickly. I’ve checked them, but keep an eye out for any unconventional patterns.”
    Encourage a code-review culture in which everyone reviews AI-written code just
    like they would any other code to catch any quirks.'
  prefs: []
  type: TYPE_NORMAL
- en: Real-world teams that adopt AI (like those at [Snyk](https://oreil.ly/8Dmn7))
    report that it can boost productivity, but they also stress keeping a human in
    the loop for validation. In one [2024 survey by GitHub](https://oreil.ly/oivAx),
    97% of developers reported using AI coding tools at work in some capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and Validation for AI-Generated Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After building your web app with AI help, test thoroughly to ensure everything
    works as intended and to catch issues that you or the AI might have introduced.
    Here’s how you can approach testing in this AI-assisted context:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs: []
  type: TYPE_NORMAL
- en: 'For backend logic, write unit tests for critical functions (like a function
    that calculates something or validates input). If the AI wrote the function, writing
    a test for it can reveal any hidden bugs. You can even have the AI generate these
    tests, as mentioned. Be cautious, though: AI-generated tests are sometimes trivial
    or assume an implementation, so you may need to guide it to test edge cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Write tests for the password strength function, including edge cases like empty
    password, very long password, password with special chars, etc.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Integration tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the API endpoints with something like Supertest (for Node) or direct HTTP
    calls. Check that each endpoint returns the expected results. AI can help you
    scaffold these:'
  prefs: []
  type: TYPE_NORMAL
- en: Write integration tests for the /api/to-dos endpoints using Jest and Supertest.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It might produce tests that start the app, hit the endpoints, and assert on
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Web UI testing can be done with tools like Jest (for component logic) and Cypress
    or Playwright for end-to-end UI tests. You can certainly ask AI to generate a
    Cypress test scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a Cypress test that loads the app, adds a new to-do via the form, and
    checks that it appears in the list.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You’ll get a test script, which you can run. This is quite powerful—you quickly
    get end-to-end test coverage by leveraging the AI to script user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Manual tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever automated tests you run, always do some manual exploratory testing,
    too. Click around the web app yourself (or have QA do it, if you’re working in
    a team). The AI might not anticipate every real-world scenario: for example, maybe
    using the browser Back button breaks some state, or a particular sequence of actions
    causes a glitch. As you find bugs, fix them or ask the AI to help fix them. Manual
    testing is also important for UI/UX judgment—does the app feel good to use? Are
    there any awkward flows? The AI won’t know how to judge these subjective UX issues,
    so human feedback is key.'
  prefs: []
  type: TYPE_NORMAL
- en: Code review
  prefs: []
  type: TYPE_NORMAL
- en: If you’re working with others, have them review the AI-generated code. Fresh
    eyes can catch things you might have glossed over—they might spot a security oversight
    or simply suggest a more idiomatic way to write something. Teams using AI often
    maintain normal code-review processes, just with [more focus](https://oreil.ly/O5Dbj)
    on reviewing for subtle bugs or security issues that an AI might inadvertently
    introduce.
  prefs: []
  type: TYPE_NORMAL
- en: Security audit
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)
    will dive into security, but even at development time, it’s worth scanning your
    code for known vulnerability patterns.  There are automated tools you can run,
    like linters and [Static Application Security Testing](https://oreil.ly/T531z)
    (SAST) tools, or you can prompt the AI:'
  prefs: []
  type: TYPE_NORMAL
- en: Review the Express app code and list any potential security vulnerabilities
    or best practice violations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI might flag some surprising things, like “You are not sanitizing user
    input here” or “You should set up CORS properly.” Use that as a checklist for
    hardening the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting effect of using AI is that you may write tests you wouldn’t
    have otherwise, because the AI makes it so easy to create them. This can actually
    lead to *more* robust code in the end. If you adopt a practice of generating tests
    immediately after generating features (essentially AI-assisted test-driven development,
    or at least post hoc tests), you ensure that the rapid development doesn’t compromise
    quality. Think of it like this: since the AI saved you time writing code, invest
    some of that saved time into writing and running tests.'
  prefs: []
  type: TYPE_NORMAL
- en: AI can suggest insecure code if the user isn’t careful. For example, earlier
    AI versions might generate SQL queries that are vulnerable to injection attacks
    if not specifically prompted to avoid that. By testing and reviewing, you catch
    these issues. [One study](https://oreil.ly/U3b8H) found that developers using
    AI assistance tended to be overconfident in their code’s security, even when it
    was worse than it would’ve been if written manually.
  prefs: []
  type: TYPE_NORMAL
- en: Never skip validation just because an AI wrote the code. Assume it can have
    bugs, just like any human-written code.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of Successful AI-Built Web Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s highlight a couple of examples (composites drawn from various reports)
    where AI assistance played a significant role in delivering real web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ecommerce site by a solo developer
  prefs: []
  type: TYPE_NORMAL
- en: A solo developer wanted to create a small ecommerce web app to sell custom T-shirts
    but had limited time. He used GPT, through an IDE extension, to build the entire
    stack. He prompted the AI to generate a React frontend with product listings,
    a cart, and checkout pages, as well as a Node.js backend with endpoints for products
    and orders. He used Stripe for payments, integrating it by asking the AI to help
    with Stripe’s API. After working on it in the evenings for two weeks, he had a
    functioning site.
  prefs: []
  type: TYPE_NORMAL
- en: This developer reported that AI had done probably 70% of the coding, especially
    the repetitive UI parts and form handling, while he focused on configuring Stripe
    correctly and fine-tuning the UI for branding. In the end, customers could browse
    products, add them to the cart, and purchase them—all in a system built largely
    via vibe coding. It also highlights that external service integration (like Stripe)
    is feasible with AI guidance, as long as documentation is available for the model
    to draw from or you provide it.
  prefs: []
  type: TYPE_NORMAL
- en: Internal company dashboard
  prefs: []
  type: TYPE_NORMAL
- en: A product manager with some coding skills used an AI pair programmer to create
    an internal analytics dashboard for her team. Normally, she would have had to
    wait for engineering resources, but using a tool like Replit’s Ghostwriter or
    GitHub Copilot in a web project, she managed to build a basic web app herself.
    The AI helped with setting up a simple Flask backend to query their database (with
    safe read-only credentials) and a Vue.js frontend to display graphs (using a charting
    library). She described what each chart should show (“total sign-ups over time,”
    “active users by region”), and the AI wrote the SQL queries and chart code.
  prefs: []
  type: TYPE_NORMAL
- en: The whole process took a couple of weeks of tinkering and testing, but eventually
    she delivered a working dashboard. The code quality wasn’t enterprise grade, but
    since it was internal, it was fine. More importantly, she empowered her team with
    a tool in a fraction of the time. This example illustrates how AI tools can enable
    nonspecialist programmers to produce useful web apps, unblocking tasks that might
    otherwise sit in a backlog. It’s an example of the “unbundling of the programmer”
    that I’ll discuss in [Chapter 10](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844),
    which is all about how individuals can create personal or team-specific software
    more easily now.
  prefs: []
  type: TYPE_NORMAL
- en: Startup minimum viable product (MVP)
  prefs: []
  type: TYPE_NORMAL
- en: 'A small startup (just two cofounders: one business, one technical) needed an
    MVP web application to show to investors. The technical cofounder used vibe coding
    extensively to build an MVP in record time. Using an AI assistant, he scaffolded
    a modern web app using Next.js for the SSR React frontend and a simple Node API.
    He leveraged AI to implement features like social login (the AI wrote the OAuth
    flows), image uploads (the AI integrated with a cloud-storage API), and an AI-based
    feature within the product itself. They even used the AI to help integrate an
    NLP model from an API. In a few months, one developer achieved what might normally
    take a small team four to six months. The result was a somewhat hacky but functioning
    product that they could demo, and they could even onboard beta users onto the
    platform.'
  prefs: []
  type: TYPE_NORMAL
- en: When the cofounders later hired more devs to polish the product, the new devs
    found the AI-written code to be mostly understandable, though they did refactor
    significant portions for scalability. This underlines that AI can get you to the
    first stage quickly, but you might need to invest in quality as you move to the
    next stages.
  prefs: []
  type: TYPE_NORMAL
- en: These stories, while anecdotal, align with emerging patterns in the industry.
    In web development specifically, which often involves wiring many components together,
    the productivity boost is very tangible. [Microsoft](https://oreil.ly/QLunu) and
    [others](https://oreil.ly/BNVrB) reported studies finding that developers with
    AI could complete tasks significantly faster than those without.
  prefs: []
  type: TYPE_NORMAL
- en: However, there have also been cautionary tales. For instance, a developer might
    deploy an AI-generated web app with a security flaw because they don’t fully understand
    the code. This risk reinforces why testing and review are crucial.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, building web applications with AI assistance is becoming a mainstream
    approach. It doesn’t remove the need for skilled developers; rather, it augments
    them. The developers still plan the architecture, ensure correctness, and handle
    the complex or novel aspects of the code, while the AI handles the repetitive
    boilerplate code that glues everything together. The end-to-end workflow we walked
    through—from scaffolding to frontend to backend to testing—demonstrates that practically
    every step of web development can be accelerated with AI, as long as you apply
    your human judgment and expertise along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ve seen how vibe coding extends to full-scale web application
    development. By treating the AI as an always available pair programmer, you can
    tackle frontend and backend tasks in parallel, generate components and APIs from
    natural descriptions, and iteratively refine a prototype application to production
    quality. The keys to success include clearly communicating your intent (so the
    AI knows what you want at each step), carefully verifying (to catch issues in
    the AI output), and leveraging the AI not just to generate code but for things
    like brainstorming schema designs and writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also explored how a developer can effectively be a full stack engineer,
    augmented by AI bridging gaps in their knowledge by suggesting code in areas they
    are less familiar with. This greatly reduces development time for common features
    and democratizes development in some ways, enabling people to create custom web
    solutions without large teams (a theme I’ll revisit in [Chapter 10](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844)).
  prefs: []
  type: TYPE_NORMAL
- en: AI doesn’t replace understanding the requirements or ensuring quality; it accelerates
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your web application is up and running, the next concern is making
    sure it is secure, reliable, and maintainable. [Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)
    dives into the challenges of security and reliability in AI-generated codebases,
    identifying common vulnerabilities that might slip in, how to audit for and fix
    them, and best practices (like the ones we’ve started applying here with tests
    and reviews) to ensure that moving fast with AI doesn’t break things. Essentially,
    we’ll shift from building to hardening—making sure your vibe-coded software stands
    up to real-world conditions and threats.
  prefs: []
  type: TYPE_NORMAL
