<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. A Platform Engineering Approach to Modern DevOps"><div class="chapter" id="chapter_10_a_platform_engineering_approach_to_modern_devops_1749354009763489">
      <h1><span class="label">Chapter 10. </span>A Platform Engineering Approach <span class="keep-together">to Modern DevOps</span></h1>
      <p>The previous chapters have painted a picture of the many systems and practices that characterize modern software delivery. This long journey has illustrated the daunting complexity that modern software teams must contend with<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" id="xi_platformengineering103235"/>. In addition, modern software development has tended to “shift left” many concerns—security<a contenteditable="false" data-type="indexterm" data-primary="shift-left security" data-secondary="impact on software development" id="id1102"/>, observability, and infrastructure management work—that were previously handled by operations teams. If even the most experienced and well-resourced development teams are strained by this complexity and added responsibility, how are we to manage? </p>
      <p>Platform engineering has emerged to help modern software organizations answer this very question.<em> </em>It is the discipline of designing, building, and maintaining internal developer platforms that provide integrated tooling and infrastructure for software delivery. While previous chapters explored the individual components of modern software delivery, we’ll see in this chapter how platform engineering pulls these capabilities together into a cohesive platform that serves development teams. </p>
      <p>In this chapter, we’ll explore how organizations can build and run effective platform engineering teams. We’ll look at how these teams fit into organizations and what role they play in enabling rapid, secure delivery. Then we’ll dig into the practical aspects of building and operating high-performing platform teams—everything from team structure to day-to-day operations. We’ll explore concrete ways to measure developer platform effectiveness, ensuring our investments deliver real value. We’ll discuss the balance between standardization and team autonomy—how to provide guardrails without stifling innovation. Finally, we’ll look at strategies for sustainable platform evolution, ensuring our platform grows alongside our organization’s needs.</p>
      <section data-type="sect1" data-pdf-bookmark="Why Platform Engineering?"><div class="sect1" id="chapter_10_why_platform_engineering_1749354009763736">
        <h1>Why Platform Engineering?</h1>
        <p>We understand that traditional approaches to developer tooling often require development teams to navigate a complex landscape of tools and practices on their own. Platform engineering treats internal developer platforms as a strategic product, with development teams as valued customers. This shift comes at a critical time, as the rapid evolution of software practices has created a cognitive load crisis for developers, who must juggle an expanding set of responsibilities. Platform engineering addresses this crisis, and we’ll dig into the business case for it and how it reinforces a collaborative DevOps culture.</p>
        <section data-type="sect2" data-pdf-bookmark="The Developer Cognitive Load Crisis "><div class="sect2" id="chapter_10_the_developer_cognitive_load_crisis_1749354009763810">
          <h2>The Developer Cognitive Load Crisis </h2>
          <p>Each new tool that we add to our toolchain<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="developer cognitive load crisis" id="id1103"/> and each new practice we add to our delivery process promises to accelerate delivery or to improve software quality. The cumulative effect, however, can create an unsustainable cognitive burden on our development teams. Consider that developers must juggle SCM, CI/CD pipeline configuration, IaC templates, security scanning tools, deployment strategies, monitoring systems, and a host of other specialized tools. Each comes with its own complexities, best practices, and failure modes.</p>
          <p>This cognitive burden is particularly acute as teams adopt AI-powered tools<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="and cognitive burden increase for developers" data-secondary-sortas="cognitive burden increase for developers" id="id1104"/> across the development lifecycle. While these tools promise to accelerate delivery, they often require significant expertise to implement effectively. Platform engineering can encapsulate this complexity, making AI capabilities accessible through standardized interfaces and templates, without requiring every developer to become an AI expert.</p>
          <p>The data tells a concerning story: a recent <a href="https://oreil.ly/TyQ9U">Harness survey</a> of engineering leaders found that 78% of developers spend at least 30% of their time on manual, repetitive tasks rather than writing code. Hours get consumed by operational responsibilities and tool management—activities that, while necessary, pull developers away from their most valuable work: creating innovative solutions to business problems. As concerning as the lost time itself is the fragmentation of focus that creates a cognitive burden that directly impacts delivery quality and speed. Legacy processes often compound the challenge, generating low-value work that prevents deep, creative thinking.</p>
          <p>The cost of context switching<a contenteditable="false" data-type="indexterm" data-primary="context switching cost for development teams" id="id1105"/> is taxing. When developers constantly pivot between writing application logic, debugging pipelines, investigating security alerts, and troubleshooting production issues, each transition extracts a mental cost. This cost doesn’t just slow feature delivery—it fundamentally undermines the conditions that enable developer excellence. Deep, uninterrupted focus time drives software quality and innovation. When developers constantly jump between coding and operational tasks, both technical excellence and creative problem-solving suffer, leading to accumulated technical debt.</p>
          <p>This issue impacts more than productivity metrics—it directly affects morale, retention, and the ability to attract top talent. The best engineering organizations understand that a great developer experience—where engineers can spend more time solving problems and less time wrestling with inefficiencies—not only leads to better software but also fosters a culture where top talent thrives and sticks around. A successful platform will address these sources of dissatisfaction, and developers will flock to it. If most developers must be forced to use a platform, there’s likely something wrong with the platform or its rollout.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="From Toolchains to Platform as a Product "><div class="sect2" id="chapter_10_from_toolchains_to_platform_as_a_product_1749354009763866">
          <h2>From Toolchains to Platform as a Product </h2>
          <p>Platform engineers address developer<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="developer platform structures" id="xi_platformengineeringdeveloperplatformstructures101950"/> experience directly by creating an environment where developers<a contenteditable="false" data-type="indexterm" data-primary="developer platform structure" id="xi_developerplatformstructure1019114"/> can be maximally productive. This means designing, building, and maintaining the underlying developer platforms that enable the smooth development, deployment, and operation of applications and services. </p>
          <p>Developer platforms typically address a number of areas, as shown in <a data-type="xref" href="#chapter_10_figure_1_1749354009750918">Figure 10-1</a>. This includes a portal, CI/CD pipelines, and IaC. Automated measures to ensure security, compliance, and cloud cost compliance are woven throughout.</p>
          <figure><div id="chapter_10_figure_1_1749354009750918" class="figure">
            <img src="assets/ansd_1001.png" width="600" height="294"/>
            <h6><span class="label">Figure 10-1. </span>Developer platform capabilities</h6>
          </div></figure>
          <p>Developer platforms can be built in several ways: platform teams may assemble them from various tools, organizations can purchase prepackaged solutions from vendors like GitLab or Harness, or they can use orchestration tools like Humanitec to create a unified layer over existing toolsets. In practice, most implementations combine these approaches rather than following a single clean strategy. Teams usually pick a strategy and make some accommodations for things that are important to the organization but don’t quite fit into the strategy. Being practical problem-solvers, engineers often blend strategies, adapting their chosen approach to accommodate crucial organizational needs, and ultimately they make it work.</p>
          <p>Platforms present paved roads—proven patterns and practices that development teams can follow with confidence. Paved roads often take the form of application or infrastructure templates<a contenteditable="false" data-type="indexterm" data-primary="template pipelines" id="id1106"/>. Consider a standard web application template. Starting from scratch, developers might require several days to manually string together foundational capabilities and set up deployment—tedious and redundant work. A platform-provided template comes preconfigured with essential frameworks already in place. This includes standardized approaches for metrics collection, fault tolerance patterns, security configurations with sensible defaults, and structured logging with request tracing—all integrated within a cohesive framework. Templates can extend beyond application code to include infrastructure definitions and deployment pipeline configurations, forming a comprehensive application foundation.</p>
          <p>In addition, platforms often offer templates that, at the application level, standardize approaches and encapsulate organizational best practices for cross-cutting concerns like authentication, logging, and error handling. The operational layer includes deployment pipelines that incorporate security scanning, load testing, and automated rollback procedures. The infrastructure layer leverages automation to provision resources with appropriate security groups, monitoring configurations, and disaster recovery procedures. </p>
          <p>These capabilities are exposed through self-service portals or interfaces that abstract underlying complexity while maintaining security and compliance guardrails. For instance, a platform might provide an API for provisioning databases that automatically configures backup schedules, encryption, and access controls according to organizational standards.</p>
          <p>The benefit is clear: rather than leaving teams to piece together tools, templates automate this tedious setup and configuration work while embedding best practices, security, and compliance standards. This makes developers more productive—with templated code in place, they can immediately focus on building features. Moreover, when they go to work on another project, whether because they’ve changed teams or because they need to update a dependency, they will be more comfortable and productive due to the familiar environment. Meanwhile, this added consistency reduces risk as it is easier to manage risks across a handful of standard tools and templates than a constellation of unique snowflakes scattered across the organization.</p>
          <p>It’s important to note that the specific templates and automations provided by a platform team will vary significantly from organization to organization. There’s no one-size-fits-all approach. A platform team’s focus must be laser-sharp on addressing the unique needs and use cases of its internal development teams. What works for a large financial institution with stringent compliance requirements will likely look very different from the platform built for a fast-moving startup. The key is for the platform team to deeply understand its “customers”—the development teams—and tailor its offerings to their specific pain points and workflows. Later in this chapter, we dig into the product mindset that platform engineering requires to ensure that the team is a true, developer experience–focused service provider to development teams<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_platformengineeringdeveloperplatformstructures101950" id="id1107"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_developerplatformstructure1019114" id="id1108"/>.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="The Business Case for Platform Engineering "><div class="sect2" id="chapter_10_the_business_case_for_platform_engineering_1749354009763921">
          <h2>The Business Case for Platform Engineering </h2>
          <p>The business case for<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="business case for" id="id1109"/><a contenteditable="false" data-type="indexterm" data-primary="business case for platform engineering" id="id1110"/> platform engineering rests on a simple premise: by streamlining software development and operations, we can realize developer and operations productivity gains that make our teams more efficient and reduce the costs associated with risk. Consider the cost of developer time. If most developers spend roughly 30% of their time on repetitive, non-value-added tasks, for an organization with just 250 developers, this translates to substantial recoverable costs. Across companies we surveyed, developers earned an average of $107,599 annually, amounting to over $32,000 per developer in lost productivity annually. For organizations with 250 developers, this represents an $8 million hidden cost in lost development time.</p>
          <p>Platform engineering provides developer platforms that automate many of these repetitive tasks, recovering lost time. Platform standardization and centralized platform development eliminate efforts duplicated across teams. This enables operations teams to support a larger application portfolio with existing headcount while maintaining consistent security and compliance standards.</p>
          <p>The return on investment (ROI) of platform engineering extends beyond developer productivity. It addresses the business risks that keep teams up at night. Developer platform <em>paved roads</em> reduce the risk and potential cost of security breaches by eliminating security gaps that arise from inconsistent implementations across teams. With standardized deployment processes and monitoring practices, platform teams can reduce both the frequency and the impact of service outages. By embedding proven patterns for high availability and disaster recovery into platform components, organizations maintain business continuity even during incidents. Meanwhile, built-in compliance controls and automated audit trails help organizations avoid costly regulatory violations.</p>
          <p>Platform engineering can also act as a powerful accelerator for broader organizational initiatives, such as cloud migrations or application modernization. By providing a standardized and automated foundation, platform engineering creates repeatable pathways that accelerate timelines while reducing risk. </p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Supporting a Collaborative DevOps Culture"><div class="sect2" id="chapter_10_supporting_a_collaborative_devops_culture_1749354009763974">
          <h2>Supporting a Collaborative DevOps Culture</h2>
          <p>Platform engineering supports collaboration<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="and collaborative DevOps culture" data-secondary-sortas="collaborative DevOps culture" id="id1111"/><a contenteditable="false" data-type="indexterm" data-primary="DevOps" data-secondary="collaborative culture development" id="id1112"/><a contenteditable="false" data-type="indexterm" data-primary="collaborative DevOps culture" id="id1113"/> between development, operations, and security teams, a theme we’ve returned to throughout previous chapters. A unified, self-service platform acts as a collaborative bridge. Instead of siloed responsibilities and potential friction points, platforms bring a more integrated ecosystem where operations and security requirements are addressed directly and automatically in platform paved roads. These paved roads give developers preapproved, secure patterns and automated workflows that inherently incorporate security best practices. </p>
          <p>This is particularly powerful in regulated environments<a contenteditable="false" data-type="indexterm" data-primary="regulatory environments" id="id1114"/>: instead of implementing new regulations for each application team, with the high probability that it won’t be done consistently, the platform team can implement those rules once, at the platform level, ensuring compliance for everyone. Developers can focus on creating business value while automatically adhering to operational and security standards through platform guardrails. The net result is a more streamlined, secure software delivery pipeline.</p>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Creating and Operating Platform Teams"><div class="sect1" id="chapter_10_creating_and_operating_platform_teams_1749354009764026">
        <h1>Creating and Operating Platform Teams</h1>
        <p>Now that we understand the value of platform engineering (the “why”), we turn to implementation (the “how”). In this section, we’ll examine how to establish and operate effective platform engineering teams<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="platform team operations" id="xi_platformengineeringplatformteamoperations1047217"/>. We’ll look at the key characteristics of successful teams, discuss engagement models that keep platform teams closely aligned with development needs, and review operating models that support a scalable, high-performance platform engineering function.</p>
        <section data-type="sect2" data-pdf-bookmark="Critical Characteristics of a Platform Team "><div class="sect2" id="chapter_10_critical_characteristics_of_a_platform_team_1749354009764076">
          <h2>Critical Characteristics of a Platform Team </h2>
          <p>The most successful platform engineering teams bring more than deep technical expertise—they bring product insight and customer empathy. Starting with platform leadership<a contenteditable="false" data-type="indexterm" data-primary="leadership, characteristics of platform" id="id1115"/>: leaders need the technical depth to understand the challenges developers face across the organization, while also possessing the strategic vision to align the platform with business goals. They must maintain credibility with both engineers and business stakeholders, bridging the gap between the technical and the strategic. Ideal leaders have a strong background in these three domains—development, operations, and security. This focus will help guide the team and organization in the right direction.</p>
          <p>The platform team itself should be a microcosm of your development organization, encompassing expertise in development, security, and operations. This cross-functional knowledge allows the team to create integrated solutions that address the full spectrum of developer needs. The team should include engineers with experience in key bottleneck areas like security and compliance, in addition to engineers versed in development, enterprise architecture, and existing tools. As AI becomes a fundamental part of software delivery, platform teams benefit from including at least one member with expertise in AI/ML operations<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="as essential for platform team" data-secondary-sortas="essential for platform team" id="id1116"/>. This role bridges the gap between data science and software delivery, helping the team effectively integrate and manage AI-powered tools within the platform. They ensure AI components remain reliable, explainable, and aligned with organizational governance requirements.</p>
          <p>Remember, the platform is a product, and developers are its customers. To ensure the platform evolves based on developer needs rather than platform team preferences alone, the team needs strong product management<a contenteditable="false" data-type="indexterm" data-primary="product management, platform teams" id="id1117"/> capabilities. This includes skills in user research, road map development, and adoption measurement. By understanding developer needs and measuring platform effectiveness, the team can ensure the platform remains a valuable asset for the entire organization.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Engagement Models That Work"><div class="sect2" id="chapter_10_engagement_models_that_work_1749354009764125">
          <h2>Engagement Models That Work</h2>
          <p>One of the first considerations<a contenteditable="false" data-type="indexterm" data-primary="engagement models for platform teams" id="xi_engagementmodelsforplatformteams105645"/> when starting a platform practice is determining how the team will engage with the larger organization. A successful platform team requires an engagement model that provides a deep understanding of developer needs and promotes effective collaboration across the organization. Platform teams must also engage with their customers—the development teams—in a thoughtful and structured manner.</p>
          <p>An “immersion program” is an example of an engagement model<a contenteditable="false" data-type="indexterm" data-primary="immersion engagement, platform engineering" id="id1118"/> that works well in some organizations. With this model, platform engineers temporarily embed themselves within individual development teams. The hands-on approach gives the teams insights into the daily challenges faced by developers; it fosters empathy and creates a deeper understanding of their needs. By working side-by-side with developers, platform engineers can identify pain points, bottlenecks, and opportunities for improvement. This ensures that the platform evolves in tandem with the unique needs of specific teams while still maintaining a central governance structure. This model can work particularly well when you are just getting started with platform engineering, as it helps form a deep understanding of team challenges and constraints.</p>
          <p>Another option is to establish a Center of Excellence<a contenteditable="false" data-type="indexterm" data-primary="Center of Excellence model for platform teams" id="id1119"/>. This type of platform team operates as a distinct, cross-functional group serving all development teams. They provide feedback on platform features, advocate for adoption, and assist with the integration of platform capabilities into development workflows. Collaboration across the organization ensures that the platform remains aligned with the evolving needs of the development community. This model works well for larger organizations with diverse projects, as it provides clear ownership and centralized best practices while reducing the duplication of effort.</p>
          <p>Alternatively, hybrid models, where platform engineers serve both as centralized experts and as embedded resources, offer the best of both worlds—consistency in tooling and processes coupled with intimate knowledge of specific product <span class="keep-together">challenges.</span> </p>
          <p>Choosing the right model depends on your organization’s size, complexity, and strategic priorities. The stage of your platform maturity can also be a factor. As the platform matures and the user base grows, the engagement model needs to scale. While high-touch support might be feasible for early adopters, a more scalable approach is necessary for widespread adoption. Self-service onboarding, enabled by comprehensive documentation and intuitive tools, allows teams to integrate with the platform seamlessly and autonomously. </p>
          <p>Lastly, while each of these models provides a structural foundation for platform success, they must be reinforced by robust mechanisms to measure and validate platform effectiveness. Later in this chapter we’ll look at ensuring that systematic feedback loops are in place to measure developer satisfaction and platform adoption<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_engagementmodelsforplatformteams105645" id="id1120"/>.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Effective Operating Models"><div class="sect2" id="chapter_10_effective_operating_models_1749354009764175">
          <h2>Effective Operating Models</h2>
          <p>While the engagement model guides how the platform team interacts with development teams, the operating model<a contenteditable="false" data-type="indexterm" data-primary="operating models, platform team" id="id1121"/> defines the platform team’s internal processes and principles. The operating model is crucial for serving development teams while maintaining high operational standards. It dictates how the team functions, allocates resources, and interacts with the broader organization. An effective model strikes a balance between empowerment and control. </p>
          <p>A strong operating model prioritizes self-service capabilities that empower development teams to move quickly and independently. The platform team maintains appropriate guardrails through automation and template offerings that encapsulate best practices for the organization. </p>
          <p>Clear, up-to-date, and readily accessible documentation is another feature of an effective operating model. Documentation should empower developers to understand and adopt platform capabilities without requiring hand-holding from the platform team.</p>
          <p>Finally, your operating model should be structured to handle both tactical and strategic needs—implementing SLAs for critical issues while protecting dedicated time for platform improvements and addressing developer feedback. Techniques like support rotations and engineering sprints can help teams manage this balance<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_platformengineeringplatformteamoperations1047217" id="id1122"/>.</p>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Defining Your Platform Strategy"><div class="sect1" id="chapter_10_defining_your_platform_strategy_1749354009764231">
        <h1>Defining Your Platform Strategy</h1>
        <p>A coherent platform strategy<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="strategy development" id="xi_platformengineeringstrategydevelopment107340"/> is squarely focused on your developer needs. It takes into account the constraints of your organization and the objectives most important to your business. In this section we’ll discuss how your strategy should clearly articulate a set of principles that will guide decision making. We’ll explore how a deep understanding of your platform customers should drive the initial scope. Lastly, we’ll discuss the challenges you may encounter in balancing standardization through the platform with flexibility in allowing teams to diverge when needed.</p>
        <section data-type="sect2" data-pdf-bookmark="Setting Platform Principles "><div class="sect2" id="chapter_10_setting_platform_principles_1749354009764287">
          <h2>Setting Platform Principles </h2>
          <p>Platform strategy starts with clear principles<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="principles for strategy" id="xi_platformengineeringprinciplesforstrategy107660"/> that articulate how your platform team will approach solutions. When the team is getting pulled in many different directions and is asked to address a growing set of concerns, clear principles act as a compass. They guide decision making and provide a framework for evaluating trade-offs, resolving conflicts, and maintaining focus amid the complexities of platform development. Once you have defined your principles, it’s important to share them throughout your organization to get the alignment that will help the team be successful.</p>
          <p>The following principles are ones that should underpin any platform strategy: </p>
          <dl>
            <dt>Developer experience and effectiveness is the primary driver of platform design.</dt>
            <dd>
              <p><strong> </strong>Every capability should aim to reduce cognitive load and streamline development workflows, rather than adding complexity. </p>
            </dd>
            <dt>Security and compliance requirements are embedded seamlessly into the platform.</dt>
            <dd>
              <p>This makes it easier for developers to “do things right” than to bypass controls. The approach fosters a secure development environment without hindering <span class="keep-together">productivity.</span></p>
            </dd>
            <dt>Platform evolution is driven by measurable developer needs and demonstrable business outcomes.</dt>
            <dd>
              <p>Platform evolution is not driven only by the technical preferences of the platform team or the strong opinions of any given developer team. The platform team will solicit feedback from developers, track platform usage, and measure the impact on key metrics like deployment frequency and lead time. </p>
            </dd>
          </dl>
          <p>A key strategic decision is whether adoption<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="adoption considerations" id="id1123"/> should be mandatory or optional. Mandatory platforms can drive consistency and standardization, but risk reducing the incentive to deliver a great developer experience. Optional adoption, on the other hand, forces the platform team to earn trust and prove value, leading to more user-focused, innovative solutions. While this approach can create fragmentation, it fosters excellence in practice, not just in theory. Some organizations begin with optional adoption and introduce mandates later to consolidate gains and bring late adopters on board.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Platform Antiprinciples and Resolving Conflicts"><div class="sect2" id="chapter_10_platform_anti_principles_and_resolving_conflicts_1749354009764338">
          <h2>Platform Antiprinciples and Resolving Conflicts</h2>
          <p>Just as important as what your platform strategy should embrace is what it should avoid. Common antiprinciples that undermine platform success include:</p>
          <dl>
            <dt>Perfectionism over progress</dt>
            <dd>
              <p>Delaying platform releases until they’re “perfect” often means developers create their own solutions in the meantime, making eventual adoption harder.</p>
            </dd>
            <dt>Technology-driven development</dt>
            <dd>
              <p>Building platform capabilities because they’re technically interesting or cool rather than because they solve real developer problems.</p>
            </dd>
            <dt>Mandatory adoption without demonstrating value</dt>
            <dd>
              <p>Forcing teams to use the platform before proving its value creates resistance and potentially damages the platform’s reputation long term.</p>
            </dd>
          </dl>
          <p>When principles come into tension with each other, as they inevitably will, having a clear prioritization framework helps. For example, when security requirements conflict with developer experience, most organizations need a structured approach to resolve this tension. Successful platform teams typically prioritize:</p>
          <ol>
            <li>
              <p>Security and compliance requirements that carry regulatory risk</p>
            </li>
            <li>
              <p>Developer experience for high-frequency activities</p>
            </li>
            <li>
              <p>Standardization for operational consistency</p>
            </li>
            <li>
              <p>Innovation and flexibility</p>
            </li>
          </ol>
          <p>This hierarchy helps teams make consistent decisions when principles compete. When facing such conflicts, platform teams should document the tension, the decision-making process, and the eventual resolution to create precedent for future decisions.</p>
          <p>Allowing a model like this to support a choice that results in poor developer experience in the name of security is dangerous. You have planted a seed for circumventing or manipulating the platform. Treating such a decision as a necessary stopgap, and then working to develop a more efficient and pleasant way of satisfying the governance control, is a key to long-term success<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_platformengineeringprinciplesforstrategy107660" id="id1124"/>.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Understanding Your Platform Audience "><div class="sect2" id="chapter_10_understanding_your_platform_audience_1749354009764388">
          <h2>Understanding Your Platform Audience </h2>
          <p>Going back to our first principle: developer experience and effectiveness<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="audience consideration" id="id1125"/> is the primary driver of platform design. A successful platform strategy starts with a deep understanding of your development teams’ needs and the broader organizational context. The immersion engagement model <a contenteditable="false" data-type="indexterm" data-primary="immersion engagement, platform engineering" id="id1126"/>can help here. With this model platform engineers embed in individual application teams for a time period. By sitting next to application developers and learning about their work through close observation and asking questions, platform team members are better able to identify common friction points, bottlenecks, and opportunities for improvement. Consider both immediate pain points hindering developer productivity and long-term strategic objectives. </p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Selecting Platform Scope "><div class="sect2" id="chapter_10_selecting_platform_scope_1749354009764438">
          <h2>Selecting Platform Scope </h2>
          <p>Once you’ve started to develop a clear picture of your platform audience, the next step is to define the initial scope<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="scope consideration" id="id1127"/> of your platform capabilities. The most effective approach is to start small by focusing on foundational elements that immediately unlock developer productivity. Streamlined infrastructure provisioning, automated delivery pipelines, and integrated security automation are good examples. As your platform matures and the organization’s needs evolve, you can incrementally expand into more advanced areas, like creating a comprehensive developer portal or introducing self-service analytics tools. The key is to resist the temptation to solve every problem at once—successful platforms grow steadily, guided by demonstrated value and continuous feedback from the teams they serve.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="A Practical Road Map Example"><div class="sect2" id="chapter_10_a_practical_road_map_example_1749354009764490">
          <h2>A Practical Road Map Example</h2>
          <p>Let’s walk through a practical example of using an understanding of our audience<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="audience consideration" id="id1128"/> to select initial scope. A useful approach is to zero in on the teams and use cases that are already driving rapid innovation. For example, teams that are adopting new technologies or making the leap to cloud platforms often face acute challenges that even a simple platform can help quickly resolve. </p>
          <p>In our example, we decide to focus our efforts to support an applications team transitioning to microservices on AWS and Kubernetes. This team is struggling with standardized infrastructure and deployment patterns. By addressing this specific need, we can demonstrate the platform’s value and gain traction within our organization. In identifying our earlier adopter team, we are careful to select a team that is enthusiastic about actively collaborating in refining the platform offering and willing to provide frequent feedback.</p>
          <p>In this case, we start by creating a paved road that streamlines common tasks. We automate the creation of a new microservice from repository creation through CI/CD pipeline configuration and infrastructure provisioning. Out of the gate, this doesn’t need to encompass every tool in the pipeline. We focus on including only the core build, deploy, and governance layers, and we embed organizational standards directly into our template. In accordance with our second principle, security requirements, compliance controls, and operational best practices are baked in. We partner closely with compliance and security teams to ensure our automated patterns meet their requirements. The goal is that by using our platform, application teams default to doing the right thing. </p>
          <p>Another suggestion for an easy win is to consider offering application teams audit help as a service as part of your platform.<em> </em>Build in functionality that automates answering certain audit questions on their behalf. Because you’re building the system with internal audit in mind, this will be easy to provide and will help drive adoption and delight your users. </p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Balancing Standardization and Flexibility "><div class="sect2" id="chapter_10_balancing_standardization_and_flexibility_1749354009764544">
          <h2>Balancing Standardization and Flexibility </h2>
          <p>In establishing a platform engineering<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="standardization and flexibility balance" id="id1129"/> practice, you may find challenges in standardizing software delivery with your platform paths and giving the teams the flexibility they need (or just want). Consistent software delivery, through standardized platform paths, is what ensures the platform’s reliability, operational efficiency, and ultimately its business value. However, your platform should allow some team autonomy; teams should be able to innovate to come up with the most appropriate and efficient solutions for their specific needs. An overly opinionated template with very rigid paths will only deter adoption of your platform. </p>
          <p>One way to approach this challenge is to consider the components of your template in these three categories:</p>
          <dl>
            <dt>Mandatory components</dt>
            <dd>
              <p>This set of components addresses functions like logging configuration, monitoring setup, and security controls. These are mission-critical concerns (security, observability, compliance) and are strictly standardized. Their inclusion is enforced.</p>
            </dd>
            <dt>Configurable components</dt>
            <dd>
              <p>These components include resource scaling configuration, cache settings, and database connections. Teams should be able to configure as needed without impacting overall objectives of standardization.</p>
            </dd>
            <dt>Extension points</dt>
            <dd>
              <p>Finally, extension points should be used to allow teams to customize aspects such as health checks, configure specialized middleware, and define team-specific metrics. Well-documented APIs provide these extension points, defining clear interfaces between standardized and flexible components. </p>
            </dd>
          </dl>
          <p>With this modular approach, teams can use paved path templates while having the flexibility to adapt them to their needs. A team building a high-throughput service might customize the scaling configuration and add specialized performance metrics, while a team building a security-sensitive service might add extra authentication middleware and audit logging.</p>
          <p>The role of governance<a contenteditable="false" data-type="indexterm" data-primary="governance" data-secondary="platform approach" id="id1130"/> in this balance is crucial. Effective platforms use PaC<a contenteditable="false" data-type="indexterm" data-primary="Policy-as-Code (PaC) frameworks" id="id1131"/><a contenteditable="false" data-type="indexterm" data-primary="PaC (Policy-as-Code) frameworks" id="id1132"/> and automated validation to create guardrails that prevent serious issues while allowing deviation within safe boundaries. For instance, instead of mandating every technology choice, you might implement automated checks that verify that key requirements are met, regardless of the specific implementation. This approach allows teams to innovate while ensuring essential standards are maintained<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_platformengineeringstrategydevelopment107340" id="id1133"/>.</p>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Platform Measurement and Evolution"><div class="sect1" id="chapter_10_platform_measurement_and_evolution_1749354009764610">
        <h1>Platform Measurement and Evolution</h1>
        <p>With a platform strategy in place, the next step is to measure its effectiveness and drive its adoption. This section explores how to define and track metrics to demonstrate platform value and then examines strategies for encouraging developer engagement and platform utilization.</p>
        <section data-type="sect2" data-pdf-bookmark="Measuring Platform Success "><div class="sect2" id="chapter_10_measuring_platform_success_1749354009764675">
          <h2>Measuring Platform Success </h2>
          <p>You can’t improve what you don’t measure<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="measuring success" id="id1134"/>. Think of your platform as a product with both technical and business KPIs. Indicators should help you assess value to both developers and the business. Key metric<a contenteditable="false" data-type="indexterm" data-primary="metrics" data-secondary="platform engineering success" id="id1135"/> categories include:</p>
          <dl>
            <dt>Developer productivity</dt>
            <dd>
              <p>How much faster can teams ship features using the platform? Track metrics like deployment frequency, lead time for changes, and MTTR. Use metrics to get a better understanding of time spent writing code versus managing infrastructure.</p>
            </dd>
            <dt>Platform adoption</dt>
            <dd>
              <p>Are teams actually using the platform? Metrics should measure both breadth (the number of active users, projects leveraging the platform, and the percentage of new projects onboarded) and depth (how extensively teams leverage available features). Usage patterns here can help identify both successful offerings and potential friction points.</p>
            </dd>
            <dt>Operational efficiency</dt>
            <dd>
              <p>How much has the platform reduced costs or improved operational performance? Look at infrastructure costs, incident rates, and support ticket volume.</p>
            </dd>
            <dt>Business impact</dt>
            <dd>
              <p>Ultimately, does the platform contribute to business goals? Metrics should connect platform investments to organizational outcomes such as faster time-to-market, increased customer satisfaction, or improved product quality.</p>
            </dd>
          </dl>
          <p>We track platform performance and value creation to validate continuous improvement and guide platform initiatives. Next, we’ll explore strategies to encourage initial platform adoption and facilitate platform evolution to unlock further value.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Driving Platform Adoption "><div class="sect2" id="chapter_10_driving_platform_adoption_1749354009764727">
          <h2>Driving Platform Adoption </h2>
          <p>Armed with a clear vision for our platform<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="adoption considerations" id="id1136"/> informed by understanding of our audience’s most acute pain points, our next challenge lies in driving adoption of our platform. A well-executed adoption strategy combines careful capability selection, seamless access, and proactive engagement.</p>
          <p>A minimum viable platform (MVP)<a contenteditable="false" data-type="indexterm" data-primary="minimum viable platform (MVP) approach" id="id1137"/><a contenteditable="false" data-type="indexterm" data-primary="MVP (minimum viable platform) approach" id="id1138"/> approach is one that will help drive early adoption. Instead of trying to build everything at once, focus platform work on delivering a small set of high-value, low-effort capabilities that address the most pressing pain points for development teams. These initial wins build credibility and demonstrate our platform’s potential, making it easier to secure buy-in and resources for future expansion. Based on the understanding we’ve gained about our audience, consider the tasks that consume the most developer time or cause the most friction. By tackling these challenges first, we can quickly show tangible benefits and generate excitement around the platform.</p>
          <p>Finally, if you are a platform team you must actively market<a contenteditable="false" data-type="indexterm" data-primary="marketing platform capabilities for developers" id="id1139"/> your capabilities. Building a great platform is only half the battle; you also need to convince developers to use it. Consider developer education programs, technical showcases, and clear communication of the platform benefits and road map. Host workshops and training sessions to teach developers how to use the platform effectively. Showcase successful use cases and highlight the positive impact the platform has had on other teams. Maintain a clear road map and communicate upcoming features and improvements to build excitement and encourage adoption. By actively engaging with the developer community, platform teams can foster a culture of adoption and ensure the platform becomes an integral part of the development workflow.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Leveraging Internal Developer Portals for Platform Success"><div class="sect2" id="chapter_10_leveraging_internal_developer_portals_for_platform_1749354009764786">
          <h2>Leveraging Internal Developer Portals for Platform Success</h2>
          <p>Internal developer portals (IDPs)<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="IDPs" id="xi_platformengineeringIDPs1020047"/><a contenteditable="false" data-type="indexterm" data-primary="internal developer portals (IDPs)" id="xi_internaldeveloperportalsIDPs1020047"/><a contenteditable="false" data-type="indexterm" data-primary="IDPs (internal developer portals)" id="xi_IDPsinternaldeveloperportals1020047"/> serve as the interface between development teams and your platform capabilities. Portals make the platform easy to discover and use by bringing everything together in one place. The most effective portals include service discovery, contextual documentation, and self-service capabilities, making them the natural starting point for any developer interaction with the platform.</p>
          <section data-type="sect3" data-pdf-bookmark="Core portal components"><div class="sect3" id="chapter_10_core_portal_components_1749354009764835">
            <h3>Core portal components</h3>
            <p>A well-designed IDP typically includes:</p>
            <dl>
              <dt>Software catalog</dt>
              <dd>
                <p>A centralized registry of all services, APIs, and components with ownership information and dependency mapping</p>
              </dd>
              <dt>Self-service workflows</dt>
              <dd>
                <p>Automated processes for common tasks like creating new services or provisioning environments using “golden path” templates</p>
              </dd>
              <dt>Documentation hub</dt>
              <dd>
                <p>Contextual, searchable technical resources that appear when needed</p>
              </dd>
              <dt>Scorecards</dt>
              <dd>
                <p>Metrics showing service maturity, compliance status, and adoption of best <span class="keep-together">practices</span></p>
              </dd>
            </dl>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="AI-enhanced developer experience"><div class="sect3" id="chapter_10_ai_enhanced_developer_experience_1749354009764885">
            <h3>AI-enhanced developer experience</h3>
            <p>Modern IDPs increasingly leverage the following AI<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="leveraging for enhanced developer experience" id="id1140"/> capabilities to reduce cognitive load and accelerate platform adoption:</p>
            <dl>
              <dt>Natural language interfaces</dt>
              <dd>
                <p>Allow developers to find resources and execute workflows using conversational queries.</p>
              </dd>
              <dt>Intelligent recommendations</dt>
              <dd>
                <p>Suggest relevant documentation, services, and configuration options based on the developer’s context and history.</p>
              </dd>
              <dt>Automated troubleshooting</dt>
              <dd>
                <p>Analyze error patterns and suggest potential solutions when developers encounter issues.</p>
              </dd>
              <dt>Predictive assistance</dt>
              <dd>
                <p>Anticipate developer needs based on their current activities and proactively offer relevant resources.</p>
              </dd>
            </dl>
            <p>These AI capabilities transform the portal from a passive resource to an active assistant that guides developers through complex operations without requiring them to become experts.</p>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="Building an effective portal"><div class="sect3" id="chapter_10_building_an_effective_portal_1749354009764932">
            <h3>Building an effective portal</h3>
            <p>For sustainable success, treat your IDP as a product with dedicated resources for its ongoing development. Measure its effectiveness through metrics like developer adoption rates, time saved through self-service workflows, and new developer <span class="keep-together">time-to-productivity</span>.</p>
            <p>IDPs have recently become available off the shelf. Backstage, developed initially at Spotify, was open sourced and donated to the Cloud Native Computing Foundation in 2020. Commercial offerings to simplify Backstage adoption and management have emerged from vendors including Roadie<a contenteditable="false" data-type="indexterm" data-primary="Spotify" id="id1141"/><a contenteditable="false" data-type="indexterm" data-primary="Harness" id="id1142"/>, Spotify, and Harness. Non-Backstage commercial IDPs are also available, such as Atlassian’s Compass<a contenteditable="false" data-type="indexterm" data-primary="Atlassian’s Compass" id="id1143"/>.</p>
            <p>A well-designed IDP reduces cognitive load, accelerates onboarding, and makes platform adoption the path of least resistance, transforming how developers experience your entire platform offering<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_platformengineeringIDPs1020047" id="id1144"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_internaldeveloperportalsIDPs1020047" id="id1145"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_IDPsinternaldeveloperportals1020047" id="id1146"/>.</p>
          </div></section>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Sustainable Platform Evolution "><div class="sect2" id="chapter_10_sustainable_platform_evolution_1749354009764981">
          <h2>Sustainable Platform Evolution </h2>
          <p>With initial adoption underway<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="sustainable evolution" id="xi_platformengineeringsustainableevolution1025544"/><a contenteditable="false" data-type="indexterm" data-primary="sustainable evolution, platform engineering" id="xi_sustainableevolutionplatformengineering1025544"/>, the next step is ensuring the platform’s sustainable evolution. This hinges on balancing developer empowerment with platform integrity, achieved through PaC<a contenteditable="false" data-type="indexterm" data-primary="Policy-as-Code (PaC) frameworks" id="id1147"/><a contenteditable="false" data-type="indexterm" data-primary="governance" data-secondary="in sustainable platform evolution" data-secondary-sortas="sustainable platform evolution" id="id1148"/><a contenteditable="false" data-type="indexterm" data-primary="PaC (Policy-as-Code) frameworks" id="id1149"/> and automation, continuous feedback loops, and continual investment in reliability and scalability. Leveraging PaC that enables “trust but verify” automation is one way to achieve this balance. By encoding organizational standards into programmable policies (using tools like OPA or custom enforcement engines), your platform team can delegate control while maintaining compliance. </p>
          <p>Policy and Policy as Code can give some control to development teams to reduce bottlenecks and foster agility without sacrificing standardization. For example, policies can define acceptable resource usage limits, enforce security best practices, or ensure compliance with organizational standards. Developers can operate within predefined boundaries, knowing that their actions won’t compromise the stability or security of the platform. Crucially, policies can also be used to signal upcoming changes, such as deprecating older systems or templates. By issuing warnings well in advance, developers have time to migrate to newer, supported options, ensuring a smooth transition and minimizing disruption when the older systems are eventually retired.</p>
          <p>AI<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="and sustainable platform evolution" data-secondary-sortas="sustainable platform evolution" id="id1150"/> technology is evolving rapidly, creating both opportunities and challenges for platform teams. It’s crucial to establish a systematic approach to evaluating emerging AI tools before incorporating them into your platform. Create a sandbox environment where promising technologies can be tested against real-world scenarios using your organization’s data. Develop clear criteria for graduating AI capabilities from experimental to production-ready, including considerations around reliability, explainability, and governance. This approach allows your platform to benefit from AI advancements while managing the risks of rapidly evolving technology.</p>
          <p>Platform evolution must be guided by empirical evidence rather than assumptions. Your team must make a regular practice of reviewing your “platform intelligence triangle”<a contenteditable="false" data-type="indexterm" data-primary="platform intelligence triangle, reviewing" id="id1151"/>—the combination of platform usage metrics, support requests, and developer feedback. Use these to guide road map development and identify developer needs and pain points. Are certain features underutilized? Are there common support requests that indicate areas for improvement? For instance, if you notice increasing support tickets around a particular service coupled with declining usage patterns, it might indicate a reliability issue that requires immediate attention. Regular platform health checks should examine both technical metrics (error rates, response times) and adoption metrics (feature usage, team onboarding success).</p>
          <p>Finally, consistent investment in platform reliability and scalability is nonnegotiable—a single significant outage can erase months of trust-building. As platform adoption grows—and platform load increases—investment in reliability engineering<a contenteditable="false" data-type="indexterm" data-primary="reliability" data-secondary="platform engineering" id="id1152"/> becomes more critical. Developers need to trust that the platform will be available when they need it and that it will perform consistently. This includes implementing robust observability, establishing clear incident management processes, and maintaining transparent communication channels with development teams<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_platformengineeringsustainableevolution1025544" id="id1153"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_sustainableevolutionplatformengineering1025544" id="id1154"/>. </p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="A Practical Example: Platform Engineering in Action"><div class="sect2" id="chapter_10_a_practical_example_platform_engineering_in_actio_1749354009765038">
          <h2>A Practical Example: Platform Engineering in Action</h2>
          <p>As an example<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="practical example" id="xi_platformengineeringpracticalexample1026327"/>, consider a financial services organization with 1,400 developers spread across 80 product teams facing significant delivery challenges. An audit revealed inconsistent security practices, and the CTO was concerned about both velocity and compliance risks. Meanwhile, internal metrics showed developers spending nearly 45% of their time on noncoding activities—managing pipelines, configuring environments, and addressing security and compliance requirements.</p>
          <p>To address these challenges, the organization formed a dedicated platform team consisting of six people: a platform engineering lead, a senior developer with CI/CD expertise, a security engineer, an operations engineer, a platform engineer with Kubernetes expertise, and a technical product manager who would also handle <span class="keep-together">documentation.</span></p>
          <section data-type="sect3" data-pdf-bookmark="Discovery and strategy development"><div class="sect3" id="chapter_10_discovery_and_strategy_development_1749354009765092">
            <h3>Discovery and strategy development</h3>
            <p>The team began with an intensive discovery phase<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="strategy development" id="id1155"/> to understand both developer pain points and compliance requirements. They implemented a structured immersion program, embedding team members with representative product teams to observe workflows and document challenges. This research revealed common pain points:</p>
            <ul>
              <li>
                <p>Duplicated effort in maintaining separate CI/CD pipelines across teams</p>
              </li>
              <li>
                <p>Inconsistent security scanning implementation</p>
              </li>
              <li>
                <p>Manual environment provisioning creating delays and inconsistencies</p>
              </li>
              <li>
                <p>Poorly understood compliance requirements implemented differently across teams</p>
              </li>
            </ul>
            <p>Simultaneously, the team engaged with governance<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="governance considerations" id="id1156"/><a contenteditable="false" data-type="indexterm" data-primary="governance" data-secondary="platform approach" id="id1157"/> stakeholders through working sessions with the CISO’s team, enterprise architecture, compliance, and legal to understand security controls, technical standards, audit requirements, and data handling requirements.</p>
            <p>Based on this research, the team developed a platform strategy with clear principles:</p>
            <ul>
              <li>
                <p>Developer experience drives platform design—reducing cognitive load.</p>
              </li>
              <li>
                <p>Security and compliance are built in, not bolted on.</p>
              </li>
              <li>
                <p>Everything is measurable—focusing only on what delivers value.</p>
              </li>
              <li>
                <p>The platform is optional but compelling—solving real problems.</p>
              </li>
            </ul>
            <p>The team deliberately focused their initial scope on a single high-impact capability: secure CI/CD pipelines with embedded security controls.</p>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="Building the minimum viable platform"><div class="sect3" id="chapter_10_building_the_minimum_viable_platform_1749354009765140">
            <h3>Building the minimum viable platform</h3>
            <p>The team delivered their MVP<a contenteditable="false" data-type="indexterm" data-primary="MVP (minimum viable platform) approach" id="id1158"/><a contenteditable="false" data-type="indexterm" data-primary="minimum viable platform (MVP) approach" id="id1159"/> within eight weeks: a template-driven pipeline system with embedded security scanning. Key components included:</p>
            <ul>
              <li>
                <p>Pipeline templates with best practices for different application types</p>
              </li>
              <li>
                <p>Preconfigured security scanning integrated directly into the pipeline</p>
              </li>
              <li>
                <p>Automated evidence collection for compliance requirements</p>
              </li>
              <li>
                <p>Self-service configuration through a simple YAML file</p>
              </li>
            </ul>
            <p>The team embedded required security controls directly into the pipeline templates, with static analysis, dependency scanning, container scanning, and compliance checks running automatically. Results fed into a centralized dashboard, while automated evidence collection simplified audit preparation.</p>
            <p>With key checks automated, including required levels of code coverage, the change management process was streamlined dramatically for application teams on the platform. They were excited to be granted an exemption from going to the CAB.</p>
            <p>Working closely with two pilot teams, the platform team refined their offering based on weekly feedback. Documentation was developed alongside the code, with both technical reference material and practical guides.</p>
            <p>Within three months, the MVP showed impressive results with pilot teams:</p>
            <ul>
              <li>
                <p>Deployment time reduced from five days to six hours.</p>
              </li>
              <li>
                <p>Security scanning coverage increased from 40% to 100%.</p>
              </li>
              <li>
                <p>Audit preparation time reduced from days to hours.</p>
              </li>
              <li>
                <p>Critical vulnerabilities discovered and remediated through automated scanning.</p>
              </li>
            </ul>
            <p>By the six-month mark, 15 teams (about 250 engineers) were using the secure pipeline templates, and security incidents from these teams had dropped by 40%, compared with nonadopting teams.</p>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="Expanding platform capabilities"><div class="sect3" id="chapter_10_expanding_platform_capabilities_1749354009765187">
            <h3>Expanding platform capabilities</h3>
            <p>Based on comprehensive telemetry and user feedback, the platform team identified environment provisioning as their next target. They also recognized that with growing adoption, they needed a more scalable approach to onboarding and support.</p>
            <p>Their next phase focused on two key capabilities:</p>
            <ul>
              <li>
                <p>An IDP<a contenteditable="false" data-type="indexterm" data-primary="IDPs (internal developer portals)" id="id1160"/><a contenteditable="false" data-type="indexterm" data-primary="internal developer portals (IDPs)" id="id1161"/> that served as a single interface for all platform capabilities, including:</p>
                <ul>
                  <li>
                    <p>A service catalog with automated discovery</p>
                  </li>
                  <li>
                    <p>Self-service onboarding for secure pipelines</p>
                  </li>
                  <li>
                    <p>Integrated documentation and guides</p>
                  </li>
                  <li>
                    <p>Real-time visibility into pipeline status and security findings</p>
                  </li>
                </ul>
              </li>
              <li>
                <p>IaC<a contenteditable="false" data-type="indexterm" data-primary="Infrastructure as Code (IaC)" id="id1162"/><a contenteditable="false" data-type="indexterm" data-primary="IaC (Infrastructure as Code)" id="id1163"/> templates for common application patterns that encoded best practices for:</p>
                <ul>
                  <li>
                    <p>Secure network configuration</p>
                  </li>
                  <li>
                    <p>Properly configured access controls</p>
                  </li>
                  <li>
                    <p>Compliance-aligned logging and monitoring</p>
                  </li>
                  <li>
                    <p>Resource limits and cost controls</p>
                  </li>
                </ul>
              </li>
            </ul>
            <p>These templates integrated with the IDP, allowing developers to provision compliant environments with minimal effort.</p>
            <p>The expanded platform dramatically increased adoption. Within six months:</p>
            <ul>
              <li>
                <p>45 teams (representing around 600 developers) were using the secure pipelines.</p>
              </li>
              <li>
                <p>30 teams had adopted the IaC templates for environment provisioning.</p>
              </li>
              <li>
                <p>The platform handled over 2,000 deployments per month.</p>
              </li>
              <li>
                <p>Support requests per user had dropped by 70% due to self-service capabilities.</p>
              </li>
            </ul>
            <p>The platform team continued to operate with just six people despite serving hundreds of developers, leveraging self-service capabilities and automation to scale their impact.</p>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="Enterprise-wide adoption and business impact"><div class="sect3" id="chapter_10_enterprise_wide_adoption_and_business_impact_1749354009765238">
            <h3>Enterprise-wide adoption and business impact</h3>
            <p>To drive broader adoption<a contenteditable="false" data-type="indexterm" data-primary="platform engineering" data-secondary="adoption considerations" id="id1164"/>, the platform team developed a multifaceted approach:</p>
            <ul>
              <li>
                <p>Internal events showcasing capabilities and success stories</p>
              </li>
              <li>
                <p>A “Platform Champions” program identifying advocates in each department</p>
              </li>
              <li>
                <p>Executive dashboards showing adoption metrics and business impact</p>
              </li>
              <li>
                <p>Training programs with both self-paced and instructor-led options</p>
              </li>
            </ul>
            <p>The CTO established incentives for adoption, with platform users receiving priority for cloud resources and streamlined compliance reviews.</p>
            <p>As platform adoption grew, governance approaches evolved. Instead of manual reviews and documentation, security and compliance requirements were encoded directly into the platform through:</p>
            <ul>
              <li>
                <p>PaC frameworks that automatically enforced standards</p>
              </li>
              <li>
                <p>Built-in evidence collection that satisfied audit requirements</p>
              </li>
              <li>
                <p>Self-service exception processes for legitimate edge cases</p>
              </li>
              <li>
                <p>Automated compliance reporting from platform telemetry</p>
              </li>
            </ul>
            <p>By the 18-month mark, the platform had achieved significant results:</p>
            <ul>
              <li>
                <p>85% of development teams (representing around 1,200 developers) using the platform.</p>
              </li>
              <li>
                <p>Developer productivity increased by 35%.</p>
              </li>
              <li>
                <p>Deployment frequency increased 6× across the organization.</p>
              </li>
              <li>
                <p>Mean time to recover from failures decreased by 70%.</p>
              </li>
              <li>
                <p>Security incidents reduced by 65% for platform users.</p>
              </li>
              <li>
                <p>Audit preparation time reduced by 90%.</p>
              </li>
              <li>
                <p>Time-to-market for new features reduced by 40%.</p>
              </li>
            </ul>
            <p>These improvements translated to tangible business outcomes: faster feature releases, quicker responses to market changes, reduced downtime, and lower security and compliance risks.</p>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="Ongoing improvements"><div class="sect3" id="chapter_10_ongoing_improvements_1749354009765287">
            <h3>Ongoing improvements</h3>
            <p>Three years into the journey, the platform team continually evolved its offerings. Their road map included AI-assisted development capabilities, advanced observability tools, expanded security automation, and developer experience improvements based on ongoing research.</p>
            <p>The key lessons from this platform engineering journey included:</p>
            <dl>
              <dt>Product mindset is essential</dt>
              <dd>
                <p>Treating developers as customers drives better decisions.</p>
              </dd>
              <dt>Starting small builds credibility</dt>
              <dd>
                <p>Deliver one capability well before expanding.</p>
              </dd>
              <dt>Self-service is key to scale</dt>
              <dd>
                <p>Adopt an agile approach, delivering iteratively.</p>
              </dd>
              <dt>Metrics drive investment</dt>
              <dd>
                <p>Measure both technical outcomes and business impact.</p>
              </dd>
              <dt>Governance integration creates win-wins</dt>
              <dd>
                <p>The right tooling can turn compliance from a constraint into an accelerator.</p>
              </dd>
            </dl>
            <p>This example demonstrates how a small, focused platform team can drive significant organizational transformation by systematically addressing developer needs while streamlining governance requirements. By starting with high-impact capabilities, measuring outcomes, and treating the platform as a product, the team achieved remarkable scale, serving 1,400 developers with just six platform engineers<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_platformengineeringpracticalexample1026327" id="id1165"/>.</p>
          </div></section>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="chapter_10_conclusion_1749354009765334">
        <h1>Conclusion</h1>
        <p>As we wrap up our exploration of modern software delivery, one thing is clear: AI<a contenteditable="false" data-type="indexterm" data-primary="AI-native software delivery" id="xi_AInativesoftwaredelivery1048693"/> isn’t just another tool in our DevOps toolkit; it’s fundamentally changing how we build and deliver software.</p>
        <p>Throughout this book, we’ve seen how AI is impacting every stage of the software lifecycle. From detecting code patterns in repositories to optimizing test selection, from identifying security vulnerabilities to automating cloud cost optimization, AI capabilities are rapidly becoming integral to modern delivery practices.</p>
        <p class="fix_tracking">Platform engineering ties these elements together, creating a foundation where AI-powered capabilities work in concert to accelerate delivery while maintaining governance. By building developer platforms that abstract complexity and embed best practices, teams can focus more on creating business value and less on the undifferentiated heavy lifting that has traditionally consumed so much developer time.</p>
        <p>At the time of writing, AI for developer coding assistants<a contenteditable="false" data-type="indexterm" data-primary="AI coding assistants" id="id1166"/> is more mature than AI for many parts of software delivery. This promises to put new strains on DevOps teams as innovation becomes increasingly constrained not on an organization’s ability to generate code, but on its ability to validate and deliver those applications. Delivery excellence, increasingly dependent on AI, will be a key factor in who will take full advantage of advances in coding techniques and who will be frustrated<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_platformengineering103235" id="id1167"/>.</p>
        <section data-type="sect2" data-pdf-bookmark="Looking Forward"><div class="sect2" id="chapter_10_looking_forward_1749354009765380">
          <h2>Looking Forward</h2>
          <p>The shift to AI-native delivery practices is still in its early stages, but the direction is unmistakable. Organizations that effectively integrate AI into their delivery pipelines will gain significant advantages:</p>
          <ul>
            <li>
              <p class="fix_tracking">Accelerated delivery cycles as AI eliminates bottlenecks and automates routine tasks</p>
            </li>
            <li>
              <p>Improved quality and security through AI-powered testing and vulnerability detection</p>
            </li>
            <li>
              <p>Reduced operational costs via intelligent resource optimization and automated remediation</p>
            </li>
            <li>
              <p>Enhanced developer experience as cognitive load shifts from operational concerns to creative problem-solving</p>
            </li>
          </ul>
          <p>In practice, this means deployment decisions will increasingly be made based on sophisticated AI analysis rather than human judgment alone. Test strategies will adapt dynamically to code changes instead of following rigid patterns. Infrastructure will self-optimize based on application needs rather than requiring manual tuning.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Getting Started"><div class="sect2" id="chapter_10_getting_started_1749354009765424">
          <h2>Getting Started</h2>
          <p>If you’re looking to implement these practices in your organization, we recommend a pragmatic approach:</p>
          <ul>
            <li>
              <p>Identify your most painful bottlenecks first. Where are your teams spending the most time on low-value activities? These are your prime targets for AI-powered automation.</p>
            </li>
            <li>
              <p>Start small and measure relentlessly. Implement focused improvements, validate their impact, and use that success to drive further adoption.</p>
            </li>
            <li>
              <p>Build for your developers, not for the tools. Adopt a product mindset for your delivery platform, ensuring it actually solves real problems for your teams.</p>
            </li>
            <li>
              <p>Embed governance, don’t bolt it on. Use your platform to make compliance and security seamless parts of the development process, not afterthoughts.</p>
            </li>
          </ul>
          <p>The organizations that thrive in this new era won’t necessarily be those with the largest engineering teams or the biggest budgets. Rather, they’ll be the ones that most effectively harness AI to deliver better software, faster, while maintaining the governance guardrails necessary for enterprise operation.</p>
          <p>This won’t happen overnight. Like any significant transformation, it requires committed leadership, continuous learning, and a willingness to challenge established processes. But the rewards—measured in development velocity, product quality, and ultimately business outcomes—make this journey worth undertaking<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_AInativesoftwaredelivery1048693" id="id1168"/>.</p>
          <p>The future of software delivery is intelligent, automated, and built for the needs of the human developers who remain at its core. We hope this book has provided you with both the technical understanding and the practical strategies to begin building that future in your organization today.</p>
        </div></section>
      </div></section>
    </div></section></div></div></body></html>