- en: Chapter 4\. Linear Algebra and Calculus for Deep Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algebra and calculus are pillars of data science, especially the learning algorithms
    which are based on concepts from these two mathematical fields. This chapter presents
    some key algebra and calculus topics in a way that everyone can understand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: It helps to know why you’re learning something. This way, you gain the motivation
    to continue and you know which way to point your focus.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*Algebra *is the study of operations and relational rules, as well as the constructions
    and ideas that result from them. Algebra covers topics such as linear equations
    and matrices. You can consider algebra as the first step towards calculus.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '*Calculus *is the study of curve slopes and rates of change. Calculus covers
    topics such as derivatives and integrals. It is heavily used in many fields such
    as economics and engineering. Different learning algorithms rely on the concepts
    of calculus to perform their complex operations.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between the two is that while calculus works with ideas of change,
    motion, and accumulation, algebra deals with mathematical symbols and the rules
    for manipulating those symbols. Calculus focuses on the characteristics and behavior
    of changing functions, while algebra offers the foundation for solving equations
    and comprehending functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[Heading to Come]'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vectors and Matrices
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *vector* is an object that has a magnitude (length) and a direction (arrowhead).
    The basic representation of a vector is an arrow with coordinates on the axis.
    But first, let’s see what an axis is.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The x-axis and y-axis are perpendicular lines that specify a plane’s boundaries
    and the locations of different points within them in a two-dimensional Cartesian
    coordinate system. The x-axis is horizontal and the y-axis is vertical.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: These axes may represent vectors, with the x-axis representing the vector’s
    horizontal component and the y-axis representing its vertical component.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-1 shows a simple 2-dimensional Cartesian coordinate system with both
    axes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph12.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. 2-dimensional Cartesian coordinate system
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The 2-dimensional Cartesian coordinate system uses simple parentheses to show
    the location of different points following this order:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P o i n t c o o r d i n a t e s equals left-parenthesis
    h o r i z o n t a l l o c a t i o n left-parenthesis x right-parenthesis comma
    v e r t i c a l l o c a t i o n left-parenthesis y right-parenthesis right-parenthesis"><mrow><mi>P</mi>
    <mi>o</mi> <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>c</mi> <mi>o</mi> <mi>o</mi> <mi>r</mi>
    <mi>d</mi> <mi>i</mi> <mi>n</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>s</mi> <mo>=</mo>
    <mo>(</mo> <mi>h</mi> <mi>o</mi> <mi>r</mi> <mi>i</mi> <mi>z</mi> <mi>o</mi> <mi>n</mi>
    <mi>t</mi> <mi>a</mi> <mi>l</mi> <mi>l</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>t</mi>
    <mi>i</mi> <mi>o</mi> <mi>n</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mi>v</mi>
    <mi>e</mi> <mi>r</mi> <mi>t</mi> <mi>i</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mi>l</mi>
    <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mo>(</mo>
    <mi>y</mi> <mo>)</mo> <mo>)</mo></mrow></math>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P o i n t c o o r d i n a t e s equals left-parenthesis
    h o r i z o n t a l l o c a t i o n left-parenthesis x right-parenthesis comma
    v e r t i c a l l o c a t i o n left-parenthesis y right-parenthesis right-parenthesis"><mrow><mi>P</mi>
    <mi>o</mi> <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>c</mi> <mi>o</mi> <mi>o</mi> <mi>r</mi>
    <mi>d</mi> <mi>i</mi> <mi>n</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>s</mi> <mo>=</mo>
    <mo>(</mo> <mi>h</mi> <mi>o</mi> <mi>r</mi> <mi>i</mi> <mi>z</mi> <mi>o</mi> <mi>n</mi>
    <mi>t</mi> <mi>a</mi> <mi>l</mi> <mi>l</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>t</mi>
    <mi>i</mi> <mi>o</mi> <mi>n</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mi>v</mi>
    <mi>e</mi> <mi>r</mi> <mi>t</mi> <mi>i</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mi>l</mi>
    <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mo>(</mo>
    <mi>y</mi> <mo>)</mo> <mo>)</mo></mrow></math>
- en: Therefore, if you want to draw point A which has (2, 3) as coordinates, you
    are likely to look at a graph from point zero, move two points to the right and
    from there, three points upwards. The result of the point should look like Figure
    4-2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph13.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. The location of A on the coordinate system
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s now add another point and draw a vector between them. Suppose you have
    also point B with (4, 5) as coordinates. Naturally, as the coordinates of B are
    both higher than the coordinates of A, you would expect vector AB to be upwards
    sloping. Figure 4-3 shows the new point B and vector AB.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph14.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Vector AB joining A and B points together in magnitude and direction
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, having drawn the vector using the coordinates of both points, how
    would you refer to the vector? Simply put, vector AB has its own coordinates that
    represent it. Remember that the vector is a representation of the movement from
    point A to point B. This means the 2-point movement along the X-axis and the Y-axis
    is the vector. Mathematically, to find the vector, you should subtract the two
    coordinate points from each other while respecting the direction. Here’s how:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '*Vector AB* means that you are going from A to B, therefore, you need to subtract
    the coordinates of point B from the coordinates of point A:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math><mrow><mover><mrow><mi>A</mi> <mi>B</mi></mrow> <mo stretchy="true" style="math-style:normal;math-depth:0;">→</mo></mover>
    <mo>=</mo> <mo><</mo> <mn>4</mn> <mo>−</mo> <mn>2,5</mn> <mo>−</mo> <mn>3</mn>
    <mo>></mo></mrow></math><math><mrow><mover><mrow><mi>A</mi> <mi>B</mi></mrow>
    <mo stretchy="true" style="math-style:normal;math-depth:0;">→</mo></mover> <mo>=</mo>
    <mo><</mo> <mn>2,2</mn> <mo>></mo></mrow></math>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mover><mrow><mi>A</mi> <mi>B</mi></mrow> <mo stretchy="true" style="math-style:normal;math-depth:0;">→</mo></mover>
    <mo>=</mo> <mo><</mo> <mn>4</mn> <mo>−</mo> <mn>2,5</mn> <mo>−</mo> <mn>3</mn>
    <mo>></mo></mrow></math><math><mrow><mover><mrow><mi>A</mi> <mi>B</mi></mrow>
    <mo stretchy="true" style="math-style:normal;math-depth:0;">→</mo></mover> <mo>=</mo>
    <mo><</mo> <mn>2,2</mn> <mo>></mo></mrow></math>
- en: '*Vector BA* means that you are going from B to A, therefore, you need to subtract
    the coordinates of point A from the coordinates of point B:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向量BA*表示从B到A，因此，您需要从点A的坐标中减去点B的坐标：'
- en: <math alttext="ModifyingAbove upper B upper A With right-arrow equals less-than
    2 minus 4 comma 3 minus 5 greater-than"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mo><</mo> <mn>2</mn> <mo>-</mo> <mn>4</mn> <mo>,</mo>
    <mn>3</mn> <mo>-</mo> <mn>5</mn> <mo>></mo></mrow></math>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove upper B upper A With right-arrow equals less-than
    2 minus 4 comma 3 minus 5 greater-than"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mo><</mo> <mn>2</mn> <mo>-</mo> <mn>4</mn> <mo>,</mo>
    <mn>3</mn> <mo>-</mo> <mn>5</mn> <mo>></mo></mrow></math>
- en: <math alttext="ModifyingAbove upper B upper A With right-arrow equals less-than
    negative 2 comma negative 2 greater-than"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mo><</mo> <mo>-</mo> <mn>2</mn> <mo>,</mo> <mo>-</mo>
    <mn>2</mn> <mo>></mo></mrow></math>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove upper B upper A With right-arrow equals less-than
    negative 2 comma negative 2 greater-than"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mo><</mo> <mo>-</mo> <mn>2</mn> <mo>,</mo> <mo>-</mo>
    <mn>2</mn> <mo>></mo></mrow></math>
- en: To interpret AB and BA vectors, you think in terms of movement. AB vector represents
    going from point A to point B, two positive points horizontally and vertically
    (right and upwards respectively). BA vector represents going from point B to point
    A, two negative points horizontally and vertically (left and downwards respectively).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解释AB和BA向量时，你要考虑移动。AB向量表示从点A到点B的移动，水平和垂直方向分别为两个正点（向右和向上）。BA向量表示从点B到点A的移动，水平和垂直方向分别为两个负点（向左和向下）。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Vectors AB and BA are not the same thing even though they share the same slope.
    But what is a slope anyway?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 向量AB和BA虽然具有相同的斜率，但它们并不是同一物体。但是斜率到底是什么？
- en: 'The *slope* is the ratio of the vertical change between two points on the line
    to the horizontal change between the same two points. You calculate the slope
    using this mathematical formula:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*斜率*是线上两点之间的垂直变化与水平变化之间的比率。您可以使用以下数学公式计算斜率：'
- en: <math alttext="upper S l o p e equals StartFraction left-parenthesis normal
    upper Delta upper Y right-parenthesis Over left-parenthesis normal upper Delta
    upper X right-parenthesis EndFraction"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi>
    <mi>p</mi> <mi>e</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>(</mo><mi>Δ</mi><mi>Y</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>Δ</mi><mi>X</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper S l o p e equals StartFraction left-parenthesis normal
    upper Delta upper Y right-parenthesis Over left-parenthesis normal upper Delta
    upper X right-parenthesis EndFraction"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi>
    <mi>p</mi> <mi>e</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>(</mo><mi>Δ</mi><mi>Y</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>Δ</mi><mi>X</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
- en: <math alttext="upper S l o p e o f ModifyingAbove upper A upper B With right-arrow
    equals two-halves equals 1"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi>
    <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>2</mn></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></math>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper S l o p e o f ModifyingAbove upper A upper B With right-arrow
    equals two-halves equals 1"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi>
    <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>2</mn></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></math>
- en: <math alttext="upper S l o p e o f ModifyingAbove upper B upper A With right-arrow
    equals StartFraction negative 2 Over negative 2 EndFraction equals 1"><mrow><mi>S</mi>
    <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>-</mo><mn>2</mn></mrow>
    <mrow><mo>-</mo><mn>2</mn></mrow></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></math>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper S l o p e o f ModifyingAbove upper B upper A With right-arrow
    equals StartFraction negative 2 Over negative 2 EndFraction equals 1"><mrow><mi>S</mi>
    <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>-</mo><mn>2</mn></mrow>
    <mrow><mo>-</mo><mn>2</mn></mrow></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></math>
- en: If the two vectors were simply lines (with no direction), then, they would be
    the same object. However, adding the directional component makes them two distinguishable
    mathematical objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个向量只是线（没有方向），那么它们将是相同的对象。然而，添加方向性组件使它们成为两个可区分的数学对象。
- en: Figure 4-4 sheds more light on the concept of the slope, as *x* has shifted
    two points to the right and *y* has shifted two points to the left.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4更详细地解释了斜率的概念，因为x向右移动了两个点，y向左移动了两个点。
- en: '![](Images/dlf_graph15.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_graph15.png)'
- en: Figure 4-4\. The change in x and the change in y for vector AB
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-4。向量AB的x和y的变化
- en: Figure 4-5 shows the change in *x* and the change in *y* in the case of vector
    BA.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-5展示了向量BA的x和y的变化。
- en: '![](Images/dlf_graph16.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_graph16.png)'
- en: Figure 4-5\. The change in x and the change in y for vector BA
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-5。向量BA的x和y的变化
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A vector that has a magnitude of 1 is referred to as a *unit vector*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 具有大小为1的向量称为*单位向量*。
- en: Researchers typically use vectors as representations of speed especially in
    engineering. Navigation is one field that heavily relies on vectors. It allows
    navigators to determine their positions and plan their destinations. Naturally,
    magnitude represents speed and the direction represents the destination.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员通常使用向量作为速度的表示，尤其在工程领域。导航是一个严重依赖向量的领域。它允许导航员确定他们的位置并规划他们的目的地。自然地，大小表示速度，方向表示目的地。
- en: You can add and subtract vectors from each other and from scalars. This allows
    for a shift in direction and magnitude. What you should retain from the previous
    discussion is that vectors indicate directions between different points on the
    axis.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将向量相互相加和相减，也可以与标量相加和相减。这允许方向和大小的变化。您应该从前面的讨论中记住的是，向量表示轴上不同点之间的方向。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *scalar *is a value with magnitude but no direction. Scalars, as opposed to
    vectors, are used to represent elements like temperature and prices. Basically,
    scalars are numbers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*标量*是具有大小但没有方向的值。与向量相反，标量用于表示温度和价格等元素。基本上，标量是数字。'
- en: In machine learning, the *x*-axis and *y*-axis respectively represent data and
    the model’s results. The independent (predictor) variable is represented by the
    *x*-axis in a scatter plot, and the dependent (forecast) variable is represented
    by the *y*-axis.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，x轴和y轴分别代表数据和模型的结果。在散点图中，独立（预测）变量由x轴表示，而依赖（预测）变量由y轴表示。
- en: 'A *matrix* is a row-and-column-organized rectangular array containing numbers^([1](ch04.xhtml#idm46147468230768)).
    Matrices are useful in computer graphics and other domains as well as to define
    and manipulate linear systems of equations. What differentiates a matrix from
    a vector? The simplest answer is that a vector is a matrix with a single column
    or a single row. Here’s a a basic example of a 3 x 3 matrix:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵*是一个按行和列组织的包含数字的矩形数组。矩阵在计算机图形和其他领域中很有用，用于定义和操作线性方程组。矩阵与向量有何不同？最简单的答案是，向量是具有单列或单行的矩阵。这是一个3
    x 3矩阵的基本示例：'
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    9 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 13 3rd Row 1st Column
    1 2nd Column 5 3rd Column 12 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>13</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>5</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    9 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 13 3rd Row 1st Column
    1 2nd Column 5 3rd Column 12 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>13</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>5</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced></math>
- en: 'Matrices’ sizes are referred to using their rows and columns respectively.
    A row is a horizontal line and a column is a vertical line. The following representation
    is a 2 x 4 matrix:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的大小分别使用它们的行和列来表示。行是水平线，列是垂直线。以下表示是一个2 x 4矩阵：
- en: <math alttext="Start 2 By 4 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    1 4th Column 3 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 9 4th Column
    4 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 4 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    1 4th Column 3 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 9 4th Column
    4 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></math>
- en: 'The following representation is another example of a matrix. This time it is
    a 4 x 2 matrix:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表示是另一个矩阵的示例。这次是一个4 x 2矩阵：
- en: <math alttext="Start 4 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 3rd Row 1st Column 8 2nd Column 22 4th Row
    1st Column 7 2nd Column 3 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd></mtr> <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>7</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 4 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 3rd Row 1st Column 8 2nd Column 22 4th Row
    1st Column 7 2nd Column 3 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd></mtr> <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>7</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></math>
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Matrices are heavily used in machine learning. Rows generally represent time
    and columns represent features.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵在机器学习中被广泛使用。行通常表示时间，列表示特征。
- en: 'The summation of different matrices is straightforward but must be used only
    when the matrices match in size (which means they have the same number of columns
    and rows). For instance, let’s add the two following matrices:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不同矩阵的求和很简单，但只有在矩阵大小相匹配时才能使用（即它们具有相同的列数和行数）。例如，让我们将以下两个矩阵相加：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 5 2nd Column 8 EndMatrix plus Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 4 2nd Column 11 2nd Row 1st Column 6 2nd Column 13 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mo>+</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd> <mtd><mn>13</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 5 2nd Column 8 EndMatrix plus Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 4 2nd Column 11 2nd Row 1st Column 6 2nd Column 13 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mo>+</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd> <mtd><mn>13</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'You can see that to add two matrices, you simply have to add the numbers in
    the same positions. Now, if you try to add the two following matrices, you won’t
    be able to do it as there is a mismatch in what to add:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，要添加两个矩阵，只需将相同位置的数字相加。现在，如果您尝试添加以下两个矩阵，您将无法做到，因为要添加的内容不匹配：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 8 2nd Column 3 2nd Row
    1st Column 3 2nd Column 2 EndMatrix plus Start 3 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 3rd Row 1st Column 5 2nd Column
    4 EndMatrix"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><mn>8</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 8 2nd Column 3 2nd Row
    1st Column 3 2nd Column 2 EndMatrix plus Start 3 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 3rd Row 1st Column 5 2nd Column
    4 EndMatrix"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><mn>8</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'The subtraction of matrices is also straighforward and follows the same rules
    as the summation of matrices. Let’s take the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的减法也很简单，遵循与矩阵加法相同的规则。让我们看下面的例子：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 EndMatrix minus Start 2 By 2 Matrix 1st Row
    1st Column 3 2nd Column 9 2nd Row 1st Column negative 1 2nd Column negative 5
    EndMatrix equals Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column negative
    7 2nd Row 1st Column negative 9 2nd Column 15 EndMatrix"><mrow><mfenced open="["
    close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>8</mn></mrow></mtd> <mtd><mn>10</mn></mtd></mtr></mtable></mfenced> <mo>-</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>7</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>9</mn></mrow></mtd>
    <mtd><mn>15</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 EndMatrix minus Start 2 By 2 Matrix 1st Row
    1st Column 3 2nd Column 9 2nd Row 1st Column negative 1 2nd Column negative 5
    EndMatrix equals Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column negative
    7 2nd Row 1st Column negative 9 2nd Column 15 EndMatrix"><mrow><mfenced open="["
    close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>8</mn></mrow></mtd> <mtd><mn>10</mn></mtd></mtr></mtable></mfenced> <mo>-</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>7</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>9</mn></mrow></mtd>
    <mtd><mn>15</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Evidently, subtraction of matrics is also a summation of matrices with a change
    of signals in one of them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，矩阵的减法也是矩阵的加法，其中一个矩阵中的信号发生变化。
- en: 'Matrix multiplication by a scalar is quite simple. Let’s take the following
    example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘以标量是非常简单的。让我们看下面的例子：
- en: <math alttext="3 times Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2
    2nd Row 1st Column 8 2nd Column 22 EndMatrix equals Start 2 By 2 Matrix 1st Row
    1st Column 15 2nd Column 6 2nd Row 1st Column 24 2nd Column 66 EndMatrix"><mrow><mn>3</mn>
    <mo>×</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>15</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>24</mn></mtd> <mtd><mn>66</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 times Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2
    2nd Row 1st Column 8 2nd Column 22 EndMatrix equals Start 2 By 2 Matrix 1st Row
    1st Column 15 2nd Column 6 2nd Row 1st Column 24 2nd Column 66 EndMatrix"><mrow><mn>3</mn>
    <mo>×</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>15</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>24</mn></mtd> <mtd><mn>66</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'So basically, you are multiplying every element in the matrix by the scalar. Matrix
    multiplication by another matrix is a bit more complicated since they use the
    *dot product* method. First of all, in order to multiply two matrices together,
    they must satisfy this condition:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，您正在将矩阵中的每个元素乘以标量。矩阵乘以另一个矩阵稍微复杂，因为它们使用*点乘*方法。首先，为了将两个矩阵相乘，它们必须满足这个条件：
- en: <math alttext="upper M a t r i x Subscript x y Baseline times upper M a t r
    i x Subscript y z Baseline equals upper M a t r i x Subscript x z"><mrow><mi>M</mi>
    <mi>a</mi> <mi>t</mi> <mi>r</mi> <mi>i</mi> <msub><mi>x</mi> <mrow><mi>x</mi><mi>y</mi></mrow></msub>
    <mo>×</mo> <mi>M</mi> <mi>a</mi> <mi>t</mi> <mi>r</mi> <mi>i</mi> <msub><mi>x</mi>
    <mrow><mi>y</mi><mi>z</mi></mrow></msub> <mo>=</mo> <mi>M</mi> <mi>a</mi> <mi>t</mi>
    <mi>r</mi> <mi>i</mi> <msub><mi>x</mi> <mrow><mi>x</mi><mi>z</mi></mrow></msub></mrow></math>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper M a t r i x Subscript x y Baseline times upper M a t r
    i x Subscript y z Baseline equals upper M a t r i x Subscript x z"><mrow><mi>M</mi>
    <mi>a</mi> <mi>t</mi> <mi>r</mi> <mi>i</mi> <msub><mi>x</mi> <mrow><mi>x</mi><mi>y</mi></mrow></msub>
    <mo>×</mo> <mi>M</mi> <mi>a</mi> <mi>t</mi> <mi>r</mi> <mi>i</mi> <msub><mi>x</mi>
    <mrow><mi>y</mi><mi>z</mi></mrow></msub> <mo>=</mo> <mi>M</mi> <mi>a</mi> <mi>t</mi>
    <mi>r</mi> <mi>i</mi> <msub><mi>x</mi> <mrow><mi>x</mi><mi>z</mi></mrow></msub></mrow></math>
- en: 'This means that the first matrix must have a number of columns equal to the
    number of rows in the second matrix, and the resulting matrix from the dot product
    is a matrix that has the number of rows of the first matrix and the number of
    columns of the second matrix. The dot product is explained in this example representation
    of a 1 x 3 and 3 x 1 matrix multiplication (notice the equal number of columns
    and rows):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第一个矩阵的列数必须等于第二个矩阵的行数，点乘的结果矩阵是第一个矩阵的行数和第二个矩阵的列数。点乘在这个1 x 3和3 x 1矩阵乘法的示例表示中解释（注意相同的列数和行数）：
- en: <math alttext="Start 1 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    3 EndMatrix times Start 3 By 1 Matrix 1st Row  3 2nd Row  2 3rd Row  1 EndMatrix
    equals Start 1 By 1 Matrix 1st Row  left-parenthesis 1 times 3 right-parenthesis
    plus left-parenthesis 2 times 2 right-parenthesis plus left-parenthesis 3 times
    1 right-parenthesis EndMatrix equals Start 1 By 1 Matrix 1st Row  10 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>×</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>(</mo> <mn>1</mn>
    <mo>×</mo> <mn>3</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>2</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>3</mn> <mo>×</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>10</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 1 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    3 EndMatrix times Start 3 By 1 Matrix 1st Row  3 2nd Row  2 3rd Row  1 EndMatrix
    equals Start 1 By 1 Matrix 1st Row  left-parenthesis 1 times 3 right-parenthesis
    plus left-parenthesis 2 times 2 right-parenthesis plus left-parenthesis 3 times
    1 right-parenthesis EndMatrix equals Start 1 By 1 Matrix 1st Row  10 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>×</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>(</mo> <mn>1</mn>
    <mo>×</mo> <mn>3</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>2</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>3</mn> <mo>×</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>10</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Let’s take another example of a 2 x 2 matrix multiplication:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个2 x 2矩阵乘法的例子：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 0 2nd Column 1 EndMatrix times Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 0 2nd Row 1st Column 2 2nd Column 1 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 7 2nd Column 2 2nd Row 1st Column 2 2nd Column 1 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>×</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 0 2nd Column 1 EndMatrix times Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 0 2nd Row 1st Column 2 2nd Column 1 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 7 2nd Column 2 2nd Row 1st Column 2 2nd Column 1 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>×</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'There is a special type of matrix called the *identity matrix* which is basically
    the number 1 for matrices. It is defined as follows for a 2 x2 dimension:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊类型的矩阵称为*单位矩阵*，基本上是矩阵的数字1。对于2 x 2维度，它定义如下：
- en: <math alttext="upper I equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column
    0 2nd Row 1st Column 0 2nd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper I equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column
    0 2nd Row 1st Column 0 2nd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'And as follows for a 3 x 3 dimension:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于3 x 3维度，如下所示：
- en: <math alttext="upper I equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper I equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Multiplying any matrix by the identity matrix yields the same original matrix.
    This is why it can be referred to as the 1 of matrices (multiplying any number
    by 1 yields the same number). It is worth noting that matrix multplication is
    not commutative, which means that the order of multiplication changes the result
    such as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何矩阵乘以单位矩阵会产生相同的原始矩阵。这就是为什么它可以被称为矩阵的1（将任何数字乘以1会得到相同的数字）。值得注意的是，矩阵乘法不是可交换的，这意味着乘法的顺序会改变结果，例如：
- en: <math alttext="upper A upper B not-equals upper B upper A"><mrow><mi>A</mi>
    <mi>B</mi> <mo>≠</mo> <mi>B</mi> <mi>A</mi></mrow></math>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper A upper B not-equals upper B upper A"><mrow><mi>A</mi>
    <mi>B</mi> <mo>≠</mo> <mi>B</mi> <mi>A</mi></mrow></math>
- en: '*Matrix transposing* is a process that involves changing the rows of into columns
    and vice versa. The transpose of a matrix is obtained by reflecting the matrix
    along its main diagonal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵转置*是一个过程，涉及将行变为列，反之亦然。矩阵的转置是通过沿其主对角线反射矩阵获得的：'
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 4 2nd Column 6 3rd Column
    1 2nd Row 1st Column 1 2nd Column 4 3rd Column 2 EndMatrix Superscript upper T
    Baseline equals Start 3 By 2 Matrix 1st Row 1st Column 4 2nd Column 1 2nd Row
    1st Column 6 2nd Column 4 3rd Row 1st Column 1 2nd Column 2 EndMatrix"><mrow><msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 4 2nd Column 6 3rd Column
    1 2nd Row 1st Column 1 2nd Column 4 3rd Column 2 EndMatrix Superscript upper T
    Baseline equals Start 3 By 2 Matrix 1st Row 1st Column 4 2nd Column 1 2nd Row
    1st Column 6 2nd Column 4 3rd Row 1st Column 1 2nd Column 2 EndMatrix"><mrow><msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Transposing is used in some machine learning algorithms and is not an uncommon
    operation when dealing with such models. If you are wondering about the role of
    matrices in data science and machine learning, you can refer to this non-exhaustive
    list:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 转置在一些机器学习算法中使用，并且在处理这些模型时不是一个罕见的操作。如果您想了解数据科学和机器学习中矩阵的作用，可以参考这个非详尽的列表：
- en: Representation of data
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表示
- en: Matrices often represent data with rows representing samples and columns representing
    features. For example, a row in a matrix can present OHLC data in one time step.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵通常表示具有行表示样本和列表示特征的数据。例如，矩阵中的一行可以表示一个时间步长中的OHLC数据。
- en: Linear algebra
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数
- en: Matrices and linear algebra are intertwined, and many learning algorithms use
    the concepts of matrices in their operations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵和线性代数是相互交织的，许多学习算法在其操作中使用矩阵的概念。
- en: Data relationship matrices
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数据关系矩阵
- en: If you remember from Chapter 3, covariance and correlation measures are often
    represented as matrices. These relationship calculations are important concepts
    in machine learning.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得第3章，协方差和相关性度量通常表示为矩阵。这些关系计算是机器学习中重要的概念。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You should retain the following key concepts from this section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从本节中保留以下关键概念：
- en: A vector is an object that has a magnitude (length) and a direction (arrowhead).
    Multiple vectors grouped together form a matrix.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量是一个具有大小（长度）和方向（箭头头部）的对象。多个向量组合在一起形成一个矩阵。
- en: A matrix can be used to store data. It has its special ways of performing operations.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵可用于存储数据。它有其特殊的操作方式。
- en: Matrix multiplication uses the dot product method.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵乘法使用点乘方法。
- en: Transposing a matrix means to swap its rows and its columns.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转置矩阵意味着交换其行和列。
- en: Introduction to Linear Equations
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性方程简介
- en: You have already seen an example of a linear equation in the section that discusses
    linear regression and statistical inference from Chapter 3\. *Linear equations*
    are basically formulae that present an equality relationship between between different
    variables and constants. In the case of machine learning, it is often a relationship
    between a dependent variable (the output) and the independent variable (the input). The
    best way to understand linear equations is through examples.​
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在讨论线性回归和第3章统计推断中看到了线性方程的一个例子。*线性方程*基本上是呈现不同变量和常数之间的等式关系的公式。在机器学习的情况下，它通常是依赖变量（输出）和自变量（输入）之间的关系。理解线性方程的最佳方法是通过示例。​
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The aim of linear equations is to find an unknown variable, usually denoted
    by the letter *x*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程的目的是找到一个未知变量，通常用字母*x*表示。
- en: 'Let’s see a very basic example which you can consider as a first building block
    towards more advanced calculus concepts you will see later on. The following examples
    requires finding the value of *x*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个非常基本的例子，您可以将其视为以后将看到的更高级微积分概念的第一个基本构建块。以下例子需要找到*x*的值：
- en: <math alttext="10 x equals 20"><mrow><mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x equals 20"><mrow><mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
- en: You should understand the equation as "*10 times which number equals 20?”*.
    When a constant is directly attached to a variable such as *x*, it refers to a
    multiplication operation. Now, to solve for *x* (so, finding the value of *x*
    that equalizes the equation), you have an obvious solution which is to get rid
    of 10 so that you have x on one side of the equation and the rest on the other
    side.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将方程理解为“10乘以哪个数字等于20？”当一个常数直接附加到变量（如*x*）时，它指的是一个乘法运算。现在，要解出*x*（即找到使方程相等的*x*的值），您有一个明显的解决方案，即摆脱10，这样您就可以在方程的一边得到*x*，而在另一边得到其余部分。
- en: 'Naturally, to get rid of 10, you divide by 10 so that what remains is 1 which
    if multiplied by the variable *x* does nothing. However, keep in mind two important
    things:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，为了消除10，您应该除以10，这样剩下的是1，如果乘以变量*x*则不会有任何变化。但是，请记住两个重要的事情：
- en: If you do a mathematical operation on one side of an equation, you must do it
    on the other side as well. This is why they are called equations.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在方程的一边进行数学运算，则必须在另一边进行相同的运算。这就是它们被称为方程的原因。
- en: For simplicity, instead of dividing by the constant to get rid of it, you should
    multiply it by its reciprocal.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为简单起见，您应该将常数乘以其倒数而不是除以它来消除它。
- en: 'The *reciprocal* of a number is one divided by that number. Here’s the mathematical
    representation of it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字的*倒数*是该数字的倒数。这是它的数学表示：
- en: <math alttext="upper R e c i p r o c a l left-parenthesis x right-parenthesis
    equals StartFraction 1 Over x EndFraction"><mrow><mi>R</mi> <mi>e</mi> <mi>c</mi>
    <mi>i</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper R e c i p r o c a l left-parenthesis x right-parenthesis
    equals StartFraction 1 Over x EndFraction"><mrow><mi>R</mi> <mi>e</mi> <mi>c</mi>
    <mi>i</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
- en: 'Now, back to the example, to find *x*, you can do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到例子，要找到*x*，您可以这样做：
- en: <math alttext="left-parenthesis one-tenth right-parenthesis 10 x equals 20 left-parenthesis
    one-tenth right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>10</mn></mfrac>
    <mo>)</mo></mrow> <mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>10</mn></mfrac> <mo>)</mo></mrow></mrow></math>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis one-tenth right-parenthesis 10 x equals 20 left-parenthesis
    one-tenth right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>10</mn></mfrac>
    <mo>)</mo></mrow> <mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>10</mn></mfrac> <mo>)</mo></mrow></mrow></math>
- en: 'Performing the multiplication and simplifying gives the following result:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 进行乘法并简化得到以下结果：
- en: <math alttext="x equals 2"><mrow><mi>x</mi> <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 2"><mrow><mi>x</mi> <mo>=</mo> <mn>2</mn></mrow></math>
- en: 'This means that the solution of the equation is 2\. To verify this, you just
    need to plug it into the original equation as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着方程的解是2。要验证这一点，您只需要将其代入原方程如下：
- en: <math alttext="10 times 2 equals 20"><mrow><mn>10</mn> <mo>×</mo> <mn>2</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 times 2 equals 20"><mrow><mn>10</mn> <mo>×</mo> <mn>2</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
- en: Therefore, it takes two 10’s to get 20.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要两个10来得到20。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Dividing the number by itself or multiplying it by its reciprocal is the same
    thing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字除以自身或乘以其倒数是相同的。
- en: 'Let’s take another example of how to solve *x* through linear techniques. Consider
    the following problem:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个通过线性技术解决*x*的例子。考虑以下问题：
- en: <math alttext="eight-sixths x equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn></mrow></math>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="eight-sixths x equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn></mrow></math>
- en: 'Performing the multiplication and simplifying gives the following result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 进行乘法并简化得到以下结果：
- en: <math alttext="left-parenthesis six-eighths right-parenthesis eight-sixths x
    equals 24 left-parenthesis six-eighths right-parenthesis"><mrow><mrow><mo>(</mo>
    <mfrac><mn>6</mn> <mn>8</mn></mfrac> <mo>)</mo></mrow> <mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn> <mrow><mo>(</mo> <mfrac><mn>6</mn> <mn>8</mn></mfrac>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis six-eighths right-parenthesis eight-sixths x
    equals 24 left-parenthesis six-eighths right-parenthesis"><mrow><mrow><mo>(</mo>
    <mfrac><mn>6</mn> <mn>8</mn></mfrac> <mo>)</mo></mrow> <mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn> <mrow><mo>(</mo> <mfrac><mn>6</mn> <mn>8</mn></mfrac>
    <mo>)</mo></mrow></mrow></math>
- en: <math alttext="x equals 18"><mrow><mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 18"><mrow><mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
- en: 'This means that the solution of the equation is 18\. To verify this, you just
    need to plug it into the original equation as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着方程的解是18。要验证这一点，您只需要将其代入原方程如下：
- en: <math alttext="eight-sixths times 18 equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mo>×</mo> <mn>18</mn> <mo>=</mo> <mn>24</mn></mrow></math>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="eight-sixths times 18 equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mo>×</mo> <mn>18</mn> <mo>=</mo> <mn>24</mn></mrow></math>
- en: 'Let’s  dig in a little deeper, because typically, linear equations are not
    this simple. Sometimes they contain more variables and more constants, which need
    more detailed solutions, but let’s keep taking it step by step. Consider the following
    example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一点，因为通常，线性方程并不是这么简单。有时它们包含更多的变量和常数，需要更详细的解决方案，但让我们一步一步地继续。考虑以下例子：
- en: <math alttext="3 x minus 6 equals 12"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x minus 6 equals 12"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
- en: 'Solving for *x* requires rearranging the equation a little bit. Remember, the
    aim is to leave *x* on one side and the rest on the other. Here, you have to get
    rid of the constant 6 before taking care of 3\. The first part of the solution
    is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解出*x*需要稍微重新排列方程。记住，目标是让*x*在一边，其余在另一边。在处理3之前，您必须摆脱常数6。解的第一部分如下：
- en: <math alttext="3 x minus 6 left-parenthesis plus 6 right-parenthesis equals
    12 left-parenthesis plus 6 right-parenthesis"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo> <mo>=</mo> <mn>12</mn>
    <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo></mrow></math>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x minus 6 left-parenthesis plus 6 right-parenthesis equals
    12 left-parenthesis plus 6 right-parenthesis"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo> <mo>=</mo> <mn>12</mn>
    <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo></mrow></math>
- en: 'Notice how you have to add 6 to both parts of the equation. The part on the
    left will cancel itself out while the part on the right will add up to 18:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您必须在方程的两边都加上6。左边的部分将自行取消，而右边的部分将加起来得到18：
- en: <math alttext="3 x equals 18"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x equals 18"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
- en: 'Finally, you’re all set to multiply by the reciprocal of the constant attached
    to the variable *x*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过乘以附加到变量*x*的常数的倒数来解决：
- en: <math alttext="left-parenthesis one-third right-parenthesis 3 x equals 18 left-parenthesis
    one-third right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac>
    <mo>)</mo></mrow> <mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac> <mo>)</mo></mrow></mrow></math>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis one-third right-parenthesis 3 x equals 18 left-parenthesis
    one-third right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac>
    <mo>)</mo></mrow> <mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac> <mo>)</mo></mrow></mrow></math>
- en: 'Simplifying and solving for *x* leaves the following solution:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简化并解出*x*得到以下解：
- en: <math alttext="x equals 6"><mrow><mi>x</mi> <mo>=</mo> <mn>6</mn></mrow></math>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 6"><mrow><mi>x</mi> <mo>=</mo> <mn>6</mn></mrow></math>
- en: 'This means that the solution of the equation is 6\. To verify this, just plug
    it into the original equation as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着方程的解是6。要验证这一点，只需将其代入原方程如下：
- en: <math alttext="left-parenthesis 3 times 6 right-parenthesis minus 6 equals 12"><mrow><mo>(</mo>
    <mn>3</mn> <mo>×</mo> <mn>6</mn> <mo>)</mo> <mo>-</mo> <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis 3 times 6 right-parenthesis minus 6 equals 12"><mrow><mo>(</mo>
    <mn>3</mn> <mo>×</mo> <mn>6</mn> <mo>)</mo> <mo>-</mo> <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
- en: 'By now, you should start noticing that linear algebra is all about using shortcuts
    and quick techniques to simplify equations and find unknown variables. The next
    example shows how sometimes the variable *x* can occur in multiple places:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该开始注意到线性代数是关于使用快捷方式和快速技巧简化方程并找到未知变量的。下一个例子展示了有时变量*x*可能出现在多个地方：
- en: <math alttext="6 x plus x equals 27 minus 2 x"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>=</mo> <mn>27</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="6 x plus x equals 27 minus 2 x"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>=</mo> <mn>27</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
- en: 'Remember, the main focus is to have *x* on one side of the equation and the
    rest on the other side:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，主要重点是让*x*在方程的一边，其余在另一边：
- en: <math alttext="6 x plus x plus 2 x equals 27"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="6 x plus x plus 2 x equals 27"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
- en: 'Adding the constants of *x* gives you the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加*x*的常数得到以下结果：
- en: <math alttext="9 x equals 27"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="9 x equals 27"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
- en: 'The final step is dividing by 9 so that you only have *x* remaining:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是除以9，这样您只剩下*x*：
- en: <math alttext="x equals 3"><mrow><mi>x</mi> <mo>=</mo> <mn>3</mn></mrow></math>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 3"><mrow><mi>x</mi> <mo>=</mo> <mn>3</mn></mrow></math>
- en: You may now verify this by plugging 3 in the place of *x* in the original equation.
    You will notice that both sides of the equation will be equal.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以通过在原方程中将3代入*x*来验证这一点。您会注意到方程的两边是相等的。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Even though this section is quite simple, it contains the basic foundations
    you need to start advancing in algebra and calculus. The main points to retain
    before going further are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一部分非常简单，但它包含了您在代数和微积分中开始进阶所需的基本基础。在继续之前需要记住的主要要点如下：
- en: A linear equation is a representation in which the highest exponent on any variable
    is one. This means that there are no variables that are raised to the power of
    two and above.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性方程是一种表示，其中任何变量的最高指数为一。这意味着没有变量被提高到二次及以上的幂。
- en: A linear equation line is straight when plotted on a chart.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性方程在图表上绘制时是直线。
- en: The application of linear equations in modeling a wide range of real-world occurrences
    makes them crucial in many branches of mathematics and research. They are also
    widely utilized in machine learning.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving for *x* is the process of finding its value that equalizes both sides
    of the equation.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When performing an operation (such as adding a constant or multiplying by a
    constant) on one side of the equation, you have to do it on the other side as
    well.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reciprocals are useful to simplify equations.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systems of Equations
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *system of equation* is when there are two or more equations working together
    to solve a variable or more. Therefore, instead of the usual single equation like
    the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
- en: 'Systems of equations resemble the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
- en: <math alttext="y plus 2 x equals 10"><mrow><mi>y</mi> <mo>+</mo> <mn>2</mn>
    <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y plus 2 x equals 10"><mrow><mi>y</mi> <mo>+</mo> <mn>2</mn>
    <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: There are methods that solve them and particularities, which are discussed in
    this section. Systems of equations are useful in machine learning and are used
    in many of its aspects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the previous system of equation from the beginning of this section
    and solve it graphically. Plotting the two functions can actually give the solution
    directly. The point of intersection of linear equations is the solution. Therefore,
    the coordinates of the intersection (*x, y*) refer to the solutions of the *x*
    and *y* respectively.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'From Figure 4-6, it seems that *x* = 10 and *y* = -10\. Plugging these values
    into their respective variables gives the correct answer:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 plus 10 equals 20"><mrow><mn>10</mn> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 plus 10 equals 20"><mrow><mn>10</mn> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
- en: <math alttext="left-parenthesis negative 10 right-parenthesis plus left-parenthesis
    2 times 10 right-parenthesis equals 10"><mrow><mo>(</mo> <mo>-</mo> <mn>10</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>10</mn> <mo>)</mo>
    <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis negative 10 right-parenthesis plus left-parenthesis
    2 times 10 right-parenthesis equals 10"><mrow><mo>(</mo> <mo>-</mo> <mn>10</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>10</mn> <mo>)</mo>
    <mo>=</mo> <mn>10</mn></mrow></math>
- en: '![](Images/dlf_graph1.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. A graph showing the two functions and their intersection (solution)
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As the functions are linear, there can be three cases to solving them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: There is only one solution for each variable.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no solution. This occurs when the functions are *parallel* (this means
    that they never intersect).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The is an infinite number of solutions. This occurs when it’s the same function
    (since all points fall on the straight line).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before moving on to solving systems of equations using algebra, let’s visually
    see how can there be no solution and how can there be an infinite number of solutions.
    Consider the following system:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 x equals 10"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 x equals 10"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: <math alttext="4 x equals 20"><mrow><mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="4 x equals 20"><mrow><mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
- en: Figure 4-7 charts the two together. Since they are exactly the same equation,
    they fall on the same line. In reality, there are two lines in Figure 4-7, but
    since they are the same, they are indistinguishable. For every *x* on the line,
    there is a corresponding *y*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph2.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. A graph showing the two functions and their infinite intersections
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, consider the following system:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x equals 10"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x equals 10"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: <math alttext="6 x equals 10"><mrow><mn>6</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="6 x equals 10"><mrow><mn>6</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: Figure 4-8 shows how they never intersect which is intuitive as you cannot multiply
    the same number (represented by the variable *x*) with different numbers and expect
    to get the same result.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph3.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. A graph showing the two functions and their impossible intersection
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Algebraic methods are used when there are more than two variables since they
    cannot be solved through graphs. This mainly entails two methods, substitution
    and elimination.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitution* is used when you can replace the value of a variable in one
    equation and plug it in the second equation. Consider the following example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus y equals 2"><mrow><mi>x</mi> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></math>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x plus y equals 2"><mrow><mi>x</mi> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></math>
- en: <math alttext="10 x plus y equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x plus y equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: 'The easiest method is to rearrange the first equation so that you have *y*
    in terms of *x*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y equals 2 minus x"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mo>-</mo>
    <mi>x</mi></mrow></math>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals 2 minus x"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mo>-</mo>
    <mi>x</mi></mrow></math>
- en: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
- en: 'Solving for *x* in the second equation becomes simple:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
- en: <math alttext="10 x plus 2 minus x equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>2</mn> <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x plus 2 minus x equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>2</mn> <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: <math alttext="10 x minus x equals 10 minus 2"><mrow><mn>10</mn> <mi>x</mi>
    <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn></mrow></math>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x minus x equals 10 minus 2"><mrow><mn>10</mn> <mi>x</mi>
    <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn></mrow></math>
- en: <math alttext="9 x equals 8"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>8</mn></mrow></math>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="9 x equals 8"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>8</mn></mrow></math>
- en: <math alttext="x equals eight-ninths"><mrow><mi>x</mi> <mo>=</mo> <mfrac><mn>8</mn>
    <mn>9</mn></mfrac></mrow></math>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals eight-ninths"><mrow><mi>x</mi> <mo>=</mo> <mfrac><mn>8</mn>
    <mn>9</mn></mfrac></mrow></math>
- en: <math alttext="x equals 0.8889"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn> <mo>.</mo>
    <mn>8889</mn></mrow></math>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 0.8889"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn> <mo>.</mo>
    <mn>8889</mn></mrow></math>
- en: 'Now that you have found the value of *x*, you can easily find *y* by plugging
    the value of *x* in the first equation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="0.8889 plus y equals 2"><mrow><mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>+</mo> <mi>y</mi> <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="0.8889 plus y equals 2"><mrow><mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>+</mo> <mi>y</mi> <mo>=</mo> <mn>2</mn></mrow></math>
- en: <math alttext="y equals 2 minus 0.8889"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn>
    <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>8889</mn></mrow></math>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals 2 minus 0.8889"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn>
    <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>8889</mn></mrow></math>
- en: <math alttext="y equals 1.111"><mrow><mi>y</mi> <mo>=</mo> <mn>1</mn> <mo>.</mo>
    <mn>111</mn></mrow></math>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals 1.111"><mrow><mi>y</mi> <mo>=</mo> <mn>1</mn> <mo>.</mo>
    <mn>111</mn></mrow></math>
- en: 'To check if your solution is correct, you can plug in the values of x and y
    in both formulas:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="0.8889 plus 1.111 equals 2"><mrow><mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>+</mo> <mn>1</mn> <mo>.</mo> <mn>111</mn> <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="0.8889 plus 1.111 equals 2"><mrow><mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>+</mo> <mn>1</mn> <mo>.</mo> <mn>111</mn> <mo>=</mo> <mn>2</mn></mrow></math>
- en: <math alttext="left-parenthesis 10 times 0.8889 right-parenthesis plus 1.111
    equals 10"><mrow><mo>(</mo> <mn>10</mn> <mo>×</mo> <mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>)</mo> <mo>+</mo> <mn>1</mn> <mo>.</mo> <mn>111</mn> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis 10 times 0.8889 right-parenthesis plus 1.111
    equals 10"><mrow><mo>(</mo> <mn>10</mn> <mo>×</mo> <mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>)</mo> <mo>+</mo> <mn>1</mn> <mo>.</mo> <mn>111</mn> <mo>=</mo> <mn>10</mn></mrow></math>
- en: Graphically this means that the two equations intersect at (0.8889, 1.111).
    This technique can be used with more than two variables. Follow the same process
    until the equations are simplified enough to give you the answers. The issue with
    substitution is that it may take some time when you’re dealing with more than
    two variables.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '*Elimination* is a faster alternative. It is about eliminating variables until
    there is only one left. Consider the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 x plus 4 y equals 20" display="block"><mrow><mn>2</mn> <mi>x</mi>
    <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math> <math alttext="3
    x plus 2 y equals 10" display="block"><mrow><mn>3</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 x plus 4 y equals 20" display="block"><mrow><mn>2</mn> <mi>x</mi>
    <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math> <math alttext="3
    x plus 2 y equals 10" display="block"><mrow><mn>3</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: 'Noticing that there is 4*y* and 2*y*, it is possible to multiply the second
    equation by 2 so that you can subtract the equations from each other (which will
    remove the *y* variable):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有4*y*和2*y*，可以将第二个方程乘以2，然后将两个方程相减（这将消除*y*变量）：
- en: <math alttext="2 x plus 4 y equals 20"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 x plus 4 y equals 20"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
- en: <math alttext="6 x plus 4 y equals 20"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="6 x plus 4 y equals 20"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
- en: 'Subtracting the two equations from each other gives the following result:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个方程相减得到以下结果：
- en: <math alttext="minus 4 x equals 0"><mrow><mo>-</mo> <mn>4</mn> <mi>x</mi> <mo>=</mo>
    <mn>0</mn></mrow></math>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="minus 4 x equals 0"><mrow><mo>-</mo> <mn>4</mn> <mi>x</mi> <mo>=</mo>
    <mn>0</mn></mrow></math>
- en: <math alttext="x equals 0"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 0"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></math>
- en: 'Therefore, *x* = 0\. Graphically, this means that they intersect whenever *x*
    = 0 (exactly at the vertical *y* line). Plugging in the value of *x* in the first
    formula gives *y*  = 5:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*x*=0。从图形上看，这意味着它们在*x*=0时相交（正好在垂直的*y*线上）。将*x*的值代入第一个公式得到*y*=5：
- en: <math alttext="left-parenthesis 2 times 0 right-parenthesis plus 4 y equals
    20"><mrow><mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mn>4</mn>
    <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis 2 times 0 right-parenthesis plus 4 y equals
    20"><mrow><mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mn>4</mn>
    <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
- en: <math alttext="4 y equals 20"><mrow><mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="4 y equals 20"><mrow><mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
- en: <math alttext="y equals 5"><mrow><mi>y</mi> <mo>=</mo> <mn>5</mn></mrow></math>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals 5"><mrow><mi>y</mi> <mo>=</mo> <mn>5</mn></mrow></math>
- en: Similarly, elimination can also solve equations with three variables. The choice
    between substitution and elimination depends on the type of equations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，消元法也可以解决具有三个变量的方程。选择替换和消元之间取决于方程的类型。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Key takeaways from this section can be summed up as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的要点可以总结如下：
- en: Systems of equations solve variables together. They are very useful in machine
    learning and are used in some algorithms.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程组解决变量。它们在机器学习中非常有用，并且在一些算法中使用。
- en: Graphical solutions are preferred for simple systems of equations.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单的方程组，图形解法是首选。
- en: Solving systems of equations through algebra entails the use of substitution
    and elimination methods.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代数解方程组需要使用替换和消元方法。
- en: Substitution is preferred when the system is simple but elimination is the way
    to go when the system is a bit more complex.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统比较简单时，首选替换法，但当系统稍微复杂时，消元法是更好的选择。
- en: Trigonometry
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角学
- en: '*Trigonometry e*xplores the behavior of what is known as *trigonometric functions*
    that relate the angles of a triangle to the lengths of its sides. The most-used
    triangle is the right-angled triangle which has one angle at 90**°**. Figure 4-9
    shows an example of a right-angled triangle.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*三角学探讨了所谓的*三角函数*的行为，这些函数将三角形的角度与其边长联系起来。最常用的三角形是直角三角形，其中一个角为90°。图4-9展示了一个直角三角形的例子。'
- en: '![](Images/dlf_trig1.PNG)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/dlf_trig1.PNG)
- en: Figure 4-9\. A right-angled triangle
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-9。直角三角形
- en: 'Let’s define the main characteristics of a right-angled triangle:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义直角三角形的主要特征：
- en: The longest side of the triangle is called a *hypotenuse.*
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形的最长边称为*斜边*。
- en: The angle in front of the hypotenuse is the right angle (the one at 90**°**).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斜边前面的角度是直角（90°的角度）。
- en: Depending on the other angle (θ) you choose (from the two that remains), the
    line between this angle and the hypotenuse is called the *adjacent* and the other
    line is called the *opposite*.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据您选择的另一个角度（θ）（从剩下的两个中选择），连接这个角度和斜边之间的线称为*邻边*，另一条线称为*对边*。
- en: 'Trigonometric functions are simply the division of a line by the other. Remember
    that you have three lines in a triangle (hypotenuse, opposite, and adjacent).
    The trigonometric functions are found as follow:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数简单地是一条线除以另一条线。记住三角形中有三条线（斜边、对边和邻边）。三角函数的计算如下：
- en: <math alttext="s i n left-parenthesis theta right-parenthesis equals StartFraction
    upper O p p o s i t e Over upper H y p o t e n u s e EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>O</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow>
    <mrow><mi>H</mi><mi>y</mi><mi>p</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></mfrac></mstyle></mrow></math>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="s i n left-parenthesis theta right-parenthesis equals StartFraction
    upper O p p o s i t e Over upper H y p o t e n u s e EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>O</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow>
    <mrow><mi>H</mi><mi>y</mi><mi>p</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></mfrac></mstyle></mrow></math>
- en: <math alttext="c o s left-parenthesis theta right-parenthesis equals StartFraction
    upper A d j a c e n t Over upper H y p o t e n u s e EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>A</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow>
    <mrow><mi>H</mi><mi>y</mi><mi>p</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></mfrac></mstyle></mrow></math>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="c o s left-parenthesis theta right-parenthesis equals StartFraction
    upper A d j a c e n t Over upper H y p o t e n u s e EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>A</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow>
    <mrow><mi>H</mi><mi>y</mi><mi>p</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></mfrac></mstyle></mrow></math>
- en: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    upper O p p o s i t e Over upper A d j a c e n t EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>O</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow>
    <mrow><mi>A</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></mfrac></mstyle></mrow></math>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    upper O p p o s i t e Over upper A d j a c e n t EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>O</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow>
    <mrow><mi>A</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></mfrac></mstyle></mrow></math>
- en: 'From the previous three trigonometric functions, it is possible to extract
    a trigonometric identity which reaches *tan* from *sin* and *cos* using basic
    linear algebra:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述三个三角函数中，可以提取一个三角恒等式，通过基本的线性代数从*sin*和*cos*得到*tan*：
- en: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    s i n left-parenthesis theta right-parenthesis Over c o s left-parenthesis theta
    right-parenthesis EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow>
    <mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    s i n left-parenthesis theta right-parenthesis Over c o s left-parenthesis theta
    right-parenthesis EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow>
    <mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
- en: '*Hyperbolic functions *are similar to trigonometric operations but are defined
    using exponential functions.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*双曲函数*类似于三角函数，但是使用指数函数定义。'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This part on hyperbolic functions is extremely important as it forms the basis
    of what is known as *activation functions*, a key concept in neural networks,
    the protagonists of deep learning models. You will see them in detail in Chapter
    8.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 关于双曲函数的部分非常重要，因为它构成了所谓的*激活函数*的基础，这是神经网络中的关键概念，是深度学习模型的主角。您将在第8章中详细了解它们。
- en: 'Euler’s number (denoted as *e*) is one of the most important numbers in mathematics.
    It is an *irrational number*, which is a real number that cannot be expressed
    as a fraction. The word *irrational* comes from the fact that there is no *ratio*
    to express it; it has nothing to do with its personality. Euler’s number *e* is
    also the base of the natural logarithm *ln* and the first digits of it are 2.71828\.
    One of the best approximations to get *e* is the following formula:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉数（表示为*e*）是数学中最重要的数字之一。它是一个*无理数*，即不能表示为分数的实数。 *无理* 一词源于无法用比例表达它的事实；这与其个性无关。欧拉数*e*也是自然对数*ln*的底数，其前几位数字为2.71828。获得*e*的最佳近似值的一个公式如下：
- en: <math alttext="e equals left-parenthesis 1 plus StartFraction 1 Over n EndFraction
    right-parenthesis Superscript n"><mrow><mi>e</mi> <mo>=</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></mrow></math>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="e equals left-parenthesis 1 plus StartFraction 1 Over n EndFraction
    right-parenthesis Superscript n"><mrow><mi>e</mi> <mo>=</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></mrow></math>
- en: 'By increasing *n* in the previous formula, you will approach the value of *e*.
    It has many interesting properties, notably the fact that its slope is its own
    value. Let’s take for example the following function (also called the natural
    exponent function):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加前述公式中的*n*，您将接近*e*的值。它有许多有趣的性质，特别是其斜率等于其自身的值。让我们以以下函数为例（也称为自然指数函数）：
- en: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
- en: At any point, the slope of the function is the same value. Take a look at Figure
    4-10.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何点，函数的斜率都是相同的值。看一下图4-10。
- en: '![](Images/dlf_graph4.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/dlf_graph4.png)
- en: Figure 4-10\. The graph of the natural exponent function
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-10。自然指数函数的图形
- en: Note
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may be wondering about the use of explaining exponents and logarithms in
    this book. There are mainly two reasons for this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么这本书要解释指数和对数。主要有两个原因：
- en: Exponents and more importantly Euler’s number are used in hyperbolic functions
    where *tanh(x)* is one of the main activation functions for neural networks, a
    type of machine and deep learning model.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数和更重要的是欧拉数在双曲函数中使用，其中*tanh(x)*是神经网络的主要激活函数之一，这是一种机器学习和深度学习模型。
- en: Logarithms are very useful in *data normalization* but also in *loss functions*,
    concepts that you will see in later chapters.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数在*数据归一化*以及*损失函数*中非常有用，这些概念将在后面的章节中看到。
- en: Therefore, having a deep understanding of what they refer to is primordial in
    building up expertise in the subsequent models.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在建立对后续模型的专业知识时，深入理解它们所指的内容是至关重要的。
- en: 'Hyperbolic functions use the natural exponent function and are defined as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 双曲函数使用自然指数函数，并定义如下：
- en: <math alttext="s i n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="s i n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
- en: <math alttext="c o s h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline plus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="c o s h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline plus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
- en: <math alttext="t a n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over e Superscript
    x Baseline plus e Superscript negative x Baseline EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mrow><msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow></mfrac></mstyle></mrow></math>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="t a n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over e Superscript
    x Baseline plus e Superscript negative x Baseline EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mrow><msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow></mfrac></mstyle></mrow></math>
- en: Among the key characteristics of *tanh(x)* is non-linearity, the limitation
    between [-1, 1], and the fact that it is centered at zero. Figure 4-11 shows the
    graph of *tanh(x)*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*tanh(x)*的关键特征之一是非线性，限制在[-1, 1]之间，并且它以零为中心。图4-11显示了*tanh(x)*的图形。'
- en: '![](Images/dlf_graph5.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_graph5.png)'
- en: Figure 4-11\. The graph of tanh(x) showing how it’s limited between -1 and 1
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-11. tanh(x)的图形显示它在-1和1之间的限制
- en: Note
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Key concepts to retain from this section are summed up as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节中保留的关键概念总结如下：
- en: Trigonometry is a field that explores the behavior of trigonometric functions
    which relate the angles of a triangle to the lengths of its sides.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角学是一门探索三角函数行为的领域，它将三角形的角与其边长联系起来。
- en: A trigonometric identity is a shortcut that relates the trigonometric functions
    with each other.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角恒等式是一种将三角函数相互关联的快捷方式。
- en: Eurler’s number *e* is irrational and is the base of the natural logarithm.
    It has many applications in exponential growth and in hyperbolic functions.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧拉数*e*是无理数，是自然对数的底。它在指数增长和双曲函数中有许多应用。
- en: Hyperbolic functions resemble trigonmetric functions but are not the same thing.
    While trigonometric functions relate to a triangles and circles, hyperbolic functions
    relate to hyperbolas.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双曲函数类似于三角函数，但并不相同。虽然三角函数涉及三角形和圆，双曲函数涉及双曲线。
- en: The hyperbolic tangent function is used in neural networks, a deep learning
    algorithm.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双曲正切函数在神经网络中使用，这是一种深度学习算法。
- en: Limits and Continuity
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极限与连续性
- en: Calculus works by making visible the infinitesimally small.
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 微积分通过使微小量可见来工作。
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Keith Devlin'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- Keith Devlin'
- en: Let’s move now to calculus after seeing the major topics of linear algebra.
    Limits don’t have to be nightmarish. I have always found them to be misunderstood.
    They are actually quite easy to get. But first, you need motivation and this comes
    from knowing the added value of learning limits.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在看完线性代数的主要主题后，让我们现在转向微积分。极限不必是噩梦。我一直发现它们被误解了。实际上，它们很容易理解。但首先，你需要动力，这来自于了解学习极限的附加价值。
- en: 'Understanding limits is very important in machine learning models for many
    reasons:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多原因，深入了解极限在机器学习模型中非常重要：
- en: Optimization
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 优化
- en: In optimization methods like gradient descent, limits can be used to regulate
    the step size and guarantee convergence to a local minimum (a concept you will
    learn in Chapter 8).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在像梯度下降这样的优化方法中，极限可以用来调节步长并确保收敛到局部最小值（这是您将在第8章中学到的概念）。
- en: Feature Selection
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 特征选择
- en: Limits can be used to rank the significance of various model features and perform
    feature selection, which can make the model simpler and perform better.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 极限可用于排列各种模型特征的重要性并执行特征选择，这可以使模型更简单且性能更好。
- en: Sensitivity analysis
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感性分析
- en: A machine learning model’s sensitivity to changes in input data and its capacity
    to generalize to new data can be used to examine a model’s behavior.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型对输入数据变化的敏感性以及泛化到新数据的能力可以用来检查模型的行为。
- en: ​Also, limits are used in more advanced calculus concepts you will run across
    in the coming pages.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ​此外，极限在您将在接下来的页面中遇到的更高级的微积分概念中使用。
- en: The main aim of limits is to know the value of a function when it’s undefined.
    But what is an undefined function? When you have a function that gives a solution
    that is not possible (such as dividing by zero), limits help you bypass this issue
    in order to know the value of the function at that point. So the aim of limits
    is to solve functions even when they are undefined.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 极限的主要目的是在函数未定义时知道函数的值。但什么是未定义的函数？当你有一个给出不可能解决方案的函数（例如除以零）时，极限帮助你绕过这个问题，以便知道该点的函数值。因此，极限的目的是解决函数，即使它们是未定义的。
- en: 'Remember that the solution to a function that takes *x* as an input is a value
    in the *y* axis. Figure 4-12 shows a linear graph of the following function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，将*x*作为输入的函数的解是*y*轴上的一个值。图4-12显示了以下函数的线性图：
- en: <math alttext="f left-parenthesis x right-parenthesis equals x plus 2"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>x</mi> <mo>+</mo> <mn>2</mn></mrow></math>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x plus 2"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>x</mi> <mo>+</mo> <mn>2</mn></mrow></math>
- en: '![](Images/dlf_graph6.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_graph6.png)'
- en: Figure 4-12\. The graph of the function f(x) = x + 2
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-12. 函数f(x) = x + 2的图形
- en: The solution of the function in the graph is the one that lies on the linear
    line taking into account the value of *x* every time.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图中函数的解是考虑到每次*x*的值的线性线上的值。
- en: What would be the solution of the function (the value of *y*) when *x* = 4?
    Clearly, the answer is 6, as substituting the value of *x* by 4 gives 6.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当*x* = 4时，函数的解（*y*的值）是多少？显然，答案是6，因为将*x*的值替换为4会得到6。
- en: <math alttext="f left-parenthesis 4 right-parenthesis equals 4 plus 2 equals
    6"><mrow><mi>f</mi> <mo>(</mo> <mn>4</mn> <mo>)</mo> <mo>=</mo> <mn>4</mn> <mo>+</mo>
    <mn>2</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis 4 right-parenthesis equals 4 plus 2 equals
    6"><mrow><mi>f</mi> <mo>(</mo> <mn>4</mn> <mo>)</mo> <mo>=</mo> <mn>4</mn> <mo>+</mo>
    <mn>2</mn> <mo>=</mo> <mn>6</mn></mrow></math>
- en: 'Thinking of this solution in terms of limits would be saying, what is the solution
    of the function as *x* approaches 4 from both sides (the negative side and the
    positive side)? Table 4-1 simplifies this dilemma:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从极限的角度来看这个解，就是说，当*x*从两侧（负侧和正侧）趋近于4时，函数的解是什么？表4-1简化了这个困境：
- en: Table 4-1\. Finding x
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1. 寻找x
- en: '| *f(x)* | *   x* |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| *f(x)* | *  x* |'
- en: '| 5.998 | 3.998 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 5.998 | 3.998 |'
- en: '| 5.999 | 3.999 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 5.999 | 3.999 |'
- en: '| 6.000 | 4 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 6.000 | 4 |'
- en: '| 6.001 | 4.001 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 6.001 | 4.001 |'
- en: '| 6.002 | 4.002 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 6.002 | 4.002 |'
- en: Approaching from the negative side is the equivalent of adding a fraction of
    a number while below 4 and analyzing the result every time. Similarly, approaching
    from the positive side is the equivalent of removing a fraction of a number while
    above 4 and analyzing the result every time. The solution seems to converge to
    6 as x approaches 4\. This is the solution to the limit.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从负侧接近相当于在4以下添加一个数字的一部分并分析结果。同样，从正侧接近相当于在4以上减去一个数字的一部分并分析结果。当x趋近于4时，解似乎收敛到6。这就是极限的解。
- en: 'Limits in the general form are written following this convention:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一般形式的极限按照以下约定书写：
- en: <math alttext="limit Underscript x right-arrow a Endscripts f left-parenthesis
    x right-parenthesis equals upper L"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow a Endscripts f left-parenthesis
    x right-parenthesis equals upper L"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
- en: 'The general form of the limit is read as follows: as you approach *a* along
    the *x*-axis (whether from the positive or the negative side), the function *f(x)*
    gets closer to the value of *L*.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 极限的一般形式读作：当你沿着*x*轴接近*a*时（无论是从正侧还是负侧），函数*f(x)*趋近于值*L*。
- en: Note
  id: totrans-296
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The idea of the limit states that as you lock-in and approach a number from
    either side (negative or positive), the solution of the equation approaches a
    certain number, and the solution to the limit is that number.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 极限的概念表明，当你从任一侧（负数或正数）锁定并接近一个数字时，方程的解趋近于某个数字，极限的解就是那个数字。
- en: As mentioned previously, limits are useful when the exact point of the solution
    is undefined using the conventional way of substitution.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当使用传统的代入方法无法定义解的确切点时，极限是有用的。
- en: 'A one-sided limit is different from the general limit. The left-hand limit
    is where you search for the limit going from the negative side to the positive
    side, and the right-hand limit is when you search for the limit going from the
    positive side to the negative side. The general limit exists when the two one-sided
    limits exist and are equal. Therefore, the previous statements are summarized
    as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 单侧极限与一般极限不同。左侧极限是你从负侧到正侧寻找极限，右侧极限是你从正侧到负侧寻找极限。当两个单侧极限存在且相等时，一般极限存在。因此，前述陈述总结如下：
- en: The left-hand limit exists.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧极限存在。
- en: The right-hand limit exists.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧极限存在。
- en: The left-hand limit is equal to the right-hand limit.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧极限等于右侧极限。
- en: 'The left hand limit is defined as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧极限定义如下：
- en: <math alttext="limit Underscript x right-arrow a Superscript minus Baseline
    Endscripts f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi>
    <mo>-</mo></msup></mrow></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>L</mi></mrow></math>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow a Superscript minus Baseline
    Endscripts f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi>
    <mo>-</mo></msup></mrow></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>L</mi></mrow></math>
- en: 'The right hand limit is defined as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧极限定义如下：
- en: <math alttext="limit Underscript x right-arrow a Superscript plus Baseline Endscripts
    f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi> <mo>+</mo></msup></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow a Superscript plus Baseline Endscripts
    f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi> <mo>+</mo></msup></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
- en: 'Let’s take the following equation:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的方程：
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    cubed minus 27 Over x minus 3 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mi>x</mi><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    cubed minus 27 Over x minus 3 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mi>x</mi><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
- en: 'What is the solution of the function when x = 3? Substitution leads to the
    following issue:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当x = 3时函数的解是什么？代入会导致以下问题：
- en: <math alttext="f left-parenthesis 3 right-parenthesis equals StartFraction 3
    cubed minus 27 Over 3 minus 3 EndFraction equals StartFraction 27 minus 27 Over
    3 minus 3 EndFraction equals StartFraction 0 Over 0 EndFraction equals upper U
    n d e f i n e d"><mrow><mi>f</mi> <mrow><mo>(</mo> <mn>3</mn> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mn>3</mn>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>27</mn><mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mn>0</mn> <mn>0</mn></mfrac></mstyle>
    <mo>=</mo> <mi>U</mi> <mi>n</mi> <mi>d</mi> <mi>e</mi> <mi>f</mi> <mi>i</mi> <mi>n</mi>
    <mi>e</mi> <mi>d</mi></mrow></math>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis 3 right-parenthesis equals StartFraction 3
    cubed minus 27 Over 3 minus 3 EndFraction equals StartFraction 27 minus 27 Over
    3 minus 3 EndFraction equals StartFraction 0 Over 0 EndFraction equals upper U
    n d e f i n e d"><mrow><mi>f</mi> <mrow><mo>(</mo> <mn>3</mn> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mn>3</mn>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>27</mn><mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mn>0</mn> <mn>0</mn></mfrac></mstyle>
    <mo>=</mo> <mi>U</mi> <mi>n</mi> <mi>d</mi> <mi>e</mi> <mi>f</mi> <mi>i</mi> <mi>n</mi>
    <mi>e</mi> <mi>d</mi></mrow></math>
- en: However, thinking about this in terms of limits as Table 4-2 shows, it seems
    that as you approach *x = 3*, either from the left side or the right side, the
    solution tends to approach 27.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从表4-2所示的极限的角度来看，当你接近*x = 3*时，无论是从左侧还是右侧，解都趋向于27。
- en: Table 4-2\. Finding x
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2。找到x
- en: '| f(x) |    x |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| f(x) |    x |'
- en: '| 2.9998 | 26.9982 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 2.9998 | 26.9982 |'
- en: '| 2.9999 | 26.9991 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 2.9999 | 26.9991 |'
- en: '| 3.0000 | Undefined |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 3.0000 | 未定义 |'
- en: '| 3.0001 | 27.0009 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 3.0001 | 27.0009 |'
- en: '| 3.0002 | 27.0018 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 3.0002 | 27.0018 |'
- en: Graph-wise, this can be seen as a discontinuity in the chart along both axes.
    The discontinuity exists on the line around the coordinate (3, 27).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，这可以看作是图表中沿着两个轴的不连续性。不连续性存在于坐标（3，27）附近的线上。
- en: Some functions do not have limits. For example, what is the limit of the following
    function as *x* approaches 5?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数没有极限。例如，当*x*趋近于5时，以下函数的极限是多少？
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over x minus 5 EndFraction"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo>-</mo><mn>5</mn></mrow></mfrac></mrow></math>
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over x minus 5 EndFraction"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo>-</mo><mn>5</mn></mrow></mfrac></mrow></math>
- en: Looking at Table 4-3, it seems that as *x* approaches 5, the results highly
    diverge when approaching from both sides. For instance, approaching from the negative
    side, the limit of 4.9999 is -10,000 and from the positive side, the limit of
    5.0001 is 10,000.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 看看表4-3，当*x*趋近于5时，结果在从两侧接近时高度发散。例如，从负侧接近，4.9999的极限是-10,000，从正侧接近，5.0001的极限是10,000。
- en: '| f(x) |    x |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| f(x) |    x |'
- en: '| 4.9998 | -5000 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 4.9998 | -5000 |'
- en: '| 4.9999 | -10000 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 4.9999 | -10000 |'
- en: '| 5.0000 | Undefined |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 5.0000 | 未定义 |'
- en: '| 5.0001 | 10000 |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 5.0001 | 10000 |'
- en: '| 5.0002 | 5000 |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 5.0002 | 5000 |'
- en: Remember that for the general limit to exist, both one-sided limits must exist
    and must be equal, which is not the case here. Graphing this gives Figure 4-13,
    which may help you understand why the limit does not exist.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一般极限存在时，两个单侧极限必须存在且相等，而这里并非如此。绘制图表得到图4-13，这可能有助于理解为什么极限不存在。
- en: '![](Images/dlf_graph7.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_graph7.png)'
- en: Figure 4-13\. The graph of the function proving that the limit does not exist
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-13。证明极限不存在的函数图
- en: 'But what if the function that you want to analyze looks like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你想分析的函数看起来像这样呢：
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mrow></math>
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mrow></math>
- en: 'Looking at Table 4-3, it seems that as x approaches 5, the results rapidly
    accelerate as they diverge to a certain very big number referred to as infinity
    (∞). Take a look at Table 4-4:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 看看表4-3，似乎当x趋近于5时，结果迅速加速，趋向于一个非常大的数字，称为无穷大（∞）。看看表4-4：
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mstyle></mrow></math>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mstyle></mrow></math>
- en: Table 4-3\. Finding x
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-3。找到x
- en: '| f(x) |    x |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| f(x) |    x |'
- en: '| 4.99997 | 33333.33 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 4.99997 | 33333.33 |'
- en: '| 4.99998 | 50000 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 4.99998 | 50000 |'
- en: '| 4.99999 | 100000 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 4.99999 | 100000 |'
- en: '| 4.9999999 | 10000000 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 4.9999999 | 10000000 |'
- en: '| 5 | Undefined |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 未定义 |'
- en: '| 5.0000001 | 10000000 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 5.0000001 | 10000000 |'
- en: '| 5.00001 | 100000 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 5.00001 | 100000 |'
- en: '| 5.00002 | 50000 |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 5.00002 | 50000 |'
- en: '| 5.00003 | 33333.33 |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 5.00003 | 33333.33 |'
- en: See how at every tiny step *x* approaches 5, *y* approaches positive infinity.
    The answer to the limit question is therefore, positive infinity (+∞). Figure
    4-14 shows the graph of the function. Notice how they both rise in value as x
    approaches 5.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 看看每一个微小步骤中*x*趋近于5时，*y*趋近于正无穷大。因此，极限问题的答案是正无穷大（+∞）。图4-14显示了函数的图形。注意当x趋近于5时它们的值都在上升。
- en: '![](Images/dlf_graph8.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_graph8.png)'
- en: Figure 4-14\. The graph of the function proving that the limit exists as x approaches
    5
  id: totrans-349
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-14。证明当x趋近于5时极限存在的函数图
- en: '*Continuous* functions are ones that are drawn without gaps or holes in the
    graph, while *discontinuous* functions contain such gaps and holes. This usually
    means that the latter contain points where the solution of the functions is undefined
    and may need to be approximated by limits. Therefore, continuity and limits are
    two related concepts.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s proceed to solving limits; after all, you are not going to create a table
    every time and analyze the results subjectively to find the limits. There are
    three ways to solve limits:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitution*: This is the simplest rule and is generally used first.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Factoring*: This comes after substitution does not work.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conjugate methods*: This solution comes after the first two ways do not work.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *substitution* way is simply plugging in the value which *x* approaches.
    Basically, these are functions that have solutions where the limits are used.
    Take the following example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts x plus 10 minus
    2 x"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 5 Endscripts x plus 10 minus
    2 x"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
- en: 'Using the substitution way, the limit of the function is found as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow 5 Endscripts
    x plus 10 minus 2 x equals 5 plus 10 minus left-parenthesis 2 times 5 right-parenthesis
    equals 5 EndLayout"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><munder><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></munder>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>5</mn> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>×</mo>
    <mn>5</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow 5 Endscripts
    x plus 10 minus 2 x equals 5 plus 10 minus left-parenthesis 2 times 5 right-parenthesis
    equals 5 EndLayout"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><munder><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></munder>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>5</mn> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>×</mo>
    <mn>5</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
- en: Therefore, the answer to the limit is 5.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'The *factoring* way is the next option when substitution does not work (for
    example, the limit is undefined after plugging in the value of *x* in the function).
    *Factoring* is all about changing the form of the equation using factors in a
    way that it is not undefined anymore when using the substitution way. Take the
    following example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac></mrow></math>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac></mrow></math>
- en: 'If you try the substitution way, you will get an undefined value as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow negative
    6 Endscripts StartFraction left-parenthesis x plus 6 right-parenthesis left-parenthesis
    x squared minus x plus 1 right-parenthesis Over x plus 6 EndFraction equals StartFraction
    left-parenthesis negative 6 plus 6 right-parenthesis left-parenthesis left-parenthesis
    negative 6 right-parenthesis squared minus left-parenthesis negative 6 right-parenthesis
    plus 1 right-parenthesis Over negative 6 plus 6 EndFraction equals StartFraction
    0 Over 0 EndFraction equals upper U n d e f i n e d EndLayout"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><munder><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></munder> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mo>(</mo><msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mn>0</mn>
    <mn>0</mn></mfrac> <mo>=</mo> <mi>U</mi> <mi>n</mi> <mi>d</mi> <mi>e</mi> <mi>f</mi>
    <mi>i</mi> <mi>n</mi> <mi>e</mi> <mi>d</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow negative
    6 Endscripts StartFraction left-parenthesis x plus 6 right-parenthesis left-parenthesis
    x squared minus x plus 1 right-parenthesis Over x plus 6 EndFraction equals StartFraction
    left-parenthesis negative 6 plus 6 right-parenthesis left-parenthesis left-parenthesis
    negative 6 right-parenthesis squared minus left-parenthesis negative 6 right-parenthesis
    plus 1 right-parenthesis Over negative 6 plus 6 EndFraction equals StartFraction
    0 Over 0 EndFraction equals upper U n d e f i n e d EndLayout"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><munder><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></munder> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mo>(</mo><msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mn>0</mn>
    <mn>0</mn></mfrac> <mo>=</mo> <mi>U</mi> <mi>n</mi> <mi>d</mi> <mi>e</mi> <mi>f</mi>
    <mi>i</mi> <mi>n</mi> <mi>e</mi> <mi>d</mi></mrow></mtd></mtr></mtable></math>
- en: 'Factoring may help in this case. For example, the nominator is multiplied by
    (x+6) and then divided by (x+6). Simplifying this by canceling the two terms could
    give a solution:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction equals limit Underscript x
    right-arrow negative 6 Endscripts x squared minus x plus 1"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction equals limit Underscript x
    right-arrow negative 6 Endscripts x squared minus x plus 1"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
- en: 'Now that factoring is done, you can try substitution once again:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts x squared
    minus x plus 1 equals left-parenthesis negative 6 right-parenthesis squared minus
    left-parenthesis negative 6 right-parenthesis plus 1 equals 43"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>-</mo> <mrow><mo>(</mo> <mo>-</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mn>1</mn> <mo>=</mo> <mn>43</mn></mrow></math>
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow negative 6 Endscripts x squared
    minus x plus 1 equals left-parenthesis negative 6 right-parenthesis squared minus
    left-parenthesis negative 6 right-parenthesis plus 1 equals 43"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>-</mo> <mrow><mo>(</mo> <mo>-</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mn>1</mn> <mo>=</mo> <mn>43</mn></mrow></math>
- en: The limit of the function as *x* tends towards -6 is therefore 43.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'The *conjugate* way is the next option in case substitution and factoring do
    not work. A conjugate is simply the changing of signs between two variables. For
    example, the conjugate of *x* + *y* is  *x* - *y*. The way to do this in the case
    of a fraction is to multiply the nominator and the denominator by the conjugate
    of one of them (with a preference to use the conjugate of the term that has a
    square root since it will get canceled out). Take the following example:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
- en: 'By multiplying both terms by the conjugate of the denominator, you will have
    started to use the conjugate way to solve the problem:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction left-parenthesis StartFraction
    StartRoot x EndRoot plus 3 Over StartRoot x EndRoot plus 3 EndFraction right-parenthesis"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mrow><mo>(</mo>
    <mfrac><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow> <mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow></mfrac>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction left-parenthesis StartFraction
    StartRoot x EndRoot plus 3 Over StartRoot x EndRoot plus 3 EndFraction right-parenthesis"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mrow><mo>(</mo>
    <mfrac><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow> <mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow></mfrac>
    <mo>)</mo></mrow></mrow></math>
- en: 'Taking into account the multiplication and simplifying gives the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over left-parenthesis StartRoot x EndRoot minus 3 right-parenthesis left-parenthesis
    StartRoot x EndRoot plus 3 right-parenthesis EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow></mfrac></mstyle></mrow></math>
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over left-parenthesis StartRoot x EndRoot minus 3 right-parenthesis left-parenthesis
    StartRoot x EndRoot plus 3 right-parenthesis EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow></mfrac></mstyle></mrow></math>
- en: 'You will be left with the following familiar situation:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over x minus 9 EndFraction"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow></mfrac></mrow></math>
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over x minus 9 EndFraction"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow></mfrac></mrow></math>
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot x EndRoot
    plus 3"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <msqrt><mi>x</mi></msqrt> <mo>+</mo> <mn>3</mn></mrow></math>
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot x EndRoot
    plus 3"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <msqrt><mi>x</mi></msqrt> <mo>+</mo> <mn>3</mn></mrow></math>
- en: 'Now, the function is ready for substitution:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot 9 EndRoot
    plus 3 equals 3 plus 3 equals 6"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <msqrt><mn>9</mn></msqrt> <mo>+</mo>
    <mn>3</mn> <mo>=</mo> <mn>3</mn> <mo>+</mo> <mn>3</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot 9 EndRoot
    plus 3 equals 3 plus 3 equals 6"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <msqrt><mn>9</mn></msqrt> <mo>+</mo>
    <mn>3</mn> <mo>=</mo> <mn>3</mn> <mo>+</mo> <mn>3</mn> <mo>=</mo> <mn>6</mn></mrow></math>
- en: The solution to the function is therefore 6\. As you can see, sometimes work
    needs to be done on preparing the equations in order to be ready for substitution.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The main key points of this section on limits are as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Limits help find solutions for functions that may be undefined in certain points.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the general limit to exist, the two one-sided limits must exist and must
    be equal.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are ways to find the limit of a function, notably substitution, factoring,
    and the conjugate way.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits are useful in machine learning such as sensitivity analysis and optimization.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *derivative* measures the change in a function given a change of one or more
    of its inputs. In other words, it is the rate of change of a function at a given
    point.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a solid understanding of derivatives is important in building machine
    learning models for multiple reasons:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: In order to minimize the loss function (a concept you will see in Chapter 8),
    optimization methods employ derivatives to ascertain the direction of the steepest
    descent and modify model parameters. Gradient descent is one of the most frequently
    used optimization techniques in machine learning.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Backpropagation
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: To execute gradient descent in deep learning, the backpropagation technique
    uses derivatives to calculate the gradients of the loss function with respect
    to the model’s parameters.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter tuning
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: To improve the performance of the model, derivatives are used for sensitivity
    analysis and tuning of hyperparameters (another concept you will perfectly grasp
    in Chapter 8).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget what you have learned from the previous section on limits, as
    you will be needing them for this section as well. Calculus mainly deals with
    derivatives and integrals. This section discusses derivatives and their uses.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: You can consider derivatives as functions that represent (or model) the slope
    of another function at some point. A *slope* is a measure of a line’s position
    relative to a horizontal line. A positive slope indicates a line moving up, while
    a negative slope indicates a line moving down.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Derivatives and slopes are related concepts, but they are not the same thing.
    Here’s the main difference between the two:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: The slope measures the steepness of a line. It is the ratio of the change in
    the y-axis to the change in the *x*-axis. You have already seen this in the section
    that discusses linear algebra.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derivative describes the rate of change of a given function. As the distance
    between two points on a function approaches zero, the derivative of that function
    at that point is the limit of the slope of the tangent line.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before explaining derivatives in layperson’s terms and seeing some examples,
    let’s see their formal definitions (which means their mathematical representation
    in their default form):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
- en: 'The equation forms the basis of solving derivatives, although there are many
    shortcuts that you will learn and understand where they come from. Let’s try finding
    the derivative of a function using the formal definition. Consider the following
    equation:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    4 x minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>-</mo>
    <mn>2</mn></mrow></math>
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    4 x minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>-</mo>
    <mn>2</mn></mrow></math>
- en: 'To find the derivative, plug *f(x)* inside the formal definition and then solve
    the limit:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
- en: 'To simplify things, let’s find *f(x + h)* so that plugging it in the formal
    definition becomes easier:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x plus h right-parenthesis equals left-parenthesis
    x plus h right-parenthesis squared plus 4 left-parenthesis x plus h right-parenthesis
    minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo>
    <mi>h</mi> <mo>)</mo></mrow> <mo>-</mo> <mn>2</mn></mrow></math>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x plus h right-parenthesis equals left-parenthesis
    x plus h right-parenthesis squared plus 4 left-parenthesis x plus h right-parenthesis
    minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo>
    <mi>h</mi> <mo>)</mo></mrow> <mo>-</mo> <mn>2</mn></mrow></math>
- en: <math alttext="f left-parenthesis x plus h right-parenthesis equals x squared
    plus 2 x h plus h squared plus 4 x plus 4 h minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mi>h</mi> <mo>+</mo> <msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>h</mi>
    <mo>-</mo> <mn>2</mn></mrow></math>
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x plus h right-parenthesis equals x squared
    plus 2 x h plus h squared plus 4 x plus 4 h minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mi>h</mi> <mo>+</mo> <msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>h</mi>
    <mo>-</mo> <mn>2</mn></mrow></math>
- en: 'Now, let’s plug f(x + h) into the definition:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction x squared plus 2 x h plus h squared plus
    4 x plus 4 h minus 2 minus x squared minus 4 x plus 2 Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>4</mn><mi>h</mi><mo>-</mo><mn>2</mn><mo>-</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>2</mn></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction x squared plus 2 x h plus h squared plus
    4 x plus 4 h minus 2 minus x squared minus 4 x plus 2 Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>4</mn><mi>h</mi><mo>-</mo><mn>2</mn><mo>-</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>2</mn></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
- en: 'Notice how there are many terms that can be simplified so that the formula
    becomes clearer. Remember, you are trying to find the limit for the moment, and
    the derivative is found after solving the limit:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction 2 x h plus h squared plus 4 h Over h
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>4</mn><mi>h</mi></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction 2 x h plus h squared plus 4 h Over h
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>4</mn><mi>h</mi></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
- en: 'The division by *h* gives further potential for simplification since you can
    divide all the terms in the numerator by the denominator *h*:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts 2 x plus h plus 4"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts 2 x plus h plus 4"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>+</mo> <mn>4</mn></mrow></math>
- en: 'It’s now time to solve the limit. Because the equation is simple, the first
    attempt is by substitution, which is, as you have guessed, possible. By substituting
    the variable *h* and making it zero (according to the limit), you are left with
    the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
- en: 'That is the derivative of the original function *f(x)*. If you want to find
    the derivative of the function when *x* = 2, you simply have to plug it in to
    the derivative function:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis 2 right-parenthesis equals 2 left-parenthesis
    2 right-parenthesis plus 4 equals 8"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mo>+</mo> <mn>4</mn> <mo>=</mo> <mn>8</mn></mrow></math>
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis 2 right-parenthesis equals 2 left-parenthesis
    2 right-parenthesis plus 4 equals 8"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mo>+</mo> <mn>4</mn> <mo>=</mo> <mn>8</mn></mrow></math>
- en: Take a look at the graph of the function that you have just solved. Figure 4-15
    shows the original function’s graph with the derivative (the straight line). Notice
    how *f'(2)* lies exactly at 8\. The slope of *f(x)* when *x* = 2 is 8.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph9.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15\. The original f(x) with its derivative f'(x)
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-423
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that when *f(x)* hits the bottom and starts rising, *f'(x)* crossed the
    zero line at -2\. This is a concept you will later in this chapter.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: You are unlikely to use the formal definition every time you want to find a
    derivative (which can be used on every function). There are derivative rules that
    allow you to save a lot of time through shortcuts. The first rule is referred
    to as the *power rule,* which is a way to find the derivative of functions with
    exponents.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common to also refer to derivatives using this notation (which is the
    same thing as *f''(x)*):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
- en: 'The power rule for finding derivatives is as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo>.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo>.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: 'Basically, what this means is that the derivative is found by multiplying the
    constant by the exponent and then subtracting 1 from the exponent. Here’s an example:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup></mrow></math>
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    1 times 4 right-parenthesis x Superscript left-parenthesis 4 minus 1 right-parenthesis
    Baseline equals 4 x cubed"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>×</mo>
    <mn>4</mn> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mo>(</mo><mn>4</mn><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msup>
    <mo>=</mo> <mn>4</mn> <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    1 times 4 right-parenthesis x Superscript left-parenthesis 4 minus 1 right-parenthesis
    Baseline equals 4 x cubed"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>×</mo>
    <mn>4</mn> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mo>(</mo><mn>4</mn><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msup>
    <mo>=</mo> <mn>4</mn> <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
- en: 'Remember that if there is no constant attached to the variable, it means that
    the constant is equal to 1\. Here’s a more complex example with the same principle:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals 2 x squared plus
    3 x Superscript 7 Baseline minus 2 x cubed"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>x</mi> <mn>7</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals 2 x squared plus
    3 x Superscript 7 Baseline minus 2 x cubed"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>x</mi> <mn>7</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 4 x plus
    21 x Superscript 6 Baseline minus 6 x squared"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>4</mn> <mi>x</mi>
    <mo>+</mo> <mn>21</mn> <msup><mi>x</mi> <mn>6</mn></msup> <mo>-</mo> <mn>6</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 4 x plus
    21 x Superscript 6 Baseline minus 6 x squared"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>4</mn> <mi>x</mi>
    <mo>+</mo> <mn>21</mn> <msup><mi>x</mi> <mn>6</mn></msup> <mo>-</mo> <mn>6</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'It is worth noting that the rule also applies to constants even though they
    do not satisfy the general form of the power rule. The derivative of a constant
    is zero. However, it helps to know why, but first, you must be aware of this mathematical
    concept:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi> <mn>0</mn></msup>
    <mo>=</mo> <mn>1</mn></mrow></math>
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi> <mn>0</mn></msup>
    <mo>=</mo> <mn>1</mn></mrow></math>
- en: 'With this being said, you can imagine constants as always being multiplied
    by *x* to the power of zero (since it does not change their value). Now, if you
    want to find the derivative of 17, here’s how it would go:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="17 equals 17 x Superscript 0 Baseline equals left-parenthesis
    0 times 17 right-parenthesis x Superscript 0 minus 1 Baseline equals 0 x Superscript
    negative 1 Baseline equals 0"><mrow><mn>17</mn> <mo>=</mo> <mn>17</mn> <msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>×</mo> <mn>17</mn>
    <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mn>0</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="17 equals 17 x Superscript 0 Baseline equals left-parenthesis
    0 times 17 right-parenthesis x Superscript 0 minus 1 Baseline equals 0 x Superscript
    negative 1 Baseline equals 0"><mrow><mn>17</mn> <mo>=</mo> <mn>17</mn> <msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>×</mo> <mn>17</mn>
    <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mn>0</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn></mrow></math>
- en: 'As you know, anything multiplied by zero returns zero as a result. This gives
    the constants rule for derivatives as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a right-parenthesis
    equals 0"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a right-parenthesis
    equals 0"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>
- en: You follow the same logic when encountering fractions or negative numbers in
    the exponents.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'The *product rule* of derivatives is useful when there are two functions multiplied
    by each other. The product rule is as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-bracket f left-parenthesis
    x right-parenthesis g left-parenthesis x right-parenthesis right-bracket equals
    f prime left-parenthesis x right-parenthesis g left-parenthesis x right-parenthesis
    plus f left-parenthesis x right-parenthesis g prime left-parenthesis x right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>=</mo> <msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>+</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-bracket f left-parenthesis
    x right-parenthesis g left-parenthesis x right-parenthesis right-bracket equals
    f prime left-parenthesis x right-parenthesis g left-parenthesis x right-parenthesis
    plus f left-parenthesis x right-parenthesis g prime left-parenthesis x right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>=</mo> <msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>+</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: 'Let’s take an example and find the derivative using the product rule:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
- en: 'The equation can clearly by segmented into two terms, *f(x)* and *g(x),* like
    this:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="g left-parenthesis x right-parenthesis equals left-parenthesis
    x cubed plus 1 right-parenthesis"><mrow><mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g left-parenthesis x right-parenthesis equals left-parenthesis
    x cubed plus 1 right-parenthesis"><mrow><mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
- en: 'Let’s find the derivatives of the two terms before applying the product rule.
    Notice that finding the derivative of *f(x)* and *g(x)* is easy once you have
    understood the power rule:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
- en: <math alttext="g prime left-parenthesis x right-parenthesis equals 3 x squared"><mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g prime left-parenthesis x right-parenthesis equals 3 x squared"><mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'When applying the product rule, you should get the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis 3 x squared right-parenthesis
    plus left-parenthesis 2 x right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>)</mo></mrow> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h prime left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis 3 x squared right-parenthesis
    plus left-parenthesis 2 x right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>)</mo></mrow> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals 3 x Superscript
    4 Baseline plus 6 x squared plus 2 x Superscript 4 Baseline plus 2 x"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h prime left-parenthesis x right-parenthesis equals 3 x Superscript
    4 Baseline plus 6 x squared plus 2 x Superscript 4 Baseline plus 2 x"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals 5 x Superscript
    4 Baseline plus 6 x squared plus 2 x"><mrow><msup><mi>h</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn> <msup><mi>x</mi>
    <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>2</mn> <mi>x</mi></mrow></math>
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h prime left-parenthesis x right-parenthesis equals 5 x Superscript
    4 Baseline plus 6 x squared plus 2 x"><mrow><msup><mi>h</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn> <msup><mi>x</mi>
    <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>2</mn> <mi>x</mi></mrow></math>
- en: Figure 4-16 shows the graph of *h(x)* and *h'(x)*.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph10.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16\. The original h(x) with its derivative h'(x)
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The next step is to see the *quotient rule,* which deals with the division
    of two functions. The formal definition is as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-bracket StartFraction
    f left-parenthesis x right-parenthesis Over g left-parenthesis x right-parenthesis
    EndFraction right-bracket equals StartFraction f prime left-parenthesis x right-parenthesis
    g left-parenthesis x right-parenthesis minus f left-parenthesis x right-parenthesis
    g prime left-parenthesis x right-parenthesis Over left-bracket g left-parenthesis
    x right-parenthesis right-bracket squared EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mstyle> <mo>]</mo></mrow>
    <mo>=</mo> <mfrac><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <msup><mrow><mo>[</mo><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>]</mo></mrow>
    <mn>2</mn></msup></mfrac></mrow></math>
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-bracket StartFraction
    f left-parenthesis x right-parenthesis Over g left-parenthesis x right-parenthesis
    EndFraction right-bracket equals StartFraction f prime left-parenthesis x right-parenthesis
    g left-parenthesis x right-parenthesis minus f left-parenthesis x right-parenthesis
    g prime left-parenthesis x right-parenthesis Over left-bracket g left-parenthesis
    x right-parenthesis right-bracket squared EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mstyle> <mo>]</mo></mrow>
    <mo>=</mo> <mfrac><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <msup><mrow><mo>[</mo><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>]</mo></mrow>
    <mn>2</mn></msup></mfrac></mrow></math>
- en: 'Let’s apply it into the following function:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    squared minus x plus 1 Over x squared plus 1 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow> <mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></math>
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    squared minus x plus 1 Over x squared plus 1 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow> <mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></math>
- en: 'As usual, it’s better to start by finding the derivatives of *f(x)* and *g(x)*
    which in this case are clearly separated, with *f(x)* being the nominator and
    *g(x)* being the denominator. When applying the quotient rule, you should get
    the following:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    left-parenthesis 2 x minus 1 right-parenthesis left-parenthesis x squared plus
    1 right-parenthesis minus left-parenthesis x squared minus x plus 1 right-parenthesis
    left-parenthesis 2 x right-parenthesis Over left-parenthesis x squared plus 1
    right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>)</mo></mrow></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    left-parenthesis 2 x minus 1 right-parenthesis left-parenthesis x squared plus
    1 right-parenthesis minus left-parenthesis x squared minus x plus 1 right-parenthesis
    left-parenthesis 2 x right-parenthesis Over left-parenthesis x squared plus 1
    right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>)</mo></mrow></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    2 x cubed plus 2 x minus x squared minus 1 minus 2 x cubed plus 2 x squared minus
    2 x Over left-parenthesis x squared plus 1 right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mo>-</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>1</mn><mo>-</mo><mn>2</mn><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>2</mn><mi>x</mi></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    2 x cubed plus 2 x minus x squared minus 1 minus 2 x cubed plus 2 x squared minus
    2 x Over left-parenthesis x squared plus 1 right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mo>-</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>1</mn><mo>-</mo><mn>2</mn><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>2</mn><mi>x</mi></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    x squared minus 1 Over left-parenthesis x squared plus 1 right-parenthesis squared
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>1</mn></mrow> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    x squared minus 1 Over left-parenthesis x squared plus 1 right-parenthesis squared
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>1</mn></mrow> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mfrac></mstyle></mrow></math>
- en: '*Exponential derivatives* deal with power rule applied to constants. Take a
    look at the following equation -- how would you find its derivative?'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals a Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>a</mi> <mi>x</mi></msup></mrow></math>
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals a Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>a</mi> <mi>x</mi></msup></mrow></math>
- en: 'Instead of the usual variable-base-constant-exponent, it is constant-base-variable-exponent.
    This is treated differently when trying to calculate the derivative. The formal
    definition is as follow:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction a Superscript x Baseline
    equals a Superscript x Baseline left-parenthesis ln a right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mi>a</mi> <mi>x</mi></msup> <mo>=</mo>
    <msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mi>a</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction a Superscript x Baseline
    equals a Superscript x Baseline left-parenthesis ln a right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mi>a</mi> <mi>x</mi></msup> <mo>=</mo>
    <msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mi>a</mi> <mo>)</mo></mrow></mrow></math>
- en: 'The following example shows how this is done:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction 4 Superscript x Baseline
    equals 4 Superscript x Baseline left-parenthesis ln 4 right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mn>4</mn> <mi>x</mi></msup> <mo>=</mo>
    <msup><mn>4</mn> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mn>4</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction 4 Superscript x Baseline
    equals 4 Superscript x Baseline left-parenthesis ln 4 right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mn>4</mn> <mi>x</mi></msup> <mo>=</mo>
    <msup><mn>4</mn> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mn>4</mn> <mo>)</mo></mrow></mrow></math>
- en: 'Euler’s number, mentioned earlier, has a special derivative. When it comes
    to finding the derivative of *e*, the answer is interesting:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction e Superscript x Baseline
    equals e Superscript x Baseline left-parenthesis ln e right-parenthesis equals
    e Superscript x"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>e</mi> <mi>x</mi></msup> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup>
    <mrow><mo>(</mo> <mo form="prefix">ln</mo> <mi>e</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction e Superscript x Baseline
    equals e Superscript x Baseline left-parenthesis ln e right-parenthesis equals
    e Superscript x"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>e</mi> <mi>x</mi></msup> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup>
    <mrow><mo>(</mo> <mo form="prefix">ln</mo> <mi>e</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
- en: This is because the natural log function and the exponential function are inverses
    of one another, so, the term *ln e* equals to 1\. Therefore, the derivative of
    the exponential function function *e* is itself.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'In parallel, let’s discuss logarithmic derivatives. By now, you should have
    known what exponents and logarithms are. The general definition for both types
    of logarithms is as follows:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction log Subscript a Baseline
    x equals StartFraction 1 Over x ln a EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msub><mo form="prefix">log</mo> <mi>a</mi></msub>
    <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>a</mi></mrow></mfrac></mrow></math>
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction log Subscript a Baseline
    x equals StartFraction 1 Over x ln a EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msub><mo form="prefix">log</mo> <mi>a</mi></msub>
    <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>a</mi></mrow></mfrac></mrow></math>
- en: <math alttext="StartFraction d y Over d x EndFraction ln x equals log Subscript
    e Baseline x equals StartFraction 1 Over x ln e EndFraction equals StartFraction
    1 Over x EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mo form="prefix">ln</mo> <mi>x</mi> <mo>=</mo> <msub><mo form="prefix">log</mo>
    <mi>e</mi></msub> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>e</mi></mrow></mfrac></mstyle> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction ln x equals log Subscript
    e Baseline x equals StartFraction 1 Over x ln e EndFraction equals StartFraction
    1 Over x EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mo form="prefix">ln</mo> <mi>x</mi> <mo>=</mo> <msub><mo form="prefix">log</mo>
    <mi>e</mi></msub> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>e</mi></mrow></mfrac></mstyle> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
- en: Notice how in the second derivative function of the natural logarithm, the term
    *ln e* is once again encountered, thus making simplification quite easy since
    it is equal to 1.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals 7 l o g 2 left-parenthesis
    x right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>7</mn> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals 7 l o g 2 left-parenthesis
    x right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>7</mn> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: 'Using the formal definition, the derivative of this logarithmic function is
    as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 7 left-parenthesis
    StartFraction 1 Over x ln 2 EndFraction right-parenthesis equals StartFraction
    7 Over x ln 2 EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>7</mn> <mrow><mo>(</mo> <mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>7</mn> <mrow><mi>x</mi><mo
    form="prefix">ln</mo><mn>2</mn></mrow></mfrac></mstyle></mrow></math>
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 7 left-parenthesis
    StartFraction 1 Over x ln 2 EndFraction right-parenthesis equals StartFraction
    7 Over x ln 2 EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>7</mn> <mrow><mo>(</mo> <mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>7</mn> <mrow><mi>x</mi><mo
    form="prefix">ln</mo><mn>2</mn></mrow></mfrac></mstyle></mrow></math>
- en: Note
  id: totrans-485
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that the logarithm *log* has a base of 10, but the natural logarithm
    *ln* has a base of *e* (~2.7182)
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: The natural logarithm and the log function are actually linearly related through
    simple multiplication. If you know the log of the constant *a*, you can find its
    natural logarithm *ln* by multiplying the log of *a* by 2.303.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'One major concept in derivatives is the *chain rule*. Let’s back up to the
    power rule, which deals with exponents on variables. Remember the following formula
    to find the derivative:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo>.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo>.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: 'This is a simplified version because there is only *x*, but the reality is
    that you must multiply by the derivative of the term under the exponent. Until
    now, you have seen only *x* as the variable under the exponent. The derivative
    of *x* is 1, which is why it is simplified and rendered invisible. However, with
    more complex functions such as this one:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    4 x plus 1 right-parenthesis squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mrow><mo>(</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></math>
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    4 x plus 1 right-parenthesis squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mrow><mo>(</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></math>
- en: 'The derivative of the function is found by following these two steps:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Find the derivative of the outside function without touching the inside function.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the derivative of the inside function and multiply it by the rest of the
    function.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The solution is therefore as follows (knowing that the derivative of *4x +
    1* is just 4):'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 left-parenthesis
    4 x plus 1 right-parenthesis .4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>.</mo> <mn>4</mn></mrow></math>
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 left-parenthesis
    4 x plus 1 right-parenthesis .4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>.</mo> <mn>4</mn></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 8 left-parenthesis
    4 x plus 1 right-parenthesis"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>8</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 8 left-parenthesis
    4 x plus 1 right-parenthesis"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>8</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 32 x plus
    8"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>32</mn> <mi>x</mi> <mo>+</mo> <mn>8</mn></mrow></math>
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 32 x plus
    8"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>32</mn> <mi>x</mi> <mo>+</mo> <mn>8</mn></mrow></math>
- en: 'The same applies with the exponential functions. Take the following example:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals e Superscript
    x Baseline left-parenthesis 1 right-parenthesis equals e Superscript x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup> <mrow><mo>(</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup></mrow></math>
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals e Superscript
    x Baseline left-parenthesis 1 right-parenthesis equals e Superscript x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup> <mrow><mo>(</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup></mrow></math>
- en: The chain rule can actually be considered as a master rule as it applies anywhere
    even in the product rule and the quotient rule.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: There are more concepts to master in derivatives, but as this book is not meant
    to be a full calculus masterclass, you should at least know the meaning of a derivative,
    how it is found, what does it represent, and how can it be used in machine and
    deep learning.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-504
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key points of this section on derivatives are as follow:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: A derivative measures the change in a function given a change of one or more
    of its inputs.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power rule is used to find the derivative of a function raised to a power.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product rule is used to find the derivative of two functions that are multiplied
    together.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quotient rule is used to find the derivative of two functions that are divided
    by each other.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain rule is the master rule used in differentiating (which means the process
    of finding the derivative). Due to simplicity, it is often overlooked.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives play a crucial role in machine learning such as enabling optimization
    techniques, aiding model training, and enhancing the interpretability of the models.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrals and the Fundamental Theorem of Calculus
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *integral* is an operation that represents the area under a curve of a function
    given an interval. It is the inverse of a derivative, which is why it is also
    called an *anti-derivative*.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The process of finding integrals is called *integration*. Integrals can be used
    to find areas below a curve and they are also heavily used in the world of finance
    such as risk management, portfolio management, probabilistic methods, and even
    option pricing.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The most basic way of understanding an integral is by thinking of calculating
    an area below the curve of a function. This can also be done by manually, calculating
    different changes in the *x*-axis, but it won’t be accurate (accuracy increases
    as you add up much smaller slices). Therefore, as the size of the slices approaches
    zero, the accuracy of the area gets better. Since this is a tedious process, integrals
    are here for the rescue.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that an integral is the inverse of a derivative. This is important
    because it implies a direct relationship between the two. The basic definition
    of an integral is as follows:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral f left-parenthesis x right-parenthesis d x equals upper
    F left-parenthesis upper X right-parenthesis plus upper C"><mrow><mo>∫</mo> <mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mo>(</mo>
    <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral f left-parenthesis x right-parenthesis d x equals upper
    F left-parenthesis upper X right-parenthesis plus upper C"><mrow><mo>∫</mo> <mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mo>(</mo>
    <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>C</mi></mrow></math>
- en: <math alttext="upper T h e integral s y m b o l r e p r e s e n t s t h e i
    n t e g r a t i o n p r o c e s s"><mrow><mi>T</mi> <mi>h</mi> <mi>e</mi> <mo>∫</mo>
    <mi>s</mi> <mi>y</mi> <mi>m</mi> <mi>b</mi> <mi>o</mi> <mi>l</mi> <mi>r</mi> <mi>e</mi>
    <mi>p</mi> <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>s</mi>
    <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>e</mi> <mi>g</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>p</mi> <mi>r</mi>
    <mi>o</mi> <mi>c</mi> <mi>e</mi> <mi>s</mi> <mi>s</mi></mrow></math>
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper T h e integral s y m b o l r e p r e s e n t s t h e i
    n t e g r a t i o n p r o c e s s"><mrow><mi>T</mi> <mi>h</mi> <mi>e</mi> <mo>∫</mo>
    <mi>s</mi> <mi>y</mi> <mi>m</mi> <mi>b</mi> <mi>o</mi> <mi>l</mi> <mi>r</mi> <mi>e</mi>
    <mi>p</mi> <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>s</mi>
    <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>e</mi> <mi>g</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>p</mi> <mi>r</mi>
    <mi>o</mi> <mi>c</mi> <mi>e</mi> <mi>s</mi> <mi>s</mi></mrow></math>
- en: <math alttext="f left-parenthesis x right-parenthesis i s t h e d e r i v a
    t i v e o f t h e g e n e r a l f u n c t i o n upper F left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>i</mi> <mi>s</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi>
    <mi>d</mi> <mi>e</mi> <mi>r</mi> <mi>i</mi> <mi>v</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>o</mi> <mi>f</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>g</mi>
    <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>r</mi> <mi>a</mi> <mi>l</mi> <mi>f</mi> <mi>u</mi>
    <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>F</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></math>
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis i s t h e d e r i v a
    t i v e o f t h e g e n e r a l f u n c t i o n upper F left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>i</mi> <mi>s</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi>
    <mi>d</mi> <mi>e</mi> <mi>r</mi> <mi>i</mi> <mi>v</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>o</mi> <mi>f</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>g</mi>
    <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>r</mi> <mi>a</mi> <mi>l</mi> <mi>f</mi> <mi>u</mi>
    <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>F</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></math>
- en: <math alttext="upper C r e p r e s e n t s t h e l o s t c o n s t a n t i n
    t h e d i f f e r e n t i a t i o n p r o c e s s"><mrow><mi>C</mi> <mi>r</mi>
    <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi>
    <mi>s</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>l</mi> <mi>o</mi> <mi>s</mi> <mi>t</mi>
    <mi>c</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>n</mi> <mi>t</mi>
    <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>d</mi> <mi>i</mi> <mi>f</mi>
    <mi>f</mi> <mi>e</mi> <mi>r</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>i</mi> <mi>a</mi>
    <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi>
    <mi>e</mi> <mi>s</mi> <mi>s</mi></mrow></math>
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C r e p r e s e n t s t h e l o s t c o n s t a n t i n
    t h e d i f f e r e n t i a t i o n p r o c e s s"><mrow><mi>C</mi> <mi>r</mi>
    <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi>
    <mi>s</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>l</mi> <mi>o</mi> <mi>s</mi> <mi>t</mi>
    <mi>c</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>n</mi> <mi>t</mi>
    <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>d</mi> <mi>i</mi> <mi>f</mi>
    <mi>f</mi> <mi>e</mi> <mi>r</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>i</mi> <mi>a</mi>
    <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi>
    <mi>e</mi> <mi>s</mi> <mi>s</mi></mrow></math>
- en: <math alttext="d x r e p r e s e n t s s l i c i n g a l o n g x a s i t a p
    p r o a c h e s z e r o"><mrow><mi>d</mi> <mi>x</mi> <mi>r</mi> <mi>e</mi> <mi>p</mi>
    <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>s</mi> <mi>s</mi>
    <mi>l</mi> <mi>i</mi> <mi>c</mi> <mi>i</mi> <mi>n</mi> <mi>g</mi> <mi>a</mi> <mi>l</mi>
    <mi>o</mi> <mi>n</mi> <mi>g</mi> <mi>x</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi>
    <mi>a</mi> <mi>p</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>a</mi> <mi>c</mi> <mi>h</mi>
    <mi>e</mi> <mi>s</mi> <mi>z</mi> <mi>e</mi> <mi>r</mi> <mi>o</mi></mrow></math>
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="d x r e p r e s e n t s s l i c i n g a l o n g x a s i t a p
    p r o a c h e s z e r o"><mrow><mi>d</mi> <mi>x</mi> <mi>r</mi> <mi>e</mi> <mi>p</mi>
    <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>s</mi> <mi>s</mi>
    <mi>l</mi> <mi>i</mi> <mi>c</mi> <mi>i</mi> <mi>n</mi> <mi>g</mi> <mi>a</mi> <mi>l</mi>
    <mi>o</mi> <mi>n</mi> <mi>g</mi> <mi>x</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi>
    <mi>a</mi> <mi>p</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>a</mi> <mi>c</mi> <mi>h</mi>
    <mi>e</mi> <mi>s</mi> <mi>z</mi> <mi>e</mi> <mi>r</mi> <mi>o</mi></mrow></math>
- en: 'What the preceding equation means is that the integral of *f(x)* is the general
    function *F(x)* plus a constant *C* which was lost initially in the initial differentiation
    process. Here’s an example to better explain the need to put in the constant:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    5"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>5</mn></mrow></math>
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    5"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>5</mn></mrow></math>
- en: 'Calculating its derivative, you get the following result:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
- en: Now, what if you wanted to integrate it so that you go back to the original
    function (which in this case is represented by the capital letter *F(x)* instead
    of *f(x)*)?
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>x</mi> <mi>d</mi>
    <mi>x</mi></mrow></math>
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>x</mi> <mi>d</mi>
    <mi>x</mi></mrow></math>
- en: 'Normally, having seen the differentiation process (which means taking the derivative),
    you would return 2 as the exponent, which gives you the following answer:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x equals x squared"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x d x equals x squared"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'This does not look like the original function. It’s missing the constant 5\.
    But you have no way of knowing that or even if you knew there was a constant,
    what is it? 1? 2? 677? This is why a constant *C* is added in the integration
    process so that it represents the lost constant. Therefore, the answer to the
    integration problem is as follows:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x equals x squared plus upper C"><mrow><mo>∫</mo>
    <mn>2</mn> <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x d x equals x squared plus upper C"><mrow><mo>∫</mo>
    <mn>2</mn> <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mi>C</mi></mrow></math>
- en: Note
  id: totrans-533
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Up until now, the discussion has been limited to *indefinite integrals* where
    the integration symbol is *naked* (which means there are no boundaries to it).
    You will see what this means right after defining the necessary rules to complete
    the integration.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'For the power function (just like the previous function), the general rule
    for integration is as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral x Superscript a Baseline d x equals StartFraction x
    Superscript a plus 1 Baseline Over a plus 1 EndFraction plus upper C"><mrow><mo>∫</mo>
    <msup><mi>x</mi> <mi>a</mi></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><msup><mi>x</mi> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msup>
    <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral x Superscript a Baseline d x equals StartFraction x
    Superscript a plus 1 Baseline Over a plus 1 EndFraction plus upper C"><mrow><mo>∫</mo>
    <msup><mi>x</mi> <mi>a</mi></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><msup><mi>x</mi> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msup>
    <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'This is much simpler than it looks. You are simply reversing the power rule
    you saw earlier. Consider the following example:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x Superscript 6 d x"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi></mrow></math>
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x Superscript 6 d x"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi></mrow></math>
- en: <math alttext="integral 2 x Superscript 6 Baseline d x equals StartFraction
    2 x Superscript 7 Baseline Over 7 EndFraction plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>7</mn></msup></mrow>
    <mn>7</mn></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x Superscript 6 Baseline d x equals StartFraction
    2 x Superscript 7 Baseline Over 7 EndFraction plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>7</mn></msup></mrow>
    <mn>7</mn></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
- en: <math alttext="integral 2 x Superscript 6 Baseline d x equals two-sevenths x
    Superscript 7 Baseline plus upper C"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x Superscript 6 Baseline d x equals two-sevenths x
    Superscript 7 Baseline plus upper C"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'To verify your answer, you can find the derivative of the result (using the
    power rule):'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals two-sevenths
    x Superscript 7 Baseline plus upper C"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals two-sevenths
    x Superscript 7 Baseline plus upper C"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    7 right-parenthesis two-sevenths x Superscript 7 minus 1 Baseline plus 0"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mn>7</mn> <mo>)</mo></mrow> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mrow><mn>7</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>+</mo> <mn>0</mn></mrow></math>
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    7 right-parenthesis two-sevenths x Superscript 7 minus 1 Baseline plus 0"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mn>7</mn> <mo>)</mo></mrow> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mrow><mn>7</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>+</mo> <mn>0</mn></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x Superscript
    6"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>6</mn></msup></mrow></math>
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x Superscript
    6"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>6</mn></msup></mrow></math>
- en: 'Let’s take another example. Consider the following integration problem:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>d</mi> <mi>x</mi></mrow></math>
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>d</mi> <mi>x</mi></mrow></math>
- en: 'Naturally, using the rule, you should find the following result:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 d x equals 2 x plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 d x equals 2 x plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'Let’s move on to *definite integrals,* which are integrals with numbers on
    top and bottom that represent intervals below a curve of a function. Hence, *indefinite*
    integrals find the area under the curve everywhere but definite integrals are
    bounded within an interval given by point *a* and point *b*. The general definition
    of indefinite integrals is as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral Subscript a Superscript b Baseline f left-parenthesis
    x right-parenthesis d x equals upper F left-parenthesis upper B right-parenthesis
    minus upper F left-parenthesis upper A right-parenthesis"><mrow><msubsup><mo>∫</mo>
    <mi>a</mi> <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>B</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>A</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral Subscript a Superscript b Baseline f left-parenthesis
    x right-parenthesis d x equals upper F left-parenthesis upper B right-parenthesis
    minus upper F left-parenthesis upper A right-parenthesis"><mrow><msubsup><mo>∫</mo>
    <mi>a</mi> <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>B</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>A</mi> <mo>)</mo></mrow></mrow></math>
- en: 'This is as simple as it gets. You will solve the integral, then plug in the
    two numbers and subtract the two functions from each other. Consider the following
    evaluation of an integral (integral solving is commonly referred to as *evaluating*
    the integral):'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral Subscript 0 Superscript 6 Baseline 3 x squared minus
    10 x plus 4 d x"><mrow><msubsup><mo>∫</mo> <mn>0</mn> <mn>6</mn></msubsup> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>d</mi> <mi>x</mi></mrow></math>
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral Subscript 0 Superscript 6 Baseline 3 x squared minus
    10 x plus 4 d x"><mrow><msubsup><mo>∫</mo> <mn>0</mn> <mn>6</mn></msubsup> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>d</mi> <mi>x</mi></mrow></math>
- en: 'The first step is to understand what is being asked. From the definition of
    integrals, it seems that the area between [0, 2] on the *x*-axis is to be calculated
    using the given function:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket x cubed minus 5 x squared plus 4 x plus upper C right-bracket right-parenthesis
    vertical-bar Subscript 0 Baseline Superscript 6 Baseline"><mrow><mi>F</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>4</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow>
    <msubsup><mrow><mo>|</mo></mrow> <mn>0</mn> <mn>6</mn></msubsup></mrow></math>
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket x cubed minus 5 x squared plus 4 x plus upper C right-bracket right-parenthesis
    vertical-bar Subscript 0 Baseline Superscript 6 Baseline"><mrow><mi>F</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>4</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow>
    <msubsup><mrow><mo>|</mo></mrow> <mn>0</mn> <mn>6</mn></msubsup></mrow></math>
- en: 'To evaluate the integral at the given points, simply plug in the values as
    follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 6 cubed minus 5 left-parenthesis 6 right-parenthesis squared plus
    4 left-parenthesis 6 right-parenthesis plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 cubed minus 5 left-parenthesis 0 right-parenthesis
    squared plus 4 left-parenthesis 0 right-parenthesis plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mn>6</mn> <mn>3</mn></msup>
    <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <mrow><mo>(</mo> <mrow><mo>[</mo>
    <msup><mn>0</mn> <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 6 cubed minus 5 left-parenthesis 6 right-parenthesis squared plus
    4 left-parenthesis 6 right-parenthesis plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 cubed minus 5 left-parenthesis 0 right-parenthesis
    squared plus 4 left-parenthesis 0 right-parenthesis plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mn>6</mn> <mn>3</mn></msup>
    <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <mrow><mo>(</mo> <mrow><mo>[</mo>
    <msup><mn>0</mn> <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 216 minus 180 plus 24 plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 minus 0 plus 0 plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo>
    <mo>(</mo> <mo>[</mo> <mn>216</mn> <mo>-</mo> <mn>180</mn> <mo>+</mo> <mn>24</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>-</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 216 minus 180 plus 24 plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 minus 0 plus 0 plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo>
    <mo>(</mo> <mo>[</mo> <mn>216</mn> <mo>-</mo> <mn>180</mn> <mo>+</mo> <mn>24</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>-</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 60 plus upper C right-bracket right-parenthesis minus left-parenthesis
    left-bracket 0 plus upper C right-bracket right-parenthesis"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mo>[</mo> <mn>60</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 60 plus upper C right-bracket right-parenthesis minus left-parenthesis
    left-bracket 0 plus upper C right-bracket right-parenthesis"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mo>[</mo> <mn>60</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    60 minus 0 right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo>
    <mo>=</mo> <mo>(</mo> <mn>60</mn> <mo>-</mo> <mn>0</mn> <mo>)</mo></mrow></math>
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    60 minus 0 right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo>
    <mo>=</mo> <mo>(</mo> <mn>60</mn> <mo>-</mo> <mn>0</mn> <mo>)</mo></mrow></math>
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals 60"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>60</mn></mrow></math>
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals 60"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>60</mn></mrow></math>
- en: Note
  id: totrans-561
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The constant *C* will always cancel out in definite integrals so you can leave
    it out in this kind of problems.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the area below the graph of *f(x)* and above the *x*-axis, as well
    as between [0, 6] on the *x*-axis, is equal to 60 square units. The following
    shows a few rules of thumb on integrals (after all, this chapter is supposed to
    refresh your knowledge or to give you a basic understanding of a few key mathematical
    concepts):'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the integral of a constant:'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral a d x equals a x plus upper C"><mrow><mo>∫</mo> <mi>a</mi>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>a</mi> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral a d x equals a x plus upper C"><mrow><mo>∫</mo> <mi>a</mi>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>a</mi> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'To find the integral of a variable:'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral x d x equals one-half x squared plus upper C"><mrow><mo>∫</mo>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral x d x equals one-half x squared plus upper C"><mrow><mo>∫</mo>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'To find the integral of a reciprocal:'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral StartFraction 1 Over x EndFraction d x equals ln StartAbsoluteValue
    x EndAbsoluteValue plus upper C"><mrow><mo>∫</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mo form="prefix">ln</mo> <mrow><mo>|</mo> <mi>x</mi>
    <mo>|</mo></mrow> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral StartFraction 1 Over x EndFraction d x equals ln StartAbsoluteValue
    x EndAbsoluteValue plus upper C"><mrow><mo>∫</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mo form="prefix">ln</mo> <mrow><mo>|</mo> <mi>x</mi>
    <mo>|</mo></mrow> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'To find the integral of an exponential:'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral a Superscript x Baseline d x equals StartFraction a
    Superscript x Baseline Over ln left-parenthesis a right-parenthesis EndFraction
    plus upper C"><mrow><mo>∫</mo> <msup><mi>a</mi> <mi>x</mi></msup> <mi>d</mi> <mi>x</mi>
    <mo>=</mo> <mfrac><msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo form="prefix">ln</mo><mo>(</mo><mi>a</mi><mo>)</mo></mrow></mfrac>
    <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral a Superscript x Baseline d x equals StartFraction a
    Superscript x Baseline Over ln left-parenthesis a right-parenthesis EndFraction
    plus upper C"><mrow><mo>∫</mo> <msup><mi>a</mi> <mi>x</mi></msup> <mi>d</mi> <mi>x</mi>
    <mo>=</mo> <mfrac><msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo form="prefix">ln</mo><mo>(</mo><mi>a</mi><mo>)</mo></mrow></mfrac>
    <mo>+</mo> <mi>C</mi></mrow></math>
- en: <math alttext="integral e Superscript x Baseline d x equals e Superscript x
    Baseline plus upper C"><mrow><mo>∫</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mi>d</mi>
    <mi>x</mi> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral e Superscript x Baseline d x equals e Superscript x
    Baseline plus upper C"><mrow><mo>∫</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mi>d</mi>
    <mi>x</mi> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'The *fundamental theorem of calculus* links derivatives with integrals. This
    means that it defines derivatives in terms of integrals and vice versa. The fundamental
    theorem of calculus is actually made up of two parts:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Part I
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the fundamental theorem of calculus states that if you have
    a continuous function *f(x)*, then the original function *F(x)* defined as the
    antiderivative of *f(x)* from a fixed starting point *a* up to *x*, is a function
    that is differentiable everywhere from *a* to *x*, and its derivative is simply
    *f(x)* evaluated at *x*.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Part II
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the fundamental theorem of calculus states that if you have
    a function *f(x)* that is continuous over a certain interval [*a, b*], and you
    define a new function *F(x)* as the integral of *f(x)* from *a* to *x*, then the
    definite integral of *f(x)* over that same interval [*a, b*] can be calculated
    as *F(b) - F(a)*.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'The theorem is useful in many fields including physics and engineering, but
    optimization and other mathematical models also benefit from it. Some examples
    of using integrals in the different learning algorithms can be summed up as follows:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Density estimation
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are used in *density estimation*, a part of many machine learning
    algorithms, to calculate the probability density function.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcement learning
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are used in reinforcement learning to calculate expected values of
    reward functions. Reinforcement learning is covered in Chapter 10.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: Bayesian models
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are used in *Bayesian inference*, a statistical framework for modeling
    uncertainty.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-585
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key points of this section on integrals are as follow:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are also known as antiderivatives and they are the opposite of derivatives.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indefinite integrals find the area under the curve everywhere while definite
    integrals are bounded within an interval given by point *a* and point *b*.
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamental theorem of calculus is the bridge between derivatives and integrals.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrals are used in machine learning for modeling uncertainty, making predictions,
    and estimating expected values.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several machine and deep learning algorithms depend on optimization techniques
    to decrease error functions. This section discusses a primordial concept in the
    different learning algorithms.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimization* is the process of finding the best solution among the possible
    solutions’ universe. Optimization is all about finding the highest and lowest
    points of a function. Figure 4-17 shows the graph for the following formula:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4
    Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4
    Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
- en: '![](Images/dlf_graph18.png)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17\. The graph of the function
  id: totrans-596
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *local minimum* exists when values on the right of the *x*-axis are decreasing
    until reaching a point where they start increasing. The point does not have to
    necessarily be the lowest point in the function, hence the name *local*. In Figure
    4-18, the function has a local minimum at point A.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: A *local maximum* exists when values on the right of the x-axis are increasing
    until reaching a point where they start decreasing. The point does not have to
    necessarily be the highest point in the function. In Figure 4-18, the function
    has a local maximum at point B.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: A *global minimum* exists when values on the right of the x-axis are decreasing
    until reaching a point where they start increasing. The point must be the lowest
    point in the function hence the name global. In Figure 4-18, the function has
    a global minimum at point C.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: A *global maximum* exists when values on the right of the x-axis are increasing
    until reaching a point where they start decreasing without. The point must be
    the highest point in the function. In Figure 4-18, there is no global maximum,
    as the function will continue infinitely without shaping a top. You can clearly
    see how the function accelerates upwards.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with machine and deep learning models, the aim is to find model
    parameters (or inputs) that minimize what is known as a *loss function* (a function
    that gives the error of forecasts). If the loss function is convex, optimization
    techniques should find the parameters that tend towards the global minimum where
    the loss function is minimized. Furthermore, if the loss function is non-convex,
    the convergence is not guaranteed, and the optimization may only lead towards
    approaching a local minimum, which is a part of the aim, but this leaves the global
    minimum which is the final aim.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: 'But how are these minima and maxima found? Let’s look at it step by step:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to perform the first derivative test (which is simply calculating
    the derivative of the function). Then, setting the function equal to zero and
    solving for *x* will give what is known as critical points. *Critical points*
    are the points where the function changes direction (the values stop going in
    one direction and start going in another). Therefore, these points are maxima
    and minima.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is to perform the second derivative test (which is simply calculating
    the derivative of the derivative). Then, setting the function equal to zero and
    solving for *x* will give what is known as inflection points. *Inflection points*
    give where the function is concave up and where it is concave down.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In other words, critical points are where the function changes direction and
    inflection points are where the function changes its concavity. Figure 4-19 shows
    the difference between a concave up function and a concave down function.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph19.png)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
- en: Figure 4-18\. A concave up versus a concave down functions
  id: totrans-607
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: <math alttext="upper C o n c a v e u p f u n c t i o n equals x squared"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>c</mi> <mi>a</mi> <mi>v</mi> <mi>e</mi> <mi>u</mi> <mi>p</mi>
    <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C o n c a v e u p f u n c t i o n equals x squared"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>c</mi> <mi>a</mi> <mi>v</mi> <mi>e</mi> <mi>u</mi> <mi>p</mi>
    <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: <math alttext="upper C o n c a v e d o w n f u n c t i o n equals minus x squared"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>c</mi> <mi>a</mi> <mi>v</mi> <mi>e</mi> <mi>d</mi> <mi>o</mi>
    <mi>w</mi> <mi>n</mi> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi>
    <mi>o</mi> <mi>n</mi> <mo>=</mo> <mo>-</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C o n c a v e d o w n f u n c t i o n equals minus x squared"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>c</mi> <mi>a</mi> <mi>v</mi> <mi>e</mi> <mi>d</mi> <mi>o</mi>
    <mi>w</mi> <mi>n</mi> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi>
    <mi>o</mi> <mi>n</mi> <mo>=</mo> <mo>-</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'The steps to find the extrema are as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Find the first derivative and set it to zero.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the first derivative to find *x*. The values are called critical points
    and they represent the points where the function changes the direction.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug in values in the formula that are either below or above the critical points.
    If the result of the first derivative is positive it means that it’s increasing
    around that point and if it’s negative, then it means that it’s decreasing around
    that point.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the second derivative and set it to zero.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the second derivative to find *x*. The values, called inflection points, represent
    the points where concavity changes from up to down and vice versa.
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug in values in the formula that are either below or above the inflection
    points. If the result of the second derivative is positive, it means there is
    a minimum at that point, and if it’s negative it means there is a maximum at that
    point.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to understand that the first derivative and second derivative
    tests relate to critical points as opposed to the second derivative test relating
    to inflection points. The following example finds the extrema of the function:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    x plus 4"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    x plus 4"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
- en: 'The first step is to take the first derivative, set it to zero, and solve for
    *x*:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    1"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    1"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
- en: <math alttext="2 x plus 1 equals 0"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 x plus 1 equals 0"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <mn>0</mn></mrow></math>
- en: <math alttext="x equals negative one-half"><mrow><mi>x</mi> <mo>=</mo> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></math>
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals negative one-half"><mrow><mi>x</mi> <mo>=</mo> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></math>
- en: 'Therefore, there is a critical point at that value. Now, the next step is to
    find the second derivative:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f double-prime left-parenthesis x right-parenthesis equals 2"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f double-prime left-parenthesis x right-parenthesis equals 2"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn></mrow></math>
- en: 'Next, the critical point must be plugged into the second derivative formula:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f double-prime left-parenthesis negative one-half right-parenthesis
    equals 2"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f double-prime left-parenthesis negative one-half right-parenthesis
    equals 2"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn></mrow></math>
- en: The second derivative is positive at the critical point. This means that there
    is a local minimum at that point.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, you will see more complex optimization techniques such
    as the gradient descent and the stochastic gradient descent, which are fairly
    common in machine learning algorithms.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-629
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key points of this section on optimization are as follow:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: Optimization is the process of finding the function’s extrema
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical points are the points where the function changes direction (the values
    stop going in one direction and start going in another)
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inflection points give where the function is concave up and where it is concave
    down.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A loss function is a function that measures the error of forecasts in predictive
    machine learning. It needs to be minimized in order to increase the accuracy of
    the model. Optimization of the loss function can be done through the discussed
    ways or through what is known as a gradient, a technique out of scope of the book.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chapters 2, 3, and 4 have presented the main numerical concepts that you need
    to start understanding basic machine and deep learning models. I have made all
    reasonable efforts to simplify as much as possible the technical requirements,
    I do encourage you to read these three chapters at least twice so that everything
    you have learned becomes a second nature.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, such a complex field requires more in-depth knowledge in mathematics,
    but I believe that with the concepts seen in this chapter, you may start discovering
    and building the models in Python. After all, they come pre-built from packages
    and libraries, and the aim of this chapter is to understand what you are working
    with It is unlikely that you will build the models from scratch using archaic
    tools.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have gained a certain understanding of data science and the
    mathematical requirements that will get you started comfortably.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.xhtml#idm46147468230768-marker)) Matrices can also contain symbols
    and expressions but for the sake of simplicity, let’s stick to numbers.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
