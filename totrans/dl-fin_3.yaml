- en: Chapter 4\. Linear Algebra and Calculus for Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algebra and calculus are pillars of data science, especially the learning algorithms
    which are based on concepts from these two mathematical fields. This chapter presents
    some key algebra and calculus topics in a way that everyone can understand.
  prefs: []
  type: TYPE_NORMAL
- en: It helps to know why you’re learning something. This way, you gain the motivation
    to continue and you know which way to point your focus.
  prefs: []
  type: TYPE_NORMAL
- en: '*Algebra *is the study of operations and relational rules, as well as the constructions
    and ideas that result from them. Algebra covers topics such as linear equations
    and matrices. You can consider algebra as the first step towards calculus.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Calculus *is the study of curve slopes and rates of change. Calculus covers
    topics such as derivatives and integrals. It is heavily used in many fields such
    as economics and engineering. Different learning algorithms rely on the concepts
    of calculus to perform their complex operations.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between the two is that while calculus works with ideas of change,
    motion, and accumulation, algebra deals with mathematical symbols and the rules
    for manipulating those symbols. Calculus focuses on the characteristics and behavior
    of changing functions, while algebra offers the foundation for solving equations
    and comprehending functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Heading to Come]'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vectors and Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *vector* is an object that has a magnitude (length) and a direction (arrowhead).
    The basic representation of a vector is an arrow with coordinates on the axis.
    But first, let’s see what an axis is.
  prefs: []
  type: TYPE_NORMAL
- en: The x-axis and y-axis are perpendicular lines that specify a plane’s boundaries
    and the locations of different points within them in a two-dimensional Cartesian
    coordinate system. The x-axis is horizontal and the y-axis is vertical.
  prefs: []
  type: TYPE_NORMAL
- en: These axes may represent vectors, with the x-axis representing the vector’s
    horizontal component and the y-axis representing its vertical component.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-1 shows a simple 2-dimensional Cartesian coordinate system with both
    axes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. 2-dimensional Cartesian coordinate system
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The 2-dimensional Cartesian coordinate system uses simple parentheses to show
    the location of different points following this order:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P o i n t c o o r d i n a t e s equals left-parenthesis
    h o r i z o n t a l l o c a t i o n left-parenthesis x right-parenthesis comma
    v e r t i c a l l o c a t i o n left-parenthesis y right-parenthesis right-parenthesis"><mrow><mi>P</mi>
    <mi>o</mi> <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>c</mi> <mi>o</mi> <mi>o</mi> <mi>r</mi>
    <mi>d</mi> <mi>i</mi> <mi>n</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>s</mi> <mo>=</mo>
    <mo>(</mo> <mi>h</mi> <mi>o</mi> <mi>r</mi> <mi>i</mi> <mi>z</mi> <mi>o</mi> <mi>n</mi>
    <mi>t</mi> <mi>a</mi> <mi>l</mi> <mi>l</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>t</mi>
    <mi>i</mi> <mi>o</mi> <mi>n</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mi>v</mi>
    <mi>e</mi> <mi>r</mi> <mi>t</mi> <mi>i</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mi>l</mi>
    <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mo>(</mo>
    <mi>y</mi> <mo>)</mo> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you want to draw point A which has (2, 3) as coordinates, you
    are likely to look at a graph from point zero, move two points to the right and
    from there, three points upwards. The result of the point should look like Figure
    4-2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. The location of A on the coordinate system
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s now add another point and draw a vector between them. Suppose you have
    also point B with (4, 5) as coordinates. Naturally, as the coordinates of B are
    both higher than the coordinates of A, you would expect vector AB to be upwards
    sloping. Figure 4-3 shows the new point B and vector AB.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Vector AB joining A and B points together in magnitude and direction
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, having drawn the vector using the coordinates of both points, how
    would you refer to the vector? Simply put, vector AB has its own coordinates that
    represent it. Remember that the vector is a representation of the movement from
    point A to point B. This means the 2-point movement along the X-axis and the Y-axis
    is the vector. Mathematically, to find the vector, you should subtract the two
    coordinate points from each other while respecting the direction. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Vector AB* means that you are going from A to B, therefore, you need to subtract
    the coordinates of point B from the coordinates of point A:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math><mrow><mover><mrow><mi>A</mi> <mi>B</mi></mrow> <mo stretchy="true" style="math-style:normal;math-depth:0;">→</mo></mover>
    <mo>=</mo> <mo><</mo> <mn>4</mn> <mo>−</mo> <mn>2,5</mn> <mo>−</mo> <mn>3</mn>
    <mo>></mo></mrow></math><math><mrow><mover><mrow><mi>A</mi> <mi>B</mi></mrow>
    <mo stretchy="true" style="math-style:normal;math-depth:0;">→</mo></mover> <mo>=</mo>
    <mo><</mo> <mn>2,2</mn> <mo>></mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '*Vector BA* means that you are going from B to A, therefore, you need to subtract
    the coordinates of point A from the coordinates of point B:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="ModifyingAbove upper B upper A With right-arrow equals less-than
    2 minus 4 comma 3 minus 5 greater-than"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mo><</mo> <mn>2</mn> <mo>-</mo> <mn>4</mn> <mo>,</mo>
    <mn>3</mn> <mo>-</mo> <mn>5</mn> <mo>></mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="ModifyingAbove upper B upper A With right-arrow equals less-than
    negative 2 comma negative 2 greater-than"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mo><</mo> <mo>-</mo> <mn>2</mn> <mo>,</mo> <mo>-</mo>
    <mn>2</mn> <mo>></mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: To interpret AB and BA vectors, you think in terms of movement. AB vector represents
    going from point A to point B, two positive points horizontally and vertically
    (right and upwards respectively). BA vector represents going from point B to point
    A, two negative points horizontally and vertically (left and downwards respectively).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vectors AB and BA are not the same thing even though they share the same slope.
    But what is a slope anyway?
  prefs: []
  type: TYPE_NORMAL
- en: 'The *slope* is the ratio of the vertical change between two points on the line
    to the horizontal change between the same two points. You calculate the slope
    using this mathematical formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S l o p e equals StartFraction left-parenthesis normal
    upper Delta upper Y right-parenthesis Over left-parenthesis normal upper Delta
    upper X right-parenthesis EndFraction"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi>
    <mi>p</mi> <mi>e</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>(</mo><mi>Δ</mi><mi>Y</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>Δ</mi><mi>X</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S l o p e o f ModifyingAbove upper A upper B With right-arrow
    equals two-halves equals 1"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi>
    <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>2</mn></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S l o p e o f ModifyingAbove upper B upper A With right-arrow
    equals StartFraction negative 2 Over negative 2 EndFraction equals 1"><mrow><mi>S</mi>
    <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>-</mo><mn>2</mn></mrow>
    <mrow><mo>-</mo><mn>2</mn></mrow></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: If the two vectors were simply lines (with no direction), then, they would be
    the same object. However, adding the directional component makes them two distinguishable
    mathematical objects.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-4 sheds more light on the concept of the slope, as *x* has shifted
    two points to the right and *y* has shifted two points to the left.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph15.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. The change in x and the change in y for vector AB
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Figure 4-5 shows the change in *x* and the change in *y* in the case of vector
    BA.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph16.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. The change in x and the change in y for vector BA
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A vector that has a magnitude of 1 is referred to as a *unit vector*.
  prefs: []
  type: TYPE_NORMAL
- en: Researchers typically use vectors as representations of speed especially in
    engineering. Navigation is one field that heavily relies on vectors. It allows
    navigators to determine their positions and plan their destinations. Naturally,
    magnitude represents speed and the direction represents the destination.
  prefs: []
  type: TYPE_NORMAL
- en: You can add and subtract vectors from each other and from scalars. This allows
    for a shift in direction and magnitude. What you should retain from the previous
    discussion is that vectors indicate directions between different points on the
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *scalar *is a value with magnitude but no direction. Scalars, as opposed to
    vectors, are used to represent elements like temperature and prices. Basically,
    scalars are numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In machine learning, the *x*-axis and *y*-axis respectively represent data and
    the model’s results. The independent (predictor) variable is represented by the
    *x*-axis in a scatter plot, and the dependent (forecast) variable is represented
    by the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *matrix* is a row-and-column-organized rectangular array containing numbers^([1](ch04.xhtml#idm46147468230768)).
    Matrices are useful in computer graphics and other domains as well as to define
    and manipulate linear systems of equations. What differentiates a matrix from
    a vector? The simplest answer is that a vector is a matrix with a single column
    or a single row. Here’s a a basic example of a 3 x 3 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    9 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 13 3rd Row 1st Column
    1 2nd Column 5 3rd Column 12 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>13</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>5</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrices’ sizes are referred to using their rows and columns respectively.
    A row is a horizontal line and a column is a vertical line. The following representation
    is a 2 x 4 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 4 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    1 4th Column 3 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 9 4th Column
    4 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The following representation is another example of a matrix. This time it is
    a 4 x 2 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 4 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 3rd Row 1st Column 8 2nd Column 22 4th Row
    1st Column 7 2nd Column 3 EndMatrix"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd></mtr> <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>7</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Matrices are heavily used in machine learning. Rows generally represent time
    and columns represent features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The summation of different matrices is straightforward but must be used only
    when the matrices match in size (which means they have the same number of columns
    and rows). For instance, let’s add the two following matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 5 2nd Column 8 EndMatrix plus Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 4 2nd Column 11 2nd Row 1st Column 6 2nd Column 13 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mo>+</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd> <mtd><mn>13</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that to add two matrices, you simply have to add the numbers in
    the same positions. Now, if you try to add the two following matrices, you won’t
    be able to do it as there is a mismatch in what to add:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 8 2nd Column 3 2nd Row
    1st Column 3 2nd Column 2 EndMatrix plus Start 3 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 3rd Row 1st Column 5 2nd Column
    4 EndMatrix"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><mn>8</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The subtraction of matrices is also straighforward and follows the same rules
    as the summation of matrices. Let’s take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 EndMatrix minus Start 2 By 2 Matrix 1st Row
    1st Column 3 2nd Column 9 2nd Row 1st Column negative 1 2nd Column negative 5
    EndMatrix equals Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column negative
    7 2nd Row 1st Column negative 9 2nd Column 15 EndMatrix"><mrow><mfenced open="["
    close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>8</mn></mrow></mtd> <mtd><mn>10</mn></mtd></mtr></mtable></mfenced> <mo>-</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>7</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>9</mn></mrow></mtd>
    <mtd><mn>15</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Evidently, subtraction of matrics is also a summation of matrices with a change
    of signals in one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrix multiplication by a scalar is quite simple. Let’s take the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 times Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2
    2nd Row 1st Column 8 2nd Column 22 EndMatrix equals Start 2 By 2 Matrix 1st Row
    1st Column 15 2nd Column 6 2nd Row 1st Column 24 2nd Column 66 EndMatrix"><mrow><mn>3</mn>
    <mo>×</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>15</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>24</mn></mtd> <mtd><mn>66</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'So basically, you are multiplying every element in the matrix by the scalar. Matrix
    multiplication by another matrix is a bit more complicated since they use the
    *dot product* method. First of all, in order to multiply two matrices together,
    they must satisfy this condition:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper M a t r i x Subscript x y Baseline times upper M a t r
    i x Subscript y z Baseline equals upper M a t r i x Subscript x z"><mrow><mi>M</mi>
    <mi>a</mi> <mi>t</mi> <mi>r</mi> <mi>i</mi> <msub><mi>x</mi> <mrow><mi>x</mi><mi>y</mi></mrow></msub>
    <mo>×</mo> <mi>M</mi> <mi>a</mi> <mi>t</mi> <mi>r</mi> <mi>i</mi> <msub><mi>x</mi>
    <mrow><mi>y</mi><mi>z</mi></mrow></msub> <mo>=</mo> <mi>M</mi> <mi>a</mi> <mi>t</mi>
    <mi>r</mi> <mi>i</mi> <msub><mi>x</mi> <mrow><mi>x</mi><mi>z</mi></mrow></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the first matrix must have a number of columns equal to the
    number of rows in the second matrix, and the resulting matrix from the dot product
    is a matrix that has the number of rows of the first matrix and the number of
    columns of the second matrix. The dot product is explained in this example representation
    of a 1 x 3 and 3 x 1 matrix multiplication (notice the equal number of columns
    and rows):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 1 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    3 EndMatrix times Start 3 By 1 Matrix 1st Row  3 2nd Row  2 3rd Row  1 EndMatrix
    equals Start 1 By 1 Matrix 1st Row  left-parenthesis 1 times 3 right-parenthesis
    plus left-parenthesis 2 times 2 right-parenthesis plus left-parenthesis 3 times
    1 right-parenthesis EndMatrix equals Start 1 By 1 Matrix 1st Row  10 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>×</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>(</mo> <mn>1</mn>
    <mo>×</mo> <mn>3</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>2</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>3</mn> <mo>×</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>10</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example of a 2 x 2 matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 0 2nd Column 1 EndMatrix times Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 0 2nd Row 1st Column 2 2nd Column 1 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 7 2nd Column 2 2nd Row 1st Column 2 2nd Column 1 EndMatrix"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>×</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a special type of matrix called the *identity matrix* which is basically
    the number 1 for matrices. It is defined as follows for a 2 x2 dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper I equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column
    0 2nd Row 1st Column 0 2nd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'And as follows for a 3 x 3 dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper I equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying any matrix by the identity matrix yields the same original matrix.
    This is why it can be referred to as the 1 of matrices (multiplying any number
    by 1 yields the same number). It is worth noting that matrix multplication is
    not commutative, which means that the order of multiplication changes the result
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper A upper B not-equals upper B upper A"><mrow><mi>A</mi>
    <mi>B</mi> <mo>≠</mo> <mi>B</mi> <mi>A</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '*Matrix transposing* is a process that involves changing the rows of into columns
    and vice versa. The transpose of a matrix is obtained by reflecting the matrix
    along its main diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 4 2nd Column 6 3rd Column
    1 2nd Row 1st Column 1 2nd Column 4 3rd Column 2 EndMatrix Superscript upper T
    Baseline equals Start 3 By 2 Matrix 1st Row 1st Column 4 2nd Column 1 2nd Row
    1st Column 6 2nd Column 4 3rd Row 1st Column 1 2nd Column 2 EndMatrix"><mrow><msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Transposing is used in some machine learning algorithms and is not an uncommon
    operation when dealing with such models. If you are wondering about the role of
    matrices in data science and machine learning, you can refer to this non-exhaustive
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: Representation of data
  prefs: []
  type: TYPE_NORMAL
- en: Matrices often represent data with rows representing samples and columns representing
    features. For example, a row in a matrix can present OHLC data in one time step.
  prefs: []
  type: TYPE_NORMAL
- en: Linear algebra
  prefs: []
  type: TYPE_NORMAL
- en: Matrices and linear algebra are intertwined, and many learning algorithms use
    the concepts of matrices in their operations.
  prefs: []
  type: TYPE_NORMAL
- en: Data relationship matrices
  prefs: []
  type: TYPE_NORMAL
- en: If you remember from Chapter 3, covariance and correlation measures are often
    represented as matrices. These relationship calculations are important concepts
    in machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You should retain the following key concepts from this section:'
  prefs: []
  type: TYPE_NORMAL
- en: A vector is an object that has a magnitude (length) and a direction (arrowhead).
    Multiple vectors grouped together form a matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix can be used to store data. It has its special ways of performing operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix multiplication uses the dot product method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transposing a matrix means to swap its rows and its columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Linear Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already seen an example of a linear equation in the section that discusses
    linear regression and statistical inference from Chapter 3\. *Linear equations*
    are basically formulae that present an equality relationship between between different
    variables and constants. In the case of machine learning, it is often a relationship
    between a dependent variable (the output) and the independent variable (the input). The
    best way to understand linear equations is through examples.​
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The aim of linear equations is to find an unknown variable, usually denoted
    by the letter *x*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a very basic example which you can consider as a first building block
    towards more advanced calculus concepts you will see later on. The following examples
    requires finding the value of *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x equals 20"><mrow><mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: You should understand the equation as "*10 times which number equals 20?”*.
    When a constant is directly attached to a variable such as *x*, it refers to a
    multiplication operation. Now, to solve for *x* (so, finding the value of *x*
    that equalizes the equation), you have an obvious solution which is to get rid
    of 10 so that you have x on one side of the equation and the rest on the other
    side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, to get rid of 10, you divide by 10 so that what remains is 1 which
    if multiplied by the variable *x* does nothing. However, keep in mind two important
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: If you do a mathematical operation on one side of an equation, you must do it
    on the other side as well. This is why they are called equations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, instead of dividing by the constant to get rid of it, you should
    multiply it by its reciprocal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *reciprocal* of a number is one divided by that number. Here’s the mathematical
    representation of it:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper R e c i p r o c a l left-parenthesis x right-parenthesis
    equals StartFraction 1 Over x EndFraction"><mrow><mi>R</mi> <mi>e</mi> <mi>c</mi>
    <mi>i</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to the example, to find *x*, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis one-tenth right-parenthesis 10 x equals 20 left-parenthesis
    one-tenth right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>10</mn></mfrac>
    <mo>)</mo></mrow> <mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>10</mn></mfrac> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing the multiplication and simplifying gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 2"><mrow><mi>x</mi> <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the solution of the equation is 2\. To verify this, you just
    need to plug it into the original equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 times 2 equals 20"><mrow><mn>10</mn> <mo>×</mo> <mn>2</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it takes two 10’s to get 20.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dividing the number by itself or multiplying it by its reciprocal is the same
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example of how to solve *x* through linear techniques. Consider
    the following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="eight-sixths x equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing the multiplication and simplifying gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis six-eighths right-parenthesis eight-sixths x
    equals 24 left-parenthesis six-eighths right-parenthesis"><mrow><mrow><mo>(</mo>
    <mfrac><mn>6</mn> <mn>8</mn></mfrac> <mo>)</mo></mrow> <mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn> <mrow><mo>(</mo> <mfrac><mn>6</mn> <mn>8</mn></mfrac>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 18"><mrow><mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the solution of the equation is 18\. To verify this, you just
    need to plug it into the original equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="eight-sixths times 18 equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mo>×</mo> <mn>18</mn> <mo>=</mo> <mn>24</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s  dig in a little deeper, because typically, linear equations are not
    this simple. Sometimes they contain more variables and more constants, which need
    more detailed solutions, but let’s keep taking it step by step. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x minus 6 equals 12"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving for *x* requires rearranging the equation a little bit. Remember, the
    aim is to leave *x* on one side and the rest on the other. Here, you have to get
    rid of the constant 6 before taking care of 3\. The first part of the solution
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x minus 6 left-parenthesis plus 6 right-parenthesis equals
    12 left-parenthesis plus 6 right-parenthesis"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo> <mo>=</mo> <mn>12</mn>
    <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how you have to add 6 to both parts of the equation. The part on the
    left will cancel itself out while the part on the right will add up to 18:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x equals 18"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you’re all set to multiply by the reciprocal of the constant attached
    to the variable *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis one-third right-parenthesis 3 x equals 18 left-parenthesis
    one-third right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac>
    <mo>)</mo></mrow> <mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplifying and solving for *x* leaves the following solution:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 6"><mrow><mi>x</mi> <mo>=</mo> <mn>6</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the solution of the equation is 6\. To verify this, just plug
    it into the original equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis 3 times 6 right-parenthesis minus 6 equals 12"><mrow><mo>(</mo>
    <mn>3</mn> <mo>×</mo> <mn>6</mn> <mo>)</mo> <mo>-</mo> <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you should start noticing that linear algebra is all about using shortcuts
    and quick techniques to simplify equations and find unknown variables. The next
    example shows how sometimes the variable *x* can occur in multiple places:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="6 x plus x equals 27 minus 2 x"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>=</mo> <mn>27</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, the main focus is to have *x* on one side of the equation and the
    rest on the other side:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="6 x plus x plus 2 x equals 27"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the constants of *x* gives you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="9 x equals 27"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is dividing by 9 so that you only have *x* remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 3"><mrow><mi>x</mi> <mo>=</mo> <mn>3</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: You may now verify this by plugging 3 in the place of *x* in the original equation.
    You will notice that both sides of the equation will be equal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Even though this section is quite simple, it contains the basic foundations
    you need to start advancing in algebra and calculus. The main points to retain
    before going further are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A linear equation is a representation in which the highest exponent on any variable
    is one. This means that there are no variables that are raised to the power of
    two and above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A linear equation line is straight when plotted on a chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application of linear equations in modeling a wide range of real-world occurrences
    makes them crucial in many branches of mathematics and research. They are also
    widely utilized in machine learning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving for *x* is the process of finding its value that equalizes both sides
    of the equation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When performing an operation (such as adding a constant or multiplying by a
    constant) on one side of the equation, you have to do it on the other side as
    well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reciprocals are useful to simplify equations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systems of Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *system of equation* is when there are two or more equations working together
    to solve a variable or more. Therefore, instead of the usual single equation like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Systems of equations resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y plus 2 x equals 10"><mrow><mi>y</mi> <mo>+</mo> <mn>2</mn>
    <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: There are methods that solve them and particularities, which are discussed in
    this section. Systems of equations are useful in machine learning and are used
    in many of its aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the previous system of equation from the beginning of this section
    and solve it graphically. Plotting the two functions can actually give the solution
    directly. The point of intersection of linear equations is the solution. Therefore,
    the coordinates of the intersection (*x, y*) refer to the solutions of the *x*
    and *y* respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Figure 4-6, it seems that *x* = 10 and *y* = -10\. Plugging these values
    into their respective variables gives the correct answer:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 plus 10 equals 20"><mrow><mn>10</mn> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis negative 10 right-parenthesis plus left-parenthesis
    2 times 10 right-parenthesis equals 10"><mrow><mo>(</mo> <mo>-</mo> <mn>10</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>10</mn> <mo>)</mo>
    <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. A graph showing the two functions and their intersection (solution)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As the functions are linear, there can be three cases to solving them:'
  prefs: []
  type: TYPE_NORMAL
- en: There is only one solution for each variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no solution. This occurs when the functions are *parallel* (this means
    that they never intersect).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The is an infinite number of solutions. This occurs when it’s the same function
    (since all points fall on the straight line).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before moving on to solving systems of equations using algebra, let’s visually
    see how can there be no solution and how can there be an infinite number of solutions.
    Consider the following system:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 x equals 10"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="4 x equals 20"><mrow><mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-7 charts the two together. Since they are exactly the same equation,
    they fall on the same line. In reality, there are two lines in Figure 4-7, but
    since they are the same, they are indistinguishable. For every *x* on the line,
    there is a corresponding *y*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. A graph showing the two functions and their infinite intersections
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, consider the following system:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x equals 10"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="6 x equals 10"><mrow><mn>6</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-8 shows how they never intersect which is intuitive as you cannot multiply
    the same number (represented by the variable *x*) with different numbers and expect
    to get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. A graph showing the two functions and their impossible intersection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Algebraic methods are used when there are more than two variables since they
    cannot be solved through graphs. This mainly entails two methods, substitution
    and elimination.
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitution* is used when you can replace the value of a variable in one
    equation and plug it in the second equation. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus y equals 2"><mrow><mi>x</mi> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x plus y equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest method is to rearrange the first equation so that you have *y*
    in terms of *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y equals 2 minus x"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mo>-</mo>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving for *x* in the second equation becomes simple:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x plus 2 minus x equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>2</mn> <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x minus x equals 10 minus 2"><mrow><mn>10</mn> <mi>x</mi>
    <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="9 x equals 8"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals eight-ninths"><mrow><mi>x</mi> <mo>=</mo> <mfrac><mn>8</mn>
    <mn>9</mn></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 0.8889"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn> <mo>.</mo>
    <mn>8889</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have found the value of *x*, you can easily find *y* by plugging
    the value of *x* in the first equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="0.8889 plus y equals 2"><mrow><mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>+</mo> <mi>y</mi> <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y equals 2 minus 0.8889"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn>
    <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>8889</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y equals 1.111"><mrow><mi>y</mi> <mo>=</mo> <mn>1</mn> <mo>.</mo>
    <mn>111</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if your solution is correct, you can plug in the values of x and y
    in both formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="0.8889 plus 1.111 equals 2"><mrow><mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>+</mo> <mn>1</mn> <mo>.</mo> <mn>111</mn> <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis 10 times 0.8889 right-parenthesis plus 1.111
    equals 10"><mrow><mo>(</mo> <mn>10</mn> <mo>×</mo> <mn>0</mn> <mo>.</mo> <mn>8889</mn>
    <mo>)</mo> <mo>+</mo> <mn>1</mn> <mo>.</mo> <mn>111</mn> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Graphically this means that the two equations intersect at (0.8889, 1.111).
    This technique can be used with more than two variables. Follow the same process
    until the equations are simplified enough to give you the answers. The issue with
    substitution is that it may take some time when you’re dealing with more than
    two variables.
  prefs: []
  type: TYPE_NORMAL
- en: '*Elimination* is a faster alternative. It is about eliminating variables until
    there is only one left. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 x plus 4 y equals 20" display="block"><mrow><mn>2</mn> <mi>x</mi>
    <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math> <math alttext="3
    x plus 2 y equals 10" display="block"><mrow><mn>3</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Noticing that there is 4*y* and 2*y*, it is possible to multiply the second
    equation by 2 so that you can subtract the equations from each other (which will
    remove the *y* variable):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 x plus 4 y equals 20"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="6 x plus 4 y equals 20"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtracting the two equations from each other gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="minus 4 x equals 0"><mrow><mo>-</mo> <mn>4</mn> <mi>x</mi> <mo>=</mo>
    <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 0"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, *x* = 0\. Graphically, this means that they intersect whenever *x*
    = 0 (exactly at the vertical *y* line). Plugging in the value of *x* in the first
    formula gives *y*  = 5:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis 2 times 0 right-parenthesis plus 4 y equals
    20"><mrow><mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mn>4</mn>
    <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="4 y equals 20"><mrow><mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y equals 5"><mrow><mi>y</mi> <mo>=</mo> <mn>5</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, elimination can also solve equations with three variables. The choice
    between substitution and elimination depends on the type of equations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Key takeaways from this section can be summed up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Systems of equations solve variables together. They are very useful in machine
    learning and are used in some algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical solutions are preferred for simple systems of equations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving systems of equations through algebra entails the use of substitution
    and elimination methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitution is preferred when the system is simple but elimination is the way
    to go when the system is a bit more complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigonometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Trigonometry e*xplores the behavior of what is known as *trigonometric functions*
    that relate the angles of a triangle to the lengths of its sides. The most-used
    triangle is the right-angled triangle which has one angle at 90**°**. Figure 4-9
    shows an example of a right-angled triangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_trig1.PNG)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9\. A right-angled triangle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s define the main characteristics of a right-angled triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: The longest side of the triangle is called a *hypotenuse.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The angle in front of the hypotenuse is the right angle (the one at 90**°**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the other angle (θ) you choose (from the two that remains), the
    line between this angle and the hypotenuse is called the *adjacent* and the other
    line is called the *opposite*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trigonometric functions are simply the division of a line by the other. Remember
    that you have three lines in a triangle (hypotenuse, opposite, and adjacent).
    The trigonometric functions are found as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="s i n left-parenthesis theta right-parenthesis equals StartFraction
    upper O p p o s i t e Over upper H y p o t e n u s e EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>O</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow>
    <mrow><mi>H</mi><mi>y</mi><mi>p</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="c o s left-parenthesis theta right-parenthesis equals StartFraction
    upper A d j a c e n t Over upper H y p o t e n u s e EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>A</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow>
    <mrow><mi>H</mi><mi>y</mi><mi>p</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    upper O p p o s i t e Over upper A d j a c e n t EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>O</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow>
    <mrow><mi>A</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous three trigonometric functions, it is possible to extract
    a trigonometric identity which reaches *tan* from *sin* and *cos* using basic
    linear algebra:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    s i n left-parenthesis theta right-parenthesis Over c o s left-parenthesis theta
    right-parenthesis EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow>
    <mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '*Hyperbolic functions *are similar to trigonometric operations but are defined
    using exponential functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This part on hyperbolic functions is extremely important as it forms the basis
    of what is known as *activation functions*, a key concept in neural networks,
    the protagonists of deep learning models. You will see them in detail in Chapter
    8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Euler’s number (denoted as *e*) is one of the most important numbers in mathematics.
    It is an *irrational number*, which is a real number that cannot be expressed
    as a fraction. The word *irrational* comes from the fact that there is no *ratio*
    to express it; it has nothing to do with its personality. Euler’s number *e* is
    also the base of the natural logarithm *ln* and the first digits of it are 2.71828\.
    One of the best approximations to get *e* is the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="e equals left-parenthesis 1 plus StartFraction 1 Over n EndFraction
    right-parenthesis Superscript n"><mrow><mi>e</mi> <mo>=</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'By increasing *n* in the previous formula, you will approach the value of *e*.
    It has many interesting properties, notably the fact that its slope is its own
    value. Let’s take for example the following function (also called the natural
    exponent function):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: At any point, the slope of the function is the same value. Take a look at Figure
    4-10.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10\. The graph of the natural exponent function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may be wondering about the use of explaining exponents and logarithms in
    this book. There are mainly two reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Exponents and more importantly Euler’s number are used in hyperbolic functions
    where *tanh(x)* is one of the main activation functions for neural networks, a
    type of machine and deep learning model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logarithms are very useful in *data normalization* but also in *loss functions*,
    concepts that you will see in later chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, having a deep understanding of what they refer to is primordial in
    building up expertise in the subsequent models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperbolic functions use the natural exponent function and are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="s i n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="c o s h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline plus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="t a n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over e Superscript
    x Baseline plus e Superscript negative x Baseline EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mrow><msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Among the key characteristics of *tanh(x)* is non-linearity, the limitation
    between [-1, 1], and the fact that it is centered at zero. Figure 4-11 shows the
    graph of *tanh(x)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11\. The graph of tanh(x) showing how it’s limited between -1 and 1
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Key concepts to retain from this section are summed up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometry is a field that explores the behavior of trigonometric functions
    which relate the angles of a triangle to the lengths of its sides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trigonometric identity is a shortcut that relates the trigonometric functions
    with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eurler’s number *e* is irrational and is the base of the natural logarithm.
    It has many applications in exponential growth and in hyperbolic functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperbolic functions resemble trigonmetric functions but are not the same thing.
    While trigonometric functions relate to a triangles and circles, hyperbolic functions
    relate to hyperbolas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hyperbolic tangent function is used in neural networks, a deep learning
    algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits and Continuity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calculus works by making visible the infinitesimally small.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Keith Devlin'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s move now to calculus after seeing the major topics of linear algebra.
    Limits don’t have to be nightmarish. I have always found them to be misunderstood.
    They are actually quite easy to get. But first, you need motivation and this comes
    from knowing the added value of learning limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding limits is very important in machine learning models for many
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  prefs: []
  type: TYPE_NORMAL
- en: In optimization methods like gradient descent, limits can be used to regulate
    the step size and guarantee convergence to a local minimum (a concept you will
    learn in Chapter 8).
  prefs: []
  type: TYPE_NORMAL
- en: Feature Selection
  prefs: []
  type: TYPE_NORMAL
- en: Limits can be used to rank the significance of various model features and perform
    feature selection, which can make the model simpler and perform better.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitivity analysis
  prefs: []
  type: TYPE_NORMAL
- en: A machine learning model’s sensitivity to changes in input data and its capacity
    to generalize to new data can be used to examine a model’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: ​Also, limits are used in more advanced calculus concepts you will run across
    in the coming pages.
  prefs: []
  type: TYPE_NORMAL
- en: The main aim of limits is to know the value of a function when it’s undefined.
    But what is an undefined function? When you have a function that gives a solution
    that is not possible (such as dividing by zero), limits help you bypass this issue
    in order to know the value of the function at that point. So the aim of limits
    is to solve functions even when they are undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the solution to a function that takes *x* as an input is a value
    in the *y* axis. Figure 4-12 shows a linear graph of the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x plus 2"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>x</mi> <mo>+</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12\. The graph of the function f(x) = x + 2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The solution of the function in the graph is the one that lies on the linear
    line taking into account the value of *x* every time.
  prefs: []
  type: TYPE_NORMAL
- en: What would be the solution of the function (the value of *y*) when *x* = 4?
    Clearly, the answer is 6, as substituting the value of *x* by 4 gives 6.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis 4 right-parenthesis equals 4 plus 2 equals
    6"><mrow><mi>f</mi> <mo>(</mo> <mn>4</mn> <mo>)</mo> <mo>=</mo> <mn>4</mn> <mo>+</mo>
    <mn>2</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking of this solution in terms of limits would be saying, what is the solution
    of the function as *x* approaches 4 from both sides (the negative side and the
    positive side)? Table 4-1 simplifies this dilemma:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Finding x
  prefs: []
  type: TYPE_NORMAL
- en: '| *f(x)* | *   x* |'
  prefs: []
  type: TYPE_TB
- en: '| 5.998 | 3.998 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.999 | 3.999 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.000 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.001 | 4.001 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.002 | 4.002 |'
  prefs: []
  type: TYPE_TB
- en: Approaching from the negative side is the equivalent of adding a fraction of
    a number while below 4 and analyzing the result every time. Similarly, approaching
    from the positive side is the equivalent of removing a fraction of a number while
    above 4 and analyzing the result every time. The solution seems to converge to
    6 as x approaches 4\. This is the solution to the limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Limits in the general form are written following this convention:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow a Endscripts f left-parenthesis
    x right-parenthesis equals upper L"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The general form of the limit is read as follows: as you approach *a* along
    the *x*-axis (whether from the positive or the negative side), the function *f(x)*
    gets closer to the value of *L*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The idea of the limit states that as you lock-in and approach a number from
    either side (negative or positive), the solution of the equation approaches a
    certain number, and the solution to the limit is that number.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, limits are useful when the exact point of the solution
    is undefined using the conventional way of substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A one-sided limit is different from the general limit. The left-hand limit
    is where you search for the limit going from the negative side to the positive
    side, and the right-hand limit is when you search for the limit going from the
    positive side to the negative side. The general limit exists when the two one-sided
    limits exist and are equal. Therefore, the previous statements are summarized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand limit exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right-hand limit exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The left-hand limit is equal to the right-hand limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The left hand limit is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow a Superscript minus Baseline
    Endscripts f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi>
    <mo>-</mo></msup></mrow></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>L</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The right hand limit is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow a Superscript plus Baseline Endscripts
    f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi> <mo>+</mo></msup></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    cubed minus 27 Over x minus 3 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mi>x</mi><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the solution of the function when x = 3? Substitution leads to the
    following issue:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis 3 right-parenthesis equals StartFraction 3
    cubed minus 27 Over 3 minus 3 EndFraction equals StartFraction 27 minus 27 Over
    3 minus 3 EndFraction equals StartFraction 0 Over 0 EndFraction equals upper U
    n d e f i n e d"><mrow><mi>f</mi> <mrow><mo>(</mo> <mn>3</mn> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mn>3</mn>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>27</mn><mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mn>0</mn> <mn>0</mn></mfrac></mstyle>
    <mo>=</mo> <mi>U</mi> <mi>n</mi> <mi>d</mi> <mi>e</mi> <mi>f</mi> <mi>i</mi> <mi>n</mi>
    <mi>e</mi> <mi>d</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: However, thinking about this in terms of limits as Table 4-2 shows, it seems
    that as you approach *x = 3*, either from the left side or the right side, the
    solution tends to approach 27.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. Finding x
  prefs: []
  type: TYPE_NORMAL
- en: '| f(x) |    x |'
  prefs: []
  type: TYPE_TB
- en: '| 2.9998 | 26.9982 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.9999 | 26.9991 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0000 | Undefined |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0001 | 27.0009 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0002 | 27.0018 |'
  prefs: []
  type: TYPE_TB
- en: Graph-wise, this can be seen as a discontinuity in the chart along both axes.
    The discontinuity exists on the line around the coordinate (3, 27).
  prefs: []
  type: TYPE_NORMAL
- en: Some functions do not have limits. For example, what is the limit of the following
    function as *x* approaches 5?
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over x minus 5 EndFraction"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo>-</mo><mn>5</mn></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Table 4-3, it seems that as *x* approaches 5, the results highly
    diverge when approaching from both sides. For instance, approaching from the negative
    side, the limit of 4.9999 is -10,000 and from the positive side, the limit of
    5.0001 is 10,000.
  prefs: []
  type: TYPE_NORMAL
- en: '| f(x) |    x |'
  prefs: []
  type: TYPE_TB
- en: '| 4.9998 | -5000 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.9999 | -10000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0000 | Undefined |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0001 | 10000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0002 | 5000 |'
  prefs: []
  type: TYPE_TB
- en: Remember that for the general limit to exist, both one-sided limits must exist
    and must be equal, which is not the case here. Graphing this gives Figure 4-13,
    which may help you understand why the limit does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-13\. The graph of the function proving that the limit does not exist
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'But what if the function that you want to analyze looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at Table 4-3, it seems that as x approaches 5, the results rapidly
    accelerate as they diverge to a certain very big number referred to as infinity
    (∞). Take a look at Table 4-4:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3\. Finding x
  prefs: []
  type: TYPE_NORMAL
- en: '| f(x) |    x |'
  prefs: []
  type: TYPE_TB
- en: '| 4.99997 | 33333.33 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.99998 | 50000 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.99999 | 100000 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.9999999 | 10000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Undefined |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0000001 | 10000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.00001 | 100000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.00002 | 50000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.00003 | 33333.33 |'
  prefs: []
  type: TYPE_TB
- en: See how at every tiny step *x* approaches 5, *y* approaches positive infinity.
    The answer to the limit question is therefore, positive infinity (+∞). Figure
    4-14 shows the graph of the function. Notice how they both rise in value as x
    approaches 5.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14\. The graph of the function proving that the limit exists as x approaches
    5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Continuous* functions are ones that are drawn without gaps or holes in the
    graph, while *discontinuous* functions contain such gaps and holes. This usually
    means that the latter contain points where the solution of the functions is undefined
    and may need to be approximated by limits. Therefore, continuity and limits are
    two related concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s proceed to solving limits; after all, you are not going to create a table
    every time and analyze the results subjectively to find the limits. There are
    three ways to solve limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitution*: This is the simplest rule and is generally used first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Factoring*: This comes after substitution does not work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conjugate methods*: This solution comes after the first two ways do not work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *substitution* way is simply plugging in the value which *x* approaches.
    Basically, these are functions that have solutions where the limits are used.
    Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts x plus 10 minus
    2 x"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the substitution way, the limit of the function is found as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow 5 Endscripts
    x plus 10 minus 2 x equals 5 plus 10 minus left-parenthesis 2 times 5 right-parenthesis
    equals 5 EndLayout"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><munder><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></munder>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>5</mn> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>×</mo>
    <mn>5</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the answer to the limit is 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *factoring* way is the next option when substitution does not work (for
    example, the limit is undefined after plugging in the value of *x* in the function).
    *Factoring* is all about changing the form of the equation using factors in a
    way that it is not undefined anymore when using the substitution way. Take the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try the substitution way, you will get an undefined value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow negative
    6 Endscripts StartFraction left-parenthesis x plus 6 right-parenthesis left-parenthesis
    x squared minus x plus 1 right-parenthesis Over x plus 6 EndFraction equals StartFraction
    left-parenthesis negative 6 plus 6 right-parenthesis left-parenthesis left-parenthesis
    negative 6 right-parenthesis squared minus left-parenthesis negative 6 right-parenthesis
    plus 1 right-parenthesis Over negative 6 plus 6 EndFraction equals StartFraction
    0 Over 0 EndFraction equals upper U n d e f i n e d EndLayout"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><munder><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></munder> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mo>(</mo><msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mn>0</mn>
    <mn>0</mn></mfrac> <mo>=</mo> <mi>U</mi> <mi>n</mi> <mi>d</mi> <mi>e</mi> <mi>f</mi>
    <mi>i</mi> <mi>n</mi> <mi>e</mi> <mi>d</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Factoring may help in this case. For example, the nominator is multiplied by
    (x+6) and then divided by (x+6). Simplifying this by canceling the two terms could
    give a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction equals limit Underscript x
    right-arrow negative 6 Endscripts x squared minus x plus 1"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that factoring is done, you can try substitution once again:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts x squared
    minus x plus 1 equals left-parenthesis negative 6 right-parenthesis squared minus
    left-parenthesis negative 6 right-parenthesis plus 1 equals 43"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>-</mo> <mrow><mo>(</mo> <mo>-</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mn>1</mn> <mo>=</mo> <mn>43</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The limit of the function as *x* tends towards -6 is therefore 43.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *conjugate* way is the next option in case substitution and factoring do
    not work. A conjugate is simply the changing of signs between two variables. For
    example, the conjugate of *x* + *y* is  *x* - *y*. The way to do this in the case
    of a fraction is to multiply the nominator and the denominator by the conjugate
    of one of them (with a preference to use the conjugate of the term that has a
    square root since it will get canceled out). Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'By multiplying both terms by the conjugate of the denominator, you will have
    started to use the conjugate way to solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction left-parenthesis StartFraction
    StartRoot x EndRoot plus 3 Over StartRoot x EndRoot plus 3 EndFraction right-parenthesis"><mrow><msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mrow><mo>(</mo>
    <mfrac><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow> <mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow></mfrac>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking into account the multiplication and simplifying gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over left-parenthesis StartRoot x EndRoot minus 3 right-parenthesis left-parenthesis
    StartRoot x EndRoot plus 3 right-parenthesis EndFraction"><mrow><msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be left with the following familiar situation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over x minus 9 EndFraction"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot x EndRoot
    plus 3"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <msqrt><mi>x</mi></msqrt> <mo>+</mo> <mn>3</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the function is ready for substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot 9 EndRoot
    plus 3 equals 3 plus 3 equals 6"><mrow><msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <msqrt><mn>9</mn></msqrt> <mo>+</mo>
    <mn>3</mn> <mo>=</mo> <mn>3</mn> <mo>+</mo> <mn>3</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the function is therefore 6\. As you can see, sometimes work
    needs to be done on preparing the equations in order to be ready for substitution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The main key points of this section on limits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Limits help find solutions for functions that may be undefined in certain points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the general limit to exist, the two one-sided limits must exist and must
    be equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are ways to find the limit of a function, notably substitution, factoring,
    and the conjugate way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits are useful in machine learning such as sensitivity analysis and optimization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *derivative* measures the change in a function given a change of one or more
    of its inputs. In other words, it is the rate of change of a function at a given
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a solid understanding of derivatives is important in building machine
    learning models for multiple reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  prefs: []
  type: TYPE_NORMAL
- en: In order to minimize the loss function (a concept you will see in Chapter 8),
    optimization methods employ derivatives to ascertain the direction of the steepest
    descent and modify model parameters. Gradient descent is one of the most frequently
    used optimization techniques in machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: Backpropagation
  prefs: []
  type: TYPE_NORMAL
- en: To execute gradient descent in deep learning, the backpropagation technique
    uses derivatives to calculate the gradients of the loss function with respect
    to the model’s parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter tuning
  prefs: []
  type: TYPE_NORMAL
- en: To improve the performance of the model, derivatives are used for sensitivity
    analysis and tuning of hyperparameters (another concept you will perfectly grasp
    in Chapter 8).
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget what you have learned from the previous section on limits, as
    you will be needing them for this section as well. Calculus mainly deals with
    derivatives and integrals. This section discusses derivatives and their uses.
  prefs: []
  type: TYPE_NORMAL
- en: You can consider derivatives as functions that represent (or model) the slope
    of another function at some point. A *slope* is a measure of a line’s position
    relative to a horizontal line. A positive slope indicates a line moving up, while
    a negative slope indicates a line moving down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derivatives and slopes are related concepts, but they are not the same thing.
    Here’s the main difference between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: The slope measures the steepness of a line. It is the ratio of the change in
    the y-axis to the change in the *x*-axis. You have already seen this in the section
    that discusses linear algebra.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derivative describes the rate of change of a given function. As the distance
    between two points on a function approaches zero, the derivative of that function
    at that point is the limit of the slope of the tangent line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before explaining derivatives in layperson’s terms and seeing some examples,
    let’s see their formal definitions (which means their mathematical representation
    in their default form):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation forms the basis of solving derivatives, although there are many
    shortcuts that you will learn and understand where they come from. Let’s try finding
    the derivative of a function using the formal definition. Consider the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    4 x minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>-</mo>
    <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the derivative, plug *f(x)* inside the formal definition and then solve
    the limit:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify things, let’s find *f(x + h)* so that plugging it in the formal
    definition becomes easier:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x plus h right-parenthesis equals left-parenthesis
    x plus h right-parenthesis squared plus 4 left-parenthesis x plus h right-parenthesis
    minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo>
    <mi>h</mi> <mo>)</mo></mrow> <mo>-</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x plus h right-parenthesis equals x squared
    plus 2 x h plus h squared plus 4 x plus 4 h minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mi>h</mi> <mo>+</mo> <msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>h</mi>
    <mo>-</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s plug f(x + h) into the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction x squared plus 2 x h plus h squared plus
    4 x plus 4 h minus 2 minus x squared minus 4 x plus 2 Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    movablelimits="true" form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>4</mn><mi>h</mi><mo>-</mo><mn>2</mn><mo>-</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>2</mn></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how there are many terms that can be simplified so that the formula
    becomes clearer. Remember, you are trying to find the limit for the moment, and
    the derivative is found after solving the limit:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction 2 x h plus h squared plus 4 h Over h
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo movablelimits="true" form="prefix">lim</mo>
    <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>4</mn><mi>h</mi></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The division by *h* gives further potential for simplification since you can
    divide all the terms in the numerator by the denominator *h*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts 2 x plus h plus 4"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s now time to solve the limit. Because the equation is simple, the first
    attempt is by substitution, which is, as you have guessed, possible. By substituting
    the variable *h* and making it zero (according to the limit), you are left with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'That is the derivative of the original function *f(x)*. If you want to find
    the derivative of the function when *x* = 2, you simply have to plug it in to
    the derivative function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis 2 right-parenthesis equals 2 left-parenthesis
    2 right-parenthesis plus 4 equals 8"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mo>+</mo> <mn>4</mn> <mo>=</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the graph of the function that you have just solved. Figure 4-15
    shows the original function’s graph with the derivative (the straight line). Notice
    how *f'(2)* lies exactly at 8\. The slope of *f(x)* when *x* = 2 is 8.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15\. The original f(x) with its derivative f'(x)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that when *f(x)* hits the bottom and starts rising, *f'(x)* crossed the
    zero line at -2\. This is a concept you will later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You are unlikely to use the formal definition every time you want to find a
    derivative (which can be used on every function). There are derivative rules that
    allow you to save a lot of time through shortcuts. The first rule is referred
    to as the *power rule,* which is a way to find the derivative of functions with
    exponents.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common to also refer to derivatives using this notation (which is the
    same thing as *f''(x)*):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The power rule for finding derivatives is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo>.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, what this means is that the derivative is found by multiplying the
    constant by the exponent and then subtracting 1 from the exponent. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    1 times 4 right-parenthesis x Superscript left-parenthesis 4 minus 1 right-parenthesis
    Baseline equals 4 x cubed"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>×</mo>
    <mn>4</mn> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mo>(</mo><mn>4</mn><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msup>
    <mo>=</mo> <mn>4</mn> <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that if there is no constant attached to the variable, it means that
    the constant is equal to 1\. Here’s a more complex example with the same principle:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals 2 x squared plus
    3 x Superscript 7 Baseline minus 2 x cubed"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>x</mi> <mn>7</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 4 x plus
    21 x Superscript 6 Baseline minus 6 x squared"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>4</mn> <mi>x</mi>
    <mo>+</mo> <mn>21</mn> <msup><mi>x</mi> <mn>6</mn></msup> <mo>-</mo> <mn>6</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that the rule also applies to constants even though they
    do not satisfy the general form of the power rule. The derivative of a constant
    is zero. However, it helps to know why, but first, you must be aware of this mathematical
    concept:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi> <mn>0</mn></msup>
    <mo>=</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'With this being said, you can imagine constants as always being multiplied
    by *x* to the power of zero (since it does not change their value). Now, if you
    want to find the derivative of 17, here’s how it would go:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="17 equals 17 x Superscript 0 Baseline equals left-parenthesis
    0 times 17 right-parenthesis x Superscript 0 minus 1 Baseline equals 0 x Superscript
    negative 1 Baseline equals 0"><mrow><mn>17</mn> <mo>=</mo> <mn>17</mn> <msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>×</mo> <mn>17</mn>
    <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mn>0</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, anything multiplied by zero returns zero as a result. This gives
    the constants rule for derivatives as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a right-parenthesis
    equals 0"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: You follow the same logic when encountering fractions or negative numbers in
    the exponents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *product rule* of derivatives is useful when there are two functions multiplied
    by each other. The product rule is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-bracket f left-parenthesis
    x right-parenthesis g left-parenthesis x right-parenthesis right-bracket equals
    f prime left-parenthesis x right-parenthesis g left-parenthesis x right-parenthesis
    plus f left-parenthesis x right-parenthesis g prime left-parenthesis x right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>=</mo> <msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>+</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example and find the derivative using the product rule:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation can clearly by segmented into two terms, *f(x)* and *g(x),* like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="g left-parenthesis x right-parenthesis equals left-parenthesis
    x cubed plus 1 right-parenthesis"><mrow><mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find the derivatives of the two terms before applying the product rule.
    Notice that finding the derivative of *f(x)* and *g(x)* is easy once you have
    understood the power rule:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="g prime left-parenthesis x right-parenthesis equals 3 x squared"><mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'When applying the product rule, you should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis 3 x squared right-parenthesis
    plus left-parenthesis 2 x right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>)</mo></mrow> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals 3 x Superscript
    4 Baseline plus 6 x squared plus 2 x Superscript 4 Baseline plus 2 x"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals 5 x Superscript
    4 Baseline plus 6 x squared plus 2 x"><mrow><msup><mi>h</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn> <msup><mi>x</mi>
    <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>2</mn> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-16 shows the graph of *h(x)* and *h'(x)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16\. The original h(x) with its derivative h'(x)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The next step is to see the *quotient rule,* which deals with the division
    of two functions. The formal definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-bracket StartFraction
    f left-parenthesis x right-parenthesis Over g left-parenthesis x right-parenthesis
    EndFraction right-bracket equals StartFraction f prime left-parenthesis x right-parenthesis
    g left-parenthesis x right-parenthesis minus f left-parenthesis x right-parenthesis
    g prime left-parenthesis x right-parenthesis Over left-bracket g left-parenthesis
    x right-parenthesis right-bracket squared EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mstyle> <mo>]</mo></mrow>
    <mo>=</mo> <mfrac><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <msup><mrow><mo>[</mo><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>]</mo></mrow>
    <mn>2</mn></msup></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply it into the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    squared minus x plus 1 Over x squared plus 1 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow> <mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, it’s better to start by finding the derivatives of *f(x)* and *g(x)*
    which in this case are clearly separated, with *f(x)* being the nominator and
    *g(x)* being the denominator. When applying the quotient rule, you should get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    left-parenthesis 2 x minus 1 right-parenthesis left-parenthesis x squared plus
    1 right-parenthesis minus left-parenthesis x squared minus x plus 1 right-parenthesis
    left-parenthesis 2 x right-parenthesis Over left-parenthesis x squared plus 1
    right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>)</mo></mrow></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    2 x cubed plus 2 x minus x squared minus 1 minus 2 x cubed plus 2 x squared minus
    2 x Over left-parenthesis x squared plus 1 right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle
    scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mo>-</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>1</mn><mo>-</mo><mn>2</mn><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>2</mn><mi>x</mi></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    x squared minus 1 Over left-parenthesis x squared plus 1 right-parenthesis squared
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>1</mn></mrow> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '*Exponential derivatives* deal with power rule applied to constants. Take a
    look at the following equation -- how would you find its derivative?'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals a Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>a</mi> <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the usual variable-base-constant-exponent, it is constant-base-variable-exponent.
    This is treated differently when trying to calculate the derivative. The formal
    definition is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction a Superscript x Baseline
    equals a Superscript x Baseline left-parenthesis ln a right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mi>a</mi> <mi>x</mi></msup> <mo>=</mo>
    <msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mi>a</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction 4 Superscript x Baseline
    equals 4 Superscript x Baseline left-parenthesis ln 4 right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mn>4</mn> <mi>x</mi></msup> <mo>=</mo>
    <msup><mn>4</mn> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mn>4</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Euler’s number, mentioned earlier, has a special derivative. When it comes
    to finding the derivative of *e*, the answer is interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction e Superscript x Baseline
    equals e Superscript x Baseline left-parenthesis ln e right-parenthesis equals
    e Superscript x"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>e</mi> <mi>x</mi></msup> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup>
    <mrow><mo>(</mo> <mo form="prefix">ln</mo> <mi>e</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This is because the natural log function and the exponential function are inverses
    of one another, so, the term *ln e* equals to 1\. Therefore, the derivative of
    the exponential function function *e* is itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In parallel, let’s discuss logarithmic derivatives. By now, you should have
    known what exponents and logarithms are. The general definition for both types
    of logarithms is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction log Subscript a Baseline
    x equals StartFraction 1 Over x ln a EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msub><mo form="prefix">log</mo> <mi>a</mi></msub>
    <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>a</mi></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction ln x equals log Subscript
    e Baseline x equals StartFraction 1 Over x ln e EndFraction equals StartFraction
    1 Over x EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mo form="prefix">ln</mo> <mi>x</mi> <mo>=</mo> <msub><mo form="prefix">log</mo>
    <mi>e</mi></msub> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>e</mi></mrow></mfrac></mstyle> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Notice how in the second derivative function of the natural logarithm, the term
    *ln e* is once again encountered, thus making simplification quite easy since
    it is equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals 7 l o g 2 left-parenthesis
    x right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>7</mn> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the formal definition, the derivative of this logarithmic function is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 7 left-parenthesis
    StartFraction 1 Over x ln 2 EndFraction right-parenthesis equals StartFraction
    7 Over x ln 2 EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>7</mn> <mrow><mo>(</mo> <mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>7</mn> <mrow><mi>x</mi><mo
    form="prefix">ln</mo><mn>2</mn></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that the logarithm *log* has a base of 10, but the natural logarithm
    *ln* has a base of *e* (~2.7182)
  prefs: []
  type: TYPE_NORMAL
- en: The natural logarithm and the log function are actually linearly related through
    simple multiplication. If you know the log of the constant *a*, you can find its
    natural logarithm *ln* by multiplying the log of *a* by 2.303.
  prefs: []
  type: TYPE_NORMAL
- en: 'One major concept in derivatives is the *chain rule*. Let’s back up to the
    power rule, which deals with exponents on variables. Remember the following formula
    to find the derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo>.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplified version because there is only *x*, but the reality is
    that you must multiply by the derivative of the term under the exponent. Until
    now, you have seen only *x* as the variable under the exponent. The derivative
    of *x* is 1, which is why it is simplified and rendered invisible. However, with
    more complex functions such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    4 x plus 1 right-parenthesis squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mrow><mo>(</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The derivative of the function is found by following these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the derivative of the outside function without touching the inside function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the derivative of the inside function and multiply it by the rest of the
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The solution is therefore as follows (knowing that the derivative of *4x +
    1* is just 4):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 left-parenthesis
    4 x plus 1 right-parenthesis .4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>.</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 8 left-parenthesis
    4 x plus 1 right-parenthesis"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>8</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 32 x plus
    8"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>32</mn> <mi>x</mi> <mo>+</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies with the exponential functions. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals e Superscript
    x Baseline left-parenthesis 1 right-parenthesis equals e Superscript x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup> <mrow><mo>(</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The chain rule can actually be considered as a master rule as it applies anywhere
    even in the product rule and the quotient rule.
  prefs: []
  type: TYPE_NORMAL
- en: There are more concepts to master in derivatives, but as this book is not meant
    to be a full calculus masterclass, you should at least know the meaning of a derivative,
    how it is found, what does it represent, and how can it be used in machine and
    deep learning.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key points of this section on derivatives are as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: A derivative measures the change in a function given a change of one or more
    of its inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power rule is used to find the derivative of a function raised to a power.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product rule is used to find the derivative of two functions that are multiplied
    together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quotient rule is used to find the derivative of two functions that are divided
    by each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain rule is the master rule used in differentiating (which means the process
    of finding the derivative). Due to simplicity, it is often overlooked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives play a crucial role in machine learning such as enabling optimization
    techniques, aiding model training, and enhancing the interpretability of the models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrals and the Fundamental Theorem of Calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *integral* is an operation that represents the area under a curve of a function
    given an interval. It is the inverse of a derivative, which is why it is also
    called an *anti-derivative*.
  prefs: []
  type: TYPE_NORMAL
- en: The process of finding integrals is called *integration*. Integrals can be used
    to find areas below a curve and they are also heavily used in the world of finance
    such as risk management, portfolio management, probabilistic methods, and even
    option pricing.
  prefs: []
  type: TYPE_NORMAL
- en: The most basic way of understanding an integral is by thinking of calculating
    an area below the curve of a function. This can also be done by manually, calculating
    different changes in the *x*-axis, but it won’t be accurate (accuracy increases
    as you add up much smaller slices). Therefore, as the size of the slices approaches
    zero, the accuracy of the area gets better. Since this is a tedious process, integrals
    are here for the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that an integral is the inverse of a derivative. This is important
    because it implies a direct relationship between the two. The basic definition
    of an integral is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral f left-parenthesis x right-parenthesis d x equals upper
    F left-parenthesis upper X right-parenthesis plus upper C"><mrow><mo>∫</mo> <mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mo>(</mo>
    <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper T h e integral s y m b o l r e p r e s e n t s t h e i
    n t e g r a t i o n p r o c e s s"><mrow><mi>T</mi> <mi>h</mi> <mi>e</mi> <mo>∫</mo>
    <mi>s</mi> <mi>y</mi> <mi>m</mi> <mi>b</mi> <mi>o</mi> <mi>l</mi> <mi>r</mi> <mi>e</mi>
    <mi>p</mi> <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>s</mi>
    <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>e</mi> <mi>g</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>p</mi> <mi>r</mi>
    <mi>o</mi> <mi>c</mi> <mi>e</mi> <mi>s</mi> <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis i s t h e d e r i v a
    t i v e o f t h e g e n e r a l f u n c t i o n upper F left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>i</mi> <mi>s</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi>
    <mi>d</mi> <mi>e</mi> <mi>r</mi> <mi>i</mi> <mi>v</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>o</mi> <mi>f</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>g</mi>
    <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>r</mi> <mi>a</mi> <mi>l</mi> <mi>f</mi> <mi>u</mi>
    <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>F</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper C r e p r e s e n t s t h e l o s t c o n s t a n t i n
    t h e d i f f e r e n t i a t i o n p r o c e s s"><mrow><mi>C</mi> <mi>r</mi>
    <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi>
    <mi>s</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>l</mi> <mi>o</mi> <mi>s</mi> <mi>t</mi>
    <mi>c</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>n</mi> <mi>t</mi>
    <mi>i</mi> <mi>n</mi> <mi>t</mi> <mi>h</mi> <mi>e</mi> <mi>d</mi> <mi>i</mi> <mi>f</mi>
    <mi>f</mi> <mi>e</mi> <mi>r</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>i</mi> <mi>a</mi>
    <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi>
    <mi>e</mi> <mi>s</mi> <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="d x r e p r e s e n t s s l i c i n g a l o n g x a s i t a p
    p r o a c h e s z e r o"><mrow><mi>d</mi> <mi>x</mi> <mi>r</mi> <mi>e</mi> <mi>p</mi>
    <mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>s</mi> <mi>s</mi>
    <mi>l</mi> <mi>i</mi> <mi>c</mi> <mi>i</mi> <mi>n</mi> <mi>g</mi> <mi>a</mi> <mi>l</mi>
    <mi>o</mi> <mi>n</mi> <mi>g</mi> <mi>x</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi>
    <mi>a</mi> <mi>p</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>a</mi> <mi>c</mi> <mi>h</mi>
    <mi>e</mi> <mi>s</mi> <mi>z</mi> <mi>e</mi> <mi>r</mi> <mi>o</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'What the preceding equation means is that the integral of *f(x)* is the general
    function *F(x)* plus a constant *C* which was lost initially in the initial differentiation
    process. Here’s an example to better explain the need to put in the constant:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    5"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>5</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating its derivative, you get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if you wanted to integrate it so that you go back to the original
    function (which in this case is represented by the capital letter *F(x)* instead
    of *f(x)*)?
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>x</mi> <mi>d</mi>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, having seen the differentiation process (which means taking the derivative),
    you would return 2 as the exponent, which gives you the following answer:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x equals x squared"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not look like the original function. It’s missing the constant 5\.
    But you have no way of knowing that or even if you knew there was a constant,
    what is it? 1? 2? 677? This is why a constant *C* is added in the integration
    process so that it represents the lost constant. Therefore, the answer to the
    integration problem is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x equals x squared plus upper C"><mrow><mo>∫</mo>
    <mn>2</mn> <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Up until now, the discussion has been limited to *indefinite integrals* where
    the integration symbol is *naked* (which means there are no boundaries to it).
    You will see what this means right after defining the necessary rules to complete
    the integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the power function (just like the previous function), the general rule
    for integration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral x Superscript a Baseline d x equals StartFraction x
    Superscript a plus 1 Baseline Over a plus 1 EndFraction plus upper C"><mrow><mo>∫</mo>
    <msup><mi>x</mi> <mi>a</mi></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><msup><mi>x</mi> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msup>
    <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much simpler than it looks. You are simply reversing the power rule
    you saw earlier. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x Superscript 6 d x"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x Superscript 6 Baseline d x equals StartFraction
    2 x Superscript 7 Baseline Over 7 EndFraction plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0"
    displaystyle="false"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>7</mn></msup></mrow>
    <mn>7</mn></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x Superscript 6 Baseline d x equals two-sevenths x
    Superscript 7 Baseline plus upper C"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify your answer, you can find the derivative of the result (using the
    power rule):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals two-sevenths
    x Superscript 7 Baseline plus upper C"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    7 right-parenthesis two-sevenths x Superscript 7 minus 1 Baseline plus 0"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mn>7</mn> <mo>)</mo></mrow> <mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mrow><mn>7</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>+</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x Superscript
    6"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>6</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example. Consider the following integration problem:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>d</mi> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, using the rule, you should find the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 d x equals 2 x plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to *definite integrals,* which are integrals with numbers on
    top and bottom that represent intervals below a curve of a function. Hence, *indefinite*
    integrals find the area under the curve everywhere but definite integrals are
    bounded within an interval given by point *a* and point *b*. The general definition
    of indefinite integrals is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral Subscript a Superscript b Baseline f left-parenthesis
    x right-parenthesis d x equals upper F left-parenthesis upper B right-parenthesis
    minus upper F left-parenthesis upper A right-parenthesis"><mrow><msubsup><mo>∫</mo>
    <mi>a</mi> <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>B</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>A</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is as simple as it gets. You will solve the integral, then plug in the
    two numbers and subtract the two functions from each other. Consider the following
    evaluation of an integral (integral solving is commonly referred to as *evaluating*
    the integral):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral Subscript 0 Superscript 6 Baseline 3 x squared minus
    10 x plus 4 d x"><mrow><msubsup><mo>∫</mo> <mn>0</mn> <mn>6</mn></msubsup> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>d</mi> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to understand what is being asked. From the definition of
    integrals, it seems that the area between [0, 2] on the *x*-axis is to be calculated
    using the given function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket x cubed minus 5 x squared plus 4 x plus upper C right-bracket right-parenthesis
    vertical-bar Subscript 0 Baseline Superscript 6 Baseline"><mrow><mi>F</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>4</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow>
    <msubsup><mrow><mo>|</mo></mrow> <mn>0</mn> <mn>6</mn></msubsup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To evaluate the integral at the given points, simply plug in the values as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 6 cubed minus 5 left-parenthesis 6 right-parenthesis squared plus
    4 left-parenthesis 6 right-parenthesis plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 cubed minus 5 left-parenthesis 0 right-parenthesis
    squared plus 4 left-parenthesis 0 right-parenthesis plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mn>6</mn> <mn>3</mn></msup>
    <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <mrow><mo>(</mo> <mrow><mo>[</mo>
    <msup><mn>0</mn> <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 216 minus 180 plus 24 plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 minus 0 plus 0 plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo>
    <mo>(</mo> <mo>[</mo> <mn>216</mn> <mo>-</mo> <mn>180</mn> <mo>+</mo> <mn>24</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>-</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 60 plus upper C right-bracket right-parenthesis minus left-parenthesis
    left-bracket 0 plus upper C right-bracket right-parenthesis"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mo>[</mo> <mn>60</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    60 minus 0 right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo>
    <mo>=</mo> <mo>(</mo> <mn>60</mn> <mo>-</mo> <mn>0</mn> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals 60"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>60</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The constant *C* will always cancel out in definite integrals so you can leave
    it out in this kind of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the area below the graph of *f(x)* and above the *x*-axis, as well
    as between [0, 6] on the *x*-axis, is equal to 60 square units. The following
    shows a few rules of thumb on integrals (after all, this chapter is supposed to
    refresh your knowledge or to give you a basic understanding of a few key mathematical
    concepts):'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the integral of a constant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral a d x equals a x plus upper C"><mrow><mo>∫</mo> <mi>a</mi>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>a</mi> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the integral of a variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral x d x equals one-half x squared plus upper C"><mrow><mo>∫</mo>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the integral of a reciprocal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral StartFraction 1 Over x EndFraction d x equals ln StartAbsoluteValue
    x EndAbsoluteValue plus upper C"><mrow><mo>∫</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mo form="prefix">ln</mo> <mrow><mo>|</mo> <mi>x</mi>
    <mo>|</mo></mrow> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the integral of an exponential:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral a Superscript x Baseline d x equals StartFraction a
    Superscript x Baseline Over ln left-parenthesis a right-parenthesis EndFraction
    plus upper C"><mrow><mo>∫</mo> <msup><mi>a</mi> <mi>x</mi></msup> <mi>d</mi> <mi>x</mi>
    <mo>=</mo> <mfrac><msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo form="prefix">ln</mo><mo>(</mo><mi>a</mi><mo>)</mo></mrow></mfrac>
    <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral e Superscript x Baseline d x equals e Superscript x
    Baseline plus upper C"><mrow><mo>∫</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mi>d</mi>
    <mi>x</mi> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The *fundamental theorem of calculus* links derivatives with integrals. This
    means that it defines derivatives in terms of integrals and vice versa. The fundamental
    theorem of calculus is actually made up of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Part I
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the fundamental theorem of calculus states that if you have
    a continuous function *f(x)*, then the original function *F(x)* defined as the
    antiderivative of *f(x)* from a fixed starting point *a* up to *x*, is a function
    that is differentiable everywhere from *a* to *x*, and its derivative is simply
    *f(x)* evaluated at *x*.
  prefs: []
  type: TYPE_NORMAL
- en: Part II
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the fundamental theorem of calculus states that if you have
    a function *f(x)* that is continuous over a certain interval [*a, b*], and you
    define a new function *F(x)* as the integral of *f(x)* from *a* to *x*, then the
    definite integral of *f(x)* over that same interval [*a, b*] can be calculated
    as *F(b) - F(a)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The theorem is useful in many fields including physics and engineering, but
    optimization and other mathematical models also benefit from it. Some examples
    of using integrals in the different learning algorithms can be summed up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Density estimation
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are used in *density estimation*, a part of many machine learning
    algorithms, to calculate the probability density function.
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcement learning
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are used in reinforcement learning to calculate expected values of
    reward functions. Reinforcement learning is covered in Chapter 10.
  prefs: []
  type: TYPE_NORMAL
- en: Bayesian models
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are used in *Bayesian inference*, a statistical framework for modeling
    uncertainty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key points of this section on integrals are as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are also known as antiderivatives and they are the opposite of derivatives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indefinite integrals find the area under the curve everywhere while definite
    integrals are bounded within an interval given by point *a* and point *b*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamental theorem of calculus is the bridge between derivatives and integrals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrals are used in machine learning for modeling uncertainty, making predictions,
    and estimating expected values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several machine and deep learning algorithms depend on optimization techniques
    to decrease error functions. This section discusses a primordial concept in the
    different learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimization* is the process of finding the best solution among the possible
    solutions’ universe. Optimization is all about finding the highest and lowest
    points of a function. Figure 4-17 shows the graph for the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4
    Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph18.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17\. The graph of the function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *local minimum* exists when values on the right of the *x*-axis are decreasing
    until reaching a point where they start increasing. The point does not have to
    necessarily be the lowest point in the function, hence the name *local*. In Figure
    4-18, the function has a local minimum at point A.
  prefs: []
  type: TYPE_NORMAL
- en: A *local maximum* exists when values on the right of the x-axis are increasing
    until reaching a point where they start decreasing. The point does not have to
    necessarily be the highest point in the function. In Figure 4-18, the function
    has a local maximum at point B.
  prefs: []
  type: TYPE_NORMAL
- en: A *global minimum* exists when values on the right of the x-axis are decreasing
    until reaching a point where they start increasing. The point must be the lowest
    point in the function hence the name global. In Figure 4-18, the function has
    a global minimum at point C.
  prefs: []
  type: TYPE_NORMAL
- en: A *global maximum* exists when values on the right of the x-axis are increasing
    until reaching a point where they start decreasing without. The point must be
    the highest point in the function. In Figure 4-18, there is no global maximum,
    as the function will continue infinitely without shaping a top. You can clearly
    see how the function accelerates upwards.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with machine and deep learning models, the aim is to find model
    parameters (or inputs) that minimize what is known as a *loss function* (a function
    that gives the error of forecasts). If the loss function is convex, optimization
    techniques should find the parameters that tend towards the global minimum where
    the loss function is minimized. Furthermore, if the loss function is non-convex,
    the convergence is not guaranteed, and the optimization may only lead towards
    approaching a local minimum, which is a part of the aim, but this leaves the global
    minimum which is the final aim.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how are these minima and maxima found? Let’s look at it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to perform the first derivative test (which is simply calculating
    the derivative of the function). Then, setting the function equal to zero and
    solving for *x* will give what is known as critical points. *Critical points*
    are the points where the function changes direction (the values stop going in
    one direction and start going in another). Therefore, these points are maxima
    and minima.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is to perform the second derivative test (which is simply calculating
    the derivative of the derivative). Then, setting the function equal to zero and
    solving for *x* will give what is known as inflection points. *Inflection points*
    give where the function is concave up and where it is concave down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In other words, critical points are where the function changes direction and
    inflection points are where the function changes its concavity. Figure 4-19 shows
    the difference between a concave up function and a concave down function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_graph19.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-18\. A concave up versus a concave down functions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: <math alttext="upper C o n c a v e u p f u n c t i o n equals x squared"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>c</mi> <mi>a</mi> <mi>v</mi> <mi>e</mi> <mi>u</mi> <mi>p</mi>
    <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper C o n c a v e d o w n f u n c t i o n equals minus x squared"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>c</mi> <mi>a</mi> <mi>v</mi> <mi>e</mi> <mi>d</mi> <mi>o</mi>
    <mi>w</mi> <mi>n</mi> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi>
    <mi>o</mi> <mi>n</mi> <mo>=</mo> <mo>-</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to find the extrema are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the first derivative and set it to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the first derivative to find *x*. The values are called critical points
    and they represent the points where the function changes the direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug in values in the formula that are either below or above the critical points.
    If the result of the first derivative is positive it means that it’s increasing
    around that point and if it’s negative, then it means that it’s decreasing around
    that point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the second derivative and set it to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the second derivative to find *x*. The values, called inflection points, represent
    the points where concavity changes from up to down and vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug in values in the formula that are either below or above the inflection
    points. If the result of the second derivative is positive, it means there is
    a minimum at that point, and if it’s negative it means there is a maximum at that
    point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to understand that the first derivative and second derivative
    tests relate to critical points as opposed to the second derivative test relating
    to inflection points. The following example finds the extrema of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    x plus 4"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to take the first derivative, set it to zero, and solve for
    *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    1"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 x plus 1 equals 0"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals negative one-half"><mrow><mi>x</mi> <mo>=</mo> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, there is a critical point at that value. Now, the next step is to
    find the second derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f double-prime left-parenthesis x right-parenthesis equals 2"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the critical point must be plugged into the second derivative formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f double-prime left-parenthesis negative one-half right-parenthesis
    equals 2"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The second derivative is positive at the critical point. This means that there
    is a local minimum at that point.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, you will see more complex optimization techniques such
    as the gradient descent and the stochastic gradient descent, which are fairly
    common in machine learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key points of this section on optimization are as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization is the process of finding the function’s extrema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical points are the points where the function changes direction (the values
    stop going in one direction and start going in another)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inflection points give where the function is concave up and where it is concave
    down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A loss function is a function that measures the error of forecasts in predictive
    machine learning. It needs to be minimized in order to increase the accuracy of
    the model. Optimization of the loss function can be done through the discussed
    ways or through what is known as a gradient, a technique out of scope of the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chapters 2, 3, and 4 have presented the main numerical concepts that you need
    to start understanding basic machine and deep learning models. I have made all
    reasonable efforts to simplify as much as possible the technical requirements,
    I do encourage you to read these three chapters at least twice so that everything
    you have learned becomes a second nature.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, such a complex field requires more in-depth knowledge in mathematics,
    but I believe that with the concepts seen in this chapter, you may start discovering
    and building the models in Python. After all, they come pre-built from packages
    and libraries, and the aim of this chapter is to understand what you are working
    with It is unlikely that you will build the models from scratch using archaic
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have gained a certain understanding of data science and the
    mathematical requirements that will get you started comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.xhtml#idm46147468230768-marker)) Matrices can also contain symbols
    and expressions but for the sake of simplicity, let’s stick to numbers.
  prefs: []
  type: TYPE_NORMAL
