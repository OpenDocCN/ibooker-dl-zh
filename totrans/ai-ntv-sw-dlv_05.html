<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Securing Applications and the Software Supply Chain"><div class="chapter" id="chapter_5_securing_applications_and_the_software_supply_chai_1749354010735711">
      <h1><span class="label">Chapter 5. </span>Securing Applications <span class="keep-together">and the Software Supply Chain</span></h1>
      <p>We’ve touched on security<a contenteditable="false" data-type="indexterm" data-primary="security considerations" id="xi_securityconsiderations5335"/> tools and practices throughout this book as we’ve navigated the delivery process from SCM to continuous integration and delivery. We discussed how RBAC and Policy-as-Code (PaC) governance in modern tools help secure your code repositories and pipelines, and we mentioned the role of early security testing in continuous integration. We looked at dynamic testing to uncover runtime vulnerabilities in your applications. This has been a light touch on security. </p>
      <p>In this chapter, we’ll bring security to the forefront and give it the attention it deserves in a world where cyberattacks are growing in both frequency and sophistication. High-profile breaches regularly make headlines, regulations are tightening globally, and customers increasingly evaluate vendors based on security posture. </p>
      <p>With release cycles measured in days rather than months, the traditional model of security as a final gate before production has become untenable. Instead, we have shifted the burden “left” toward developers<a contenteditable="false" data-type="indexterm" data-primary="shift-left security" id="id690"/>, who must now integrate security practices into their daily workflows. Developers who are not security experts now bear an unprecedented burden of security responsibility.</p>
      <p>Artificial intelligence<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="security tools" id="id691"/> promises some relief for this tension. AI-powered security tools are improving detection accuracy, dramatically reducing false positives that waste developer time, and even automatically generating remediation code. Rather than simply shifting the security burden left, AI helps share that burden, providing developers with expert-level security guidance without requiring them to become security experts themselves. </p>
      <p class="pagebreak-before">This chapter will cover how the evolution toward AI-native software delivery has transformed how we approach security—not by simply adding more tools or processes, but by fundamentally changing how we identify, prioritize, and remediate security issues. We’ll look at the importance of software supply chain security that is protecting the tools, processes, and people involved with how software is built and delivered, from the initial code to the final product. It’s a critical concern as modern software relies heavily on interconnected components, each presenting potential vulnerabilities that could be exploited by malicious actors.</p>
      <p>Understanding supply chain concerns and learning to evaluate your SDLC<a contenteditable="false" data-type="indexterm" data-primary="software development lifecycle (SDLC)" id="id692"/><a contenteditable="false" data-type="indexterm" data-primary="SDLC (software development lifecycle)" id="id693"/> with a security lens will equip you to put strong security measures in place and better protect your applications, data, and your organization’s reputation.</p>
      <section data-type="sect1" data-pdf-bookmark="Modern Applications and the Cyberthreat Landscape"><div class="sect1" id="chapter_5_modern_applications_and_the_cyberthreat_landscape_1749354010735862">
        <h1>Modern Applications and the Cyberthreat Landscape</h1>
        <p>Building and deploying modern software<a contenteditable="false" data-type="indexterm" data-primary="security considerations" data-secondary="cyberthreat landscape for applications" id="xi_securityconsiderationscyberthreatlandscapeforapplications51150"/><a contenteditable="false" data-type="indexterm" data-primary="cyberthreat landscape for applications" id="xi_cyberthreatlandscapeforapplications51150"/> applications relies heavily on distributed and complex software supply chains. These supply chains often encompass a vast network of code repositories, open source dependencies, third-party components, artifact repositories, and CI/CD pipelines. While this interconnectedness fosters innovation and accelerates our development cycles, it also introduces security risks throughout. The expanding attack surface and the potential for vulnerabilities to propagate throughout the supply chain have made our software supply chains a prime target for malicious actors. </p>
        <p>In this section we’ll look at these threats and learn how regulatory compliance frameworks that govern software supply chains are evolving to address them. Finally we’ll look at how new compliance requirements impact your organization.</p>
        <section data-type="sect2" data-pdf-bookmark="The Growing Threat of Software Supply Chain Attacks"><div class="sect2" id="chapter_5_the_growing_threat_of_software_supply_chain_attack_1749354010735922">
          <h2>The Growing Threat of Software Supply Chain Attacks</h2>
          <p>The software supply chain<a contenteditable="false" data-type="indexterm" data-primary="software supply chains" data-secondary="growth of cyberthreats to" id="xi_softwaresupplychainsgrowthofcyberthreatsto51539"/> encompasses all of the people, processes, and tools involved in creating and delivering software. It spans the complete lifecycle of software development, from the initial code creation to its deployment and maintenance. It’s a complex ecosystem where each element plays a crucial role in the final product.</p>
          <p>The software supply chain is made up of two primary concerns: applications and the DevOps toolchain, as shown in <a data-type="xref" href="#chapter_5_figure_1_1749354010722636">Figure 5-1</a>.</p>
          <figure><div id="chapter_5_figure_1_1749354010722636" class="figure">
            <img src="assets/ansd_0501.png" width="600" height="311"/>
            <h6><span class="label">Figure 5-1. </span>The software supply chain</h6>
          </div></figure>
          <section data-type="sect3" data-pdf-bookmark="Applications risks in the software supply chain"><div class="sect3" id="chapter_5_applications_risks_in_the_software_supply_chain_1749354010735975">
            <h3>Applications risks in the software supply chain</h3>
            <p>“Applications” here refers to all of the elements of your software<a contenteditable="false" data-type="indexterm" data-primary="application risks in software supply chain" id="id694"/>, including your proprietary source code; open source dependencies like libraries, frameworks, and modules; and the software artifacts produced during the development process. </p>
            <p>According to the 2024 Open Source Security and Risk Analysis report by Synopsys, 96% of codebases contain open source components. It’s important to remember that our organizations are responsible for securing the open source<a contenteditable="false" data-type="indexterm" data-primary="open source software (OSS)" data-secondary="vulnerability to cyberthreats" id="id695"/> components we use, just as they are with internally developed code. Because open source usage is so widespread, we shouldn’t be surprised that over 80% of vulnerabilities found in applications are from OSS dependencies. A vulnerability discovered in 2021 in a widely used Java logging library called Log4j<a contenteditable="false" data-type="indexterm" data-primary="Log4j" id="id696"/> is an example of an open source–introduced threat. This vulnerability allowed attackers to remotely execute code on affected systems simply by sending a specially crafted string to the application’s log. The exploit was exceptionally dangerous due to the widespread use of Log4j in applications and services, leading to a massive scramble to patch and mitigate the vulnerability. </p>
            <p>The discovery of a backdoor in the widely used XZ Utils data compression tool<a contenteditable="false" data-type="indexterm" data-primary="XZ Utils data compression tool" id="id697"/> provides another example. XZ Utils, like many OSS projects, is maintained by volunteers with limited resources for addressing security issues. One trusted contributor was found to have implemented a backdoor that would have allowed an attacker to gain administrator privileges to systems running software built with the tool. This utility is present in most Linux distributions, and was fortunately discovered before the tool had been widely deployed in production systems.</p>
            <p class="pagebreak-before">Another emerging threat in the application supply chain exploits the hallucinations of AI coding assistants<a contenteditable="false" data-type="indexterm" data-primary="AI coding assistants" data-secondary="hallucinations security issue" id="id698"/>. When AI models hallucinate package names, recommending nonexistent libraries or incorrect package identifiers, they create an opportunity for attackers. Malicious actors can monitor popular AI coding assistants for such hallucinations, and then register these hallucinated package names in public repositories. When developers attempt to use these nonexistent but AI-recommended packages, they unknowingly install malicious code. This “hallucination squatting” attack vector<a contenteditable="false" data-type="indexterm" data-primary="hallucination squatting, by cyber attackers" id="id699"/> has already been observed in the wild, with researchers finding that common coding assistants frequently suggest nonexistent packages. </p>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="DevOps risks in the software supply chain"><div class="sect3" id="chapter_5_devops_risks_in_the_software_supply_chain_1749354010736023">
            <h3>DevOps risks in the software supply chain</h3>
            <p>The DevOps toolchain includes the suite of tools and processes used to automate the building, testing, and deployment of your software. This encompasses code repositories, CI/CD tools and pipelines, artifact registries, and other tools that streamline the development process such as GitOps and IaCM tools.</p>
            <p>The SolarWinds hack<a contenteditable="false" data-type="indexterm" data-primary="SolarWinds hack" id="id700"/> stands as a stark example of how a compromised DevOps toolchain can be exploited to propagate malicious code. In this sophisticated attack, threat actors infiltrated the SolarWinds Orion software build system, injecting malicious code into legitimate software updates. These tainted updates were then distributed to eighteen thousand SolarWinds customers, granting the attackers widespread access to their networks. This incident highlighted the potential for attackers to leverage the trust and automation inherent in DevOps pipelines to distribute malware at scale, turning a routine software update into a devastating cyberattack.</p>
            <p>The Codecov supply chain hack<a contenteditable="false" data-type="indexterm" data-primary="Codecov supply chain hack" id="id701"/> in 2021 is another example of a toolchain security breach, one that impacted thousands of organizations. Malicious actors modified a Codecov Bash Uploader script (a tool customers use to upload code coverage data). This modification allowed the attackers to exfiltrate sensitive information, such as tokens, keys, and credentials from the continuous integration environments of Codecov’s customers. The breach went undetected for over two months, potentially exposing sensitive data stored in customers’ continuous integration environments.</p>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="A threat that is growing"><div class="sect3" id="chapter_5_a_threat_that_is_growing_1749354010736072">
            <h3>A threat that is growing</h3>
            <p>Software supply chain attacks are not going away. <a href="https://oreil.ly/Uwphu">Gartner Research</a> predicts that by 2025, 45% of organizations worldwide will have experienced attacks on their software supply chains. A security flaw in a line of code, a third-party library, or a tool in your pipeline can have a ripple effect, compromising the entire software product. Securing the software supply chain is about not just protecting individual components but also ensuring the integrity and security of the entire development and delivery process<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_softwaresupplychainsgrowthofcyberthreatsto51539" id="id702"/>.</p>
          </div></section>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Regulatory Compliance Frameworks That Apply to Software Supply Chains"><div class="sect2" id="chapter_5_regulatory_compliance_frameworks_that_apply_to_sof_1749354010736121">
          <h2>Regulatory Compliance Frameworks That Apply <span class="keep-together">to Software Supply Chains</span></h2>
          <p>Given the increasing threat, governments and regulating<a contenteditable="false" data-type="indexterm" data-primary="regulatory environments" id="xi_regulatoryenvironments54169"/><a contenteditable="false" data-type="indexterm" data-primary="software supply chains" data-secondary="regulatory compliance frameworks" id="xi_softwaresupplychainsregulatorycomplianceframeworks54169"/> authorities have responded with regulations that aim to address these challenges by establishing best practices, promoting transparency, and requiring organizations to take proactive measures to secure their software supply chains. Some of the most important compliance and regulatory frameworks that have emerged include the following:</p>
          <dl>
            <dt>United States Executive Order 14028, Improving the Nation’s Cybersecurity</dt>
            <dd>
              <p>This executive order<a contenteditable="false" data-type="indexterm" data-primary="United States Executive Order 14028, Improving the Nation’s Cybersecurity" id="id703"/>, issued in 2021, mandates that federal agencies and their software providers enhance their software supply chain security practices. It emphasizes the use of secure software development practices, vulnerability disclosure, and incident response.</p>
            </dd>
            <dt>The European Union’s Network and Information Security 2 Directive (NIS2 Directive)</dt>
            <dd>
              <p>This directive<a contenteditable="false" data-type="indexterm" data-primary="EU Network and Information Security 2 Directive (NIS2 Directive)" id="id704"/><a contenteditable="false" data-type="indexterm" data-primary="NIS2 Directive (Network and Information Security 2 Directive)" id="id705"/> aims to establish a high common level of cybersecurity across the EU. It includes provisions on software supply chain security, requiring organizations to assess and manage risks associated with software components and third-party dependencies.</p>
            </dd>
            <dt>NIST SP 800-218, Secure Software Development Framework (SSDF)</dt>
            <dd>
              <p>This National Institute of Standards and Technology publication<a contenteditable="false" data-type="indexterm" data-primary="NIST SP 800-218, Secure Software Development Framework (SSDF)" id="id706"/><a contenteditable="false" data-type="indexterm" data-primary="SSDF (NIST SP 800-218, Secure Software Development Framework)" id="id707"/> offers guidance for integrating security into the SDLC, including supply chain risk management. It provides a comprehensive framework for secure software development <span class="keep-together">practices</span>.</p>
            </dd>
            <dt>ISO/IEC 27036-2:2023</dt>
            <dd>
              <p>This standard<a contenteditable="false" data-type="indexterm" data-primary="ISO/IEC 27036-2:2023" id="id708"/> offers guidelines for managing information security risks related to suppliers and the supply chain. It covers various aspects, including supplier selection, contract management, and performance monitoring.</p>
            </dd>
            <dt>Payment Card Industry Data Security Standard (PCI DSS)</dt>
            <dd>
              <p>While not solely focused on the software supply chain<a contenteditable="false" data-type="indexterm" data-primary="Payment Card Industry Data Security Standard (PCI DSS)" id="id709"/>, PCI DSS requires organizations handling payment card data to implement secure software development practices, which include managing supply chain risks.</p>
            </dd>
            <dt>Cyber Resilience Act (CRA)</dt>
            <dd>
              <p>This proposed EU regulation<a contenteditable="false" data-type="indexterm" data-primary="Cyber Resilience Act (CRA)" id="id710"/><a contenteditable="false" data-type="indexterm" data-primary="CRA (Cyber Resilience Act)" id="id711"/> aims to enhance the cybersecurity of digital products and services. It includes requirements for vulnerability handling, security updates, software bill of materials (SBOM), and reporting actively exploited vulnerabilities within 24 hours of awareness.</p>
            </dd>
          </dl>
          <p class="pagebreak-before">In addition, Quality System Regulation (QSR) (21 CFR Part 820)<a contenteditable="false" data-type="indexterm" data-primary="Quality System Regulation (QSR) (21 CFR Part 820)" id="id712"/> and General Data Protection Regulation (GDPR)<a contenteditable="false" data-type="indexterm" data-primary="General Data Protection Regulation (GDPR)" id="id713"/> are frameworks that regulate software practices that indirectly impact software supply chain concerns. The QSR mandates rigorous controls and processes to ensure the safety and effectiveness of medical devices, encompassing software components. This includes requiring manufacturers to validate and control the software integrated into their devices. Similarly, GDPR’s stringent requirements for protecting personal data necessitate that organizations implement robust technical and organizational measures, potentially extending to the security of software and its supply chain, especially if it processes personal data. </p>
          <p>These frameworks and regulations contribute to a more secure and resilient software ecosystem, benefiting both businesses and consumers. However, the increased complexity can impact development teams. Understanding these requirements and integrating them into your processes is critical for successful compliance<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_securityconsiderationscyberthreatlandscapeforapplications51150" id="id714"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_cyberthreatlandscapeforapplications51150" id="id715"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_regulatoryenvironments54169" id="id716"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_softwaresupplychainsregulatorycomplianceframeworks54169" id="id717"/>.</p>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Securing Modern Applications with Shift Left"><div class="sect1" id="chapter_5_securing_modern_applications_with_shift_left_1749354010736171">
        <h1>Securing Modern Applications with Shift Left</h1>
        <p>Against highly motivated hackers, our traditional wait-until-the-end security methods are not enough<a contenteditable="false" data-type="indexterm" data-primary="shift-left security" id="xi_shiftleftsecurity574112"/>. Not only do these measures not provide the protection we require, but traditional security testing also slows the delivery of our software. To protect modern applications, organizations must use tools and practices designed for modern DevOps workflows. In this section we’ll look at the challenges organizations face in implementing security practices. In <a data-type="xref" href="ch03.html#chapter_3_the_build_and_pre_deployment_testing_steps_of_cont_1749354010266208">Chapter 3</a> we touched on shift-left security, the practice of implementing security practices in the earliest stages of development. We’ll look at how to use this approach to mitigate risks, as well as best practices for implementing shift-left security and managing vulnerabilities in a developer-friendly way.</p>
        <section data-type="sect2" data-pdf-bookmark="The Need for Developer-Friendly Shift-Left Security"><div class="sect2" id="chapter_5_the_need_for_developer_friendly_shift_left_securit_1749354010736221">
          <h2>The Need for Developer-Friendly Shift-Left Security</h2>
          <p>Rather than waiting until the end of the software development cycle to test the security of your application, you must actively address and test security concerns at every possible stage. This approach not only saves time and effort by avoiding extensive reworking of the software code later on but also enhances the overall security and efficiency of the final product. <a data-type="xref" href="#chapter_5_figure_2_1749354010722665">Figure 5-2</a> contrasts a shift-left security approach with a traditional application security approach.</p>
          
          
     <p>It’s important to note that effective shift-left security means more than performing security testing earlier in your delivery process. While this may help save developers from the cost of context switches that come when returning to code after days or weeks, it’s ultimately not saving work. A truly effective implementation requires choosing security tools that seamlessly integrate with your CI/CD pipelines. These tools should not only identify vulnerabilities but also prioritize them based on severity and provide actionable insights. The tools you choose should normalize and de-duplicate findings, to help developers avoid alert fatigue and concentrate on the most critical risks. This integrated approach ensures that security is absolutely central to the development process.</p>
     
          
          <figure><div id="chapter_5_figure_2_1749354010722665" class="figure">
            <img src="assets/ansd_0502.png" width="600" height="217"/>
            <h6><span class="label">Figure 5-2. </span>Shift-left approach contrasted with a traditional testing approach</h6>
          </div></figure>
          
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Application Security Scanners"><div class="sect2" id="chapter_5_application_security_scanners_1749354010736266">
          <h2>Application Security Scanners</h2>
          <p>There are numerous scanners<a contenteditable="false" data-type="indexterm" data-primary="application security scanners" id="xi_applicationsecurityscanners58641"/> and tools available to do security testing and analysis, and many are now enhanced with AI capabilities. Let’s look at the most common categories of these scanners and tools:</p>
          <dl>
            <dt>Software composition analysis (SCA)</dt>
            <dd>
              <p>This type of scanner<a contenteditable="false" data-type="indexterm" data-primary="software composition analysis (SCA)" id="id718"/><a contenteditable="false" data-type="indexterm" data-primary="SCA (software composition analysis)" id="id719"/> identifies vulnerabilities in third-party components and dependencies by analyzing software bills of materials (SBOMs)<a contenteditable="false" data-type="indexterm" data-primary="software bills of materials (SBOMs)" id="id720"/><a contenteditable="false" data-type="indexterm" data-primary="bills of materials, software" id="id721"/><a contenteditable="false" data-type="indexterm" data-primary="SBOMs (software bills of materials)" id="id722"/> to detect known vulnerabilities in libraries and frameworks. We’ll look at SBOMs later in this chapter. SCA tools feature significant ML capabilities around the likelihood a vulnerability can be reached or exploited. Snyk is one popular example of an SCA scanner.</p>
            </dd>
            <dt>Static application security testing (SAST)</dt>
            <dd>
              <p>SAST tools<a contenteditable="false" data-type="indexterm" data-primary="static application security testing (SAST)" id="id723"/><a contenteditable="false" data-type="indexterm" data-primary="SAST (static application security testing)" id="id724"/> analyze source code for potential vulnerabilities without executing the application by scanning code for patterns indicative of vulnerabilities, such as SQL injection, XSS, and buffer overflows. AI is enhancing SAST to reduce the incidence of false positives, wasting less engineer time. SonarQube<a contenteditable="false" data-type="indexterm" data-primary="SonarQube" id="id725"/>, Checkmarx<a contenteditable="false" data-type="indexterm" data-primary="Checkmarx" id="id726"/>, and Fortify are examples of SAST tools.</p>
            </dd>
            <dt>Container scanning</dt>
            <dd>
              <p>This type of scanning<a contenteditable="false" data-type="indexterm" data-primary="container image" id="id727"/> identifies vulnerabilities in container images and their dependencies by analyzing the contents of container images for known vulnerabilities and configuration errors.</p>
            </dd>
            <dt class="pagebreak-before less_space">Secret detection scanning</dt>
            <dd>
              <p class="fix_tracking">This type of scanning detects sensitive information<a contenteditable="false" data-type="indexterm" data-primary="secret detection" id="id728"/>, such as API keys, passwords, and tokens, within code repositories and configuration files. With AI, secret detection tools are getting better at detecting obfuscated secrets and distinguishing between actual credentials and test data, reducing false positives and the associated toil. </p>
            </dd>
            <dt>Dynamic application security testing</dt>
            <dd>
              <p class="fix_tracking">This<strong> </strong>testing method analyzes a running application<a contenteditable="false" data-type="indexterm" data-primary="dynamic application security testing (DAST)" id="id729"/><a contenteditable="false" data-type="indexterm" data-primary="DAST (dynamic application security testing)" id="id730"/> to identify vulnerabilities by simulating external attacks. It interacts with the application like a real user to detect issues such as injection flaws, authentication problems, and configuration errors without needing access to the source code. AI-enhanced DAST tools generate test cases based on application behavior rather than using fixed patterns. They attempt to automatically validate their findings to tackle the false-positive problem.</p>
            </dd>
            <dt>Infrastructure-as-Code scanning</dt>
            <dd>
              <p>This type of scan analyzes IaC<a contenteditable="false" data-type="indexterm" data-primary="IaC (Infrastructure as Code)" id="id731"/><a contenteditable="false" data-type="indexterm" data-primary="Infrastructure as Code (IaC)" id="id732"/> files to identify security vulnerabilities, misconfigurations, and compliance issues before deployment.</p>
            </dd>
          </dl>
          <p>These types of scanners are integrated early in software development pipelines, in line with the shift-left approach. Secret scanning is a recommended security practice that automatically identifies and alerts users to sensitive information in code repositories and other data sources.</p>
          <p class="fix_tracking">This prevents sensitive information from being incorporated into a codebase to begin with. SCA<a contenteditable="false" data-type="indexterm" data-primary="SCA (software composition analysis)" id="id733"/><a contenteditable="false" data-type="indexterm" data-primary="software composition analysis (SCA)" id="id734"/> tools are also typically integrated early in the pipeline, after code is committed and before building. SAST<a contenteditable="false" data-type="indexterm" data-primary="SAST (static application security testing)" id="id735"/><a contenteditable="false" data-type="indexterm" data-primary="static application security testing (SAST)" id="id736"/> scans can be part of a build phase. Container scanning is typically integrated after container images are built and before deployment.</p>
          <p>By incorporating SCA, SAST, container scanning, secret scanning, DAST, and IaC scanning throughout your development pipelines, you can effectively implement shift-left security and proactively protect your applications from vulnerabilities.</p>
          <p>Every issue that your test tools identify must be triaged. There is cost in reviewing the issue, determining if it is real or not, and then remediating it. False positives, issues that are reported but are not real, are a significant problem. They waste the time of the reviewer, draining resources from other security efforts and innovation. Further, by “crying wolf” they diminish the trust engineers place in security findings, and can slow response times to other, real problems. With this in mind, it’s no surprise that reducing the number of false positives is a key priority for AI<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="security tools" id="id737"/> in many scanning tools.</p>
          <p>The triage problem is exacerbated by the number of scanners involved, which may find the same issues in different ways. In some organizations, there may even be multiple SAST tools used on the same codebase. In these environments, security test orchestration layers may be used to de-duplicate and normalize the findings into a single, manageable list. In an AI-native environment, AI/ML has a role to play here in pattern-matching as well as reducing developer toil.</p>
          <p>Issues will be detected across all these types of scanners and need to be remediated. Security tools are increasingly offering automated or semi-automated remediation through specialized AI coding assistants to streamline this process for developers<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_shiftleftsecurity574112" id="id738"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_applicationsecurityscanners58641" id="id739"/>.</p>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Securing the Software Supply Chain"><div class="sect1" id="chapter_5_securing_the_software_supply_chain_1749354010736316">
        <h1>Securing the Software Supply Chain</h1>
        <p>In this section we’ll examine common security<a contenteditable="false" data-type="indexterm" data-primary="security considerations" data-secondary="software supply chain" id="id740"/><a contenteditable="false" data-type="indexterm" data-primary="software supply chains" data-secondary="security considerations" id="id741"/> risks inherent to today’s software supply chains. We’ll look at risks associated with code repositories, CI/CD pipelines, artifact repositories, open source dependencies, and the infrastructure underpinning your software development process. AI is transforming how organizations detect and respond to these risks by identifying patterns and anomalies across complex supply chains that would be impossible to monitor manually at scale. We’ll look at various frameworks and benchmarks you can use to assess the security of your toolchain. By the end of this section, you’ll have a better understanding of the potential threats and how to mitigate them.</p>
        <p>The complexity of modern software supply chains creates an ideal use case for artificial intelligence. AI systems<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="usefulness for securing software supply chains" id="id742"/> can continuously monitor for suspicious patterns across repositories, build systems, and deployments. For example, ML models can detect unusual commit patterns that might indicate a compromised developer account, identify suspicious package behavior that signals a potential supply chain attack, or spot configuration drifts that could create security vulnerabilities. These AI capabilities provide unprecedented visibility and protection across interconnected <span class="keep-together">components.</span></p>
        <section data-type="sect2" data-pdf-bookmark="Identifying Top CI/CD Security Risks"><div class="sect2" id="chapter_5_identifying_top_ci_cd_security_risks_1749354010736367">
          <h2>Identifying Top CI/CD Security Risks</h2>
          <p>The Open Worldwide Application Security Project (OWASP), a leading organization focused on improving software security, has identified the top 10 CI/CD security risks<a contenteditable="false" data-type="indexterm" data-primary="CI/CD pipeline" data-secondary="security risk identification" id="xi_CICDpipelinesecurityriskidentification5127180"/>. As the following list illustrates, the range of threats are diverse. Understanding these risks and implementing the recommended mitigation strategies will help you secure and strengthen your CI/CD ecosystem:</p>
          <dl>
            <dt>Insufficient flow control mechanisms</dt>
            <dd>
              <p>Insufficient flow control mechanisms in CI/CD pipelines<a contenteditable="false" data-type="indexterm" data-primary="insufficient flow control mechanisms, CI/CD pipelines" id="id743"/> can be exploited by attackers who can gain access to your pipeline. By bypassing necessary reviews and approvals, malicious code or artifacts can be pushed through the pipeline, potentially reaching production environments with severe consequences.</p>
            </dd>
            <dt>Inadequate identity and access management</dt>
            <dd>
              <p>The complexity of managing numerous identities across various systems<a contenteditable="false" data-type="indexterm" data-primary="identity and access management, security issue" id="id744"/>, combined with the tendency for overly permissive accounts, can lead to compromise. If any user account is compromised, attackers could gain extensive access, potentially reaching the production environment. </p>
            </dd>
            <dt>Dependency chain abuse</dt>
            <dd>
              <p>Dependency chain<a contenteditable="false" data-type="indexterm" data-primary="dependency chain, exploitation of vulnerabilities in" id="id745"/> abuse refers to the exploitation of vulnerabilities in how your development and build systems fetch code dependencies. This can happen when these systems are tricked into fetching and executing malicious packages instead of legitimate ones. Attackers exploit it by publishing malicious packages with the same name as internal packages (dependency confusion), hijacking maintainer accounts (dependency hijacking), or relying on typos (typosquatting) to trick developers into downloading their packages.</p>
            </dd>
            <dt>Poisoned pipeline execution </dt>
            <dd>
              <p>This is a cyberattack where malicious code is injected into a CI/CD pipeline<a contenteditable="false" data-type="indexterm" data-primary="poisoned pipeline execution" id="id746"/>, often through compromised source control systems. The poisoned code can then be executed within the pipeline, potentially granting attackers the same access and privileges as the build job. The attacker can manipulate build configuration files or other files the pipeline relies on, leading to actions such as credential theft, data exfiltration, or deployment of malicious artifacts.</p>
            </dd>
            <dt>Insufficient pipeline-based access controls</dt>
            <dd>
              <p>The risk arises when pipeline execution nodes have excessive access<a contenteditable="false" data-type="indexterm" data-primary="accessibility" id="id747"/> to resources and systems. This can be exploited by attackers to run malicious code within a pipeline, abusing the permissions granted to the pipeline to move laterally within or outside the CI/CD system. </p>
            </dd>
            <dt>Insufficient credential hygiene</dt>
            <dd>
              <p>Insufficient credential hygiene<a contenteditable="false" data-type="indexterm" data-primary="credential hygiene, insufficient" id="id748"/> is a significant risk in environments where credentials are widely used across different systems and contexts. Examples include accidental code pushes containing credentials, insecure usage in build and deployment processes, unrotated credentials, and credentials being printed to console outputs or stored within container images. </p>
            </dd>
            <dt>Insecure system configuration</dt>
            <dd>
              <p>Insecure system configuration<a contenteditable="false" data-type="indexterm" data-primary="system configuration, insecure" id="id749"/> is a common vulnerability due to the numerous systems and vendors in a typical toolchain. Misconfigurations, such as outdated software, overly permissive access controls, or insecure default settings, can easily be exploited by attackers to gain unauthorized access, manipulate CI/CD flows, or even compromise production environments. </p>
            </dd>
            <dt>Ungoverned usage of third-party services</dt>
            <dd>
              <p class="fix_tracking">Third-party services<a contenteditable="false" data-type="indexterm" data-primary="third-party services, ungoverned use of" id="id750"/> in CI/CD pipelines, while convenient and valuable for development, can easily be granted excessive access to sensitive resources, effectively expanding the attack surface of an organization. This lack of governance and visibility makes it difficult to maintain proper access controls, leaving organizations vulnerable to attacks if any of these third-party services are compromised. </p>
            </dd>
            <dt>Improper artifact integrity validation</dt>
            <dd>
              <p>Due to the multiple stages and sources involved in software delivery, malicious actors can potentially tamper with artifacts<a contenteditable="false" data-type="indexterm" data-primary="artifact integrity validation" id="id751"/> without raising alarms. If not detected, these compromised artifacts can flow through the pipeline and eventually be deployed into production, executing malicious code and compromising systems. </p>
            </dd>
            <dt>Insufficient logging and visibility</dt>
            <dd>
              <p>Without robust logging<a contenteditable="false" data-type="indexterm" data-primary="logs and logging" data-secondary="insufficient visibility" id="id752"/>, you’re essentially blind to malicious activities happening within your development pipeline, making it difficult to detect and respond to attacks in a timely manner. </p>
            </dd>
          </dl>
          <p>Understanding these risks and implementing the recommended mitigation strategies is key to building a secure and resilient CI/CD ecosystem<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_CICDpipelinesecurityriskidentification5127180" id="id753"/>.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Identifying Top OSS Risks"><div class="sect2" id="chapter_5_identifying_top_oss_risks_1749354010736413">
          <h2>Identifying Top OSS Risks</h2>
          <p>OSS<a contenteditable="false" data-type="indexterm" data-primary="open source software (OSS)" data-secondary="identifying security risks" id="xi_opensourcesoftwareOSSidentifyingsecurityrisks517434"/> dependency usage is ubiquitous, and so organizations must contend with the security and compliance risks that it brings. We previously mentioned two examples. In the first, the Log4j threat, thousands of systems were impacted. The second, the XZ Utils example, while caught early, illustrated how a malicious actor could wreak havoc by compromising an OSS component.</p>
          <p>Common vulnerabilities and exposures (CVEs)<a contenteditable="false" data-type="indexterm" data-primary="common vulnerabilities and exposures (CVEs)" id="id754"/><a contenteditable="false" data-type="indexterm" data-primary="CVEs (common vulnerabilities and exposures)" id="id755"/> are one mechanism that organizations can use to identify known security problems in order to take steps to mitigate them. CVE monitoring tools automate the process of scanning your software and alerting you to the potential risks. While diligent monitoring can help you eliminate known threats from the OSS you use, it does not guarantee that your OSS components are truly safe. Unmaintained components or outdated dependencies also create risks, and because OSS packages bring in dozens of dependencies, these can be very complex to manage. </p>
          <p>While CVE management can help fight known threats, there are other classes of threats to contend with. The OWASP Foundation has created the following top 10 list to capture a fuller spectrum of OSS risks that your organization needs to guard against:</p>
          <dl>
            <dt>Known vulnerabilities</dt>
            <dd>
              <p>An open source component can contain security flaws that are publicly disclosed, often through CVEs or other channels. These vulnerabilities<a contenteditable="false" data-type="indexterm" data-primary="known vulnerabilities, OSS" id="id756"/>, if exploitable in your software, can compromise your system’s confidentiality, integrity, or <span class="keep-together">availability.</span></p>
            </dd>
            <dt class="pagebreak-before less_space">Compromise of legitimate package</dt>
            <dd>
              <p>Attackers<a contenteditable="false" data-type="indexterm" data-primary="packages, security considerations" id="id757"/> may inject malicious code into existing projects or distribution infrastructure by hijacking accounts or exploiting vulnerabilities. This can lead to code execution on end user or organizational systems, putting confidentiality, integrity, and availability at risk. </p>
            </dd>
            <dt>Name confusion attacks</dt>
            <dd>
              <p>Name confusion attacks<a contenteditable="false" data-type="indexterm" data-primary="name confusion attacks" id="id758"/> involve malicious actors creating components with names that closely resemble legitimate ones, aiming to trick users into installing them. These attacks can lead to the execution of harmful code on both user and organizational systems, compromising confidentiality, integrity, and availability. </p>
            </dd>
            <dt>Unmaintained software</dt>
            <dd>
              <p>Because unmaintained OSS components<a contenteditable="false" data-type="indexterm" data-primary="unmaintained OSS components, security risk" id="id759"/> are no longer actively developed or supported, patches for new vulnerabilities might not be available. This situation can result in increased effort and longer resolution times for downstream developers who need to create their own patches. </p>
            </dd>
            <dt>Outdated software</dt>
            <dd>
              <p>Using outdated software components<a contenteditable="false" data-type="indexterm" data-primary="outdated software components, security risk" id="id760"/> in your projects can create significant challenges. It can make emergency updates difficult, especially if vulnerabilities are discovered in the version you’re using. Older releases also may not be as thoroughly tested for security issues as newer versions. </p>
            </dd>
            <dt>Untracked dependencies</dt>
            <dd>
              <p>Untracked dependencies<a contenteditable="false" data-type="indexterm" data-primary="untracked dependencies, security risk" id="id761"/><a contenteditable="false" data-type="indexterm" data-primary="dependencies, and security risks" id="id762"/> can introduce vulnerabilities without the developers’ knowledge. These dependencies may be missed due to incomplete SBOMs, limited SCA tool capabilities, or manual installation methods. </p>
            </dd>
            <dt>License risk</dt>
            <dd>
              <p>Open source components may have licenses that are incompatible with the intended use, violate legal requirements, or lack a license altogether. Using components without a license<a contenteditable="false" data-type="indexterm" data-primary="license risk" id="id763"/> or failing to comply with license terms can lead to legal repercussions. </p>
            </dd>
            <dt>Immature software</dt>
            <dd>
              <p>Immature open source projects, lacking best practices like standard versioning, testing, or documentation, can introduce operational risks to your software. This lack of maturity may lead to unexpected behavior and increased development effort along with vulnerabilities. </p>
            </dd>
            <dt>Unapproved change</dt>
            <dd>
              <p>Unapproved changes<a contenteditable="false" data-type="indexterm" data-primary="unapproved changes, security risk" id="id764"/> to software components can lead to compromised integrity and reproducibility of software builds. </p>
            </dd>
            <dt>Under-/oversized dependency</dt>
            <dd>
              <p>Open source components<a contenteditable="false" data-type="indexterm" data-primary="under- or oversized dependency, security risk" id="id765"/> can vary significantly in size and functionality, leading to security risks. Small components offer minimal functionality but can still introduce significant risk due to their reliance on upstream projects. Large components, while potentially offering more features, may have a larger attack surface due to unused capabilities and dependencies. </p>
            </dd>
          </dl>
          <p class="fix_tracking">In the next section we’ll look at a framework—SLSA—that can help address these risks<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_opensourcesoftwareOSSidentifyingsecurityrisks517434" id="id766"/>. </p>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Ensuring Integrity with Supply Chain Levels for Software Artifacts"><div class="sect1" id="chapter_5_ensuring_integrity_with_supply_chain_levels_for_so_1749354010736469">
        <h1>Ensuring Integrity with Supply Chain Levels <span class="keep-together">for Software Artifacts</span></h1>
        <p>Clearly, the risks of OSS are numerous<a contenteditable="false" data-type="indexterm" data-primary="security considerations" data-secondary="software supply chain" id="xi_securityconsiderationssoftwaresupplychain522450"/><a contenteditable="false" data-type="indexterm" data-primary="software supply chains" data-secondary="protecting integrity of level" id="xi_softwaresupplychainsprotectingintegrityoflevel522450"/><a contenteditable="false" data-type="indexterm" data-primary="software supply chains" data-secondary="supply chain level integrity protection" id="xi_softwaresupplychainssupplychainlevelintegrityprotection522450"/><a contenteditable="false" data-type="indexterm" data-primary="artifact integrity validation" id="xi_artifactintegrityvalidation522450"/>. Before we leverage OSS or any third-party components in our own software, we must ask: Who wrote this software? Was it built and released with tools and on platforms that we can trust? What dependencies does it bring in? Does it conform to the regulatory requirements that are important to us?</p>
        <p>Supply Chain Levels for Software Artifacts (SLSA<a contenteditable="false" data-type="indexterm" data-primary="Supply Chain Levels for Software Artifacts (SLSA)" id="xi_SupplyChainLevelsforSoftwareArtifactsSLSA522560"/><a contenteditable="false" data-type="indexterm" data-primary="open source software (OSS)" data-secondary="SLSA to safeguard software vulnerabilities" id="xi_opensourcesoftwareOSSSLSAtosafeguardsoftwarevulnerabilities522560"/>, pronounced “salsa”) is a framework that provides a structured approach to answering these questions. SLSA is designed to bolster the integrity of software artifacts throughout the software supply chain. It enhances the security of software supply chains and can help address the OSS threats we’ve looked at. </p>
        <p>Similar to the chain of custody for physical evidence, SLSA emphasizes the importance of tracking and verifying the integrity of software artifacts throughout their lifecycle. In this section, we’ll dig into SLSA and provide guidance on how to comply with its requirements to safeguard your software from potential threats.</p>
        <section data-type="sect2" data-pdf-bookmark="SLSA Overview"><div class="sect2" id="chapter_5_slsa_overview_1749354010736524">
          <h2>SLSA Overview</h2>
          <p>SLSA is an open source project driven by the Open Source Security Foundation. With its focus on practical implementation and measurable security improvements, SLSA has gained significant traction. </p>
          <p>SLSA offers benefits to providers and consumers of OSS and vendor-provided software. Within your organization you can use SLSA to help secure your software development process from internal tampering. This ensures that the code that you deploy to production is the code you’ve built, tested, and signed off on. </p>
          <p>For consumers of software, SLSA provides mechanisms to verify the authenticity and integrity of OSS. Package registries are able to use SLSA to guarantee that an uploaded OSS package is built from a source in a legitimate repository. As an OSS consumer, sourcing from trusted registries ensures the packages you download are valid. In addition, you can require that your vendors adhere to SLSA principles. Verifying vendor SLSA certifications from reputable third-party auditors can provide an extra layer of confidence.</p>
          <p><a href="https://oreil.ly/i7qar">SLSA defines a tiered framework</a>, allowing organizations to progressively enhance their software supply chain security. Levels represent increasing degrees of assurance and protection against tampering. An organization with no protections in place is considered at Level 0. </p>
          <p>SLSA Level 1 is the foundation. Level 1 requires that basic provenance information be produced. This information should detail the build processes, describe dependencies, and give the source code location. Level 1 is the starting point for organizations embarking on their software supply chain security journey. Consumers can use this information to make decisions about the risks associated with the software.</p>
          <p>Level 2 builds upon Level 1 by introducing stronger build requirements. Your build environment must be isolated and controlled. This level also mandates artifact signing for integrity verification, preventing tampering.</p>
          <p>Finally, Level 3 requires source code provenance and build reproducibility. Provenance must be auditable and its integrity must be ensured. </p>
          <p><a data-type="xref" href="#chapter_5_table_1_1749354010727546">Table 5-1</a> summarizes requirements at each of the three levels SLSA 1.0 defines.</p>
          <table id="chapter_5_table_1_1749354010727546">
            <caption><span class="label">Table 5-1. </span>SLSA levels</caption>
            <thead>
              <tr>
                <th>Implementer</th>
                <th>Requirement</th>
                <th>Degree</th>
                <th>L1</th>
                <th>L2</th>
                <th>L3</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Producer</td>
                <td>Choose an appropriate build platform</td>
                <td/>
                <td>✓</td>
                <td>✓</td>
                <td>✓</td>
              </tr>
              <tr>
                <td/>
                <td>Follow a consistent build process</td>
                <td/>
                <td>✓</td>
                <td>✓</td>
                <td>✓</td>
              </tr>
              <tr>
                <td/>
                <td>Distribute provenance</td>
                <td/>
                <td>✓</td>
                <td>✓</td>
                <td>✓</td>
              </tr>
              <tr>
                <td>Build platform</td>
                <td>Provence generation exists</td>
                <td>Exists</td>
                <td>✓</td>
                <td>✓</td>
                <td>✓</td>
              </tr>
              <tr>
                <td/>
                <td>Provence generation is ensured to be authentic</td>
                <td>Authentic</td>
                <td/>
                <td>✓</td>
                <td>✓</td>
              </tr>
              <tr>
                <td/>
                <td>Provence generation is unforgeable</td>
                <td>Unforgeable</td>
                <td/>
                <td/>
                <td>✓</td>
              </tr>
              <tr>
                <td/>
                <td>Isolation strength</td>
                <td>Hosted</td>
                <td/>
                <td>✓</td>
                <td>✓</td>
              </tr>
              <tr>
                <td/>
                <td>Isolation strength</td>
                <td>Isolated</td>
                <td/>
                <td/>
                <td>✓</td>
              </tr>
            </tbody>
          </table>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Using SLSA to Ensure Integrity"><div class="sect2" id="chapter_5_using_slsa_to_ensure_integrity_1749354010736583">
          <h2>Using SLSA to Ensure Integrity</h2>
          <p>The following principles have guided the design decisions of the SLSA framework: </p>
          <dl>
            <dt>Trust a small number of platforms; focus on artifacts</dt>
            <dd>
              <p>Extend trust to a few core platforms, such as build and packaging tools, and then automate the verification of artifacts<a contenteditable="false" data-type="indexterm" data-primary="artifact verification for OSS security" id="id767"/> produced by those platforms. For example, your trusted build platform produces and signs provenance attestations for each artifact it’s used to build. Downstream platforms then verify the provenance signed by the public key to automatically determine that an artifact meets the SLSA level.</p>
            </dd>
            <dt>Trace software back to source code, not individuals</dt>
            <dd>
              <p>Establish a direct and verifiable link between the final software artifact and its original source code<a contenteditable="false" data-type="indexterm" data-primary="source code, tracing software back to" id="id768"/>. This approach is in contrast with trusting individuals with write access to package registries and trusting the immutable and analyzable nature of code itself. By establishing a direct link, organizations can significantly reduce the risk of malicious code injection or unauthorized modifications.</p>
            </dd>
            <dt>Prefer attestations over inferences</dt>
            <dd>
              <p>Rely on direct evidence of an artifact’s origin over inferring the trustworthiness of the artifact based on knowledge of intermediary build systems or other systems. Instead of inferring the integrity, SLSA mandates explicit attestations<a contenteditable="false" data-type="indexterm" data-primary="attestations versus inferences, and artifact trustworthiness" id="id769"/><a contenteditable="false" data-type="indexterm" data-primary="inferences versus attestations, and artifact trustworthiness" id="id770"/> about an artifact’s provenance. This requires concrete proof of an artifact’s build process.</p>
            </dd>
          </dl>
          <p>In SLSA 1.0, the build platform is central to ensuring artifact<a contenteditable="false" data-type="indexterm" data-primary="build platform integrity, OSS" id="xi_buildplatformintegrityOSS533477"/> integrity. <em>Build platform</em> is used to refer to the systems responsible for compiling, packaging, and preparing your software for distribution. A robust build platform is essential for achieving higher SLSA levels. The system you select should support isolated builds, meaning for each build, new infrastructure is created, and after the build runs, the infrastructure is deleted. In addition, the system should enforce nonprivileged, containerized continuous integration steps that do not use volume mounts. This prevents access to the provenance key information in compliance with SLSA specifications. With a fortified build system, you are assured that malicious actors can’t tamper with your build.</p>
          <p>In addition to choosing a build platform that can guarantee artifact integrity, your system should produce and distribute attestations (digitally signed records) that demonstrate that your software meets your desired SLSA build level. SLSA provenance attestations are cryptographic signatures that provide verifiable evidence about the origin and build process of a software artifact. They act as a digital passport<a contenteditable="false" data-type="indexterm" data-primary="digital passports, for artifact integrity" id="id771"/>, ensuring the integrity and authenticity of the artifact.</p>
          <p>Consider a container image<a contenteditable="false" data-type="indexterm" data-primary="container image" id="id772"/> built using a CI/CD pipeline. An SLSA provenance attestation for this image might include the following information:</p>
          <dl>
            <dt>Builder</dt>
            <dd>
              <p>The CI/CD platform used to build the image (e.g., GitHub Actions, GitLab CI/CD)</p>
            </dd>
            <dt>Invocation</dt>
            <dd>
              <p>The specific build configuration or script used to create the image</p>
            </dd>
            <dt>Materials</dt>
            <dd>
              <p>The source code repositories, dependencies, and other inputs used in the build process</p>
            </dd>
            <dt class="pagebreak-before less_space">Subject</dt>
            <dd>
              <p>The artifact itself, identified by its unique digest (hash)</p>
            </dd>
            <dt>Signature</dt>
            <dd>
              <p>A cryptographic signature generated by a trusted entity, verifying the authenticity and integrity of the attestation</p>
            </dd>
          </dl>
          <p>To validate SLSA provenance attestations, organizations can use tools like the SLSA Verifier Service<a contenteditable="false" data-type="indexterm" data-primary="SLSA Verifier Service" id="id773"/>. This service verifies the authenticity of the attestation, checks the signature against the public key of the trusted signer, and ensures the attestation adheres to the SLSA specification.</p>
          <p>To achieve maximum security, SLSA recommends that build platforms, rather than individual developers, generate provenance. If your organization doesn’t use a build platform, consider adopting one with SLSA support. For third-party platforms, check their compatibility and request SLSA support if needed. If you maintain your own build platform, add SLSA provenance generation capabilities.</p>
          <p>Similarly, package ecosystems<a contenteditable="false" data-type="indexterm" data-primary="packages, security considerations" id="id774"/> should distribute SLSA provenance alongside software packages, embedding attestations within packages or providing them as separate metadata files. If your organization uses a third-party ecosystem, inquire about SLSA support and follow their guidelines. For direct distribution, include SLSA provenance within your package artifacts<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_buildplatformintegrityOSS533477" id="id775"/>.</p>
          <p>By leveraging SLSA provenance attestations, your organization can gain confidence in the authenticity and integrity of software artifacts and reduce the risk of supply chain attacks.</p>
          <section data-type="sect3" data-pdf-bookmark="Enhancing supply chain security beyond SLSA"><div class="sect3" id="chapter_5_enhancing_supply_chain_security_beyond_slsa_1749354010736633">
            <h3>Enhancing supply chain security beyond SLSA</h3>
            <p>While SLSA provides an excellent framework for build integrity, it primarily focuses on artifact provenance and build system integrity. To address the full spectrum of supply chain risks identified in the OWASP Top Ten CI/CD risks, organizations need additional security measures.</p>
            <p>A comprehensive supply chain security strategy should include:</p>
            <dl>
              <dt>Continuous behavioral monitoring</dt>
              <dd>
                <p>Modern delivery and security platforms<a contenteditable="false" data-type="indexterm" data-primary="continuous behavioral monitoring, supply chain security" id="id776"/>, powered by AI and ML, are improving to detect anomalous activities across repositories, build systems, and deployment pipelines. These systems establish baselines of normal behavior and flag deviations that might indicate compromise. Monitoring and security tools such as Datadog CI and GitGuardian are popular choices today.</p>
              </dd>
              <dt class="pagebreak-before less_space">Advanced dependency analysis</dt>
              <dd>
                <p>Beyond basic vulnerability scanning<a contenteditable="false" data-type="indexterm" data-primary="dependencies, and security risks" id="id777"/>, intelligent analysis tools can evaluate package behavior, code patterns, and maintainer activity trends to identify potentially malicious dependencies before they’re publicly reported. AI-powered systems can detect subtle indicators of compromise by analyzing code semantics and behavior in ways that traditional scanners cannot, helping to protect against sophisticated supply chain attacks like dependency confusion or typosquatting.</p>
              </dd>
              <dt>Automated policy enforcement</dt>
              <dd>
                <p>Implement automated policy<a contenteditable="false" data-type="indexterm" data-primary="automation" data-secondary="for supply chain security" data-secondary-sortas="supply chain security" id="id778"/> guardrails throughout your pipelines that enforce security requirements beyond build integrity. These systems prevent overly permissive access, block dangerous configurations, and ensure proper secrets management—addressing risks like insufficient RBAC and credential hygiene that SLSA doesn’t fully cover. Today, implementing policy widely across a delivery platform is still unevenly done. Looking forward, it is a strong approach and one that will benefit from AI both in becoming more adaptable to changing threats and in rapid creation of policy through AI code generation assistance in PaC scenarios.</p>
              </dd>
              <dt>Supply chain risk prediction</dt>
              <dd>
                <p>Predictive analytics<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="predictive analytics for supply chain risks" id="id779"/><a contenteditable="false" data-type="indexterm" data-primary="predictive analytics" id="id780"/> and AI models analyze historical vulnerability trends and emerging threat intelligence to highlight components in your supply chain that pose higher potential risk, helping teams proactively address vulnerabilities before they become critical issues. By analyzing patterns across thousands of projects and dependencies, these systems identify risk factors in your environment before they lead to security incidents, enabling proactive hardening of vulnerable areas.</p>
              </dd>
            </dl>
            <p class="fix_tracking">By combining these AI-enhanced capabilities with SLSA’s build integrity focus, organizations can create a defense-in-depth approach that addresses the full range of supply chain risks. This comprehensive strategy protects not just the build process but also the entire software delivery pipeline, from development through deployment.</p>
          </div></section>
          <section data-type="sect3" data-pdf-bookmark="Addressing AI-generated dependency risks"><div class="sect3" id="chapter_5_addressing_ai_generated_dependency_risks_1749354010736680">
            <h3>Addressing AI-generated dependency risks</h3>
            <p>As organizations increasingly adopt AI<a contenteditable="false" data-type="indexterm" data-primary="AI (artificial intelligence) systems" data-secondary="dependency risks generated by" id="id781"/><a contenteditable="false" data-type="indexterm" data-primary="AI coding assistants" data-secondary="dependency risks" id="id782"/><a contenteditable="false" data-type="indexterm" data-primary="packages, security considerations" id="id783"/> coding assistants, a new supply chain risk has emerged: AI hallucination squatting<a contenteditable="false" data-type="indexterm" data-primary="hallucination squatting, by cyber attackers" id="id784"/>. This occurs when attackers register package names that AI tools incorrectly suggest through hallucinations, creating a vector for malicious code injection. </p>
            <p>While the core SLSA framework provides significant protection against traditional supply chain attacks, organizations using AI coding tools should implement additional safeguards:</p>
            <dl>
              <dt>Verified registry policies</dt>
              <dd>
                <p>Configure package managers to only pull from officially vetted registries<a contenteditable="false" data-type="indexterm" data-primary="registry policies, using verified" id="id785"/> and private repositories with known-good packages. This prevents developers from inadvertently installing packages from untrusted sources, even if an AI assistant suggests them.</p>
              </dd>
              <dt>Package age and popularity checks</dt>
              <dd>
                <p>Implement tooling that automatically verifies recommended packages against minimum download counts and established history metrics. New packages with minimal usage should trigger additional review.</p>
              </dd>
              <dt>AI confidence verification</dt>
              <dd>
                <p>When using AI coding assistants that provide confidence scores for their recommendations, implement processes to flag low-confidence package suggestions for manual verification against authoritative sources.</p>
              </dd>
              <dt>Preinstallation validation</dt>
              <dd>
                <p>Add automated checks to your development environment that validate package existence and provenance in trusted repositories before allowing dependencies to be added to project files.</p>
              </dd>
            </dl>
            <p>These additional controls, when combined with SLSA practices and comprehensive SBOMs, create a defense-in-depth approach that protects against both traditional supply chain attacks and emerging AI-facilitated threats. By addressing the specific risks that AI introduces to the dependency selection process, organizations can safely leverage AI coding assistants while maintaining supply chain integrity. With the exception of AI confidence verification, each of these practices is helpful against other package-based attacks, such as typosquatting<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_securityconsiderationssoftwaresupplychain522450" id="id786"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_softwaresupplychainsprotectingintegrityoflevel522450" id="id787"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_softwaresupplychainssupplychainlevelintegrityprotection522450" id="id788"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_SupplyChainLevelsforSoftwareArtifactsSLSA522560" id="id789"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_opensourcesoftwareOSSSLSAtosafeguardsoftwarevulnerabilities522560" id="id790"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_artifactintegrityvalidation522450" id="id791"/>.</p>
          </div></section>
        </div></section>
      </div></section>
      
      
      <section data-type="sect1" data-pdf-bookmark="Addressing Zero-Day Vulnerabilities with Software Bill of Materials"><div class="sect1" id="chapter_5_addressing_zero_day_vulnerabilities_with_software_1749354010736730">
        <h1>Addressing Zero-Day Vulnerabilities <span class="keep-together">with Software Bill of Materials</span></h1>
        <p>In the first section<a contenteditable="false" data-type="indexterm" data-primary="security considerations" data-secondary="zero-day vulnerabilities with SBOMs" id="xi_securityconsiderationszerodayvulnerabilitieswithSBOMs541532"/><a contenteditable="false" data-type="indexterm" data-primary="zero-day vulnerabilities with SBOMs" id="xi_zerodayvulnerabilitieswithSBOMs541532"/><a contenteditable="false" data-type="indexterm" data-primary="bills of materials, software" id="xi_billsofmaterialssoftware541532"/><a contenteditable="false" data-type="indexterm" data-primary="software bills of materials (SBOMs)" id="xi_softwarebillsofmaterialsSBOMs541532"/><a contenteditable="false" data-type="indexterm" data-primary="SBOMs (software bills of materials)" id="xi_SBOMssoftwarebillsofmaterials541532"/>, we looked at the Log4j exploit that allowed attackers to execute arbitrary code remotely by exploiting a specific pattern in log messages, leading to widespread data breaches, ransomware attacks, and disruptions to critical services. This was an example of a zero-day exploit, one of the most insidious types of threats because it exploits vulnerabilities that are unknown to the software vendor, giving attackers a significant advantage before any defenses can be put in place. In this section, we’ll look at how an SBOM serves as an essential tool in the battle against this type of vulnerability. An SBOM provides a detailed inventory of all components and dependencies used in a software artifact. We’ll look at the composition and characteristics of SBOMs, and how they are managed throughout the SDLC. </p>
        <p>While dependency management tools and package managers have existed for years to track and manage software components, SBOM has witnessed significant advancements since 2018. Collaborative efforts, including the National Telecommunications and Information Administration (NTIA) Multistakeholder Process<a contenteditable="false" data-type="indexterm" data-primary="National Telecommunications and Information Administration (NTIA) Multistakeholder Process" id="id792"/>, have developed best practices and recommendations for SBOMs. This collaborative effort brought together industry experts, government agencies, and academics to define standards and guidelines for SBOM generation, sharing, and consumption. </p>
        <p>As a result, SBOM has emerged as a key building block. In fact, <a href="https://oreil.ly/aIlVL">recent Linux Foundation research</a> found that 78% of organizations were producing or consuming SBOMs in 2022, up 66% from the prior year.</p>
        <p>You have two standards<a contenteditable="false" data-type="indexterm" data-primary="standards adherence" data-secondary="SBOM standards" id="id793"/> to choose from when creating SBOMs for your software:</p>
        <dl>
          <dt>CycloneDX</dt>
          <dd>
            <p>The CycloneDX<a contenteditable="false" data-type="indexterm" data-primary="CycloneDX" id="id794"/> project emerged as a leading standard for SBOMs, providing a machine-readable format for representing software components, dependencies, and their relationships. CycloneDX has gained widespread adoption and support from various organizations.</p>
          </dd>
          <dt>SPDX</dt>
          <dd>
            <p>Software Package Data Exchange (SPDX)<a contenteditable="false" data-type="indexterm" data-primary="Software Package Data Exchange (SPDX)" id="id795"/><a contenteditable="false" data-type="indexterm" data-primary="SPDX (Software Package Data Exchange)" id="id796"/> is another popular standard for SBOMs, sponsored by the Linux Foundation and codified in the ISO/IEC 5962 international standard. It offers a flexible and extensible format for representing software components. SPDX has been widely used in the open source community for many years.</p>
          </dd>
        </dl>
        <p>SPDX is a more established format with a broader scope, encompassing not only component information but also metadata about the SBOM itself, such as its creator and creation date. It’s particularly well-suited for managing OSS licenses and sharing information about packages. </p>
        <p>CycloneDX is a newer format that offers a more structured and machine-readable approach, with a focus on providing detailed information about software components and their relationships. CycloneDX is often preferred for its flexibility and adaptability, making it suitable for a wide range of use cases. Your specific use case may determine which standard you adopt; the tools and processes you select for software supply chain security management should be able to support both standards.</p>
        <p>Regardless of the specific format you choose, the factors you use to assess the quality of the SBOM are the same. The NTIA has developed a set of minimum elements that SBOMs should contain to provide essential information about software components and their dependencies. Ensuring the presence of these elements will facilitate effective analysis of SBOMs across various tools and platforms, as well as adherence to the underlying SPDX or CycloneDX specification. </p>
        <p>By providing a comprehensive inventory of components, SBOMs offer transparency and traceability that can help ensure compliance with your organization’s security policies and legal requirements. PaC frameworks<a contenteditable="false" data-type="indexterm" data-primary="Policy-as-Code (PaC) frameworks" id="id797"/><a contenteditable="false" data-type="indexterm" data-primary="PaC (Policy-as-Code) frameworks" id="id798"/> can leverage SBOMs to automate this compliance. With PaC you define security policies using code, which can be managed and version-controlled like code. These policies can then be applied to SBOMs, ensuring that software components adhere to the organization’s security standards for OSS. Automated compliance reduces the risk of human error and improves efficiency.</p>
        <p>For example, your organization might define a policy that only allows OSS components with permissive licenses (e.g., MIT, Apache License 2.0) to be used to ensure compatibility with the organization’s existing software portfolio and avoid potential legal issues.</p>
        <p>You might define a<strong> </strong>policy to automatically reject OSS components with known vulnerabilities above a certain severity threshold. Or you could establish criteria for evaluating the reputation and trustworthiness of OSS vendors. This can include factors like vendor size, security practices, and community involvement.</p>
        <p>Combining SBOMs with PaC creates a powerful framework for governing OSS usage, ensuring compliance, and mitigating security risks. Automating enforcement of security policies reduces the burden on security teams and improves overall efficiency.</p>
      </div></section>
      
        <section data-type="sect1" data-pdf-bookmark="Using SBOMs to Remediate Dependency Issues"><div class="sect1" id="chapter_5_using_sboms_to_remediate_dependency_issues_1749354010736780">
          <h1>Using SBOMs to Remediate Dependency Issues</h1>
          <p>In complex codebases with countless dependencies<a contenteditable="false" data-type="indexterm" data-primary="dependencies, and security risks" id="id799"/>, pinpointing and fixing affected artifacts can be a daunting task. Adhering to the following best practices can help your organization be ready to react quickly to zero-day exploits and other threats:</p>
          <dl>
            <dt>Keep SBOMs up-to-date</dt>
            <dd>
              <p>Ensure that SBOMs are generated automatically as part of your CI/CD processes. This ensures that you always have up-to-date information about your software’s dependencies for every artifact your organization supports.</p>
            </dd>
            <dt>Utilize automated vulnerability scanning tools</dt>
            <dd>
              <p class="fix_tracking">Employ automated tools to scan your SBOMs against vulnerability databases. These tools can identify known vulnerabilities in your dependencies in a timely way, allowing you to prioritize remediation efforts and address potential security threats.</p>
            </dd>
            <dt>Establish a robust patch management process</dt>
            <dd>
              <p>Develop a well-defined process for patching vulnerabilities identified in your SBOMs. This includes setting priorities for patching, coordinating with vendors, and testing patches before deployment. By maintaining an up-to-date and secure software supply chain, you can significantly reduce the risk of zero-day exploits being used.</p>
            </dd>
          </dl>
          <p>AI significantly enhances these best practices. Intelligent SBOM analysis systems can:</p>
          <dl>
            <dt>Predict vulnerability impact</dt>
            <dd>
              <p>AI models can analyze your application architecture to determine if a vulnerable component is in an exploitable position, distinguishing between theoretical vulnerabilities and those that pose immediate risk. This contextual analysis helps teams focus on the most critical issues first.</p>
            </dd>
            <dt>Automate dependency updates</dt>
            <dd>
              <p>When vulnerabilities are identified, AI systems can automatically generate pull requests with appropriate dependency updates, test compatibility with your codebase, and manage the update process across multiple repositories. This automation dramatically reduces the time from vulnerability disclosure to remediation.</p>
            </dd>
            <dt>Identify hidden dependencies</dt>
            <dd>
              <p>ML algorithms can detect undocumented or transitive dependencies that might not be explicitly captured in package manifests, providing a more complete view of your actual attack surface<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_securityconsiderationszerodayvulnerabilitieswithSBOMs541532" id="id800"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_zerodayvulnerabilitieswithSBOMs541532" id="id801"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_billsofmaterialssoftware541532" id="id802"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_softwarebillsofmaterialsSBOMs541532" id="id803"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_SBOMssoftwarebillsofmaterials541532" id="id804"/>.</p>
            </dd>
          </dl>
        </div></section>
      
      <section data-type="sect1" data-pdf-bookmark="Adopting DevSecOps Principles"><div class="sect1" id="chapter_5_adopting_devsecops_principles_1749354010736828">
        <h1>Adopting DevSecOps Principles</h1>
        <p>We’ve seen in this chapter how vulnerable the software supply chain is<a contenteditable="false" data-type="indexterm" data-primary="security considerations" data-secondary="DevSecOps principles for supply chain protection" id="xi_securityconsiderationsDevSecOpsprinciplesforsupplychainprotection547282"/><a contenteditable="false" data-type="indexterm" data-primary="DevSecOps principles for supply chain protection" id="xi_DevSecOpsprinciplesforsupplychainprotection547282"/><a contenteditable="false" data-type="indexterm" data-primary="software supply chains" data-secondary="DevSecOps principles for protecting" id="xi_softwaresupplychainsDevSecOpsprinciplesforprotecting547282"/>. Consistently delivering software in a secure manner requires more than careful vetting of the tools and third-party components that you use. It requires more than choosing CI/CD tools and technologies that support SLSA and the generation of SBOMs and attestations. To ensure consistent secure delivery, your team must maintain a secure platform, conduct thorough vulnerability testing, prioritize and fix issues promptly, prevent insecure code releases, comply with regulations, and guarantee the integrity of your software and all of its components. </p>
        <p>This cannot be the work of a single role on your team or a single team within your organization. It requires a collaborative approach that integrates security into the entire SDLC. This is what a DevSecOps approach speaks to. Unlike traditional approaches where security is added on in a few places, DevSecOps promotes continual collaboration between development, security, and operations teams, ensuring that security is considered from the beginning. </p>
        <p>In this section, we’ll explain DevSecOps principles and show how adopting these principles will help you to more quickly identify and remediate vulnerabilities, reduce the risk of breaches, and improve the overall security of your software. </p>
        <section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Establish a Collaborative Culture and Break Down Functional Silos"><div class="sect2" id="chapter_5_establish_a_collaborative_culture_and_break_down_f_1749354010736876">
          <h2 class="less_space">Establish a Collaborative Culture and Break Down Functional Silos</h2>
          <p>The first and most vital step to successfully implementing DevSecOps is to establish a collaborative culture with a security-first mindset. Naturally, this can be the most difficult step and requires the full support of your organization’s leadership team. Security must be an organizational priority and become a responsibility shared by developers, operations, security teams, and others. </p>
          <p>A simple way to break down silos and establish a shared sense of ownership is to create cross-functional DevSecOps teams. Siloed teams can limit communication and knowledge sharing, which can lead to duplicated efforts and inconsistent processes. In contrast, cross-functional DevSecOps teams foster collaboration and open communication. By including the perspective of development, operations, and security roles when, for example, establishing a new security practice or selecting a new security-related tool, you can more easily get the buy-in and alignment needed to be successful. </p>
          <p>In addition, cross-functional teams can help prevent selections or recommendations that create bottlenecks and strain productivity. An example of this would be a unilateral mandate to impose some new application security checks without considering their impact on the development process. The impact of this would be increased workload for developers, which strains not only productivity but also the trust and goodwill within your organization.</p>
          <p>In addition to creating cross-functional teams, you should identify and support a few key security champions across your organization to help promote security initiatives and raise awareness among their peers. Use your cross-functional teams and security champions to share ideas and communicate your progress by establishing open and transparent communication channels to facilitate the exchange of information and ideas. This can include regular meetings, team chats, and knowledge-sharing sessions.</p>
          <p>AI tools serve as collaborative bridges between security and development teams by providing shared context and translating between security and development concerns. For example, when an AI-powered security tool identifies a vulnerability, it can explain the issue in developer-friendly terms while also providing the security context that security teams need. This shared understanding reduces friction between teams and helps establish a security culture where everyone speaks the same language.</p>
          <p>Lastly, invest in security training. Identify skills gaps and provide ongoing security training to all team members, equipping them with the knowledge and skills to identify and mitigate security risks. This not only raises the bar of the entire team, but also demonstrates your organizational commitment to security as a priority.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Adopt and Enforce Secure Coding Methodologies and Shift-Left"><div class="sect2" id="chapter_5_adopt_and_enforce_secure_coding_methodologies_and_1749354010736925">
          <h2>Adopt and Enforce Secure Coding Methodologies and Shift-Left</h2>
          <p>Secure coding practices are essential for preventing vulnerabilities. The OWASP Top 10 and Common Weakness Enumeration (CWE) provide helpful guidance for identifying and addressing common security vulnerabilities. In addition, ensure your methodologies address the following common threats:</p>
          <dl>
            <dt>Input validation</dt>
            <dd>
              <p class="fix_tracking">Always validate user input<a contenteditable="false" data-type="indexterm" data-primary="input validation cyberthreat" id="id805"/><a contenteditable="false" data-type="indexterm" data-primary="cyberthreat landscape for applications" id="id806"/> to prevent malicious data from being injected into your application. This can help prevent SQL injection, XSS, and other injection attacks.</p>
            </dd>
            <dt>Output encoding</dt>
            <dd>
              <p>Properly encode<a contenteditable="false" data-type="indexterm" data-primary="output encoding cyberthreat" id="id807"/><a contenteditable="false" data-type="indexterm" data-primary="security considerations" data-secondary="cyberthreat landscape for applications" id="id808"/> output to prevent XSS attacks. This ensures that user-generated content is displayed safely on the page without allowing malicious code to be executed.</p>
            </dd>
            <dt>Error handling</dt>
            <dd>
              <p>Implement robust error handling<a contenteditable="false" data-type="indexterm" data-primary="error handling, using robust" id="id809"/> to prevent information leakage and potential vulnerabilities. Avoid displaying sensitive error messages that could provide attackers with valuable information.</p>
            </dd>
            <dt>Session management</dt>
            <dd>
              <p>Use secure session management techniques<a contenteditable="false" data-type="indexterm" data-primary="session management techniques, securing" id="id810"/> to protect user data and prevent unauthorized access. This includes using strong session identifiers and implementing timeouts.</p>
            </dd>
            <dt>Authentication and authorization</dt>
            <dd>
              <p>Implement strong authentication<a contenteditable="false" data-type="indexterm" data-primary="authentication and authorization" id="id811"/> mechanisms and enforce proper authorization controls to restrict access to sensitive resources.</p>
            </dd>
            <dt>Cryptography</dt>
            <dd>
              <p>Use secure cryptographic algorithms<a contenteditable="false" data-type="indexterm" data-primary="cryptography practices" id="id812"/> and practices to protect sensitive data. Avoid weak encryption methods and ensure proper key management.</p>
            </dd>
            <dt>Dependency management</dt>
            <dd>
              <p>Keep dependencies<a contenteditable="false" data-type="indexterm" data-primary="dependencies, and security risks" id="id813"/> up-to-date and manage them securely to avoid vulnerabilities. Use tools like dependency scanners to identify and address known vulnerabilities in third-party libraries.</p>
            </dd>
          </dl>
          <p class="fix_tracking">While staying informed about the latest threats and secure coding can prevent many vulnerabilities, your organization’s best efforts won’t be infallible. Static and dynamic analysis tools, along with early-stage security testing, act as a backstop, catching issues that might be overlooked in code reviews. This is where shift-left comes in. We’ve covered how shift-left<a contenteditable="false" data-type="indexterm" data-primary="shift-left security" data-secondary="early remediation benefit" id="id814"/> enables you to identify and address vulnerability at an early stage. Early remediation reduces the risk of vulnerabilities getting released into production code<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_securityconsiderationsDevSecOpsprinciplesforsupplychainprotection547282" id="id815"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_DevSecOpsprinciplesforsupplychainprotection547282" id="id816"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_softwaresupplychainsDevSecOpsprinciplesforprotecting547282" id="id817"/>.</p>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="chapter_5_summary_1749354010736971">
        <h1>Summary</h1>
        <p>Security cannot be an afterthought in modern software development. It must be an integral part of the entire development process. As we’ve seen throughout this chapter, an AI-native approach to security transforms: </p>
        <ul>
          <li>
            <p>How vulnerabilities are discovered, using intelligent analysis rather than just static rules</p>
          </li>
          <li>
            <p>How findings are prioritized, based on actual risk rather than generic severity ratings </p>
          </li>
          <li>
            <p class="fix_tracking">How remediations are implemented, with automated guidance and code generation</p>
          </li>
          <li>
            <p>How supply chains are secured, through continuous monitoring and anomaly detection </p>
          </li>
          <li>
            <p>How teams collaborate, with shared context and understanding across security and development </p>
          </li>
        </ul>
        <p>By embedding security into every phase, from design to deployment<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="xi_securityconsiderations5335" id="id818"/>, and by fostering a culture of shared responsibility augmented by AI, organizations can build and deliver applications that are fortified against modern threats. </p>
        <p>In <a data-type="xref" href="ch06.html#chapter_6_chaos_engineering_and_service_reliability_1749354010916149">Chapter 6</a>, we’ll turn our attention to making our apps more resilient by using chaos testing to uncover weaknesses that might otherwise go undetected.</p>
      </div></section>
    </div></section></div></div></body></html>