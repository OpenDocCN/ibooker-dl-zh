["```py\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Generate tensorflow graph\nsklearn_model = RandomForestClassifier(\n    class_weight=\"balanced\", n_estimators=50)\nprint(\"About to fit model on training set.\")\nsklearn_model.fit(train_X, train_y)\n\ntrain_y_pred = sklearn_model.predict(train_X)\nvalid_y_pred = sklearn_model.predict(valid_X)\ntest_y_pred = sklearn_model.predict(test_X)\n\nweighted_score = accuracy_score(train_y, train_y_pred, sample_weight=train_w)\nprint(\"Weighted train Classification Accuracy: %f\" % weighted_score)\nweighted_score = accuracy_score(valid_y, valid_y_pred, sample_weight=valid_w)\nprint(\"Weighted valid Classification Accuracy: %f\" % weighted_score)\nweighted_score = accuracy_score(test_y, test_y_pred, sample_weight=test_w)\nprint(\"Weighted test Classification Accuracy: %f\" % weighted_score)\n```", "```py\nWeighted train Classification Accuracy: 0.989845\nWeighted valid Classification Accuracy: 0.681413\n```", "```py\nTrain Weighted Classification Accuracy: 0.742045\nValid Weighted Classification Accuracy: 0.648828\n```", "```py\ndef eval_tox21_hyperparams(n_hidden=50, n_layers=1, learning_rate=.001,\n                           dropout_prob=0.5, n_epochs=45, batch_size=100,\n                           weight_positives=True):\n```", "```py\nentropy = tf.nn.sigmoid_cross_entropy_with_logits(logits=y_logit, labels=y_expand)\n# Multiply by weights\nif weight_positives:\n  w_expand = tf.expand_dims(w, 1)\n  entropy = w_expand * entropy\n```", "```py\nscores = {}\nn_reps = 3\nhidden_sizes = [50]\nepochs = [10]\ndropouts = [.5, 1.0]\nnum_layers = [1, 2]\n\nfor rep in range(n_reps):\n  for n_epochs in epochs:\n    for hidden_size in hidden_sizes:\n      for dropout in dropouts:\n        for n_layers in num_layers:\n          score = eval_tox21_hyperparams(n_hidden=hidden_size, n_epochs=n_epochs,\n                                         dropout_prob=dropout, n_layers=n_layers)\n          if (hidden_size, n_epochs, dropout, n_layers) not in scores:\n            scores[(hidden_size, n_epochs, dropout, n_layers)] = []\n          scores[(hidden_size, n_epochs, dropout, n_layers)].append(score)\nprint(\"All Scores\")\nprint(scores)\n\navg_scores = {}\nfor params, param_scores in scores.iteritems():\n  avg_scores[params] = np.mean(np.array(param_scores))\nprint(\"Scores Averaged over %d repetitions\" % n_reps)\n```", "```py\nn_rates = 5\nlearning_rates = 10**(-np.random.uniform(low=1, high=6, size=n_rates))\n```"]