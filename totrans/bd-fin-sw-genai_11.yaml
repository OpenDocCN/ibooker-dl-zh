- en: 9 Searching and auditing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 搜索和审计
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Another iteration on our ACH dashboard
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们的ACH仪表板的另一轮迭代
- en: Adding searching capabilities for ACH transactions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为ACH交易添加搜索功能
- en: Auditing of user actions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户行为审计
- en: In previous chapters, we built the minimum viable product (MVP) and went through
    an iteration where we received feedback and used it to drive the next set of enhancements.
    This chapter continues using the same concepts. With the release of expanded support
    for exceptions and various UI/UX tweaks, we should expect feedback on those features
    and other functionality that users need.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们构建了最小可行产品（MVP），经历了一个迭代过程，我们收到了反馈并利用它来推动下一组增强功能。本章将继续使用相同的概念。随着对异常处理和多种UI/UX调整的扩展支持发布，我们应该期待对这些功能和用户所需的其他功能反馈。
- en: Users would like to be able to search for transactions based on several criteria
    as they need to handle customer complaints about when a transaction was processed.
    In addition, other stakeholders have asked for the ability to audit interactions
    with the dashboard to gauge customer engagement and set up user tracking in the
    future.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 用户希望能够根据几个标准搜索交易，因为他们需要处理客户关于交易何时处理的投诉。此外，其他利益相关者要求能够审计与仪表板的交互，以衡量客户参与度并设置未来的用户跟踪。
- en: 9.1 Sprint planning
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 迭代计划
- en: 'In the Agile world, the team needs to prepare for the sprint before starting
    any work. We already have an idea of what needs to be accomplished with this sprint
    but also have to define stories to know exactly what is expected in any given
    story and identify any acceptance criteria that may go along with it. We continue
    to follow the standard format for our stories: `As` `a` `[role],` `I` `[want`
    `to],` `[so` `that]`. For instance, to add search capabilities to our product,
    we may have something similar to `As` `a` `user,` `I` `want` `to` `be` `able`
    `to` `search` `for` `transactions,` `so` `that` `I` `can` `better` `research`
    `customer inquiries` `about` `their` `transactions`. Feel free to practice the
    phrasing for the additional user stories (even if it is just in your head) for
    the remaining tasks we cover in this chapter.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷世界中，团队需要在开始任何工作之前为迭代做准备。我们已经有了关于这个迭代需要完成什么工作的想法，但还必须定义故事，以确切知道任何给定故事中期望的内容，并确定可能与之相关的任何验收标准。我们继续遵循我们故事的标准格式：“作为[角色]，我[想要]，[以便]”。例如，为了向我们的产品添加搜索功能，我们可能有一个类似这样的故事：“作为用户，我想要能够搜索交易，以便我能够更好地研究客户关于他们交易的询问”。请随意练习剩余任务中附加用户故事的措辞（即使只是在脑海中），我们将在本章中涵盖这些任务。
- en: We take a moment to visualize the changes using another Gantt chart. Again,
    the chart presents a timeline of our changes, which can be shown to any stakeholders
    interested in the project. In our experience, this is one of the most effective
    means of communicating to stakeholders when the project is going to be complete.
    Often, stakeholders outside our team are not familiar with more Agile ways of
    tracking progress and just want to know when our code will be available. A simple
    Gantt chart gives them an idea of how the work should be progressing. The following
    listing shows the Gantt chart definition in PlantUML.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花点时间使用另一个Gantt图来可视化这些变化。同样，图表展示了我们变化的时序，可以向任何对项目感兴趣的利益相关者展示。根据我们的经验，这是在项目即将完成时与利益相关者沟通最有效的方法之一。通常，我们团队之外的利益相关者可能不熟悉更敏捷的进度跟踪方式，他们只想知道我们的代码何时可用。一个简单的Gantt图可以给他们一个关于工作进展情况的想法。以下列表显示了PlantUML中的Gantt图定义。
- en: Listing 9.1  PlantUML Gantt chart definition
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1 PlantUML Gantt图定义
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 Begins the Gantt chart definition'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 开始Gantt图定义'
- en: '#2 Defines days that should be skipped'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义应跳过的天数'
- en: '#3 Title for our chart'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们图表的标题'
- en: '#4 Defines timeline for searching enhancements; note that long lines can be
    split into multiple lines using the backslash character. Any trailing space after
    the backslash can cause parsing errors.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义搜索增强的时序；注意，长行可以使用反斜杠字符拆分为多行。反斜杠后面的任何尾随空格都可能导致解析错误。'
- en: '#5 Defines timeline for auditing enhancements'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 定义审计增强的时序'
- en: '#6 Defines a milestone'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 定义里程碑'
- en: '#7 Ends the Gantt chart definition'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 结束Gantt图定义'
- en: Figure 9.1 shows the generated Gantt chart. Not only does it provide a roadmap
    for where we are in the development process, but creating the chart helps us start
    thinking about the steps and requirements for any given enhancement.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 展示了生成的甘特图。它不仅为我们提供了我们在开发过程中的路线图，而且创建图表有助于我们开始思考任何给定增强的步骤和要求。
- en: '![A screenshot of a calendar  Description automatically generated](../Images/CH09_F01_Kardell.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![日历截图  自动生成的描述](../Images/CH09_F01_Kardell.png)'
- en: Figure 9.1 Gantt chart showing timeframes
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1 甘特图显示时间框架
- en: We should now have an idea of the steps we need to take for the various enhancements
    and can get straight to work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该对需要采取的步骤有一个概念，可以立即开始工作。
- en: 9.2 Searching ACH transactions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 搜索 ACH 交易
- en: Which file contained that transaction? When was that transaction loaded? These
    are the types of questions we want to be able to answer with this enhancement.
    Throughout this book, we have focused on Prearranged Payment and Deposit (PPD)
    batches, which contain payments for payroll, utilities, and mortgage payments,
    among the rest. If a customer’s utility payment is not processed correctly, and
    their water/electricity gets turned off, we can be sure we are going to hear about
    it. Of course, that is an extreme case. It is more likely that the customer has
    been alerted by a particular company that their payment was not received, and
    they have to pay late fees. Either way, the customer will not be too happy when
    they call.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个文件包含了那笔交易？那笔交易是什么时候加载的？这是我们希望通过这次增强能够回答的问题类型。在这本书的整个过程中，我们一直关注预先安排的支付和存款（PPD）批次，其中包含了工资、公用事业费和抵押贷款支付等。如果客户的公用事业费处理不当，他们的水/电被切断，我们可以肯定我们会听到关于这件事的消息。当然，这是一个极端情况。更有可能的是，客户已经收到特定公司的通知，他们的付款尚未收到，他们必须支付滞纳金。无论如何，当客户打电话来时，他们都不会太高兴。
- en: We need to look at adding the ability to search our loaded files for both names
    and amounts. This feature will require changes to the UI as we will need to be
    able to enter search information and a new API to support the actual search and
    returning of results. Our immediate concern is the ability to find transactions
    within our limited dataset. In practice, ACH records should be kept for six years
    from the date of the receipt, and with billions of payments moving through the
    ACH network every year, chances are we will have sizeable datasets to search.
    We need to evaluate other mechanisms for searching, in addition to our real-time
    method before this project is ready for production.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑添加在加载的文件中搜索名称和金额的能力。这个功能将需要更改 UI，因为我们需要能够输入搜索信息，并需要一个新 API 来支持实际的搜索和返回结果。我们当前的关注点是能够在我们的有限数据集中找到交易。在实践中，ACH
    记录应从收据日期起保存六年，并且每年有数十亿笔支付通过 ACH 网络流动，因此我们可能会拥有大量的数据集需要搜索。在项目准备投入生产之前，我们需要评估其他搜索机制，除了我们的实时方法之外。
- en: 9.2.1 BDD testing for searching
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 BDD 测试搜索
- en: Before putting together a feature to help validate the new (yet to be written)
    search API, we first must create a file we can use with our feature. We can use
    our existing file creation feature (ach_file_creation.feature) and add a new scenario
    to create a file for a specific user with a known amount. While we could search
    within one of the existing files, it is likely cleaner to keep the files associated
    with features separated so that our tests will remain more robust. The following
    listing shows creating a file for customer Sally Saver, with a single dollar transaction,
    which should be more than enough to get us started.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合一个功能以帮助验证新的（尚未编写的）搜索 API 之前，我们首先必须创建一个我们可以用于我们功能的文件。我们可以使用我们现有的文件创建功能（ach_file_creation.feature）并添加一个新的场景来为特定用户创建一个已知金额的文件。虽然我们可以在现有的文件中进行搜索，但将文件与功能分开以保持更清洁，这样我们的测试将更加稳健。以下列表展示了为顾客萨莉·萨弗创建一个文件，其中包含一笔单美元的交易，这应该足以让我们开始。
- en: Listing 9.2  Creating a file for Sally Saver
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2  为萨莉·萨弗创建文件
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With our file created, we can now work on setting up our BDD test to search
    for transactions. This should provide us with some insights into how we want the
    process to work in general. For instance, we know that we want to be able to search
    by at least the individual name and an amount. A couple of questions that should
    be up for discussion with various stakeholders in our project may be along the
    lines of
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建完文件后，我们现在可以开始设置我们的BDD测试来搜索交易。这应该会让我们对整个过程的工作方式有一些了解。例如，我们知道我们想要能够通过至少个人名称和金额进行搜索。我们项目中的各种利益相关者可能需要讨论的一些问题可能包括
- en: Are we going to separate these searches out on the API side (e.g., allowing
    query parameters of `customer` and `amount`)? Or will we allow one search field
    and have the backend try to query the correct field?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否将在API端将这些搜索分开（例如，允许`customer`和`amount`的查询参数）？还是我们将允许一个搜索字段，并让后端尝试查询正确的字段？
- en: Are fields mutually exclusive? If we are searching for a customer, can we also
    search for an account?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段是否互斥？如果我们正在搜索客户，我们也能搜索账户吗？
- en: If we allow searching using multiple fields, will these be combined using AND
    or OR? Should that be determined by the user?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们允许使用多个字段进行搜索，这些字段将使用AND还是OR组合？这应该由用户决定吗？
- en: Asking those questions (and the answers to them) will help guide our design
    process. For now, we will take the approach where a user will be shown a single
    search box that will support any searches we want to perform. We will also put
    the responsibility of deciding what the user wants to search for on the server
    side instead of on the UI. Another approach would be to have the UI split the
    fields and allow the API to accept different query parameters. With an approach
    to our search in mind, we can create a scenario to test our API search using a
    customer name.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 提出这些问题（以及它们的答案）将有助于指导我们的设计过程。目前，我们将采用一种方法，即向用户展示一个单独的搜索框，该搜索框将支持我们想要执行的任何搜索。我们还将把决定用户想要搜索什么的责任放在服务器端，而不是用户界面端。另一种方法是将UI分割字段，并允许API接受不同的查询参数。在考虑了我们的搜索方法后，我们可以创建一个场景来测试我们的API搜索，使用客户名称作为测试。
- en: Listing 9.3  Search by individual name
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3  按个人名称搜索
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There was a need to add new syntax for the `When` and `Then` clauses to support
    our transaction search. The code is shown in the following listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加新的语法来支持`When`和`Then`子句，以便支持我们的交易搜索。代码如下所示。
- en: Listing 9.4  Updates to test_file_api.py
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4  更新test_file_api.py
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Ensures the new scenario is loaded'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 确保新场景已加载'
- en: '#2 Annotates the method with @when and parses the line'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用@when注解方法并解析行'
- en: '#3 Defines a function to call our method and saves the response'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义一个函数来调用我们的方法并保存响应'
- en: '#4 Annotates the method with @then and parses the line'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用@then注解方法并解析行'
- en: '#5 Defines a function to validate the results of the API response'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 定义一个函数来验证API响应的结果'
- en: Now that we have the supporting code behind the test, what should we expect
    to see if we were to run it? That’s right—a `404 error` will be returned! That
    is to be expected because we have not yet defined the endpoint. In the next section,
    we will address this problem by adding the API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了测试背后的支持代码，如果我们运行它，我们应该期待看到什么？没错——会返回一个`404错误`！这是可以预料的，因为我们还没有定义端点。在下一节中，我们将通过添加API来解决这个问题。
- en: 9.2.2 Search API
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 搜索API
- en: At this point, we want to have an API that takes some input from the user and
    then searches the database for a transaction. As previously mentioned, we are
    only going to search for individual names and amounts. We expect the API to be
    called with a single query parameter named `criteria`. The API will determine
    whether the argument is applicable to an individual name or an amount.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们希望有一个API，它从用户那里获取一些输入，然后在数据库中搜索交易。如前所述，我们只将搜索个人名称和金额。我们期望API使用一个名为`criteria`的单个查询参数被调用。API将确定参数是否适用于个人名称或金额。
- en: This is not the only approach that we could have taken. We could also have split
    the search criteria into separate fields that would make the server side a bit
    easier but may have made searching more cumbersome from the user’s perspective.
    Another method would be to blend specifying search criteria with keywords (e.g.,
    allowing for searches such as `individual` `name` `=` `"user"` `and` `amount`
    `=` `$1.00`). Then we would have more parsing to do to get the fields we want
    to use. Another consideration is whether we want to use `GET` or `POST`. As mentioned,
    our example uses `GET`, and we pass a query parameter, which is what we will be
    searching for. This approach works, but the URL with the query parameters may
    appear on the web server, firewall, application, and third-party logs. If we enable
    searching for potentially sensitive information, such as account and tax identification
    numbers, we may want to reconsider this approach since we do not want such sensitive
    information showing in logs. There is no wrong answer—depending on our audience
    and what we expect to be searching, we may be told to go with a specific approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们唯一可能采取的方法。我们还可以将搜索条件拆分为单独的字段，这样会使服务器端更容易一些，但可能从用户的角度来看搜索会更加繁琐。另一种方法是将指定搜索条件与关键词（例如，允许搜索如`individual`
    `name` `=` `"user"` `and` `amount` `=` `$1.00`）相结合。然后我们需要进行更多的解析以获取我们想要使用的字段。另一个考虑因素是我们要使用`GET`还是`POST`。如前所述，我们的示例使用`GET`，并传递一个查询参数，这是我们将会搜索的内容。这种方法是可行的，但带有查询参数的URL可能会出现在网络服务器、防火墙、应用程序和第三方日志中。如果我们启用搜索可能敏感的信息，如账户和税务识别号码，我们可能需要重新考虑这种方法，因为我们不希望这样的敏感信息出现在日志中。没有错误的答案——根据我们的受众和我们所期望的搜索内容，我们可能会被告知采用特定的方法。
- en: We first build a simple endpoint to work past the `404` `HTTP` status code being
    currently returned. The following listing shows the initial implementation of
    the endpoint.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建一个简单的端点来处理当前返回的`404` `HTTP`状态码。以下列表显示了端点的初始实现。
- en: Listing 9.5  Initial endpoint definition for searches
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5  搜索的初始端点定义
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Defines a GET request with supporting documentation'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义带有支持文档的 GET 请求'
- en: '#2 Defines the method specifying the query parameter'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义指定查询参数的方法'
- en: '#3 Returns a hardcoded array entry containing the query parameter'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回包含查询参数的硬编码数组条目'
- en: While this code may get us past the `404 error`, it does not do much to help
    us create a useful endpoint. For that, we need to build both the SQL queries and
    response objects to return the data. We start by creating a `TransactionSearchResponse`
    class to hold our data. The following listing shows the `TransactionSearchResponse`
    and the expected fields. If we find that we are missing something, we can always
    come back and add it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码可能帮助我们绕过`404错误`，但它并没有为我们创建一个有用的端点做出太多贡献。为此，我们需要构建SQL查询和返回数据的响应对象。我们首先创建一个`TransactionSearchResponse`类来存储我们的数据。以下列表显示了`TransactionSearchResponse`和预期的字段。如果我们发现我们缺少某些内容，我们总是可以回来添加。
- en: Listing 9.6  The `TransactionSearchResponse` class
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6  `TransactionSearchResponse` 类
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 Our standard import statements for Pydantic fields'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们的标准导入语句用于 Pydantic 字段'
- en: '#2 Defines the class using the BaseModel from Pydantic as the base'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用 Pydantic 的 BaseModel 作为基类定义类'
- en: '#3 Defines the various fields and constraints for our class'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义我们类的各种字段和约束'
- en: '#4 Provides an example of the response object for use with our documentation'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 提供用于文档的响应对象示例'
- en: '#5 Provides an example of the response object for use with our documentation'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 提供用于文档的响应对象示例'
- en: 'Now that we have a place to store our response, we need to populate it. We
    do this by using a new class called `TransactionSearchSql`, which will store any
    code dealing with transaction search. We wanted to keep things simple with our
    first search attempt, so we handle the following three scenarios:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储响应的地方，我们需要填充它。我们通过使用一个新的类`TransactionSearchSql`来完成，这个类将存储任何与交易搜索相关的代码。我们希望在我们的第一次搜索尝试中保持简单，所以我们处理以下三种情况：
- en: Searching by a single amount
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单个金额进行搜索
- en: Searching by an amount range
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过金额范围进行搜索
- en: Searching by an individual name
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过个人名称进行搜索
- en: We created a method called `get_transactions`, as shown in the following listing.
    Here, we have two regular expressions to determine whether an amount was passed
    or a range of amounts was used. Otherwise, we default to using the name. For most
    people, the trickiest part of the code is likely to be the use of regular expressions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `get_transactions` 的方法，如下所示。在这里，我们有两个正则表达式来确定是否传递了金额或使用了金额范围。否则，我们默认使用名称。对于大多数人来说，代码中最棘手的部分可能是正则表达式的使用。
- en: Listing 9.7  The `get_transaction` method
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7  `get_transaction` 方法
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Defines a function that returns a list of transactions'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了一个返回交易列表的函数'
- en: '#2 A pattern to match a single amount'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 匹配单个金额的模式'
- en: '#3 A pattern to match two amounts'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 匹配两个金额的模式'
- en: '#4 Checks the criteria against a single amount and calls the appropriate method'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将标准与单个金额进行比对并调用相应的方法'
- en: '#5 Uses the walrus operator to store the match results for the multiple_amounts_pattern'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用 walrus 运算符存储 multiple_amounts_pattern 的匹配结果'
- en: '#6 Retrieves the amounts using the groups() method from match'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用 match 的 groups() 方法检索金额'
- en: '#7 Calls the method with the retrieved arguments'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 使用检索到的参数调用方法'
- en: '#8 Otherwise, no amounts matched, and we should use the individual name.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 否则，没有匹配的金额，我们应该使用单个名称。'
- en: 'Before moving on, let’s break down the regular expressions to ensure you understand
    their usage. Here are the important points:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们分解正则表达式以确保你理解它们的用法。以下是一些重要点：
- en: Each pattern string is prefixed by `r` to denote a raw string, which prevents
    us from having to escape any strings. Otherwise, we would have to use `\\` instead
    of `\`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模式字符串都以前缀 `r` 开头，表示原始字符串，这防止了我们不得不转义任何字符串。否则，我们不得不使用 `\\` 而不是 `\`。
- en: The characters `^` and `$` are input boundary assertions, indicating the start
    and end of the string, respectively. These help us eliminate matching strings
    that contain characters other than the pattern we are interested in.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符 `^` 和 `$` 是输入边界断言，分别表示字符串的开始和结束。这些帮助我们消除包含我们感兴趣模式之外字符的匹配字符串。
- en: The `\d` matches any digit (0–9), and `+` is a quantifier that means to match
    one or more occurrences of the preceding atom (the most basic unit of a regular
    expression).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d` 匹配任何数字（0–9），而 `+` 是一个量词，表示匹配前一个原子（正则表达式的最基本单元）的一个或多个出现。'
- en: The `\.` matches the literal period character because a single period will otherwise
    match any character.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\.` 匹配实际的点字符，因为单个点否则会匹配任何字符。'
- en: The `\d` matches any digit (0–9), and adding the `{2}` is another quantifier
    that specifies the count of atoms to match.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d` 匹配任何数字（0–9），而添加 `{2}` 是另一个量词，指定要匹配的原子数量。'
- en: The `\s` matches any whitespace. Again, we see the plus sign quantifier, which
    allows the two amounts to be separated by at least one character and up to any
    amount of whitespace.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配任何空白字符。同样，我们看到加号量词，它允许两个金额之间至少有一个字符，并且可以有任何数量的空白字符。'
- en: Wrapping a portion of the regular expression in parentheses creates a capture
    group. These groups can then be referenced later, as you’ll see when we use `match.groups()`
    to extract the found values.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将正则表达式的一部分括起来创建一个捕获组。然后，你可以稍后引用这些组，正如我们在使用 `match.groups()` 提取找到的值时所看到的那样。
- en: Regular expressions are not limited to the financial industry, and you will
    find them throughout your career. While they can be difficult to grasp, generative
    AI tools are a great way to help break down regular expressions and provide more
    insight into them. Practice makes perfect, and to get more hands-on experience
    with regular expressions, you may want to check out *Regular Expression Puzzles
    and AI Coding Assistant*s (2023, Manning) by David Mertz.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不仅限于金融行业，你将在整个职业生涯中找到它们。虽然它们可能难以掌握，但生成式 AI 工具是帮助分解正则表达式并提供更多见解的绝佳方式。熟能生巧，为了获得更多正则表达式的实践经验，你可能想查看
    David Mertz 的 *正则表达式谜题和 AI 编码助手*（2023，Manning）。
- en: With that behind us, let’s take a look at the functions that are actually retrieving
    the transactions based on the search criteria provided. In our cases, the queries
    themselves remain much the same with only the `Where` clauses being unique for
    each query. The following listing shows the `_get_transactions_using_amount` function
    that looks for an exact amount and returns any results.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们看看根据提供的搜索条件实际检索交易的函数。在我们的案例中，查询本身保持不变，只是每个查询的 `Where` 子句是唯一的。以下列表显示了
    `_get_transactions_using_amount` 函数，该函数查找精确金额并返回任何结果。
- en: Listing 9.8  Retrieving transactions by amount
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8  通过金额检索事务
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 We declare that the row will be of type TransactionSearchResponse.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们声明该行将为 TransactionSearchResponse 类型。'
- en: '#2 The standard columns that we are trying to select'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们试图选择的常规列'
- en: '#3 Appends the Where clause for the query'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 为查询添加 Where 子句'
- en: '#4 Uses the criteria that we want to pass to the query'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用我们想要传递给查询的标准'
- en: '#5 Gets all rows and returns the response'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 获取所有行并返回响应'
- en: We have factored out the common portion of the SQL query into the `get_sql_selection_query`
    method, which allows the `Where` clause to be added to the query. When searching
    for transactions by amount, we used an exact match. When using a range of amounts,
    we employ the Postgres syntax and use the keyword `BETWEEN`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 SQL 查询的公共部分提取到 `get_sql_selection_query` 方法中，这使得可以在查询中添加 `Where` 子句。当通过金额搜索事务时，我们使用了精确匹配。当使用金额范围时，我们使用
    Postgres 语法并使用关键字 `BETWEEN`。
- en: Listing 9.9  Using the `BETWEEN` keyword
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9  使用 `BETWEEN` 关键字
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Uses BETWEEN to search between two amounts; often more concise and readable
    than multiple conditions'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用 BETWEEN 在两个金额之间进行搜索；通常比多个条件更简洁、更易读'
- en: Similarly, when searching for an individual name, we use the `ILIKE` keyword,
    as shown in listing 9.10\. Using `ILIKE` allows us to do a case-insensitive search—otherwise,
    we are searching for the same string. Note that ILIKE is a Postgres-specific command.
    Other databases such as MySQL use the `LIKE` keyword, but it is case-insensitive
    by default. Still, other databases such as Oracle are case-sensitive and require
    the `UPPER` function in the comparison to achieve a case-insensitive search. So,
    always be aware of the database you are using.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当搜索单个名称时，我们使用 `ILIKE` 关键字，如列表 9.10 所示。使用 `ILIKE` 允许我们进行不区分大小写的搜索——否则，我们是在搜索相同的字符串。请注意，ILIKE
    是 Postgres 特有的命令。其他数据库如 MySQL 使用 `LIKE` 关键字，但默认情况下不区分大小写。仍然，其他数据库如 Oracle 是区分大小写的，并且需要在比较中使用
    `UPPER` 函数来实现不区分大小写的搜索。所以，始终要意识到你正在使用的数据库。
- en: We may consider appending a percentage sign (`%)` to the criteria, which is
    a SQL wildcard and would match the individual name if anything appeared after
    it. Or perhaps we could replace any spaces found in the string with the wildcard
    to expand our search results. Those are just some basic starting points if additional
    search capabilities are required.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑在标准中添加一个百分号（`%`），这是一个 SQL 通配符，如果其后有任何内容出现，它将匹配单个名称。或者，我们可能可以将字符串中找到的任何空格替换为通配符以扩展我们的搜索结果。如果需要额外的搜索功能，这些只是基本起点。
- en: Listing 9.10  Case-insensitive search
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10  不区分大小写的搜索
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 Use ILIKE for a case-insensitive search of the individual name.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用 ILIKE 对单个名称进行不区分大小写的搜索。'
- en: The following listing shows the common portion of the query that retrieves the
    transaction information. In addition to the need of joining records together to
    drill down to transaction details, we rename the fields to ensure they can be
    stored in our response object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了检索事务信息的查询的公共部分。除了需要将记录连接起来以深入事务细节之外，我们还重命名了字段以确保它们可以存储在我们的响应对象中。
- en: Listing 9.11  Common transaction query selection criteria
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11  常见事务查询选择标准
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 The selection criteria required for our object. The fields are prefixed
    to help determine the files they belong to. It is not always necessary when the
    names are unique but is helpful for maintaining the code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们对象所需的选取标准。字段前缀有助于确定它们所属的文件。当名称唯一时，这并不总是必要的，但对于维护代码是有帮助的。'
- en: '#2 Joining of the various records'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 连接各种记录'
- en: With the queries working and returning our data, we should now see that all
    our tests have passed. Next, we look at how to add the search capability to our
    UI.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询运行并返回我们的数据时，我们现在应该看到所有测试都已通过。接下来，我们看看如何将搜索功能添加到我们的用户界面中。
- en: 9.2.3 UI search page
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 UI 搜索页面
- en: To add search functionality to our page, we start by adding an icon to our sidebar
    navigation. This means we can update NavButtons.tsx to add a new button with an
    icon.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要将搜索功能添加到我们的页面中，我们首先在侧边栏导航中添加一个图标。这意味着我们可以更新 NavButtons.tsx 来添加一个带有图标的按钮。
- en: Listing 9.12  Updating NavButtons.tsx
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12  更新 NavButtons.tsx
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Imports the search icon'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入搜索图标'
- en: '#2 Includes the search icon'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 包含搜索图标'
- en: Of course, if we try clicking the button, we receive a `404` `NOT` `FOUND` error
    message because we have yet to define our actual page. As with previous pages,
    we will create a simple page that will allow us to resolve the `404` error message
    and give us a starting point for developing the rest of the page. The following
    listing shows the src/app/search/page.tsx.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们尝试点击按钮，我们会收到一个`404` `NOT` `FOUND`错误消息，因为我们还没有定义我们的实际页面。与之前的页面一样，我们将创建一个简单的页面，这将允许我们解决`404`错误消息，并为我们开发页面的其余部分提供一个起点。以下列表显示了`src/app/search/page.tsx`。
- en: Listing 9.13  Search page stub
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.13  搜索页面草稿
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 Creates a simple search page'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建一个简单的搜索页面'
- en: '#2 Something to identify the page so we know we navigated to it'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 用来识别页面，以便我们知道我们已经导航到该页面'
- en: With our page stubbed out, we can click the search button, and we should see
    our navigation and search page. Now, we can add the components that will give
    us the necessary functionality to create a search page capable of displaying our
    results. The hardest part is deciding how to layout the page. From previous API
    calls (such as returning exceptions in chapter 8), we already know how to fetch
    data from an API and display it within a DataGrid component. We will be following
    the same steps of defining an object to hold the data, a component to display
    the data, and then adding that to our search page.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的页面草稿完成后，我们可以点击搜索按钮，应该会看到我们的导航和搜索页面。现在，我们可以添加必要的组件，以创建一个能够显示结果的搜索页面。最难的部分是决定如何布局页面。从之前的API调用（例如第8章中返回的异常），我们已经知道如何从API获取数据并在DataGrid组件中显示它。我们将遵循相同的步骤：定义一个用于存储数据的对象，一个用于显示数据的组件，然后将它添加到我们的搜索页面中。
- en: We start by defining an interface `AchTransactionSearchResponse` to hold the
    data that the API response will pass back. The following listing shows the fields
    and their data types.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个接口`AchTransactionSearchResponse`来存储API响应将传递回的数据。以下列表显示了字段及其数据类型。
- en: Listing 9.14  The `AchTransactionSearchResponse` interface
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.14  `AchTransactionSearchResponse` 接口
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 Exports the AchTransactionSearchResponse so that it is available everywhere'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导出`AchTransactionSearchResponse`使其在所有地方可用'
- en: '#2 The fields returned from the API'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 API返回的字段'
- en: Once we have a place to hold the retrieved data, we can create a component that
    will display the data. This `AchTransactionSearchResults` component will be similar
    to other components we have created, where we pass the results of our API call
    into the component via the results object of `AchTransactionSearchResultsProps`.
    We utilize the `renderCell` property on the column definitions to add links that
    allow users to jump directly to the file or batch of a particular search result.
    Furthermore, since our results did not have an ID column, we have to define one
    to the DataGrid component using the `getRowId` property. The `entry_id` can act
    as our ID column because for each result, the `entry_id` is the UUID for the transaction,
    and that is unique. The following listing shows the more important parts of the
    component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个地方来存储检索到的数据，我们就可以创建一个组件来显示这些数据。这个`AchTransactionSearchResults`组件将类似于我们创建的其他组件，我们将通过`AchTransactionSearchResultsProps`的结果对象将API调用的结果传递给组件。我们利用列定义上的`renderCell`属性添加链接，允许用户直接跳转到特定搜索结果的文件或批次。此外，由于我们的结果没有ID列，我们必须使用`getRowId`属性在DataGrid组件中定义一个。`entry_id`可以作为我们的ID列，因为对于每个结果，`entry_id`是交易的UUID，它是唯一的。以下列表显示了组件的更重要的部分。
- en: Listing 9.15  The `AchTransactionSearchResults` component
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.15  `AchTransactionSearchResults` 组件
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 Exports the search results function and declares the parameters read only'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导出搜索结果函数并声明参数为只读'
- en: '#2 Uses the router for navigation purposes'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用路由进行导航目的'
- en: '#3 Begins defining columns to show'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 开始定义要显示的列'
- en: '#4 Defines a column that will create a link, which will navigate to the file
    details page when clicked'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义一个列，该列将创建一个链接，点击后将导航到文件详情页面'
- en: '#5 Defines a column that will create a link, which will navigate to the batch
    details page when clicked'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 定义一个列，该列将创建一个链接，点击后将导航到批量详情页面'
- en: '#6'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#6'
- en: '#7 Since there is no specific parameter named id, we specify which field can
    be used.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 由于没有名为id的具体参数，我们指定哪个字段可以使用。'
- en: Now that we have a place to store the data and a way to present them, all that
    is left is to make the API call and pass it to our component. For that, we updated
    our search page to have a text input field and a search button to make the actual
    API call. We use the `onChange` event of the `TextField` to store the text entered
    by the user into the `searchCriteria` field. When the user clicks the search button,
    the `onClick` event is fired, and the `handleSearch` is executed. The `handleSearch`
    makes a call to our API and stores the result. The important pieces of the updated
    search page are shown in the following listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储数据的地方和展示数据的方式，剩下要做的就是调用 API 并将其传递给我们的组件。为此，我们更新了我们的搜索页面，添加了一个文本输入字段和一个搜索按钮来执行实际的
    API 调用。我们使用 `TextField` 的 `onChange` 事件将用户输入的文本存储到 `searchCriteria` 字段中。当用户点击搜索按钮时，将触发
    `onClick` 事件，并执行 `handleSearch`。`handleSearch` 调用我们的 API 并存储结果。更新的搜索页面的重要部分如下所示。
- en: Listing 9.16  Updated search page
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.16  更新的搜索页面
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 Initializes the searchCriteria to an empty string'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将搜索标准初始化为空字符串'
- en: '#2 Initializes the results to an empty string'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将结果初始化为空字符串'
- en: '#3 The handleChange function saves the entered text to be used later.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 handleChange 函数将输入的文本保存以供以后使用。'
- en: '#4 The handleSearch function calls the API and saves the results using setResults.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 handleSearch 函数调用 API 并使用 setResults 保存结果。'
- en: '#5 Uses axios to get the response'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用 axios 获取响应'
- en: '#6 Defines a TextField element for a user to enter a search string'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 定义一个用于用户输入搜索字符串的 TextField 元素'
- en: '#7 Defines a button element that will search for the entered string'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 定义一个将搜索输入字符串的按钮元素'
- en: '#8 A component that takes the results to display them'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 一个用于显示结果的组件'
- en: We now have a search page that can perform basic transaction searches and provides
    the ability to jump directly to the file or batch where the transactions were
    found. Next, we reinforce testing with Playwright to get some integration-level
    tests for our search capabilities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以执行基本交易搜索并提供直接跳转到找到交易的文件或批次的搜索页面。接下来，我们通过 Playwright 加强测试，以获取我们搜索功能的一些集成级别测试。
- en: 9.2.4 Integration testing with Playwright
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 使用 Playwright 进行集成测试
- en: After we make searching for our transaction possible, it would be nice to add
    an integration test that we can use for integration and regression testing. We
    set up a test that requires us to
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使搜索我们的交易成为可能之后，添加一个集成测试将是一个很好的选择，我们可以用它来进行集成和回归测试。我们设置了一个测试，需要我们
- en: Upload a file to parse
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传文件以解析
- en: Navigate to the search page
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到搜索页面
- en: Populate the search page
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充搜索页面
- en: Wait for an ACH response
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 ACH 响应
- en: Validate the result is populated
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证结果是否已填充
- en: Take a screenshot
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拍摄屏幕截图
- en: We created a Python script named test_search_page.py to perform all these necessary
    steps. In addition, we want to have the option to debug our test with the browser
    window displayed; to accomplish that, we need to create a few Pytest fixtures.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 test_search_page.py 的 Python 脚本来执行所有这些必要的步骤。此外，我们希望有选项可以在浏览器窗口显示的情况下调试我们的测试；为了实现这一点，我们需要创建一些
    Pytest 固定装置。
- en: Listing 9.17  Pytest fixtures for Playwright
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.17  Playwright 的 Pytest 固定装置
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 Defines a fixture with the scope session, which will cause the fixture to
    persist for the length of the test session'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个具有会话范围的固定装置，这将导致固定装置在测试会话期间持续存在'
- en: '#2 Defines a function named browser that creates a browser instance. We use
    headless=False to step through the test session and see what the browser is doing.
    Using headless=True will hide the browser window and is the default way of running
    unit tests.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义一个名为 browser 的函数，用于创建浏览器实例。我们使用 headless=False 以逐步进行测试会话并查看浏览器正在做什么。使用
    headless=True 将隐藏浏览器窗口，这是运行单元测试的默认方式。'
- en: '#3 The yield browser command will return the browser object.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 yield 浏览器命令将返回浏览器对象。'
- en: '#4 When all tests are finished, the browser is closed.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 当所有测试完成后，关闭浏览器。'
- en: '#5 Defines a fixture with the scope of function, which is the default scope'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 定义一个具有函数范围的固定装置，这是默认范围'
- en: '#6 Creates a page that will be used with the test'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 创建一个用于测试的页面'
- en: '#7 Uses the default tab if it exists; otherwise, creates a new one'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 如果存在，则使用默认选项卡；否则，创建一个新的选项卡'
- en: '#8 Returns the page using yield, so it is available to the test'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 使用 yield 返回页面，以便在测试中可用'
- en: '#9 Clears the context after the test is run'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 测试运行后清除上下文'
- en: That is enough to get the Playwright structure set up. Now, we want to ensure
    our database is empty and that we load our ACH file before starting our integration
    test.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够设置 Playwright 结构了。现在，我们想要确保我们的数据库为空，并在开始集成测试之前加载我们的 ACH 文件。
- en: Listing 9.18  Clearing the database and loading our file
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.18  清空数据库并加载我们的文件
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 Define a fixture with autouse set to True. This causes it to be included
    for every test by default.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个设置为 autouse 为 True 的 fixture。这会导致它默认包含在每个测试中。'
- en: '#2 Clears our database'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 清空我们的数据库'
- en: '#3 Loads a file for the test into the database'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将测试文件加载到数据库中'
- en: '#4 Ensures the path is correct based on where we are running from'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 确保路径正确，基于我们从哪里运行'
- en: Now that the setup is done, we can start the actual testing with Playwright.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置完成，我们可以开始使用 Playwright 进行实际测试。
- en: Listing 9.19  Playwright testing
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.19  Playwright 测试
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 Navigates to the search screen and ensures the page is loaded'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导航到搜索屏幕并确保页面已加载'
- en: '#2 Validates that we are on the correct page'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 验证我们是否在正确的页面上'
- en: '#3 Finds the textbox and enters the text “sally saver”'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 找到文本框并输入文本“sally saver”'
- en: '#4 Finds the search button'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 找到搜索按钮'
- en: '#5 Expects an API response from the search button when it is clicked'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 预期当点击搜索按钮时会有 API 响应'
- en: '#6 Checks that the response was 200'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 检查响应状态码为 200'
- en: '#7 We should be able to see an entry with the text “Sally Saver.”'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 我们应该能够看到一个包含文本“Sally Saver”的条目。'
- en: '#8 Takes a screenshot for posterity'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 为永存性拍摄屏幕截图'
- en: 'Now you know how to perform some integration testing where you may need to
    make API calls and validate the results. In the next section, we look at another
    critical aspect of development in many industries: keeping an audit trail.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何执行一些集成测试，你可能需要调用 API 并验证结果。在下一节中，我们将探讨许多行业中开发的一个关键方面：保持审计跟踪。
- en: 9.3 Auditing user interactions
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 审计用户交互
- en: One of the critical security controls put forth by The Center for Internet Security
    is that of audit log management ([https://mng.bz/gaGE](https://mng.bz/gaGE)).
    While we won’t be covering all the aspects, we will at least begin the journey
    by ensuring that we are collecting data about the usage of our application. Keep
    in mind that collecting data is the first step. If we do not have a strategy to
    monitor, review, and receive alerts as necessary, the logs are useless.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网安全中心提出的几个关键安全控制之一是审计日志管理（[https://mng.bz/gaGE](https://mng.bz/gaGE)）。虽然我们不会涵盖所有方面，但我们将至少从确保我们收集有关应用程序使用情况的数据开始。记住，收集数据是第一步。如果我们没有监控、审查和必要时接收警报的策略，日志就毫无用处。
- en: Many times, we have worked on a problem where we were put on the wrong path
    initially because someone had identified an error occurring in a log. Further
    research showed that the error had been occurring for many months (as far back
    as logs were readily available) and was not the source of the current problem.
    Sometimes, in the heat of a production incident, you can easily fall into that
    type of trap because of the need to resolve the problem quickly. With proper audit
    log management, you can gain a better understanding of the baseline application
    behavior and monitor for application misuse, among many other benefits.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，我们解决过的问题最初是因为有人识别到日志中发生错误而被引入了错误的方向。进一步的研究表明，错误已经发生数月（远至日志容易获取的时候）并且不是当前问题的源头。有时，在生产的紧急事件中，由于需要快速解决问题，你很容易陷入这种陷阱。通过适当的审计日志管理，你可以更好地理解基线应用程序行为，并监控应用程序滥用，以及其他许多好处。
- en: While there are many commercial off-the-shelf tools (COTS) such as Splunk, Dynatrace,
    DataDog, and Sentry that help with logging and observability, we focus primarily
    on logging our data into the database and growing from there if necessary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多现成的商业工具（COTS）如 Splunk、Dynatrace、DataDog 和 Sentry 可以帮助进行日志记录和可观察性，但我们主要关注将数据记录到数据库中，并在必要时从那里扩展。
- en: 9.3.1 Database design
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 数据库设计
- en: If we want to get started with auditing, we need to create a new database table
    to store our data. It will be based on the needs of your application and on what
    you are trying to accomplish. In our case, we are going to keep track of the API
    requests coming into the system. We introduce a new data type for dealing with
    hosts and networks—the `INET` data type for the `ip_address` field. While using
    a string data type for `ip_address` would certainly work as well, there are additional
    comparisons and functions in Postgres for dealing with `INET` that can make life
    easier. For instance, we could search for all addresses in a given range by using
    `WHERE ip_address` `<<` `'192.168.1.0/24'`. This search may be helpful if we wanted
    to see activity coming from a list of addresses that we suspect of abusing our
    application. The following listing shows the creation of the table.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要开始进行审计，我们需要创建一个新的数据库表来存储我们的数据。这将基于您的应用程序需求以及您试图实现的目标。在我们的案例中，我们将跟踪进入系统的API请求。我们引入了一种新的数据类型来处理主机和网络——`ip_address`字段的`INET`数据类型。虽然使用字符串数据类型对于`ip_address`来说当然也可以工作，但Postgres提供了处理`INET`的额外比较和函数，这可以使生活更加轻松。例如，我们可以通过使用`WHERE
    ip_address` `<<` `'192.168.1.0/24'`来搜索给定范围内的所有地址。如果我们想查看来自我们怀疑滥用我们应用程序的地址列表的活动，这种搜索可能会有所帮助。以下列表显示了表的创建。
- en: Listing 9.20  The `audit_log` table
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.20  `audit_log`表
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Creates a table named audit_log'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建名为audit_log的表'
- en: '#2 Saves when the record has been created using a TIMESTAMP datatype. We also
    use NOT NULL so that the field must always be populated. Finally, we default to
    using the NOW() function in Postgres, which will populate the field with the current
    date/time when records are inserted without a value.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当记录使用TIMESTAMP数据类型创建时保存。我们还使用NOT NULL，以确保字段必须始终被填充。最后，我们默认使用Postgres中的NOW()函数，该函数将在记录插入时填充字段，如果没有提供值。'
- en: '#3 Creates a field named ip_address with the INET data type, which is a handy
    type for network addresses'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建一个名为ip_address的字段，其数据类型为INET，这是一个方便处理网络地址的数据类型'
- en: With the table in place, we can create the code necessary to write these audit
    records out.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在表就绪后，我们可以创建编写这些审计记录所需的代码。
- en: 9.3.2 TDD testing for auditing
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 为审计进行的TDD测试
- en: We create the unit tests for our API first and then add the required code to
    make our tests pass. Should we also consider the BDD-style testing? The answer
    to that depends on how the business will choose to use the audit log. If the log
    will serve primarily as something that developers use, then the business will
    likely not need to work with us to develop tests. In contrast, if the business
    plans to use the audit log to pull the activity to help determine metrics, we
    may need to work with them to develop tests. We could easily see the business
    making that type of request and the need to update our tests to read something
    along the lines of `WHEN` `I` `REQUEST` `A` `LIST` `OF` `FILES` `THEN` `I` `SHOULD`
    `SEE AN` `AUDIT` `LOG` `RECORD` `INDICATING` `FILES` `WERE` `SHOWN`. For now,
    we will stick with our standard unit testing. The unit test defines a record and
    then retrieves it so that we can compare the fields. We currently have a field
    for `user_id`, but since we are not tracking users at the moment, we will leave
    it empty.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为API创建单元测试，然后添加必要的代码以使测试通过。我们也应该考虑BDD风格的测试吗？这个答案取决于业务如何选择使用审计日志。如果日志主要作为开发者使用的东西，那么业务可能不需要与我们合作来开发测试。相反，如果业务计划使用审计日志来拉取活动以帮助确定指标，我们可能需要与他们合作来开发测试。我们可以很容易地看到业务提出那种类型的要求，并需要更新我们的测试以读取类似`WHEN`
    `I` `REQUEST` `A` `LIST` `OF` `FILES` `THEN` `I` `SHOULD` `SEE AN` `AUDIT` `LOG`
    `RECORD` `INDICATING` `FILES` `WERE` `SHOWN`的内容。现在，我们将坚持我们的标准单元测试。单元测试定义了一个记录然后检索它，以便我们可以比较字段。我们目前有一个`user_id`字段，但由于我们目前没有跟踪用户，我们将留空。
- en: Listing 9.21  Unit test for the audit log
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.21  审计日志的单元测试
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Clears the database each time'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 每次清除数据库'
- en: '#2 Creates a dummy record'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建一个虚拟记录'
- en: '#3 Uses the AuditLog class to create and retrieve a record'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用AuditLog类创建和检索记录'
- en: '#4 Excludes the specified fields from the dictionary as these are populated
    by the database and do not affect the comparison; then asserts the record match'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 从字典中排除指定的字段，因为这些字段由数据库填充且不影响比较；然后断言记录匹配'
- en: The unit test requires an object for `AuditLogRecord`, which is a standard Pydantic
    model to hold our data. We use two new data types in this model—`IPvAnyNetwork`
    and `AnyUrl` (both available as imports from Pydantic). The `IPvAnyNetwork` works
    well for representing the `INET` field we defined in the table and provides validation
    as expected for IP addresses, regardless of whether they are defined as a single
    address (e.g., `127.0.0.1`) or a range of them (e.g., `192.168.1.0/24`). Of course,
    we would not expect to see a range of addresses in this field for an audit record.
    The `AnyUrl` field similarly provides validation of URLs, saving us from having
    to write regular expressions to validate the field. Listing 9.22 shows our `AuditLogRecord`
    class, with some less interesting fields removed for brevity.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试需要一个 `AuditLogRecord` 对象，这是一个标准的 Pydantic 模型，用于存储我们的数据。在这个模型中，我们使用了两种新的数据类型——`IPvAnyNetwork`
    和 `AnyUrl`（两者都可作为从 Pydantic 导入的导入项）。`IPvAnyNetwork` 对于表示我们在表中定义的 `INET` 字段效果很好，并且对于
    IP 地址提供了预期的验证，无论它们是单个地址（例如，`127.0.0.1`）还是一系列地址（例如，`192.168.1.0/24`）。当然，我们不会期望在这个字段中看到地址范围。`AnyUrl`
    字段类似地提供了对 URL 的验证，使我们免于编写正则表达式来验证字段。列表 9.22 显示了我们的 `AuditLogRecord` 类，为了简洁起见，删除了一些不太有趣的字段。
- en: Listing 9.22  The `AuditLogRecord` class
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.22  `AuditLogRecord` 类
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 Defines the ip_address as a type of IPvAnyNetwork, which allows Pydantic
    to validate IP addresses and networks'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将 ip_address 定义为 IPvAnyNetwork 类型，这允许 Pydantic 验证 IP 地址和网络'
- en: '#2 Defines the URL as a type of AnyUrl, which allows Pydantic to validate whether
    the URL is properly formatted'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将 URL 定义为 AnyUrl 类型，这允许 Pydantic 验证 URL 是否格式正确'
- en: '#3 Defines a field validator so that the URL is converted to a string to be
    stored in the database'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义了一个字段验证器，以便将 URL 转换为字符串以存储在数据库中'
- en: As shown in listing 9.22, we also use a field validator to return the URL field
    as a string. This is because we will receive an error when attempting to insert
    it into the database because the URL datatype is not compatible with a string.
    We could have explicitly coded for it in the audit log class responsible for inserting
    the record, but this approach wraps up everything nicely, and other developers
    do not have to worry about it, which helps reduce cognitive load.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 9.22 所示，我们也使用字段验证器将 URL 字段作为字符串返回。这是因为当我们尝试将其插入数据库时，我们会收到错误，因为 URL 数据类型与字符串不兼容。我们可以在负责插入记录的审计日志类中明确编码它，但这种方法可以很好地封装一切，其他开发者不必担心它，这有助于减少认知负荷。
- en: The final step of being able to write records and get this unit test to pass
    is generating an actual class to be inserted into the database. In the following
    listing, we create an `AuditLog` class that contains a `log_record` and `get_log_record`
    methods. For other database records, we specifically used `Sql` as part of the
    name. In this case, we did not necessarily want to tie it to a database.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 能够写入记录并使这个单元测试通过的最后一步是生成一个实际要插入数据库的类。在以下列表中，我们创建了一个包含 `log_record` 和 `get_log_record`
    方法的 `AuditLog` 类。对于其他数据库记录，我们特别使用了 `Sql` 作为名称的一部分。在这种情况下，我们并不一定想将其绑定到数据库。
- en: Listing 9.23  The `AuditLog` class
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.23  `AuditLog` 类
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Defines a dictonary to use'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了一个要使用的字典'
- en: '#2 Defines the fields to insert; we will return the audit_log_id we obtained
    from the database.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义了要插入的字段；我们将返回从数据库中获得的 audit_log_id。'
- en: '#3 Because we used a dict_row for row_factory, we can reference the audit_log_id
    directly.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 因为使用了 dict_row 作为 row_factory，我们可以直接引用 audit_log_id。'
- en: With that in place, our unit test is passing, and we can add audit records wherever
    we want. Now, let’s see how to integrate what we know with the FastAPI framework.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们的单元测试通过了，我们可以在任何想要的地方添加审计记录。现在，让我们看看如何将我们所学的内容与 FastAPI 框架集成。
- en: 9.3.3 Auditing logic
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 审计逻辑
- en: The most obvious way to add auditing to our application is by making a call
    to the `log_record` method and passing an `AuditLogRecord`, as seen from our unit
    test. We could certainly take one of our existing endpoints and add the call into
    it, ending up with something akin to the following listing, which allows us to
    write a message but does not capture some of the other potentially useful information
    we defined fields for.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的应用程序添加审计的最明显方式是通过调用 `log_record` 方法并传递一个 `AuditLogRecord`，正如我们在单元测试中所看到的。我们当然可以取我们的现有端点之一并添加调用，最终得到以下类似列表的内容，这允许我们写入消息，但并没有捕获我们为定义的字段所定义的一些其他可能有用的信息。
- en: Listing 9.24  One way to add logging of our API
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.24  添加我们的 API 记录的一种方式
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 Manually calls the log_record method whenever the API is executed, but we
    are missing many of the interesting fields'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 在API执行时手动调用log_record方法，但我们遗漏了许多有趣的字段'
- en: We could enhance the previous listing by including the request field. Then we
    can pull the additional information from the request object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包括请求字段来增强前面的列表。然后我们可以从请求对象中提取额外的信息。
- en: Listing 9.25  Including request information in our API
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.25  在我们的API中包含请求信息
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Updates the method to include the Request object'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 更新方法以包括请求对象'
- en: '#2 We now have access to some of the interesting fields'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们现在可以访问一些有趣的字段'
- en: While that works, it requires the developers to add more boilerplate logic than
    we would prefer. Since we are primarily interested in auditing the usage of our
    APIs, we can take another approach.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可行，但它要求开发者添加比我们更愿意的更多样板逻辑。由于我们主要对审计API的使用感兴趣，我们可以采取另一种方法。
- en: 9.4 Using middleware for our logging
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用中间件进行日志记录
- en: With the goal of logging the API requests, we can look at adding a middleware
    function that has the sole purpose of logging our requests. We can employ both
    the request and response, which allows us to capture the response code as well.
    While we could also look at configuring our Nginx logs to capture the information
    in the production environment, seeing how to accomplish this in FastAPI is also
    helpful since it can be widely applied for other requirements. We use the `@app.middleware`
    notation to write our log record.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录API请求，我们可以考虑添加一个具有唯一日志记录请求目的的中间件函数。我们可以使用请求和响应，这使我们能够捕获响应代码。虽然我们也可以考虑配置我们的Nginx日志以捕获生产环境中的信息，但了解如何在FastAPI中实现这一点也是有帮助的，因为它可以广泛应用于其他需求。我们使用`@app.middleware`注解来编写我们的日志记录。
- en: Listing 9.26  The middleware layer for logging
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.26  日志记录的中间件层
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#1 Defines a middleware component that executes for every HTTP request'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了一个中间件组件，该组件为每个HTTP请求执行'
- en: '#2 Defines a method to log requests'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义一个日志请求的方法'
- en: '#3 Passes the request on to the next layer'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将请求传递给下一层'
- en: '#4 Gets the log_message that was defined in the request.state and defaults
    if not present'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 获取在请求.state中定义的log_message，如果不存在则默认'
- en: '#5 Builds an AuditLogRecord with our desired request fields'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用我们期望的请求字段构建一个AuditLogRecord'
- en: '#6 Writes the log messages'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 编写日志消息'
- en: '#7 Returns the response'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 返回响应'
- en: It is relatively easy to insert that middleware layer and have it perform the
    logging. Then we can log all the calls that are coming in, which removes the need
    for the boilerplate code. Moreover, it keeps our code cleaner and lets the developers
    focus on their code. The only drawback is that adding a message would take a little
    more effort. Of course, the message is going to reflect what the `REST` `API`
    call is doing. So, in some respect, it is redundant (and a waste of space) to
    log a message. For instance, do we need to know someone viewed ACH files when
    the log also shows that they were performing a `GET` on `/api/v1/files`? Of course,
    we may need to do it for business reasons because it is easier for people unfamiliar
    with the data to interpret the message when being reviewed. Rather than waste
    the storage, we may decide to have a utility method that could perform that interpretation
    and insert the appropriate message during an extract. The use cases could vary,
    of course, and we only want to illustrate some of the alternatives. In this case,
    we do want to store the text in the database table, and we are going to accomplish
    that using a decorator. The following listing shows how to include a message in
    the request state using a `log_message` annotation we defined.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 插入该中间件层并使其执行日志记录相对容易。然后我们可以记录所有传入的调用，这消除了样板代码的需求。此外，它使我们的代码更简洁，让开发者专注于他们的代码。唯一的缺点是添加消息需要更多的努力。当然，消息将反映`REST`
    `API`调用正在做什么。因此，从某种意义上说，记录消息是多余的（并且是空间的浪费）。例如，当日志显示他们在`/api/v1/files`上执行`GET`操作时，我们是否需要知道有人查看ACH文件？当然，我们可能需要出于业务原因这样做，因为当被审查时，对于不熟悉数据的人来说，解释消息更容易。与其浪费存储空间，我们可能决定有一个实用方法，可以在提取期间执行该解释并插入适当的消息。用例可能各不相同，我们只想说明一些替代方案。在这种情况下，我们确实想在数据库表中存储文本，我们将使用装饰器来完成这项工作。以下列表显示了如何使用我们定义的`log_message`注解在请求状态中包含消息。
- en: Listing 9.27  The `log_message` annotation
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.27  `log_message`注解
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 If we have a request, it saves the message that was passed.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果有请求，它将保存传递的消息。'
- en: Finally, we only need to make some minor changes to the API. By using our new
    annotation, we can customize the message written to the database. The next listing
    shows the final changes to our API call.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要对API进行一些小的更改。通过使用我们新的注解，我们可以自定义写入数据库的消息。以下列表显示了我们对API调用的最终更改。
- en: Listing 9.28  Final changes for logging
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.28  日志的最终更改
- en: '[PRE27]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#1 Annotates each of our API calls with a unique message'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 为我们的每个API调用添加一个独特的消息'
- en: '#2 Ensures the request object is part of the method'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 确保请求对象是方法的一部分'
- en: Adding that little bit of logic completes the logging of our API messages. Now,
    log messages are written out for any APIs we annotate with `@log_message`. This
    is just the beginning of tracing and auditing your application. You can vastly
    expand collecting data in your application by exploring projects such as OpenTelemetry,
    OpenTracing, or Prometheus, to name just a few.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这部分逻辑就完成了我们的API消息记录。现在，任何我们用`@log_message`注解的API都会写入日志消息。这只是追踪和审计应用程序的开始。通过探索诸如OpenTelemetry、OpenTracing或Prometheus等项目，您可以极大地扩展在应用程序中收集数据的能力，仅举几个例子。
- en: 9.5 Viewing the audit log
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 查看审计日志
- en: Now that we have the application logging API requests, let’s add the ability
    to view the log in our application. This page will function in much the same way
    the exceptions page from chapter 8 did. We need to retrieve the audit records
    and place them in a DataGrid to be viewed. Of course, we can expand the functionality
    as needed, but for now, simply returning the data is all that we need to accomplish.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序的日志API请求，让我们添加在应用程序中查看日志的能力。这个页面将像第8章中的异常页面一样工作。我们需要检索审计记录并将它们放入DataGrid中以便查看。当然，我们可以根据需要扩展功能，但到目前为止，仅仅返回数据就是我们需要完成的任务。
- en: 9.5.1 Creating the page
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 创建页面
- en: We create the page.tsx under `src/app/audit`. This page will be responsible
    for making a request to the API and then passing the returned data down to a component
    that can display the records. The following listing shows the basic page.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`src/app/audit`下创建`page.tsx`页面。这个页面将负责向API发出请求，然后将返回的数据传递给一个可以显示记录的组件。以下列表显示了基本页面。
- en: Listing 9.29  Audit page
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.29  审计页面
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 Gets the audit records from the database'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从数据库获取审计记录'
- en: '#2 Displays the audit records'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 显示审计记录'
- en: To finish this page, we also want to create the `AuditResponse` interface, as
    shown in listing 9.30\. We keep the names aligned with those from the API because
    there is less work for us. However, in previous chapters, we have shown the process
    of mapping fields to internal representations of the data, and that is still valid
    here. Keep in mind the tradeoffs we incur by exactly matching the API—the biggest
    problem being when the API changes or when we move to another vendor where the
    field names may change. These changes must be propagated throughout the application
    instead of at a single point. We recommend always trying to use a layer of abstraction
    to prevent these types of problems. Nobody wants to spend their time changing
    `created_at` to `created_on` and having to retest everywhere it may touch.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一页，我们还想创建`AuditResponse`接口，如列表9.30所示。我们保持名称与API中的名称一致，因为这样我们工作量更小。然而，在前几章中，我们已经展示了将字段映射到数据内部表示的过程，这一点在这里仍然有效。请记住，我们通过精确匹配API所承担的权衡——最大的问题是当API发生变化或当我们迁移到另一个供应商（字段名称可能发生变化）时。这些更改必须在整个应用程序中传播，而不是在单个点上。我们建议始终尝试使用一层抽象来防止这类问题。没有人愿意花费时间将`created_at`更改为`created_on`，并需要在可能触及的每个地方重新测试。
- en: Listing 9.30  The `AuditResponse` interface
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.30  `AuditResponse`接口
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 9.5.2 Creating the page components
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 创建页面组件
- en: We pass the data down to our `AuditLogRecords` component so that the presentation
    logic is taken care of. At this point, we should hopefully see how components
    help break our code apart into smaller, more manageable pieces. We try to keep
    the pages responsible for retrieving the data, while components on the page are
    responsible for presenting that data. We tend to have more duplicated code when
    applications are first being developed. This is often due to developers trying
    to rush to meet deadlines. As the code matures (and the developers get a better
    sense of the application), we can often start to create more generalized code.
    Breaking down our code into components helps us get to that point quicker. The
    next listing shows the code for the presentation of an audit record.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据传递给我们的 `AuditLogRecords` 组件，以便处理展示逻辑。在这个阶段，我们希望看到组件如何帮助我们将代码分解成更小、更易于管理的部分。我们试图让页面负责检索数据，而页面上的组件则负责展示这些数据。在应用程序最初开发时，我们往往会有更多重复的代码。这通常是因为开发者试图赶在截止日期前完成任务。随着代码的成熟（以及开发者对应用程序有更好的理解），我们通常可以开始创建更通用的代码。将我们的代码分解成组件有助于我们更快地达到这一点。下一个列表显示了展示审计记录的代码。
- en: Listing 9.31  The A`uditLogRecords` component
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.31  `AuditLogRecords` 组件
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '#1 Defines a field to keep track of the modal'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个字段来跟踪模态'
- en: '#2 Defines the contents of the audit details for the modal'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义模态的审计详情内容'
- en: '#3 When the button is clicked, passes information to the modal and sets that
    it is now open'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当按钮被点击时，将信息传递给模态并设置它现在是打开的'
- en: '#4 Uses the DataGrid element to display the text'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用 DataGrid 元素来显示文本'
- en: '#5 Includes the AuditModal component to display the detailed contents'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 包含 `AuditModal` 组件以显示详细内容'
- en: There is an extra utility method we have also built as part of the component—the
    `stripSubnet` method. The code for this method is shown in the following listing.
    Note it only removes a trailing `/32`, so why do we have a function to remove
    it, and why exactly is it there?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还构建了一个额外的实用方法作为组件的一部分——`stripSubnet` 方法。此方法的代码如下所示。注意它只移除尾部的 `/32`，那么为什么我们有移除它的函数，它究竟在哪里？
- en: Listing 9.32  The `stripSubnet` utility method
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.32  `stripSubnet` 实用方法
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '#1 Splits the IP address on the slash'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 在斜杠处分割 IP 地址'
- en: '#2 If the subnet is 32, that indicates a single IP address.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果子网为 32，则表示单个 IP 地址。'
- en: '#3 Returns the IP only when it is a single IP address'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 仅当 IP 地址为单个 IP 时返回 IP'
- en: '#4 Otherwise, returns the string as it came through'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 否则，返回传入的字符串'
- en: The `/32` is part of the Classless Inter-Domain Routing (CIDR) notation, which
    is a way to define IP address ranges. The `/32` means that the given address is
    a single address, and it is just an explicit way to indicate that. To illustrate,
    we could represent the addresses between `192.168.1.0` and `192.168.1.255` with
    `192.168.1.0/24`. That explains what the `/32` is but not why it is there. We
    are seeing the `/32` because we chose to represent the IP address in our Pydantic
    model with `IPvAnyNetwork`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`/32` 是无类域间路由（CIDR）表示法的一部分，它是一种定义 IP 地址范围的方式。`/32` 表示给定的地址是一个单独的地址，它只是明确表示这一点的一种方式。为了说明，我们可以用
    `192.168.1.0/24` 来表示 `192.168.1.0` 和 `192.168.1.255` 之间的地址。这解释了 `/32` 是什么，但没有解释为什么它在那里。我们看到
    `/32` 是因为我们选择在 Pydantic 模型中以 `IPvAnyNetwork` 的形式表示 IP 地址。'
- en: Pydantic supports many network types. The ones that we are primarily concerned
    with at this point are `IPvAnyAddress` and `IPvAnyNetwork`. The decision to use
    `INET` for our `ip_address` column was the catalyst for the problem. The `INET`
    datatype supports storing IP addresses using the CIDR notation. For that reason,
    we chose to use a datatype in Pydantic that closely modeled that functionality,
    even though we should only have a single IP address in our table. We used this
    example to illustrate how design decisions can have a downstream effect. The `INET`
    requirement for the column may be set because there is a need to be able to query
    for ranges of IP addresses, and having an `INET` data type makes sense even though
    there is no business need for the audit record to contain more than a single IP
    address. Perhaps, the decisions were already made (for better or worse) by the
    time the UI piece lands on our plate. The business does not want users to see
    the `/32` as part of the IP address because most users will not understand the
    notation, so we need to correct the display.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic支持许多网络类型。目前我们主要关注的是`IPvAnyAddress`和`IPvAnyNetwork`。使用`INET`作为我们的`ip_address`列的决定是问题的催化剂。`INET`数据类型支持使用CIDR表示法存储IP地址。因此，我们选择在Pydantic中使用一个紧密模拟该功能的类型，尽管我们表中应该只有一个IP地址。我们使用这个例子来说明设计决策如何产生下游影响。列的`INET`要求可能是因为有查询IP地址范围的需求，即使审计记录不需要包含多个IP地址，使用`INET`数据类型也是有意义的。也许，这些决策（无论好坏）在UI组件到达我们手中之前就已经做出了。业务不希望用户看到IP地址中的`/32`部分，因为大多数用户不会理解这种表示法，所以我们需要纠正显示。
- en: The following listing shows some additional unit tests that help illustrate
    the difference between the Pydantic types of `IPvAnyAddress` and `IPvAnyNetwork`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了帮助说明Pydantic类型`IPvAnyAddress`和`IPvAnyNetwork`之间差异的一些额外的单元测试。
- en: Listing 9.33  Unit testing of the network types
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.33  网络类型的单元测试
- en: '[PRE32]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Another custom component we make use of is `AuditModal`. When the details of
    an audit record are clicked, we want to display a formatted window with the audit
    information (listing 9.34). This is meant to be a more complete view of the audit
    record, so we do not need to clutter up the initial view. `AuditModal` is a relatively
    straightforward component. As we already have the entire record returned, this
    is just a presentation of the data, as opposed to the previous chapter where we
    specifically retrieved the ACH record data when the user clicked the view icon.
    Remember, the difference was that we did not want to return possible NPI data
    unless the user requested it. Now we have the ability to view audit information,
    monitor for users requesting NPI data, and address any potential misuse (whether
    intentional or not) of the data.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个自定义组件`AuditModal`。当点击审计记录的详细信息时，我们希望显示一个格式化的窗口，包含审计信息（列表9.34）。这是对审计记录的更完整视图，因此我们不需要在初始视图中添加杂乱。`AuditModal`是一个相对简单的组件。因为我们已经返回了整个记录，这只是一个数据的展示，与上一章中我们在用户点击查看图标时特别检索ACH记录数据的情况不同。记住，区别在于我们不想在没有用户请求的情况下返回可能的NPI数据。现在我们有了查看审计信息的能力，监控用户请求NPI数据，并解决任何潜在的数据滥用（无论是有意还是无意）。
- en: Listing 9.34  The `AuditRecords` component
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.34  `AuditRecords`组件
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 Clickable button that displays detailed information on the audit record'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 可点击的按钮，显示审计记录的详细信息'
- en: '#2 Clickable button that displays detailed information on the audit record'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 可点击的按钮，显示审计记录的详细信息'
- en: '#3 DataGrid element that displays all the audit record results'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 显示所有审计记录结果的DataGrid元素'
- en: '#4 AuditModal component that displays when the icon is clicked'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 当点击图标时显示的AuditModal组件'
- en: With the ability to pull and view audit data, we are missing one critical piece
    to our puzzle—let’s add the API endpoint to retrieve our data.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够拉取和查看审计数据的能力之后，我们缺少拼图中的关键一块——让我们添加API端点来检索我们的数据。
- en: 9.5.3 Adding the APIs for the audit log
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 添加审计日志的API
- en: While we built the initial SQL calls that retrieved records and the UI layers
    to display the data, we have not built the API itself yet. We now need to ensure
    we can call the API and return the data. The following listing shows that all
    it takes is a few lines to accomplish this task, and most of those are helping
    document the API for others to use. We created the audit API in its own file named
    routers/audit.py. Because this endpoint has nothing to do with ACH files, we wanted
    to separate it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们构建了检索记录的初始SQL调用和显示数据的UI层，但我们尚未构建API本身。我们现在需要确保我们可以调用API并返回数据。下面的列表显示，完成这项任务只需要几行代码，其中大部分都是帮助文档化API供他人使用。我们创建了名为`routers/audit.py`的单独文件来创建审计API。因为这个端点与ACH文件无关，我们希望将其分离。
- en: Listing 9.35  Audit router
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.35  审计路由器
- en: '[PRE34]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Simple call to get and return all audit records'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 简单调用以获取和返回所有审计记录'
- en: Since we separated our code for easier maintenance, the API will not be reachable
    until we add it using an `include_router` method. We had initially done this for
    the router/files.py file, and all our APIs up until this point have been put into
    that file, meaning there has been no need to revisit the main.py file until now.
    The next listing shows the additional line needed to access our API.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为了便于维护而分离了代码，API将无法访问，直到我们使用`include_router`方法添加它。我们最初是为`router/files.py`文件这样做，直到这一点，我们所有的API都放入了那个文件，这意味着现在没有必要重新访问`main.py`文件。下一个列表显示了访问我们的API所需的附加行。
- en: Listing 9.36  Adding the router
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.36  添加路由器
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '#1 The additional router to handle the audit API requests'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 处理审计API请求的附加路由器'
- en: That was the final piece to put into place. Now we should have fully functioning
    audit capabilities. We can expand on this with additional logging and more specific
    logging of business scenarios, such as invalid input and other scenarios where
    we may want to log more than just confirmation that an API was accessed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是最后要放置的部分。现在我们应该拥有完整的审计功能。我们可以通过额外的日志记录和更具体的业务场景日志记录来扩展这一点，例如无效输入和其他我们可能希望记录的不仅仅是API访问确认的场景。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Each successive iteration helps improve the functionality of our application.
    We looked to address requests/concerns brought up by the end-users, new functionality
    required by the business, and technical debt.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一次连续的迭代都有助于提升我们应用程序的功能。我们致力于解决最终用户提出的要求/关注点、业务所需的新功能以及技术债务。
- en: Being able to search is a necessary feature of our application. Transactions
    are loaded at various times through different files throughout the day. If a customer
    has a question about when a transaction was loaded, we need to be able to provide
    an answer quickly.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够进行搜索是我们应用程序的一个必要功能。交易在一天中的不同时间通过不同的文件加载。如果客户对交易何时加载有疑问，我们需要能够快速提供答案。
- en: Whether we are working toward protecting our application from intruders or disgruntled
    employees to gain deeper insight into the application, it all starts with proper
    auditing for security and compliance, accompanied by general analysis.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论我们是致力于保护我们的应用程序免受入侵者或不满的员工侵害，还是为了更深入地了解应用程序，这一切都始于适当的审计，以保障安全和合规，并伴随一般分析。
- en: We touched on the importance of not just logging but also of how having a successful
    strategy for managing logs will play a part in our success. We should not trust
    that the application is working or not being attacked—instead, we must have the
    data and analyze it.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们谈到了不仅记录日志的重要性，而且拥有一个成功的日志管理策略将在我们的成功中扮演一部分。我们不应相信应用程序正在运行或未被攻击——相反，我们必须有数据并对其进行分析。
- en: You were shown the importance of expanding exception handling and enhancing
    UI/UX based on user feedback to improve overall user satisfaction and system functionality.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已经了解到，根据用户反馈扩展异常处理和增强UI/UX的重要性，以提升整体用户满意度和系统功能。
- en: The significance of enabling transaction search by multiple criteria was highlighted
    in addressing customer complaints effectively and ensuring better UX.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有效解决客户投诉并确保更好的用户体验中，通过多个标准启用交易搜索的重要性得到了强调。
- en: Stakeholder requests for audit capabilities emphasized the value of tracking
    dashboard interactions for understanding user engagement and planning future system
    improvements.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利益相关者对审计功能的需求强调了跟踪仪表板交互以了解用户参与度和规划未来系统改进的价值。
- en: We focused on the importance of Agile sprint planning, including defining clear
    user stories and acceptance criteria to ensure alignment and successful delivery
    of sprint goals.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们关注了敏捷冲刺计划的重要性，包括定义清晰的用户故事和验收标准，以确保对齐和成功交付冲刺目标。
- en: Gantt charts are effective in visualizing project timelines, aiding in stakeholder
    communication and expectation management.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gantt图在可视化项目时间线方面非常有效，有助于利益相关者的沟通和期望管理。
- en: The requirement for robust search capabilities in large datasets underscores
    the need for an efficient search API, which prompted us to explore UI changes
    and real-time search methods.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型数据集中对强大搜索功能的需求强调了高效搜索API的必要性，这促使我们探索用户界面更改和实时搜索方法。
- en: Developing BDD tests illustrated the critical role of testing in validating
    new search functionalities, ensuring they meet specified scenarios and user needs.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发BDD测试说明了测试在验证新搜索功能中的关键作用，确保它们满足指定的场景和用户需求。
- en: Implementing a search API involved understanding various approaches for criteria
    handling, highlighting the importance of flexible and user-friendly search functionalities.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施搜索API涉及理解各种处理标准的方法，突出了灵活且用户友好的搜索功能的重要性。
- en: The exploration of logging and auditing emphasized the significance of security
    practices in monitoring API usage and user interactions to ensure safe and accountable
    system behavior.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对日志和审计的探索强调了在监控API使用和用户交互中实施安全实践的重要性，以确保安全和问责制的系统行为。
- en: Designing a database for audit logs reinforced the need to capture detailed
    request information such as user agent and IP address for comprehensive security
    and analysis.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计审计日志数据库强化了捕获详细请求信息（如用户代理和IP地址）的需求，以实现全面的安全和分析。
- en: Using middleware in FastAPI demonstrated how to streamline logging processes,
    which reduces redundant code and enhances code maintainability.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在FastAPI中使用中间件演示了如何简化日志过程，这减少了冗余代码并增强了代码的可维护性。
- en: Integrating an audit log view into the application showed the value of transparency
    and monitoring of system activities to support ongoing improvement and accountability.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将审计日志视图集成到应用程序中，展示了透明度和监控系统活动以支持持续改进和问责制的价值。
