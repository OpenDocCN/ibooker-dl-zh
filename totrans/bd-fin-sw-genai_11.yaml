- en: 9 Searching and auditing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another iteration on our ACH dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding searching capabilities for ACH transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing of user actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In previous chapters, we built the minimum viable product (MVP) and went through
    an iteration where we received feedback and used it to drive the next set of enhancements.
    This chapter continues using the same concepts. With the release of expanded support
    for exceptions and various UI/UX tweaks, we should expect feedback on those features
    and other functionality that users need.
  prefs: []
  type: TYPE_NORMAL
- en: Users would like to be able to search for transactions based on several criteria
    as they need to handle customer complaints about when a transaction was processed.
    In addition, other stakeholders have asked for the ability to audit interactions
    with the dashboard to gauge customer engagement and set up user tracking in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Sprint planning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Agile world, the team needs to prepare for the sprint before starting
    any work. We already have an idea of what needs to be accomplished with this sprint
    but also have to define stories to know exactly what is expected in any given
    story and identify any acceptance criteria that may go along with it. We continue
    to follow the standard format for our stories: `As` `a` `[role],` `I` `[want`
    `to],` `[so` `that]`. For instance, to add search capabilities to our product,
    we may have something similar to `As` `a` `user,` `I` `want` `to` `be` `able`
    `to` `search` `for` `transactions,` `so` `that` `I` `can` `better` `research`
    `customer inquiries` `about` `their` `transactions`. Feel free to practice the
    phrasing for the additional user stories (even if it is just in your head) for
    the remaining tasks we cover in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: We take a moment to visualize the changes using another Gantt chart. Again,
    the chart presents a timeline of our changes, which can be shown to any stakeholders
    interested in the project. In our experience, this is one of the most effective
    means of communicating to stakeholders when the project is going to be complete.
    Often, stakeholders outside our team are not familiar with more Agile ways of
    tracking progress and just want to know when our code will be available. A simple
    Gantt chart gives them an idea of how the work should be progressing. The following
    listing shows the Gantt chart definition in PlantUML.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.1  PlantUML Gantt chart definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Begins the Gantt chart definition'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines days that should be skipped'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Title for our chart'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Defines timeline for searching enhancements; note that long lines can be
    split into multiple lines using the backslash character. Any trailing space after
    the backslash can cause parsing errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Defines timeline for auditing enhancements'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Defines a milestone'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Ends the Gantt chart definition'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 shows the generated Gantt chart. Not only does it provide a roadmap
    for where we are in the development process, but creating the chart helps us start
    thinking about the steps and requirements for any given enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a calendar  Description automatically generated](../Images/CH09_F01_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 Gantt chart showing timeframes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We should now have an idea of the steps we need to take for the various enhancements
    and can get straight to work.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Searching ACH transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which file contained that transaction? When was that transaction loaded? These
    are the types of questions we want to be able to answer with this enhancement.
    Throughout this book, we have focused on Prearranged Payment and Deposit (PPD)
    batches, which contain payments for payroll, utilities, and mortgage payments,
    among the rest. If a customer’s utility payment is not processed correctly, and
    their water/electricity gets turned off, we can be sure we are going to hear about
    it. Of course, that is an extreme case. It is more likely that the customer has
    been alerted by a particular company that their payment was not received, and
    they have to pay late fees. Either way, the customer will not be too happy when
    they call.
  prefs: []
  type: TYPE_NORMAL
- en: We need to look at adding the ability to search our loaded files for both names
    and amounts. This feature will require changes to the UI as we will need to be
    able to enter search information and a new API to support the actual search and
    returning of results. Our immediate concern is the ability to find transactions
    within our limited dataset. In practice, ACH records should be kept for six years
    from the date of the receipt, and with billions of payments moving through the
    ACH network every year, chances are we will have sizeable datasets to search.
    We need to evaluate other mechanisms for searching, in addition to our real-time
    method before this project is ready for production.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1 BDD testing for searching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before putting together a feature to help validate the new (yet to be written)
    search API, we first must create a file we can use with our feature. We can use
    our existing file creation feature (ach_file_creation.feature) and add a new scenario
    to create a file for a specific user with a known amount. While we could search
    within one of the existing files, it is likely cleaner to keep the files associated
    with features separated so that our tests will remain more robust. The following
    listing shows creating a file for customer Sally Saver, with a single dollar transaction,
    which should be more than enough to get us started.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.2  Creating a file for Sally Saver
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With our file created, we can now work on setting up our BDD test to search
    for transactions. This should provide us with some insights into how we want the
    process to work in general. For instance, we know that we want to be able to search
    by at least the individual name and an amount. A couple of questions that should
    be up for discussion with various stakeholders in our project may be along the
    lines of
  prefs: []
  type: TYPE_NORMAL
- en: Are we going to separate these searches out on the API side (e.g., allowing
    query parameters of `customer` and `amount`)? Or will we allow one search field
    and have the backend try to query the correct field?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are fields mutually exclusive? If we are searching for a customer, can we also
    search for an account?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we allow searching using multiple fields, will these be combined using AND
    or OR? Should that be determined by the user?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asking those questions (and the answers to them) will help guide our design
    process. For now, we will take the approach where a user will be shown a single
    search box that will support any searches we want to perform. We will also put
    the responsibility of deciding what the user wants to search for on the server
    side instead of on the UI. Another approach would be to have the UI split the
    fields and allow the API to accept different query parameters. With an approach
    to our search in mind, we can create a scenario to test our API search using a
    customer name.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.3  Search by individual name
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There was a need to add new syntax for the `When` and `Then` clauses to support
    our transaction search. The code is shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.4  Updates to test_file_api.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Ensures the new scenario is loaded'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Annotates the method with @when and parses the line'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines a function to call our method and saves the response'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Annotates the method with @then and parses the line'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Defines a function to validate the results of the API response'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the supporting code behind the test, what should we expect
    to see if we were to run it? That’s right—a `404 error` will be returned! That
    is to be expected because we have not yet defined the endpoint. In the next section,
    we will address this problem by adding the API.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2 Search API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we want to have an API that takes some input from the user and
    then searches the database for a transaction. As previously mentioned, we are
    only going to search for individual names and amounts. We expect the API to be
    called with a single query parameter named `criteria`. The API will determine
    whether the argument is applicable to an individual name or an amount.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only approach that we could have taken. We could also have split
    the search criteria into separate fields that would make the server side a bit
    easier but may have made searching more cumbersome from the user’s perspective.
    Another method would be to blend specifying search criteria with keywords (e.g.,
    allowing for searches such as `individual` `name` `=` `"user"` `and` `amount`
    `=` `$1.00`). Then we would have more parsing to do to get the fields we want
    to use. Another consideration is whether we want to use `GET` or `POST`. As mentioned,
    our example uses `GET`, and we pass a query parameter, which is what we will be
    searching for. This approach works, but the URL with the query parameters may
    appear on the web server, firewall, application, and third-party logs. If we enable
    searching for potentially sensitive information, such as account and tax identification
    numbers, we may want to reconsider this approach since we do not want such sensitive
    information showing in logs. There is no wrong answer—depending on our audience
    and what we expect to be searching, we may be told to go with a specific approach.
  prefs: []
  type: TYPE_NORMAL
- en: We first build a simple endpoint to work past the `404` `HTTP` status code being
    currently returned. The following listing shows the initial implementation of
    the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.5  Initial endpoint definition for searches
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a GET request with supporting documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the method specifying the query parameter'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns a hardcoded array entry containing the query parameter'
  prefs: []
  type: TYPE_NORMAL
- en: While this code may get us past the `404 error`, it does not do much to help
    us create a useful endpoint. For that, we need to build both the SQL queries and
    response objects to return the data. We start by creating a `TransactionSearchResponse`
    class to hold our data. The following listing shows the `TransactionSearchResponse`
    and the expected fields. If we find that we are missing something, we can always
    come back and add it.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.6  The `TransactionSearchResponse` class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Our standard import statements for Pydantic fields'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the class using the BaseModel from Pydantic as the base'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines the various fields and constraints for our class'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Provides an example of the response object for use with our documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Provides an example of the response object for use with our documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a place to store our response, we need to populate it. We
    do this by using a new class called `TransactionSearchSql`, which will store any
    code dealing with transaction search. We wanted to keep things simple with our
    first search attempt, so we handle the following three scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching by a single amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching by an amount range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching by an individual name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a method called `get_transactions`, as shown in the following listing.
    Here, we have two regular expressions to determine whether an amount was passed
    or a range of amounts was used. Otherwise, we default to using the name. For most
    people, the trickiest part of the code is likely to be the use of regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.7  The `get_transaction` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a function that returns a list of transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 A pattern to match a single amount'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 A pattern to match two amounts'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Checks the criteria against a single amount and calls the appropriate method'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Uses the walrus operator to store the match results for the multiple_amounts_pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Retrieves the amounts using the groups() method from match'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Calls the method with the retrieved arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Otherwise, no amounts matched, and we should use the individual name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, let’s break down the regular expressions to ensure you understand
    their usage. Here are the important points:'
  prefs: []
  type: TYPE_NORMAL
- en: Each pattern string is prefixed by `r` to denote a raw string, which prevents
    us from having to escape any strings. Otherwise, we would have to use `\\` instead
    of `\`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The characters `^` and `$` are input boundary assertions, indicating the start
    and end of the string, respectively. These help us eliminate matching strings
    that contain characters other than the pattern we are interested in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `\d` matches any digit (0–9), and `+` is a quantifier that means to match
    one or more occurrences of the preceding atom (the most basic unit of a regular
    expression).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `\.` matches the literal period character because a single period will otherwise
    match any character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `\d` matches any digit (0–9), and adding the `{2}` is another quantifier
    that specifies the count of atoms to match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `\s` matches any whitespace. Again, we see the plus sign quantifier, which
    allows the two amounts to be separated by at least one character and up to any
    amount of whitespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping a portion of the regular expression in parentheses creates a capture
    group. These groups can then be referenced later, as you’ll see when we use `match.groups()`
    to extract the found values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions are not limited to the financial industry, and you will
    find them throughout your career. While they can be difficult to grasp, generative
    AI tools are a great way to help break down regular expressions and provide more
    insight into them. Practice makes perfect, and to get more hands-on experience
    with regular expressions, you may want to check out *Regular Expression Puzzles
    and AI Coding Assistant*s (2023, Manning) by David Mertz.
  prefs: []
  type: TYPE_NORMAL
- en: With that behind us, let’s take a look at the functions that are actually retrieving
    the transactions based on the search criteria provided. In our cases, the queries
    themselves remain much the same with only the `Where` clauses being unique for
    each query. The following listing shows the `_get_transactions_using_amount` function
    that looks for an exact amount and returns any results.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.8  Retrieving transactions by amount
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We declare that the row will be of type TransactionSearchResponse.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The standard columns that we are trying to select'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Appends the Where clause for the query'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Uses the criteria that we want to pass to the query'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Gets all rows and returns the response'
  prefs: []
  type: TYPE_NORMAL
- en: We have factored out the common portion of the SQL query into the `get_sql_selection_query`
    method, which allows the `Where` clause to be added to the query. When searching
    for transactions by amount, we used an exact match. When using a range of amounts,
    we employ the Postgres syntax and use the keyword `BETWEEN`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.9  Using the `BETWEEN` keyword
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses BETWEEN to search between two amounts; often more concise and readable
    than multiple conditions'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when searching for an individual name, we use the `ILIKE` keyword,
    as shown in listing 9.10\. Using `ILIKE` allows us to do a case-insensitive search—otherwise,
    we are searching for the same string. Note that ILIKE is a Postgres-specific command.
    Other databases such as MySQL use the `LIKE` keyword, but it is case-insensitive
    by default. Still, other databases such as Oracle are case-sensitive and require
    the `UPPER` function in the comparison to achieve a case-insensitive search. So,
    always be aware of the database you are using.
  prefs: []
  type: TYPE_NORMAL
- en: We may consider appending a percentage sign (`%)` to the criteria, which is
    a SQL wildcard and would match the individual name if anything appeared after
    it. Or perhaps we could replace any spaces found in the string with the wildcard
    to expand our search results. Those are just some basic starting points if additional
    search capabilities are required.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.10  Case-insensitive search
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Use ILIKE for a case-insensitive search of the individual name.'
  prefs: []
  type: TYPE_NORMAL
- en: The following listing shows the common portion of the query that retrieves the
    transaction information. In addition to the need of joining records together to
    drill down to transaction details, we rename the fields to ensure they can be
    stored in our response object.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.11  Common transaction query selection criteria
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The selection criteria required for our object. The fields are prefixed
    to help determine the files they belong to. It is not always necessary when the
    names are unique but is helpful for maintaining the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Joining of the various records'
  prefs: []
  type: TYPE_NORMAL
- en: With the queries working and returning our data, we should now see that all
    our tests have passed. Next, we look at how to add the search capability to our
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.3 UI search page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add search functionality to our page, we start by adding an icon to our sidebar
    navigation. This means we can update NavButtons.tsx to add a new button with an
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.12  Updating NavButtons.tsx
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports the search icon'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Includes the search icon'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if we try clicking the button, we receive a `404` `NOT` `FOUND` error
    message because we have yet to define our actual page. As with previous pages,
    we will create a simple page that will allow us to resolve the `404` error message
    and give us a starting point for developing the rest of the page. The following
    listing shows the src/app/search/page.tsx.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.13  Search page stub
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a simple search page'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Something to identify the page so we know we navigated to it'
  prefs: []
  type: TYPE_NORMAL
- en: With our page stubbed out, we can click the search button, and we should see
    our navigation and search page. Now, we can add the components that will give
    us the necessary functionality to create a search page capable of displaying our
    results. The hardest part is deciding how to layout the page. From previous API
    calls (such as returning exceptions in chapter 8), we already know how to fetch
    data from an API and display it within a DataGrid component. We will be following
    the same steps of defining an object to hold the data, a component to display
    the data, and then adding that to our search page.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining an interface `AchTransactionSearchResponse` to hold the
    data that the API response will pass back. The following listing shows the fields
    and their data types.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.14  The `AchTransactionSearchResponse` interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Exports the AchTransactionSearchResponse so that it is available everywhere'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The fields returned from the API'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a place to hold the retrieved data, we can create a component that
    will display the data. This `AchTransactionSearchResults` component will be similar
    to other components we have created, where we pass the results of our API call
    into the component via the results object of `AchTransactionSearchResultsProps`.
    We utilize the `renderCell` property on the column definitions to add links that
    allow users to jump directly to the file or batch of a particular search result.
    Furthermore, since our results did not have an ID column, we have to define one
    to the DataGrid component using the `getRowId` property. The `entry_id` can act
    as our ID column because for each result, the `entry_id` is the UUID for the transaction,
    and that is unique. The following listing shows the more important parts of the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.15  The `AchTransactionSearchResults` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Exports the search results function and declares the parameters read only'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses the router for navigation purposes'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Begins defining columns to show'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Defines a column that will create a link, which will navigate to the file
    details page when clicked'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Defines a column that will create a link, which will navigate to the batch
    details page when clicked'
  prefs: []
  type: TYPE_NORMAL
- en: '#6'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Since there is no specific parameter named id, we specify which field can
    be used.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a place to store the data and a way to present them, all that
    is left is to make the API call and pass it to our component. For that, we updated
    our search page to have a text input field and a search button to make the actual
    API call. We use the `onChange` event of the `TextField` to store the text entered
    by the user into the `searchCriteria` field. When the user clicks the search button,
    the `onClick` event is fired, and the `handleSearch` is executed. The `handleSearch`
    makes a call to our API and stores the result. The important pieces of the updated
    search page are shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.16  Updated search page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Initializes the searchCriteria to an empty string'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Initializes the results to an empty string'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The handleChange function saves the entered text to be used later.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The handleSearch function calls the API and saves the results using setResults.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Uses axios to get the response'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Defines a TextField element for a user to enter a search string'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Defines a button element that will search for the entered string'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 A component that takes the results to display them'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a search page that can perform basic transaction searches and provides
    the ability to jump directly to the file or batch where the transactions were
    found. Next, we reinforce testing with Playwright to get some integration-level
    tests for our search capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.4 Integration testing with Playwright
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we make searching for our transaction possible, it would be nice to add
    an integration test that we can use for integration and regression testing. We
    set up a test that requires us to
  prefs: []
  type: TYPE_NORMAL
- en: Upload a file to parse
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the search page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the search page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for an ACH response
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the result is populated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a screenshot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a Python script named test_search_page.py to perform all these necessary
    steps. In addition, we want to have the option to debug our test with the browser
    window displayed; to accomplish that, we need to create a few Pytest fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.17  Pytest fixtures for Playwright
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a fixture with the scope session, which will cause the fixture to
    persist for the length of the test session'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines a function named browser that creates a browser instance. We use
    headless=False to step through the test session and see what the browser is doing.
    Using headless=True will hide the browser window and is the default way of running
    unit tests.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The yield browser command will return the browser object.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 When all tests are finished, the browser is closed.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Defines a fixture with the scope of function, which is the default scope'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Creates a page that will be used with the test'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Uses the default tab if it exists; otherwise, creates a new one'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Returns the page using yield, so it is available to the test'
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Clears the context after the test is run'
  prefs: []
  type: TYPE_NORMAL
- en: That is enough to get the Playwright structure set up. Now, we want to ensure
    our database is empty and that we load our ACH file before starting our integration
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.18  Clearing the database and loading our file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Define a fixture with autouse set to True. This causes it to be included
    for every test by default.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Clears our database'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Loads a file for the test into the database'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Ensures the path is correct based on where we are running from'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the setup is done, we can start the actual testing with Playwright.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.19  Playwright testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Navigates to the search screen and ensures the page is loaded'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Validates that we are on the correct page'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Finds the textbox and enters the text “sally saver”'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Finds the search button'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Expects an API response from the search button when it is clicked'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Checks that the response was 200'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 We should be able to see an entry with the text “Sally Saver.”'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Takes a screenshot for posterity'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know how to perform some integration testing where you may need to
    make API calls and validate the results. In the next section, we look at another
    critical aspect of development in many industries: keeping an audit trail.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Auditing user interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the critical security controls put forth by The Center for Internet Security
    is that of audit log management ([https://mng.bz/gaGE](https://mng.bz/gaGE)).
    While we won’t be covering all the aspects, we will at least begin the journey
    by ensuring that we are collecting data about the usage of our application. Keep
    in mind that collecting data is the first step. If we do not have a strategy to
    monitor, review, and receive alerts as necessary, the logs are useless.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, we have worked on a problem where we were put on the wrong path
    initially because someone had identified an error occurring in a log. Further
    research showed that the error had been occurring for many months (as far back
    as logs were readily available) and was not the source of the current problem.
    Sometimes, in the heat of a production incident, you can easily fall into that
    type of trap because of the need to resolve the problem quickly. With proper audit
    log management, you can gain a better understanding of the baseline application
    behavior and monitor for application misuse, among many other benefits.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many commercial off-the-shelf tools (COTS) such as Splunk, Dynatrace,
    DataDog, and Sentry that help with logging and observability, we focus primarily
    on logging our data into the database and growing from there if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1 Database design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to get started with auditing, we need to create a new database table
    to store our data. It will be based on the needs of your application and on what
    you are trying to accomplish. In our case, we are going to keep track of the API
    requests coming into the system. We introduce a new data type for dealing with
    hosts and networks—the `INET` data type for the `ip_address` field. While using
    a string data type for `ip_address` would certainly work as well, there are additional
    comparisons and functions in Postgres for dealing with `INET` that can make life
    easier. For instance, we could search for all addresses in a given range by using
    `WHERE ip_address` `<<` `'192.168.1.0/24'`. This search may be helpful if we wanted
    to see activity coming from a list of addresses that we suspect of abusing our
    application. The following listing shows the creation of the table.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.20  The `audit_log` table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a table named audit_log'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Saves when the record has been created using a TIMESTAMP datatype. We also
    use NOT NULL so that the field must always be populated. Finally, we default to
    using the NOW() function in Postgres, which will populate the field with the current
    date/time when records are inserted without a value.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a field named ip_address with the INET data type, which is a handy
    type for network addresses'
  prefs: []
  type: TYPE_NORMAL
- en: With the table in place, we can create the code necessary to write these audit
    records out.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2 TDD testing for auditing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We create the unit tests for our API first and then add the required code to
    make our tests pass. Should we also consider the BDD-style testing? The answer
    to that depends on how the business will choose to use the audit log. If the log
    will serve primarily as something that developers use, then the business will
    likely not need to work with us to develop tests. In contrast, if the business
    plans to use the audit log to pull the activity to help determine metrics, we
    may need to work with them to develop tests. We could easily see the business
    making that type of request and the need to update our tests to read something
    along the lines of `WHEN` `I` `REQUEST` `A` `LIST` `OF` `FILES` `THEN` `I` `SHOULD`
    `SEE AN` `AUDIT` `LOG` `RECORD` `INDICATING` `FILES` `WERE` `SHOWN`. For now,
    we will stick with our standard unit testing. The unit test defines a record and
    then retrieves it so that we can compare the fields. We currently have a field
    for `user_id`, but since we are not tracking users at the moment, we will leave
    it empty.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.21  Unit test for the audit log
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Clears the database each time'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates a dummy record'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses the AuditLog class to create and retrieve a record'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Excludes the specified fields from the dictionary as these are populated
    by the database and do not affect the comparison; then asserts the record match'
  prefs: []
  type: TYPE_NORMAL
- en: The unit test requires an object for `AuditLogRecord`, which is a standard Pydantic
    model to hold our data. We use two new data types in this model—`IPvAnyNetwork`
    and `AnyUrl` (both available as imports from Pydantic). The `IPvAnyNetwork` works
    well for representing the `INET` field we defined in the table and provides validation
    as expected for IP addresses, regardless of whether they are defined as a single
    address (e.g., `127.0.0.1`) or a range of them (e.g., `192.168.1.0/24`). Of course,
    we would not expect to see a range of addresses in this field for an audit record.
    The `AnyUrl` field similarly provides validation of URLs, saving us from having
    to write regular expressions to validate the field. Listing 9.22 shows our `AuditLogRecord`
    class, with some less interesting fields removed for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.22  The `AuditLogRecord` class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines the ip_address as a type of IPvAnyNetwork, which allows Pydantic
    to validate IP addresses and networks'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the URL as a type of AnyUrl, which allows Pydantic to validate whether
    the URL is properly formatted'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines a field validator so that the URL is converted to a string to be
    stored in the database'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in listing 9.22, we also use a field validator to return the URL field
    as a string. This is because we will receive an error when attempting to insert
    it into the database because the URL datatype is not compatible with a string.
    We could have explicitly coded for it in the audit log class responsible for inserting
    the record, but this approach wraps up everything nicely, and other developers
    do not have to worry about it, which helps reduce cognitive load.
  prefs: []
  type: TYPE_NORMAL
- en: The final step of being able to write records and get this unit test to pass
    is generating an actual class to be inserted into the database. In the following
    listing, we create an `AuditLog` class that contains a `log_record` and `get_log_record`
    methods. For other database records, we specifically used `Sql` as part of the
    name. In this case, we did not necessarily want to tie it to a database.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.23  The `AuditLog` class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a dictonary to use'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the fields to insert; we will return the audit_log_id we obtained
    from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Because we used a dict_row for row_factory, we can reference the audit_log_id
    directly.'
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, our unit test is passing, and we can add audit records wherever
    we want. Now, let’s see how to integrate what we know with the FastAPI framework.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.3 Auditing logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most obvious way to add auditing to our application is by making a call
    to the `log_record` method and passing an `AuditLogRecord`, as seen from our unit
    test. We could certainly take one of our existing endpoints and add the call into
    it, ending up with something akin to the following listing, which allows us to
    write a message but does not capture some of the other potentially useful information
    we defined fields for.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.24  One way to add logging of our API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Manually calls the log_record method whenever the API is executed, but we
    are missing many of the interesting fields'
  prefs: []
  type: TYPE_NORMAL
- en: We could enhance the previous listing by including the request field. Then we
    can pull the additional information from the request object.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.25  Including request information in our API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Updates the method to include the Request object'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We now have access to some of the interesting fields'
  prefs: []
  type: TYPE_NORMAL
- en: While that works, it requires the developers to add more boilerplate logic than
    we would prefer. Since we are primarily interested in auditing the usage of our
    APIs, we can take another approach.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Using middleware for our logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the goal of logging the API requests, we can look at adding a middleware
    function that has the sole purpose of logging our requests. We can employ both
    the request and response, which allows us to capture the response code as well.
    While we could also look at configuring our Nginx logs to capture the information
    in the production environment, seeing how to accomplish this in FastAPI is also
    helpful since it can be widely applied for other requirements. We use the `@app.middleware`
    notation to write our log record.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.26  The middleware layer for logging
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a middleware component that executes for every HTTP request'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines a method to log requests'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Passes the request on to the next layer'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Gets the log_message that was defined in the request.state and defaults
    if not present'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Builds an AuditLogRecord with our desired request fields'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Writes the log messages'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Returns the response'
  prefs: []
  type: TYPE_NORMAL
- en: It is relatively easy to insert that middleware layer and have it perform the
    logging. Then we can log all the calls that are coming in, which removes the need
    for the boilerplate code. Moreover, it keeps our code cleaner and lets the developers
    focus on their code. The only drawback is that adding a message would take a little
    more effort. Of course, the message is going to reflect what the `REST` `API`
    call is doing. So, in some respect, it is redundant (and a waste of space) to
    log a message. For instance, do we need to know someone viewed ACH files when
    the log also shows that they were performing a `GET` on `/api/v1/files`? Of course,
    we may need to do it for business reasons because it is easier for people unfamiliar
    with the data to interpret the message when being reviewed. Rather than waste
    the storage, we may decide to have a utility method that could perform that interpretation
    and insert the appropriate message during an extract. The use cases could vary,
    of course, and we only want to illustrate some of the alternatives. In this case,
    we do want to store the text in the database table, and we are going to accomplish
    that using a decorator. The following listing shows how to include a message in
    the request state using a `log_message` annotation we defined.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.27  The `log_message` annotation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#1 If we have a request, it saves the message that was passed.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we only need to make some minor changes to the API. By using our new
    annotation, we can customize the message written to the database. The next listing
    shows the final changes to our API call.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.28  Final changes for logging
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Annotates each of our API calls with a unique message'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures the request object is part of the method'
  prefs: []
  type: TYPE_NORMAL
- en: Adding that little bit of logic completes the logging of our API messages. Now,
    log messages are written out for any APIs we annotate with `@log_message`. This
    is just the beginning of tracing and auditing your application. You can vastly
    expand collecting data in your application by exploring projects such as OpenTelemetry,
    OpenTracing, or Prometheus, to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Viewing the audit log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the application logging API requests, let’s add the ability
    to view the log in our application. This page will function in much the same way
    the exceptions page from chapter 8 did. We need to retrieve the audit records
    and place them in a DataGrid to be viewed. Of course, we can expand the functionality
    as needed, but for now, simply returning the data is all that we need to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.1 Creating the page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We create the page.tsx under `src/app/audit`. This page will be responsible
    for making a request to the API and then passing the returned data down to a component
    that can display the records. The following listing shows the basic page.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.29  Audit page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Gets the audit records from the database'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Displays the audit records'
  prefs: []
  type: TYPE_NORMAL
- en: To finish this page, we also want to create the `AuditResponse` interface, as
    shown in listing 9.30\. We keep the names aligned with those from the API because
    there is less work for us. However, in previous chapters, we have shown the process
    of mapping fields to internal representations of the data, and that is still valid
    here. Keep in mind the tradeoffs we incur by exactly matching the API—the biggest
    problem being when the API changes or when we move to another vendor where the
    field names may change. These changes must be propagated throughout the application
    instead of at a single point. We recommend always trying to use a layer of abstraction
    to prevent these types of problems. Nobody wants to spend their time changing
    `created_at` to `created_on` and having to retest everywhere it may touch.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.30  The `AuditResponse` interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 9.5.2 Creating the page components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We pass the data down to our `AuditLogRecords` component so that the presentation
    logic is taken care of. At this point, we should hopefully see how components
    help break our code apart into smaller, more manageable pieces. We try to keep
    the pages responsible for retrieving the data, while components on the page are
    responsible for presenting that data. We tend to have more duplicated code when
    applications are first being developed. This is often due to developers trying
    to rush to meet deadlines. As the code matures (and the developers get a better
    sense of the application), we can often start to create more generalized code.
    Breaking down our code into components helps us get to that point quicker. The
    next listing shows the code for the presentation of an audit record.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.31  The A`uditLogRecords` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a field to keep track of the modal'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the contents of the audit details for the modal'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 When the button is clicked, passes information to the modal and sets that
    it is now open'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Uses the DataGrid element to display the text'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Includes the AuditModal component to display the detailed contents'
  prefs: []
  type: TYPE_NORMAL
- en: There is an extra utility method we have also built as part of the component—the
    `stripSubnet` method. The code for this method is shown in the following listing.
    Note it only removes a trailing `/32`, so why do we have a function to remove
    it, and why exactly is it there?
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.32  The `stripSubnet` utility method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Splits the IP address on the slash'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 If the subnet is 32, that indicates a single IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns the IP only when it is a single IP address'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Otherwise, returns the string as it came through'
  prefs: []
  type: TYPE_NORMAL
- en: The `/32` is part of the Classless Inter-Domain Routing (CIDR) notation, which
    is a way to define IP address ranges. The `/32` means that the given address is
    a single address, and it is just an explicit way to indicate that. To illustrate,
    we could represent the addresses between `192.168.1.0` and `192.168.1.255` with
    `192.168.1.0/24`. That explains what the `/32` is but not why it is there. We
    are seeing the `/32` because we chose to represent the IP address in our Pydantic
    model with `IPvAnyNetwork`.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic supports many network types. The ones that we are primarily concerned
    with at this point are `IPvAnyAddress` and `IPvAnyNetwork`. The decision to use
    `INET` for our `ip_address` column was the catalyst for the problem. The `INET`
    datatype supports storing IP addresses using the CIDR notation. For that reason,
    we chose to use a datatype in Pydantic that closely modeled that functionality,
    even though we should only have a single IP address in our table. We used this
    example to illustrate how design decisions can have a downstream effect. The `INET`
    requirement for the column may be set because there is a need to be able to query
    for ranges of IP addresses, and having an `INET` data type makes sense even though
    there is no business need for the audit record to contain more than a single IP
    address. Perhaps, the decisions were already made (for better or worse) by the
    time the UI piece lands on our plate. The business does not want users to see
    the `/32` as part of the IP address because most users will not understand the
    notation, so we need to correct the display.
  prefs: []
  type: TYPE_NORMAL
- en: The following listing shows some additional unit tests that help illustrate
    the difference between the Pydantic types of `IPvAnyAddress` and `IPvAnyNetwork`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.33  Unit testing of the network types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Another custom component we make use of is `AuditModal`. When the details of
    an audit record are clicked, we want to display a formatted window with the audit
    information (listing 9.34). This is meant to be a more complete view of the audit
    record, so we do not need to clutter up the initial view. `AuditModal` is a relatively
    straightforward component. As we already have the entire record returned, this
    is just a presentation of the data, as opposed to the previous chapter where we
    specifically retrieved the ACH record data when the user clicked the view icon.
    Remember, the difference was that we did not want to return possible NPI data
    unless the user requested it. Now we have the ability to view audit information,
    monitor for users requesting NPI data, and address any potential misuse (whether
    intentional or not) of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.34  The `AuditRecords` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Clickable button that displays detailed information on the audit record'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Clickable button that displays detailed information on the audit record'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 DataGrid element that displays all the audit record results'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 AuditModal component that displays when the icon is clicked'
  prefs: []
  type: TYPE_NORMAL
- en: With the ability to pull and view audit data, we are missing one critical piece
    to our puzzle—let’s add the API endpoint to retrieve our data.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.3 Adding the APIs for the audit log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we built the initial SQL calls that retrieved records and the UI layers
    to display the data, we have not built the API itself yet. We now need to ensure
    we can call the API and return the data. The following listing shows that all
    it takes is a few lines to accomplish this task, and most of those are helping
    document the API for others to use. We created the audit API in its own file named
    routers/audit.py. Because this endpoint has nothing to do with ACH files, we wanted
    to separate it.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.35  Audit router
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Simple call to get and return all audit records'
  prefs: []
  type: TYPE_NORMAL
- en: Since we separated our code for easier maintenance, the API will not be reachable
    until we add it using an `include_router` method. We had initially done this for
    the router/files.py file, and all our APIs up until this point have been put into
    that file, meaning there has been no need to revisit the main.py file until now.
    The next listing shows the additional line needed to access our API.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.36  Adding the router
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The additional router to handle the audit API requests'
  prefs: []
  type: TYPE_NORMAL
- en: That was the final piece to put into place. Now we should have fully functioning
    audit capabilities. We can expand on this with additional logging and more specific
    logging of business scenarios, such as invalid input and other scenarios where
    we may want to log more than just confirmation that an API was accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each successive iteration helps improve the functionality of our application.
    We looked to address requests/concerns brought up by the end-users, new functionality
    required by the business, and technical debt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to search is a necessary feature of our application. Transactions
    are loaded at various times through different files throughout the day. If a customer
    has a question about when a transaction was loaded, we need to be able to provide
    an answer quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether we are working toward protecting our application from intruders or disgruntled
    employees to gain deeper insight into the application, it all starts with proper
    auditing for security and compliance, accompanied by general analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We touched on the importance of not just logging but also of how having a successful
    strategy for managing logs will play a part in our success. We should not trust
    that the application is working or not being attacked—instead, we must have the
    data and analyze it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You were shown the importance of expanding exception handling and enhancing
    UI/UX based on user feedback to improve overall user satisfaction and system functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The significance of enabling transaction search by multiple criteria was highlighted
    in addressing customer complaints effectively and ensuring better UX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stakeholder requests for audit capabilities emphasized the value of tracking
    dashboard interactions for understanding user engagement and planning future system
    improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We focused on the importance of Agile sprint planning, including defining clear
    user stories and acceptance criteria to ensure alignment and successful delivery
    of sprint goals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gantt charts are effective in visualizing project timelines, aiding in stakeholder
    communication and expectation management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The requirement for robust search capabilities in large datasets underscores
    the need for an efficient search API, which prompted us to explore UI changes
    and real-time search methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing BDD tests illustrated the critical role of testing in validating
    new search functionalities, ensuring they meet specified scenarios and user needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a search API involved understanding various approaches for criteria
    handling, highlighting the importance of flexible and user-friendly search functionalities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exploration of logging and auditing emphasized the significance of security
    practices in monitoring API usage and user interactions to ensure safe and accountable
    system behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a database for audit logs reinforced the need to capture detailed
    request information such as user agent and IP address for comprehensive security
    and analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using middleware in FastAPI demonstrated how to streamline logging processes,
    which reduces redundant code and enhances code maintainability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating an audit log view into the application showed the value of transparency
    and monitoring of system activities to support ongoing improvement and accountability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
