- en: Chapter 5\. Testing with Copilot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand how Copilot works and how to interact with it through
    the editor and chat interfaces, we can move on to other ways it increases productivity.
    Copilot simplifies routine tasks that can consume a lot of time and resources.
    Automating such work allows you to devote your cycles, thinking, and focus to
    the more complex tasks needed to create software.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter focuses on one particular capability: using Copilot to generate
    tests. In the following sections, you’ll see how Copilot can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide guidance on testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create standard test cases for unit testing and integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build out edge cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize custom testing instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write tests using the framework of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help implement best practices, like [test-driven development](https://oreil.ly/-nm1N)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Copilot’s Agent mode to help drive test creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generative AI and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When generating tests, Copilot’s results may vary significantly in content,
    suitability, and even accuracy. This usually depends on the amount of context
    provided, the interface, and the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Per the nature of generative AI, nothing is guaranteed to be exactly as you
    want. So, it is important to review the suggested tests to ensure that they are
    valid and a good fit. If they’re not what you expected, you may need to edit them
    or refactor your prompt and try again.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you’ll have a solid framework for harnessing this
    capability. Using that, you’ll be able to leverage Copilot in multiple ways to
    help ensure that you have the testing coverage you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by asking Copilot the broadest question about testing: “How do
    I test my code?”'
  prefs: []
  type: TYPE_NORMAL
- en: How Do I Test?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to quickly pivot and learn new programming languages and frameworks
    is a standard expectation for most software professionals. You’re likely already
    comfortable with how to write tests for any language you’ve been using regularly.
    But having to switch or migrate code to a different environment can pose a substantial
    learning curve. As discussed previously, one of the Copilot features that is helpful
    here is the ability to ask how to write or translate code in the new language.
    The same can be done for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Have Code Active Before Prompt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the prompts and queries we’re covering in this chapter, the best results
    will usually occur when you have one or more files that are part of your project
    open and active in the editor. If you don’t have any files active, Copilot may
    fall back to telling you how to do things in more general terms for your project’s
    type, rather than giving you specifics for your project’s content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use a project for a Kubernetes Operator written in Go as our example
    here. Suppose you are new to Go and have little or no idea how to test the code
    you’ve just produced. You could do research on [Stack Overflow](https://stackoverflow.com)
    or any other number of forums or sites, or ask colleagues. But you can also ask
    Copilot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: More Specific Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to be more specific about the part of your project that you want
    to test, you can include the file name in the prompt, use a chat variable, or
    add items as context as discussed in [Chapter 3](ch03.html#ch03). Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Copilot first analyzes the project. Then, since your prompt is general, Copilot
    tells you how to create an example test for the project. It uses the *chat participant*
    and *slash command* default of `@workspace /setupTests` to produce the basic info.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot provides a summary of its suggestions along with buttons to make changes
    and take actions. See [Figure 5-1](#initial-suggestions-f).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Initial suggestions for adding tests
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the same response, Copilot also provides an explanation for the suggestions
    along with a terminal command to run the test ([Figure 5-2](#further-explanation-o)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Further explanation on adding tests
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you click the Apply Changes button (shown in [Figure 5-1](#initial-suggestions-f)),
    the file will be created for you, as shown in the left part of [Figure 5-3](#file-created-via-appl).
    Note that Copilot’s response also includes information on how to run your tests.
    This is pretty impressive for one general query!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. A file created via the Apply Changes button
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The intent of `/setupTests` is to do macro-level setup of testing code and
    related changes. At the time of this writing, this feature is still experimental,
    and you may find its usefulness varies depending on the situation. Likewise, having
    Copilot default to using the `@workspace` chat participant does not always yield
    the best results. You may see better results not using these defaults when initially
    generating tests. The result of using the “rerun without” option on the previous
    query provides a more comprehensive set of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide on a testing framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the testing framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a test directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write test files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write test cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automate testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Included with these is text that describes in more detail what to do along with
    sample code. [Figure 5-4](#example-output-from-u) shows an excerpt from the results
    of using “rerun without.”
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Example output from using the “rerun without” option
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Options for working around `/setupTests` are discussed in the following sidebar.
    The same types of options can be utilized for working around other default commands
    being added.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an additional example, let’s tackle something less familiar to most: testing
    SQL code. I have a large demo file of SQL statements that I use for some of my
    training courses, which creates tables to populate a database for a university
    curriculum, schedule, faculty, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: If I open that file in the editor and ask Copilot how to test its content, Copilot
    replies as shown in [Figure 5-8](#initial-sql-test-resp). It generates a step-by-step
    plan for the testing and then creates a new file that implements the plan (shown
    on the left). The proposed new file contains SQL commands that can be used for
    doing 10 tests with a test database.
  prefs: []
  type: TYPE_NORMAL
- en: This file can then be reviewed and saved as your new tests. Copilot uses `/tests`
    to quickly generate this output. However, if you don’t want to use the quick version,
    you can use any of the strategies we discussed previously for “rerun without”
    to execute the prompt again without using the shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Initial SQL test response
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Again, this is pretty impressive for a simple query against one file. And note
    that this will work for any language, not just Python.
  prefs: []
  type: TYPE_NORMAL
- en: Trusting Generated Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we’re still early in the discussion about having Copilot generate tests,
    it’s important to remember to review them just as you would any other generated
    content. Tests generated by AI may include false positives, duplicate assertions,
    and incorrect logic based on misinterpreting the code. Fortunately, test code
    is generally easy to read, which can make it easier to quickly review and verify.
  prefs: []
  type: TYPE_NORMAL
- en: This section has shown you how to utilize Copilot to create instructions and
    code for testing when you need to start from scratch. More commonly, you may be
    coding in a language you already know and just want Copilot to help create the
    *boilerplate* code for tasks like unit testing. In the next section, you’ll see
    several ways to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the necessity of creating tests for cases like continuous integration
    and test-driven development, manually crafting tests can represent a significant
    portion of your time and workload on a project. With Copilot, you can automate
    test generation by using several approaches. And you can choose from varying degrees
    of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, the tests you generate with Copilot will be unit tests, designed
    to perform basic testing for a single function or procedure. However, the range
    and depth of Copilot-generated tests can vary with the prompt and interface used.
    We’ll explore the various approaches in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the /tests Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to have Copilot generate tests for you is using the built-in
    slash command `/tests` inline (in the IDE’s editor). This command operates on
    the code you select or reference in the IDE and then attempts to create basic
    unit tests appropriate to the code. You can enter this command through any of
    the chat interfaces available in the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume you’re again working with a simple function to determine whether a number
    is prime. The implementation doesn’t matter, but here’s one version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 5-9](#invoking-copilot-to-g) shows an example of using the `/tests`
    command via the inline chat. The most straightforward usage is highlighting the
    code to be tested and then entering the command in the chat interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0509.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9\. Invoking Copilot to generate tests via the `/tests` command
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After running that command, Copilot generates assert-based tests for primes,
    nonprimes, one, zero, large primes, and large nonprimes. As [Figure 5-10](#tests-from-inline-cha)
    shows, when going through the inline chat, Copilot proposes the changes as a new
    file in the editor with the corresponding name *test_is_prime.py*. If you like
    the suggested tests, you can click the Accept button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0510.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10\. Tests from the inline chat option
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The same results as running `/tests` in the inline chat interface can be achieved
    by choosing Copilot > Generate Tests from the context menu; see [Figure 5-11](#generating-tests-via).
    In fact, Copilot will want to use the `/tests` shortcut in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0511.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-11\. Generating tests via the context menu
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you run the `/tests` command in the separate chat interface, you’ll likely
    get similar results, but with more of an explanation in the chat area about the
    approach Copilot is going to take, the framework it has chosen, and the type of
    tests it will create.
  prefs: []
  type: TYPE_NORMAL
- en: A new section just above the text entry area shows any files changed. Keep/Undo
    buttons are available for all files. Proposed individual files are shown by their
    first line and have their own controls to keep (the checkmark) and undo (the curved
    left arrow). The control that looks like a document icon with + and - in it is
    used to show the diff introduced by the proposed changes in the editor. [Figure 5-12](#tests-from-tests-com)
    shows a portion of the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0512.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-12\. Tests from the `/tests` command in the main chat
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Changing Icons and Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copilot commonly changes the controls used in their various interfaces and moves
    them around, unfortunately. By the time you are reading this, Copilot has likely
    changed things again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the following hold true across releases for proposed edits:'
  prefs: []
  type: TYPE_NORMAL
- en: There will be controls to accept/keep and reject/undo changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkmarks double as keep controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be a control to see the suggested diffs as a file in the editor or
    apply suggested diffs to a file in the editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diff controls may or may not set up the file with a reasonable name. You
    should always make sure to save your files yourself after reviewing and choosing
    which changes to keep.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These responses cover a basic range of use cases. But what if you want to have
    additional tests generated and/or more cases covered? You can approach that by
    supplying more explicit prompts, the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tests from Explicit Prompts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to create tests is by providing prompts through the chat interface.
    A simple prompt like “Create tests for the selected code” will usually result
    in Copilot running the `/tests` command again (assuming that command is available
    in your IDE). However, you can supply a more directed prompt to have Copilot suggest
    tests for other cases. For example, if you’ve incorporated the tests already generated,
    you can select the current test file and the implementation file as context and
    then prompt Copilot about any other edge cases with a prompt like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Copilot responds by identifying some additional tests cases, along with explanations
    for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Copilot further provides the code that can be added for those test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This might make you wonder whether you can extend the prompt to cover more
    use cases. Indeed, you can! For example, you can be more prescriptive, telling
    Copilot to add test cases for other inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this prompt, Copilot adds additional test cases for your consideration
    and review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A key part of getting the most value-add from Copilot is asking it additional
    questions beyond the scope of what it may generate with default prompts or commands.
    To use our analogy of Copilot as someone new to the team, you may want or need
    to prod them to think beyond the usual test cases about other scenarios. The same
    holds true for prompting Copilot to get more comprehensive results.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer to create some quick tests inline with your code, a variation
    on the prompt approach can easily do that. We’ll look at that option next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tests from Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you may not want (or need) to engage the chat feature to create your
    tests. You may be actively working in your editor *in the flow* and want to do
    the equivalent of telling Copilot, “Insert some simple, quick tests here.” That
    can be done by creating a comment as a directive to Copilot. Then you simply need
    to accept the suggestions for individual tests or testing functions that it returns.
    The process follows the same interactive flow for acceptance, editing, etc., as
    discussed in [Chapter 2](ch02.html#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this method is that you can initiate it from a simple (or complex)
    comment line within the code. The disadvantage is that you may have to repeatedly
    step through accepting parts of suggestions or get generic suggestions that aren’t
    as useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example of a directive comment placed inline after the code
    for the `is_prime` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In response, Copilot suggests an inline function with a set of simple asserts,
    as shown in [Figure 5-13](#simple-set-of-assert). All the lines from 10–23 were
    automatically generated by Copilot in response to the comment on line 9.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0513.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-13\. A simple set of assert test cases generated from the comment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Alternatively, you could use a more generic comment such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Copilot generates similar test cases to the other methods, but
    in the same file. [Figure 5-14](#another-example-of-te) shows an excerpt of the
    generated tests. The only line that was typed in was the first comment. All the
    other lines were generated and accepted based on that one.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0514.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-14\. Another example of tests generated from a comment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, in this section, let’s look at a different way of using Copilot to
    help us test: validating inputs to functions inline.'
  prefs: []
  type: TYPE_NORMAL
- en: Validating Inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As another angle on testing, Copilot can also assist with generating code to
    check that inputs going into a function are valid. With our example function,
    we can tell Copilot to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, Copilot responds and suggests assertions, as requested, to validate
    the inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also be less specific about using asserts and ask Copilot to generate
    checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows Copilot to generate code to validate the inputs, but with a more
    standard coding mechanism to surface any issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]python'
  prefs: []
  type: TYPE_NORMAL
- en: 'def is_prime(num):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not isinstance(num, int):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError("Input must be an integer")
  prefs: []
  type: TYPE_NORMAL
- en: 'if num < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Input must be a non-negative integer")
  prefs: []
  type: TYPE_NORMAL
- en: 'if num < 2:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2, int(num ** 0.5) + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if num % i == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each approach may be useful in different cases depending on how simple you want
    the results to be versus the need for broader coverage. Remember that since you
    are interacting with an AI, prompting and setting the context are the keys to
    getting explicit results (versus generic results or ones rendered quickly inline).
    Depending on where you are at with your overall progress on a project and experience
    with the languages and frameworks you are using, you may find that a combination
    of these approaches works well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we leave this section on creating unit tests, here’s a generic prompt
    template for creating a set of unit tests (adapted from the [Copilot documentation](https://oreil.ly/NOS8j)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The words enclosed by < and > are meant to be replaced with specific terms
    by you. This template has several key elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs: []
  type: TYPE_NORMAL
- en: It explicitly asks for a comprehensive suite of unit tests, so the AI generates
    more than just basic tests and covers a wide variety of potential use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Scenarios
  prefs: []
  type: TYPE_NORMAL
- en: 'It specifies that the tests should include:'
  prefs: []
  type: TYPE_NORMAL
- en: Edge cases to test for boundary conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling for errors that should be raised when invalid actions occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data validation to ensure that inputs are correctly validated and handled by
    the methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve covered the unit-test approaches, let’s look at how we can leverage
    Copilot to help us write integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Integration Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use Copilot to create integration tests by telling it to focus on the
    way multiple components interact rather than creating tests for isolated units
    of code. To do this, you need to write your prompts with clear instructions that
    emphasize the collaboration between services, modules, and/or external systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys to having Copilot create successful integration tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Craft specific prompts
  prefs: []
  type: TYPE_NORMAL
- en: Ask Copilot to write integration tests for interaction between components rather
    than just generating tests for code.
  prefs: []
  type: TYPE_NORMAL
- en: Use mocks for external dependencies
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests frequently need to simulate an external service such as a
    database or an API. You can instruct Copilot to use mocks so tests can verify
    the functionality without having to have real implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Request coverage of interactions
  prefs: []
  type: TYPE_NORMAL
- en: Ask Copilot to verify that methods are called, data flows as expected between
    components, or that expected side effects occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generic template for a prompt for integration tests could look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '(Again, the terms in <> are meant to be replaced for your specific use case.)
    As an example, suppose that we have an Express application with two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserService`'
  prefs: []
  type: TYPE_NORMAL
- en: Handles user data
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthController`'
  prefs: []
  type: TYPE_NORMAL
- en: Handles login requests and delegates to `UserService`
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to write integration tests to ensure that the `AuthController` correctly
    interacts with `UserService` and the HTTP layer. Here is a prompt to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the response that Copilot generates based on that prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You may need to do additional tweaking on the integration test code to ensure
    everything works as intended, but this gives you a solid starting point to work
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the kinds of tests you are creating through Copilot, you may want
    to have them tailored for your project or per testing guidelines you must adhere
    to. In the next section, we’ll look at how to set up custom testing instructions
    for Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Custom Testing Instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can customize how Copilot generates tests for your project by providing
    custom test-generation instructions. This ensures that Copilot produces tests
    that align with your preferred frameworks, coding standards, and workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test-generation instructions can be set up at two levels: user level and workspace
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: For a particular workspace, you can add instructions directly to your project’s
    *.vscode/settings.json* file. If these are persisted, they customize Copilot’s
    behavior for everyone working with that project.
  prefs: []
  type: TYPE_NORMAL
- en: To create instructions that apply across all projects you work with, you can
    instead add instructions to your *global* VS Code settings.
  prefs: []
  type: TYPE_NORMAL
- en: At either of these levels, you can also create a separate Markdown file with
    more detailed instructions and then point your settings to the file. This is useful
    for complex or evolving standards that you want to reuse across multiple projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding custom test instructions in your settings file, they should be
    placed under the key `github.copilot.chat.testGeneration.instructions`. Here’s
    an example with both specific instructions spelled out and a referenced file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The content in the file *test-guidelines.md* could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You may have to iterate to get the best form for the instructions, but once
    they’re set up, Copilot should honor them for typical operations like `@workspace
    /tests`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Test Instructions Are Experimental
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of this writing, the custom test instructions feature is still labeled as
    *experimental.*
  prefs: []
  type: TYPE_NORMAL
- en: For the final part of this chapter, let’s look at how Copilot can help with
    using frameworks and creating tests *before* writing implementation code. This
    is useful for techniques like test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Before the Coding and Leveraging Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Test-driven development* (*TDD*) has already been mentioned in this chapter.
    If you’re unfamiliar with the term, it’s an approach to software development that
    emphasizes writing test cases for code before writing the actual code itself.
    TDD is considered a best practice or requirement in many coding projects and groups.'
  prefs: []
  type: TYPE_NORMAL
- en: More on TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are new to TDD or interested in learning more about the practice, the
    web has many references. A relatively quick but informative read can be found
    at the [testdriven.io](https://oreil.ly/VaMiK) website.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Copilot to create test cases for TDD and then implement the code
    to be tested. Consider a simple example of creating a test class and tests for
    code that will help manage student records at a university. We’ll use [Mockito](https://site.mockito.org)
    in our testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: About Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mockito specializes in helping Java applications manage dependencies and simulating
    external interactions from other components without requiring the implementation
    or presence of the components themselves—i.e., *mocking*. Previously in the chapter,
    we showed how Copilot can incorporate mocking for generating integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, suppose we begin with an empty project called *students*, and we
    have Copilot create a [*pom.xml*](https://oreil.ly/Qx29p) file for a Java project
    with desired versions of dependencies. Here’s a prompt for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As shown in [Figure 5-15](#pomxml-creation), this prompt triggers Copilot to
    try to understand our intent and then run the `/new` shortcut command to set up
    a structure if needed. After that, it figures out the code for the *pom.xml* file
    we asked for and gives a link to see it and a button shortcut to create it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0515.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-15\. pom.xml creation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To build out our testing code, let’s create an appropriate test class and initial
    set of tests. We’ll do this in the separate Chat interface since we can expect
    a significant amount of output and we may want to put it in a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the prompt, we tell Copilot to reference the content of the *pom.xml* file
    to make sure it knows to pick up the Mockito dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This then makes our initial query something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Copilot returns this in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. **Dependencies**:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mockito-core` dependency in your pom.xml
  prefs: []
  type: TYPE_NORMAL
- en: is used for mocking the `University` class.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. **Test Setup**:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@BeforeEach` method initializes the mock
  prefs: []
  type: TYPE_NORMAL
- en: '`University` object and a sample `Student` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. **Test Cases**:'
  prefs: []
  type: TYPE_NORMAL
- en: '- `testEnrollStudent`: Verifies that a student is enrolled in the'
  prefs: []
  type: TYPE_NORMAL
- en: university and checks the list of enrolled students.
  prefs: []
  type: TYPE_NORMAL
- en: '- `testGetStudentDetails`: Verifies that the correct student'
  prefs: []
  type: TYPE_NORMAL
- en: details are returned when queried by ID.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have the `Student` and `University` classes
  prefs: []
  type: TYPE_NORMAL
- en: implemented in your project for these tests to work. Let me know if
  prefs: []
  type: TYPE_NORMAL
- en: you need help creating those classes!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Referencing #file:pom.xml, create only a StudentTest class for a'
  prefs: []
  type: TYPE_NORMAL
- en: student enrolled at a university. A student will have personal
  prefs: []
  type: TYPE_NORMAL
- en: attributes such as a first and last name, a phone number, an
  prefs: []
  type: TYPE_NORMAL
- en: address, and a contact email.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here is the `StudentTest` class for testing a student with personal
  prefs: []
  type: TYPE_NORMAL
- en: 'attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: package com.example;
  prefs: []
  type: TYPE_NORMAL
- en: import org.junit.jupiter.api.BeforeEach;
  prefs: []
  type: TYPE_NORMAL
- en: import org.junit.jupiter.api.Test;
  prefs: []
  type: TYPE_NORMAL
- en: import static org.junit.jupiter.api.Assertions.*;
  prefs: []
  type: TYPE_NORMAL
- en: class StudentTest {
  prefs: []
  type: TYPE_NORMAL
- en: private Student student;
  prefs: []
  type: TYPE_NORMAL
- en: '@BeforeEach'
  prefs: []
  type: TYPE_NORMAL
- en: void setUp() {
  prefs: []
  type: TYPE_NORMAL
- en: student = new Student("John", "Doe", "123-456-7890",
  prefs: []
  type: TYPE_NORMAL
- en: '"123 Main St", "john.doe@example.com");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: void testStudentAttributes() {
  prefs: []
  type: TYPE_NORMAL
- en: // Verify that the student's attributes are correctly set
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("John", student.getFirstName());
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("Doe", student.getLastName());
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("123-456-7890", student.getPhoneNumber());
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("123 Main St", student.getAddress());
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("john.doe@example.com", student.getEmail());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: void testUpdatePhoneNumber() {
  prefs: []
  type: TYPE_NORMAL
- en: // Update the phone number and verify the change
  prefs: []
  type: TYPE_NORMAL
- en: student.setPhoneNumber("987-654-3210");
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("987-654-3210", student.getPhoneNumber());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: void testUpdateAddress() {
  prefs: []
  type: TYPE_NORMAL
- en: // Update the address and verify the change
  prefs: []
  type: TYPE_NORMAL
- en: student.setAddress("456 Elm St");
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("456 Elm St", student.getAddress());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: void testUpdateEmail() {
  prefs: []
  type: TYPE_NORMAL
- en: // Update the email and verify the change
  prefs: []
  type: TYPE_NORMAL
- en: student.setEmail("new.email@example.com");
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("new.email@example.com", student.getEmail());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explanation:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1\. **Attributes Tested**:'
  prefs: []
  type: TYPE_NORMAL
- en: '- First name'
  prefs: []
  type: TYPE_NORMAL
- en: '- Last name'
  prefs: []
  type: TYPE_NORMAL
- en: '- Phone number'
  prefs: []
  type: TYPE_NORMAL
- en: '- Address'
  prefs: []
  type: TYPE_NORMAL
- en: '- Email'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. **Test Cases**:'
  prefs: []
  type: TYPE_NORMAL
- en: '- `testStudentAttributes`: Ensures the attributes are initialized'
  prefs: []
  type: TYPE_NORMAL
- en: correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '- `testUpdatePhoneNumber`, `testUpdateAddress`, `testUpdateEmail`'
  prefs: []
  type: TYPE_NORMAL
- en: ': Verify that updates to attributes work as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: This test assumes the existence of a `Student` class with
  prefs: []
  type: TYPE_NORMAL
- en: appropriate getters and setters. Let me know if you need help
  prefs: []
  type: TYPE_NORMAL
- en: creating the `Student` class!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Install any needed dependencies for testing with mvn and then run
  prefs: []
  type: TYPE_NORMAL
- en: tests
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Referencing #editor, create a student class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: mvn test
  prefs: []
  type: TYPE_NORMAL
- en: 'The Maven test compilation failed due to the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. JUnit Dependencies Missing:'
  prefs: []
  type: TYPE_NORMAL
- en: The org.junit.jupiter.api package is not found, indicating that the
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 (Jupiter) dependency is missing in the pom.xml.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Student Class Not Found: The Student class is not being'
  prefs: []
  type: TYPE_NORMAL
- en: recognized, which could be due to incorrect package structure or
  prefs: []
  type: TYPE_NORMAL
- en: missing compilation.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Annotations Not Recognized: Annotations like @BeforeEach and'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test are not recognized, which is also related to the missing'
  prefs: []
  type: TYPE_NORMAL
- en: JUnit dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will now:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the required JUnit 5 dependency to the pom.xml.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the Student class is correctly compiled and accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Re-run the tests after fixing these issues
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <dependencies>
  prefs: []
  type: TYPE_NORMAL
- en: <!-- ...existing dependencies... -->
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>org.junit.jupiter</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>junit-jupiter</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>5.10.0</version>
  prefs: []
  type: TYPE_NORMAL
- en: <scope>test</scope>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: </dependencies>
  prefs: []
  type: TYPE_NORMAL
- en: Made changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Maven test run failed because the `Student` class could not be
  prefs: []
  type: TYPE_NORMAL
- en: found during the test execution. This indicates that the `Student`
  prefs: []
  type: TYPE_NORMAL
- en: class might not be compiled or is not in the correct package
  prefs: []
  type: TYPE_NORMAL
- en: structure.
  prefs: []
  type: TYPE_NORMAL
- en: I will verify the `Student` class's location and ensure it is
  prefs: []
  type: TYPE_NORMAL
- en: properly compiled and accessible. Then, I will re-run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the agent has figured out what it needs to try next. After we review
    and tell Copilot to proceed, it generates a new *Student.java* file with the correct
    content and in the correct location, and then proceeds to run the tests again.
    This time, they succeed because the agent has completed all needed changes. [Figure 5-18](#successful-completion)
    shows the success via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The new *Student.java* file in the upper left with its new content waiting to
    be approved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The successful build/test run in the lower left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent’s assessment that the tests all passed, the `Student` class is implemented,
    and the project is working as expected, in the upper right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “files changed” area in the lower right showing that updates were made by
    the agent to the *pom.xml* file and the *Student.java* file to get everything
    working
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/lghc_0518.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-18\. Successful completion via the agent
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Certainly, we could have done this without the agent via several passes and
    individual actions. But, where we can leverage Copilot’s agentic abilities, we
    can save ourselves some time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we can review the changes, save the updated files into the workspace,
    and add other functionality if we need it. Similar multistep processes for testing
    workflows can be done with this step-by-step approach, whether using the agent
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the more context and direction you can give Copilot through the prompt,
    workspace files, editor, etc., the more likely it will produce good content and
    suggestions for you to incorporate. If, however, you don’t get what you expect,
    don’t be afraid to iterate on your prompt/query until you get the results you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve focused on how to apply Copilot’s completion suggestions
    and chat capabilities in the context of creating tests for code. As shown in the
    different sections, you can use various approaches to have Copilot generate tests
    relevant to code in your workspace. Inline completion and suggestions from Copilot
    can be utilized, as well as the chat capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Most options for generating tests rely on passing the request to the chat interface
    in some form—either by using shortcut (slash) commands or entering a prompt through
    the inline or separate chat interfaces. For any substantial or complex, lengthy
    tests, working through the chat functionality will likely provide the best results.
    For quick, boilerplate unit tests or simple unit-testing functions, using specific
    inline comments as prompts can work well.
  prefs: []
  type: TYPE_NORMAL
- en: Most basic commands for creating tests through Copilot produce unit tests. Copilot
    can be used to create integration tests by ensuring that the prompt includes sections
    targeted toward interaction of components, mocking, and verifying the expected
    outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot can be used to support best practices such as TDD. With this strategy,
    Copilot can be used to generate initial testing code and then later generate the
    appropriate implementation to pass the test. As with all approaches mentioned
    in the chapter, it’s important to review the results to make sure they are usable
    and what you intended. You should always feel free to disregard suggestions or
    code from Copilot and/or reframe prompts and queries to get more accurate results.
    Also, you can define more explicit context to have Copilot consider for generating
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: As with implementation code, testing code should ideally be verbosely commented.
    This makes the code more readable and easily understandable. However, explaining
    and documenting our test cases or our implementations is something we may put
    off until later because it takes cycles away from other work, and the algorithms
    may be changed. In [Chapter 6](ch06.html#ch06), we’ll explore how Copilot can
    help make these tasks almost effortless.
  prefs: []
  type: TYPE_NORMAL
