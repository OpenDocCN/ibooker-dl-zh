<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section class="pagenumrestart" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 1. Introduction to Large Language Models"><div class="chapter" id="ch01_introduction_to_large_language_models_1748895465615150">
<h1><span class="label">Chapter 1. </span>Introduction to Large Language Models</h1>

<p>The <a contenteditable="false" data-primary="LLMs (large language models)" data-type="indexterm" id="icd101"/><a contenteditable="false" data-primary="large language models" data-see="LLMs" data-type="indexterm" id="id326"/>rise<a contenteditable="false" data-primary="large language model operations engineers" data-see="LLMOps engineers" data-type="indexterm" id="id327"/> in popularity of large language models (LLMs) is no accident; they’re transforming how we interact with technology and pushing the boundaries of what machine learning models can do.</p>

<p>But here’s the catch: while these models are impressive, scaling them up and managing them in production is no walk in the park. The leap from a research project to a fully fledged, reliable tool is filled with obstacles. We’re talking about meeting enormous computational requirements, managing complex data, and ensuring that everything runs smoothly and securely whether you are self-hosting or using proprietary models.</p>

<p>Before we dive into the nitty-gritty of LLM operations, it’s important to understand why and how these models came to be. Knowing their origins and trajectory helps us appreciate the challenges we face when predicting their behaviors in production.</p>

<p>The evolution of LLMs reflects a series of incremental innovations, each addressing specific limitations of previous models. Early models were limited in scope and required extensive human input for even basic tasks. With advancements in architecture, such as the shift from recurrent neural networks (RNNs) to transformers, and the scaling of model sizes, LLMs have become more sophisticated. This evolution has brought about new challenges, such as managing massive amounts of data and ensuring efficient training processes.</p>

<p>So, let’s get into it.</p>

<section class="pagebreak-before" data-type="sect1" data-pdf-bookmark="Some Key Terms"><div class="sect1" id="ch01_some_key_terms_1748895465615383">
<h1 class="less_space">Some Key Terms</h1>

<p>There<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="terminology" data-type="indexterm" id="id328"/> are three terms we should clarify before going any further:</p>

<dl>
	<dt>Foundation models</dt>
	<dd>
	<p><em>Foundation models<a contenteditable="false" data-primary="foundation models" data-type="indexterm" id="id329"/></em> are<a contenteditable="false" data-primary="ML (machine learning)" data-secondary="foundation models" data-type="indexterm" id="id330"/> advanced ML architectures that serve as the foundational building blocks for creating specialized models. They are pretrained on massive datasets, often consisting of text and recently including other data types such as code, images, audio, and video to develop general language comprehension and pattern recognition capabilities. These models encode statistical relationships and linguistic structures from their training data, forming a robust starting point for further fine-tuning. This fine-tuning tailors the models to specific tasks or applications, such as powering LLMs or other AI-driven solutions.</p>
	</dd>
	<dt>Large language models</dt>
	<dd>
	<p><em>Large language models</em> are<a contenteditable="false" data-primary="large language models" data-type="indexterm" id="id331"/> specialized implementations of foundation models that have undergone additional training or fine-tuning to excel in specific language-based tasks. These models are designed to predict and generate human-like text by analyzing and emulating natural language patterns. LLMs are highly versatile, supporting several<a contenteditable="false" data-primary="NLP (natural language processing)" data-type="indexterm" id="id332"/> natural<a contenteditable="false" data-primary="natural language processing" data-see="NLP" data-type="indexterm" id="id333"/> language processing (NLP) applications such as text generation, sentiment analysis, language translation, question answering, and more. Popular use cases include chatbots, content creation, multilingual communication, data analysis, code generation, recommendation systems, and virtual assistants. <a data-type="xref" href="#ch01_enterprise_use_cases_for_llms_1748895465616095">“Enterprise Use Cases for LLMs”</a> will look at these applications in more detail.</p>
	</dd>
	<dt>Generative AI models</dt>
	<dd>
	<p><em>Generative AI</em>, or <em>GenAI</em>, refers<a contenteditable="false" data-primary="generative AI" data-type="indexterm" id="id334"/> to foundation models that have been trained specifically to generate content (images, text, audio, or video) based on the patterns and information they have learned. Some of the earliest generative AI models were generative adversarial networks (GANs), introduced in 2018; more recently, diffusion models, LLMs, and multimodal models like Gemini have become available. Given their generative nature, LLMs are considered a subset of generative AI models. In the context of LLMs, generative AI can generate text responses, creative stories, product descriptions, and more, based on input and learned patterns.</p>
	</dd>
</dl>

<p>Confusingly, these three terms are frequently used interchangeably and loosely. For example, a popular image generation model, DALL-E<a contenteditable="false" data-primary="DALL-E" data-type="indexterm" id="id335"/>, is better categorized as a generative AI model than as a large language model. Recently, however, the DALL-E image generation functionality has been integrated into the <a contenteditable="false" data-primary="ChatGPT" data-secondary="image generation" data-type="indexterm" id="id336"/><a contenteditable="false" data-primary="OpenAI" data-secondary="ChatGPT" data-type="indexterm" id="id337"/>ChatGPT chatbot, one of the most popular LLM applications. Therefore, a user can ask an LLM like ChatGPT to generate images. Over time, the language seems to be evolving toward calling all of these <em>AI models,</em> for simplicity.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Transformer Models"><div class="sect1" id="ch01_transformer_models_1748895465615445">
<h1>Transformer Models</h1>

<p>The <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="transformer models" data-type="indexterm" id="icd102"/><a contenteditable="false" data-primary="transformers and transformer models" data-type="indexterm" id="icd103"/>transformer model, introduced by the paper <a href="https://oreil.ly/J8MBW">“Attention Is All You Need,”</a> marked one of the biggest shifts in how we approach sequence-based tasks. Transformers have set new standards in how to handle language data.</p>

<p>Before transformers, the most popular solution for <a contenteditable="false" data-primary="NLP (natural language processing)" data-secondary="RNNs" data-type="indexterm" id="id338"/>NLP tasks<a contenteditable="false" data-primary="RNNs (recurrent neural networks)" data-type="indexterm" id="icd103x"/><a contenteditable="false" data-primary="recurrent neural networks (RNNs)" data-type="indexterm" id="icd104x"/> was <em>recurrent neural networks</em>. RNNs process data sequentially, one step at a time, which makes them suitable for handling time-dependent data such as text. However, this sequential processing introduces a significant drawback: RNNs often struggle to retain information from earlier steps as they move forward in the sequence, especially over long inputs.</p>

<p>During neural network training, the model processes input data and generates predictions. These predictions are compared to the correct answers using a loss function, which calculates the error (how far the predictions are from the correct answers). An algorithm, such<a contenteditable="false" data-primary="backpropagation" data-type="indexterm" id="id339"/> as <em>backpropagation</em>, calculates<a contenteditable="false" data-primary="gradients, in neural network training" data-type="indexterm" id="id340"/> <em>gradients</em>: values that indicate how the model’s parameters (weights and biases) should be adjusted to reduce the error and improve accuracy.</p>

<p>However, in long sequences like those handled by RNNs, gradients can become very small as they are repeatedly multiplied during backpropagation. Over time, these small values may shrink so much that computers treat them as zero, effectively stopping the model from learning. This issue is known as<a contenteditable="false" data-primary="vanishing gradient problem" data-type="indexterm" id="id341"/> the <em>vanishing gradient problem</em>, and it prevents the model from learning long-term dependencies in the data.</p>

<p><em>Transformers</em>, on the other hand, overcome this limitation by using self-attention and parallel processing, allowing them to handle sequences more efficiently and capture long-range dependencies effectively. Instead of processing data one step at a time, transformers analyze all input tokens (e.g., words in a sentence) simultaneously. <em>Self-attention</em> is<a contenteditable="false" data-primary="self-attention" data-type="indexterm" id="id342"/> a mechanism that allows each word or token in a sequence to focus on other words in the same sequence, regardless of their position. This is achieved by calculating a set of attention weights that measure the relevance of each token in the sequence to every other token. For instance, in a sentence, self-attention can help a word like <em>it</em> to align itself with its correct reference, even if that reference is several words away. Thus, self-attention allows the model to weigh the importance of each token relative to others in the input, enabling it to capture relationships across the entire input sequence efficiently. This parallel processing not only speeds up computation but also eliminates the issues associated with sequential processing, like the vanishing gradient problem.</p>

<p>Thanks to their ability to manage long-range dependencies and handle vast amounts of data, transformer-based models excel in various <a contenteditable="false" data-primary="NLP (natural language processing)" data-secondary="transformers" data-type="indexterm" id="id343"/>NLP tasks, including translation, summarization, and question answering. Their ability to focus on different parts of the sequence regardless of their relative distance, along with positional encoding to retain sequence order, allows transformers to handle long sequences without losing context.</p>

<p>Some people wondered, “Well, since they can be scaled much better now, how about we throw more computing power and a lot more data at these models to see what happens?” Models like GPT-3, LLaMA, and their successors demonstrated that increasing the number of parameters can significantly improve the performance of transformer models.</p>

<p>Transformers have extended their influence beyond NLP into image processing with innovations like<a contenteditable="false" data-primary="ViT (vision transformer)" data-type="indexterm" id="id344"/> the <em>vision transformer</em> (ViT), which treats image patches as sequences and applies transformer models to them. ViT has shown promising results in image classification, offering a viable alternative to the previous solution, convolutional neural networks (CNNs). Additionally, in <a contenteditable="false" data-primary="recommender systems" data-type="indexterm" id="id345"/>recommender systems, transformers’ ability to model complex patterns and dependencies enhances accuracy and personalization. <a data-type="xref" href="#ch01_table_1_1748895465606161">Table 1-1</a> compares the abilities of the neural network models we’ve discussed.<a contenteditable="false" data-primary="recurrent neural networks (RNNs)" data-startref="icd103x" data-type="indexterm" id="id346"/><a contenteditable="false" data-primary="RNNs (recurrent neural networks)" data-startref="icd104x" data-type="indexterm" id="id347"/><a contenteditable="false" data-primary="CNNs (convolutional neural networks)" data-type="indexterm" id="id348"/><a contenteditable="false" data-primary="convolutional neural networks (CNNs)" data-type="indexterm" id="id349"/></p>

<table id="ch01_table_1_1748895465606161">
	<caption><span class="label">Table 1-1. </span>The evolution of different neural network models</caption>
	<thead>
		<tr>
			<th> </th>
			<th>CNNs</th>
			<th>RNNs</th>
			<th>Transformers</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="subheading">Application</td>
			<td>
			<p>Best suited for spatial-based tasks (e.g., images)</p>
			</td>
			<td>
			<p>Well suited for sequence-based tasks (e.g., NLP)</p>
			</td>
			<td>
			<p>Well suited for capturing all three modalities: images, NLP, and speech</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Computation</td>
			<td>
			<p>Highly parallelizable input processing</p>
			</td>
			<td>
			<p>Sequential processing</p>
			</td>
			<td>
			<p>Parallel processing of inputs</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Performance on language-specific tasks</td>
			<td>
			<p>Need large number of stacked convolution blocks for handling long-range dependencies</p>
			</td>
			<td>
			<p>Can handle long-range dependencies much better than CNNs but can handle the dependencies well only to a given length</p>
			</td>
			<td>
			<p>Can handle long- to very-long-range dependencies much better than other architectures such as RNNs or LSTMs</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Scalability</td>
			<td>
			<p>Scalable</p>
			</td>
			<td>
			<p>Limited scalability</p>
			</td>
			<td>
			<p>Highly scalable</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Data requirements</td>
			<td>
			<p>Work well even on small datasets</p>
			</td>
			<td>
			<p>Work well even on small datasets</p>
			</td>
			<td>
			<p>Don’t work well on small datasets</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Ease of training</td>
			<td>
			<p>Easy to train and tune</p>
			</td>
			<td>
			<p>Require more tuning than CNNs</p>
			</td>
			<td>
			<p>Difficult to train and tune</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Interpretability</td>
			<td>
			<p>Easy to debug</p>
			</td>
			<td>
			<p>Difficult to debug</p>
			</td>
			<td>
			<p>Difficult to debug</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Deployment</td>
			<td>
			<p>Easy to deploy</p>
			</td>
			<td>
			<p>Easy to deploy</p>
			</td>
			<td>
			<p>Difficult to deploy</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Small edge devices</td>
			<td>
			<p>Works well on edge devices</p>
			</td>
			<td>
			<p>Works well on edge devices</p>
			</td>
			<td>
			<p>Limited support for edge devices</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Explainability</td>
			<td>
			<p>Supports wide variety of explainability</p>
			</td>
			<td>
			<p>Limited explainability</p>
			</td>
			<td>
			<p>Very limited explainability</p>
			</td>
		</tr>
	</tbody>
</table>

<p>This trend of throwing more compute and data at transformers is what sparked the evolution of LLMs, as well as the shift from an architecture that can do well on a single modality to one that generalizes on most modalities. Understanding this evolution can help you appreciate the differences in model <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="transformer models" data-startref="icd102" data-type="indexterm" id="id350"/>architectures.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Large Language Models"><div class="sect1" id="ch01_large_language_models_1748895465615508">
<h1>Large Language Models</h1>

<p>LLMs<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="overview of" data-type="indexterm" id="id351"/> excel at understanding context and making associations among words, phrases, and concepts to provide relevant information based on the input query or prompt. While structured knowledge bases rely on human-curated data, LLMs can automatically extract knowledge from unstructured text. When trained on diverse textual sources, they can process a vast amount of information without explicit human intervention. However, this also introduces a challenge, as the model can learn biased or incorrect information from the training data.</p>

<p>LLMs are also designed to understand and generate human-like text and to be accessible through natural language queries in conversational, interactive settings. This makes them convenient and user-friendly for retrieving information and obtaining responses.</p>

<p>These models are “large” not just because of the amount of data they’re trained on but also because of their number of parameters. Think<a contenteditable="false" data-primary="parameters, in LLMs" data-type="indexterm" id="id352"/> of <em>parameters</em> as being like “knobs” inside the models that may be adjusted during training to help the models learn better. In neural networks, parameters are weights and <a contenteditable="false" data-primary="bias" data-secondary="neural networks" data-type="indexterm" id="id353"/>biases. When an input like a prompt is presented to a model, it first transforms the input into a numerical representation, and then the numbers are processed through the neural network. Each node in the neural network contains a bias, adding or subtracting to the input value, and each connection between nodes contains a weight that will multiply the value of the input as it passes through nodes. Using more parameters greatly extends the capabilities of traditional transformer models, but not without massive trade-offs in cost and evaluation complexity.</p>

<p>There are two basic categories of LLMs, discriminative and generative. <em>Discriminative models</em>, such<a contenteditable="false" data-primary="discriminative models" data-type="indexterm" id="id354"/> as <a contenteditable="false" data-primary="BERT (Bidirectional Encoder Representations from Transformers)" data-type="indexterm" id="icd102x"/>​BERT (Bidirectional Encoder Representations from Transformers), which was introduced in 2018, learn the boundary between classes in a classification problem. They’re concerned with the conditional probability <em>P</em>(<em>y</em>|<em>x</em>), which is the probability of the output given the input. Discriminative transformer models are typically used for tasks like text classification, sentiment analysis, and named-entity recognition, where the goal is to predict a label or category given some input <a contenteditable="false" data-primary="transformers and transformer models" data-startref="icd103" data-type="indexterm" id="id355"/>​text.</p>

<p><em>Generative models</em>,<a contenteditable="false" data-primary="generative LLMs" data-seealso="LLMs" data-type="indexterm" id="id356"/> such as GPT-3 and GPT-4, <a contenteditable="false" data-primary="GPT (generative pretrained transformer) series" data-type="indexterm" id="icd106x"/><a contenteditable="false" data-primary="generative pretrained transformer (GPT) series" data-type="indexterm" id="icd107x"/>learn the joint probability distribution of the input and the output, or <em>P</em>(<em>x</em>, <em>y</em>), and can generate new data points similar to the training data. Generative models are used for tasks like text generation, where the goal is to generate new text similar to the text the model was trained on. Not all LLMs need to be generative, although most are. Throughout this book, when we refer to “LLMs,” we mean generative LLMs.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="LLM Architectures"><div class="sect1" id="ch01_llm_architectures_1748895465615558">
<h1>LLM Architectures</h1>

<p>There<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="architectures" data-type="indexterm" id="icd104"/> are two main types of architecture for language models: encoders and decoders. Encoders and decoders can also be combined, and there is ongoing research on new architectures.</p>

<section data-type="sect2" data-pdf-bookmark="Encoder-Only LLMs"><div class="sect2" id="ch01_encoder_only_llms_1748895465615611">
<h2>Encoder-Only LLMs</h2>

<p><em>Encoder-only models</em> are designed<a contenteditable="false" data-primary="encoder-only models (AutoEncoding models)" data-type="indexterm" id="id357"/><a contenteditable="false" data-primary="AutoEncoding models (encoder-only models)" data-type="indexterm" id="id358"/>​ to process and comprehend input text, transforming it into a meaningful representation or embedding.<a contenteditable="false" data-primary="embeddings" data-secondary="defined" data-type="indexterm" id="id359"/> <em>Embeddings</em> are numerical representations of data, such as words, phrases, or sentences, in a high-dimensional vector space. Embeddings capture meaning and context in a way that results in words with similar meanings or contexts being placed close together in this vector space. This representation captures the essence of the input, making it suitable for tasks where understanding the context is needed.</p>

<p>One of the most notable examples of an encoder-only model is <a href="https://oreil.ly/f2AL4">BERT</a>. During its pretraining phase, BERT uses<a contenteditable="false" data-primary="masked language modeling" data-type="indexterm" id="id360"/> <em>masked language modeling</em>, a technique where random words in the text are masked and the model learns to predict these masked words based on the surrounding context. BERT is also trained using next-sentence prediction, where it determines whether one sentence follows another <a contenteditable="false" data-primary="BERT (Bidirectional Encoder Representations from Transformers)" data-startref="icd102x" data-type="indexterm" id="id361"/>​logically.</p>

<p>The primary advantage of encoder-only models lies in their syntactic understanding of text; i.e., their ability to capture the intricate relationships between words and their contexts. These models excel in tasks such as sentiment analysis, named-entity recognition, and question answering.</p>

<p>However, encoder-only models have their limitations. They are not designed for generating new text; their focus is solely on understanding and analyzing the input. This limitation can be restrictive when using them in applications requiring text generation or completion.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Decoder-Only LLMs"><div class="sect2" id="ch01_decoder_only_llms_1748895465615658">
<h2>Decoder-Only LLMs</h2>

<p><em>Decoder-only models</em> are<a contenteditable="false" data-primary="GPT (generative pretrained transformer) series" data-startref="icd106x" data-type="indexterm" id="id362"/><a contenteditable="false" data-primary="generative pretrained transformer (GPT) series" data-startref="icd107x" data-type="indexterm" id="id363"/> good<a contenteditable="false" data-primary="decoder-only models (AutoRegressive models)" data-type="indexterm" id="id364"/><a contenteditable="false" data-primary="AutoRegressive models (decoder-only models)" data-type="indexterm" id="id365"/>​ at generating coherent and contextually relevant text based on an input or prompt. Examples of this architecture are the generative pretrained transformer (GPT) series, including GPT-2, GPT-3, and the most recent GPT-4.</p>

<p>These models are pretrained using<a contenteditable="false" data-primary="language modeling objectives" data-type="indexterm" id="id366"/> a <em>language modeling objective</em>. With this technique, they learn to predict the next word in a sequence given the preceding context, allowing them to generate text that flows naturally and maintains coherence over longer passages.</p>

<p>The key advantage of decoder-only models is their ability to generate high-quality text. This makes them extremely effective for tasks such as text completion, <span class="keep-together">summarization,</span> and creative writing. They also exhibit<a contenteditable="false" data-primary="emergent properties" data-type="indexterm" id="id367"/> <em>emergent properties</em>, meaning that they can perform tasks beyond their initial training objective, such as translation and question answering, without additional fine-tuning.</p>

<p>However, their focus on text generation can be a limitation in tasks requiring deep understanding of the input text. Decoder-only models generate text based on patterns learned during training, which may not always align with the specific nuances of the input.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Encoder–Decoder LLMs"><div class="sect2" id="ch01_encoder_decoder_llms_1748895465615705">
<h2>Encoder–Decoder LLMs</h2>

<p><em>Encoder–decoder models</em> combine<a contenteditable="false" data-primary="encoder–decoder models (sequence-to-sequence models)" data-type="indexterm" id="id368"/><a contenteditable="false" data-primary="sequence-to-sequence models (encoder–decoder models)" data-type="indexterm" id="id369"/>​ the strengths of both encoder and decoder architectures, making them suitable for tasks involving complex mappings between input and output sequences.</p>

<p>In this setup, the encoder processes the input text to create an embedding, which the decoder then uses to generate the output text. Notable examples include<a contenteditable="false" data-primary="BART (Bidirectional and Auto-Regressive Transformer)" data-type="indexterm" id="id370"/><a contenteditable="false" data-primary="Bidirectional and Auto-Regressive Transformer (BART)" data-type="indexterm" id="id371"/> Bidirectional and Auto-Regressive Transformer (BART) and<a contenteditable="false" data-primary="T5 (Text-To-Text Transfer Transformer)" data-primary-sortas="Tfive" data-type="indexterm" id="id372"/> Text-To-Text Transfer Transformer (T5). BART, introduced in 2019, is trained<a contenteditable="false" data-primary="denoising auto-encoding" data-type="indexterm" id="id373"/> using<em> denoising auto-encoding</em>, where parts of the input text are corrupted and the model learns to reconstruct the original text.</p>

<p>The encoder–decoder architecture excels at tasks where the input and output are different in structure and length, such as machine translation and text summarization. However, the complexity of training and the computational resources these models require can be a drawback. Their dual architecture means they must effectively integrate both components, which can be demanding in terms of both data and processing power.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="State Space Architectures"><div class="sect2" id="ch01_state_space_architectures_1748895465615753">
<h2>State Space Architectures</h2>

<p>A <a contenteditable="false" data-primary="state space architectures" data-type="indexterm" id="id374"/>new approach tries to solve one of the problems with transformers, which is that the self-attention<a contenteditable="false" data-primary="self-attention" data-type="indexterm" id="id375"/> mechanism has<a contenteditable="false" data-primary="quadratic complexity" data-type="indexterm" id="id376"/> <em>quadratic complexity</em>. This means that the number of computations required for inferencing grows with the square of input size, since the relationship between each pair of tokens needs to be modeled. Mathematically, it is often represented as <em>O</em>(<em>n</em><sup>2</sup>), where <em>n</em> is the number of tokens (words or subwords in a sentence). Quadratic complexity is generally a hard computational problem, especially when using larger datasets.</p>

<p>The <em>state space architecture</em> replaces the transformer approach by incorporating<a contenteditable="false" data-primary="state space representations" data-type="indexterm" id="id377"/> <em>state space representations</em>, which model the state of the system instead of recording it at each step. This compression allows for linear computational complexity, improving computational performance and reducing memory requirements, but it increases the rate of error.</p>

<p>Researchers are trying to solve the error problem. Recent examples<a contenteditable="false" data-primary="Mamba and Mamba-2" data-type="indexterm" id="id378"/> are <a href="https://oreil.ly/p3rqX">Mamba and Mamba-2</a>, which create a state representation that dynamically attempts to determine the important parts of the prompt by modeling importance as a state space parameter. In experimental settings, Mamba performs as well as a transformer-based model that has double the number of parameters for small and medium prompts but still has not delivered on the promise of low error rates for larger prompts.</p>

<p>Each LLM architectural design has its own sets of strengths and limitations. Encoder-only models like BERT are highly effective for understanding and analyzing text but fall short in generating new content. Decoder-only models, exemplified by the GPT series, excel in generating coherent and contextually relevant text but are <a contenteditable="false" data-primary="nondeterministic/nondeterminism" data-type="indexterm" id="id379"/>nondeterministic, which can be problematic for some applications like text classification. Emerging architectures like state space models, which promise enhancements in performance and applicability, should be monitored, but they haven’t been proven yet.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Small Language Models"><div class="sect2" id="ch01_small_language_models_1748895465615800">
<h2>Small Language Models</h2>

<p>Another <a contenteditable="false" data-primary="SLMs (small language models)" data-type="indexterm" id="id380"/>recent development is <em>small language models</em> (SLMs), which are compact, efficient language models designed to perform <a contenteditable="false" data-primary="NLP (natural language processing)" data-secondary="SLMs" data-type="indexterm" id="id381"/>NLP tasks while using fewer computational resources than LLMs.</p>

<p>Unlike LLMs, which contain billions of parameters and require substantial memory and processing power, SLMs are often designed to have millions or even just hundreds of thousands of parameters. The trade-off is that they must focus on specific tasks or subjects. This makes them lightweight, cost-effective, and deployable on <span class="keep-together">a wider</span> range of devices, including mobile phones, IoT edge devices, and in environments with limited computational resources. The development of SLMs has been driven by the demand for efficient, accessible AI solutions that can operate in real time and offline, providing functionality without relying on cloud-based <span class="keep-together">infrastructure.</span></p>

<p>SLMs do not perform well on tasks that require contextual understanding, extensive memory, or reasoning abilities. They are not intended for more general problem-solving and need to be fine-tuned on specific datasets to perform well on particular tasks, maximizing efficiency while maintaining accuracy within a defined scope. While LLMs tend to perform several NLP tasks reasonably well in a large number of domains, SLMs need to be specifically trained. For instance, an LLM might be able to perform moderately well at summarizing legal documents as well as medical articles, while an SLM would excel in one and perform poorly at the <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="architectures" data-startref="icd104" data-type="indexterm" id="id382"/>other.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Choosing an LLM"><div class="sect1" id="ch01_choosing_an_llm_1748895465615848">
<h1>Choosing an LLM</h1>

<p>In<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="choosing" data-type="indexterm" id="icd105"/> the LLM world, it’s easy to get swept up in the excitement of the latest breakthroughs and cutting-edge technologies. New models pop up all the time. The truth is, selecting the right LLM is more than just a technical decision; it’s a strategic choice with far-reaching implications.</p>

<section data-type="sect2" data-pdf-bookmark="Considerations in the Selection of an LLM"><div class="sect2" id="ch01_considerations_in_the_selection_of_an_llm_1748895465615898">
<h2>Considerations in the Selection of an LLM</h2>

<p>Here<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="choosing" data-tertiary="considerations for" data-type="indexterm" id="id383"/> are five reasons why the model you choose can make all the difference:</p>

<dl>
	<dt>Alignment with objectives</dt>
	<dd>
	<p>Are you looking for a model that excels at generating human-like text? Or do you need one that can understand complex queries and provide accurate responses? The specific capabilities of different models can vary significantly. Some are designed with a focus on conversational abilities, while others are optimized for tasks like summarization or translation. Choosing a model that aligns with your objectives ensures that you’re investing in a tool that will deliver the results you need.</p>
	</dd>
	<dt>Performance and efficiency</dt>
	<dd>
	<p>Not all LLMs are created equal. Larger models might offer impressive performance and efficiency, but they often come with high computational costs and slower response times. Smaller, more optimized models tend to provide faster results and be more cost-effective, but rarely do they match the performance of their larger counterparts.</p>
	</dd>
	<dt>Training data and bias</dt>
	<dd>
	<p>The training data used to develop an LLM shapes its behavior and outputs. Variations in the datasets on which models are trained can lead to variations in how they handle specific topics or issues. <a contenteditable="false" data-primary="bias" data-secondary="training data and" data-type="indexterm" id="id384"/>Some models exhibit biases based on their training data, which can impact the accuracy and fairness of their responses. Choosing a model with a diverse and representative training dataset can help mitigate these risks and ensure more reliable and equitable outcomes.</p>
	</dd>
	<dt>Customization and adaptability</dt>
	<dd>
	<p>Your needs might not fit neatly into the one-size-fits-all approach of a generic LLM. Some models offer greater flexibility and can be fine-tuned or customized to better suit your specific requirements. If that’s what you need, choose one with strong customization capabilities so that you can mold it to better fit your use case.</p>
	</dd>
	<dt>Integration and support</dt>
	<dd>
	<p>The practical aspects of integrating an LLM into your existing systems and workflows <a contenteditable="false" data-primary="workflows" data-type="indexterm" id="id385"/>cannot be overlooked. Some models come with robust support and <span class="keep-together">documentation,</span> making integration smoother and less time-consuming. Others require more effort to set up and maintain. Considering how well a model integrates with your infrastructure and the level of support available can save you time and reduce headaches over the long run.</p>
	</dd>
</dl>

<p>Overall, the LLM model you choose is not just a technical decision; it’s a strategic one that impacts the effectiveness, efficiency, and overall success of your AI initiatives. Remember: the model you choose matters. By carefully evaluating your needs and understanding the strengths and limitations of different models, you can make an informed choice that aligns with your goals and sets you up for success.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="The Big Debate: Open Source Versus Proprietary LLMs"><div class="sect2" id="ch01_the_big_debate_open_source_versus_proprietary_llm_1748895465615950">
<h2>The Big Debate: Open Source Versus Proprietary LLMs</h2>

<p>Companies <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="choosing" data-tertiary="open source versus proprietary LLMs" data-type="indexterm" id="icd106"/>must navigate a complex landscape when choosing among open source, closed-source, and open weight LLMs. <a data-type="xref" href="#ch01_figure_1_1748895465600862">Figure 1-1</a> shows the choices of a sample of companies today. This section looks at each option’s limitations and <a contenteditable="false" data-primary="proprietary (closed-source) LLMs" data-secondary="adoption of" data-type="indexterm" id="id386"/>benefits.</p>

<figure><div id="ch01_figure_1_1748895465600862" class="figure"><img alt="" src="assets/llmo_0101.png" width="1266" height="695"/>
<h6><span class="label">Figure 1-1. </span>Enterprise adoption of different proprietary LLMs (source: <a href="https://oreil.ly/lqXYT">Andreessen Horowitz</a>)</h6>
</div></figure>

<section data-type="sect3" data-pdf-bookmark="Open source and open weight LLMs"><div class="sect3" id="ch01_open_source_and_open_weight_llms_1748895465615999">
<h3>Open source and open weight LLMs</h3>

<p>Open source and open weight are two types of publicly accessible LLMs that have gained traction in the AI community as of this writing, particularly among those looking to customize, deploy, or study advanced AI without relying on proprietary solutions.</p>

<p><em>Open source </em>LLMs<a contenteditable="false" data-primary="open source LLMs" data-secondary="proprietary LLMs versus" data-type="indexterm" id="icd107"/> are models with freely available underlying source code. Anyone can inspect, modify, and potentially redistribute the model and its architecture. These models typically include details about the architecture, training methods, and source code for the framework. Using open source models provides technical transparency and adaptability and fosters a community of collaboration. However, open source LLMs may or may not come with pretrained weights, the trained parameters that make the model functional and useful for specific tasks. These weights are the model’s “knowledge” gained from its training on large datasets and are essential for the model to perform effectively without retraining from scratch. Companies that want to take advantage of such models may need to acquire the training data themselves.</p>

<p>With <em>open weight</em> LLMs,<a contenteditable="false" data-primary="open weight LLMs" data-type="indexterm" id="icd108"/> the weights are publicly accessible. Having access to the weights means that users can directly deploy the model for real-world applications like text generation, summarization, and translation or fine-tune it on their own data. While many open weight models are also open source, some restrict use for commercial applications or require adherence to specific licensing terms, as seen with models like Meta’s Llama series.</p>

<p>The distinction between open source and open weight LLMs is crucial in determining how accessible and useful a model is “out of the box.” Open source models without weights can still allow for architectural experimentation and model-training setups, but they lack immediate functionality for practical applications until they are trained, and training requires substantial computational resources. In contrast, open weight models provide ready-to-use capabilities, making them more accessible to developers who do not have the resources for large-scale model training but want to fine-tune or deploy a pretrained model.</p>

<p>By leveraging open source and/or open weight models such as Llama or Mistral, companies can deploy models on existing hardware. This can be more cost-effective than using cloud-based proprietary solutions, which involve renting hardware. Such an approach can be particularly advantageous for startups or small to medium enterprises (SMEs) operating under tight budget constraints. For these companies, the financial savings can free up resources for other needs, like fine-tuning.</p>

<p>A company may have requirements besides financial concerns, such as wanting to ensure that the training data includes or excludes specific datasets. In these cases, an open weight model is not sufficient; the business really needs an open source model. For example, a company may want to guarantee that a model has never seen a specific data point; an open weight model whose training dataset is not shared can’t offer such a guarantee.</p>

<p>Community support<a contenteditable="false" data-primary="community support, for open source LLMs" data-type="indexterm" id="id387"/> is another potential advantage of open source LLMs. The collaborative nature of the open source ecosystem means that developers, researchers, and organizations continuously contribute to improving these models, and newly fine-tuned models are easily available via Hugging Face. Companies benefit not only from this collective intelligence but also from access to a wider range of resources, tools, and best practices. This community-driven development is dynamic and evolving, and it’s often where new developments begin.</p>

<p>However, the open source/open weight approach is not without its challenges. Maintenance and support can be significant hurdles. Data privacy and security also emerge as big concerns. Transparency can be a double-edged sword, exposing a company to potential risks even as it demands significant effort to safeguard sensitive information and comply with data protection regulations. Ensuring that these models do not become a vector for security breaches requires meticulous attention and proactive measures.</p>

<p>Scalability<a contenteditable="false" data-primary="scaling" data-secondary="scalability" data-tertiary="open source LLMs" data-type="indexterm" id="id388"/> and performance are additional considerations. Open source LLMs aren’t always optimized for large-scale deployments. Companies with substantial operational demands might face performance bottlenecks or scalability challenges. The customization required to adapt open source models for enterprise-grade applications can be resource intensive and require significant engineering efforts.</p>

<p>Open source and<a contenteditable="false" data-primary="security" data-secondary="open source LLMs" data-type="indexterm" id="id389"/> open weight language models also introduce security concerns. Anyone can immediately use, fine-tune, or modify pretrained open weight models and potentially apply them in harmful ways, such as generating misinformation, creating realistic fake content, or deploying automated tools for phishing and social engineering<a contenteditable="false" data-primary="social engineering attacks" data-type="indexterm" id="id390"/>. Since open weight models’ training data often includes both public and proprietary datasets, they can also sometimes unintentionally generate or reveal sensitive or biased information embedded in the training data, posing privacy risks.</p>

<p>Furthermore, open source models, which include the code and architectural blueprints, are vulnerable to manipulation and exploitation. Malicious actors can introduce harmful code or adjust models to bypass safety mechanisms, then distribute these altered versions under the guise of legitimate software. This can lead to scenarios where organizations unknowingly adopt models that include backdoors or biased, harmful outputs. The decentralized nature of open source development means that code modifications don’t always go through rigorous security checks, leaving room for vulnerabilities that could be exploited. Addressing these security challenges requires adopting responsible AI practices, including rigorous code reviews, security audits, and clear usage policies to mitigate risks while promoting open collaboration.</p>

<p>Carefully review any contractual restrictions on usage before adopting a model. You don’t want to build a whole commercial application around an open source LLM only to find out that it does not allow <a contenteditable="false" data-primary="open weight LLMs" data-startref="icd108" data-type="indexterm" id="id391"/>commercial <a contenteditable="false" data-primary="open source LLMs" data-secondary="proprietary LLMs versus" data-startref="icd107" data-type="indexterm" id="id392"/>usage.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Closed-source LLMs"><div class="sect3" id="ch01_closed_source_llms_1748895465616044">
<h3>Closed-source LLMs</h3>

<p>On<a contenteditable="false" data-primary="proprietary (closed-source) LLMs" data-secondary="overview of" data-type="indexterm" id="id393"/><a contenteditable="false" data-primary="closed-source LLMs" data-see="proprietary LLMs" data-type="indexterm" id="id394"/> the other side of the spectrum are <em>closed-source</em>, or <em>proprietary</em>, LLMs such as those developed by leading tech giants. These models often come with robust support and maintenance, including dedicated assistance for troubleshooting and optimizing performance. This support infrastructure ensures that any issues encountered are addressed promptly, allowing companies to focus on their core activities without getting sidetracked by technical difficulties.</p>

<p>Closed-source LLMs are generally optimized for large-scale deployments, making sure that they can scale with operational loads effectively, so they often come with performance guarantees. Their performance benchmarks often reflect their ability to deliver consistent and reliable results—a critical factor for companies with high operational demands.</p>

<p>One of the primary limitations of the closed-source approach is the high cost. Another is the lack of transparency, which means that companies have limited <span class="keep-together">visibility</span> into the internal workings of these models. While this concern may seem unusual, consider a scenario in which a commercial LLM provider inadvertently consumes private data during training. You use this LLM provider for your own application, and some of your users realize how to get your application to reveal the private data. The people whose data was revealed sue you. We recommend that you fully understand what legal protections are in place when using information services like third-party LLMs.</p>

<p>Regardless of these drawbacks, companies are willing to make expensive bets right now, hoping for excellent returns in the future from investing in <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="choosing" data-startref="icd106" data-tertiary="open source versus proprietary LLMs" data-type="indexterm" id="id395"/>GenAI <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="choosing" data-startref="icd105" data-type="indexterm" id="id396"/>applications.</p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Enterprise Use Cases for LLMs"><div class="sect1" id="ch01_enterprise_use_cases_for_llms_1748895465616095">
<h1>Enterprise Use Cases for LLMs</h1>

<p>LLMs <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="enterprise use cases for" data-type="indexterm" id="icd109"/>are transforming enterprise operations in many industries, from changing how we retrieve knowledge to enhancing autonomous agents. They do this through a handful of applications, including knowledge retrieval, translation, audio–speech synthesis, recommender systems, and autonomous agents.</p>

<section data-type="sect2" data-pdf-bookmark="Knowledge Retrieval"><div class="sect2" id="ch01_knowledge_retrieval_1748895465616145">
<h2>Knowledge Retrieval</h2>

<p>People <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="enterprise use cases for" data-tertiary="knowledge retrieval" data-type="indexterm" id="id397"/><a contenteditable="false" data-primary="knowledge retrieval" data-type="indexterm" id="id398"/>have long used search engines to discover information, but the limitations of these tools’ have become more apparent as data volumes and complexity grow. LLMs offer a new paradigm for accessing and using information. Unlike conventional systems, which rely heavily on keyword matching and ranking algorithms, LLMs bring a conversational, personalized approach to information retrieval.</p>

<p>Users can engage in long conversations with LLMs. Instead of simply receiving a list of links or documents, they can set parameters for the tone, intent, and structure of the information they need. This capability transforms the search experience from a transactional process into a dynamic dialogue. For example, an LLM can interpret a request like “Explain this concept as if I were a beginner,” and provide a tailored explanation that’s both accessible and relevant.</p>

<p>On the data retrieval side, LLMs can enhance productivity tools, for example through integrations with office software suites like those from Google and Microsoft. Imagine querying a spreadsheet with natural language to extract insights or asking a document to summarize key points. This simplifies data management and makes complex information more accessible. Furthermore, LLMs can integrate with internal systems to automate routine tasks and create knowledge graphs, streamlining <a contenteditable="false" data-primary="workflows" data-type="indexterm" id="id399"/>workflows and enhancing organizational efficiency. However, while LLMs improve the accuracy and relevance of information retrieval, they also require meticulous handling to ensure data privacy and system security.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Translation"><div class="sect2" id="ch01_translation_1748895465616191">
<h2>Translation</h2>

<p>Translation<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="enterprise use cases for" data-tertiary="translation" data-type="indexterm" id="id400"/><a contenteditable="false" data-primary="translation" data-type="indexterm" id="id401"/> is another domain where LLMs are being used heavily. Traditional machine translation systems often struggled with languages for which they had limited datasets, as they had to rely on statistical methods. LLMs are changing this by offering zero-shot and few-shot translation capabilities. <em>Zero-shot<a contenteditable="false" data-primary="zero-shot translation" data-type="indexterm" id="id402"/> </em>refers to the model’s ability to translate languages without prior examples, a feat that was previously challenging.<a contenteditable="false" data-primary="few-shot translation" data-type="indexterm" id="id403"/> <em>Few-shot</em>, on the other hand, allows LLMs to perform well with minimal data.</p>

<p>This is particularly advantageous for translating languages that are underrepresented in training datasets. For companies involved in global operations or content creation, this is a major selling point. It eases localization of content, such as subtitling films or translating marketing materials, without extensive data requirements, allowing companies to expand into new markets without investing too many resources up front.</p>

<p>LLMs trained on multilingual datasets can easily adapt to new languages, allowing translations across a broader spectrum of languages, including those with sparse resources. The applications for this extend to literature, film, and even real-time communication, where accurate and contextually appropriate translation can be helpful.</p>

<p>Yet, while LLMs offer significant improvements over traditional translation methods, maintaining accuracy and handling idioms still remain open challenges.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Speech Synthesis"><div class="sect2" id="ch01_speech_synthesis_1748895465616237">
<h2>Speech Synthesis</h2>

<p>The <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="enterprise use cases for" data-tertiary="speech synthesis" data-type="indexterm" id="id404"/><a contenteditable="false" data-primary="speech synthesis" data-type="indexterm" id="id405"/>ability to generate speech that resonates with human listeners can significantly enhance user experience and interaction.<em> Speech synthesis</em>, generating audio that mimics human speech from text, is another area where LLMs are making remarkable progress. Historically, speech synthesis systems have struggled with creating natural and engaging audio outputs: the sound generated sounded clearly “robotic.” LLMs, however, have the potential to revolutionize this field by generating human-like speech with impressive fidelity. With training on text and audio datasets, LLMs can understand and replicate the subtleties of human speech, such as intonation, rhythm, and stress.</p>

<p>This is useful for applications like virtual assistants, realistic voice-overs for characters in video games, or engaging audio content for educational materials. Using LLMs to automate the creation of speech content makes it easy for businesses to produce large volumes of content without the time and costs of extensive manual recording. However, audio–speech synthesis still has room to improve, especially with regard to recognizing accents and other variations in speech.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Recommender Systems"><div class="sect2" id="ch01_recommender_systems_1748895465616284">
<h2>Recommender Systems</h2>

<p>Recommender<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="enterprise use cases for" data-tertiary="recommender systems" data-type="indexterm" id="id406"/><a contenteditable="false" data-primary="recommender systems" data-type="indexterm" id="id407"/> systems are at the heart of many digital platforms, from ecommerce to streaming services. LLMs enhance these systems by incorporating a deeper understanding of users’ preferences and contextual factors. Earlier recommender systems relied on historical user data and predefined algorithms, which often led to limited or repetitive suggestions. LLMs, with their ability to process and interpret diverse data sources, offer a more nuanced approach.</p>

<p>LLM-powered recommender systems can analyze user interactions, preferences, and even conversational cues, including audio and video inputs, to deliver personalized recommendations in real time. For example, if a user describes a product in natural language and provides an image, the LLM can integrate both modalities to offer more relevant suggestions, even in response to ambiguous or vague requests.</p>

<p>Despite these advantages, many challenges remain unsolved. For example, maintaining user trust requires careful attention to the model’s transparency and reasoning.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Autonomous AI Agents"><div class="sect2" id="ch01_autonomous_ai_agents_1748895465616330">
<h2>Autonomous AI Agents</h2>

<p><em>AI agents</em> are<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="enterprise use cases for" data-tertiary="AI agents" data-type="indexterm" id="id408"/><a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="AI agents" data-type="indexterm" id="icd101x"/> designed to perform specific tasks autonomously, leveraging LLMs to execute complex operations that would otherwise require human intervention.</p>

<p>For example, in a customer service environment, traditional automated agent systems might follow rigid scripts or rely on basic rule-based logic. LLM-powered AI agents, however, can engage in dynamic, context-aware conversations. They understand user queries more deeply, interpret intent more accurately, and generate responses that are more natural and engaging.</p>

<p>In project management, LLMs can power intelligent project assistants that manage schedules, set reminders, and even draft project reports. These AI agents can interact with team members, understand project requirements, and adapt their responses to ongoing developments.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Agentic Systems"><div class="sect2" id="ch01_agentic_systems_1748895465616377">
<h2>Agentic Systems</h2>

<p><em>Agentic systems</em> represent<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="enterprise use cases for" data-tertiary="agentic systems" data-type="indexterm" id="id409"/><a contenteditable="false" data-primary="agentic systems" data-secondary="overview of" data-type="indexterm" id="id410"/> a more novel application of LLMs, where AI agents not only perform tasks but also make strategic decisions. These systems leverage LLMs’ data processing and analysis capabilities to discern patterns and make informed decisions in real time. This is particularly helpful in environments where decisions need to be based on complex, multifaceted information (as shown by the example workflow in <a data-type="xref" href="#ch01_figure_2_1748895465600898">Figure 1-2</a>).</p>

<figure><div id="ch01_figure_2_1748895465600898" class="figure"><img alt="" src="assets/llmo_0102.png" width="1435" height="770"/>
<h6><span class="label">Figure 1-2. </span>Agentic AI in the enterprise (source: <a href="https://oreil.ly/NapOi">Haptik</a>)</h6>
</div></figure>

<p>In finance, agentic systems can digest data from financial reports, news articles, and market analytics, then use it to analyze market trends, assess risk factors, and make investment recommendations that align with investment strategies.</p>

<p>Similarly, in supply chain management, agentic systems can optimize inventory levels, predict demand fluctuations, and coordinate logistics based on data from various sources—such as sales forecasts, supply chain disruptions, and production schedules.</p>

<p>However, these systems aren’t always reliable. Integrating them into existing workflows requires careful planning. Companies must consider how AI agents and agentic systems will interact with human teams, how they will be managed, and how their outputs will be monitored. Clear guidelines and oversight mechanisms are essential to ensure that these systems complement rather than disrupt existing operations. These issues are discussed in <a data-type="xref" href="ch08.html#ch08_governance_monitoring_privacy_and_security_1748896766177413">Chapter 8</a>.</p>

<p>Data security and privacy are also big concerns. LLMs handle vast amounts of sensitive information, and protecting it from breaches or misuse is key. You need to establish strong data governance policies and invest in security measures to safeguard against potential risks. These issues, too, are discussed<a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="AI agents" data-startref="icd101x" data-type="indexterm" id="id411"/><a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="enterprise use cases for" data-startref="icd109" data-type="indexterm" id="id412"/> in <a data-type="xref" href="ch08.html#ch08_governance_monitoring_privacy_and_security_1748896766177413">Chapter 8</a>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Ten Challenges of Building with LLMs"><div class="sect1" id="ch01_ten_challenges_of_building_with_llms_1748895465616430">
<h1>Ten Challenges of Building with LLMs</h1>

<p>LLMs <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-type="indexterm" id="icd110"/>introduce several new challenges, which can be amplified by the enormous scale of LLMs and their numerous applications. Addressing these challenges is important for integrating and deploying LLMs in production. Following is a list of 10 challenges with pointers to the chapters in this book where they are addressed.</p>

<section data-type="sect2" data-pdf-bookmark="1. Size and Complexity"><div class="sect2" id="ch01_section_1_size_and_complexity_1748895465616485">
<h2>1. Size and Complexity</h2>

<p>LLMs <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="size and complexity" data-type="indexterm" id="id413"/><a contenteditable="false" data-primary="complexity, challenge of" data-seealso="evaluation" data-type="indexterm" id="id414"/>generally have millions or even billions of parameters. This makes training, monitoring, and evaluating them extremely complex. Moreover, being generative models, they can fail silently, producing <a contenteditable="false" data-primary="hallucinations" data-type="indexterm" id="id415"/>hallucinations and inaccurate information. Addressing this requires a structured approach that not only includes benchmarks commonly used for machine learning but also adds several other techniques; <a data-type="xref" href="ch07.html#ch07_evaluation_for_llms_1748896751667823">Chapter 7</a> explores this topic further.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="2. Training Scale and Duration"><div class="sect2" id="ch01_section_2_training_scale_and_duration_1748895465616534">
<h2>2. Training Scale and Duration</h2>

<p>Training<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="training scale and duration" data-type="indexterm" id="id416"/><a contenteditable="false" data-primary="scaling" data-secondary="challenge of" data-type="indexterm" id="icd111"/> LLMs requires processing large datasets. This is difficult not only from the data management perspective but also in terms of the memory and computational resources required for training the models. We discuss this in <a data-type="xref" href="ch03.html#ch03_llm_based_applications_1748895493844515">Chapter 3</a>.</p>

<p>Training LLMs can take days, weeks, or even months, and managing parallel and distributed training across large clusters of GPUs and TPUs requires specialized hardware and organizational skills. This means that hardware represents a major dependency on external organizations and market availability, one that requires careful, systematic planning. We discuss this in <a data-type="xref" href="ch09.html#ch09_scaling_hardware_infrastructure_and_resource_ma_1748896826216961">Chapter 9</a>.</p>

<p>Handling large, potentially sensitive training datasets requires careful security measures and anonymization, as discussed in <a data-type="xref" href="ch02.html#ch02_introduction_to_llmops_1748895480208948">Chapter 2</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="3. Prompt Engineering"><div class="sect2" id="ch01_section_3_prompt_engineering_1748895465616583">
<h2>3. Prompt Engineering</h2>

<p>One <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="prompt engineering" data-type="indexterm" id="id417"/><a contenteditable="false" data-primary="prompt engineering" data-secondary="challenge of" data-type="indexterm" id="id418"/>of the most common ways to make an LLM work better for a specific problem is prompt engineering, the science and art of crafting the text inputs that are sent to the models. Prompt updates can significantly improve or degrade the user experience. But prompt engineering is iterative and can be difficult to master and document, especially with closed-source LLMs. You’ll find a discussion of this in <a data-type="xref" href="ch05.html#ch05_model_domain_adaptation_for_llm_based_applications_1748896666813361">Chapter 5</a>.</p>

<p>Updates of proprietary models, like <a contenteditable="false" data-primary="OpenAI" data-secondary="GPT series" data-type="indexterm" id="id419"/><a contenteditable="false" data-primary="generative pretrained transformer (GPT) series" data-type="indexterm" id="id420"/><a contenteditable="false" data-primary="GPT (generative pretrained transformer) series" data-type="indexterm" id="id421"/>OpenAI’s GPT-4, can result in significant<a contenteditable="false" data-primary="model drift" data-type="indexterm" id="id422"/> <em>model drift</em>, <a contenteditable="false" data-primary="drift" data-type="indexterm" id="id423"/>where the same inputs suddenly provide a different output due to a model update. Model drift requires effort and financial commitment to fix. This becomes additionally complex when there are many interdependent prompts connected to each other, such as in an<a contenteditable="false" data-primary="orchestration frameworks" data-type="indexterm" id="id424"/> <em>orchestration framework</em> (i.e., a structured platform used to automate, coordinate, and manage complex tasks and services) and there’s a change in the underlying model, as the entire complex prompt chain can break in unexpected and hard-to-detect ways. If your infrastructure relies heavily on prompt-engineering pipelines, monitoring is crucial; <a data-type="xref" href="ch07.html#ch07_evaluation_for_llms_1748896751667823">Chapter 7</a> goes into this in more depth.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="4. Inference Latency and Throughput"><div class="sect2" id="ch01_section_4_inference_latency_and_throughput_1748895465616629">
<h2>4. Inference Latency and Throughput</h2>

<p>Responses<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="inference latency and throughput" data-type="indexterm" id="id425"/><a contenteditable="false" data-primary="latency" data-secondary="of inferences" data-secondary-sortas="inferences" data-type="indexterm" id="id426"/><a contenteditable="false" data-primary="throughput" data-type="indexterm" id="id427"/> provided by LLMs are also called <em>inferences</em>. LLMs are often deployed in applications that require real-time or near-real-time responses, which means that optimizing for speed becomes important. This can be especially complex with dynamic models like LLMs. Also, maintaining high throughput without having access to model parameters can add complexity for LLMOps teams. Edge devices used in IoT applications introduce even more challenges related to limited computational resources and varying network conditions. These issues are discussed in <a data-type="xref" href="ch09.html#ch09_scaling_hardware_infrastructure_and_resource_ma_1748896826216961">Chapter 9</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="5. Ethical Considerations"><div class="sect2" id="ch01_section_5_ethical_considerations_1748895465616675">
<h2>5. Ethical Considerations</h2>

<p>Like <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="ethical considerations" data-type="indexterm" id="id428"/><a contenteditable="false" data-primary="ethics" data-secondary="challenge of" data-type="indexterm" id="id429"/>any other machine learning model, LLMs generate outputs based on the data that they have been trained on. LLMs applications are frequently designed to create the experience of chatting with a human instead of a machine, making them accessible to a much larger user base than specialized machine learning systems and greatly increasing the impact of potential biases introduced by the training data.</p>

<p><a data-type="xref" href="ch07.html#ch07_evaluation_for_llms_1748896751667823">Chapter 7</a> discusses techniques for monitoring LLM outputs, and the privacy and ethical implications of their use are explained in <a data-type="xref" href="ch08.html#ch08_governance_monitoring_privacy_and_security_1748896766177413">Chapter 8</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="6. Resource Scaling and Orchestration"><div class="sect2" id="ch01_section_6_resource_scaling_and_orchestration_1748895465616721">
<h2>6. Resource Scaling and Orchestration</h2>

<p>The <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="resource scaling and orchestration" data-type="indexterm" id="id430"/>scale at which LLMs operate often requires load balancing and dynamic resource scaling. Different proprietary models can also behave very differently based on the use case, and constant scenario modeling is expensive and time intensive. <a data-type="xref" href="ch05.html#ch05_model_domain_adaptation_for_llm_based_applications_1748896666813361">Chapter 5</a> explores how to manage dependencies across various components in distributed multi-model environments, ensuring reliability and <a contenteditable="false" data-primary="scaling" data-secondary="challenge of" data-startref="icd111" data-type="indexterm" id="id431"/>scalability.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="7. Integrations and Toolkits"><div class="sect2" id="ch01_section_7_integrations_and_toolkits_1748895465616768">
<h2>7. Integrations and Toolkits</h2>

<p>LLMs<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="integrations and toolkits" data-type="indexterm" id="id432"/> require several new integrations and toolkits that are adapted to both generative as well as discriminative use cases and involve communicating with various APIs. Integrating these LLMs into existing systems requires robust security protocols to prevent vulnerabilities and potential misuse. Changes in LLMs and version management, discussed in <a data-type="xref" href="ch08.html#ch08_governance_monitoring_privacy_and_security_1748896766177413">Chapter 8</a>, can also lead to compatibility issues across the stack.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="8. Broad Applicability"><div class="sect2" id="ch01_section_8_broad_applicability_1748895465616814">
<h2>8. Broad Applicability</h2>

<p>LLMs <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="broad applicability" data-type="indexterm" id="id433"/>are adaptable and easy to use, which means that they can be applied to numerous consumer-facing applications, as we will see in <a data-type="xref" href="ch03.html#ch03_llm_based_applications_1748895493844515">Chapter 3</a>. This makes them more likely to be exposed to untested scenarios than traditional machine learning systems, and thus they require a faster feedback loop to monitor and improve their performance. <a data-type="xref" href="ch07.html#ch07_evaluation_for_llms_1748896751667823">Chapter 7</a> addresses monitoring techniques.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="9. Privacy and Security"><div class="sect2" id="ch01_section_9_privacy_and_security_1748895465616860">
<h2>9. Privacy and Security</h2>

<p>Collecting<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="privacy and security" data-type="indexterm" id="id434"/><a contenteditable="false" data-primary="privacy" data-secondary="challenge of" data-type="indexterm" id="id435"/><a contenteditable="false" data-primary="security" data-secondary="challenge of" data-type="indexterm" id="id436"/> real-time information involves handling user data, sometimes including personally identifying information (PII). This means that security and privacy become the cornerstone of maintaining trust and regulatory compliance. This challenge extends well beyond inference monitoring, touching the domain of <span class="keep-together">cybersecurity.</span></p>

<p>Even companies such as OpenAI<a contenteditable="false" data-primary="OpenAI" data-secondary="database leaks" data-type="indexterm" id="id437"/> have <a href="https://oreil.ly/yqPpG">received reports about database leaks</a> into user accounts that made chat interactions visible to unauthorized users. We talk more about privacy and security in <a data-type="xref" href="ch08.html#ch08_governance_monitoring_privacy_and_security_1748896766177413">Chapter 8</a>.</p>

<p>Regularly auditing your data management processes, both internally and externally, is also vital for enhancing user trust and complying with legal requirements. Best practices for data management are discussed in <a data-type="xref" href="ch04.html#ch04_data_engineering_for_llms_1748895507364914">Chapter 4</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="10. Costs"><div class="sect2" id="ch01_section_10_costs_1748895465616906">
<h2>10. Costs</h2>

<p>One <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-tertiary="costs" data-type="indexterm" id="id438"/><a contenteditable="false" data-primary="costs" data-secondary="challenge of" data-type="indexterm" id="id439"/>of the biggest considerations for LLMs is cost, both immediate and long-term. While most transformer models require expensive training, maintaining and scaling LLMs incurs the highest costs, especially in the inference stages. You could end up paying even for failed requests, so experimenting with model performance can become very expensive very quickly for companies building on <a contenteditable="false" data-primary="proprietary (closed-source) LLMs" data-secondary="costs" data-type="indexterm" id="id440"/>closed and proprietary models.</p>

<p>Even in open source models, excessive fine-tuning can quickly lead to a phenomenon<a contenteditable="false" data-primary="overfitting" data-type="indexterm" id="id441"/> called <em>overfitting</em>,<a contenteditable="false" data-primary="open source LLMs" data-secondary="overfitting" data-type="indexterm" id="id442"/> where the model appears to perform extremely well because it learns the training dataset but does not generalize to the unseen data that will be presented to it by real users. There are always trade-offs between generalization ability and cost; these are explored <a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="challenges of building" data-startref="icd110" data-type="indexterm" id="id443"/>in <a data-type="xref" href="ch05.html#ch05_model_domain_adaptation_for_llm_based_applications_1748896666813361">Chapter 5</a>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="ch01_conclusion_1748895465616950">
<h1>Conclusion</h1>

<p>Adopting LLMs requires careful consideration and strategic planning to navigate these intricate challenges, and organizations require a new discipline and a set of new tools to succeed. We call this discipline LLMOps, and we start our journey by defining it in the next <a contenteditable="false" data-primary="LLMs (large language models)" data-startref="icd101" data-type="indexterm" id="id444"/>​chapter.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="References"><div class="sect1" id="ch01_references_1748895465616994">
<h1>References</h1>

<p>Dao, Tri, and Albert Gu. <a href="https://oreil.ly/POlHU">“Transformers Are SSMs: Generalized Models and Efficient Algorithms Through Structured State Space Duality”</a>, arXiv, May 31, 2024.</p>

<p>Devlin, Jacob, et al. <a href="https://oreil.ly/84NM2">“BERT: Pre-Training of Deep Bidirectional Transformers for Language Understanding”</a>, arXiv, May 24, 2019.</p>

<p>Haptik. n.d. <a href="https://oreil.ly/CO7uA">“A Comprehensive Guide to Agentic AI”</a>, Accessed May 21, 2025.</p>

<p>OpenAI. <a href="https://oreil.ly/5kdkr">“March 20 ChatGPT Outage: Here’s What Happened”</a>, March 24, 2023.</p>

<p>Vaswani, Ashish, et al. “Attention Is All You Need”, In <a href="https://oreil.ly/hfTxe"><em>NIPS’17: Proceedings of the 31st International Conference on Neural Information Processing Systems</em></a>, edited by Ulrike von Luxburg, Isabelle Guyon, Samy Bengio, Hanna Wallach, and Rob Fergus (Curran Associates, 2017).</p>

<p>Wang, Sarah, and Shangda Xu. <a href="https://oreil.ly/yRrmR">“16 Changes to the Way Enterprises Are Building and Buying Generative AI”</a>, Andreessen Horowitz, March 21, 2024.</p>
</div></section>
</div></section></div></div></body></html>