<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">6</span> </span> <span class="chapter-title-text">Constructing knowledge graphs with LLMs</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header">This chapter covers </h3>
<ul>
<li class="readable-text" id="p2">Structured data extraction</li>
<li class="readable-text" id="p3">Different approaches to extraction</li>
</ul>
</div>
<div class="readable-text" id="p4">
<p>In this chapter, you will explore the process of constructing knowledge graphs using LLMs from unstructured sources like text documents. The focus will be on how LLMs can extract and structure data from raw text, transforming it into usable formats for building knowledge graphs.</p>
</div>
<div class="readable-text intended-text" id="p5">
<p>In previous chapters, you learned about basic techniques for document chunking, embedding, and retrieval (chapter 2), as well as more advanced methods for improving retrieval accuracy (chapter 3). However, as you learned in chapter 4, relying solely on text embeddings can lead to challenges in scenarios where data needs to be structured to answer questions that require filtering, counting, or aggregation operations. To solve the limitations of only using text embeddings, you will learn how to transform unstructured data into structured formats suitable for knowledge graph construction, using LLMs for automated data extraction. By the end of the chapter, you will be able to extract structured information from raw text, design a knowledge graph model for the extracted data, and import this data into a graph database.</p>
</div>
<div class="readable-text intended-text" id="p6">
<p>You’ll begin by exploring a common challenge in legal document retrieval---managing multiple contracts and their terms---and learn how structured data extraction provides a solution. Throughout the chapter, you’ll follow examples that illustrate the process and guide you step by step through the workflow of constructing a knowledge graph from unstructured text.</p>
</div>
<div class="readable-text" id="p7">
<h2 class="readable-text-h2"><span class="num-string">6.1</span> Extracting structured data from text</h2>
</div>
<div class="readable-text" id="p8">
<p>Much of the information found online, and even within companies, exists in unstructured formats like various documents. However, there are situations where the simple retrieval technique using only text embeddings falls short. Legal documents are one such example. </p>
</div>
<div class="readable-text intended-text" id="p9">
<p>For instance, if you’re asking about the payment terms in a contract with ACME Inc., it’s crucial to ensure that the terms are actually from that specific contract and not from others. When you simply chunk and retrieve across multiple legal documents, the top <code>k</code> chunks you get at retrieval could come from different, unrelated documents, causing confusion, as shown in figure 6.1.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p10">
<img alt="figure" height="634" src="../Images/6-1.png" width="929"/>
<h5 class="figure-container-h5"><span class="num-string">Figure 6.1</span> Basic vector retrieval strategy might return chunks from various contracts.</h5>
</div>
<div class="readable-text" id="p11">
<p>Figure 6.1 illustrates how contract documents are broken down into text chunks and indexed using text embeddings. When an end user asks a specific question, such as about the payment terms of a particular contract, the system retrieves the most relevant chunks. However, if multiple contracts contain different payment terms, the retrieval process may unintentionally pull information from various documents, mixing relevant chunks from the target contract with irrelevant ones from others. This happens because the system focuses on retrieving top-ranked text chunks based on similarity, without always distinguishing whether the chunks come from the correct contract. As a result, chunks that share keywords like “payment” or “terms” but belong to different contracts may be included, leading to a fragmented and inconsistent view of the terms. This confusion can then be responsible when the LLM tries to synthesize these mixed chunks into a coherent answer, ultimately increasing the risk of inaccurate or misleading information.</p>
</div>
<div class="readable-text intended-text" id="p12">
<p>Additionally, consider the following question: How many active contracts do we currently have with ACME Inc.? To answer this, you would first need to filter all contracts based on their active status and then count the relevant ones. These types of queries resemble traditional business intelligence questions, where the text-embedding approach falls short.</p>
</div>
<div class="readable-text intended-text" id="p13">
<p>Text embeddings are primarily designed to retrieve semantically similar content, not to handle operations like filtering, sorting, or aggregating data. To handle such operations, structured data is required, as text embeddings alone are not well-suited for these operations.</p>
</div>
<div class="readable-text intended-text" id="p14">
<p>For some domains, structuring data is vital when implementing RAG applications. Luckily, LLMs excel at extracting structured data from text due to their deep understanding of natural language, allowing them to identify relevant information accurately. They can be finetuned or guided through specific prompts to locate and extract required data points, converting unstructured information into a structured format like tables or key–value pairs. Using LLMs for structured data extraction is particularly useful when dealing with large volumes of documents where manually identifying and organizing such information would be labor intensive and time consuming. By automating the extraction process, LLMs enable businesses to transform unstructured information into actionable, structured data, which can then be used for further analysis or RAG applications.</p>
</div>
<div class="readable-text intended-text" id="p15">
<p>Imagine you’re working at a company as a software engineer, and you’re part of a team tasked with building a chatbot that can answer questions based on the company’s legal documents. Since this is a large-scale project, the team is divided into two groups: one focused on data preparation and the other on implementing the retrieval systems described in chapters 4 and 5. You’re assigned to the data preparation team, where your job is to process legal documents and extract structured information. This information will be used to build a knowledge graph, following the workflow visualized in figure 6.2.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p16">
<img alt="figure" height="479" src="../Images/6-2.png" width="1012"/>
<h5 class="figure-container-h5"><span class="num-string">Figure 6.2</span> Building knowledge graphs from text by using LLMs to extract structured data information</h5>
</div>
<div class="readable-text intended-text" id="p17">
<p>The workflow visualized in figure 6.2 begins with contract documents as input, which are processed using an LLM to extract structured information. In the legal domain, you can extract various details such as involved parties, dates, terms, and more. Here, the structured output is represented in a JSON format, and this structured information is then stored in Neo4j, which will serve as the foundation for the legal chatbot’s data retrieval.</p>
</div>
<div class="readable-text intended-text" id="p18">
<p>These two examples highlight the limitations of simple text embeddings when it comes to handling specific, structured queries, such as asking for payment terms in a contract or counting active agreements. In both cases, accurate answers require structured data rather than relying solely on the semantic similarity of unstructured text. In the remainder of this chapter, we’ll dive deeper into how LLMs can be effectively used to extract structured data from complex documents and how this structured output plays a critical role in constructing reliable knowledge graphs for advanced retrieval tasks. To follow along, you’ll need access to a running, blank Neo4j instance. This can be a local installation or a cloud-hosted instance; just make sure it’s empty. You can follow the implementation directly in the accompanying Jupyter notebook available here: <a href="https://github.com/tomasonjo/kg-rag/blob/main/notebooks/ch06.ipynb">https://github.com/tomasonjo/kg-rag/blob/main/notebooks/ch06.ipynb</a>.</p>
</div>
<div class="readable-text intended-text" id="p19">
<p>Let’s dive in.</p>
</div>
<div class="readable-text" id="p20">
<h3 class="readable-text-h3"><span class="num-string">6.1.1</span> Structured Outputs model definition</h3>
</div>
<div class="readable-text" id="p21">
<p>Extracting structured data from text is not a new idea; it has been a vital task in data processing for many years. Historically, this process was known as <em>information extraction</em> and required complex systems, often relying on multiple machine learning models working together. These systems were typically expensive to build and maintain, requiring a team of skilled engineers and domain experts to ensure they functioned correctly. Due to these reasons, only large organizations with substantial resources could afford to implement such solutions. The high cost and technical barriers made it inaccessible for many businesses and individuals. However, advancements in LLMs have dramatically simplified the process. Today, users can prompt an LLM to extract structured information with a much lower technical threshold instead of building and training multiple models. This shift has opened up a wide range of use cases for structured data extraction. </p>
</div>
<div class="readable-text intended-text" id="p22">
<p>Extracting structured data using LLMs has become such a common use case that OpenAI introduced a Structured Outputs feature in its API to simplify and standardize the process. This feature allows developers to define the expected output format ahead of time, ensuring that the model’s response adheres to a specific structure. Structured Outputs is not a separate library; it is a built-in capability of the OpenAI API, available through function calling or schema definitions. For example, in Python, developers often use libraries like Pydantic to define data schemas. These schemas can then be passed to the model, guiding it to produce outputs that match the specified format, as shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p23">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.1</span> Defining the desired output using the Pydantic library</h5>
<div class="code-area-container">
<pre class="code-area">from pydantic import BaseModel

class CalendarEvent(BaseModel):
    name: str
    date: str = Field(..., description="The date of the event. Use yyyy-MM-dd format")
    participants: list[str]</pre>
</div>
</div>
<div class="readable-text" id="p24">
<p>The <code>CalendarEvent</code> class in listing 6.1 represents a structured way to capture details about an event. It includes a name for the event, a date when it will occur, and a list of participants. By defining these attributes explicitly, it ensures that any event data conforms to this structure, making it easier to extract and work with event information in a reliable and consistent manner. The available types for attributes are </p>
</div>
<ul>
<li class="readable-text" id="p25"> String </li>
<li class="readable-text" id="p26"> Number </li>
<li class="readable-text" id="p27"> Boolean </li>
<li class="readable-text" id="p28"> Integer </li>
<li class="readable-text" id="p29"> Object </li>
<li class="readable-text" id="p30"> Array </li>
<li class="readable-text" id="p31"> Enum </li>
<li class="readable-text" id="p32"> anyOf </li>
</ul>
<div class="readable-text" id="p33">
<p>Let’s examine the definition of the <code>date</code> attribute. </p>
</div>
<div class="browsable-container listing-container" id="p34">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.2</span> <code>date</code> attribute</h5>
<div class="code-area-container">
<pre class="code-area">date: str = Field(..., description="The date of the event. Use yyyy-MM-dd format")</pre>
</div>
</div>
<div class="readable-text" id="p35">
<p>The code in listing 6.2 provides instructions on how to extract data for the <code>date</code> attribute. Naming the attribute <code>date</code> signals to the model to focus on date-related information. By using the <code>str</code> type, we specify that the extracted information should be represented as a string, as there’s no native datetime type available. Additionally, the <code>description</code> clarifies the desired <code>yyyy-MM-dd</code> format. This step is crucial because, although the model knows it’s dealing with a string, the description ensures that the date follows the specific format. Without this guidance, the <code>str</code> type alone might not convey enough detail about the expected output structure. </p>
</div>
<div class="readable-text intended-text" id="p36">
<p>Structured Outputs significantly simplifies the development process by ensuring that the LLM responses adhere to a predefined schema. This reduces the need for post-processing and validation, allowing developers to focus on using the data within their systems. The feature provides type safety, guaranteeing that responses are always correctly formatted, and eliminates the need for complex prompts to achieve consistent output, making the process more efficient and reliable overall.</p>
</div>
<div class="readable-text intended-text" id="p37">
<p>The first step in extracting structured output from legal documents is to define the contract data model that needs to be extracted. Since you’re a software engineer and not a legal expert, it’s important to consult someone with domain knowledge to determine which information is most important to extract. Additionally, speaking with end users about the specific questions they want answered can provide valuable insights.</p>
</div>
<div class="readable-text intended-text" id="p38">
<p>Following these initial discussions, you propose the contract data model shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p39">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.3</span> Defining the desired output using a Pydantic object</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">class Contract(BaseModel):
    """
    Represents the key details of the contract.  <span class="aframe-location"/> #1
    """

    contract_type: str = Field(
        ...,
        description="The type of contract being entered into.",
        enum=contract_types,  <span class="aframe-location"/> #2
    )
    parties: List[Organization] = Field(  <span class="aframe-location"/> #3
        ...,
        description="List of parties involved in the contract, with details of each party's role.",
    )
    effective_date: str = Field(
        ...,
        description="The date when the contract becomes effective. Use yyyy-MM-dd format.",  <span class="aframe-location"/> #4
    )
    term: str = Field(
        ...,
        description="The duration of the agreement, including provisions for renewal or termination.",
    )
    contract_scope: str = Field(
        ...,
        description="Description of the scope of the contract, including rights, duties, and any limitations.",
    )
    end_date: Optional[str] = Field(   <span class="aframe-location"/> #5
        ...,
        description="The date when the contract becomes expires. Use yyyy-MM-
    <span class="">↪</span> dd format.",
    )
    total_amount: Optional[float] = Field(
        ..., description="Total value of the contract."
    )
    governing_law: Optional[Location] = Field(
        ..., description="The jurisdiction's laws governing the contract."
    )</pre>
<div class="code-annotations-overlay-container">
     #1 Description of the extracted object
     <br/>#2 Using enum to define the possible values an LLM can use
     <br/>#3 An attribute can be an object like the Organization in this example.
     <br/>#4 Since the datetime type isn’t available, you want to define the date format to be extracted.
     <br/>#5 You can use Optional for attributes that might not appear in all contracts.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p40">
<p>The class name, <code>Contract</code>, along with the concise docstring, “Represents the key details of the contract,” provide the LLM with a high-level understanding that the desired output should capture essential contractual information. This guides the model to focus on extracting and organizing key details, such as the contract type, involved parties, dates, and financials. </p>
</div>
<div class="readable-text intended-text" id="p41">
<p>In general, attributes can be categorized as either mandatory or optional. When an attribute is optional, you designate it with an <code>Optional</code> type, indicating to the LLM that the information may or may not be present. It’s vital to mark attributes as optional when information could be missing, as otherwise, some LLMs may hallucinate values in an attempt to fill the gaps. For instance, <code>total_amount</code> is optional since some contracts are simply agreements with no monetary exchange. Conversely, the <code>effective_date</code> attribute is mandatory, as you expect each contract to have a starting date. </p>
</div>
<div class="readable-text intended-text" id="p42">
<p>Notice how each attribute includes a <code>description</code> value to provide clear guidance to the LLM, ensuring it extracts the desired information accurately. This is a good practice, even when some attributes seem obvious. In some cases, you may also want to specify the allowed values for a particular attribute. You can achieve this by using the <code>enum</code> parameter. For example, the <code>contract_type</code> attribute utilizes the <code>enum</code> parameter to inform the LLM of the specific categories to apply. The following listing contains the available values for the <code>contract_type</code> parameter. </p>
</div>
<div class="browsable-container listing-container" id="p43">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.4</span> Contract type enum values</h5>
<div class="code-area-container">
<pre class="code-area">contract_types = [
    "Service Agreement",
    "Licensing Agreement",
    "Non-Disclosure Agreement (NDA)",
    "Partnership Agreement",
    "Lease Agreement"
]</pre>
</div>
</div>
<div class="readable-text" id="p44">
<p>Clearly, the list in listing 6.4 is not exhaustive, as there are additional options that could be included.</p>
</div>
<div class="readable-text intended-text" id="p45">
<p>Some attributes may be more complex and can be defined as custom objects. For instance, the <code>parties</code> attribute is a list of <code>Organization</code> objects. A list is used because contracts typically involve multiple parties, and a custom object allows for extracting more than just a simple string about a specific attribute. The code in the following listing defines the <code>Organization</code> object. </p>
</div>
<div class="browsable-container listing-container" id="p46">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.5</span> Custom <code>Organization</code> object</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">class Organization(BaseModel):
    """
    Represents an organization, including its name and location.
    """

    name: str = Field(..., description="The name of the organization.")
    location: Location = Field(
        ..., description="The primary location of the organization."
    )
    role: str = Field(
        ...,
        description="The role of the organization in the contract, such as 
    <span class="">↪</span> 'provider', 'client', 'supplier', etc.",<span class="aframe-location"/> #1
    )</pre>
<div class="code-annotations-overlay-container">
     #1 You can provide possible values in the description instead of enum if you aren’t providing all possible values but only examples.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p47">
<p>The <code>Organization</code> object in listing 6.5 captures the key details of an organization involved in the contract, including its name, primary location, and role. The <code>location</code> attribute is a nested <code>Location</code> object, allowing us to structure the information into values like city, state, and country. As you can see, we can have nested objects, but the typical advice is to avoid too many levels of nested objects for better performance. For the <code>role</code> attribute, we’ve provided examples like “provider” and “client” but opted not to use an enum to avoid restricting the values. This flexibility is important, as the exact roles may vary and aren’t entirely predictable. By defining the organization this way, the LLM is guided to extract more detailed and structured information about the parties involved. </p>
</div>
<div class="readable-text intended-text" id="p48">
<p>Lastly, you need to define the <code>Location</code> object. </p>
</div>
<div class="browsable-container listing-container" id="p49">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.6</span> Custom <code>Location</code> object</h5>
<div class="code-area-container">
<pre class="code-area">class Location(BaseModel):
    """
    Represents a physical location including address, city, state, and country.
    """

    address: Optional[str] = Field(
        ..., description="The street address of the location."
    )
    city: Optional[str] = Field(..., description="The city of the location.")
    state: Optional[str] = Field(
        ..., description="The state or region of the location."
    )
    country: str = Field(
        ...,
        description="The country of the location. Use the two-letter ISO standard.",     <span class="aframe-location"/> #1
    )</pre>
<div class="code-annotations-overlay-container">
     #1 LLMs are familiar with ISO standards being used for countries, so you instruct the model to standardize values based on a specific standard.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p50">
<p>The <code>Location</code> object represents a physical address, capturing details such as the street address, city, state or region, and country. All attributes, except for the <code>country</code>, are optional, allowing flexibility when full location details may not be available. For the <code>country</code> attribute, we guide the LLM to use the two-letter ISO standard, ensuring consistency and making it easier to work with and process across different systems. This structure enables the LLM to extract standardized, usable information while allowing for incomplete or partial data when necessary. </p>
</div>
<div class="readable-text intended-text" id="p51">
<p>You’ve now defined the contract data model, which can be used to extract relevant information from the company’s contracts. This model will serve as the blueprint for guiding LLMs in structured data extraction. With a clear understanding of the data structure in place, it’s time to explore how you can effectively prompt the LLM to extract this information. </p>
</div>
<div class="readable-text" id="p52">
<h3 class="readable-text-h3"><span class="num-string">6.1.2</span> Structured Outputs extraction request</h3>
</div>
<div class="readable-text" id="p53">
<p>With the contract data model defined, you now have a data definition that LLMs can follow to extract structured information. The next step is to ensure that the LLM understands exactly how to output this data in a consistent format. This is where OpenAI’s Structured Outputs feature comes in. By using this feature, you can guide the LLM’s behavior to output data that strictly adheres to the contract model while using the same chat template introduced in previous chapters. </p>
</div>
<div class="readable-text intended-text" id="p54">
<p>The Structured Outputs documentation (<a href="https://mng.bz/oZZp">https://mng.bz/oZZp</a>) uses system messages to additionally guide the LLM to focus on the task at hand. By using a system message, as shown in the following listing, you can provide clear instructions to steer the model’s behavior effectively.</p>
</div>
<div class="browsable-container listing-container" id="p55">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.7</span> System message for structured output extraction</h5>
<div class="code-area-container">
<pre class="code-area">system_message = """
You are an expert in extracting structured information from legal documents and contracts.
Identify key details such as parties involved, dates, terms, obligations, and legal definitions.
Present the extracted information in a clear, structured format. Be concise, focusing on essential
legal content and ignoring unnecessary boilerplate language. The extracted data will be used to address
any questions that may arise regarding the contracts."""</pre>
</div>
</div>
<div class="readable-text" id="p56">
<p>It’s difficult to provide precise instructions for crafting the ideal system message. What’s clear is that you should define the domain and provide the LLM with context on how the output will be used. Beyond that, it often comes down to trial and error.</p>
</div>
<div class="readable-text intended-text" id="p57">
<p>Finally, you define a function that takes any text as input and outputs a dictionary as defined by the contract data model.</p>
</div>
<div class="browsable-container listing-container" id="p58">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.8</span> System message for structured output extraction</h5>
<div class="code-area-container">
<pre class="code-area">def extract(document, model="gpt-4o-2024-08-06", temperature=0):
    response = client.beta.chat.completions.parse(
        model=model,
        temperature=temperature,
        messages=[
            {"role": "system", "content": system_message},  <span class="aframe-location"/> #1
            {"role": "user", "content": document},   <span class="aframe-location"/> #2
        ],
        response_format=Contract, <span class="aframe-location"/> #3
    )
    return json.loads(response.choices[0].message.content)</pre>
<div class="code-annotations-overlay-container">
     #1 Passing in system message as first message
     <br/>#2 The document is passed as a user message without any additional instructions.
     <br/>#3 The output format is defined using the response_format parameters.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p59">
<p>The extract function in listing 6.8 processes a text document and returns a dictionary based on the contract data model. It utilizes the latest GPT-4o model available at the time of writing, which supports structured output. The function sends a system message to guide the LLM, followed by the raw user-provided document text without any modifications. The response is then formatted according to the <code>Contract</code> data model and returned as a dictionary. </p>
</div>
<div class="readable-text intended-text" id="p60">
<p>To see this process in action, let’s now look at how we can apply this method using a real-world dataset. Since accessing proprietary contracts can be difficult due to confidentiality, you will use a public dataset titled the Contract Understanding Atticus Dataset (CUAD). </p>
</div>
<div class="readable-text" id="p61">
<h3 class="readable-text-h3"><span class="num-string">6.1.3</span> CUAD dataset</h3>
</div>
<div class="readable-text" id="p62">
<p>While all companies have contracts and legal documents, these are typically not public due to the sensitive nature of the information they contain. For the purpose of this demonstration, we will use a single text document from the CUAD dataset (Hendrycks et al., 2021). CUAD is a specialized corpus created for training AI models to understand and review legal contracts. </p>
</div>
<div class="readable-text intended-text" id="p63">
<p>The following listing shows an improved version. The contract is available in the accompanying GitHub repository of the book, eliminating the need to download the entire dataset. The code handles opening the file and reading its content.</p>
</div>
<div class="browsable-container listing-container" id="p64">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.9</span> Reading the contract text document</h5>
<div class="code-area-container">
<pre class="code-area">with open('../data/license_agreement.txt', 'r') as file:
    contents = file.read()   <span class="aframe-location"/> #1</pre>
<div class="code-annotations-overlay-container">
     #1 Reads the file
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p65">
<p>You can now process the contract by executing the code shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p66">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.10</span> Extracting structured information from text</h5>
<div class="code-area-container">
<pre class="code-area">data = extract(contents)
print(data)</pre>
</div>
</div>
<div class="readable-text" id="p67">
<p>The results will look similar to the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p68">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.11</span> Results of the extraction</h5>
<div class="code-area-container">
<pre class="code-area">{'contract_type': 'Licensing Agreement',
 'parties': [{'name': 'Mortgage Logic.com, Inc.',
   'location': {'address': 'Two Venture Plaza, 2 Venture',
    'city': 'Irvine',
    'state': 'California',
    'country': 'US'},
   'role': 'Client'},
  {'name': 'TrueLink, Inc.',
   'location': {'address': '3026 South Higuera',
    'city': 'San Luis Obispo',
    'state': 'California',
    'country': 'US'},
   'role': 'Provider'}],
 'effective_date': '1999-02-26',
 'term': "1 year, with automatic renewal for successive one-year periods unless terminated with 30 days' notice prior to the end of the term.",
 'contract_scope': 'TrueLink grants Mortgage Logic.com a nonexclusive license to use the Interface for origination, underwriting, processing, and funding of consumer finance receivables. TrueLink will provide hosting services, including storage, response time management, bandwidth, availability, access to usage statistics, backups, internet connection, and domain name assistance. TrueLink will also provide support services and transmit credit data as permitted under applicable agreements and laws.',
 'end_date': None,
 'total_amount': None,
 'governing_law': {'address': None,
  'city': None,
  'state': 'California',
  'country': 'US'}}</pre>
</div>
</div>
<div class="readable-text" id="p69">
<p>The extracted contract data is organized into structured fields, though not all attributes are fully populated. For instance, some fields like <code>end_date</code> and <code>total_amount</code> are marked as <code>None</code>, indicating missing or unspecified information. Meanwhile, attributes such as the <code>contract_scope</code> contain more detailed, descriptive text that outlines the operational details of the agreement, such as the services provided and responsibilities. The structure includes a clear breakdown of the parties involved, their roles, and locations. The contract also specifies its start date and renewal conditions, but other financial or termination details remain undefined as they are missing in the contract. </p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p70">
<h5 class="callout-container-h5 readable-text-h5">Exercise 6.1</h5>
</div>
<div class="readable-text" id="p71">
<p>Download the CUAD dataset and explore creating various contract data models based on different types of contracts. Once you’ve defined different models, you can test and refine them by analyzing how well they capture and categorize the key legal information across the contracts.</p>
</div>
</div>
<div class="readable-text" id="p72">
<p>In this section, you successfully extracted structured data from a contract document using the CUAD dataset and the contract data model defined earlier. The LLM was guided to identify key contract details, and the results were formatted in a structured way, allowing you to organize important information such as contract type, parties, and terms. This process demonstrates how LLMs can efficiently transform unstructured legal documents into actionable data.</p>
</div>
<div class="readable-text intended-text" id="p73">
<p>Now that you’ve seen how to extract structured information from legal contracts, the next section will focus on how to incorporate this data into a knowledge graph. </p>
</div>
<div class="readable-text" id="p74">
<h2 class="readable-text-h2"><span class="num-string">6.2</span> Constructing the graph</h2>
</div>
<div class="readable-text" id="p75">
<p>As the final step in the chapter, you’ll import the extracted structured output into Neo4j. This follows the standard approach for importing structured data. First, you should design a suitable graph model that represents the relationships and entities in your data. Graph modeling is beyond the scope of this book, but you can use LLMs to assist in defining the graph schema or look at other learning material such as Neo4j Graph Academy. </p>
</div>
<div class="readable-text intended-text" id="p76">
<p>An example of a contract graph model is illustrated in figure 6.3, which you will be using in this step. The graph model represents a contract system with three main entities: <code>Contract</code>, <code>Organization</code>, and <code>Location</code>. The <code>Contract</code> node stores details such as its ID, type, effective date, term, total amount, governing law, and scope. </p>
</div>
<div class="readable-text intended-text" id="p77">
<p>Organizations are linked to contracts through the <code>HAS_PARTY</code> relationship, and each organization has a <code>HAS_LOCATION</code> relationship to a <code>Location</code> node, which captures the organization’s address, city, state, and country. Locations are represented as separate nodes to accommodate the possibility that a single organization may have multiple addresses. </p>
</div>
<div class="readable-text intended-text" id="p78">
<p>Now that you’ve defined the graph model, the next step is to begin the process of constructing the knowledge graph. This involves several key steps, each of which will be covered in the following subsections. First, you’ll define unique constraints and indexes to ensure data integrity and improve performance. After that, you’ll import the structured contract data into Neo4j using a Cypher statement. Once the data is loaded, you will visualize the graph to confirm that all entities and relationships are correctly represented. Finally, we’ll address important data refinement tasks, such as entity resolution, which ensures that different representations of the same real-world entity are merged correctly, and we’ll touch on how to handle both structured and unstructured data in the graph.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p79">
<img alt="figure" height="992" src="../Images/6-3.png" width="821"/>
<h5 class="figure-container-h5"><span class="num-string">Figure 6.3</span> Contract graph model</h5>
</div>
<div class="readable-text" id="p80">
<h3 class="readable-text-h3"><span class="num-string">6.2.1</span> Data import</h3>
</div>
<div class="readable-text" id="p81">
<p>Defining unique constraints and indexes wherever applicable is a best practice, as it not only ensures the integrity of the graph but also enhances query performance. The code in the following listing defines unique constraints for <code>Contract</code>, <code>Organization</code>, and <code>Location</code> nodes. </p>
</div>
<div class="browsable-container listing-container" id="p82">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.12</span> Defining the unique constraints</h5>
<div class="code-area-container">
<pre class="code-area">neo4j_driver.execute_query(
    "CREATE CONSTRAINT IF NOT EXISTS FOR (c:Contract) REQUIRE c.id IS UNIQUE;"
)
neo4j_driver.execute_query(
    "CREATE CONSTRAINT IF NOT EXISTS FOR (o:Organization) REQUIRE o.name IS UNIQUE;"
)
neo4j_driver.execute_query(
    "CREATE CONSTRAINT IF NOT EXISTS FOR (l:Location) REQUIRE l.fullAddress IS UNIQUE;"
)</pre>
</div>
</div>
<div class="readable-text" id="p83">
<p>Next, you need to prepare an import Cypher statement that will take the dictionary output and load it into Neo4j, adhering to the graph schema outlined in figure 6.3. The import Cypher statement is shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p84">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.13</span> Defining the import Cypher statement</h5>
<div class="code-area-container">
<pre class="code-area">import_query = """WITH $data AS contract_data
MERGE (contract:Contract {id: randomUUID()})   <span class="aframe-location"/> #1
SET contract += {
  contract_type: contract_data.contract_type,
  effective_date: contract_data.effective_date,
  term: contract_data.term,
  contract_scope: contract_data.contract_scope,
  end_date: contract_data.end_date,
  total_amount: contract_data.total_amount,
  governing_law: contract_data.governing_law.state + ' ' +
                 contract_data.governing_law.country
}
WITH contract, contract_data
UNWIND contract_data.parties AS party      <span class="aframe-location"/> #2
MERGE (p:Organization {name: party.name})
MERGE (loc:Location {
  fullAddress: party.location.address + ' ' +
                party.location.city + ' ' +
                party.location.state + ' ' +
                party.location.country})
SET loc += {
  address: party.location.address,
  city: party.location.city,
  state: party.location.state,
  country: party.location.country
}
MERGE (p)-[:LOCATED_AT]-&gt;(loc)  <span class="aframe-location"/> #3
MERGE (p)-[r:HAS_PARTY]-&gt;(contract)  <span class="aframe-location"/> #4
SET r.role = party.role
"""</pre>
<div class="code-annotations-overlay-container">
     #1 Creates the Contract node using a random UUID as unique identifier
     <br/>#2 Creates the Party nodes and their locations
     <br/>#3 Links parties to their location
     <br/>#4 Links parties to the contract
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p85">
<p>Explaining Cypher statements, such as the one in listing 6.13, is outside the scope of this book. However, if you need assistance, LLMs can help clarify the details and provide a deeper understanding of the Cypher statement. However, we want to highlight that the query in listing 6.13 is not idempotent due to the use of <code>randomUUID()</code> for the contract ID. As a result, running the query multiple times will create duplicate contract entries in the database, each with a unique ID.</p>
</div>
<div class="readable-text intended-text" id="p86">
<p>Now that everything is prepared, you can execute the code in the following listing to import the contract into Neo4j.</p>
</div>
<div class="browsable-container listing-container" id="p87">
<h5 class="listing-container-h5 browsable-container-h5"><span class="num-string">Listing 6.14</span> Importing the contract data into Neo4j</h5>
<div class="code-area-container">
<pre class="code-area">neo4j_driver.execute_query(import_query, data=data)</pre>
</div>
</div>
<div class="readable-text" id="p88">
<p>Once the import is successful, you can open the Neo4j browser to explore the generated graph, which should closely resemble the visualization shown in figure 6.4.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p89">
<img alt="figure" height="940" src="../Images/6-4.png" width="1100"/>
<h5 class="figure-container-h5"><span class="num-string">Figure 6.4</span> Contract graph data visualized</h5>
</div>
<div class="readable-text intended-text" id="p90">
<p>The visualization in figure 6.4 depicts a graph where a central “Licensing Agreement” (representing a contract) is linked to two organizations: “Mortgage Logic.com, Inc.” and “TrueLink, Inc.” via the relationship <code>HAS_PARTY</code>. Each organization is further connected to a “US” node representing their location through the <code>LOCATED_AT</code> relationship. </p>
</div>
<div class="readable-text" id="p91">
<h3 class="readable-text-h3"><span class="num-string">6.2.2</span> Entity resolution</h3>
</div>
<div class="readable-text" id="p92">
<p>You’ve successfully imported the graph, but your work isn’t done yet. In most cases, especially when dealing with natural language processing or LLM-driven data processing, some level of data cleaning is necessary. One of the most crucial steps in this cleaning process is entity resolution. Entity resolution refers to the process of identifying and merging different representations of the same real-world entity within a dataset or knowledge graph. When working with large and diverse datasets, it’s common for the same entity to appear in multiple forms due to inconsistencies like spelling variations, different naming conventions, or even slight discrepancies in data formats, as shown in figure 6.5, where we see three nodes representing variations of the same entity. The three names are</p>
</div>
<ul>
<li class="readable-text" id="p93"> UTI Asset Management Company </li>
<li class="readable-text" id="p94"> UTI Asset Management Company Limited </li>
<li class="readable-text" id="p95"> UTI Asset Management Company Ltd<span class="aframe-location"/> </li>
</ul>
<div class="browsable-container figure-container" id="p96">
<img alt="figure" height="792" src="../Images/6-5.png" width="855"/>
<h5 class="figure-container-h5"><span class="num-string">Figure 6.5</span> Potential duplicates</h5>
</div>
<div class="readable-text" id="p97">
<p>Entity resolution in this context involves identifying that all these variations refer to the same real-world organization, despite minor differences in naming conventions (such as “Limited” vs. “Ltd”). The goal of entity resolution is to unify these disparate references into a single, coherent node within the graph. This not only improves data integrity but also enhances the graph’s ability to make more accurate inferences and relationships. Techniques used in entity resolution include string matching, clustering algorithms, and even machine learning methods that use the context surrounding each entity to detect and resolve duplicates.</p>
</div>
<div class="readable-text intended-text" id="p98">
<p>It is important to note that entity resolution is highly use case and domain specific. A generic, one-size-fits-all solution rarely works because each domain has its own naming conventions, data schemas, and nuances in how entities are represented. For instance, the methods and thresholds that might work well for resolving organizations in a financial dataset could produce suboptimal results when dealing with biological entities in a healthcare setting. Consequently, one of the most effective strategies is to develop domain-specific ontologies or rules that reflect your particular data context. Additionally, using subject matter experts to define matching criteria and using iterative feedback loops—where potential matches are verified or corrected—can greatly improve accuracy. By combining domain expertise with context-aware machine learning or clustering techniques, you can develop a more robust and flexible approach to entity resolution. This will ensure that you capture the subtle details that matter most in your unique data environment. </p>
</div>
<div class="readable-text" id="p99">
<h3 class="readable-text-h3"><span class="num-string">6.2.3</span> Adding unstructured data to the graph</h3>
</div>
<div class="readable-text" id="p100">
<p>Knowledge graphs are increasingly used to store both structured and unstructured data, a scenario that has become even more common with the advent of LLMs. In this context, LLMs can be used to extract structured data from unstructured sources like text documents. However, storing the original unstructured documents and the extracted structured data within the graph preserves the richness of the original data while enabling more precise querying and analysis of the extracted information. An expanded graph schema where structured and unstructured information is combined is presented in figure 6.6. <span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p101">
<img alt="figure" height="595" src="../Images/6-6.png" width="870"/>
<h5 class="figure-container-h5"><span class="num-string">Figure 6.6</span> Expanded graph model with added unstructured data</h5>
</div>
<div class="readable-text" id="p102">
<p>When incorporating unstructured data into a graph, it’s common to use a simple chunking strategy based on token count or word length to split text into manageable segments. While this naive approach works for general use cases, certain domains, such as legal contracts, benefit from more specialized chunking methods. For example, splitting a contract by its clauses preserves its semantic structure and improves the quality of downstream analysis. This smarter approach allows the graph to capture more meaningful relationships, enabling richer insights and more accurate inferences.</p>
</div>
<div class="readable-text intended-text" id="p103">
<p>This chapter has guided you through constructing knowledge graphs from unstructured data using LLMs. You explored the limitations of text embeddings in handling structured queries and learned how structured data extraction provides a solution. By defining data models, prompting LLMs for extraction, and importing the results into a graph database, you saw how to transform raw text into usable data for knowledge graphs. Additionally, we covered key tasks like entity resolution and combining structured and unstructured data for richer insights. With this knowledge, you can now apply structured data extraction in practical scenarios. </p>
</div>
<div class="readable-text" id="p104">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p105"> Simply chunking documents for retrieval can result in inaccurate or mixed results, especially in domains like legal documents where document boundaries matter. </li>
<li class="readable-text" id="p106"> Retrieval tasks like filtering, sorting, and aggregating require structured data, as text embeddings alone are not suited for such operations. </li>
<li class="readable-text" id="p107"> LLMs are effective at extracting structured data from unstructured text, converting it into usable formats like tables or key–value pairs. </li>
<li class="readable-text" id="p108"> Structured output features in LLMs allow developers to define schemas, ensuring responses follow a specific format and reducing the need for postprocessing. </li>
<li class="readable-text" id="p109"> Defining a clear data model with attributes such as contract type, parties, and dates is essential for guiding LLMs to extract relevant information accurately. </li>
<li class="readable-text" id="p110"> Entity resolution in knowledge graphs is important for merging different representations of the same entity, improving data consistency and accuracy. </li>
<li class="readable-text" id="p111"> Combining structured and unstructured data in knowledge graphs preserves the richness of the source material while enabling more precise querying.  </li>
</ul>
</div></body></html>