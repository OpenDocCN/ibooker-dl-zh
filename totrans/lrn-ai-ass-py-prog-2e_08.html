<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div class="readable-text" id="p1">
<h1 class="readable-text-h"><span class="calibre22"><span class="calibre22">9</span></span> <span class="calibre22"><em class="calibre5">Automating tedious tasks</em></span></h1>
</div>
<div class="readable-text">
<h3 class="introduction-header">This chapter covers</h3>
<ul class="calibre24">
<li class="readable-text1" id="p2">Understanding why programmers write tools</li>
<li class="readable-text1" id="p3">Determining which modules we need to write a given tool</li>
<li class="readable-text1" id="p4">Automating cleaning up emails that have &gt; &gt; &gt; symbols </li>
<li class="readable-text1" id="p5">Automating manipulating PDF files</li>
<li class="readable-text1" id="p6">Automating removing duplicate pictures across multiple image libraries</li>
</ul>
</div>
<div class="readable-text" id="p7">
<p class="calibre15">Suppose that you’re responsible for creating 100 reports, one for each of 100 people. Perhaps you’re a teacher and need to send a report to each of your students. Perhaps you work for HR and need to send an annual assessment report to each employee. Regardless of your role, you have the problem of having to create these reports, and you decided to prepare your reports as .pdf files. You need a customized cover page for each report too, and those cover pages are designed by one of your colleagues (a graphic design artist).</p>
</div>
<div class="readable-text" id="p8">
<p class="calibre15">You and your colleague work independently, and, finally, the job is done. Or wait, not so fast. Because now you have to put each cover page at the beginning of each report.</p>
</div>
<div class="readable-text" id="p9">
<p class="calibre15">At this point, a nonprogrammer might grit their teeth and start on the job, manually merging the cover page with the first report, the second cover page with the second report, and so on. That could take hours. Not knowing that there may be another way, a nonprogrammer may just power ahead until the job is done.</p>
</div>
<div class="readable-text" id="p10">
<p class="calibre15">But you’re a programmer now. And most programmers, the two of us included, would never power ahead with manual work like this. </p>
</div>
<div class="readable-text" id="p11">
<p class="calibre15">In this chapter, we’re going to show you how to write programs to automate tedious tasks. The second example in the chapter will automate the “merging cover pages with reports” situation. But we’ll do others as well. Received an email that’s been forwarded so many times</p>
</div>
<div class="readable-text" id="p12">
<p class="calibre15">&gt; &gt; &gt; &gt; &gt; &gt; that it looks</p>
</div>
<div class="readable-text" id="p13">
<p class="calibre15">like</p>
</div>
<div class="readable-text" id="p14">
<p class="calibre15">&gt; &gt; &gt; &gt; &gt; &gt; this? </p>
</div>
<div class="readable-text" id="p15">
<p class="calibre15">Or does your family have several phones, each with hundreds of images, and you just want to get the images all in the same place so that you can archive them without losing anything? In this chapter, we’ll show you how to automate tasks like that. </p>
</div>
<div class="readable-text" id="p16">
<h2 class="readable-text-h1" id="sigil_toc_id_133"><span class="calibre22">9.1</span> Why programmers make tools</h2>
</div>
<div class="readable-text" id="p17">
<p class="calibre15">There’s a common sentiment that programmers often express: we’re lazy. This doesn’t mean that we don’t want to do our work. It means that we don’t want to do <em class="calibre18">repetitive, boring, tedious </em>work because that’s what computers are good at. Programmers develop a sort of spidey-sense for this kind of drudgery. Suppose Leo has a few hundred photos, and he wants to delete any photos that are duplicates. There’s no way he’d do this by hand. Or suppose that Dan has to send out a customized email to each of his students. If it’s more than a few students, there’s no way he’s doing this by hand. As soon as programmers start noticing that they’re repeating the same keys on the keyboard or working through the same steps over and over, they’ll stop and make a tool to automate it.<em class="calibre18"> </em></p>
</div>
<div class="readable-text" id="p18">
<p class="calibre15">When programmers talk about tools, they’re talking about programs that do something that saves them time. A tool often isn’t the end goal, and writing one can itself feel tedious and not glamorous. But once we have a tool, we can use it to save us time. Sometimes, we’ll use a tool once, for one specific job, and then never again. Commonly, though, a tool ends up being useful over and over, whether we use the tool exactly as we wrote it or by making some small changes. For example, after Dan finishes teaching each course, he uses a program he wrote to collate all student grades and submit them to the university. He makes small changes to the tool each time—changing the weights of each assignment, for example—but then Dan can use that slightly modified tool to do the work.</p>
</div>
<div class="readable-text" id="p19">
<p class="calibre15">The great thing about using Copilot is that it makes cranking out these tools easier. Here’s how one software engineer explains it: </p>
</div>
<div class="readable-text" id="p20">
<blockquote class="calibre2">
<div class="readable-text">
     We all know that tools are important, that effective tools are challenging to create, and that management doesn’t care or understand the need for tools. . . . I can’t express how fundamentally different programming feels now that I can build two quality tools per day, for every single itch I want to scratch. [1]
    </div>
</blockquote>
</div>
<div class="readable-text" id="p21">
<h2 class="readable-text-h1" id="sigil_toc_id_134"><span class="calibre22">9.2</span> How to use Copilot to write tools</h2>
</div>
<div class="readable-text" id="p22">
<p class="calibre15">As we learned in chapter 5 when talking about modules, sometimes we need to use a module to help us write the program we want. Some modules are built into Python. For example, in chapter 5, we used the built-in zipfile module to help us create a .zip file. Other modules aren’t built in, and we need to install them first before we can use them. </p>
</div>
<div class="readable-text" id="p23">
<p class="calibre15">When writing a tool, it’s often the case that we’ll be working with some specialized data format (zip files, PDF files, Microsoft Excel spreadsheets, images) or performing some specialized task (sending email, interacting with a website, moving files around). For most of this, we’re going to need to use a module. Which module, though? And is it built in, or do we need to install it? These are the first questions we need to get answers to.</p>
</div>
<div class="readable-text" id="p24">
<p class="calibre15">Fortunately, we can use Copilot Chat (or ChatGPT) to help us get started. As a reminder, we’re using the Copilot Chat feature because it’s built into our Visual Studio Code (VS Code) IDE and because Copilot Chat has access to the very code we’re currently writing so it can incorporate what we’re doing into its answers.</p>
</div>
<div class="readable-text" id="p25">
<p class="calibre15">The plan is to have a conversation with Copilot to determine which module we need to use. Once we know that and install the module, if necessary, then we can get down to the business of writing the code for our tool. We’ll do that the way we’ve always done it: by writing the function header and a docstring and having Copilot fill in the code for us. Once Copilot starts writing code, we need to follow the same steps as in previous chapters, including checking code correctness, fixing bugs, and maybe even doing some problem decomposition. To focus our attention on writing tools to automate tasks, we’ll minimize the time we spend on these additional tasks here.</p>
</div>
<div class="readable-text" id="p26">
<p class="calibre15">It may be possible to ask Copilot or ChatGPT to write the entire tool for us, without even having to put it inside of a function. We won’t do that here, though, because we still think that the benefits of functions are worthwhile. A function will help us document our code so that we know what it does, and it enables flexibility if we later decide, for example, to add additional parameters to our function to change the behavior of the tool.</p>
</div>
<div class="readable-text" id="p27">
<h2 class="readable-text-h1" id="sigil_toc_id_135"><span class="calibre22">9.3</span> Example 1: Cleaning up email text</h2>
</div>
<div class="readable-text" id="p28">
<p class="calibre15">Sometimes, an email gets replied to and forwarded so many times that it becomes a mess, with many greater than (&gt;) signs and spaces on some of the lines. Here’s a sample email of what we mean:</p>
</div>
<div class="readable-text" id="p29">
<p class="calibre15">&gt; &gt; &gt; Hi Leo,</p>
</div>
<div class="readable-text" id="p30">
<p class="calibre15">&gt; &gt; &gt; &gt; &gt; Dan -- any luck with your natural language research?</p>
</div>
<div class="readable-text" id="p31">
<p class="calibre15">&gt; &gt; &gt; Yes! That website you showed me</p>
</div>
<div class="readable-text" id="p32">
<p class="calibre15"><a href="https://www.kaggle.com/">https://www.kaggle.com/</a></p>
</div>
<div class="readable-text" id="p33">
<p class="calibre15">&gt; &gt; &gt; is very useful. I found a dataset on there that collects</p>
</div>
<div class="readable-text" id="p34">
<p class="calibre15">a lot</p>
</div>
<div class="readable-text" id="p35">
<p class="calibre15">&gt; &gt; &gt; of questions and answers that might be useful to my research. </p>
</div>
<div class="readable-text" id="p36">
<p class="calibre15">&gt; &gt; &gt; Thank you,</p>
</div>
<div class="readable-text" id="p37">
<p class="calibre15">&gt; &gt; &gt; Dan</p>
</div>
<div class="readable-text" id="p38">
<p class="calibre15">Suppose that you wanted to save this email information for future use. You might like to clean up the &gt; and space symbols at the start of lines. You could start manually deleting them—this email isn’t that long, after all—but don’t do that because here you have an opportunity to design a general-purpose tool that you can use whenever you need to perform this task. Whether your email has five lines, a hundred lines, or a million lines, it won’t matter: just use the tool and be done. </p>
</div>
<div class="readable-text" id="p39">
<h3 class="readable-text-h2" id="sigil_toc_id_136"><span class="calibre22">9.3.1</span> Conversing with Copilot</h3>
</div>
<div class="readable-text" id="p40">
<p class="calibre15">We need to make the messy email available to our tool so that the tool can clean it up. One way we can do this is to first copy the text of an email to the clipboard (using your Copy to Clipboard command on your operating system, such as Ctrl-C).</p>
</div>
<div class="readable-text" id="p41">
<p class="calibre15">Each computer operating system has a clipboard to store the last thing copied. If you’ve ever used Copy-Paste, you’ve used that clipboard. We’re going to use the clipboard for temporary storage of text so we can edit the text in the clipboard and then paste it where we need it.</p>
</div>
<div class="readable-text" id="p42">
<p class="calibre15">After copying the text from the messy email to the clipboard, we could then run the tool on the text in the clipboard, and the tool could clean up the email and replace the clipboard contents with the cleaned-up version. For the tool to do something reasonable, we assume that your clipboard has email text on it. The tool will remove the &gt; and space characters at the start of each line so that you can paste (using your operating system Paste command, such as Ctrl-V) the newly cleaned-up email wherever you want. In terms of Python, it will need to pull the clipboard contents into a string (i.e., copy the contents of the clipboard), clean it up, and then put that new cleaned-up text back on the clipboard (i.e., paste to the clipboard), replacing the junky version of the email that was there before.</p>
</div>
<div class="readable-text" id="p43">
<p class="calibre15">So, how do we access the clipboard in our Python program? That’s what we need to figure out, so that will frame the conversation that we have with Copilot. Similar to chapter 8, we’re going to use “Human” for the prompts that we type and “GitHub Copilot” for Copilot’s responses. You can use the Copilot Chat feature or ChatGPT to have a similar conversation. We’re typing our prompts into the Copilot Chat window. </p>
</div>
<div class="readable-text" id="p44">
<p class="calibre15">In our chats with Copilot, we’re going to explore widely before settling on a solution. We’ll explain why we’re doing this once we’ve gotten the hang of things through one example, but we note this here so that you’ll be ready for this seemingly less direct approach. Copilot provides quite a bit of sample code in its responses. As we’re exploring, feel free to skim that code, but don’t get bogged down in it. We’ll look at more particulars of the code once we finish exploring and settle on a plan. Let’s start learning!</p>
</div>
<div class="readable-text4" id="p45">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>I would like to write a Python program that accesses the clipboard and lets me copy and paste using the clipboard. How can I do this?</p>
</div>
<div class="readable-text4" id="p46">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span><strong class="calibre17"> </strong>You can use the pyperclip module to access the clipboard in Python. Here’s an example program that lets you copy and paste using the clipboard:</p>
</div>
<div class="browsable-container" id="p47">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import pyperclip</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Copy to clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pyperclip.copy('Hello, world!')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Paste from clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">text = pyperclip.paste()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">print(text)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p48">
<p class="calibre54">This program first imports the pyperclip module. It then copies the string <code class="calibre25">'Hello,</code> <code class="calibre25">world!'</code> to the clipboard using the <code class="calibre25">copy()</code> function. Finally, it pastes the contents of the clipboard into the “text” variable using the <code class="calibre25">paste()</code> function and prints the result.</p>
</div>
<div class="readable-text4" id="p49">
<p class="calibre54">You can install the pyperclip module using pip by running <code class="calibre25">pip</code> <code class="calibre25">install</code> <code class="calibre25">pyperclip</code> in your terminal.</p>
</div>
<div class="readable-text" id="p50">
<p class="calibre15">Copilot’s response teaches us that we can use the pyperclip module to interact with the clipboard in our Python program. The sample code that it provided even showed us how to copy stuff from our program to the clipboard and paste stuff from the clipboard into a variable (<code class="calibre25">text</code>). We’re making great progress!</p>
</div>
<div class="readable-text" id="p51">
<p class="calibre15">The final paragraph of the response tells us how to install pyperclip. Aha! So pyperclip doesn’t come with Python by default. While we’ll learn how to install modules later, it might be nice to not have to worry about that. So, let’s continue the conversation, asking Copilot if we can do better.</p>
</div>
<div class="readable-text4" id="p52">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span> Is there a way I can do it without having to install a Python module?</p>
</div>
<div class="readable-text4" id="p53">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Yes, you can use the tkinter module that comes with Python to access the clipboard. Here’s an example program that lets you copy and paste using the clipboard without installing any additional modules:</p>
</div>
<div class="browsable-container" id="p54">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import tkinter as tk</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Create a Tkinter window</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">root = tk.Tk()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Hide the window</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">root.withdraw()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Copy to clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">root.clipboard_clear()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">root.clipboard_append('Hello, world!')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Paste from clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">text = root.clipboard_get()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">print(text)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p55">
<p class="calibre54">This program first creates a hidden Tkinter window using the <code class="calibre25">Tk()</code> function and hides it using the <code class="calibre25">withdraw()</code> method. It then clears the clipboard using the <code class="calibre25">clipboard_ clear()</code> method and appends the string <code class="calibre25">'Hello,</code> <code class="calibre25">world!'</code> to the clipboard using the <code class="calibre25">clipboard_append()</code> method. Finally, it retrieves the contents of the clipboard using the <code class="calibre25">clipboard_get()</code> method and prints the result.</p>
</div>
<div class="readable-text4" id="p56">
<p class="calibre54">Note that this method only works if you have a graphical environment available, such as a desktop environment on Linux or macOS, or the Windows desktop on Windows. If you’re running Python in a terminal-only environment, you’ll need to use a different method to access the clipboard.</p>
</div>
<div class="readable-text" id="p57">
<p class="calibre15">It seems that we’ve won something and lost something else. The win is that this tkinter module is built into Python. The loss is that “the method only works if you have a graphical environment available.” Do we have a graphical environment available in our Python setup? While we could certainly try the code to find out, this requirement gives us pause. After all, the pyperclip solution didn’t have that requirement, so we might not need it (whatever it happens to mean). Let’s try again.</p>
</div>
<div class="readable-text4" id="p58">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Is there another way I can do it without having to install a Python module?</p>
</div>
<div class="readable-text4" id="p59">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Yes, you can access the clipboard using the win32clipboard module, which is included in the standard library on Windows. Here’s an example program that allows you to copy and paste using the clipboard without installing any additional modules:</p>
</div>
<div class="browsable-container" id="p60">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import win32clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Copy to clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">text = "Hello, world!"</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">win32clipboard.OpenClipboard()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">win32clipboard.EmptyClipboard()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">win32clipboard.SetClipboardText(text)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">win32clipboard.CloseClipboard()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Paste from clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">win32clipboard.OpenClipboard()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pasted_text = win32clipboard.GetClipboardData()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">win32clipboard.CloseClipboard()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">print(pasted_text)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p61">
<p class="calibre54">This program first imports the win32clipboard module. To copy text to the clipboard, you can call the <code class="calibre25">OpenClipboard()</code> function to open the clipboard, then call <code class="calibre25">EmptyClipboard()</code> to clear any existing data, and finally call <code class="calibre25">SetClipboardText()</code> to set the text on the clipboard. After setting the text, you should call <code class="calibre25">CloseClipboard()</code> to close the clipboard.</p>
</div>
<div class="readable-text4" id="p62">
<p class="calibre54">To paste from the clipboard, you can call <code class="calibre25">OpenClipboard()</code> to open the clipboard, then call <code class="calibre25">GetClipboardData()</code> to get the text from the clipboard. After getting the text, you should call <code class="calibre25">CloseClipboard()</code> to close the clipboard. In this example, the program copies the text <code class="calibre25">"Hello,</code> <code class="calibre25">world!"</code> to the clipboard, then pastes it and prints it to the console. </p>
</div>
<div class="readable-text" id="p63">
<p class="calibre15">“Standard library on Windows,” eh? That’s concerning because it means that our tool might not work on other operating systems. Let’s see about that.</p>
</div>
<div class="readable-text4" id="p64">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Does that work on Linux or macOS too?</p>
</div>
<div class="readable-text4" id="p65">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> No, the win32clipboard module is specific to Windows and won’t work on Linux or macOS. On Linux, you can use the <code class="calibre25">xclip</code> command-line utility to access the clipboard. Here’s an example program that allows you to copy and paste using the clipboard on Linux:</p>
</div>
<div class="browsable-container" id="p66">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import subprocess</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Copy to clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">text = "Hello, world!"</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">subprocess.run(['xclip', '-selection', 'clipboard'], input=text.encode('utf-8'))</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Paste from clipboard</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">p = subprocess.Popen(['xclip', '-selection', 'clipboard', '-o'], stdout=subprocess.PIPE)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pasted_text = p.stdout.read().decode('utf-8')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">print(pasted_text)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p67">
<p class="calibre54">This program uses the subprocess module to run the <code class="calibre25">xclip</code> command-line utility. To copy text to the clipboard, you can call <code class="calibre25">subprocess.run()</code> and pass in the <code class="calibre25">xclip</code> command with the <code class="calibre25">-selection</code> <code class="calibre25">clipboard</code> option to specify the clipboard selection, and the <code class="calibre25">input</code> parameter to pass in the text you want to copy. To paste from the clipboard, you can call <code class="calibre25">subprocess.Popen()</code> and pass in the <code class="calibre25">xclip</code> command with the <code class="calibre25">-selection</code> <code class="calibre25">clipboard</code> <code class="calibre25">-o</code> options to read the text from the clipboard, and then read the output of the command using the <code class="calibre25">stdout</code> attribute of the <code class="calibre25">Popen</code> object. In this example, the program copies the text <code class="calibre25">"Hello,</code> <code class="calibre25">world!"</code> to the clipboard, then pastes it and prints it to the console. </p>
</div>
<div class="readable-text4" id="p68">
<p class="calibre54">On macOS, you can use the <code class="calibre25">pbcopy</code> and <code class="calibre25">pbpaste</code> command-line utilities to access the clipboard. The usage is similar to <code class="calibre25">xclip</code>.</p>
</div>
<div class="readable-text" id="p69">
<p class="calibre15">We’ve gotten some solutions that are specific to different operating systems. We don’t like this! We want our tool to work no matter which operating system we’re using. (Even if we’re using only Windows ourselves, maybe one day, we’ll share this tool with others who use different operating systems.)</p>
</div>
<div class="readable-text" id="p70">
<p class="calibre15">We could continue our conversation, but in retrospect, having to install that single pyperclip module doesn’t seem so bad. Let’s go ahead with it. In general, it can be valuable to explore your options when deciding how to start writing a tool, and conversing with Copilot is helpful for carrying out this exploration.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p71">
<h5 class="callout-container-h">Why we should explore and understand our options</h5>
</div>
<div class="readable-text" id="p72">
<p class="calibre15">There are several reasons why you shouldn’t just use the first module that Copilot chat tells you to use:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p73"> It may not work on all operating systems. In general, we want to find modules that work across multiple operating systems so that the tool can be used by you (if you later switch operating systems) or others with whom you’ve shared the tool. </li>
<li class="readable-text1" id="p74"> It may turn out not to work for our use case after all, or we may struggle to get the code to work. If we have other options, we can start trying those before sinking too much time into a strategy that may or may not ultimately work out. </li>
<li class="readable-text1" id="p75"> Modules are updated frequently. Usually this is to add new features and fix bugs, but sometimes, functions are removed or changed in this process as well. When the author of a module removes a function, it’s known as <em class="calibre18">deprecating that function</em><em class="calibre18">. </em>Once a function is deprecated,<em class="calibre18"> </em>it may no longer work, and we need to find a replacement. Copilot is trained only every once in a while, not continuously, so if a new version of a module comes out after Copilot was trained on it, Copilot won’t know about the updates. This can lead to Copilot suggesting code that depends on an older version of the module than the one you have. There are ways to address this, as we’ll see later in the chapter. But if you run into trouble, having other options to explore is useful. </li>
</ul>
</div>
<div class="readable-text" id="p76">
<h3 class="readable-text-h2" id="sigil_toc_id_137"><span class="calibre22">9.3.2</span> Writing the tool to clean up email</h3>
</div>
<div class="readable-text" id="p77">
<p class="calibre15">The first thing we need to do is to install the pyperclip module. How do we install it, though? The good news is that Python has made it easy to install new modules. Go to the Terminal at the bottom right of VS Code and type the following:</p>
</div>
<div class="browsable-container" id="p78">
<div class="readable-text">
<pre class="code-area">pip install pyperclip</pre>
</div>
</div>
<div class="readable-text2" id="p79">
<p class="calibre15"><span class="calibre17">Note</span>  For some operating systems, you may need to use <code class="calibre25">pip3</code> rather than <code class="calibre25">pip</code>. On Windows machines, we recommend using <code class="calibre25">pip</code> if you followed our installation instructions from chapter 2. On Mac or Linux machines, we recommend using <code class="calibre25">pip3</code>.</p>
</div>
<div class="readable-text" id="p80">
<p class="calibre15">When you run this command, you might see that other modules get installed too. Don’t worry about that: sometimes modules need other modules to be able to do their work, and Python just installs them all so that you don’t have to worry about installing those dependencies yourself.</p>
</div>
<div class="readable-text" id="p81">
<p class="calibre15">Once that’s installed, we can import the module and then write the header and docstring for our function that will remove the &gt; and space characters from the start of lines. The reason we’re importing the module here is to influence Copilot to use that module when writing the code for the function. Here’s the prompt we used and the code that Copilot gave us.</p>
</div>
<div class="browsable-container" id="p82">
<h5 class="listing-container-h"><span>Listing 9.1</span> First try: Clean up email text in the clipboard</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import pyperclip</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">def clean_email():</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    The clipboard contains lines of text.</strong>
<strong class="calibre17">    Clean up the text by removing any &gt; or space</strong>
<strong class="calibre17">    characters from the beginning of each line.</strong>
<strong class="calibre17">    Replace the clipboard with the cleaned text.</strong>
<strong class="calibre17">    '''</strong>
    text = pyperclip.paste()                     <span/> #1
    lines = text.splitlines()                <span/> #2
    for i in range(len(lines)):                  <span/> #3
        lines[i] = lines[i].lstrip(' &gt;')            <span/> #4
    text = '       <span/> #5

'.join(lines)       #5

    pyperclip.copy(text)      <span/> #6

if __name__ == '__main__':           <span/> #7
    clean_email()      <span/> #8</pre>
<div class="code-annotations-overlay-container">
     #1 Puts the current contents of the clipboard into the text string
     <br class="calibre1"/>#2 Splits the string into a list of its lines
     <br class="calibre1"/>#3 Loops through each line
     <br class="calibre1"/>#4 Removes spaces and &amp;gt; symbols from the start of the line
     <br class="calibre1"/>#5 This looks odd.
     <br class="calibre1"/>#6 Copies the cleaned-up text to the clipboard
     <br class="calibre1"/>#7 Note a common Python convention (see the following discussion).
     <br class="calibre1"/>#8 Calls our function to automatically clean up the clipboard!
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p83">
<p class="calibre15">We can see that the program is carrying out the correct sequence of steps: it’s obtaining the clipboard contents, cleaning up that text, and then copying the cleaned-up text back to the clipboard. As we learned from our earlier chat with Copilot, we want Copilot to write code that uses the <code class="calibre25">paste</code> and <code class="calibre25">copy</code> functions of <code class="calibre25">pyperclip</code>, and that’s exactly what it’s doing. The second-to-last line of the program is something we haven’t seen before in this book: </p>
</div>
<div class="browsable-container" id="p84">
<div class="readable-text">
<pre class="code-area">if __name__ == '__main__':</pre>
</div>
</div>
<div class="readable-text" id="p85">
<p class="calibre15">You can actually remove this line if you like (and if you do, also unindent the line below it). It ensures that the <code class="calibre25">clean_email</code> function is only called when you run your program, not when you import it as a module. After all, if you did want to import this as a module (to be used as part of a larger program), you would call <code class="calibre25">clean_email</code> whenever you needed that functionality, not necessarily as soon as the module was imported. (And, in general, whenever you’re interested in understanding a line of code more fully, you can ask Copilot about it!) Unfortunately, this code doesn’t work. If you run it, you’ll receive this error:</p>
</div>
<div class="browsable-container" id="p86">
<div class="readable-text">
<pre class="code-area">File "C:\repos\book_code\ch9\email_cleanup.py", line 14
    text = '
           ^
SyntaxError: unterminated string literal (detected at line 14)</pre>
</div>
</div>
<div class="readable-text" id="p87">
<p class="calibre15">The syntax error means that we have a program that isn’t written in valid Python code. We’re going to fix this now! We have a couple of options for how to do so. One is to highlight your code and ask Copilot Chat to fix the bug. For us, this did fix the problem. You could also try asking ChatGPT in conversation: “Propose a fix for the bugs in my code &lt;insert your code&gt;.” This is a useful tip to keep in mind whenever the code that you get back from Copilot doesn’t work as expected.</p>
</div>
<div class="readable-text" id="p88">
<p class="calibre15">Copilot fixed the code for us by fixing the line with the syntax error. The new code is shown in the following listing.</p>
</div>
<div class="browsable-container" id="p89">
<h5 class="listing-container-h"><span>Listing 9.2</span> Second try: Clean up email text in the clipboard</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import pyperclip</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">def clean_email():</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    The clipboard contains lines of text.</strong>
<strong class="calibre17">    Clean up the text by removing any &gt; or space</strong>
<strong class="calibre17">    characters from the beginning of each line.</strong>
<strong class="calibre17">    Replace the clipboard with the cleaned text.</strong>
<strong class="calibre17">    '''</strong>
    text = pyperclip.paste()
    lines = text.splitlines()
    for i in range(len(lines)):
        lines[i] = lines[i].lstrip(' &gt;')
    text = '\n'.join(lines)       <span/> #1

    pyperclip.copy(text)

if __name__ == '__main__':
    clean_email()</pre>
<div class="code-annotations-overlay-container">
     #1 Joins the individual lines back into one string
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p90">
<p class="calibre15">The new line of code, changed from the odd line of code that we had previously, is</p>
</div>
<div class="browsable-container" id="p91">
<div class="readable-text">
<pre class="code-area">text = '\n'.join(lines)</pre>
</div>
</div>
<div class="readable-text" id="p92">
<p class="calibre15">The goal of this line is to join all the lines of text together into a single string that the program will later copy to the clipboard. What does that <code class="calibre25">\n</code> mean? That represents the start of a newline in code. What is the <code class="calibre25">join</code> method? It takes all the items in a list (lines) and joins them together into a single string. </p>
</div>
<div class="readable-text" id="p93">
<p class="calibre15">We can understand how this works in more detail by experimenting a little with <code class="calibre25">join</code>. Here’s an example of using <code class="calibre25">join</code> with an empty string rather than the <code class="calibre25">'\n'</code> string:</p>
</div>
<div class="browsable-container" id="p94">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; lines = ['first line', 'second', 'the last line']  <span/> #1
&gt;&gt;&gt; print(''.join(lines))          <span/> #2
first linesecondthe last line</pre>
<div class="code-annotations-overlay-container">
     #1 Shows the list of three lines
     <br class="calibre1"/>#2 Calls join on the empty string
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p95">
<p class="calibre15">Notice that some of the words are squished together. That’s not exactly what we want—we need something between them. How about a space? Let’s try using <code class="calibre25">join</code> again, this time with a space in the string rather than the empty string:</p>
</div>
<div class="browsable-container" id="p96">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; print(' '.join(lines))
first line second the last line</pre>
</div>
</div>
<div class="readable-text" id="p97">
<p class="calibre15">Or, we could use <code class="calibre25">'*'</code>:</p>
</div>
<div class="browsable-container" id="p98">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; print('*'.join(lines))
first line*second*the last line</pre>
</div>
</div>
<div class="readable-text" id="p99">
<p class="calibre15">That fixes our squished words. And, the <code class="calibre25">*s</code> tells us where each line ends, but it would be nicer to actually maintain the fact that the email is three lines.</p>
</div>
<div class="readable-text" id="p100">
<p class="calibre15">We need a way in Python to use a line break or newline character, rather than a space or <code class="calibre25">*</code>. We can’t just press Enter because that would split the string over two lines and that isn’t valid Python syntax. The way to do it is by using <code class="calibre25">'\n'</code>:</p>
</div>
<div class="browsable-container" id="p101">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; print('\n'.join(lines))
first line
second
the last line</pre>
</div>
</div>
<div class="readable-text" id="p102">
<p class="calibre15">Now our tool is ready to be used. If you copy some messy email text to your clipboard, run our program, and paste the clipboard, you’ll see that the email has been cleaned up. For example, if we run it on our previous sample email, we get the following cleaned-up version:</p>
</div>
<div class="readable-text" id="p103">
<p class="calibre15">Hi Leo,</p>
</div>
<div class="readable-text" id="p104">
<p class="calibre15">Dan -- any luck with your natural language research?</p>
</div>
<div class="readable-text" id="p105">
<p class="calibre15">Yes! That website you showed me</p>
</div>
<div class="readable-text" id="p106">
<p class="calibre15"><a href="https://www.kaggle.com/">https://www.kaggle.com/</a></p>
</div>
<div class="readable-text" id="p107">
<p class="calibre15">is very useful. I found a dataset on there that collects</p>
</div>
<div class="readable-text" id="p108">
<p class="calibre15">a lot</p>
</div>
<div class="readable-text" id="p109">
<p class="calibre15">of questions and answers that might be useful to my research.</p>
</div>
<div class="readable-text" id="p110">
<p class="calibre15">Thank you,</p>
</div>
<div class="readable-text" id="p111">
<p class="calibre15">Dan</p>
</div>
<div class="readable-text" id="p112">
<p class="calibre15">Of course, we could still do more. The line breaks in that email aren’t great (the line “a lot” is extremely and needlessly short), and you might want to clean that up as well. You could begin to make these kinds of improvements by adding new requirements to your prompts to Copilot. We’ll stop here because we’ve accomplished our initial goal of email cleanup, but we encourage you to continue exploring more robust solutions on your own.</p>
</div>
<div class="readable-text" id="p113">
<h2 class="readable-text-h1" id="sigil_toc_id_138"><span class="calibre22">9.4</span> Example 2: Adding cover pages to PDF files</h2>
</div>
<div class="readable-text" id="p114">
<p class="calibre15">Let’s return to the scenario from the start of the chapter. We have written 100 reports that are in .pdf format. Our colleague has designed 100 covers for those reports that are also in .pdf format, and we need to merge the covers with the reports so that each finalized .pdf file starts with the cover and continues with the report. Figure 9.1 provides an illustration of the desired process.<span/></p>
</div>
<div class="browsable-container" id="p115">
<img alt="figure" src="../Images/9-1.png" class="calibre81"/>
<h5 class="figure-container-h"><span>Figure 9.1</span> Illustration of the desired process of creating combined .pdfs by merging the report cover in the cover directory with the report in the report’s directory. Note that the reports may be more than one page.</h5>
</div>
<div class="callout-container">
<div class="readable-text" id="p116">
<h5 class="callout-container-h">PDF files (and Microsoft Word and Excel files) aren’t text files</h5>
</div>
<div class="readable-text" id="p117">
<p class="calibre15">You might wonder why we can’t simply use Python methods such as <code class="calibre25">read</code> and <code class="calibre25">write</code> to manipulate .pdf files. After all, that’s just what we did when working with .csv files in chapter 2.</p>
</div>
<div class="readable-text" id="p118">
<p class="calibre15">The big difference is that .csv files are text files, which are files readable by humans with no formatting or special commands. However, many other file formats aren’t text files. A .pdf file, for example, isn’t human-readable and needs to be processed by code that is aware of the .pdf format. This is true of Microsoft Word files and Microsoft Excel files as well: they’re not text files, so we need specialized tools to work with them.</p>
</div>
</div>
<div class="readable-text" id="p119">
<p class="calibre15">In the resources for this book, in the ch9 folder, you’ll find two subfolders: the reports subfolder contains 100 reports as .pdf files, and the covers subfolder contains 100 covers as .pdf files, one for each report. The reports are named 1.pdf, 2.pdf, 3.pdf, and so on; the respective covers are named cover1.pdf, cover2.pdf, cover3.pdf, and so on. We’ll merge these reports and covers together in this section.</p>
</div>
<div class="readable-text" id="p120">
<p class="calibre15">Open some of the cover .pdf files and some of the report .pdf files. You can do that using a program such as Adobe Acrobat or however you typically open .pdf files on your computer. You’ll notice that the covers are always exactly one page, but the reports can be more than one page. When we get to the code, we should take care to tell Copilot that reports can be more than one page; otherwise, Copilot might write code assuming that the reports, like the covers, are only one page.</p>
</div>
<div class="readable-text" id="p121">
<p class="calibre15">You might be wondering how we created these 100 covers and reports. You’d be disappointed if we made them manually, one at a time, right? Don’t worry. We automated that creation process in much the same way we’ll automate the merging process next.</p>
</div>
<div class="readable-text" id="p122">
<h3 class="readable-text-h2" id="sigil_toc_id_139"><span class="calibre22">9.4.1</span> Conversing with Copilot</h3>
</div>
<div class="readable-text" id="p123">
<p class="calibre15">We need our tool to find all reports and covers, add the cover to the front of each report, and produce a finalized .pdf for each report that contains both the cover page and report pages. How do we merge .pdf files using Python? Let’s find out.</p>
</div>
<div class="readable-text4" id="p124">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>I need to write a <strong class="calibre17"/>Python program that merges .pdf files. How do I do this?</p>
</div>
<div class="readable-text4" id="p125">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> You can use the PyPDF2 library to merge PDF files in Python. Here is an example code snippet that shows how to merge two PDF files:</p>
</div>
<div class="browsable-container" id="p126">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import PyPDF2</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Open the PDF files to be merged</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pdf1 = open('file1.pdf', 'rb')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pdf2 = open('file2.pdf', 'rb')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Create a PDF reader object for each file</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">reader1 = PyPDF2.PdfFileReader(pdf1)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">reader2 = PyPDF2.PdfFileReader(pdf2)</em></code></em>

<em class="calibre18"><code class="calibre25"><em class="calibre18"># Create a PDF writer object</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">writer = PyPDF2.PdfFileWriter()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Loop through the pages of each PDF and add them to the writer object</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">for i in range(reader1.getNumPages()):</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> page = reader1.getPage(i)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> writer.addPage(page)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">for i in range(reader2.getNumPages()):</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> page = reader2.getPage(i)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> writer.addPage(page)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Write the merged PDF to a file</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">output = open('merged.pdf', 'wb')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">writer.write(output)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Close the input and output files</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pdf1.close()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pdf2.close()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">output.close()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p127">
<p class="calibre54">In this example, we first open the two PDF files to be merged using the <code class="calibre25">open()</code> function. We then create a PDF reader object for each file using the <code class="calibre25">PdfFileReader()</code> function from PyPDF2.</p>
</div>
<div class="readable-text4" id="p128">
<p class="calibre54">Next, we create a PDF writer object using the <code class="calibre25">PdfFileWriter()</code> function. We then loop through the pages of each PDF file using the <code class="calibre25">getNumPages()</code> and <code class="calibre25">getPage()</code> methods of the reader objects and add each page to the writer object using the <code class="calibre25">addPage()</code> method.</p>
</div>
<div class="readable-text4" id="p129">
<p class="calibre54">Finally, we write the merged PDF to a file using the <code class="calibre25">write()</code> method of the writer object and close all the input and output files using the <code class="calibre25">close()</code> method.</p>
</div>
<div class="readable-text" id="p130">
<p class="calibre15">We have a lead! This PyPDF2 module seems to do what we need. It looks like it gives us <code class="calibre25">PdfFileReader</code> to read an existing .pdf file and <code class="calibre25">PdfFileWriter</code> to create a new .pdf file. We see the code using <code class="calibre25">getPage</code> to get a page from an existing .pdf file and <code class="calibre25">addPage</code> to write it to the new .pdf file—very promising. Is there something built-in to Python that we could use, so that we don’t have to worry about installing PyPDF2?</p>
</div>
<div class="readable-text4" id="p131">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Is there a way I can do it without having to install a Python module?</p>
</div>
<div class="readable-text4" id="p132">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Yes, you can use the subprocess module to call a command-line tool like <code class="calibre25">pdftk</code> to merge PDF files. Here is an example code snippet that shows how to merge two PDF files using <code class="calibre25">pdftk</code>:</p>
</div>
<div class="browsable-container" id="p133">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import subprocess</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Call pdftk to merge the PDF files</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">subprocess.call(['pdftk', 'file1.pdf', 'file2.pdf', </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> 'cat', 'output', 'merged.pdf'])</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p134">
<p class="calibre54">In this example, we use the <code class="calibre25">subprocess.call()</code> function to call <code class="calibre25">pdftk</code> with the appropriate arguments to merge the two PDF files <code class="calibre25">file1.pdf</code> and <code class="calibre25">file2.pdf</code>. The <code class="calibre25">cat</code> argument tells <code class="calibre25">pdftk</code> to concatenate the input files, and the <code class="calibre25">output</code> argument specifies the output file name as <code class="calibre25">merged.pdf</code>.</p>
</div>
<div class="readable-text4" id="p135">
<p class="calibre54">Note that you will need to have <code class="calibre25">pdftk</code> installed on your system for this code to work. If you don’t have <code class="calibre25">pdftk</code> installed, you can download it from the official website: <a href="https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/">https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/</a>.</p>
</div>
<div class="readable-text" id="p136">
<p class="calibre15">This approach may ultimately end up being valuable, but it’s not exactly a built-in solution. After all, the final paragraph talks about us having to install some new software called <code class="calibre25">pdftk</code>!</p>
</div>
<div class="readable-text" id="p137">
<p class="calibre15">At this point, we’d probably go with the first option of using PyPDF2. But let’s press forward once more with Copilot to make sure we don’t miss any good options.</p>
</div>
<div class="readable-text4" id="p138">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Are there other Python .pdf libraries that I should consider?</p>
</div>
<div class="readable-text4" id="p139">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Yes, there are several other Python libraries that you can use to work with PDF files. Here are some popular ones:</p>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p140"> ReportLab—a library for creating PDF documents from scratch, with support for text, graphics, and images. </li>
<li class="readable-text1" id="p141"> FPDF—a library for creating PDF documents from scratch, with support for text, graphics, and images. </li>
<li class="readable-text1" id="p142"> PDFMiner—a library for extracting text and metadata from PDF files. </li>
<li class="readable-text1" id="p143"> PyMuPDF—a library for working with PDF files, with support for text, graphics, and images. </li>
<li class="readable-text1" id="p144"> pdfrw—a library for reading and writing PDF files, with support for text, graphics, and images. </li>
</ol>
<div class="readable-text4" id="p145">
<p class="calibre54">Each library has its own strengths and weaknesses, so you should choose the one that best fits your needs. If you only need to merge PDF files, then PyPDF2 or pdftk may be sufficient. However, if you need to create or manipulate PDF files in more complex ways, then one of the other libraries may be a better choice.</p>
</div>
<div class="readable-text" id="p146">
<p class="calibre15">The last paragraph tells us that we’re probably in good shape using PyPDF2 if all we need to do is merge .pdf files. But let’s finish our conversation here by understanding the pros and cons of all of these tools. That way, if we get stuck with PyPDF2, we know where to turn to next.</p>
</div>
<div class="readable-text4" id="p147">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Can you summarize the <strong class="calibre17"/>strengths and weaknesses of these libraries?</p>
</div>
<div class="readable-text4" id="p148">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Certainly! Here is a summary of the strengths and weaknesses of the libraries I mentioned:</p>
</div>
<div class="readable-text4" id="p149">
<p class="calibre54">PyPDF2—a library for working with PDF files, with support for text, graphics, and images.</p>
</div>
<div class="readable-text4" id="p150">
<p class="calibre54">Strengths:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p151"> Easy to use for simple tasks like merging PDF files. </li>
<li class="readable-text5" id="p152"> Good documentation and examples available. </li>
<li class="readable-text5" id="p153"> Supports a wide range of PDF features. </li>
</ol>
<div class="readable-text4" id="p154">
<p class="calibre54">Weaknesses:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p155"> Limited support for advanced PDF features like forms and annotations. </li>
<li class="readable-text5" id="p156"> Can be slow for large PDF files. </li>
</ol>
<div class="readable-text4" id="p157">
<p class="calibre54">ReportLab—a library for creating PDF documents from scratch, with support for text, graphics, and images.</p>
</div>
<div class="readable-text4" id="p158">
<p class="calibre54">Strengths:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p159"> Very powerful and flexible for creating complex PDF documents. </li>
<li class="readable-text5" id="p160"> Supports a wide range of PDF features. </li>
<li class="readable-text5" id="p161"> Good documentation and examples available. </li>
</ol>
<div class="readable-text4" id="p162">
<p class="calibre54">Weaknesses:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p163"> Steep learning curve for beginners. </li>
<li class="readable-text5" id="p164"> Can be slow for large PDF files. </li>
</ol>
<div class="readable-text4" id="p165">
<p class="calibre54">FPDF—a library for creating PDF documents from scratch, with support for text, graphics, and images.</p>
</div>
<div class="readable-text4" id="p166">
<p class="calibre54">Strengths:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p167"> Lightweight and easy to use. </li>
<li class="readable-text5" id="p168"> Good documentation and examples available. </li>
<li class="readable-text5" id="p169"> Supports a wide range of PDF features. </li>
</ol>
<div class="readable-text4" id="p170">
<p class="calibre54">Weaknesses:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p171"> Limited support for advanced PDF features like forms and annotations. </li>
<li class="readable-text5" id="p172"> Can be slow for large PDF files. </li>
</ol>
<div class="readable-text4" id="p173">
<p class="calibre54">PDFMiner—a library for extracting text and metadata from PDF files.</p>
</div>
<div class="readable-text4" id="p174">
<p class="calibre54">Strengths:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p175"> Very powerful and flexible for extracting text and metadata from PDF files. </li>
<li class="readable-text5" id="p176"> Supports a wide range of PDF features. </li>
<li class="readable-text5" id="p177"> Good documentation and examples available. </li>
</ol>
<div class="readable-text4" id="p178">
<p class="calibre54">Weaknesses:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p179"> Steep learning curve for beginners. </li>
<li class="readable-text5" id="p180"> Limited support for creating or manipulating PDF files. </li>
</ol>
<div class="readable-text4" id="p181">
<p class="calibre54">PyMuPDF—a library for working with PDF files, with support for text, graphics, and images.</p>
</div>
<div class="readable-text4" id="p182">
<p class="calibre54">Strengths:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p183"> Very fast and efficient for working with PDF files. </li>
<li class="readable-text5" id="p184"> Supports a wide range of PDF features. </li>
<li class="readable-text5" id="p185"> Good documentation and examples available. </li>
</ol>
<div class="readable-text4" id="p186">
<p class="calibre54">Weaknesses:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p187"> Steep learning curve for beginners. </li>
<li class="readable-text5" id="p188"> Limited support for creating or manipulating PDF files. </li>
</ol>
<div class="readable-text4" id="p189">
<p class="calibre54">pdfrw—a library for reading and writing PDF files, with support for text, graphics, and images.</p>
</div>
<div class="readable-text4" id="p190">
<p class="calibre54">Strengths:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p191"> Very powerful and flexible for reading and writing PDF files. </li>
<li class="readable-text5" id="p192"> Supports a wide range of PDF features. </li>
<li class="readable-text5" id="p193"> Good documentation and examples available. </li>
</ol>
<div class="readable-text4" id="p194">
<p class="calibre54">Weaknesses:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p195"> Steep learning curve for beginners. </li>
<li class="readable-text5" id="p196"> Can be slow for large PDF files. </li>
</ol>
<div class="readable-text" id="p197">
<p class="calibre15">Don’t be too intimidated by the “Steep learning curve for beginners” cautions in there. If Copilot has been trained on the library, then you may still be successful.</p>
</div>
<div class="readable-text" id="p198">
<p class="calibre15">Based on what we’ve learned here, we might eliminate PDFMiner because it apparently has “limited support for creating or manipulating PDF files,” but we’d keep all others in contention just in case we need them. For now, we’re going to proceed with PyPDF2 and see how it goes.</p>
</div>
<div class="readable-text" id="p199">
<h3 class="readable-text-h2" id="sigil_toc_id_140"><span class="calibre22">9.4.2</span> Writing the tool</h3>
</div>
<div class="readable-text" id="p200">
<p class="calibre15">Go ahead and install the PyPDF2 module. Be careful with the capitalization: the module is called exactly PyPDF2, not pypdf2, pyPDF2, or any other capitalization.</p>
</div>
<div class="readable-text" id="p201">
<p class="calibre15">In our previous example, we wrote a function to clean up an email that was on the clipboard. We didn’t need to pass any information to that function, so the function had no parameters. Here, our function will need three parameters: the name of the directory with the reports, the name of the directory with the covers, and the name of the directory where we want to write our finalized (merged) .pdf files.</p>
</div>
<div class="readable-text" id="p202">
<p class="calibre15">In our docstring, we need to explain what each of these directories is for and also the pattern of the filenames in the directories. After all, Copilot will need to know how the reports match up with the cover pages.</p>
</div>
<div class="readable-text" id="p203">
<h4 class="readable-text-h3">Trying PyPDF2 </h4>
</div>
<div class="readable-text" id="p204">
<p class="calibre15">We’re going to use the PyPDF2 Python library to try to get the job done. Look back to what Copilot Chat told us about the PyPDF2 library. The sample code it gave us used <code class="calibre25">PdfFileReader</code> to read existing .pdf files and <code class="calibre25">PdfFileWriter</code> to create a new .pdf file. It also used <code class="calibre25">getPage</code> and <code class="calibre25">addPage</code> to manipulate pages. Look out for these in the code that Copilot produces—they’re telltale signs that Copilot is generating code that’s on the right track. Here’s the prompt that we used and the code that Copilot gave us.</p>
</div>
<div class="browsable-container" id="p205">
<h5 class="listing-container-h"><span>Listing 9.3</span> Function to add covers to .pdf documents</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import PyPDF2</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">def add_covers(report_dir, cover_dir, final_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    report_dir is a directory of reports named 1.pdf, 2.pdf, and so on.</strong>
<strong class="calibre17">    These files may be one page or more than one page.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    cover_dir is a directory of covers, with one cover per report.</strong>
<strong class="calibre17">    The filenames in this directory are cover1.pdf, cover2.pdf, and </strong>
<strong class="calibre17">    so on. Each of these files is one page.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Add the cover to the beginning of each report,</strong>
<strong class="calibre17">    and store all resulting pdfs in final_dir.</strong>
<strong class="calibre17">    '''</strong>
    report_files = os.listdir(report_dir)     <strong class="calibre17">   </strong><span/> #1
    for report_file in report_files:                 <span/> #2
        report = open(os.path.join(report_dir, report_file), 'rb')
        report_reader = PyPDF2.PdfFileReader(report)        <span/> #3
        report_writer = PyPDF2.PdfFileWriter()                        <span/> #4
        for page_num in range(report_reader.numPages):             <span/> #5
            report_writer.addPage(  \      <strong class="calibre17">                     </strong><span/> #6
            report_reader.getPage(page_num))    <strong class="calibre17">                </strong> #6
        cover = open(os.path.join(cover_dir,                      <span/> #7
                     'cover' + report_file), 'rb')      <strong class="calibre17">          </strong> #6
        cover_reader = PyPDF2.PdfFileReader(cover)           <span/> #8
        report_writer.insertPage(  \                               <span/> #9
                      cover_reader.getPage(0), 0)        <strong class="calibre17">          </strong> #6
        result = open(os.path.join(final_dir, report_file), 'wb') #6
        report_writer.write(result)  <span/> #10
        report.close() #6
        cover.close() #6
        result.close() #6

if __name__ == '__main__': #6
    add_covers('reports', 'covers', 'final')  <span/> #11</pre>
<div class="code-annotations-overlay-container">
     #1 Gets list of the .pdf reports
     <br class="calibre1"/>#2 Loops through the .pdf reports
     <br class="calibre1"/>#3 We can use report_reader to read the pages of the report.
     <br class="calibre1"/>#4 We can use report_writer to write pages into a new .pdf file
     <br class="calibre1"/>#5 Loops through each page of the report
     <br class="calibre1"/>#6 Adds the page to our new .pdf file
     <br class="calibre1"/>#7 Opens the cover associated with this report
     <br class="calibre1"/>#8 We can use cover_reader to read the cover.
     <br class="calibre1"/>#9 Adds the cover to the start of our new .pdf file
     <br class="calibre1"/>#10 Saves our new .pdf file
     <br class="calibre1"/>#11 Calls our function to do all the merging!
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="callout-container">
<div class="readable-text" id="p206">
<h5 class="callout-container-h">Be careful with automation programs</h5>
</div>
<div class="readable-text" id="p207">
<p class="calibre15">Programs like the one we’ve written to merge .pdf files can rip through hundreds or thousands of files very quickly. If they aren’t operating correctly, they can easily result in damaged or lost files. Any time we use <code class="calibre25">open</code> with <code class="calibre25">'w'</code> or <code class="calibre25">'wb'</code> as the second parameter, it means that we’re overwriting a file.</p>
</div>
<div class="readable-text" id="p208">
<p class="calibre15">Let’s focus on this line from our program in listing 9.3:</p>
</div>
<div class="browsable-container" id="p209">
<div class="readable-text">
<pre class="code-area"><code class="calibre25">result = open(os.path.join(final_dir, report_file), 'wb')</code></pre>
</div>
</div>
<div class="readable-text" id="p210">
<p class="calibre15">It’s using the <code class="calibre25">open</code> function to open a file. Specifically, it’s opening the current <code class="calibre25">report_file</code> file in the <code class="calibre25">final_dir</code> directory. The second argument to <code class="calibre25">open</code> here, <code class="calibre25">'wb'</code>, means that we want to open the file so we can write to it (that’s the <code class="calibre25">'w'</code>) and that the file we’re writing is a binary file (that’s the <code class="calibre25">'b'</code>), not a text file. If the file doesn’t already exist, then the <code class="calibre25">'w'</code> we’ve included will result in the file being created. That’s not the dangerous part. The dangerous part is what happens when the file already exists. In that case, <code class="calibre25">'w'</code> wipes out its contents and gives us an empty file that we can start writing to. Now, if our program is working correctly and only doing this in our <code class="calibre25">final_dir</code>, then we’re OK. But this is what we need to carefully verify before letting our program loose.</p>
</div>
<div class="readable-text" id="p211">
<p class="calibre15">We highly recommend that you first test on a small directory of files that you don’t care about. Further, we recommend changing lines of code that open files using <code class="calibre25">'w'</code> or <code class="calibre25">'wb'</code> to print a harmless output message instead, so that you can see exactly which files are going to be overwritten or created. For example, in our program here, we need to comment out these two lines:</p>
</div>
<div class="browsable-container" id="p212">
<div class="readable-text">
<pre class="code-area">result = open(os.path.join(final_dir, report_file), 'wb')
report_writer.write(result)</pre>
</div>
</div>
<div class="readable-text" id="p213">
<p class="calibre15">Instead, we’ll use <code class="calibre25">print</code> to print out the file that we would have created or overwritten:</p>
</div>
<div class="browsable-container" id="p214">
<div class="readable-text">
<pre class="code-area">print('Will write', os.path.join(final_dir, report_file))</pre>
</div>
</div>
<div class="readable-text" id="p215">
<p class="calibre15">Then, when you run your program, you’ll see the names of files that the program <em class="calibre18">intended </em>to write. If the output looks good—that is, the program is operating exactly on the files that you wanted it to operate on—then you can uncomment the code that actually does the work.</p>
</div>
<div class="readable-text" id="p216">
<p class="calibre15">Exercise caution, and <em class="calibre18">always</em> keep backups of your important files!</p>
</div>
</div>
<div class="readable-text" id="p217">
<p class="calibre15">The last line of the program in listing 9.3 makes the assumption that the directory of reports is called <code class="calibre25">reports</code>, the directory of cover pages is called <code class="calibre25">covers</code>, and the directory where the final .pdf files should go is called <code class="calibre25">final</code>.</p>
</div>
<div class="readable-text" id="p218">
<p class="calibre15">Now, create the <code class="calibre25">final</code> directory. It should be there along with your <code class="calibre25">reports</code> and <code class="calibre25">covers</code> directories.</p>
</div>
<div class="readable-text" id="p219">
<p class="calibre15">The overall structure of the code looks promising to us: it’s getting a list of the .pdf reports, and then, for each one, it’s merging those pages with the cover page. It’s using a <code class="calibre25">for</code> loop to loop through the pages of the report, which is good because it can grab all the pages that way. By contrast, it’s <em class="calibre18">not </em>using a <code class="calibre25">for</code> loop on the cover .pdf file, which again is good because we know that the cover has only one page anyway.</p>
</div>
<div class="readable-text" id="p220">
<p class="calibre15">However, the first line of code it gave us looks like it’s using a function called <code class="calibre25">listdir</code> in a module called os. There are other lines that use this module as well. Do we need to be importing that os module? Indeed, we do! And we can prove it by running the code. If you run the code, you’ll get an error:</p>
</div>
<div class="browsable-container" id="p221">
<div class="readable-text">
<pre class="code-area">Traceback (most recent call last):
  File "merge_pdfs.py", …
    add_covers('reports', 'covers', 'final')
  File " merge_pdfs.py",  …
    report_files = os.listdir(report_dir)
                   ^^
NameError: name 'os' is not defined</pre>
</div>
</div>
<div class="readable-text" id="p222">
<p class="calibre15">We need to add <code class="calibre25">import os</code> at the start of our program to fix this. The updated code is in the following listing. </p>
</div>
<div class="browsable-container" id="p223">
<h5 class="listing-container-h"><span>Listing 9.4</span> Improved function to add covers to .pdf documents</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import os         </strong><span/> #1
<strong class="calibre17">import PyPDF2</strong>

<strong class="calibre17">def add_covers(report_dir, cover_dir, final_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    report_dir is a directory of reports named 1.pdf, 2.pdf, and so on.</strong>
<strong class="calibre17">    These files may be one page or more than one page.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    cover_dir is a directory of covers, with one cover per report.</strong>
<strong class="calibre17">      The filenames in this directory are cover1.pdf, cover2.pdf, and so on.</strong>
<strong class="calibre17">    Each of these files is one page.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Add the cover to the beginning of each report,</strong>
<strong class="calibre17">    and store all resulting pdfs in final_dir.</strong>
<strong class="calibre17">    '''</strong>
    report_files = os.listdir(report_dir)
    for report_file in report_files:
        report = open(os.path.join(report_dir, report_file), 'rb')
        report_reader = PyPDF2.PdfFileReader(report)
        report_writer = PyPDF2.PdfFileWriter()
        for page_num in range(report_reader.numPages):
            report_writer.addPage(report_reader.getPage(page_num))
        cover = open(os.path.join(cover_dir, 'cover' + report_file), 'rb')
        cover_reader = PyPDF2.PdfFileReader(cover)
        report_writer.insertPage(cover_reader.getPage(0), 0)
        result = open(os.path.join(final_dir, report_file), 'wb')
        report_writer.write(result)
        report.close()
        cover.close()
        result.close()

if __name__ == '__main__':
    add_covers('reports', 'covers', 'final')</pre>
<div class="code-annotations-overlay-container">
     #1 We were missing this import before.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p224">
<p class="calibre15">We’re not out of the woods yet, though. Our updated program still doesn’t work. Here’s the error we get when we run our program:</p>
</div>
<div class="browsable-container" id="p225">
<div class="readable-text">
<pre class="code-area">Traceback (most recent call last):
  File "merge_pdfs.py", line 34, in &lt;module&gt;
    add_covers('reports', 'covers', 'final')
  File "merge_pdfs.py", line 20, in add_covers
    report_reader = PyPDF2.PdfFileReader(report)    <span/> #1
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "...\PyPDF2\_reader.py", line 1974, in __init__
    deprecation_with_replacement("PdfFileReader", "PdfReader", "3.0.0")
  File "...\PyPDF2\_utils.py", line 369, in deprecation_with_replacement
    deprecation(DEPR_MSG_HAPPENED.format(old_name, removed_in, new_name))
  File "...\PyPDF2\_utils.py", line 351, in deprecation
    raise DeprecationError(msg)
PyPDF2.errors.DeprecationError: PdfFileReader is <strong class="calibre17">  </strong><span/> #2
deprecated and was removed in PyPDF2 3.0.0. Use  <strong class="calibre17">  </strong> #2
PdfReader instead.                               <strong class="calibre17">  </strong> #2</pre>
<div class="code-annotations-overlay-container">
     #1 The line in our code that’s causing an error
     <br class="calibre1"/>#2 We can’t use PdfFileReader anymore—it’s gone!
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p226">
<p class="calibre15">We’ve run into the problem where Copilot thinks, “Hey, let’s use <code class="calibre25">PdfFileReader</code>, since I’ve been trained that this is part of PyPDF2,” but between Copilot being trained and the time of our writing, the PyPDF2 maintainers have removed <code class="calibre25">PdfFileReader</code> and replaced it with something else (<code class="calibre25">PdfReader</code>, according to the final line of the error message). This discrepancy may very well be fixed for you by the time you read this book, but we want to pretend it’s still messed up so that we can teach you what to do if this does happen to you in the future. At this point, we have three options:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p227"> <em class="calibre18">Install an earlier version of PyPDF2.</em> The last two lines of the error message tell us that <code class="calibre25">PdfFileReader</code>, the function we need from PyPDF2, was removed in PyPDF2 3.0.0. As a result, if we install a version of PyPDF2 earlier than 3.0.0, we should have our function back. In general, installing earlier versions of libraries isn’t advisable because security concerns may be present in those versions that have since been fixed in more recent versions. In addition, there may be bugs present in the older versions that have since been fixed. It’s worth googling what has been changed in the library recently to determine whether using an older version is safe. In this case, we have done that homework and see no obvious risk in using an older version of PyPDF2. </li>
<li class="readable-text1" id="p228"> <em class="calibre18">Fix the code ourselves using the suggestion in the error message.</em> That is, we would replace <code class="calibre25">PdfFileReader</code> with <code class="calibre25">PdfReader</code> and run the program again. In this case, we would be told about other deprecations, and we’d need to fix those following the same process. It’s very nice of the authors of PyPDF2 to tell us what to do inside the error messages. For practice, you might like to work through this, making each update suggested by the error message. We wish all error messages were so useful, but this won’t always be the case. Sometimes, a function will be removed without giving us any recourse. In that case, it may be easier to consider our next option. </li>
<li class="readable-text1" id="p229"> <em class="calibre18">Use a different library.</em> Earlier, we asked Copilot for other possible .pdf Python libraries we could use, and we received many suggestions. If the first two of our options here aren’t satisfactory, we could jump to trying one of those. </li>
</ul>
<div class="readable-text" id="p230">
<p class="calibre15">We’re going to illustrate how to solve the problem and get our code running with the first option (using an earlier version of PyPDF2) and the third option (using a different library entirely).</p>
</div>
<div class="readable-text" id="p231">
<h4 class="readable-text-h3">Using an earlier version of PyPDF2</h4>
</div>
<div class="readable-text" id="p232">
<p class="calibre15">When using <code class="calibre25">pip install</code> to install a Python library, by default, we get the most current version of the library. That’s usually what we want—the latest and greatest—but it’s also possible to explicitly request an older version of the library. </p>
</div>
<div class="readable-text" id="p233">
<p class="calibre15">Here, we need a version of PyPDF2 prior to version 3.0.0. Rather than the standard usage of pip,</p>
</div>
<div class="browsable-container" id="p234">
<div class="readable-text">
<pre class="code-area">pip install PyPDF2</pre>
</div>
</div>
<div class="readable-text" id="p235">
<p class="calibre15">we can instead use</p>
</div>
<div class="browsable-container" id="p236">
<div class="readable-text">
<pre class="code-area">pip install "PyPDF2 &lt; 3.0.0"</pre>
</div>
</div>
<div class="readable-text" id="p237">
<p class="calibre15">The <code class="calibre25">&lt; 3.0.0</code> is what we use to ask for the most recent version of the library that’s less than version 3.0.0. The command should result in output like the following:</p>
</div>
<div class="browsable-container" id="p238">
<div class="readable-text">
<pre class="code-area">Collecting PyPDF2&lt;3.0.0
  Installing collected packages: PyPDF2
  Attempting uninstall: PyPDF2
    Found existing installation: PyPDF2 3.0.1    <span/> #1
    Uninstalling PyPDF2-3.0.1:                 <span/> #2
      Successfully uninstalled PyPDF2-3.0.1
Successfully installed PyPDF2-2.12.1         <span/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 We had an existing version that is &amp;gt;= 3.0.0.
     <br class="calibre1"/>#2 That version is being removed . . . 
     <br class="calibre1"/>#3 . . . and version 2.12.1 is being installed.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p239">
<p class="calibre15">Now we have an older version of PyPDF2 installed. At this point, you should be able to run our program. It’ll take a few seconds, and then the job will be done. You can check your final directory for the newly created .pdf files. Open a few of them to make sure that our program has done the right thing: each .pdf file should start with a cover page and contain all the pages of the report (not just the first page if the report has multiple pages).</p>
</div>
<div class="readable-text" id="p240">
<p class="calibre15">Think of how tedious this would have been by hand, and we’ve gotten the computer to do it for us. Moreover, the next time we have to do the same thing at work (more reports for more people), we’ve got a tool all set to help us get it done quickly.</p>
</div>
<div class="readable-text" id="p241">
<h4 class="readable-text-h3">Using a different .pdf library </h4>
</div>
<div class="readable-text" id="p242">
<p class="calibre15">Now let’s try solving our problem with PyPDF2 by using another library—one of those that Copilot told us about in our initial conversation about .pdf libraries.</p>
</div>
<div class="readable-text" id="p243">
<p class="calibre15">We won’t go through all the gory details with you on how we decided which library to try next, but we’ll walk through the highlights of our journey. We started by asking Copilot Chat how we can use the ReportLab Python module to merge .pdf files, but that redirected us back to using PyPDF2. We received the same response for FPDF: we were told that FPDF can’t merge .pdf files but that PyPDF2 can. We then moved on to asking about PyMuPDF, and this part of the conversation was productive:</p>
</div>
<div class="readable-text4" id="p244">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>How can I use the Python PyMuPDF library to merge .pdf files?</p>
</div>
<div class="readable-text4" id="p245">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> You can use the fitz module from the PyMuPDF library to merge PDF files. Here’s an example code snippet that shows how to merge two PDF files using PyMuPDF:</p>
</div>
<div class="browsable-container" id="p246">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import fitz</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Merge the two PDF files</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pdf_files = ['file1.pdf', 'file2.pdf']</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pdf_writer = fitz.Document()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">for pdf_file in pdf_files:</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    pdf_reader = fitz.open(pdf_file)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    for page in pdf_reader:</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">        pdf_writer.insert_pdf(page)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pdf_writer.save('merged.pdf')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">pdf_writer.close()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p247">
<p class="calibre54">This code first creates a list of PDF files to merge (<code class="calibre25">file1.pdf</code> and <code class="calibre25">file2.pdf</code>). It then creates a new <code class="calibre25">Document</code> object using <code class="calibre25">fitz</code>, which represents the merged PDF. It loops through each PDF file in the list, opens it using <code class="calibre25">fitz</code>, and inserts each page of the PDF file into the <code class="calibre25">pdf_writer</code> object using the <code class="calibre25">insert_pdf()</code> method. Finally, it saves the merged PDF to a new file called <code class="calibre25">merged.pdf</code> using the <code class="calibre25">save()</code> method.</p>
</div>
<div class="readable-text4" id="p248">
<p class="calibre54">You can modify this code to add any additional content to the merged PDF using PyMuPDF. Just create a new <code class="calibre25">Page</code> object, add the content to the page, and insert the page into the <code class="calibre25">pdf_writer</code> object using the <code class="calibre25">insert_page()</code> method.</p>
</div>
<div class="readable-text" id="p249">
<p class="calibre15">The sample code here is using <code class="calibre25">insert_pdf</code> to add each .pdf file to the merged .pdf file. We should be on the lookout for our code using <code class="calibre25">insert_pdf</code> as well. The library is called PyMuPDF, so we need to install it with</p>
</div>
<div class="browsable-container" id="p250">
<div class="readable-text">
<pre class="code-area">pip install PyMuPDF</pre>
</div>
</div>
<div class="readable-text" id="p251">
<p class="calibre15">But then we have to use <code class="calibre25">import fitz</code>? Why <code class="calibre25">import fitz</code> and not <code class="calibre25">import PyMuPDF</code>? Apparently, the designers of this library liked fitz more than PyMuPDF, so we’ll need to go with it. It’s rare indeed, but occasionally we use one name to install the library and another to import it! </p>
</div>
<div class="callout-container">
<div class="readable-text" id="p252">
<h5 class="callout-container-h">If you encounter NameError when you import</h5>
</div>
<div class="readable-text" id="p253">
<p class="calibre15">If Python gives you a <code class="calibre25">NameError</code> referring to the library that you’re trying to import, it’s a good bet that you haven’t successfully imported that library. It could be that the library isn’t in fact installed, or that you need to use a different name to import it. Use Copilot Chat to have a conversation if you ever find that you’ve installed a library but can’t seem to import it.</p>
</div>
</div>
<div class="readable-text" id="p254">
<p class="calibre15">Now we’re ready to generate some code. The following listing shows the prompt that we used and the code that Copilot gave us.</p>
</div>
<div class="browsable-container" id="p255">
<h5 class="listing-container-h"><span>Listing 9.5</span> Improved function to add covers to .pdf documents</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import os</strong>
<strong class="calibre17">import fitz </strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">def add_covers(report_dir, cover_dir, final_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    report_dir is a directory of reports named 1.pdf, 2.pdf, and so on.</strong>
<strong class="calibre17">    These files may be one page or more than one page.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    cover_dir is a directory of covers, with one cover per report.</strong>
<strong class="calibre17">    The filenames in this directory are cover1.pdf, cover2.pdf, and so on.</strong>
<strong class="calibre17">    Each of these files is one page.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Add the cover to the beginning of each report,</strong>
<strong class="calibre17">    and store all resulting pdfs in final_dir.</strong>
<strong class="calibre17">    '''</strong>
    if not os.path.exists(final_dir):         <span/> #1
        os.mkdir(final_dir)                        <span/> #2
    for report in os.listdir(report_dir):            <span/> #3
        report_path = os.path.join(report_dir, report)
        cover_path = os.path.join(cover_dir, f'cover{report}')
        final_path = os.path.join(final_dir, report)
        cover_doc = fitz.open(cover_path)                  <span/> #4
        report_doc = fitz.open(report_path)      <span/> #5
        final_doc = fitz.open()               <span/> #6
        final_doc.insert_pdf(cover_doc)      <span/> #7
        final_doc.insert_pdf(report_doc)      <span/> #8
        final_doc.save(final_path)           <span/> #9

if __name__ == '__main__':
    add_covers('reports', 'covers', 'final')</pre>
<div class="code-annotations-overlay-container">
     #1 If the final_dir directory doesn’t exist, . . . 
     <br class="calibre1"/>#2 . . . create the final_dir directory.
     <br class="calibre1"/>#3 Loops through the .pdf reports
     <br class="calibre1"/>#4 Used to read the cover
     <br class="calibre1"/>#5 Used to read the report
     <br class="calibre1"/>#6 Used as our new output file
     <br class="calibre1"/>#7 Adds the cover to our new .pdf file
     <br class="calibre1"/>#8 Adds the report to our new .pdf file
     <br class="calibre1"/>#9 Saves our new .pdf file
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p256">
<p class="calibre15">This program happens to start with some code that creates the output directory if it doesn’t already exist. After that, the steps are similar to those in our earlier program that used PyPDF2, although the functions called by each program are different. (That makes sense because PyPDF2 and PyMuPDF are different libraries, with different features and functions.) In both cases, we’re using <code class="calibre25">listdir</code> to get a list of the report .pdf filenames. In the <code class="calibre25">for</code> loop, we go through each of those reports; the code in the loop is responsible for creating a new .pdf file that contains the cover followed by the report. In our PyPDF2 code, there was an inner <code class="calibre25">for</code> loop that we needed to loop through all the pages of the report. In our current program, we don’t need that because Copilot used the <code class="calibre25">insert_pdf</code> function, which inserts a .pdf file into another .pdf file in one shot (not page by page). Whether you took the approach of installing the older library or you chose to use a different library, we’ve solved our problem and automated what would have been an unpleasantly tedious task.</p>
</div>
<div class="readable-text" id="p257">
<p class="calibre15">Notice that we’ve slightly altered the workflow that we described in the previous chapter to take into account handling the different Python modules that could aid you with your task. A modified workflow is provided in figure 9.2.<span/></p>
</div>
<div class="browsable-container" id="p258">
<img alt="figure" src="../Images/9-2.png" class="calibre82"/>
<h5 class="figure-container-h"><span>Figure 9.2</span> Additions to our workflow to account for working with different Python modules</h5>
</div>
<div class="readable-text" id="p259">
<h2 class="readable-text-h1" id="sigil_toc_id_141"><span class="calibre22">9.5</span> Example 3: Merging phone picture libraries</h2>
</div>
<div class="readable-text" id="p260">
<p class="calibre15">Now suppose that you take a lot of pictures on your phone. Your partner (or sibling, parent, or child) also takes a lot of pictures on their phone. You each have hundreds or thousands of pictures! Sometimes you send pictures to your partner, and they send pictures to you, so that you and your partner have some but not all of each other’s pictures.</p>
</div>
<div class="readable-text" id="p261">
<p class="calibre15">You live life like this for a while, but honestly, it’s becoming a mess. Half the time when you want a picture, you can’t find it because it’s a picture that your partner took on their phone that they didn’t send you. And, you’re starting to have many duplicate pictures all over the place.</p>
</div>
<div class="readable-text" id="p262">
<p class="calibre15">You then have an idea: “What if we take all the pictures from my phone and all the pictures from your phone, and we create a combined library of all the pictures! Then we’ll have all the pictures in one place!” Remember that both of your phones may have hundreds of pictures, so doing this manually is out of the question. We’re going to automate this!</p>
</div>
<div class="readable-text" id="p263">
<p class="calibre15">To specify our task more precisely, we’ll say that we have two directories of pictures (think of each directory as the contents of a phone) that we want to combine into a new directory. A common file format for pictures is a .png file, so we’ll work with those files here. Your actual phone might use .jpg files rather than .png files, but don’t worry. You can adapt what we do here to that picture file format (or any other picture file format) if you like.</p>
</div>
<div class="readable-text" id="p264">
<p class="calibre15">In the resources for this book, in the ch9 directory, you’ll find two subdirectories of picture files. These subdirectories are named pictures1 and pictures2. You can imagine that pictures1 has the pictures from your phone (98 pictures) and pictures2 has the pictures from your partner’s phone (112 pictures). We’re going to combine these two phone directories into a new directory.</p>
</div>
<div class="readable-text" id="p265">
<p class="calibre15">Open some of the .png files in the same way that you open pictures or photos on your computer. The pictures we’ve generated are just some random shapes, but the program we write here will work no matter what’s inside the pictures.</p>
</div>
<div class="readable-text" id="p266">
<p class="calibre15">At the outset, we said that the same picture might be on both phones, so we’ve generated some duplicate files in our pictures. (We have a total of 210 picture files, but 10 of them are duplicates, so there are only 200 unique pictures.) For example, in the pictures1 directory, there’s a file called 1566.png, and in the pictures2 directory, there’s a file called 2471.png. These two files are identical, and when we generate our directory of files from both phones, we’ll only want to keep one of these. What’s tricky here is that these pictures are the same even though their filenames are not.</p>
</div>
<div class="readable-text" id="p267">
<p class="calibre15">What if two filenames are the same? Does that mean that the pictures are the same? For example, notice that each directory, pictures1 and pictures2, has a file called 9595.png. You might think that filenames being the same means that the pictures inside will be the same too. But no, if you open these pictures, you’ll see that they’re different! This could happen in real life too: you and your partner could both take different pictures, and, however remote, it’s possible that the filenames your phones choose for those pictures just happen to be the same.</p>
</div>
<div class="readable-text" id="p268">
<p class="calibre15">If we’re not careful, we’ll end up copying 9595.png from pictures1 into our new directory and then overwriting it later by copying 9595.png from pictures2 into our new directory. We need to be sure that when we copy a file, we’re not overwriting a different picture that may already be there with the same filename. We provide an example of this process in figure 9.3.<span/></p>
</div>
<div class="browsable-container" id="p269">
<img alt="figure" src="../Images/9-3.png" class="calibre83"/>
<h5 class="figure-container-h"><span>Figure 9.3</span> Example of merging the photos in the pictures1 and pictures2 folders into the pictures–combined folder and managing the removal of duplicates</h5>
</div>
<div class="callout-container">
<div class="readable-text" id="p270">
<h5 class="callout-container-h">We’re working with directories, not actual phones</h5>
</div>
<div class="readable-text" id="p271">
<p class="calibre15">We’re assuming here that you have two directories of pictures already on your computer. These directories could have come from anywhere, and nothing we do here has anything specific to do with cell phones.</p>
</div>
<div class="readable-text" id="p272">
<p class="calibre15">But if you wanted to do this task for real, with pictures on your phones, you’d need to get those pictures onto your computer first. You could use ChatGPT to have that discussion! As the details are specific to different phones and go beyond what we want to use Copilot to automate, we won’t go further into this here.</p>
</div>
</div>
<div class="readable-text" id="p273">
<h3 class="readable-text-h2" id="sigil_toc_id_142"><span class="calibre22">9.5.1</span> Conversing with Copilot</h3>
</div>
<div class="readable-text" id="p274">
<p class="calibre15">Our tool is going to create a combined directory of pictures from pictures1 and pictures2, but without duplicate pictures. If our combined original picture directories have the same picture multiple times, we want only one of those copies of the picture to survive in our new directory. </p>
</div>
<div class="readable-text" id="p275">
<p class="calibre15">At this point, there are at least two things we might like to know: How do we copy a file using Python, and how do we know whether two files are the same picture? Let’s start by asking Copilot Chat how we can copy a file:</p>
</div>
<div class="readable-text4" id="p276">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>I need to write a Python program that copies files. How do I do this?</p>
</div>
<div class="readable-text4" id="p277">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> You can use the shutil module in Python to copy files. Here’s an example:</p>
</div>
<div class="browsable-container" id="p278">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import shutil</em></code></em>

<em class="calibre18"><code class="calibre25"><em class="calibre18"># Replace the source and destination paths with your own</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">source = '/path/to/source/file'</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">destination = '/path/to/destination/file'</em></code></em>

<em class="calibre18"><code class="calibre25"><em class="calibre18"># Copy the file</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">shutil.copy(source, destination)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p279">
<p class="calibre54">This will copy the file from the source path to the destination path. If the destination file already exists, it will be overwritten.</p>
</div>
<div class="readable-text" id="p280">
<p class="calibre15">Excellent. We can use that shutil module to copy a file; we’ll need to remember to import that module. The final sentence that Copilot gave us is an important warning. We should be careful to avoid copying a file over the top of another file that already exists. Next, let’s determine whether this shutil module is built-in to Python.</p>
</div>
<div class="readable-text4" id="p281">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Is this shutil module built into Python?</p>
</div>
<div class="readable-text4" id="p282">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Yes, the shutil module is a built-in module in Python, so you don’t need to install anything extra to use it.</p>
</div>
<div class="readable-text" id="p283">
<p class="calibre15">You might wonder why we’re focusing on making copies of files and putting them into our new directory, rather than moving them from our original directories into the new directory. The reason is that we want to leave our original directories alone just in case we have a bug and fail to get all the files into our new directory. If anything goes wrong in our new directory, it won’t matter because our original directories will still be intact. </p>
</div>
<div class="readable-text" id="p284">
<p class="calibre15">That wraps up what we need to know about copying files. Now let’s move on to learn how we can determine whether two files are the same picture.</p>
</div>
<div class="readable-text" id="p285">
<p class="calibre15">As we’ve already said, it’s not sufficient to use filenames to determine whether pictures are the same. How can we do it, then?</p>
</div>
<div class="readable-text4" id="p286">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Using Python, how can I determine whether .png files are the same?</p>
</div>
<div class="readable-text4" id="p287">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> You can use the filecmp module in Python to compare two files and check if they are the same. Here’s an example code snippet that compares two .png files:</p>
</div>
<div class="browsable-container" id="p288">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import filecmp</em></code></em>

<em class="calibre18"><code class="calibre25"><em class="calibre18"># Replace these file paths with the actual file paths of the .png files </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># you want to compare</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">file1 = '/path/to/file1.png'</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">file2 = '/path/to/file2.png'</em></code></em>

<em class="calibre18"><code class="calibre25"><em class="calibre18">if filecmp.cmp(file1, file2):</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> print('The files are the same.')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">else:</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> print('The files are different.')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p289">
<p class="calibre54">This code will compare the contents of the two files and return <code class="calibre25">True</code> if they are the same, and <code class="calibre25">False</code> if they are different.</p>
</div>
<div class="readable-text" id="p290">
<p class="calibre15">As a quick aside, the last sentence from Copilot is wrong. That code isn’t returning <code class="calibre25">True</code> or <code class="calibre25">False</code> anywhere. Just like Copilot can generate faulty code for us in our Python file, Copilot Chat can produce faulty explanations.</p>
</div>
<div class="readable-text" id="p291">
<p class="calibre15">Our prompt wasn’t precise about the number of files that we need to compare. Do we want to compare two files? Hundreds of files? Our prompt doesn’t say. Copilot has told us what to do if we want to compare two files, which is a reasonable thing to tell us. But that’s not quite what we need. We need to be able to determine, among hundreds of files, which files are duplicates of other files. That way, we can detect a duplicate file and not copy it into our new directory. Let’s try again.</p>
</div>
<div class="readable-text4" id="p292">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>What if I have hundreds of .png files and I want to find duplicates—is that approach you gave me still good?</p>
</div>
<div class="readable-text4" id="p293">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> If you have hundreds of .png files and you want to find duplicates, you can use the os module to iterate over all the files in a directory and compare each file to every other file in the directory. Here’s an example code snippet that does that:</p>
</div>
<div class="browsable-container" id="p294">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import os</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import filecmp</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Replace this with the actual directory path where your .png </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># files are located</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">directory = '/path/to/directory'</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Iterate over all the files in the directory</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">for filename1 in os.listdir(directory):</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">    if filename1.endswith('.png'):</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">        for filename2 in os.listdir(directory):</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">            if filename2.endswith('.png') and filename1 != filename2:</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">                file1 = os.path.join(directory, filename1)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">                file2 = os.path.join(directory, filename2)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">                if filecmp.cmp(file1, file2):</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">                    print(f'{filename1} and {filename2} are duplicates.')</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p295">
<p class="calibre54">This code will iterate over all the files in the directory and compare each <code class="calibre25">.png</code> file to every other <code class="calibre25">.png</code> file in the directory. If two files are the same, it will print a message indicating that they are duplicates. Note that this approach can be slow for large directories with many files.</p>
</div>
<div class="readable-text" id="p296">
<p class="calibre15">The outer <code class="calibre25">for</code> loop goes through each file in the directory. How do we know whether the current file has a duplicate? Well, we can go through each other file in the directory and compare it to the current file. That’s the role of the inner <code class="calibre25">for</code> loop: it uses <code class="calibre25">filecmp.cmp</code> to compare the current file (<code class="calibre25">file1</code>) to each other file (<code class="calibre25">file2</code>).</p>
</div>
<div class="readable-text" id="p297">
<p class="calibre15">We didn’t mention in our prompt that we care about finding duplicates across multiple directories, so Copilot has focused on a single directory here. If that difference turns out to be a roadblock, we could make our prompt more precise. </p>
</div>
<div class="readable-text" id="p298">
<p class="calibre15">Copilot is using two other modules here, os and filecmp. We could ask Copilot if these are built-in Python modules or not, but we’ll save a little time and just tell you here that they are built-in.</p>
</div>
<div class="readable-text" id="p299">
<p class="calibre15">We now want you to focus on the final sentence from Copilot: “Note that this approach can be slow for large directories with many files.” How slow is “slow”? How many is “many”? We don’t know. </p>
</div>
<div class="readable-text" id="p300">
<p class="calibre15">You might be tempted to ask Copilot for a better solution, one that isn’t “slow for large directories with many files.” But many programmers wouldn’t do that. It’s often a mistake to optimize our solution before we have even tried out our (unoptimized, apparently slow) approach for two reasons. First, maybe our “slow” program turns out to be fast enough! We may as well try it. Second, more optimized programs are often more sophisticated programs, and they may be more difficult for us to get right. That isn’t always the case, but it can be. And again, if our unoptimized program gets the job done, we don’t even have to worry about a more optimized version at all.</p>
</div>
<div class="readable-text" id="p301">
<p class="calibre15">Now, if it turns out that our program really is too slow or you find yourself using the program repeatedly, then it may be worth the extra investment in continuing to work with Copilot on a faster solution. For now, though, we’re good.</p>
</div>
<div class="readable-text" id="p302">
<h3 class="readable-text-h2" id="sigil_toc_id_143"><span class="calibre22">9.5.2</span> Top-down design</h3>
</div>
<div class="readable-text" id="p303">
<p class="calibre15">There’s a little more going on in this task than in our prior two tasks. For one, we need to be careful not to overwrite a file that already exists in our new directory. For another, we need to determine which files to copy in the first place (remember that we only want to copy files that don’t already match a file in our new directory). Compare this to the .pdf merging task we just accomplished, where we didn’t have these extra concerns. </p>
</div>
<div class="readable-text" id="p304">
<p class="calibre15">To that end, we’re going to use top-down design and problem decomposition here. Don’t worry, it won’t be a full-on top-down design example like we did in chapter 7. Our task here is much smaller than our spelling suggestions task from that chapter. We’ll just do a little top-down design and that will help Copilot get us what we want.</p>
</div>
<div class="readable-text" id="p305">
<p class="calibre15">Our top-level function will be responsible for solving our overall task: taking the pictures1 and pictures2 directories and putting all unique pictures into a target directory. Back in chapter 3, we learned that we should make functions as general as we can, to make them more useful or generalizable to other tasks. Here, we’ve been thinking about combining two picture directories together. But why not 3, 5, or 50 directories? Who cares how many directories we have; we should be able to just combine as many directories as we want.</p>
</div>
<div class="readable-text" id="p306">
<p class="calibre15">So, instead of designing our top-level function to take two strings (directory names) as parameters, we’ll have the function take a list of strings. That way, we can use it on as many picture directories as we want. And, we can still readily use it on two picture directories—we’ll just pass a list containing the names of the two directories.</p>
</div>
<div class="readable-text" id="p307">
<p class="calibre15">We’ll name our top-level function <code class="calibre25">make_copies</code>. We’ll need two parameters: the list of directory names that we just discussed, and the name of our target directory where we want all the files to go.</p>
</div>
<div class="readable-text" id="p308">
<p class="calibre15">What’s this function going to do? It’s going to loop through each directory in the list of directories, and then, for each directory, it’s going to loop through each file. For each file, we need to determine whether to copy it or not and, if we need to copy it, to do the actual copying.</p>
</div>
<div class="readable-text" id="p309">
<p class="calibre15">Determining whether to copy the file, and then possibly copying it, is a subtask that we can split out of <code class="calibre25">make_copies</code>. We’ll name our function for this subtask <code class="calibre25">make_copy</code>. Our <code class="calibre25">make_copy</code> function will take two parameters: the name of a file and the target directory. If the file isn’t identical to any file in the target directory, then the function will copy the file into the target directory.</p>
</div>
<div class="readable-text" id="p310">
<p class="calibre15">Say we want to copy a file called 9595.png from one of our picture directories into our target directory but that file already exists in the target directory. We don’t want to overwrite the file that’s already there, so we’ll need to come up with a new filename. We might try adding an _ (underscore) character prior to the .png part of the filename. That would give us 9595_.png. That one probably wouldn’t exist in the target directory, but if it did, we could then try 9595__.png, 9595___.png, and so on, until we find a filename that doesn’t already exist in there.</p>
</div>
<div class="readable-text" id="p311">
<p class="calibre15">Generating a unique filename is a task that we can split out of our <code class="calibre25">make_copy</code> function. We’ll call it <code class="calibre25">get_good_filename</code>. It will take a filename as a parameter and return a version of that filename that doesn’t already exist.</p>
</div>
<div class="readable-text" id="p312">
<p class="calibre15">And with that, our top-down design is done. Figure 9.4 depicts our work as a tree (well, at least the trunk of a tree), showing which function is called by which other function.<span/></p>
</div>
<div class="browsable-container" id="p313">
<img alt="figure" src="../Images/9-4.png" class="calibre84"/>
<h5 class="figure-container-h"><span>Figure 9.4</span> Top-down design for image merging. The top-most (left-most) function is <code class="calibre25">make_copies</code>, the child of that is <code class="calibre25">make_copy</code>, and the child of that is <code class="calibre25">get_good_filename</code>.</h5>
</div>
<div class="readable-text" id="p314">
<h3 class="readable-text-h2" id="sigil_toc_id_144"><span class="calibre22">9.5.3</span> Writing the tool</h3>
</div>
<div class="readable-text" id="p315">
<p class="calibre15">We don’t have any modules to install this time around. We do know from our Copilot conversation that we’ll use the built-in shutil module to copy files. We’ll also use the built-in filecmp module to compare files and the built-in os module to get a list of the files in a directory. We’ll therefore import these three modules at the top of our Python program.</p>
</div>
<div class="readable-text" id="p316">
<p class="calibre15">As in chapter 7, we’re going to solve our problem by starting at the bottom of our function tree and working toward the top. We do that so Copilot can call our already-written functions when writing code for a parent function. For each function, we provide the <code class="calibre25">def</code> line and docstring, and Copilot writes the code. We’ve also provided some annotations to explain how the code works.</p>
</div>
<div class="readable-text" id="p317">
<p class="calibre15">Looking again at figure 9.4, we see that the first function we need to implement is <code class="calibre25">get_good_filename</code>. Let’s get that one done now in the following listing.</p>
</div>
<div class="browsable-container" id="p318">
<h5 class="listing-container-h"><span>Listing 9.6</span> <code class="calibre25">get_good_filename</code> function for our picture merge task</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import shutil</strong>
<strong class="calibre17">import filecmp</strong>
<strong class="calibre17">import os</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">def get_good_filename(fname):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    fname is the name of a png file.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    While the file fname exists, add an _ character</strong>
<strong class="calibre17">    right before the .png part of the filename;</strong>
<strong class="calibre17">    e.g. 9595.png becomes 9595_.png.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Return the resulting filename.</strong>
<strong class="calibre17">    '''</strong>
    while os.path.exists(fname):          <span/> #1
        fname = fname.replace('.png', '_.png')     <span/> #2
    return fname         <span/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 While the filename exists . . . 
     <br class="calibre1"/>#2 . . . insert an _ prior to .png by replacing .png with _.png.
     <br class="calibre1"/>#3 Returns the filename that we know now doesn’t exist
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p319">
<p class="calibre15">The next function we need to write is <code class="calibre25">make_copy</code>. This is the function that copies a file into a target directory but only if the file isn’t identical to a file that we’ve already copied. We’re looking for Copilot to do several things in its code here:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p320"> Use <code class="calibre25">os.listdir</code> to get a list of files in the target directory. </li>
<li class="readable-text1" id="p321"> Use <code class="calibre25">filecmp.cmp</code> to determine whether two files are identical. </li>
<li class="readable-text1" id="p322"> Use <code class="calibre25">shutil.copy</code> to copy the file if there was no identical file. </li>
<li class="readable-text1" id="p323"> Call the function <code class="calibre25">get_good_filename</code> that we just wrote. </li>
</ul>
<div class="readable-text" id="p324">
<p class="calibre15">The following listing shows our prompt and the code that Copilot provided. Notice that the code is doing everything that we wanted it to do.</p>
</div>
<div class="browsable-container" id="p325">
<h5 class="listing-container-h"><span>Listing 9.7</span> <code class="calibre25">make_copy</code> function for our pictures merge task</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def make_copy(fname, target_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    fname is a filename like pictures1/1262.png.</strong>
<strong class="calibre17">    target_dir is the name of a directory.</strong> #2
<strong class="calibre17"> </strong> #2
<strong class="calibre17">    Compare the file fname to all files in target_dir.</strong> #2
<strong class="calibre17">    If fname is not identical to any file in </strong> #2
<strong class="calibre17">    target_dir, copy it to target_dir</strong> #2
<strong class="calibre17">    '''</strong> #2
    for target_fname in os.listdir(target_dir):     <span/> #1
        if filecmp.cmp(fname, os.path.join(  \   <strong class="calibre17"> </strong><span/> #2
                   target_dir, target_fname)):   <strong class="calibre17"> </strong>
            return                                   <span/> #3
    shutil.copy(fname, get_good_filename(     <span/> #4
            os.path.join(target_dir,  \        #4
                 os.path.basename(fname))))  <strong class="calibre17"> </strong> #4</pre>
<div class="code-annotations-overlay-container">
     #1 Loops through the files in the target directory
     <br class="calibre1"/>#2 If the file is the same as one of the files in the target directory, . . . 
     <br class="calibre1"/>#3 . . . returns from the function without having copied the file.
     <br class="calibre1"/>#4 Otherwise, copies the file and uses a good filename that doesn’t already exist.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p326">
<p class="calibre15">There’s only one function to go, and it’s our top-level <code class="calibre25">make_copies</code> function. For each file in each of our picture directories, we’re expecting the code to call <code class="calibre25">make_copy</code> to copy the file if needed, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p327">
<h5 class="listing-container-h"><span>Listing 9.8</span> <code class="calibre25">make_copies</code> function for our picture merge task</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def make_copies(dirs, target_dir):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    dirs is a list of directory names.</strong>
<strong class="calibre17">    target_dir is the name of a directory.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Check each file in the directories and compare it to all files </strong>
<strong class="calibre17">    in target_dir. If a file is not identical to any file in </strong>
<strong class="calibre17">    target_dir, copy it to target_dir</strong>
<strong class="calibre17">    '''</strong>
    for dir in dirs:                        <span/> #1
        for fname in os.listdir(dir):             <span/> #2
            make_copy(os.path.join(dir, fname),  \  <span/> #3
                      target_dir)                    #3

make_copies(['pictures1', 'pictures2'], <strong class="calibre17">   </strong><span/> #4
             'pictures_combined')       <strong class="calibre17">   </strong> #3</pre>
<div class="code-annotations-overlay-container">
     #1 Loops through our picture directories
     <br class="calibre1"/>#2 Loops through the files in the current picture directory
     <br class="calibre1"/>#3 Copies the current file into the target directory, if needed
     <br class="calibre1"/>#4 Runs our program on our two picture directories and the given target directory
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p328">
<p class="calibre15">The final line of code from Copilot, beneath the <code class="calibre25">make_copies</code> function, makes the assumption that our target directory will be named pictures_combined. Create that directory now so that it sits alongside your pictures1 and pictures2 directories of pictures.</p>
</div>
<div class="readable-text" id="p329">
<p class="calibre15">As we discussed when working with .pdf files earlier in the chapter, it’s important that you first test the program on sample directories that you don’t care about. Your sample directories should have only a few files in them, so that you can manually determine whether the program is working as expected. You should also include important edge cases, such as having the same filename in each directory.</p>
</div>
<div class="readable-text" id="p330">
<p class="calibre15">Once you have your sample directories, you should create a “harmless” version of the program that simply outputs messages rather than actually copying files. For our program here, you would change the line in <code class="calibre25">make_copy</code> to use <code class="calibre25">print</code> rather than <code class="calibre25">shutil.copy</code>.</p>
</div>
<div class="readable-text" id="p331">
<p class="calibre15">If the output looks good after you check the results carefully, only then should you run the real program on your real directories. Remember that our program is copying (rather than moving) files, so even in our real directories, if something goes wrong, there’s a good chance that the problem will be in our new directory and not the original directories that we actually care about.</p>
</div>
<div class="readable-text" id="p332">
<p class="calibre15">We’ll assume that you’re now ready to run the program on the pictures1 and pictures2 directories. Once you run it, you can check your pictures_combined directory for the results. You should see that the directory has 200 files, which is exactly the number of unique pictures that we had across our two picture directories. Did we correctly handle the situation where the same filename existed in both picture directories but were different pictures? Yes, you can see that we have files named 9595.png and 9595_.png and that we therefore haven’t overwritten one with the other.</p>
</div>
<div class="readable-text" id="p333">
<p class="calibre15">Oh, and how long did the program take to run on your computer? At most a few seconds, right? It turns out that Copilot’s warning that “this approach can be slow for large directories with many files” didn’t matter for us. </p>
</div>
<div class="readable-text" id="p334">
<p class="calibre15">Now, we all know that people tend to have thousands of pictures on their phones, not hundreds. If you ran this program on two real phone picture libraries, you would again need to determine whether it completes in an acceptable amount of time. You could run the program and let it run for a minute or two or however long you’re willing to wait. For fun, we also tested our program on a total of 10,000 small image files (a more realistic scenario than the 210 pictures across our pictures1 and pictures2 directories that we used in this chapter), and we found that it only took 1 minute to complete. At some point, our program will become too slow to be practical, and that’s when you’d need to do further research with Copilot Chat to arrive at a more efficient program. </p>
</div>
<div class="readable-text" id="p335">
<p class="calibre15">In this chapter, we succeeded in automating three tedious tasks: cleaning up an email, adding covers to hundreds of .pdf files, and wrangling multiple picture libraries into one. The approach in each case was the same: use Copilot Chat to determine which module(s) to use, then follow the approach that we’ve honed throughout the book to have Copilot write the required code.</p>
</div>
<div class="readable-text" id="p336">
<p class="calibre15">Remember, whenever you find yourself repeating the same task, it’s worth trying to automate it using Copilot and Python. There are many helpful Python modules for doing so, beyond what we showed in this chapter. For example, there are modules to manipulate images, work with Microsoft Excel or Microsoft Word files, send email, scrape data from websites, and more. If it’s a tedious task, chances are that someone has made a Python module to help with it and that Copilot will be able to help you use that module effectively.</p>
</div>
<div class="readable-text" id="p337">
<h2 class="readable-text-h1" id="sigil_toc_id_145"><span class="calibre22">9.6</span> Exercises</h2>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p338"> You already have a tool that cleans up email text by removing any <code class="calibre25">&gt;</code> or space characters from the beginning of each line. What steps will you take to enhance this tool to also remove lines that are excessively short (e.g., lines with fewer than five characters, excluding spaces)? </li>
<li class="readable-text1" id="p339"> You’re writing a Python program to clean up a bunch of images that you have stored on your computer, and you’ve decided to use the Pillow library (a fork of the Python Image Library [PIL]). After installing the latest version of Pillow, you run your program but encounter the following error: </li>
</ol>
<div class="browsable-container" id="p340">
<div class="readable-text">
<pre class="code-area">Traceback (most recent call last):
  File "image_cleanup.py", line 4, in &lt;module&gt;
    resized_image = image.resize((new_width, new_height), Image.ANTIALIAS)
                                                          ^^^^^^^^^^^^^^^
AttributeError: module 'PIL.Image' has no attribute 'ANTIALIAS'</pre>
</div>
</div>
<div class="readable-text" id="p341">
<p class="calibre15">What steps can you take to fix this problem?</p>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p342"><span class="faux-ol-li-counter">3. </span> You’ve been given an Excel file named sales_data.xlsx that contains monthly sales data for different products. Your task is to write a Python program that reads the sales data, calculates the total sales for each product, and writes the results to a new Excel file named total_sales.xlsx. The sales_data.xlsx file has columns for each month (January, February, etc.). </li>
</ol>
<div class="readable-text" id="p343">
<p class="calibre15">Your program should do the following:</p>
<ol class="calibre58">
<li class="calibre30">Read the data from <code class="calibre25">sales_data.xlsx</code>.</li>
<li class="calibre30">Calculate the total sales for each product across all months.</li>
<li class="calibre30">Write the product names and their total sales to <code class="calibre25">total_sales.xlsx</code>.</li>
</ol>
</div>
<div class="readable-text" id="p344">
<p class="calibre15">Hints: make reasonable assumptions about the input file and you may need to import libraries to help you work with the .xlsx files. If you don’t have Excel or OpenOffice to read/write .xlsx files, feel free to do the task with .csv files instead.</p>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p345"><span class="faux-ol-li-counter">4. </span> It can be tedious to find news articles from different sources to read every day. Your task is to write a webscraper in Python that extracts and display the titles and URLs of the latest articles from a news website. You’ll need the beautifulsoup4 and requests modules. </li>
</ol>
<div class="readable-text" id="p346">
<h2 class="readable-text-h1" id="sigil_toc_id_146">Summary</h2>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p347"> Programmers often make tools to automate tedious tasks. </li>
<li class="readable-text1" id="p348"> It’s often necessary to use a Python module to help us write our tool. </li>
<li class="readable-text1" id="p349"> We can use Copilot Chat to determine which Python modules we should be using. </li>
<li class="readable-text1" id="p350"> It’s helpful to converse with Copilot to understand the pros and cons of various Python modules that may be available to us. </li>
<li class="readable-text1" id="p351"> There are Python modules for working with the clipboard, working with .pdf files and other file formats, copying files, and more. </li>
</ul>
</div></body></html>