<html><head></head><body><div id="book-content" class="calibre2"><div id="sbo-rt-content" class="calibre3"><section class="calibre6" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 1. Introduction to Prompt Engineering"><div class="preface" id="ch01_1_introduction_to_prompt_engineering_1728408393615260">
<h1 class="calibre5"><span class="firstname">Chapter 1. </span>Introduction to Prompt Engineering</h1>

<p class="subtitle">ChatGPT<a contenteditable="false" data-primary="ChatGPT" data-secondary="popularity of" data-type="indexterm" id="id280" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> was released in late November of 2022. By January of the following year, the application had accumulated an estimated 100 million monthly users, making ChatGPT the fastest-growing consumer application <em class="hyperlink">ever</em>. (In comparison, TikTok took 9 months to reach 100 million users, and Instagram took 2.5 years.) And as you can surely attest, esteemed reader, this public acclaim is well deserved! LLMs—like the one that backs ChatGPT—are<a contenteditable="false" data-primary="large language models (LLMs)" data-secondary="impact on workflow" data-type="indexterm" id="id281" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> revolutionizing the way we work. Rather than running to Google to find answers via a traditional web search, you can easily just ask an LLM to talk about a topic. Rather than reading Stack Overflow or rummaging through blog posts to answer technical questions, you can ask an LLM to write you a personalized tutorial on your exact problem space and then follow it up with a set of questions and answers (a Q&amp;A) about the topic. Rather than following the traditional steps to build a programming library, you can boost your progress by pairing with an LLM-based assistant to build the scaffolding and autocomplete your code as you write it!</p>

<p class="subtitle">And<a contenteditable="false" data-primary="large language models (LLMs)" data-secondary="potential uses for" data-type="indexterm" id="id282" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> to you, <em class="hyperlink">future</em> reader, will you use LLMs in ways that we, your humble authors from the year 2024, cannot fathom? If the current trends continue, you’ll likely have conversations with LLMs many times during the course of a typical day—in the voice of the IT support assistant when your cable goes out, in a friendly conversation with the corner ATM, and, yes, even with a frustratingly realistic robo dialer. There will be other interactions as well. LLMs will curate your news for you, summarizing the headline stories that you’re most likely to be interested in and removing (or perhaps <em class="hyperlink">adding</em>) biased commentary. You’ll use LLMs to assist in your communications by writing and summarizing emails, and office and home assistants will even reach out into the real world and interact on your behalf. In a single day, your personal AI assistant might at one point act as a travel agent, helping you make travel plans, book flights, and reserve hotels; and then at another point, act as a shopping assistant, helping you find and purchase items you need.</p>

<p class="subtitle">Why are LLMs so amazing? It’s because they are magic! As futurist Arthur C. Clarke famously stated, “Any sufficiently advanced technology is indistinguishable from magic.” We think a machine that you can have a conversation with certainly qualifies as magic, but it’s the goal of this book to dispel this magic. We will demonstrate that no matter how uncanny, intuitive, and humanlike LLMs sometimes seem to be, at the core, LLMs<a contenteditable="false" data-primary="large language models (LLMs)" data-secondary="basic functioning of" data-type="indexterm" id="id283" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> are simply models that predict the next word in a block of text—that’s it and nothing more! As such, LLMs are merely tools for helping users to accomplish some task, and the way that you interact with these tools is by crafting the<a contenteditable="false" data-primary="prompts, definition of" data-type="indexterm" id="id284" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">prompt</em>―the block of text―that they are to complete. This is what we call<a contenteditable="false" data-primary="prompt engineering" data-secondary="definition of term" data-type="indexterm" id="id285" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">prompt engineering</em>. Through this book, we will build up a practical framework for prompt engineering and ultimately for building LLM applications, which <em class="hyperlink">will</em> be a magical experience for your users.</p>

<p class="subtitle">This chapter sets the background for the journey you are about to take into prompt engineering. But first, let us tell you about how we, your authors, discovered the magic for ourselves.</p>

<section data-type="sect1" data-pdf-bookmark="LLMs Are Magic" class="calibre6"><div class="preface" id="ch01_1_llms_are_magic_1728408393615353">
<h1 class="calibre5">LLMs Are Magic</h1>

<p class="subtitle">Both<a contenteditable="false" data-primary="large language models (LLMs)" data-secondary="authors' discovery of" data-type="indexterm" id="LLMdiscovery01" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> authors of this book were early research developers for the GitHub Copilot code completion product. Albert was on the founding team, and John appeared on the scene as Albert was moving on to other distant-horizon LLM research projects.</p>

<p class="subtitle">Albert first discovered the magic halfway through 2020. He puts it as follows:</p>

<blockquote class="pcalibre6 pcalibre5 calibre11">
<p class="calibre20">Every half year or so, during our ideation meetings in the ML-on-code group, someone would bring up the matter of code synthesis. And the answer was always the same: it will be amazing, one day, but that day won’t come for another five years at least. It was our cold fusion.</p>

<p class="calibre20">This was true until the first day I laid hands on an early prototype of the LLM that would become OpenAI Codex. Then I saw that the future was now: cold fusion had finally arrived.</p>

<p class="calibre20">It was immediately clear that this model was wholly different from the sorry stabs at code synthesis we had known before. This model wouldn’t just have a chance of predicting the next word―it could generate whole statements and whole functions from just the docstring. Functions that worked!</p>

<p class="calibre20">Before we decided what we could build with this model (spoiler: it would eventually become GitHub’s Copilot code completion product), we wanted to quantify how good the model really was. So, we crowdsourced a bunch of GitHub engineers and had them come up with self-contained coding tasks. Some of the tasks were comparatively easy―but these were hardcore coders, and many of their tasks were also pretty involved. A good number of the tasks were the kind a junior developer would turn to Google for, but some would push even a senior developer to Stack Overflow. Yet, if we gave the model a few tries, it could solve most of them.</p>

<p class="calibre12">We knew it then—this was the engine that would usher in a new age of coding. All we had to do was build the right vehicle around it.</p>
</blockquote>

<p class="subtitle">For John, the magical moment came a couple years later, in early 2023, when he was kicking the tires on the vehicle and taking it out for a spin. He recounts it as follows:</p>

<blockquote class="pcalibre6 pcalibre5 calibre11">
<p class="calibre20">I set up a screen recording session and laid out the coding challenge that I planned to tackle: create a function that takes an integer and returns the text version of that number. So, given an input of 10, the output would be “ten,” and given an input of 1,004,712, the output would be “one million four thousand seven hundred twelve.” It’s harder than you might expect, because, thanks to English, weird exceptions abound. The text versions of numbers between 10 and 20—“eleven,” “twelve,” and the teens—don’t follow the same pattern as numbers in any other decade. The tens place digit breaks expected patterns—for example, if 90 is “ninety” and 80 is “eighty,” then why isn’t 30 “threety” and 20 “twoty?” But the real twist in my coding challenge was that I wanted to implement the solution in a language in which I had zero personal experience—Rust. Was Copilot up to the challenge?</p>

<p class="calibre12">Normally, when learning a new programming language, I would refer to the typical how-tos: How do I create a variable? How do I create a list? How do I iterate over the items in a list? How do I write an if statement? But with Copilot, I started by just writing a docstring:</p>
</blockquote>

<pre data-type="programlisting" class="calibre21">
// GOAL: Create a function that prints a string version of any number 
   supplied to the function.
// 1 -&gt; "one"
// 2034 -&gt; "two thousand thirty four"
// 11 -&gt; "eleven"
fn
        </pre>

<blockquote class="pcalibre6 pcalibre5 calibre11">Copilot saw <em class="hyperlink">fn</em> and jumped in to help:</blockquote>

<pre data-type="programlisting" class="calibre21">
fn number_to_string(number: i32) -&gt; String {</pre>

<blockquote class="pcalibre6 pcalibre5 calibre11">
<p class="calibre20">Perfect! I didn’t know how to annotate types for the input arguments or return value of functions, but as we continued to work together, I would direct the high-level flow of work via comments like “Split up the input number into groups of three digits,” and Copilot would effectively teach me programming constructs. These included things like how to create vectors and assign them to variables, as in <code class="calibre15">let mut number_string_vec = Vec::new();</code> and how to make loops, as in <code class="calibre15">while number &gt; 0 {.</code></p>

<p class="calibre12">The experience was great. I was making progress and learning the language without being distracted by constant references to language tutorials—my project was my tutorial. Then, 20 minutes into this experiment, Copilot blew my mind. I typed a comment and started the next control loop that I knew we would need:</p>
</blockquote>

<pre data-type="programlisting" class="calibre21">
// iterate through number_string_vec, assemble the name of the number 
// for each order of magnitude, and concatenate to number_string
for
</pre>

<blockquote class="pcalibre6 pcalibre5 calibre11">
<p class="calibre12">After a moment’s pause, Copilot interjected 30 lines of code! <a href="https://oreil.ly/4ZYWY" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">In the recording, you can actually hear me audibly gasp</a>. The code compiled successfully—it was all syntactically correct—and it ran. The answer was a little wonky. An input of 5,034,012 resulted in the string “five thirty four thousand twelve million,” but hey, I wouldn’t expect a human to be right the first time, and the bug was easy to spot and correct. By the end of the 40-minute pairing session, I’d done the impossible—I ’d created nontrivial code in a language that I was completely unfamiliar with! Copilot had coached me toward basic understanding of Rust syntax, and it had demonstrated a more abstract grasp of my goals and interjected at several points to help me fill in the details. If I had tried this on my own, I suspect it would have taken hours.</p>
</blockquote>

<p class="subtitle">Our magical experiences are not unique. If you’re reading this book, you’ve likely had some mind-blowing interactions with LLMs yourself. Perhaps you first became aware of the power of LLMs with ChatGPT, or maybe your first experience was with one of the first-generation applications that have been pouring out since early 2023: internet search assistants such as Microsoft’s Bing or Google’s Bard, or document assistants such as Microsoft’s broader Copilot suite of tools. But getting to this technological inflection point was not something that happened overnight. To truly understand LLMs, it is important to know how we got here.<a contenteditable="false" data-primary="" data-startref="LLMdiscovery01" data-type="indexterm" id="id286" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Language Models: How Did We Get Here?" class="calibre6"><div class="preface" id="ch01_1_language_models_how_did_we_get_here_1728408393615395">
<h1 class="calibre5">Language Models: How Did We Get Here?</h1>

<p class="subtitle">To<a contenteditable="false" data-primary="large language models (LLMs)" data-secondary="history of" data-type="indexterm" id="LLMhistory01" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="history" data-type="indexterm" id="history01" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> understand how we got to this very interesting point in the history of technology, we first need to know what a language model actually is and what it does. Who<a contenteditable="false" data-primary="ChatGPT" data-secondary="asked to describe LLMs" data-type="indexterm" id="id287" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> better to ask than the world’s most popular LLM application: ChatGPT (see <a data-type="xref" href="#ch01_1_figure_1_1728408393602766" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 1-1</a>).</p>

<figure class="calibre22"><div id="ch01_1_figure_1_1728408393602766" class="figure"><img alt="A screenshot of a phone  Description automatically generated" src="assets/pefl_0101.png" class="calibre23"/>
<h6 class="calibre24"><span class="firstname">Figure 1-1. </span>What is a language model?</h6>
</div></figure>

<p class="subtitle">See? It’s just like we said at the opening of the chapter: the<a contenteditable="false" data-primary="large language models (LLMs)" data-secondary="basic functioning of" data-type="indexterm" id="id288" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> primary goal of a language model is to predict the probability of the next word. You’ve seen this functionality before, haven’t you? It’s the bar of completion words that appears above the keypad when you’re typing out a text message on your iPhone (see <a data-type="xref" href="#ch01_1_figure_2_1728408393602779" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 1-2</a>). You might have never noticed it…<em class="hyperlink">because it isn’t that useful.</em> If this is all that language models do, then how on earth are they currently taking the world by storm?</p>

<figure class="calibre22"><div id="ch01_1_figure_2_1728408393602779" class="figure"><img alt="A person holding a cell phone  Description automatically generated" src="assets/pefl_0102.png" class="calibre23"/>
<h6 class="calibre24"><span class="firstname">Figure 1-2. </span>John pointing to the completion bar on his phone</h6>
</div></figure>

<section data-type="sect2" data-pdf-bookmark="Early Language Models" class="calibre6"><div class="preface" id="ch01_1_early_language_models_1728408393615500">
<h2 class="calibre19">Early Language Models</h2>

<p class="subtitle">Language models have actually been around for a long time. If you’re reading this book soon after its publication, then the language model that powers the iPhone guess-the-next-word functionality is based upon<a contenteditable="false" data-primary="natural language" data-secondary="Markov model of" data-type="indexterm" id="id289" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="Markov model" data-type="indexterm" id="id290" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <a href="https://oreil.ly/D6Q3U" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">a Markov model of natural language that was first introduced in 1948</a>. However, there are other more recent language models that have more directly set the stage for the AI revolution that is now underway.</p>

<p class="subtitle">By 2014, the most powerful language models were based on the<a contenteditable="false" data-primary="sequence to sequence (seq2seq) architecture" data-type="indexterm" id="id291" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="seq2seq (sequence to sequence) architecture" data-type="indexterm" id="id292" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <a href="https://arxiv.org/abs/1409.3215" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">sequence to sequence (seq2seq) architecture introduced at Google</a>. Seq2seq was a recurrent neural network, which, in theory, should have been ideal for text processing because it processes one token at a time and recurrently updates its internal state. This allows seq2seq to process arbitrarily long sequences of text. With specialized architectures and training, the<a contenteditable="false" data-primary="natural language" data-secondary="seq2seq architecture" data-type="indexterm" id="id293" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> seq2seq architecture was capable of performing several different types of natural language tasks: classification, entity extraction, translation, summarization, and more. But these models had an Achilles’ heel—an information bottleneck limited their capabilities.</p>

<p class="subtitle">The seq2seq architecture has two major components: the<a contenteditable="false" data-primary="encoders and decoders" data-type="indexterm" id="id294" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="decoders and encoders" data-type="indexterm" id="id295" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> encoder and the decoder (see <a data-type="xref" href="#ch01_1_figure_3_1728408393602789" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 1-3</a>). Processing starts by sending the encoder a stream of tokens that are processed one at a time. As the tokens are received, the encoder updates a hidden state vector that accumulates information from the input sequence. When the last token has been processed, the final value of the hidden state, called the <a contenteditable="false" data-primary="thought vectors" data-type="indexterm" id="id296" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/>thought vector, is sent to the decoder. The decoder then uses the information from the thought vector to generate output tokens. The problem, though, is that the thought vector is fixed and finite. It often “forgets” important information from longer blocks of text, giving the decoder little to work with—this is the information bottleneck.</p>

<figure class="calibre22"><div id="ch01_1_figure_3_1728408393602789" class="figure"><img alt="" src="assets/pefl_0103.png" class="calibre23"/>
<h6 class="calibre24"><span class="firstname">Figure 1-3. </span>A translation seq2seq model</h6>
</div></figure>

<p class="subtitle">The model in the figure works as follows:</p>

<ol class="stafflist">
	<li class="calibre25">
	<p class="calibre26">Tokens from the source language are sent to the encoder one at a time and converted to an embedding vector, and they update the internal state of the encoder.</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">The internal state is packaged up as the thought vector and sent to the decoder.</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">A special “start” token is sent to the decoder, indicating that this is the start of the output tokens.</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">Conditioned upon the value of the thought vector, the decoder state is updated and an output token from the target language is emitted.</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">The output token is provided as the next input into the decoder. At this point, the process recurrently loops back and forth from step 4 to step 5.</p>
	</li>
	<li class="calibre25">
	<p class="calibre26">Finally, the decoder emits a special “end” token, indicating that the decoding process is complete. The limited thought vector could transfer only a limited amount of information to the decoder.</p>
	</li>
</ol>

<p class="subtitle">A 2015 paper, <a href="https://arxiv.org/abs/1409.0473" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">“Neural Machine Translation by Jointly Learning to Align and Translate”</a>, introduced a new approach to addressing this bottleneck. Rather than having the encoder supply a single thought vector, it preserved all the hidden state vectors generated for each token encountered in the encoding process and then allowed the decoder to “soft search” over all of the vectors. As a demonstration, the paper showed that using soft search with an English-to-French translation model increased translation quality significantly. This<a contenteditable="false" data-primary="soft search technique" data-type="indexterm" id="id297" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> soft search technique soon came to be known as the<a contenteditable="false" data-primary="attention mechanism" data-type="indexterm" id="id298" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> attention mechanism.</p>

<p class="subtitle">The attention mechanism soon gained a good deal of attention of its own in the AI community, culminating in the 2017 Google Research paper <a href="https://arxiv.org/abs/1706.03762" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"> “Attention Is All You Need”</a>, which introduced the<a contenteditable="false" data-primary="transformer architecture" data-type="indexterm" id="id299" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> transformer architecture shown in <a data-type="xref" href="#fig-1-4" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Figure 1-4</a>. The transformer<a contenteditable="false" data-primary="transformer" data-type="indexterm" id="id300" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> retained the high-level structure of its predecessor—consisting of an encoder that received tokens as input followed by a decoder that generated output tokens. But unlike the seq2seq model, all of the recurrent circuitry had been removed, and the transformer instead relies completely upon the attention mechanism. The resulting architecture was very flexible and much better at modeling training data than seq2seq. But whereas seq2seq could process arbitrarily long sequences, the transformer could process only a fixed, finite sequence of inputs and outputs. Since the transformer is the direct progenitor of the GPT models, this is a limitation that we have been pushing back against ever since.</p>

<figure class="calibre22"><div id="fig-1-4" class="figure"><img alt="" src="assets/pefl_0104.png" class="calibre23"/>
<h6 class="calibre24"><span class="firstname">Figure 1-4. </span>Transformer architecture</h6>
</div></figure>
</div></section>

<section class="calibre6" data-type="sect2" data-pdf-bookmark="GPT Enters the Scene"><div class="preface" id="ch01_1_gpt_enters_the_scene_1728408393615553">
<h2 class="calibre19">GPT Enters the Scene</h2>

<p class="subtitle">The<a contenteditable="false" data-primary="GPT (generative pre-trained transformer) models" data-secondary="introduction of" data-type="indexterm" id="GPT01" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> generative pre-trained transformer architecture was introduced in the 2018 paper <a href="https://oreil.ly/vIiDJ" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"> “Improving Language Understanding by Generative Pre-Training”</a>. The architecture wasn’t particularly special or new. Actually, the architecture was just a transformer with the encoder ripped off—it was just the decoder side. However, this simplification led to some unexpected new possibilities that would only be fully realized in coming years. It was this generative pre-trained transformer architecture—GPT—that would soon ignite the ongoing AI revolution.</p>

<p class="subtitle">In 2018, this wasn’t apparent. At that point in time, it was standard practice to <em class="hyperlink">pre-train</em> models with unlabeled data—for instance, scraps of text from the internet—and then modify the architecture of the models and apply specialized fine-tuning so that the final model would then be able to do <em class="hyperlink">one</em> task very well. And<a contenteditable="false" data-primary="transformer" data-type="indexterm" id="id301" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> so it was with the generative<a contenteditable="false" data-primary="pre-trained transformer architecture" data-type="indexterm" id="id302" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">pre-trained</em> transformer architecture. The 2018 paper simply showed that this pattern worked really well for GPTs—pre-training on unlabeled text followed by supervised fine-tuning for a particular task led to really good models for a variety of tasks such as classification, measuring similarities among documents, and answering multiple-choice questions. But we should emphasize one point: after the GPT was fine-tuned, it was only good at the single task for which it was fine-tuned.</p>

<p class="subtitle">GPT-2 was<a contenteditable="false" data-primary="malicious applications" data-type="indexterm" id="id303" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="OpenAI GPT APIs" data-secondary="details of training" data-type="indexterm" id="id304" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> simply a scaled-up version of GPT. When it was introduced in 2019, it was beginning to dawn upon researchers that the GPT architecture was something special. This is clearly evidenced in the second paragraph of the <a href="https://oreil.ly/_tv8t" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">OpenAI blog post introducing GPT-2</a>:</p>

<blockquote class="pcalibre6 pcalibre5 calibre11">
<p class="calibre12">Our model, called GPT-2 (a successor to GPT), was trained simply to predict the next word in 40 GB of Internet text. Due to our concerns about malicious applications of the technology, we are not releasing the trained model.</p>
</blockquote>

<p class="subtitle">Wow! How can those two sentences belong next to each other? How does something as innocuous as predicting the next word—just like an iPhone does when you write a text message—lead to such grave concerns about misuse? If you read the corresponding academic paper, <a href="https://oreil.ly/QEeI9" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"> “Language Models Are Unsupervised Multitask Learners”</a>, then you start to find out. GPT-2 was 1.5 billion parameters, as compared with GPT’s 117 million, and was trained on 40 GB of text, as compared with GPT’s 4.5 GB. A simple order-of-magnitude increase in model and training set size led to an unprecedented emergent quality—instead of having to fine-tune GPT-2 for a single task, you could apply the raw, pre-trained model to the task and often achieve better results than state-of-the-art models that were fine-tuned specifically for the task. This included benchmarks for understanding ambiguous pronouns, predicting missing words in text, tagging parts of speech, and more. And despite falling behind the state of the art, GPT-2 also fared surprisingly well on reading comprehension, summarization, translation, and question-answering tasks, again against models fine-tuned specifically for those tasks.</p>

<p class="subtitle">But, why all the concern about “malicious applications” of this model? It’s because the model had become quite good at mimicking natural text. And, as the OpenAI blog post indicates, this capability could be used to “generate misleading news articles, impersonate others online, automate the production of abusive or faked content to post on social media, and automate the production of spam/phishing content.” If anything, this possibility has only become more real and concerning today than it was in 2019.</p>

<p class="subtitle">GPT-3 saw another order-of-magnitude increase in both model size and training data, with a corresponding leap in capability. The 2020 paper <a href="https://arxiv.org/abs/2005.14165" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">“Language Models Are Few-Shot Learners”</a> showed that, given a few examples of the task you want the model to complete, (a.k.a. “few-shot examples”), the model could faithfully reproduce the input pattern and, as a result, perform just about any language-based task that you could imagine—and often with remarkably high-quality results. This is when we found out that you could modify the input—the prompt—and thereby condition the model to perform the requisite task at hand. This<a contenteditable="false" data-primary="prompt engineering" data-secondary="birth of" data-type="indexterm" id="id305" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> was the birth of prompt engineering.</p>

<p class="subtitle">ChatGPT, released<a contenteditable="false" data-primary="ChatGPT" data-secondary="evolution of" data-type="indexterm" id="id306" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> in November 2022, was backed by GPT-3.5―and the rest is history! But, it’s a history rapidly in the making (see <a data-type="xref" href="#ch01_1_table_1_1728408393607235" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Table 1-1</a>). In March of 2023, GPT-4 was released, and although the details were not officially revealed, that model was rumored to be another order of magnitude larger in both model size and amount of training data, and it was again much more capable than its predecessors. Since then, more and more models have appeared. Some are from OpenAI while others are from major industry players, such as Llama from Meta, Claude from Anthropic, and Gemini from Google. We have continued to see leaps in quality, and increasingly, the same level of quality is available in smaller and faster models. If anything, <em class="hyperlink">the progress is only accelerating</em>.<a contenteditable="false" data-primary="" data-startref="LLMhistory01" data-type="indexterm" id="id307" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="GPT01" data-type="indexterm" id="id308" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="OpenAI GPT APIs" data-secondary="exponential increase in metrics" data-type="indexterm" id="id309" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/><a contenteditable="false" data-primary="" data-startref="history01" data-type="indexterm" id="id310" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/></p>

<table id="ch01_1_table_1_1728408393607235" class="calibre27">
	<caption class="calibre28"><span class="firstname">Table 1-1. </span>Details of the GPT-series models, showing the exponential nature of increase in all metrics</caption>
	<thead class="calibre29">
		<tr class="calibre30">
			<th class="calibre31">Model</th>
			<th class="calibre31">Release date</th>
			<th class="calibre31">Parameter count</th>
			<th class="calibre31">Training data</th>
			<th class="calibre31">Training cost</th>
		</tr>
	</thead>
	<tbody class="calibre32">
		<tr class="calibre30">
			<td class="calibre33">GPT-1</td>
			<td class="calibre33">June 11, 2018</td>
			<td class="calibre33">117 million</td>
			<td class="calibre33">BookCorpus: 4.5 GB of text from 7,000 unpublished books of various genres</td>
			<td class="calibre33">1.7e19 FLOP</td>
		</tr>
		<tr class="calibre34">
			<td class="calibre33">GPT-2</td>
			<td class="calibre33">February 14, 2019 (initial); November 5, 2019 (full)</td>
			<td class="calibre33">1.5 billion</td>
			<td class="calibre33">WebText: 40 GB of text and 8 million documents from 45 million web pages upvoted on Reddit</td>
			<td class="calibre33">1.5e21 FLOP</td>
		</tr>
		<tr class="calibre30">
			<td class="calibre33">GPT-3</td>
			<td class="calibre33">May 28, 2020</td>
			<td class="calibre33">175 billion</td>
			<td class="calibre33">499 billion tokens consisting of Common Crawl (570 GB), WebText, English Wikipedia, and two books corpora (Books1 and Books2)</td>
			<td class="calibre33">3.1e23 FLOP</td>
		</tr>
		<tr class="calibre34">
			<td class="calibre33">GPT-3.5</td>
			<td class="calibre33">March 15, 2022</td>
			<td class="calibre33">175 billion</td>
			<td class="calibre33">Undisclosed</td>
			<td class="calibre33">Undisclosed</td>
		</tr>
		<tr class="calibre30">
			<td class="calibre33">GPT-4</td>
			<td class="calibre33">March 14, 2023</td>
			<td class="calibre33">1.8 trillion (rumored)</td>
			<td class="calibre33">Rumored to be 13 trillion tokens</td>
			<td class="calibre33">Estimated to be 2.1e25 FLOP</td>
		</tr>
	</tbody>
</table>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Prompt Engineering" class="calibre6"><div class="preface" id="ch01_1_prompt_engineering_1728408393615582">
<h1 class="calibre5">Prompt Engineering</h1>

<p class="subtitle">Now, we<a contenteditable="false" data-primary="prompt engineering" data-secondary="definition of term" data-type="indexterm" id="id311" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> arrive at the beginning of <em class="hyperlink">your</em> journey into the world of prompt engineering. At their core, LLMs are capable of one thing—completing text. The input into the model is called the<a contenteditable="false" data-primary="prompts, definition of" data-type="indexterm" id="id312" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">prompt</em>—it is a document, or block of text, that we expect the model to complete. <em class="hyperlink">Prompt engineering</em>, then, in its simplest form, is the practice of crafting the prompt so that its completion contains the information required to address the problem at hand.</p>

<p class="subtitle">In this book, we provide a much larger picture of prompt engineering that involves moves well beyond a single prompt and discuss the entire LLM-based application, where prompt construction and the interpretation of the answer are done programmatically. To<a contenteditable="false" data-primary="prompt engineering" data-secondary="goals for successful" data-type="indexterm" id="id313" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> build a quality piece of software and a quality UX, the prompt engineer must create a pattern for iterative communication among the user, the application, and the LLM. The user conveys their problem to the application, the application constructs a pseudodocument to be sent to the LLM, the LLM completes the document, and finally, the application parses the completion and conveys the result back to the user or otherwise performs an action on the user’s behalf. The science <em class="hyperlink">and art</em> of prompt engineering is to make sure that this communication is structured in a way that best translates among very different domains, the user’s problem space, and the document space of LLMs.</p>

<p class="subtitle">Prompt engineering<a contenteditable="false" data-primary="prompt engineering" data-secondary="levels of sophistication" data-type="indexterm" id="id314" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> comes in several levels of sophistication. The most basic form makes use of only a very thin application layer. For instance, when you engage with ChatGPT, you’re crafting a prompt almost directly; the application is merely wrapping the conversation thread in a special ChatML markdown. (You’ll learn more about this in <a data-type="xref" href="ch03.html#ch03a_moving_toward_chat_1728432131625250" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Chapter 3</a>.) Similarly, when GitHub Copilot was first created for code completions, it was doing little more than passing the current file along to the model to complete.</p>

<p class="subtitle">At the next level of sophistication, prompt engineering involves modifying and augmenting the user’s input into the model. For instance, LLMs deal with text, so a tech support hotline could transcribe a user’s speech to text and use it in the prompt sent to the LLM. Additionally, relevant content from previous help transcripts or from relevant support documentation could be included in the prompt. As a real-world example, as GitHub Copilot code completions developed, we realized that the completion quality improved considerably if we incorporated relevant snippets from the user’s neighboring tabs. This makes sense, right? The user had the tabs open because they were referencing information there, so it stands to reason that the model could benefit from this information as well. Another example is the new Bing chat-based search experience. In this instance, content from traditional search results is pulled into the prompt. This allows the assistant to competently discuss information that it never saw in the training data (for instance, because it referred to events that happened after the model was trained). More importantly, this approach helps Bing reduce hallucinations, a topic we’ll revisit several times throughout the book, starting in the next chapter.</p>

<p class="subtitle">Another aspect of prompt engineering at this level of sophistication comes when the interactions with the LLM become<a contenteditable="false" data-primary="state" data-type="indexterm" id="id315" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <em class="hyperlink">stateful</em>, meaning they maintain context and information from prior interactions. A chat application is the quintessential example here. With each new exchange from the user, the application must recall what happened in previous exchanges and generate a prompt that faithfully represents the interaction. As the conversation or history gets longer, you will have to be careful to not overfill the prompt or include spurious content that might distract the model. You may choose to drop the earliest exchanges or less relevant content from previous exchanges, and you may even employ summarization to compress the content.</p>

<p class="subtitle">Yet another aspect of prompt engineering at this level of sophistication involves giving the LLM-based application tools that allow the LLM to reach out into the real world by making API requests to read information or to even create or modify assets that are available on the internet. For instance, an LLM-based email application might receive this input from a user: “Send Diane an invitation to a meeting on May 5.” This application would use one tool to identify Diane in the user’s contacts list and then use a calendar API to look up her availability before finally sending an email invitation. As these models get cheaper and more powerful, just imagine the possibilities available with the APIs already at our disposal today! Prompt engineering here is critical. How will the model know which tool to use? How will it use the tool in the correct way? How will your application properly share the information from the tool execution with the model? What do we do when the tool usage results in some sort of error state? We will talk about all of this in <a data-type="xref" href="ch08.html#ch08_01_conversational_agency_1728429579285372" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">Chapter 8</a>.</p>

<p class="subtitle">The final level of sophistication that we cover in this book is how to provide the LLM application with agency—the ability to make its own decisions about how to accomplish broad goals supplied by the user. This is clearly on the frontier of our capabilities with LLMs, but research and practical exploration are underway. Already, you can download<a contenteditable="false" data-primary="AutoGPT" data-type="indexterm" id="id316" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2"/> <a href="https://oreil.ly/h3mJZ" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">AutoGPT</a> and supply it with a goal, and it will take off on a multistep process to gather the information it needs to accomplish the goal. Does it always work? No. Actually, unless the goal is quite constrained, it tends to fail at the task more often than it succeeds. But giving LLM applications some form of agency and autonomy is still an important step toward exciting future possibilities. You’ll read our take on this in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#ch08_01_conversational_agency_1728429579285372" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#ch09_llm_workflows_1728407155661595" class="pcalibre3 calibre7 pcalibre4 pcalibre1 pcalibre2">9</a>.</p>
</div></section>

<section class="calibre6" data-type="sect1" data-pdf-bookmark="Conclusion"><div class="preface" id="ch01_1_conclusion_1728408393615607">
<h1 class="calibre5">Conclusion</h1>

<p class="subtitle">As we said at the start, this chapter sets the background for the journey you are about to take into prompt engineering. We started with a discussion of the recent history of language models, and we highlighted why LLMs are so special and different—and why they are fueling the AI revolution that we are all now witnessing. We then defined the topic of this book: prompt engineering.</p>

<p class="subtitle">In particular, you should understand that this book isn’t going to be all about how to do nitpicky wording of a single prompt to get one good completion. Sure, we’ll cover that, and we’ll cover in detail all the things you need to do to generate high-quality completions that serve their intended purpose. But when we say, “prompt engineering,” we mean building the entire LLM-based application. The LLM application serves as a transformation layer, iteratively and statefully converting real-world needs into text that LLMs can address and then converting the data provided by the LLMs into information and action that address those real-world needs.</p>

<p class="subtitle">Before we set off on this journey, let’s make sure we’re appropriately packed. In the next chapter, you’ll learn how LLM text completion works from the top-level API all the way down to low-level attention mechanisms. In the subsequent chapter, we’ll build upon that knowledge to explain how LLMs have been expanded to handle chat and tool usage, and you’ll see that deep down, it’s really all the same thing—text completion. Then, with those foundational ideas in store, you’ll be ready for your journey.</p>
</div></section>
</div></section></div></div></body></html>