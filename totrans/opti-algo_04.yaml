- en: 4 Informed search algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs: []
  type: TYPE_NORMAL
- en: Defining informed search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to solve the minimum spanning tree problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to find the shortest path using informed search algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving a real-world routing problem using these algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapter, we covered blind search algorithms, which are algorithms
    in which no information about the search space is needed. In this chapter, we’ll
    look at how search can be further optimized if we utilize some information about
    the search space during the search.
  prefs: []
  type: TYPE_NORMAL
- en: As problems and search spaces become larger and more complex, the complexity
    of the algorithms themselves increases. I’ll start by introducing informed search
    algorithms, and then we’ll discuss minimum spanning tree algorithms and shortest
    path search algorithms. A routing problem will be presented as a real-life application
    to show how you can use these algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Introducing informed search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in the previous chapter, *blind search algorithms* work with
    no information about the search space, other than the information needed to distinguish
    the goal state from the others. Like the colloquial expression, “I’ll know it
    when I see it,” blind search follows a set framework of rules (e.g., breadth-first,
    depth-first, or Dijkstra’s algorithm) to systematically navigate the search space.
    *Informed search algorithms* differ from blind search algorithms in the sense
    that the algorithm uses knowledge acquired during the search to guide the search
    itself. This knowledge can take the form of distance to target or incurred costs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the 8-puzzle problem, we might use the number of misplaced tiles
    as a heuristic to determine how far any given state is from the goal state. In
    this way, we can determine at any given iteration of the algorithm how well it
    is performing and modify the search method based on current conditions. The definition
    of “good performance” depends on the heuristic algorithm being used.
  prefs: []
  type: TYPE_NORMAL
- en: Informed search algorithms can be broadly classified into those that solve for
    minimum spanning tree (MST) problems and those that compute the shortest path
    between two specific nodes or states, as outlined in figure 4.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F01_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 Examples of informed search algorithms. Each algorithm has multiple
    variants based on improvements, specific use cases, and specialized domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several algorithms have been proposed to solve MST problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Borůvka’s algorithm* finds an MST in a graph for which all edge weights are
    distinct. It also finds a minimum spanning forest, in the case of a graph that
    is not connected. It starts with each node as its own tree, identifies the cheapest
    edge leaving each tree, and then merges the trees joined by these edges. No edge
    presorting is needed or maintained in a priority queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jarník-Prim’s algorithm* starts from the root vertex and finds the lowest-weight
    edge from an MST vertex to a non-MST vertex and adds it to MST at each step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kruskal’s algorithm* sorts edges by increasing weight and starts from the
    least-weighted edge to form a small MST component and then grows them into one
    large MST. I will describe this algorithm in more detail in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hill climbing (HC), beam search, the A* algorithm, and contraction hierarchies
    (CH) are examples of informed search algorithms that can be used to find the shortest
    path between two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hill climbing* is a local search algorithm that continuously moves in the
    direction of optimizing the objective function, increasing in the case of maximization
    problems, or decreasing in the case of minimization problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beam search* explores a graph or tree by expanding the most promising node
    within a limited predefined set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The A* algorithm* combines both the cost accrued up to a node and heuristic
    information, such as the straight-line distance between this node and the destination
    node, to select new nodes for expansion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hierarchical approaches*, such as reach-based routing, highway hierarchies
    (HHs), highway-node routing (HNR), transit-node routing (TNR), and contraction
    hierarchy (CH), are hierarchical approaches that take into consideration node
    importance and try to prune the search space by admissible heuristics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section introduces the concept of an MST and presents an algorithm
    that can generate an MST for any given graph.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Minimum spanning tree algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you are the infrastructure manager for a small, remote rural town.
    Unlike most towns, there isn’t really a main street or downtown area, so most
    points of interest are scattered. Additionally, budget cuts in previous years
    have left the roads either damaged or non-existent. The damaged roads are all
    buried under mud and are essentially impassable. You’ve been given a small budget
    to fix or build roads to improve the situation, but the money isn’t enough to
    repair all the existing roads or to build new ones. Figure 4.2 shows a map of
    the town, as well as the locations of the existing damaged roads.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F02_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 The muddy city problem. The roads in this town are badly damaged,
    but there isn’t enough money to repair them all.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to approach this problem, ranging from the not feasible
    (repair all the damaged roads and live with the consequences of a bankrupt town)
    to the overly conservative (only fix a few roads, or none at all, and ignore all
    the complaining townspeople). This problem is typically known as the muddy city
    problem, where various nodes in a graph must be connected while minimizing the
    edge weights. These weights can present the cost of fixing or paving the road,
    which may vary depending on the road’s condition, length, and topology.
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical way of solving the muddy city problem involves the idea of
    a minimum spanning tree (MST). A spanning tree, in general, is a cycle-free or
    loop-free subgraph of an undirected graph that connects all the vertices of the
    graph with the minimum number of edges. In figure 4.3, the left tree shows a graph
    *G* with nodes from A to F, while the middle and right trees show spanning trees
    of *G*. Notice that generic spanning trees do not require the edges to be weighted
    (i.e., to have a length, speed, time, or cost associated with them).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F03_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 Examples of spanning trees. The middle and right trees reach every
    node of graph *G* with no loops or cycles.
  prefs: []
  type: TYPE_NORMAL
- en: An MST or minimum-weight spanning tree of an edge-weighted graph is a spanning
    tree whose weight (the sum of the weights of its edges) is no larger than the
    weight of any other spanning tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'If *G*=(*V, E*) is a graph, then any subgraph of *G* is a spanning tree if
    both of the following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The subgraph contains all vertices *V* of *G*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subgraph is connected with no circuits and no self-loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a given spanning tree *T* for a graph *G*, the weight *w* of the spanning
    tree is the sum of the weights of all the edges in *T*. If the weight of *T* is
    the lowest of the weights of all the possible spanning trees of *G*, then we can
    call this an MST.
  prefs: []
  type: TYPE_NORMAL
- en: The previously described muddy city problem will be solved as an MST. Kruskal,
    Borůvka, Jarník-Prim, and Chazelle are all examples of algorithms that can be
    used to find an MST. Algorithm 4.1 shows the pseudocode for Kruskal’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 4.1 Kruskal’s algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To better understand these steps, let’s apply Kruskal’s algorithm to solve the
    muddy city problem. Figure 4.4 shows the original graph. The numbers near the
    edges represent edge weights, and no edges have been added to the MST yet. The
    following steps will generate the MST by hand iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F04_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 Solving the muddy city problem using Kruskal’s algorithm—original
    graph
  prefs: []
  type: TYPE_NORMAL
- en: 1\.  The shortest edge is E-H with a length of 1, so it is highlighted and added
    to the MST (figure 4.5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F05_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 Solving the muddy city problem using Kruskal’s algorithm—step 1
  prefs: []
  type: TYPE_NORMAL
- en: 2\.  B-C, C-G, G-F, and I-J are now the shortest edges with lengths of 2\. B-C
    is chosen arbitrarily and is highlighted, followed by C-G, G-F, and I-J, as they
    don’t form a cycle (figure 4.6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F06_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 Solving the muddy city problem using Kruskal’s algorithm—step 2
  prefs: []
  type: TYPE_NORMAL
- en: 3\.  C-F, F-J, G-I, A-D, and D-E are now the shortest edges with lengths of
    3\. C-F cannot be chosen, as it forms a cycle. A-D is chosen arbitrarily and is
    highlighted, followed by D-E and G-I. F-J cannot be chosen, as it forms a cycle
    (figure 4.7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F07_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 Solving the muddy city problem using Kruskal’s algorithm—step 3
  prefs: []
  type: TYPE_NORMAL
- en: 4\.  The next-shortest edges are A-E and G-H with lengths 4\. A-E cannot be
    chosen because it forms a cycle, so the process finishes with the edge G-H. The
    minimum spanning tree has been found (figure 4.8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F08_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 Solving the muddy city problem using Kruskal’s algorithm—step 4
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 shows the final solution with all nodes in the graph connected.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F09_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 Solving the muddy city problem using Kruskal’s algorithm. The algorithm
    adds edges to the final tree by ascending weight order, ignoring edges that will
    form a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm can be implemented easily in Python by using NetworkX’s `find_cycle()`
    and `is_connected()` methods, which determine if an edge is a viable candidate
    for the MST, as well as the overall algorithm’s termination condition, respectively.
    For the purposes of visual presentation, I’ve also used `spring_layout()` for
    the positions of the nodes and edges of the graph. The `spring_layout()` method
    uses a random number generator internally to generate these positions, and we
    can pass a seed (which allows a deterministic generation of so-called “pseudo-random”
    numbers) to guarantee a specific layout on each execution. Try modifying the seed
    parameter, and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.1 Solving the muddy city problem using Kruskal’s algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: ① Create an undirected graph and populate it with nodes and edges.
  prefs: []
  type: TYPE_NORMAL
- en: ② Using a seed with the spring_layout method guarantees the same placement of
    nodes every time.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Sort edges by weight in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: ④ find_cycle raises an error if no cycles exist in the graph. We can try/catch
    this error to determine if adding a new edge creates a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ The set of edges in mst is a spanning tree if the graph formed by those edges
    is connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation of listing 4.1, the following code snippet is used to generate
    an MST using Kruskal and to visualize the MST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: ① Call Kruskal’s algorithm to generate the MST.
  prefs: []
  type: TYPE_NORMAL
- en: ② Draw the edges.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Add the labels.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Draw the MST.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in figure 4.10, our Python implementation of the muddy city problem
    produces the exact same results that we achieved using hand iteration. Node G,
    which is the town hall, becomes a sort of central hub for the town’s transportation
    infrastructure, and the total cost of road construction is minimized. It’s worth
    noting, however, that while MST minimizes the total cost of connecting all nodes,
    it doesn’t usually produce the most “convenient” solution. Should someone wish
    to travel from the place of worship to the hospital, for example, the shortest
    achievable distance would be 7 (passing through the police station), while our
    road network requires a total distance of 15.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F10_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 The muddy city problem solved using Kruskal’s algorithm. The highlighted
    edges are part of the MST.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply this algorithm and this code to find the MST for all nodes in a
    search space surrounding the University of Toronto. Imagine that we have been
    tasked with installing new communications cables across the city, and we want
    to minimize the length of cable we use.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.2 University of Toronto MST
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ① Use the drive network to only focus on drivable roads. This prevents the code
    from building an MST with a combination of roads and sidewalks.
  prefs: []
  type: TYPE_NORMAL
- en: ② Get an undirected copy of the graph, and sort the road network edges by edge
    length.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Call the Kruskal algorithm from optalgotools, using a presorted list and specifying
    the graph type.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Visualize the MST by highlighting the included edges.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 shows the resulting MST generated by Kruskal’s algorithm. The road
    network graph in the figure may seem like one big connected component, but it
    isn’t. There are one-way streets that seem to connect adjacent nodes on the graph,
    but in reality, they are not connected (you can go from A to B but not the reverse).
    We overcome this by converting the directed graph into an undirected graph using
    the `to_undirected` function in NetworkX.
  prefs: []
  type: TYPE_NORMAL
- en: The version of Kruskal’s algorithm used in the listing is the same as was used
    for the muddy city problem. We’re importing it from optalgotools to reduce the
    amount of code needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F11_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 The MST generated by Kruskal’s algorithm. All the edges included
    in the MST are highlighted. There are no cycles in the MST, and the total weight
    of the tree is minimized.
  prefs: []
  type: TYPE_NORMAL
- en: MSTs have a wide variety of applications in the real world, including network
    design, image segmentation, clustering, and facility location problems. MSTs are
    especially useful when dealing with problems concerning budgeting, such as planning
    networks, as they allow all nodes to be connected with a minimum total cost. As
    previously mentioned, informed search algorithms can be used to find MSTs as described
    in this section and with shortest path algorithms, which are discussed in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Shortest path algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Informed search algorithms can be used to find the shortest path between two
    nodes by using knowledge about the problem (domain-specific knowledge) to prune
    the search. This knowledge, in the form of a heuristic function, gives an estimate
    of the distance to the goal. Examples of informed search algorithms include hill
    climbing, beam search, best-first, A*, and contraction hierarchies. The following
    subsections discuss these algorithms in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Hill climbing algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assume that you are trying to climb to the top of a mountain in a dense fog.
    There is only one path up and down the mountain, but you aren’t sure exactly where
    the peak is. Thus, you are only able to judge your progress by looking one step
    behind you and seeing if you’ve gone uphill or downhill since your last step.
    How can you know when you’ve reached the summit? A good guess would be when you’re
    no longer going uphill!
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a known (non-optimized) solution to a function or with an initial
    state, the hill climbing algorithm checks the neighbors of that solution and chooses
    the neighbor that is more optimized. This process is repeated until no better
    solution can be found, at which point the algorithm terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The hill climbing algorithm is a local greedy search algorithm that tries to
    improve the efficiency of depth-first by incorporating domain-specific knowledge
    or heuristic information, so it can be considered as an informed depth-first algorithm.
    The hill climbing algorithm’s pseudocode applied to graph search is shown in the
    algorithm 4.2 assuming minimization problem.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 4.2 The hill climbing algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm sorts the successors of a node (according to their heuristic values)
    before adding them to the list to be expanded. This algorithm demands very little
    in the way of memory and computational overhead, as it simply remembers the current
    successors as the current path it is working on. It’s a non-exhaustive technique;
    it does not examine the entire tree, so its performance will be reasonably fast.
    However, while this algorithm works relatively well with convex problems, functions
    with multiple local maxima will often result in an answer that is not the global
    maximum. It also performs poorly when there are plateaus (a local set of solutions
    that are all similarly optimized).
  prefs: []
  type: TYPE_NORMAL
- en: As shown in figure 4.12, depending on the initial state, the hill climbing algorithm
    may get stuck in local optima. Once it reaches the top of a hill, the algorithm
    will stop, since any new successor will be down the hill. This is analogous to
    climbing the mountain in the fog, reaching a smaller peak, and thinking that you’ve
    reached the main summit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F12_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 Depending on the initial state, the hill climbing algorithm may
    get stuck in local optima. Once it reaches a peak, the algorithm will stop, since
    any new successor will be down the hill.
  prefs: []
  type: TYPE_NORMAL
- en: Simple hill climbing, steepest-ascent hill climbing, stochastic hill climbing,
    and random-restart hill climbing are all variants of the hill climbing algorithm,
    as shown in figure 4.13.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F13_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 Variants of the hill climbing algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '*Simple hill climbing* examines the neighboring nodes one by one and selects
    the first neighboring node that optimizes the objective function as the next node
    to be explored. *Steepest-ascent or steepest-descent hill climbing* is a variation
    on the simple hill-climbing algorithm that first examines all the neighboring
    nodes of the current state and selects one neighbor node that is closest to the
    goal state. *Stochastic hill climbing* is a randomized version of a hill climbing
    algorithm that selects a neighboring node at random without examining all the
    neighboring nodes. This algorithm decides whether to move to that neighbor or
    to examine another based on the amount of improvement in that neighbor. Random-restart
    hill climbing or first-choice hill climbing follows a try-and-try strategy and
    iteratively searches the nodes and selects the best one at each step until the
    goal is found. If it gets stuck in a local maximum, it restarts the process from
    a new random initial state. Compared to the other hill climbing variants, this
    algorithm is better able to reach the destination if there are plateaus, local
    optima, and ridges.'
  prefs: []
  type: TYPE_NORMAL
- en: Gradient descent algorithm
  prefs: []
  type: TYPE_NORMAL
- en: The *gradient descent algorithm* is widely used in machine learning to train
    models and make predictions. Gradient descent and hill climbing are two fundamentally
    different algorithms and cannot be confused with each other. Instead of climbing
    up a hill, gradient descent can be seen as hiking down to the bottom of a valley.
    Gradient descent is an iterative algorithm that looks at the slope of the local
    neighbors and moves in the direction with the steepest slope or the direction
    of negative gradient to optimize a continuous differentiable function. Alternatively,
    in the case of a maximization problem, *gradient ascent* moves in the direction
    with a positive gradient to optimize the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: The gradient descent algorithm usually converges to a global minimum if the
    function is convex (i.e., if any local minimum is also a global minimum) and the
    learning rate is properly chosen. The hill climbing algorithm is a heuristic greedy
    algorithm that can easily get stuck in local optima. It is used mainly for discrete
    optimization problems, such as the traveling salesman, as it doesn’t require the
    objective function to be differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: Assume we have the simple graph shown in figure 4.14\. The source node is S
    and the destination node is G.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F14_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 An 8 points of interest (POIs) road network in the form of a graph
  prefs: []
  type: TYPE_NORMAL
- en: This graph can be converted into a tree by finding a spanning tree that includes
    all the vertices of the original graph and that is connected and acyclic, as shown
    in figure 4.15.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F15_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 An 8 points of interest (POIs) road network in the form of a tree
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are multiple ways to go from S to G, each with different
    costs. Following the hill climbing algorithm, the shortest path between S and
    G will be S→A→C→E→G, as illustrated in figure 4.16.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F16_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 Shortest path between S and G using the hill climbing algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now use the 8-puzzle problem to illustrate the hill climbing approach.
    Figure 4.17 shows how the hill climbing search progresses, using the number of
    misplaced tiles, excluding the blank tile, as heuristic information *h*(*n*).
    For example, in step 2, tiles 1, 4, 6, and 7 are wrongly placed, so *h* = 4\.
    In step 3, tiles 1, and 4 are misplaced, so *h* = 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F17_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 Using the hill climbing algorithm to solve the 8-puzzle problem.
    At each iteration, the algorithm explores neighboring states, looking for the
    minimum heuristic value.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.3 shows a simple implementation of hill climbing in Python. The code
    selects nodes to explore by minimizing the heuristic value of the next node. A
    more complex version, involving generating shortest paths, will be presented at
    the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.3 Solving the 8-puzzle problem using hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ① The neighbor nodes of the current state can be generated using expand().
  prefs: []
  type: TYPE_NORMAL
- en: ② The “closest” neighbor is the one with the lowest cost function (i.e., the
    fewest misplaced tiles).
  prefs: []
  type: TYPE_NORMAL
- en: ③ Terminate the algorithm if the goal state has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Calculate and return the number of misplaced tiles that are not in their goal
    positions.
  prefs: []
  type: TYPE_NORMAL
- en: Note The State class and visualize function are defined in the complete listing,
    available in the book’s GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet defines the initial and goal states of the puzzle
    and uses hill climbing to solve the puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ① Check if there is even a solution.
  prefs: []
  type: TYPE_NORMAL
- en: ② Solve the puzzle using hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: ③ Plot the search progress, and visualize the solution.
  prefs: []
  type: TYPE_NORMAL
- en: The output is shown in figure 4.18.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F18_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 States of the hill climbing solution for the 8-puzzle problem. Each
    subsequent state is selected by minimizing its cost compared to its neighbors.
    As the 8-puzzle problem has not only a well-defined but also an achievable goal
    state, the algorithm’s termination condition (the goal being reached) coincides
    with the “peak” of the hill (which in this case is a valley, as it is a minimization
    problem).
  prefs: []
  type: TYPE_NORMAL
- en: As the 8-puzzle problem uses a heuristic as a cost, it essentially becomes a
    minimization problem. This implementation differs from the standard hill climbing
    in that, as a solution can always be found, and the graph is fully connected (you
    can transition from any state to another state through some combination of tile
    movements), the algorithm is guaranteed to find the optimal solution eventually.
    More complex problems will often generate solutions that are near-optimal.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 Beam search algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *beam search algorithm* tries to minimize the memory requirements of the
    breadth-first algorithm, so it can be seen as an informed breadth-first algorithm.
    While hill climbing maintains a single best state throughout the run, beam search
    keeps *w* states in memory, where *w* is the beam width. At each iteration, it
    generates the neighbors for each of the states and puts them into a pool with
    the states from the original beam. It then selects the best *w* states from the
    pool at each level to become the new beam, and the rest of the states are discarded.
    This process then repeats. The algorithm expands only the first *w* promising
    nodes at each level.
  prefs: []
  type: TYPE_NORMAL
- en: This is a non-exhaustive search, but it is also a hazardous process, because
    a goal state might be missed. As this is a local search algorithm, it is also
    susceptible to getting stuck at a local optima. A beam search with *w* equal to
    the number of nodes in each level is the same as a BFS. Because there is the risk
    that a state that could lead to the optimal solution might be discarded, beam
    searches are incomplete (they may not terminate with the solution).
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 4.3 shows the pseudocode for the beam search algorithm applied to
    a graph search.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 4.3 The beam search algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In section 2.3.1, you saw that BFS has an exponential complexity of *O*(*b^d*),
    where *b* represents the maximum branching factor for each node and *d* is the
    depth one must expand to reach the goal. In the case of beam search, we only explore
    *w* × *b* nodes at any depth, saving many unneeded nodes compared to BFS. However,
    finding the best states or routes requires sorting, which is time-consuming if
    *w* × *b* is a huge number. A beam threshold can be used to handle this problem,
    where the best node is selected based on the heuristic function *h*(*n*) within
    a certain threshold, and all the nodes outside this are pruned away.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the simple routing problem with 8 points of interest (figure 4.14)
    and following the beam search algorithm with *w* = *2*, the shortest path between
    S and G will be S-A-C-E-G, as illustrated in figure 4.19.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F19_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 The shortest path between S and G using a beam search algorithm.
    With a beam width *w* = 2, two states are kept in the beam at each iteration.
    After generating the neighbors of each element in the beam, only the best *w*
    beams are kept.
  prefs: []
  type: TYPE_NORMAL
- en: The following listing shows a basic implementation of beam search used for a
    simple routing problem. See the full code in the GitHub repo to see how the graph
    is initialized, as well as how the visualization is generated (it is quite similar
    to that of listing 4.1).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.4 Simple routing with beam search
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ① Create a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: ② Get the neighbors of the node using the origin class’s expand() method, passing
    any necessary arguments.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Prune the pool down to only the best k paths, passing any necessary arguments
    to the cost function.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Child routes are generated for each route by adding one extra node to the
    route. For each of these new routes, they are rejected (already explored), added
    to the beam (and then to the pool), or accepted (because they reach the destination).
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ None is returned if a path cannot be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can be called with the following example parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing the output of this algorithm produces the graph in figure 4.20,
    where the highlighted line represents the solution path from S to G.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F20_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 Solution using a beam width of *w* = 2. The highlighted line represents
    the solution path.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in a later section, when applying beam search to a real-life
    routing problem, generating the children in a beam search can become very complicated
    and time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 A* search algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *A** (pronounced A-star) algorithm is an informed search algorithm widely
    used in pathfinding and graph traversal. This algorithm is a special case of the
    best-first algorithm. Best-first search is a kind of mixed depth- and breadth-first
    search that expands the most desirable unexpanded node based on either the cost
    to reach the node or an estimate or heuristic value of the cost to reach the goal
    from that node. The A* algorithm takes into account both the cost to reach the
    node and the estimated cost to reach the goal in order to find the optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudocode for A* is shown in algorithm 4.4.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 4.4 A* algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A* search tries to reduce the total number of states explored by incorporating
    both the actual cost and a heuristic estimate of the cost to get to the goal from
    a given state. The driving force behind A* is the selection of a new vertex (or
    node) to explore based on the lowest value. The value of the evaluation function
    *f*(*n*) is computed using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *f*(*n*) = *g*(*n*) + *h*(*n*) | 4.1 |'
  prefs: []
  type: TYPE_TB
- en: In equation 4.1, *g*(*n*) is the actual cost of the partial path already traveled
    from the source node S to node *n*. The heuristic information *h*(*n*) can be
    the straight-line distance between node *n* and destination node G, or some other
    function. When *h*(*n*) = 0 for all nodes, A* will behave like a uniform-cost
    search (UCS), which was explained in section 3.4.2, so the node with the lowest
    cost will be expanded regardless of the estimated cost to reach the goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *weighted A**, a constant weight is added to the heuristic function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *f*(*n*) = *g*(*n*) + *w* × *h*(*n*) | 4.2 |'
  prefs: []
  type: TYPE_TB
- en: To increase the importance of *h*(*n*), *w* should be greater than 1\. A dynamic
    weight *w*(*n*) can be also used. The choice of the heuristic information is critical
    to the search results. The heuristic information *h*(*n*) is admissible if and
    only if *h*(*n*) is less than the actual cost to reach the goal state from *n*
    for every node *n* . This means that admissible heuristics never overestimate
    the cost to reach the goal and can lead to optimal solutions only when the heuristic
    function is close to the true remaining distance.
  prefs: []
  type: TYPE_NORMAL
- en: The A* heuristic algorithm operates by choosing the next vertex for exploration
    in a *greedy* manner, prioritizing nodes based on the value of the heuristic function.
    As the sum of the distance to the origin and destination is minimized when *n*
    lies on a straight line from S to G, this heuristic prioritizes nodes that are
    closer to the straight-line distance from origin to destination.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the A* procedure, let’s consider the simple problem of
    finding the shortest path between a source node S and a goal node G in an 8 points
    of interest (POIs) road network. This is the same POI graph from figure 4.14 but
    with heuristic values added for each node. An example of heuristic information
    is the straight-line distance to the goal as shown above each vertex in figure
    4.21.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F21_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 An 8 POIs road network in the form of a graph with heuristic information
    (straight-line distance to the goal) shown above each vertex
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 shows the steps for using A* to find the shortest path from S to
    G.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F22_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 The A* steps to find the shortest path between the source node S
    and goal node G in an 8 POIs road network. The sum of the already incurred costs
    and the distance to the goal is used as the heuristic value to determine whether
    to expand a certain node.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm may look complex since it seems to need to store incomplete paths
    and their lengths at various places. However, using a recursive best-first search
    implementation can solve this problem in an elegant way without the need for explicit
    path storing. The quality of the lower-bound goal distance from each node greatly
    influences the timing complexity of the algorithm. The closer the given lower
    bound is to the true distance, the shorter the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the A* algorithm to the simple routing problem as follows (see
    the book’s GitHub repo for the full code, containing graph initialization and
    visualization).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.5 Simple routing using A* search
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: ① Choose a node based on its heuristic value
  prefs: []
  type: TYPE_NORMAL
- en: ② Expand the node’s children, adding them to the frontier or terminating if
    the destination is found.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Add the toOrigin value for each node on the fly
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of A* in listing 4.5 doesn’t use a “real” A* heuristic algorithm
    for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The straight line or haversine distance from any node to the destination cannot
    be readily determined, as we only have edge weights and no real spatial data (coordinates)
    to situate each node. To get around this, I created a function called `dummy_astar_heuristic`
    that returns static, arbitrarily generated distances for the purposes of this
    example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance from the origin to any node (straight line or otherwise) cannot
    be determined ahead of time for the same reasons as in the previous point. Thus,
    we use the traveled distance (i.e., the cost from the origin to the node as far
    as has been explored), and we update that value as the algorithm discovers new
    nodes. Later in this chapter, we will see how working with geographic data (such
    as road networks) allows us to capture this information beforehand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A_Star` can be called as follows, with some example parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the same result as with beam search and hill climbing: a path
    of S-A-C-E-G.'
  prefs: []
  type: TYPE_NORMAL
- en: Haversine distance
  prefs: []
  type: TYPE_NORMAL
- en: 'The haversine formula is used to calculate the geographic distance between
    two points on earth, given their longitudes and latitudes, based on a mean spherical
    earth radius. This distance is also known as the great-circle distance and is
    calculated using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d* = *R* × *C* and *C* = 2 × atan2(√*a*, √(1-*a*))        **4.3**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding equation, *a* = sin²(∆*lat*/2) + cos(*lat1*) × cos(*lat2*)
    × sin²(∆*lon*/2), *R* is the earth radius (6,371 km or 3,691 miles), and *d* is
    the final distance between the two points. The following figure shows the haversine
    distance between Los Angeles, USA (34.0522° N, 118.2437° W) and Madrid, Spain
    (40.4168° N, 3.7038° W).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F22_UN01_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Haversine distance between Los Angeles and Madrid
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code can be used to calculate the haversine distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: ① Install the Haversine package, and import the haversine function.
  prefs: []
  type: TYPE_NORMAL
- en: ② Set coordinates of two points in (latitude, longitude) format.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set coordinates of two points in (latitude, longitude) format.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Calculate the distance in kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the A* heuristic in optalgotools defaults to calculating
    distances as if the earth were flat. For local searches, this yields the best
    results. If the size of the search area is larger, it is better to calculate distance
    by passing `optalgotools.utilities.haversine_distance` into the `measuring_dist`
    parameter, which considers the curvature of the earth.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.4 Hierarchical approaches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When facing routing problems at larger scales, such as those involving entire
    countries or graphs with millions of nodes, it is simply implausible to use basic
    approaches like Dijkstra's. In the previous chapter, you saw that bidirectional
    Dijkstra's gives a two times speedup compared to Dijkstra’s algorithm. However,
    much faster routing algorithms are needed for interactive applications like navigation
    apps. One way to achieve this is to precompute certain routes and cache them on
    servers so that response times to user queries are reasonable. Another method
    involves pruning the search space. Hierarchical search algorithms prune the search
    space by generating admissible heuristics that abstract the search space.
  prefs: []
  type: TYPE_NORMAL
- en: Note For more details about the general approaches of hierarchical methods,
    see Leighton, Wheeler, and Holte, “Faster optimal and suboptimal hierarchical
    search” [1].
  prefs: []
  type: TYPE_NORMAL
- en: Highway hierarchies involve the assignment of hierarchy “levels” to each road
    in a road network graph. This distinguishes the type of road segment (e.g., residential
    roads, national roads, highways). This is further supplemented by relevant data
    such as the maximum designated driving speed as well as the number of turns in
    the road. After the heuristics are generated for the graph, the data is passed
    through a modified search function (bidirectional Dijkstra's, A*, etc.) that considers
    the distance to the destination and the potential expansion node type. Highway
    hierarchy algorithms will generally consider highways as viable expansion nodes
    when they are further away from the target and will start to include national
    roads, and finally residential streets, as they near the destination. During the
    trip, less important roads merge with more important roads (e.g., residential
    roads merge with national roads, and national roads merge with highways). This
    allows us to avoid exploring millions of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, a long-distance driving trip from New York to Miami. In the
    beginning, you will need to navigate local roads toward a highway or interstate.
    In the middle section of the trip, you will drive exclusively on the interstate
    or highway. Nearing your destination, you will leave the interstate and once again
    take local roads. While this approach makes sense, there are some disadvantages.
    First, the algorithm overlooks what kind of roads humans prefer to drive on. While
    a highway might make sense for a given route, the user may prefer to take local
    roads (such as when driving to a friend’s house who lives nearby). Second, highway
    hierarchies do not consider factors such as traffic, which fluctuates often and
    adds significant cost to an “optimal” route. You can learn more about highway
    hierarchies in Sanders and Schultes’ article “Highway hierarchies hasten exact
    shortest path queries” [2].
  prefs: []
  type: TYPE_NORMAL
- en: The contraction hierarchies (CH) algorithm is another hierarchical approach.
    It is a speed-up technique that improves the performance of shortest-path computations
    by pruning the search space based on the concept of node contraction. For example,
    for an 80 mile single-source single-destination shortest path search query, the
    bidirectional Dijkstra's algorithm explores 220,000 nodes, unidirectional A* explores
    50,000 nodes, and bidirectional A* improves on those by exploring about 25,000
    nodes. Contraction hierarchies solve the same problem by exploring only about
    600 nodes. This makes CH much faster than Dijkstra's, bidirectional Dijkstra's,
    and A*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note Contraction hierarchies were introduced in Geisberger et al.’s 2008 “Contraction
    hierarchies: Faster and simpler hierarchical routing in road networks” article
    [3]. The 80 mile single-source single-destination shortest path search query is
    discussed on the *GraphHopper* blog ([http://mng.bz/n142](http://mng.bz/n142)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CH algorithm encompasses two main phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The *preprocessing phase* is where nodes and edges are categorized based on
    some notion of importance. Important nodes can be major cities, major intersections,
    bridges connecting the two sides of a city, or points of interest that shortest
    paths go through. Each node is contracted based on the level of importance from
    least important to most important. During the contraction process, a set of shortcut
    edges is added to the graph to preserve shortest paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *query phase* is where a bidirectional Dijkstra's search (or any other search)
    is run on the preprocessed graph, considering only increasingly important edges.
    This results in selectively ignoring less important nodes, and overall improving
    querying speed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s worth noting that the CH algorithm is mainly a preprocessing algorithm,
    which means that it is used before querying the shortest path. This preprocessing
    phase takes some time, but once it’s done, the query phase is very fast. The algorithm
    can handle large graphs and can be used for various types of graphs, not only
    road networks. Let’s dive into both phases in further detail.
  prefs: []
  type: TYPE_NORMAL
- en: The CH preprocessing phase
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessing phase takes as input the original graph, and it returns an
    augmented graph and node order to be used during the query phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume a weighted directed graph *G* = (*V*,*E*). The nodes of this graph are
    ordered based on node importance. In the case of road networks, node importance
    can be based on road type: residential roads, national roads, and motorways or
    highways. The basic intuition here is that closer to the source or target, we
    usually consider residential roads; far away from the source or target, national
    roads are considered; and even further away from the source or the target, it
    makes sense to consider highways. Some other heuristics that affect the node importance
    include the maximum speed, toll rates, the number of turns, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the node order is determined, the vertex set or nodes are ordered by importance:
    *V* = {1,2,3…,*n*}. Nodes are contracted or removed in this order using the following
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated in figure 4.23, node *v* can be contracted from graph *G*. If
    necessary, a shortcut or edge with a cost of 5 should be added to ensure that
    the shortest distance between *u* and *w* is preserved or remains the same, even
    after *v* has been contracted. Contracting a node *v* means replacing the shortest
    paths going through *v* with shortcuts. The new graph is called an *overlay graph*
    or an *augmented graph* (i.e., a graph with an augmented set of edges). This graph
    contains the same set of vertices as the initial graph and all the edges, plus
    all the added edges (shortcuts) used to preserve shortest distances in the original
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F23_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 Node contraction operation—the number in brackets denotes the cost
    of the added shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: When contracting node *v*, no shortcut is needed if there is a path *P* between
    *u* and *w* with *w*(*P*) <= *w*(<*u*,*v*,*w*>). This path is called a *witness
    path*, as shown in figure 4.24.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F24_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 Witness path—there is another path from *P* to *w* that is shorter,
    so no shortcut is needed when contracting *v*.
  prefs: []
  type: TYPE_NORMAL
- en: During the CH preprocessing phase, since the nodes are ordered based on importance,
    a node can be iteratively contracted, and an additional shortcut arc can be added
    to preserve short distances and to form an augmented graph. We end up with a contraction
    hierarchy, with one overlay graph for each individual node. This preprocessing
    is done offline, and the augmented graph is used later during the query phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a simple graph with four nodes. Figure 4.25 shows the steps
    of the contraction process. We will contract each node following the order of
    importance from the least to the most important node (i.e., following the importance
    or hierarchy level from 1 to *n*). This process will form shortcuts, which will
    allow us to search the graph much faster, as we can ignore nodes that have been
    pruned. The initial graph is shown in figure 4.25a:'
  prefs: []
  type: TYPE_NORMAL
- en: By contracting the least important node, node 1, nothing happens, as the shortest
    path between the neighboring nodes 2 and 4 does not pass by node 1 (figure 4.25b).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving forward and contracting the next most important node, node 2, we have
    now changed the shortest path for 1→3, 1→4, and 3→4\. We can encode these shortest
    paths by creating new edges (shortcuts). The numbers in brackets denote the costs
    of the added shortcuts (figure 4.25c).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contracting node 3 does not cause any change, as there is a shorter path between
    nodes 2 and 4 that does not pass by node 3 (figure 4.25d).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not need to contract node 4, as it is the last node in the graph (figure
    4.25e).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generated overlay graph after the contraction process is shown in figure
    4.25f. The nodes are ordered based on importance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F25_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 An example of the CH preprocessing phase
  prefs: []
  type: TYPE_NORMAL
- en: The order of contraction does not affect the success of CH, but it will affect
    the preprocessing and query time. Some contraction ordering systems minimize the
    number of shortcuts added in the augmented graph and thus the overall running
    time.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we need to use some notion of importance and keep all the nodes in
    a priority queue by decreasing importance. Edge difference, lazy updates, the
    number of contracted neighbors, and shortcut cover (all explained shortly) are
    examples of importance criteria. The *importance* of each node in the graph is
    its *priority*. This metric guides the order in which nodes are contracted. This
    *priority* term is dynamic and is continuously updated as nodes are contracted.
    The typical importance criteria include
  prefs: []
  type: TYPE_NORMAL
- en: '*Lazy updates*—The priority of the node on top of the priority queue (i.e.,
    the node with the smallest priority) is updated before it is removed. If this
    node is still on top after the update, it will be contracted. Otherwise, the new
    topmost node will be processed in the same way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Edge difference* (ED)—The ED of a node is the number of edges that need to
    be added versus the number of edges to be removed. We want to minimize the number
    of edges added to the augmented graph. For a node *v* in a graph, assume that'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in(*v*) is the incoming degree (i.e., the number of edges coming into a node)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: out(*v*) is the outgoing degree (i.e., the number of outgoing edges emanating
    from a node)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: deg(*v*) is the total degree of the node, which is the sum of its in and out
    degrees so deg(*v*) = in(*v*) + out(*v*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: add(*v*) is the number of added shortcuts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ED(*v*) is the edge difference after contracting node *v*, and it’s given by
    ED(*v*) = add(*v*) – deg(*v*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two figures show how the edge difference is calculated and used to
    choose between contracting an edge node like *A* (figure 4.26) and a hub node
    like *E* (figure 4.27)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F26_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26 Edge difference in the case of edge node *A*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F27_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.27 Edge difference in case of a hub node. The numbers in brackets denote
    the cost of the added shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: '*Number of contracted neighbors*—This reflects how nodes are spread across
    the map. It is better to avoid contracting all nodes in a small region of the
    graph and to ensure uniformity during the contraction process. We first contract
    the node with the smallest number of contracted neighbors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shortcut cover*—This method approximates how unavoidable the node is (e.g.,
    a bridge connecting two parts of a city across a river). It represents the number
    of neighbors of a node, and thus how many shortcuts we’ll need to create to or
    from them after contracting the node, because they’re unavoidable nodes. Nodes
    with a smaller number of shortcut covers are contracted first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The priority of a node estimates the attractiveness of contracting the node
    and can be a weighted linear combination of the previously described importance
    criteria, such as edge difference, number of contracted neighbors, and shortcut
    cover. The least important node is extracted in each iteration. The contraction
    process may affect the importance of a node, so we need to recompute this node
    importance. The newly updated importance is then compared with the node on the
    top of the priority queue (with the lowest importance) to decide whether or not
    this node needs to be contracted. The node with the smallest updated importance
    is always contracted.
  prefs: []
  type: TYPE_NORMAL
- en: The CH query phase
  prefs: []
  type: TYPE_NORMAL
- en: 'During the CH query phase, we apply bidirectional Dijkstra''s to find the shortest
    path between the source and the target, as follows (figure 4.28):'
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm from the source only considers edges *u*,*v* where level(*u*)
    > level(*v*), so you only want to relax nodes with a higher level than the node
    you have relaxed at that iteration. This is called the *upward graph*. In the
    context of Dijkstra’s algorithm, *relaxing* a node refers to the process of updating
    the estimated distance or cost to reach that node from a source node by considering
    shorter paths through neighboring nodes. This helps refine the estimate of the
    shortest path to the node from the source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm from the target only considers edges *u*,*v* where level(*u*)
    < level(*v*), so you only want to relax nodes with a lower level than the node
    you have relaxed at that iteration. This is called the *downward graph*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F28_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 CH query phase
  prefs: []
  type: TYPE_NORMAL
- en: A CH example
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following network with an arbitrary node ordering (figure 4.29).
    The numbers in the circles are the order in which the nodes will be contracted.
    The numbers on the edges represent the costs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F29_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 A CH example
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the CH algorithm on this graph to get the shortest path between two
    nodes in this road network. The following steps show how to apply the CH algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.  *Contracting node 1*—There’s no need to add a shortcut, as we do not lose
    a shortest path (figure 4.30).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F30_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.30 Graph contraction using an arbitrary node ranking—contracting node
    1
  prefs: []
  type: TYPE_NORMAL
- en: 2\.  *Contracting node 2*—There’s no need to add a shortcut, as we do not lose
    a shortest path (figure 4.31).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F31_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.31 Graph contraction using an arbitrary node ranking—contracting node
    2
  prefs: []
  type: TYPE_NORMAL
- en: 3\.  *Contracting node 3*—A shortcut needs to be added to preserve the shortest
    path between 8 and 5, as there is no witness path. The cost of the added arc is
    7 (figure 4.32).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F32_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.32 Graph contraction using an arbitrary node ranking—contracting node
    3
  prefs: []
  type: TYPE_NORMAL
- en: 4\.  *Contracting node 4*—No shortcuts need to be added (figure 4.33).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F33_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.33 Graph contraction using an arbitrary node ranking—contracting node
    4
  prefs: []
  type: TYPE_NORMAL
- en: 5\.  *Contracting node 5*—No shortcuts need to be added (figure 4.34).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F34_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.34 Graph contraction using an arbitrary node ranking—contracting node
    5
  prefs: []
  type: TYPE_NORMAL
- en: 6\.  *Contracting node 6*—No shortcuts need to be added, as there is a witness
    path between 7 and 10, which is 7-11-12-10 (figure 4.35).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F35_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.35 Graph contraction using an arbitrary node ranking—contracting node
    6
  prefs: []
  type: TYPE_NORMAL
- en: 7\.  *Contracting node 7*—No shortcuts need to be added (figure 4.36).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F36_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.36 Graph contraction using an arbitrary node ranking—contracting node
    7
  prefs: []
  type: TYPE_NORMAL
- en: 8\.  *Contracting node 8*—A shortcut needs to be added to preserve the shortest
    path between 9 and 12 (figure 4.37).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F37_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.37 Graph contraction using an arbitrary node ranking—contracting node
    8
  prefs: []
  type: TYPE_NORMAL
- en: 9\.  *Contracting node 9*—No shortcuts need to be added (figure 4.38).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F38_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.38 Graph contraction using an arbitrary node ranking—contracting node
    9
  prefs: []
  type: TYPE_NORMAL
- en: 10\.  *Contracting node 10*—No shortcuts need to be added (figure 4.39).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F39_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.39 Graph contraction using an arbitrary node ranking—contracting node
    10
  prefs: []
  type: TYPE_NORMAL
- en: 11\.  *Contracting node 11*—No shortcuts need to be added (figure 4.40).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F40_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.40 Graph contraction using an arbitrary node ranking—contracting node
    11
  prefs: []
  type: TYPE_NORMAL
- en: 12\.  *Contracting node 12*—No shortcuts need to be added (figure 4.41).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F41_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.41 Graph contraction using an arbitrary node ranking—contracting node
    12
  prefs: []
  type: TYPE_NORMAL
- en: The contracted graph can now be queried using a bidirectional Dijkstra's search.
    In the following figures, the numbers in brackets denote the cost of the added
    shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: The upward graph in figure 4.42 shows the forward Dijkstra's search from the
    source to the target. The solid lines represent the visited edges, and the bold
    solid lines represent the shortest path between the source node and the meeting
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F42_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.42 Solving a road network problem using the CH algorithm—upward graph
  prefs: []
  type: TYPE_NORMAL
- en: The downward graph in figure 4.43 shows the backward Dijkstra's search from
    the target to the source. The solid lines represent the visited edges, and the
    bold solid lines represent the shortest path between the target node and the meeting
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F43_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.43 Solving a road network problem using the CH algorithm—downward graph
  prefs: []
  type: TYPE_NORMAL
- en: The minimum is at node 12 (4 + 8 = 12), so node 12 is the meeting point (figure
    4.44).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F44_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.44 Solving a road network problem using the CH algorithm—meeting point
  prefs: []
  type: TYPE_NORMAL
- en: The shortest path will be 1-10-12-8-5\. However, this path contains a shortcut
    (5-8). The actual arc (8-3-5) needs to be unpacked according to the shortcut pointer
    (node 3) stored during the contraction process. The actual shortest path is 1-10-12-8-3-4
    with a cost of 12 (figure 4.45).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F45_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.45 Solving a road network problem using the CH algorithm—shortest path
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.6 shows the implementation in Python. Note that the code for graph
    initialization has been omitted here, as it is similar to previous examples, but
    it can be viewed in the full listing in the book’s GitHub repo. Likewise, the
    code for graph visualization is also in the full listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.6 Contraction hierarchy with predetermined node order
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: ① Copy the main graph so that the nodes are only removed from the copy, not
    the main graph.
  prefs: []
  type: TYPE_NORMAL
- en: ② Contract the node by removing it from the copied graph.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Recalculate the shortest path matrix, now with the node contracted.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Add a shortcut edge to replace the changed shortest path, and keep track of
    it so  we can uncontract it when querying later.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the preceding code creates two shortcut edges for each
    contraction, one from *P* to *v*, and one in reverse from *v* to *u*. As we are
    using an undirected graph, this duplication has no effect, since the edge (*u,
    v*) is the same as the edge (*v, u*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying the generated graph requires a simple modified bidirectional Dijkstra''s
    search, where neighbor nodes are disqualified for expansion if they are lower
    in the hierarchy than the current node. For the purposes of this book, we will
    use `networkx.algorithms.shortest_paths.weighted.bidirectional_dijkstra`, with
    a slight change (only nodes of higher hierarchy than the current node can be explored).
    As a continuation of listing 4.6, the following code snippet shows the querying
    process. The full code for the modified algorithm can be found in listing 4.6
    in the book’s GitHub repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: ① Run bidirectional Dijkstra's using NetworkX.
  prefs: []
  type: TYPE_NORMAL
- en: ② Unpack any edges that are marked as contracted, and generate the unpacked
    route.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code will generate an unpacked route that can be visualized as
    in figure 4.46.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F46_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.46 The solution path after unpacking the contracted edges. The original
    route returned by bidirectional Dijkstra's passes through the contracted edge
    (8,5), which is then unpacked into (8,3) and (3,5).
  prefs: []
  type: TYPE_NORMAL
- en: Contraction hierarchies expend a great deal of processing time on the preprocessing
    phase, but a correctly pruned graph (i.e., where the node contraction order is
    good) allows for much faster queries. While the small reduction in search space
    is negligible on a graph with 21 nodes, some graphs can be pruned up to 40%, resulting
    in significant cost and time savings when querying. In the example from listing
    4.6, the search from node 1 to node 5 explores 11 nodes, as compared to the original
    16 nodes in a normal bidirectional Dijkstra's. That’s almost a 33% reduction!
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Applying informed search to a routing problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look again at the University of Toronto routing problem introduced in
    section 3.5\. We need to find the shortest path from the King Edward VII Equestrian
    statue at Queen’s Park to the Bahen Centre for Information Technology. The search
    space is represented by a road network in which the intersections and points of
    interest (including the origin and destination) are nodes, and edges are used
    to represent road segments with weight (e.g., distance, travel time, fuel consumption,
    number of turns, etc.). Let’s look at how we can find the shortest path using
    the informed search algorithms discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 Hill climbing for routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Listing 4.7 uses two functions from `optalgotools.routing` that generate random
    and child routes. While the actual HC algorithm is deterministic, the randomized
    initial route means that different results can be achieved over different runs.
    To counter this, we’ll use a higher *n* value, which allows a broader diversity
    of children routes, so an optimal (or near optimal) solution will more likely
    be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.7 U of T routing using the hill climbing algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: ① Track time and costs for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: ② Generate an initial route randomly.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Get k neighbors (children).
  prefs: []
  type: TYPE_NORMAL
- en: While the implementation in listing 4.7 is deterministic, the initial route
    is still randomized. That means it is possible to get different results across
    runs. Hill climbing will return some decent results, as there are few local optimal
    points in the route function. However, larger search spaces will naturally have
    more local maxima and plateaus, and the HC algorithm will get stuck quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.47 shows a final solution of 806.892 m, which happens to be the same
    as the result generated by Dijkstra’s algorithm in chapter 3 (an optimal solution).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F47_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.47 Shortest path solution generated using hill climbing. The solution
    shown here uses an *n* value of 100, which increases the total processing time
    but returns better and more consistent results.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 Beam search for routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A beam search for routing will follow much the same format as the HC search,
    with the exception that a “beam” of solutions is kept for comparison at each iteration.
    The full code for listing 4.8, with the graph initialization and visualization,
    is in the book’s GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.8 U of T routing using the beam search algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ① Generate child routes for each route in the beam.
  prefs: []
  type: TYPE_NORMAL
- en: ② Initialize empty sets to keep track of visited nodes and path costs.
  prefs: []
  type: TYPE_NORMAL
- en: ③ The seen routes must be converted to a tuple so they are hashable and can
    be stored in a set.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Keep the k best routes at each iteration until generating new beams no longer
    finds better solutions.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ The final route is the best route in the last beam.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Return the final route, its cost, processing time, and space required.
  prefs: []
  type: TYPE_NORMAL
- en: Beam searches for routing are particularly costly, as they require multiple
    child routes to be generated for each beam. Like HC, generating more children
    results in a broader penetration of the search space, and thus is more likely
    to return a solution that is closer to or reaches the optimal solution. Figure
    4.48 shows a final solution generated by beam search.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F48_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.48 Shortest path using a beam search algorithm. This solution was generated
    using *k* = 10 and *n* = 20, which means that 20 routes were generated for each
    route in the beam, and the top 10 routes were kept for each new beam. Lower *k*
    and *n* values will improve processing time but reduce the likelihood of generating
    a near-optimal or optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.3 A* for routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next listing shows how we can use A* search to find the shortest route between
    two points of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.9 U of T routing using A*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: ① Set up King’s College Cir, Toronto, ON as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a graph.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set up the King Edward VII equestrian statue as the origin.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set up the Bahen Centre for Information Technology at U of T as the destination.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Get the osmid of the nearest nodes to the points
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Convert the source and destination nodes to Node.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Find the shortest path using A*.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Print the cost, processing time, space required, and explored nodes, and draw
    the final route.
  prefs: []
  type: TYPE_NORMAL
- en: The optimality of the A* search depends on the heuristic used. In this case,
    the solution returned is not optimal, but the incredibly high processing speed
    achieved is more important for most applications. Figure 4.49 shows a final solution
    generated by A* search.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_F49_Khamis.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.49 Shortest path using the A* algorithm. Better heuristic functions
    that closely approach the actual costs from any node to the goal will return better
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.4 Contraction hierarchies for routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to run CH on the road network graph, we first need to rank the nodes
    by importance and then contract the graph. For this example, we are selecting
    edge difference (ED) as our measure of node importance.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.10 U of T routing using CH
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: ① Some nodes are essentially dead ends, where they have no outbound edges. These
    nodes have an ED equal to their degree.
  prefs: []
  type: TYPE_NORMAL
- en: ② We can ignore two-way edges—an inbound edge and an outbound edge that originate
    and terminate at the same node.
  prefs: []
  type: TYPE_NORMAL
- en: ③ The edge difference is the difference between edges that need to be added
    to the graph and the degree of the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contracting the graph is as simple as adding an edge for every shortest path
    that gets altered by the contraction. The full code for graph contraction can
    be found in the book’s GitHub repo. Contracted edges are marked with an attribute
    called *midpoint*, which stores the ID of the node that was contracted. Following
    a modified bidirectional Dijkstra''s similar to that used in listing 4.6, the
    final route can be easily unpacked using the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: ① For every midpoint unpacked, recursively unpack the resulting two edges, as
    some contracted edges may contain other contracted edges.
  prefs: []
  type: TYPE_NORMAL
- en: ② Unpack every node pair in the contracted route.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repo also contains the full Python implementation of CH for routing.
    The route generated is identical to that shown by a normal bidirectional Dijkstra's
    algorithm (such as in chapter 3). If you will recall, running the normal bidirectional
    Dijkstra's in chapter 3 yielded a result where 282 nodes were explored during
    the search. For our CH result, only 164 nodes were explored, which means more
    than a 40% reduction of search space! Thus, while the optimality of the algorithm
    remains unchanged, contraction hierarchies allow for much bigger spaces to be
    searched in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1 compares the search algorithms discussed in this chapter when applied
    to the U of T routing problem. A similar table can be found in chapter 3 for blind
    search algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1 Comparing informed search algorithms in terms of time and space complexities,
    where *b* is the branching factor, *w* is the beam width, *d* is the shallowest
    graph depth, *E* is the number of edges, and *V* is the number of vertices
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithm | Cost (meters) | Time (s) | Space (bytes) | Explored | Time complexity
    | Space complexity |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Hill climbing | 806.892 | 21.546 | 976 | 400 nodes | *O*(∞) | *O*(*b*) |'
  prefs: []
  type: TYPE_TB
- en: '| Beam search | 825.929 | 44.797 | 1,664 | 800 nodes | *O*(*wd*) | *O*(wb)
    |'
  prefs: []
  type: TYPE_TB
- en: '| A* search | 846.92 | 0.063 | 8,408 | 80 nodes | *O*(*b^d*) | *O*(*b^d*) |'
  prefs: []
  type: TYPE_TB
- en: '| CH with bidirectional Dijkstra''s | 806.892 | 0.0469 | 72 | 164 nodes | *O*(*E*
    + *V*log*V*) | *O*(*b^d*/2) |'
  prefs: []
  type: TYPE_TB
- en: Note The time listed for CH with bidirectional Dijkstra's is only for querying.
    Remember that the preprocessing step is usually quite costly. In this case, contracting
    the road network of 404 nodes took around 24.03125 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: While hill climbing and beam search produced respectable results, they were
    too costly in terms of time to be useful for larger graphs. A* gives the fastest
    results but a non-optimal heuristic function, and it required excessive space
    for the heuristic values, so it has its own disadvantages. CH with bidirectional
    Dijkstra's is the only algorithm in table 4.1 that guarantees optimality, but
    the costly preprocessing step may not be suitable for all applications.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing search algorithms, it is important to be aware of the constraints
    for any given problem and to select an algorithm based on those constraints. For
    example, certain implementations of hill climbing may result in rapid exit conditions.
    If the goal is to maximize the number of problems solved (and if local maxima
    are an acceptable result), HC algorithms result in quick solutions that have some
    degree of optimality. On the other hand, preprocessing-heavy algorithms like CH
    offer incredibly low space costs (even more so when implemented with a bidirectional
    search), as well as rapid searches for guaranteed optimal solutions (if using
    Dijkstra’s algorithm). For high-volume usage implementations where preprocessing
    is not a concern (e.g., Uber), contraction hierarchies are a viable choice. In
    fact, the osrm package used in this book is primarily based on an implementation
    of contraction hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Pandana, a Python library for network analysis, uses CH to calculate shortest
    paths and fast travel accessibility metrics. In Pandana, the backend code for
    CH is in C++ but can be accessed using Python. Pyrosm is another Python library
    for reading and parsing OpenStreetMap data. It is similar to OSMnx but faster,
    and it works with Pandana.
  prefs: []
  type: TYPE_NORMAL
- en: The next listing is a snippet of code that calculates the shortest distances
    to an amenity of interest in a selected city using the CH algorithm implemented
    in Pandana. The complete code is available in the book’s GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.11 Using CH to calculate the shortest distances to amenities
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: ① Get data for the city, region, or country of interest.
  prefs: []
  type: TYPE_NORMAL
- en: ② Get nodes and edges from the road network with a "driving" type.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Get points of interest for a certain amenity in the city.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create a network graph.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Ensure all hospitals are represented as points.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Precompute distances up to 1,000 meters.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Attach hospitals to the Pandana graph.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ For each node, find the distances to the five closest hospitals up to 1,000
    meters away.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, OpenStreetMap is used to get data on the city of Toronto, and
    a subset is created to contain data on the city’s hospitals. A Pandana object
    is then created, and the range queries are precomputed, given a horizon distance
    (e.g., 1,000 meters) to represent the reachable nodes within this distance. For
    each node in the network, we can find distances to the five closest hospitals
    up to 1,000 meters away using the fast CH algorithm implemented in Pandana.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the book, we’ll look at trajectory-based algorithms starting
    with the simulated annealing algorithm and then the tabu search algorithm. These
    algorithms improve local search and are less susceptible to getting stuck in local
    optima than the previously discussed greedy algorithms, which only accept improving
    moves.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Informed search algorithms use domain-specific knowledge or heuristic information
    to streamline the search process while striving for optimal solutions or accepting
    near-optimal ones if necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Informed search algorithms can be used to solve minimum spanning tree (MST)
    problems and to find the shortest path between two nodes in a graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Borůvka algorithm, Jarník-Prim algorithm, and Kruskal algorithm are informed
    search algorithms for solving MST problems. An MST is a tree that contains the
    least weight among all the other spanning trees of a connected weighted graph.
    Kruskal’s algorithm is a greedy algorithm that computes the MST for an undirected
    connected weighted graph by repeatedly adding the next shortest edge that doesn’t
    produce a cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hill climbing (HC), beam search, best-first search, the A* algorithm, and contraction
    hierarchies (CH) are examples of informed search algorithms that can be used to
    find the shortest path between two nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HC algorithm is a local greedy search algorithm that tries to improve on
    the efficiency of depth-first by incorporating domain-specific knowledge or heuristic
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beam search expands the most promising node within a limited predefined set
    defined by the beam width.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best-first search is a greedy algorithm that always expands the node that is
    closest to the goal node based on heuristic information only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The A* algorithm is a special case of a best-first algorithm that incorporates
    both the actual cost and a heuristic estimate of the cost to get to the goal from
    a given state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CH is a speed-up technique for improving the performance of pathfinding. During
    the preprocessing phase, each node is contracted in order of importance (from
    least important to most important), and shortcuts are added to preserve the shortest
    paths. Then the bidirectional Dijkstra’s algorithm is applied to the resultant
    augmented graph to compute the shortest path between the source node and the target
    node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
