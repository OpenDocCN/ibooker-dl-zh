- en: 10 Company information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding functionality to support a company dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Company Information component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Recent ACH Batches component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an Expected Files component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Company Limits component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter looks at another iteration during our program increment. The business
    had previously mapped out the additional functionality regarding the storing and
    displaying of company information. Basically, the business is now requesting a
    dashboard at the company level. In addition, users have provided some input on
    additional functionality they would like to see implemented, which was not in
    the original scope of the project, and the business has asked us to include it
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Sprint planning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this sprint, we create a dashboard that focuses on data at the company level.
    In addition to tables and APIs, there are four additional components that our
    team must create during this sprint:'
  prefs: []
  type: TYPE_NORMAL
- en: Company information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recent batches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expected files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Company limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The company information tables are identified as blockers in our sprint because
    they must be designed and built before working on the components. It may be possible
    to start with some other components with little to no rework, as many of the tables
    for enhancements—such as the Expected Files component—only have a foreign key
    requirement back to the company ID. In such situations, it may be okay to start
    working without the foreign key, but other changes such as displaying customer
    information will require tables built to a certain extent. Figure 10.1 shows the
    Gantt chart created using PlantUML.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F01_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1  ACH dashboard enhancement timeline
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 10.2 Company Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated previously, this sprint is all about working with companies. Each
    ACH file consists of batches with various entry and addenda records. These batches
    are associated with companies. If the companies are customers of our financial
    institution, we have an opportunity to provide various reports and controls around
    them. It is important to understand that the batches are not necessarily from
    companies associated with our institution—they may be from another company or
    partners we work with to deliver transactions to the institution. The company
    dashboard and components we build for it will provide additional ACH-processing
    services to our customers. While these components can be indispensable to the
    company as they provide the potential for additional auditing, alerts, and controls,
    they are not part of the ACH standard.
  prefs: []
  type: TYPE_NORMAL
- en: We have to create database tables and APIs to support storing and accessing
    the company information in our database. The companies are business customers
    of our financial institution, and as such, we want to provide them with additional
    information and controls of ACH files that are beyond what may be typically needed
    for a personal customer. For instance, processing ACH batches for our personal
    customers usually results in posting paychecks and other prearranged payments
    or debits. From an individual’s perspective, there is no interest in the batch
    information and statistics except that the resulting transaction within the batch
    posts to their account correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If we contrast that to business customers (companies), they may very well be
    interested in the batch information because they will be able to tell the totals
    for all transactions within the batch. Similar to personal customers managing
    their account balances for individual transactions, companies need to be aware
    of all the transactions within the batch because they affect the company.
  prefs: []
  type: TYPE_NORMAL
- en: While we may receive and process ACH batches from companies that are not customers
    of our financial institution, in cases where they are, we want to provide additional
    details about the batch. By creating database tables for these companies, we also
    open the possibility to originate files in addition to receiving files to process,
    as we have been doing throughout the project. Originating ACH files is beyond
    the scope of the current development, but it is something that we could look at
    to enhance our project as a logical next step in building a fully functional ACH
    system. We will be populating our company tables with dummy data to give ourselves
    something to work with throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '10.2.1 Database design: Company information'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the `audit_log` in chapter 9 (listing 9.20) and the `bank_routing_numbers`
    table in chapter 8, we had to add many tables that were not specifically ACH related.
    With supporting company information, we now get to add a few more tables and supporting
    types. First, it makes sense to start with the company table and see what we need
    to keep track of.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.1 introduces a couple of custom types into our database. For both
    the `tax_id_type` and `industry` fields, we created new custom types to provide
    some validation and assist with data entry. These custom types help enforce the
    values of data we expect to be present in the field, which prevents entering erroneous
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The `tax_id_type` and `tax_id_number` are correalted because in the United States,
    there is more than just the Social Security Number (SSN) that individuals are
    assigned, such as Employer Identification Number (EIN) and Individual Tax Identification
    Number (ITIN) just to name a few. So, we give the field a more general name instead
    of simply calling it `ssn` or `ein`. We default to `EIN` because companies are
    more likely to use an EIN number.
  prefs: []
  type: TYPE_NORMAL
- en: The `industry` is used for reporting purposes so that various reporting and
    marketing campaigns can filter out industries when users wish to drill down or
    create reports based on industries. The `logo` field is used to store an image
    for the company so that the image can be loaded onto the company page as necessary
    and only serves to make the pages and reporting a bit nicer. We use a new type
    `BYTEA`, which can store binary data. While we would benefit from having the logo
    stored outside the database in terms of UI performance, being able to keep things
    within the database prevents us from having to introduce other technologies such
    as AWS S3 or a CDN.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.1 shows the `create` `table` statement. The `ach_company_id` is used
    to identify the company within ACH. This field corresponds to the company identification
    field on the batch header record (type 5) in an ACH system. While it is common
    to use the EIN number or some variation of it, using it is not obligatory. We
    only need to keep in mind that the field is 10 positions long and should be padded
    with leading zeros when the file is created to maintain file formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.1  Table to store company details
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines the tax_id_type with a default value of EIN since, most likely,
    this will be the type of value used'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The company identification number used on the ACH type 5 record (batch header)'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Many companies have a DUNS number, required for many services when registering
    as a company.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 We store the logo as BYTEA so that we can upload an image to the database.
    Typically, this is a URL for the location where the image is stored. Storing it
    in our database was only for convenience.'
  prefs: []
  type: TYPE_NORMAL
- en: The custom types in the previous listing need to be defined before creating
    the table. Creating the types is a straightforward process, and having these custom
    types helps us with an additional level of validation for the database and fields.
    The approach of course can vary, depending on our application’s needs. For instance,
    it would also be acceptable to store these as strings in the database, or perhaps
    as a numeric value, while having the labels stored in another location.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on several factors (company policy, team members, application, database,
    etc.) it may be preferable to store the values in another table rather than defining
    a type in the database to avoid database change requests. Since we have limited
    values, and there is no need for them to change very often, we are comfortable
    with defining them as types. The following listing shows creating of our `industry_type`
    and `tin_type`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.2  The `industry_type` and `tin_type`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As shown, creating a type to store values is simple. Another concern we may
    have—which is also a reason why team members may argue for using separate tables—is
    the ability to extract the list of valid values (e.g., if we wanted to build a
    dynamic drop-down of the valid values for the `tin_type` on the UI side). The
    following listing shows how to extract the labels for an `ENUM` type.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.3  Returning the labels for an `ENUM` in Postgres
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Returns the label for our ENUM'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Postgres tables needed to return the ENUM label'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The specific ENUM type we are interested in'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our company table in place, we can create an address table. It
    will show two addresses—the mailing and a street address—which we define with
    `address_type`. The rest of the table is standard in terms of what we need to
    store. We allow four lines for an address to cover apartment/floor numbers or
    additional information, plus other standard fields such as city, state, and zip.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.4  The `address_type` and table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines possible mailing address types'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This record is tied to the company, so a foreign key is defined.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defaults the address_type to a mailing address'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Standard address lines with room for department or floor numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Standard address lines'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Fields that can help with auditing'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Prevents more than one type of address for a company by defining a primary
    key that also uses the address_type'
  prefs: []
  type: TYPE_NORMAL
- en: We also created a table named `company_phone` to store phone numbers for the
    company. Again, we define a `phone_type` to identify different categories of phones.
    We also define a primary key of the company and phone type so that each company
    can have only one type of phone defined. Another restriction is to have unique
    `phone_number` and `extension` so that a phone number cannot be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.5  The `company_phone` type and table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines possible values for types of phones'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The table is associated with the company table with a foreign key.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Phone number fields'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Audit fields'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Prevents having more than one type of phone per company'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Prevents more than one phone number from being used'
  prefs: []
  type: TYPE_NORMAL
- en: We should now have more than enough database structure to support companies
    in our ACH dashboard. Much of this information is not strictly necessary when
    working with ACH files, but the additional information will be useful for expanding
    our project with different functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.2 Using generative AI to generate mock data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use generative AI to help boost our productivity by creating some test
    data for our companies. Using the industries we defined for our SQL type `industry_type`,
    we can instruct ChatGPT to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![image](../Images/Prompt-Icon.png)** Given this list of industries “''basic
    materials,’ . . . ''utilities’,” create fake company names, address information,
    and logos for each industry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We were provided with company names such as Elemental Resource Inc. with the
    address of 123 Mineral Lane, Boulder, CO 80301\. We also asked for randomly generated
    EIN and DUNS numbers. It is also possible to see whether ChatGPT can share with
    us any interesting phone numbers that we can include in our data. For instance,
    here are two amusing ones if you have anyone on your team who likes Phil Collins
    or Hall and Oates:'
  prefs: []
  type: TYPE_NORMAL
- en: 424-888-PHIL (7445), known as the Phil Call-Ins Hotline, where you can listen
    to songs from Phil Collins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 719-266-OATES (2837), known as the Callin Oates Hotline, where you can listen
    to a variety of songs from Hall and Oates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While having some fun test data can brighten our day, we need to get all that
    data incorporated into SQL as well. Up until this point, we have been keeping
    all our SQL in the init.sql in the Dockerfile to create tables and data. With
    the need to input the generated company data, we want to do a bit of restructuring.
    We create a subfolder named `sql` and move all the `SQL` commands that currently
    exist in init.sql, while breaking them up into different files. It should be easier
    now to manage and update our SQL as necessary. The following listing shows the
    new structure of our Docker folders.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.6  Docker folder structure for the database
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we update init.sql so that it references the new files.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.7  Updating the init.sql file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Includes the creation of tables'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Includes general ACH data such as exception information'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Each company can be stored in its own file.'
  prefs: []
  type: TYPE_NORMAL
- en: Each company is added with the following SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.8  Adding a company
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a variable saved_uuid as we need it for the other inserts to satisfy
    the foreign key constraint'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses a CTE to insert the company'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Inserts a record with our test data'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Returns the company_id assigned by the database'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Uses our CTE to save the company_id into our saved_uuid'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Inserts the address using the stored company ID'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Inserts the phone using the stored company ID'
  prefs: []
  type: TYPE_NORMAL
- en: We can tell ChatGPT to use the previous listing as a template to insert the
    company data it generated previously. Having ChatGPT generate some of this setup
    code makes it easier to get some default companies added to the database. We certainly
    could have done it ourselves, but it would have been somewhat tedious and error
    prone as we copied/pasted the data.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.3 API design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We start with a simple unit test with a new twist to ensure that we can get
    a `200` `HTTP` response code, which will indicate we are reaching the endpoint
    successfully. As we have seen, we have default companies that are loaded into
    the database when our container is started. Typically, we have been clearing our
    database for each test using `SqlUtils().truncate_all(),` and if we wanted to
    avoid truncating a table, we would need to update that method to exclude that
    particular table. Running our tests in this fashion also required the containers
    to be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: We will now create a test that uses Testcontainers to start and stop our containers
    so that we receive a fresh database every time. This makes the test self-contained,
    which is perfect for when we must move our project into a CI/CD environment.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.9  Initial unit test with Testcontainers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a fixture to make test calls'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the container using Docker Compose because we have been using it
    throughout the project. Everything is set up as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines an IP address for our record'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Defines a test that validates we return successfully; further validation
    can be done for the response as well.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a way to run tests in an isolated environment. The more we isolate
    our tests and keep them self-contained, the easier it will be for the rest of
    the team to run them in their own environment. That way, we can avoid the WOMM
    (Works on My Machine) problems—a common theme in software development.
  prefs: []
  type: TYPE_NORMAL
- en: We now follow the same formula as for previous APIs. We first create a record
    that we can return and that contains some company information we will display
    as an overview. At this point, we just want to be able to display a list of companies
    that users can then drill down into. In the following listing, we define an enumeration
    for the `IndustryType`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.10  The `IndustryType` enumeration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We define a `CompanyOverviewRecord` as shown in the following listing. While
    you have seen most of this code before, we do include a regular expression to
    verify the image is a valid format for displaying on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.11  The `CompanyOverview` Record
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We use the IndustryType to help with validation.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 States that the logo should be Base64'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Enforces the correct format with a regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a class to handle any SQL calls dealing with companies. The
    following listing shows the simple `SELECT` statement using a `row_factory` of
    `class_row`. In such cases where we are simply returning the data and not performing
    data manipulation, we could also use the `dict_row` just as easily—the choice
    really depends on our application needs.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.12  `CompaniesSql` class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Retrieves the database connection and sets the row_factory to a class_row
    for the CompanyOverviewRecord'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Limits the fields we are returning; we prefer specific fields rather than
    “*”.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns all records'
  prefs: []
  type: TYPE_NORMAL
- en: We are almost there! Now we need to add the endpoint. We have built the pieces
    starting from the bottom as we feel that makes things more reasonable as we develop
    the API. However, we could have started with defining the endpoint, drilling down
    to details of retrieving the data.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.13  Getting the endpoint for all companies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We assign a prefix for all the endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Standard documentation for the API'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Our annotation to provide some audit information for the API'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Defines the function and that it will return a list of CompanyOverviewRecords'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 The SQL call for getting all companies'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we only need to add the router to our main.py. We do a little refactoring
    to add the routers into an array and loop through them instead of having multiple
    `include_router` statements. The following listing shows the refactoring results.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.14  Refactored `app.include_router`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines an array of routers'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops through them and includes each of them, which prevents the somewhat
    redundant include_router statements'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have a passing test, but we should not stop here. It is important
    to validate the data being returned as well, not only that we received a valid
    response code of `200`. We should take a moment to think about what else needs
    to be validated to feel confident in publishing the code with a passing test.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we could receive a `200`-response code but not receive any companies.
    If the database has been populated with company data, should we check whether
    those company names exist? Or maybe there is a subset of those companies? We only
    want to drive home the point that the purpose of testing is to have confidence
    in the code we have written. Even if we do not intend to publish our code to production
    after successful automated testing, having a test suite that covers and tests
    our code so thoroughly that we feel confident in publishing it is a valuable goal.
  prefs: []
  type: TYPE_NORMAL
- en: On the side note, in addition to the ability to read companies from the database,
    for a fully functioning dashboard, we also need the ability to add, update, and
    delete. This would be a great time to take a break from reading, pull down one
    of the project versions, and get busy with some full stack development!
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.4 User interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in creating the user interface is to add a button to NavButtons.tsx
    so that we can navigate to the new page. Finding an appropriate icon should be
    the hardest part of this process. Luckily, Material UI has more than enough icons
    to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.15  NavButtons.tsx
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#1 When the navigation button is clicked, we navigate to the companies page.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the icon to display'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Sets the text to Companies'
  prefs: []
  type: TYPE_NORMAL
- en: When navigating to the company page, there will be a list of companies provided.
    We use the same pattern as for other pages. The page.tsx makes the API call retrieve
    the information about the companies, and we pass it to another component that
    does the actual work to display it.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.16  The `CompanyListing` page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a function for the page'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Variable to store the companies; defaulted to an empty array'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The URL for the API; defaults to an empty string when the environment variable
    is not defined'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 API call'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 When the response is successful, sets the companies from the response data'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Passes the companies down to the CompaniesListing'
  prefs: []
  type: TYPE_NORMAL
- en: The `CompaniesListing` component, shown in the following listing, adds several
    new items that we have not used. The `onRowClick` for the DataGrid element allows
    us to click anywhere on the row and navigate to details about that company and
    the row height property so that we can see the company images a bit better. We
    also created an `ImageBase64` to encapsulate some of the needed pieces to display
    an image.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.17  The `CompanyListing` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines the properties for this component'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The function defines the properties as Readonly.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Obtains a router object so that we can navigate as necessary'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Columns definitions for the DataGrid'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 An image element that can display the company logo'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Defines the row click method that executes when a row is clicked and takes
    us to the company dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Uses onRowClick to handle the user clicking a row on the DataGrid'
  prefs: []
  type: TYPE_NORMAL
- en: The `ImageBase64` is straightforward—we have a routine to ensure that the image
    is in the correct format, as seen in the following listing. This allows us to
    perform validation, and we return an empty string if we do not have a correctly
    formatted string.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.18  `Base64` image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '#1 A function to ensure we have a src string formatted correctly to display
    the image in the source tag. If not, we return an empty string, which will display
    the alt tags for the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the component to allow for multiple properties and default values
    if they are not passed'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Assigns the result of the function call to isBase64Image to imageSource'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 There is no img component; instead, the appropriate parameters are passed
    to a Box element.'
  prefs: []
  type: TYPE_NORMAL
- en: We could certainly have just used a `Box` element in our component or page,
    but wrapping the element and treating it as its own component has some benefits.
    We can use this tactic in multiple areas and enforce consistency throughout the
    code. Having a dedicated `ImageBase64` may be a too specific. We could create
    a more general element and pass a type to it that determines the type of `src`
    we are using and performs the necessary validation.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have the database structure to store company information and
    the APIs to access the information about the company. We have also created a component
    capable of listing our companies, as shown in figure 10.2
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH10_F02_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2  Component for listing the companies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we can view the companies in our database, we begin putting our company
    dashboard together.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Company dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a way to navigate to a listing of companies in place, we want to be able
    to display a company-level dashboard. This feature will allow us to create a few
    other components that—although not necessarily unique to companies (we could incorporate
    versions of these components at the file level)—can provide information specific
    to companies and present other directions for our application to grow.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.1 Navigation for the company dashboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a way to view all the companies, we want to be able to drill down and get
    to the company dashboard. The structure required to support the company listing
    and dashboard is shown in listing 10.19.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.19  UI structure for companies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This page will contain the company specific dashboard; the [companyID] will
    be the UUID of the company.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This is the page that displays the company listing shown in figure 10.2.'
  prefs: []
  type: TYPE_NORMAL
- en: With the page structure set up, we only need to create an empty dashboard page
    that can be populated with the company-specific components. We can use our file-level
    dashboard as a template.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.20  Empty company dashboard
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Gets the Company ID from the URL; this is possible because of the file-based
    routing being used and the directory we defined as [companyId].'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Stores the company'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Retrieves the company details'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Placeholder for the dashboard to verify navigation'
  prefs: []
  type: TYPE_NORMAL
- en: While we can now navigate to the dashboard and retrieve company details, the
    dashboard is a little barren. However, before we can start creating dashboard
    components, we need ACH batches for the companies. The next section shows how
    to produce ACH files with company-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2 Creating ACH files for our companies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already created BDD-style tests to generate ACH files for our dashboard.
    Thankfully, we can use the same code to create files specifically for our companies.
    The following listing shows a sample scenario we wrote to create a test file for
    building the company dashboard. We used ChatGPT only for getting some original
    names that might be appropriate for the company’s customers.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.21  Creating a file for Elemental Resources Inc.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we only have to ensure that our company name is not too long as this could
    offset the record. In our original code, we made sure that the field itself was
    padded out to 16 characters when too short. Now, we have the opposite problem
    where we entered a field with 22 characters. The following listing shows a simple
    piece of code that can be used to truncate the company name.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.22  Truncating and padding the company name
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It may be tempting to go through the code and find all those areas that look
    like they should be truncating strings as well. If you go down that route, make
    sure to leave enough time for testing.
  prefs: []
  type: TYPE_NORMAL
- en: To fix or not to fix?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We encountered similar production problems before and had to make the call on
    whether we needed to expand the scope of the story (e.g., where an invalid amount
    was reported on a particular field). The user story was originally written to
    fix the single field reported as incorrect; however, after researching the problem
    and finding the root cause, it was discovered that the problematic pattern was
    used in several other places in the program. Due to the problem causing invalid
    data being sent to a third party, it was decided to update the story and expand
    the scope (i.e., increase the story points) so that the problem could be addressed
    in full.
  prefs: []
  type: TYPE_NORMAL
- en: With company data and specific company ACH files loaded into the database, we
    can start building the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Company Information component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component we want to build is a screen with more details about the
    company. These will only be some additional details that can be edited as needed.
  prefs: []
  type: TYPE_NORMAL
- en: We create the required `Pydantic` class, which is used to return the data. We
    are returning more information in the `CompanyDetailRecord` than we need to display
    because the data will also be passed to a form where all the data will be updateable.
    The following listing shows the `CompanyDetailRecord` where we pass back the arrays
    of `Address` and `Phone` objects. The company has a one-to-many relationship for
    the `Address` and `Phone` types, so it is possible to have more than one row.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.23  The `CompanyDetailRecord` field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '#1 An array of Address objects used to store addresses for the company'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 An array of Phone objects used to store phone numbers for the company'
  prefs: []
  type: TYPE_NORMAL
- en: Because the address and phone records are arrays, we find that building the
    `CompanyDetailRecord` is somewhat more complicated than our previous data retrievals.
    This is because, before, we used to simply pull a record from the database and
    map it to the object. Now, we have multiple rows from multiple tables that we
    need to handle.
  prefs: []
  type: TYPE_NORMAL
- en: We could follow several approaches, but we want to stay with a single query
    like we did in the past. However, depending on our query design, this will potentially
    duplicate fields in the company table. Returning duplicated data is not the end
    of the world; however, it is an indicator that there is some room for improvement.
    After all, we have taken great pains not to carelessly return all fields by simply
    using an asterisk (which can result in returning fields we have no intention of
    using). The duplication may be of concern for performance reasons, as well as
    for causing confusion among developers.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious, but for each address and phone number, the query in listing
    10.24 will return a row. So, if we have two addresses and three phone numbers,
    we will receive five rows from the query. Given the expected number of addresses
    and phone numbers, this is not extremely problematic at this point. We do have
    a relatively large amount of data being returned for the image, but as mentioned
    before, storing data as a `Base64`-encoded string was a matter of convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we use `LEFT` `JOIN` as we have no guarantee that companies will
    have addresses or phones populated. Had we used `INNER` `JOIN`, companies would
    have required addresses and phone numbers to be returned by the query. While having
    company records without an address/phone is not likely, it is not impossible.
    Perhaps the initial record was set up but—for business reasons—the address was
    not populated (maybe there was no official documentation for their address), or
    perhaps, fields did not come over properly during a conversion or migration.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.24  Query to return company details
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We organized selected fields by their respective tables, and these are from
    the companies table.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 These fields are from the company address table.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 These fields are from the company phone table.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 We use a LEFT JOIN because records are not required to be in these tables.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Limiting our details by the company, with %s being a placeholder'
  prefs: []
  type: TYPE_NORMAL
- en: We have multiple rows and will need the application logic to ensure the duplicated
    data is not passed back. The following listing shows the full method to accomplish
    this. We must loop through each record and use a hash to ensure that `id` has
    not been encountered before.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.25  Returning company details
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Fetches all rows for our SQL query'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 If no details are found, this is an error and is reported as such.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Sets up empty hashes to store our data'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Loops through each row that was returned'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Creates an Address object as necessary'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Creates a Phone object when we have a phone number not encountered before'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 We can just reference the company fields from our first row.'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Creates an array from our hash'
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Creates an object using the company_data'
  prefs: []
  type: TYPE_NORMAL
- en: While this code works as expected, we can also condense the resulting dataset
    by using more complicated SQL. We have explored CTE in Postgres in previous examples
    and can use some of the JSON processing available in Postgres as well. The tradeoff
    is that our SQL may become less portable, but JSON processing is available for
    other major databases, such as MySQL, with some slight modifications. The following
    listing shows the updated SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.26  Getting company data using Postgres CTE
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses the JSON_AGG and JSON_BUILD_OBJECT to create an array of addresses
    for the company'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses the company_addresses table'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Selects only the records for our company'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Groups the records by company_id'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Uses the JSON_AGG and JSON_BUILD_OBJECT to create an array of phones for
    the company'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Uses the JSON_AGG and'
  prefs: []
  type: TYPE_NORMAL
- en: JSON_BUILD_OBJECT to create an array of phones for the company
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Uses COALESCE to return an empty JSON array when there are no records in
    the table'
  prefs: []
  type: TYPE_NORMAL
- en: The application becomes more streamlined, as shown in the following listing.
    We can use `**` to unpack the returned JSON into keyword arguments passed to their
    respective objects, thus creating a list of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.27  Python code to return the data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Loops through the data returned to create appropriate array'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Assigns them to the company_data hash'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a CompanyDetailRecord object using the hash we created'
  prefs: []
  type: TYPE_NORMAL
- en: Several factors should always be considered when choosing one path over another.
    This selection may depend on the application and data involved. Performing profiling
    on the application and doing `EXPLAIN` `ANALYZE` on the SQL queries are some of
    the ways to determine which method performs better. A human factor is also involved;
    it takes into consideration which version is clearer and easier to maintain. Either
    way, we can now retrieve and display customer data!
  prefs: []
  type: TYPE_NORMAL
- en: Company Information form challenge
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because we are prepopulating the company information, and completing a form
    covers much of the same material laid out in previous chapters, we believe this
    is another good opportunity to take a break and put together a form to display
    the company information. You may create something from scratch, find a template,
    or use generative AI to see if things can be done faster that way. Using generative
    AI is a good way to get started. Try feeding the SQL tables or interfaces defined
    for the fields to see whether it can generate the boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: With a basic form in place, we move to a component showing recent company batches.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Recent Batches component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we navigate to the company dashboard, we want to be able to get an idea
    of activity for the company. A great way to see the activity is listing the batches
    found for the company. Being able to pull batch information will require us to
    have some knowledge of the ACH layout for batches because we need to gather some
    information from both the batch header (type 5) and the batch control (type 8)
    records. Figure 10.3 shows an example of the component we will be building.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a company profile  Description automatically generated](../Images/CH10_F03_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3  Recent company batches
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To build the Recent Batches component, we follow three easy steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an API endpoint in FastAPI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the SQL query to gather the required data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the returned data in a MUI DataGrid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10.5.1 Implementing the recent batches API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whereas we could build an endpoint that is related to other company functions,
    we will instead implement this function as a search. While doing so is certainly
    a preference for our individual approach, we feel that rather than having something
    such as `/companies/{company_id}/batches`, we will achieve more flexibility if
    we just create an endpoint similar to our transaction search from the previous
    chapter. Therefore, we create an endpoint of `/api/v1/files/batches/search` and
    use it. The following listing from the files.py generates our API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.28  Batches search endpoint
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint should be straightforward by now. The `get_batches` routine follows
    a flow very similar to that in our transaction search. We support a few different
    search methods right from the get-go because we ignore the YAGNI principle from
    chapter 3\. While this is usually something we stay away from, rules are meant
    to be broken. Since this routine is based on the transaction search, it won’t
    take too much effort to code this up to make it available (of course, testing
    is another matter). The following listing shows the initial `get_batches` method.
    While these patterns will likely be useful in the future, for now, we are interested
    in when we do not match any of the previous patterns and will instead search using
    company’s UUID. Recall that when we are on the company dashboard, we have the
    company’s UUID in the URL. So, this will be easy to pass as a query parameter
    for the search.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.29  The `get_batches` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We created the ability to search for batches using many different methods,
    even though we are only interested in searching by the UUID at this point.'
  prefs: []
  type: TYPE_NORMAL
- en: The call for `_get_batches_using_company_uuid` is simple. As with our previous
    search queries, we have pulled the selection logic out of the query into a shared
    method since each of these search methods shares the same selection logic and
    only differs in how we filter the results.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the selection criteria are going to be the biggest and most important
    part of this search effort. The query needs to pull together a few different tables
    to build the search response. Listing 10.30 shows the SQL we used. Note that most
    of the tables are `INNER JOIN`s, but the companies table is using a `LEFT` `JOIN`
    because there is no guarantee that the company name exists in our database.
  prefs: []
  type: TYPE_NORMAL
- en: We know that ACH files can contain batches from companies that may or may not
    be our customers. Because it is entirely possible that our search results may
    return a batch for a specified company not defined in our database, the query
    may fail to return any results. We use the Postgres `COALESCE` command to pull
    the name from the company table. If that is `NULL`, we will use the record from
    the batch header and, finally, an empty string. The following listing shows the
    SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.30  SQL query
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We use the name as we have it in our database, as displayed on the batch
    header, or an empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We use a LEFT JOIN but must use ON instead of USING since the fields we
    want to join are not named the same.'
  prefs: []
  type: TYPE_NORMAL
- en: The results of our query are stored in the `BatchSearchResponse` object in api/batch_search_response.py
    and is a standard Pydantic data model that we will not elaborate on since we have
    defined a fair amount of these already.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5.2 Displaying recent batches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This UI component is simple and is responsible for making an API call to get
    data and display the results in a DataGrid. The main thing to consider is whether
    we truly want the component to be responsible for making the API call. We have
    changed our approach when handling different components. When multiple components
    are on a page and use similar data, we pass that data to the components to minimize
    server calls, hoping to reduce latency and provide a better UX. In this case,
    the data is specific to this component, so we keep everything contained in the
    component. We can envision that this may become problematic if we were to allow
    users customize components on the dashboard, but some redesign would be required,
    and we will cross that bridge once we get there.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.31 shows the basics of the UI component. We use the `renderCell`
    attribute of the MUI DataGrid to provide clickable View links that take a user
    directly to the file or batch. We also use the `formatCurrency` method whenever
    we need to format a currency. Also, note how we can use our search API with the
    parameter `companyId` that was passed in. So, in this case, the search is programmatically
    driven and not necessarily done via the user input like when searching for transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.31  The `RecentCompanyBatches` Component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The useRouter enables the component to navigate to other pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Stores the search response'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses Axios to retrieve data from our endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Creates a hyperlink that allows us to navigate to the file containing the
    batch'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Creates a hyperlink that allows us to navigate directly to the batch'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Reuses our formatCurrency routine'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Passes the required fields to create our grid; we also need to specify an
    ID for the row because we do not have a field named ID.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can show users current activity for the company, which is very useful
    and provides an at-a-glance UX. If a customer were to call for ACH support, they
    are mostly likely calling about something that happened recently. Being able to
    quickly jump to a particular file is going to be important. The next component
    will provide another way to help customers stay on top of their ACH files.
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Expected Files component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful component for our company dashboard is a component that allows
    users to keep track of any expected ACH files for a company. A company may want
    a financial institution to process files on a set schedule, and if the particular
    file has not arrived, then someone needs to be alerted and follow up. For instance,
    if the financial institution’s customer expects to see their paycheck on the 15th,,
    then the bank better make sure it is processed before that date.
  prefs: []
  type: TYPE_NORMAL
- en: This component displays a simple list and an indicator of whether the file has
    been loaded. We will be using the filename as the basis for whether a file has
    been loaded. It is common for financial institutions, data centers, and similar
    to rely on naming conventions to help facilitate various checks and balances,
    so using a filename for our component is not a unique approach to our dashboard.
    Of course, we could also expand the conditions to match any other constraints
    that might be useful from an ACH perspective—whether it is the company ID or totals
    from the batch.
  prefs: []
  type: TYPE_NORMAL
- en: Although we are approaching this problem from the company perspective, it would
    also be incorporated from a more general perspective (e.g., a financial institution
    will also expect files on a set schedule). Figure 10.4 shows an example of the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH10_F04_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4  Expected Files component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We build the Expected Files component using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the database table and type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the API endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the data using a MUI DataGrid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10.6.1 Storing expected files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our database, we create another database table named `company_expected_files`
    to store a list of filenames. We also create a `SCHEDULE_TYPE` like before to
    limit the possible values in the field. The table will only be responsible for
    holding the data necessary to determine whether the file should be found. There
    may be cases where an external job would make the determination and update a flag
    in the table. That is not required in our case, and we can rely on the API call
    to return the additional flag.
  prefs: []
  type: TYPE_NORMAL
- en: The following listing shows the creation of the table and type. We also use
    the `last_file_date`, which has to be maintained to be adjusted. We need to revise
    our file-upload logic to update this field.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.32  Creating the type and table for expected files
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Although it is not required, we define a UUID that the record could be referenced
    by.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The key is actually the company and filename as we only want to have one
    filename per company.'
  prefs: []
  type: TYPE_NORMAL
- en: We take similar steps to populate the database with some data to see the component
    in action. Listing 10.33 shows the `INSERT` for the `company_expected_files` table.
    We can insert these records for each company by using a `SELECT` statement to
    select the `company_id` field based on the `tax_id_number` for the company. Remember
    that the `company_id` is set dynamically by the database when the record is inserted.
    We could also choose to insert the record with a known UUID, but using the preceding
    approach allows us to work with the data as we expect to see it in production
    and prepare ourselves for the times when we do not have the luxury of inserting
    a known field in our test.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.33  Inserting records into the expected files table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Gets the company_id by searching companies by the tax_id_number'
  prefs: []
  type: TYPE_NORMAL
- en: With our database set up, we can now work on the logic that will power the `ExpectedFiles`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 10.6.2 Implementing the expected files API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the data for expected files loaded into the database, we need to be able
    to retrieve it, and we also need to be able to update the `last_file_date` when
    a file is uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we did was start with a test to work on building the required
    SQL logic. Again, we utilized Testcontainers to run our `docker_compose` container
    for the duration of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.34 shows the basic structure of our test file. As part of the test,
    we created a basic `CompanySearchSql` class to search for companies by their `tax_id_number`
    or `ach_company_id` number. The need for such a class is another result of the
    database dynamically assigning the UUID. To avoid scope creep, we only built enough
    functionality to get a single company, but it could easily be incorporated into
    a search page or company page so that when we have hundreds or thousands of customers,
    we do not have to page through them all.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.34  Test for the `ExpectedFilesSql` class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses Testcontainers and DockerCompose to build the container and start only
    the Postgres service. There is no need to start CloudBeaver for a temporary test.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures the container is started and stopped for our test'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses CompanySearchSql to get the company UUID'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Makes sure we actually find something'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Runs the SQL that we want to test'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Makes the necessary assertions to ensure the method worked'
  prefs: []
  type: TYPE_NORMAL
- en: With our unit test in place, we are free to build the logic behind the `get_expected_files_for_company`.
    The `SQL` query creates two additional fields that are not stored directly in
    the database. These fields are a Boolean value for whether the file has been loaded
    and the `next_file_date`, which is the next time we expect to see the file according
    to the file’s schedule. For now, we do not consider filtering our results by the
    date simply because that makes testing a bit more difficult. So, we are returning
    all the data. This does not necessarily make sense for the component when the
    current objective is to show files that were expected today. However, it works
    well enough to demonstrate the intent of the functionality. We could expand this
    component or create a new one that shows files for the coming week, gets the number
    of files expected, and similar. The `SQL` query utilizes the `INTERVAL` function,
    which makes it easy to compute the given time interval. The following listing
    shows the `SQL` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.35  SQL for the Expected Files component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses a CTE to determine when the file is next expected'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Determines whether the file was loaded'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we revise the posting of a file to update the `last_file_date` and
    `updated_at` fields for the table. This approach works well for now—when expected
    files are loaded, the date will increment accordingly and everything will function
    normally. However, problems arise when files are not uploaded. Perhaps the expected
    file does not need to be loaded that day–maybe it was a company holiday. For that
    reason, many financial institutions do not process files on weekends. When a file
    is loaded on a Friday, it may be necessary to adjust the next expected day to
    Monday instead of a Saturday. Handling these edge cases or addressing our users’
    additional needs helps make our software more robust. The following listing shows
    the addition of updating the necessary dates for our expected files.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.36  Updating the dates for our expected files
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Once parsing of the file is completed, we can update the date.'
  prefs: []
  type: TYPE_NORMAL
- en: The logic of updating the dates can be kept simple for now. The `updated_at`
    is just for audit purposes, and determining when the file was uploaded. The last
    time the file was uploaded was also at the time of the update, so we use the function
    `NOW` for both updates. The following listing shows the simple update logic used
    by the `update_last_file_date` mehod.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.37  Simple update logic
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Updates the table to indicate the file has been uploaded'
  prefs: []
  type: TYPE_NORMAL
- en: Things would get more complicated if we wanted to always keep the last file
    date set to a Monday and the processing fell on a weekend. This is an important
    problem because financial institutions may not be open on the weekend (or federal
    holidays), and it may not be appropriate to process files on those days. We certainly
    do not want to be enjoying our Sunday afternoon only to have numerous alerts come
    in, showing the files are missing! The following listing assumes a daily interval,
    but we could easily change this dynamic as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.38  Default to Monday as needed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '#1 If the date falls on a Sunday or Saturday, adds the appropriate number of
    days to force it to Monday. Be aware that this does not work if Monday is a holiday
    and the financial institution is closed. That would take some additional effort.'
  prefs: []
  type: TYPE_NORMAL
- en: While we are not overly concerned about addressing the field `last_file_date`,
    we should begin to see some of the problems that may occur with scheduled tasks,
    especially when we must consider what happens when files are not loaded. It is
    unlikely that our application should have to directly address this, and—ironically
    enough—there may be another scheduled job that needs to run and clean the database.
    For now, we can retrieve the needed data from the database, so let’s proceed with
    creating the UI side of our component.
  prefs: []
  type: TYPE_NORMAL
- en: 10.6.3 Displaying the expected files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heavy lifting should have been done on the backend. The UI component simply
    needs to display the information and an icon dependent on the `file_loaded` Boolean
    that is returned as part of the response. The most interesting part of the UI
    component (considering we have done this many times by now) is the ternary statement
    we use to decide whether to display a `TaskAlt` or a `RadioButtonUnchecked` icon.
    Otherwise, it is the typical flow of adding the component to the page.tsx and
    having the component retrieve the necessary data and display it in the DataGrid.
    The following listing shows the UI component.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.39  The `ExpectedFiles` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We use a ternary statement to determine which icon to display.'
  prefs: []
  type: TYPE_NORMAL
- en: That completes the expected files component. We started by defining the required
    database table and a custom type to support the scheduling of expected files.
    Then we created a unit test with Testcontainers so that we could get a fresh database
    for each run. This approach allowed us to work out the needed SQL to return the
    data required for our component. Finally, we called the API from our UI and formatted
    the data to display it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look to add another component that can help companies monitor and control
    suspicious activity with company limits.
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Company Limits component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This component is centered around proactive monitoring for the company. We would
    like the company to be able to set limits that would trigger alerts and possibly
    prevent transactions from being posted should those limits be hit. This can help
    companies identify and deal with transactions or activity that may be outside
    of normal behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a credit card  Description automatically generated](../Images/CH10_F05_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5  Company Limits component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As a business, if you expect less than, say, $10,000 of debit activity in a
    day, and suddenly, there is a $15,000 batch being posted for your company, you
    likely want to be alerted about that activity. In principle, this is a straightforward
    component that lists totals for the day and compares them to a limit set by the
    company or the bank—functionality that needs to be built out in a future sprint.
    In practice, we need to handle alerting the customer, allowing for processing
    when the company is okay with exceeding the limit, and rejecting the file load
    otherwise. Figure 10.5 shows the Company Limits component we will be implementing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We work on creating this component using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the database table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the API endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the returned information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 10.7.1 Storing the company limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a new table to store limits for the company. As with previous tables,
    this table will use a foreign key that references the company ID from the companies
    table. Remember that the use of the foreign key helps us maintain referential
    integrity for the database. The `ON` `DELETE` `CASCADE` and `ON` `UPDATE` `CASCADE`
    will ensure the record is removed when the company is deleted or changed accordingly
    if updated. Not every company needs to have limits, so we will keep that in mind
    as we create queries which utilize this table.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.40  Company Limits table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Keeping track of when records are created and updated can help with auditing.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few approaches to implementing this functionality, and we will use
    a basic one that can be expanded as needed. The basic approach will not require
    us to store the totals. Instead we rely on the API to gather the totals and determine
    whether they are exceeded. This means that our logic will be executed when the
    company dashboard is displayed and when the file has finished loading so that
    we can add an associated exception. Remember from chapter 8 that if we want to
    add an exception, we will have to add it to the database along with any recovery
    options if desired. The following listing shows how the general_ach_data.sql was
    updated to insert these records.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.41  Setting up the exception data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We can add a new exception code for our company limits condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 It is helpful to provide the users with some guidance on what to do when
    an exception is encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: We also set up the data for the company limits so that there is existing data
    in the database. The following listing shows the simple insertion into the database
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.42  Inserting records for the company limit
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That should be all we need to get up and running with company limits. The next
    section will show you how to update APIs so that you can work with the table.
  prefs: []
  type: TYPE_NORMAL
- en: 10.7.2 Implementing the company limits API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a minute to think about what we would like to accomplish with the company
    limits API. Of course, we need to be able to retrieve what the limits are set
    to, but we will also want to determine what the current totals are for the company
    and a Boolean flag to indicate whether the limits have been exceeded. As mentioned,
    when designing the database tables, we decided not to store the current totals
    for the debits and credits, although we certainly could have created those fields
    and updated them as we loaded them.
  prefs: []
  type: TYPE_NORMAL
- en: A potential drawback in this case is that depending on when/where we decide
    to do this check, we may have limited ability to narrow down the problem for the
    user. We should take a moment to think about where the exception can be written.
    For example, we just added a check for the expected files right after the file
    was loaded. Should we put this check in the same place? That may be our first
    inclination since we just added similar code. However, by putting it there, we
    miss out on being able to identify which batch is responsible for causing the
    company limit to be exceeded as we do not access the record numbers at that point,
    and it makes it difficult to put the actual batch header on the exception. The
    following listing shows that we included the exception during the processing of
    the batch control record.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.43  Adding the exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Checks whether we exceeded the company limits'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Calls the insert_record method from AchExceptionsSql to insert the record'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 This is our standard exception schema. It is the first time we actually
    use the ach_batch_id, although there are plenty of exceptions we need it for.'
  prefs: []
  type: TYPE_NORMAL
- en: We write out our new `COMPANY_LIMITS_EXCEEDED` exception when a file exceeds
    company limits. This means that we need to define the `CompanyLimitsSql` class
    and a method to determine whether the file exceeds the company limits. We can
    tell from the use of the method that it just needs to return a Boolean value to
    determine whether this causes an exception. The method itself is straightforward,
    with the usual getting of the connection running a SQL query and fetching the
    results. The following listing shows the method details.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.44  Determining whether a file exceeded company limits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a CTE to select the batch totals'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sums the credits and debits'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 We only need to return something.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Selects the file and sums'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 We want to return a Boolean, so the “is not None” helps us return True/False.'
  prefs: []
  type: TYPE_NORMAL
- en: The previous listing helps us determine whether we need to write an exception,
    but we also need to define a method that will be used with the UI. This is similar
    to the previous SQL with the addition of the actual fields for the limits, the
    current totals, and flags indicating whether the limit was exceeded. We prefer
    to return explicit flags for the UI to use rather than have the UI rely on making
    the determination itself. The following listing shows the SQL used to return the
    required information for our `get_company_limits` method.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.45  Query for the totals, limits, and flags
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Returns the current debit/credit totals; defaulting to zero when no batches
    are found'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Returns flags to indicate whether limits have been exceeded'
  prefs: []
  type: TYPE_NORMAL
- en: There is just some minor housekeeping to create the API endpoint and the class
    that holds the response for the UI, but there is plenty of existing code to reference
    for these tasks. In the next section, we finish adding the company limits to the
    dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 10.7.3 Displaying the company limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in figure 10.5, the component itself is straightforward as we are
    just trying to convey to the user in the simplest terms whether the limits have
    been exceeded. We do want to add a little more visual appeal to the component
    by displaying the amount as red when it exceeds the limit and green otherwise.
    The following listing shows the basics of setting this feature up.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.46  Company credits and debit limits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Colors the field red when the field has been exceeded'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Colors the field green when the field is within range'
  prefs: []
  type: TYPE_NORMAL
- en: The other aspects of the UI for the company limits already fall into place because
    we are using the existing logic for exceptions. So, that means that the file is
    automatically flagged as having an exception when viewing the dashboard, and the
    exception is returned to the DataGrid when viewing the exceptions. This does bring
    up a problem with viewing the exception for this company limit. We see the ACH
    batch control record (type 8), but we cannot easily tell which company it was
    dealing with. Even though we did save the batch header UUID as part of creating
    the exception, this was the first time we ever used it. It would be nice to update
    our code to include some batch header information when viewing an exception. Let’s
    use this opportunity to make a few changes to the exceptions and exception detail
    screens.
  prefs: []
  type: TYPE_NORMAL
- en: First, the simplest change is to drop the column for the error code from the
    exceptions screen. From a developer’s perspective, this move makes sense, but
    it can be confusing and does not add any value to the UX, especially since end-users
    have the description the code translates to.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the details for the exception consisted of only the unparsed record, which
    used a generic alert component we created for other purposes. Now that we have
    some experience in creating a modal to display details as we did with the audit
    details in chapter 9, we can use those skills to build a more detailed screen.
    We can work on displaying the details we already have (we can move the error code
    to this screen if we want), as well as information we have not used yet, such
    as the recovery action. Figure 10.6 shows the exception details modal we ended
    up with.
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a computer screen  Description automatically generated](../Images/CH10_F06_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6  Exception details modal
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `AchExceptionDetailsResponse` will have to be updated so that it returns
    the required information—the company name if available and a recovery action.
    If we have access to the records, there is certainly an opportunity to return
    a lot more information, but in the interest of bringing back the YAGNI principle
    (chapter 3), and as a reminder of KISS (Keep It Simple, Stupid), we only return
    what we need at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: The main work that we need to do is update the SQL statement for the `get_exception_detail_response`.
    We have to pull in extra tables to get the company name and recovery options.
    Keep in mind that we are not guaranteed to have recovery options nor are we guaranteed
    to have a company name. This means that we will want to avoid using an `INNER`
    `JOIN`. Instead, we will use a `LEFT` `JOIN` as in previous cases where we needed
    to keep the rows on one side of the query even when there were no matching records
    in the subsequent parts. The following listing shows the additional SQL logic
    that needs to be included. Note that since we have saved the parsed header record
    ID, we do not have to do a lot of joins to get to the record like in previous
    queries, where we had to start at the file level and drill down.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.47  Updates to get more exception details
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '#1 These fields are new to our query and select the company name if available
    and any recovery steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Joins the new tables. Again, we need to use LEFT JOIN because we are not
    guaranteed data will exist in tables.'
  prefs: []
  type: TYPE_NORMAL
- en: With the fields now included in our response, we can make the necessary updates
    to the UI to include them as well.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.48  Using the `ExceptionsModal`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Includes the ExceptionsModal and the required parameters'
  prefs: []
  type: TYPE_NORMAL
- en: The `ExceptionsModal` takes care of formatting the `exceptionData` and is based
    on what we did before for our `AuditModal` in chapter 9\. We will not display
    the company name with this component if it is an empty string, and we would like
    to provide a default recovery option of None Provided if no recovery options were
    available. Depending on the situation, it can often be beneficial to display a
    confirmation or message that validates this is an expected situation—sort of a
    21st-century “This page intentionally left blank” message. It may make sense not
    to include the company name if the problem is not directly dealing with a company
    (although a case could be made for referencing the batch for any entry exceptions
    as well). However, hiding the recovery options may make users think something
    has gone wrong, especially when they may depend on referring to recovery options.
    The following listing shows the basics of the modal. Since the query to return
    the exception detail uses the `COALESCE` function, we are guaranteed to return
    at the very least an empty string for the company name, so we use that knowledge
    to check whether the label and field should be displayed. In addition, we use
    `??` to default the recovery text when nothing has been provided.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.49  The `ExceptionsModal` Component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Conditionally includes the company name if something was returned'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Always prints something for the recovery steps, even if it is just something
    to let users know they are on their own'
  prefs: []
  type: TYPE_NORMAL
- en: Only slight adjustments to the Exceptions component are necessary to ensure
    that data is passed properly to the new modal. The following listing shows the
    updated Exceptions component. The biggest change here is simply passing a function
    that will set the open state to `False` when the modal button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.50  The Exceptions component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '#1 No longer needed because it does not add anything useful for the user'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Includes the ExceptionsModal'
  prefs: []
  type: TYPE_NORMAL
- en: So, we have now built a company dashboard that provides information that can
    ensure correct/desired files are loaded, show recent batches for the company,
    and send alerts when activity does not match the company’s expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sprint planning in this chapter focused on building key components—company information,
    recent batches, expected files, and company limits—emphasizing the importance
    of comprehensive data-structure design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A company-level dashboard was created to address the need for storing and displaying
    detailed company information beyond the initial project scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of building robust company data management systems that provide
    a framework for enhancing ACH-processing services for business customers who need
    detailed batch information was highlighted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing foundational company information tables as blockers stressed their
    dependency on further development and the consideration of early work on some
    components to reduce modifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generative AI can help create meaningful test data quickly, which enhances productivity
    by generating more than typical name and address information, including logos.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a company dashboard demonstrated the necessity of organizing UI
    structures for efficient navigation and detailed data presentation for specific
    company metrics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating detailed UI components for company overviews highlighted the value
    of user-friendly interfaces that facilitate seamless navigation and interaction
    at the company level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an API for company data retrieval reinforced the importance of well-structured
    responses and validation mechanisms for dynamic user inter­action with dashboards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing recent batch components highlighted the importance of flexible search
    functions for batch data retrieval to meet diverse business needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating expected file components stressed the need for alerting mechanisms
    and schedule compliance to ensure timely processing of crucial documents and mitigate
    risks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proactive monitoring of ACH files was explored to shift from reactive to pro­active
    measures for improved customer service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Company limit components emphasized configurable alerts and thresholds to safeguard
    against unauthorized or unexpected financial transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding exception functionality, such as alert generation, can help us notify
    customers through various channels if limits are exceeded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Testcontainers enhances testing reliability by ensuring isolated environments,
    eliminating dependency on developer-specific configurations, and allowing robust
    and portable tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
