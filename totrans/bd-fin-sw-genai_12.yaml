- en: 10 Company information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 公司信息
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Adding functionality to support a company dashboard
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加支持公司仪表板的功能
- en: Adding a Company Information component
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加公司信息组件
- en: Adding a Recent ACH Batches component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加最近ACH批次组件
- en: Adding an Expected Files component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加预期文件组件
- en: Adding a Company Limits component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加公司限制组件
- en: This chapter looks at another iteration during our program increment. The business
    had previously mapped out the additional functionality regarding the storing and
    displaying of company information. Basically, the business is now requesting a
    dashboard at the company level. In addition, users have provided some input on
    additional functionality they would like to see implemented, which was not in
    the original scope of the project, and the business has asked us to include it
    as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节探讨了我们在程序增量过程中的另一个迭代。业务部门之前已经规划了关于存储和显示公司信息的附加功能。基本上，业务部门现在要求一个公司级别的仪表板。此外，用户还提供了一些关于他们希望看到实施的附加功能的反馈，这些功能最初不在项目范围内，业务部门要求我们也将其包括在内。
- en: 10.1 Sprint planning
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 赛跑计划
- en: 'In this sprint, we create a dashboard that focuses on data at the company level.
    In addition to tables and APIs, there are four additional components that our
    team must create during this sprint:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次赛跑中，我们创建了一个关注公司层面数据的仪表板。除了表格和API之外，我们的团队在此期间必须创建以下四个额外组件：
- en: Company information
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司信息
- en: Recent batches
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近批次
- en: Expected files
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期文件
- en: Company limits
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司限制
- en: The company information tables are identified as blockers in our sprint because
    they must be designed and built before working on the components. It may be possible
    to start with some other components with little to no rework, as many of the tables
    for enhancements—such as the Expected Files component—only have a foreign key
    requirement back to the company ID. In such situations, it may be okay to start
    working without the foreign key, but other changes such as displaying customer
    information will require tables built to a certain extent. Figure 10.1 shows the
    Gantt chart created using PlantUML.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 公司信息表在我们的赛跑中被识别为阻碍因素，因为它们必须在开始构建组件之前设计和构建。可能有可能从一些其他组件开始，几乎不需要重做，因为许多增强功能的表——如预期文件组件——只需要回到公司ID的外键要求。在这种情况下，可能可以开始工作而不需要外键，但其他更改，如显示客户信息，将需要构建到一定程度的表。图10.1显示了使用PlantUML创建的甘特图。
- en: '![](../Images/CH10_F01_Kardell.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F01_Kardell.png)'
- en: Figure 10.1  ACH dashboard enhancement timeline
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1 ACH仪表板增强时间线
- en: 10.2 Company Information
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 公司信息
- en: As stated previously, this sprint is all about working with companies. Each
    ACH file consists of batches with various entry and addenda records. These batches
    are associated with companies. If the companies are customers of our financial
    institution, we have an opportunity to provide various reports and controls around
    them. It is important to understand that the batches are not necessarily from
    companies associated with our institution—they may be from another company or
    partners we work with to deliver transactions to the institution. The company
    dashboard and components we build for it will provide additional ACH-processing
    services to our customers. While these components can be indispensable to the
    company as they provide the potential for additional auditing, alerts, and controls,
    they are not part of the ACH standard.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这次赛跑完全是关于与公司合作。每个ACH文件都包含各种条目和附加记录的批次。这些批次与公司相关联。如果这些公司是我们金融机构的客户，我们就有机会提供各种关于它们的报告和控制。重要的是要理解，这些批次不一定来自与我们机构相关的公司——它们可能来自其他公司或我们与之合作的伙伴，以将交易交付给机构。我们为该仪表板构建的公司仪表板和组件将为我们的客户提供额外的ACH处理服务。虽然这些组件对公司来说可能不可或缺，因为它们提供了额外的审计、警报和控制的可能性，但它们并不是ACH标准的一部分。
- en: We have to create database tables and APIs to support storing and accessing
    the company information in our database. The companies are business customers
    of our financial institution, and as such, we want to provide them with additional
    information and controls of ACH files that are beyond what may be typically needed
    for a personal customer. For instance, processing ACH batches for our personal
    customers usually results in posting paychecks and other prearranged payments
    or debits. From an individual’s perspective, there is no interest in the batch
    information and statistics except that the resulting transaction within the batch
    posts to their account correctly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建数据库表和API来支持在数据库中存储和访问公司信息。这些公司是我们金融机构的商业客户，因此我们希望为他们提供超出通常可能需要的个人客户之外的信息和控制ACH文件。例如，为我们个人客户处理ACH批次通常会导致发布工资和其他预先安排的支付或借记。从个人的角度来看，除了批次内的交易正确记入其账户之外，他们对批次信息和统计数据没有兴趣。
- en: If we contrast that to business customers (companies), they may very well be
    interested in the batch information because they will be able to tell the totals
    for all transactions within the batch. Similar to personal customers managing
    their account balances for individual transactions, companies need to be aware
    of all the transactions within the batch because they affect the company.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此与商业客户（公司）进行对比，他们可能非常关注批次信息，因为他们将能够知道批次内所有交易的总额。与个人客户管理单个交易的账户余额类似，公司需要了解批次内的所有交易，因为这些交易会影响公司。
- en: While we may receive and process ACH batches from companies that are not customers
    of our financial institution, in cases where they are, we want to provide additional
    details about the batch. By creating database tables for these companies, we also
    open the possibility to originate files in addition to receiving files to process,
    as we have been doing throughout the project. Originating ACH files is beyond
    the scope of the current development, but it is something that we could look at
    to enhance our project as a logical next step in building a fully functional ACH
    system. We will be populating our company tables with dummy data to give ourselves
    something to work with throughout the chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可能会从不是我们金融机构客户的公司接收和处理ACH批次，但在他们是客户的情况下，我们希望提供关于批次的额外详细信息。通过为这些公司创建数据库表，我们也打开了除了接收要处理的文件外，还可以生成文件的可能性，正如我们在整个项目中一直在做的那样。生成ACH文件超出了当前开发的范围，但它是我们可以考虑的，以增强我们的项目，作为构建一个完全功能的ACH系统的逻辑下一步。我们将用虚拟数据填充我们的公司表，以便我们在本章中有所作为。
- en: '10.2.1 Database design: Company information'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 数据库设计：公司信息
- en: In addition to the `audit_log` in chapter 9 (listing 9.20) and the `bank_routing_numbers`
    table in chapter 8, we had to add many tables that were not specifically ACH related.
    With supporting company information, we now get to add a few more tables and supporting
    types. First, it makes sense to start with the company table and see what we need
    to keep track of.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第9章（列表9.20）中的`audit_log`和第8章中的`bank_routing_numbers`表之外，我们不得不添加许多与ACH无关的表。有了支持公司信息，我们现在可以添加更多表和支持类型。首先，从公司表开始，看看我们需要跟踪什么是有意义的。
- en: Listing 10.1 introduces a couple of custom types into our database. For both
    the `tax_id_type` and `industry` fields, we created new custom types to provide
    some validation and assist with data entry. These custom types help enforce the
    values of data we expect to be present in the field, which prevents entering erroneous
    data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1向我们的数据库中引入了几种自定义类型。对于`tax_id_type`和`industry`字段，我们创建了新的自定义类型以提供一些验证并协助数据录入。这些自定义类型有助于强制执行我们期望在字段中存在的数据值，从而防止输入错误数据。
- en: The `tax_id_type` and `tax_id_number` are correalted because in the United States,
    there is more than just the Social Security Number (SSN) that individuals are
    assigned, such as Employer Identification Number (EIN) and Individual Tax Identification
    Number (ITIN) just to name a few. So, we give the field a more general name instead
    of simply calling it `ssn` or `ein`. We default to `EIN` because companies are
    more likely to use an EIN number.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`tax_id_type`和`tax_id_number`是相关的，因为在美利坚合众国，个人被分配的不仅仅是社会保险号（SSN），例如雇主识别号（EIN）和个人税务识别号（ITIN）等。因此，我们给字段一个更通用的名字，而不是简单地称之为`ssn`或`ein`。我们默认为`EIN`，因为公司更有可能使用EIN号码。'
- en: The `industry` is used for reporting purposes so that various reporting and
    marketing campaigns can filter out industries when users wish to drill down or
    create reports based on industries. The `logo` field is used to store an image
    for the company so that the image can be loaded onto the company page as necessary
    and only serves to make the pages and reporting a bit nicer. We use a new type
    `BYTEA`, which can store binary data. While we would benefit from having the logo
    stored outside the database in terms of UI performance, being able to keep things
    within the database prevents us from having to introduce other technologies such
    as AWS S3 or a CDN.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`行业`字段用于报告目的，以便各种报告和营销活动可以在用户希望按行业钻取或创建报告时过滤行业。`logo`字段用于存储公司的图像，以便在需要时将图像加载到公司页面上，并且仅用于使页面和报告看起来更美观。我们使用了一种新的类型`BYTEA`，可以存储二进制数据。虽然将标志存储在数据库外对于UI性能会有所帮助，但能够将所有内容保持在数据库中可以防止我们引入其他技术，如AWS
    S3或CDN。'
- en: Listing 10.1 shows the `create` `table` statement. The `ach_company_id` is used
    to identify the company within ACH. This field corresponds to the company identification
    field on the batch header record (type 5) in an ACH system. While it is common
    to use the EIN number or some variation of it, using it is not obligatory. We
    only need to keep in mind that the field is 10 positions long and should be padded
    with leading zeros when the file is created to maintain file formatting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1显示了`create` `table`语句。`ach_company_id`用于在ACH中识别公司。此字段对应于ACH系统中批量头记录（类型5）上的公司识别字段。虽然通常使用EIN号码或其变体，但使用它不是强制性的。我们只需要记住该字段长度为10位，在创建文件时应使用前导零进行填充，以保持文件格式。
- en: Listing 10.1  Table to store company details
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1  存储公司详情的表
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 Defines the tax_id_type with a default value of EIN since, most likely,
    this will be the type of value used'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了具有默认值EIN的`tax_id_type`，因为，很可能是将使用这种类型的值'
- en: '#2 The company identification number used on the ACH type 5 record (batch header)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在ACH类型5记录（批量头）上使用的公司识别号'
- en: '#3 Many companies have a DUNS number, required for many services when registering
    as a company.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 许多公司有一个DUNS号码，在作为公司注册时，许多服务都需要这个号码。'
- en: '#4 We store the logo as BYTEA so that we can upload an image to the database.
    Typically, this is a URL for the location where the image is stored. Storing it
    in our database was only for convenience.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 我们将标志存储为BYTEA，这样我们就可以将图像上传到数据库。通常，这是一个存储图像位置的URL。将图像存储在我们的数据库中只是为了方便。'
- en: The custom types in the previous listing need to be defined before creating
    the table. Creating the types is a straightforward process, and having these custom
    types helps us with an additional level of validation for the database and fields.
    The approach of course can vary, depending on our application’s needs. For instance,
    it would also be acceptable to store these as strings in the database, or perhaps
    as a numeric value, while having the labels stored in another location.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列表中的自定义类型需要在创建表之前定义。创建类型是一个简单的过程，并且拥有这些自定义类型可以帮助我们在数据库和字段上增加一个额外的验证级别。当然，这种方法可以根据我们的应用程序需求而变化。例如，将这些值作为字符串存储在数据库中，或者可能作为数值存储，同时将标签存储在另一个位置，这也是可以接受的。
- en: Depending on several factors (company policy, team members, application, database,
    etc.) it may be preferable to store the values in another table rather than defining
    a type in the database to avoid database change requests. Since we have limited
    values, and there is no need for them to change very often, we are comfortable
    with defining them as types. The following listing shows creating of our `industry_type`
    and `tin_type`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据几个因素（公司政策、团队成员、应用程序、数据库等），可能更倾向于将值存储在另一个表中，而不是在数据库中定义类型，以避免数据库变更请求。由于我们的值有限，而且它们不需要经常更改，所以我们很乐意将它们定义为类型。以下列表显示了我们的`industry_type`和`tin_type`的创建。
- en: Listing 10.2  The `industry_type` and `tin_type`
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2  `industry_type`和`tin_type`
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As shown, creating a type to store values is simple. Another concern we may
    have—which is also a reason why team members may argue for using separate tables—is
    the ability to extract the list of valid values (e.g., if we wanted to build a
    dynamic drop-down of the valid values for the `tin_type` on the UI side). The
    following listing shows how to extract the labels for an `ENUM` type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，创建一个存储值的类型很简单。我们可能关心的另一个问题——这也是团队成员可能争论使用单独表的原因——是提取有效值列表的能力（例如，如果我们想在 UI
    端构建 `tin_type` 的动态下拉列表）。以下列表显示了如何提取 `ENUM` 类型的标签。
- en: Listing 10.3  Returning the labels for an `ENUM` in Postgres
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3  在 Postgres 中返回 `ENUM` 的标签
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Returns the label for our ENUM'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 返回我们的 ENUM 的标签'
- en: '#2 Postgres tables needed to return the ENUM label'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 需要返回 ENUM 标签的 Postgres 表'
- en: '#3 The specific ENUM type we are interested in'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们感兴趣的特定 ENUM 类型'
- en: Once we have our company table in place, we can create an address table. It
    will show two addresses—the mailing and a street address—which we define with
    `address_type`. The rest of the table is standard in terms of what we need to
    store. We allow four lines for an address to cover apartment/floor numbers or
    additional information, plus other standard fields such as city, state, and zip.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了公司表，我们就可以创建一个地址表。它将显示两个地址——邮寄地址和街道地址——我们使用 `address_type` 来定义。表中的其余部分在需要存储的内容方面是标准的。我们允许地址有四行，以覆盖公寓/楼层编号或其他信息，以及城市、州和邮政编码等标准字段。
- en: Listing 10.4  The `address_type` and table
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4  `address_type` 及其表
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Defines possible mailing address types'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义可能的邮寄地址类型'
- en: '#2 This record is tied to the company, so a foreign key is defined.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 此记录与公司相关联，因此定义了外键。'
- en: '#3 Defaults the address_type to a mailing address'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 默认地址类型为邮寄地址'
- en: '#4 Standard address lines with room for department or floor numbers'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 标准地址行，留有部门或楼层编号的空间'
- en: '#5 Standard address lines'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 标准地址行'
- en: '#6 Fields that can help with auditing'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 可帮助审计的字段'
- en: '#7 Prevents more than one type of address for a company by defining a primary
    key that also uses the address_type'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 通过定义一个同时使用地址类型的唯一主键来防止公司有超过一个地址'
- en: We also created a table named `company_phone` to store phone numbers for the
    company. Again, we define a `phone_type` to identify different categories of phones.
    We also define a primary key of the company and phone type so that each company
    can have only one type of phone defined. Another restriction is to have unique
    `phone_number` and `extension` so that a phone number cannot be reused.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为 `company_phone` 的表来存储公司的电话号码。同样，我们定义了一个 `phone_type` 来标识不同的电话类别。我们还定义了公司和电话类型的唯一主键，以便每个公司只能定义一种电话类型。另一个限制是确保
    `phone_number` 和 `extension` 的唯一性，以便电话号码不能被重复使用。
- en: Listing 10.5  The `company_phone` type and table
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5  `company_phone` 类型及其表
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Defines possible values for types of phones'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了电话类型的可能值'
- en: '#2 The table is associated with the company table with a foreign key.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 该表通过外键与公司表相关联。'
- en: '#3 Phone number fields'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 电话号码字段'
- en: '#4 Audit fields'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 审计字段'
- en: '#5 Prevents having more than one type of phone per company'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 防止每个公司有超过一种电话类型'
- en: '#6 Prevents more than one phone number from being used'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 防止使用超过一个电话号码'
- en: We should now have more than enough database structure to support companies
    in our ACH dashboard. Much of this information is not strictly necessary when
    working with ACH files, but the additional information will be useful for expanding
    our project with different functionality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有足够的数据库结构来支持我们在 ACH 仪表板中的公司。当处理 ACH 文件时，其中大部分信息并非绝对必要，但额外的信息将有助于我们扩展项目以实现不同的功能。
- en: 10.2.2 Using generative AI to generate mock data
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 使用生成式 AI 生成模拟数据
- en: 'We can use generative AI to help boost our productivity by creating some test
    data for our companies. Using the industries we defined for our SQL type `industry_type`,
    we can instruct ChatGPT to do the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成式 AI 通过为我们的公司创建一些测试数据来帮助我们提高生产力。使用我们为 SQL 类型 `industry_type` 定义的行业，我们可以指示
    ChatGPT 执行以下操作：
- en: '**![image](../Images/Prompt-Icon.png)** Given this list of industries “''basic
    materials,’ . . . ''utilities’,” create fake company names, address information,
    and logos for each industry.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](../Images/Prompt-Icon.png)** 给定以下行业列表“‘基础材料’，……‘公用事业’”，为每个行业创建虚假的公司名称、地址信息和标志。'
- en: 'We were provided with company names such as Elemental Resource Inc. with the
    address of 123 Mineral Lane, Boulder, CO 80301\. We also asked for randomly generated
    EIN and DUNS numbers. It is also possible to see whether ChatGPT can share with
    us any interesting phone numbers that we can include in our data. For instance,
    here are two amusing ones if you have anyone on your team who likes Phil Collins
    or Hall and Oates:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了公司名称，例如Elemental Resource Inc.，地址为123 Mineral Lane，Boulder，CO 80301。我们还要求随机生成的EIN和DUNS号码。也有可能看到ChatGPT能否与我们分享一些有趣的电话号码，我们可以将其包含在我们的数据中。例如，如果你团队里有喜欢Phil
    Collins或Hall and Oates的人，这里有两个有趣的号码：
- en: 424-888-PHIL (7445), known as the Phil Call-Ins Hotline, where you can listen
    to songs from Phil Collins.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 424-888-PHIL (7445)，被称为Phil Call-Ins热线，在这里你可以听到Phil Collins的歌曲。
- en: 719-266-OATES (2837), known as the Callin Oates Hotline, where you can listen
    to a variety of songs from Hall and Oates.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 719-266-OATES (2837)，被称为Callin Oates热线，在这里你可以听到Hall and Oates的各种歌曲。
- en: While having some fun test data can brighten our day, we need to get all that
    data incorporated into SQL as well. Up until this point, we have been keeping
    all our SQL in the init.sql in the Dockerfile to create tables and data. With
    the need to input the generated company data, we want to do a bit of restructuring.
    We create a subfolder named `sql` and move all the `SQL` commands that currently
    exist in init.sql, while breaking them up into different files. It should be easier
    now to manage and update our SQL as necessary. The following listing shows the
    new structure of our Docker folders.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些有趣的测试数据可以让我们的日子变得愉快，但我们还需要将这些数据全部整合到SQL中。到目前为止，我们一直将所有SQL保存在Dockerfile中的init.sql中，以创建表和数据。由于需要输入生成的公司数据，我们想要进行一些结构调整。我们创建了一个名为`sql`的子文件夹，并将目前存在于init.sql中的所有`SQL`命令移动到该文件夹中，同时将它们拆分成不同的文件。现在应该更容易管理和更新我们的SQL，根据需要。以下列表显示了我们的Docker文件夹的新结构。
- en: Listing 10.6  Docker folder structure for the database
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6  数据库的Docker文件夹结构
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we update init.sql so that it references the new files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新init.sql文件，使其引用新的文件。
- en: Listing 10.7  Updating the init.sql file
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7  更新init.sql文件
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Includes the creation of tables'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 包括创建表的操作。'
- en: '#2 Includes general ACH data such as exception information'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 包括一般的ACH数据，如异常信息。'
- en: '#3 Each company can be stored in its own file.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 每家公司可以存储在自己的文件中。'
- en: Each company is added with the following SQL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每家公司都使用以下SQL语句添加。
- en: Listing 10.8  Adding a company
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8  添加公司
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Creates a variable saved_uuid as we need it for the other inserts to satisfy
    the foreign key constraint'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建一个名为saved_uuid的变量，因为我们需要在其他插入操作中用它来满足外键约束。'
- en: '#2 Uses a CTE to insert the company'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用CTE（公用表表达式）来插入公司。'
- en: '#3 Inserts a record with our test data'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 插入包含我们的测试数据的记录。'
- en: '#4 Returns the company_id assigned by the database'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 返回数据库分配的company_id。'
- en: '#5 Uses our CTE to save the company_id into our saved_uuid'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用我们的CTE将company_id保存到我们的saved_uuid中。'
- en: '#6 Inserts the address using the stored company ID'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用存储的公司ID插入地址。'
- en: '#7 Inserts the phone using the stored company ID'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 使用存储的公司ID插入电话。'
- en: We can tell ChatGPT to use the previous listing as a template to insert the
    company data it generated previously. Having ChatGPT generate some of this setup
    code makes it easier to get some default companies added to the database. We certainly
    could have done it ourselves, but it would have been somewhat tedious and error
    prone as we copied/pasted the data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以告诉ChatGPT使用之前的列表作为模板来插入它之前生成的公司数据。让ChatGPT生成一些这样的设置代码，使得将一些默认公司添加到数据库中变得更容易。我们当然可以自己完成它，但这会有些繁琐且容易出错，因为我们复制/粘贴了数据。
- en: 10.2.3 API design
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 API设计
- en: We start with a simple unit test with a new twist to ensure that we can get
    a `200` `HTTP` response code, which will indicate we are reaching the endpoint
    successfully. As we have seen, we have default companies that are loaded into
    the database when our container is started. Typically, we have been clearing our
    database for each test using `SqlUtils().truncate_all(),` and if we wanted to
    avoid truncating a table, we would need to update that method to exclude that
    particular table. Running our tests in this fashion also required the containers
    to be up and running.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的单元测试开始，加入一些新变化以确保我们可以得到`200` `HTTP`响应码，这将表明我们已成功到达端点。正如我们所见，当我们的容器启动时，我们默认的公司会被加载到数据库中。通常，我们会在每次测试中使用`SqlUtils().truncate_all()`来清空我们的数据库，如果我们想避免截断某个表，我们需要更新那个方法以排除那个特定的表。以这种方式运行我们的测试也要求容器处于运行状态。
- en: We will now create a test that uses Testcontainers to start and stop our containers
    so that we receive a fresh database every time. This makes the test self-contained,
    which is perfect for when we must move our project into a CI/CD environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个测试，使用 Testcontainers 启动和停止我们的容器，以便每次都能收到一个新的数据库。这使得测试自包含，这对于我们必须将项目移入
    CI/CD 环境来说非常完美。
- en: Listing 10.9  Initial unit test with Testcontainers
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9  使用 Testcontainers 的初始单元测试
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Defines a fixture to make test calls'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个用于测试调用的工具'
- en: '#2 Defines the container using Docker Compose because we have been using it
    throughout the project. Everything is set up as expected.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用 Docker Compose 定义容器，因为我们一直在整个项目中使用它。一切如预期设置。'
- en: '#3 Defines an IP address for our record'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义了我们记录的 IP 地址'
- en: '#4 Defines a test that validates we return successfully; further validation
    can be done for the response as well.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义了一个测试，验证我们是否成功返回；还可以对响应进行进一步验证。'
- en: We now have a way to run tests in an isolated environment. The more we isolate
    our tests and keep them self-contained, the easier it will be for the rest of
    the team to run them in their own environment. That way, we can avoid the WOMM
    (Works on My Machine) problems—a common theme in software development.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种在隔离环境中运行测试的方法。我们越能隔离测试并保持其自包含，其他团队成员在自己的环境中运行它们就会越容易。这样，我们可以避免“在我的机器上工作”（WOMM）问题——这是软件开发中一个常见的主题。
- en: We now follow the same formula as for previous APIs. We first create a record
    that we can return and that contains some company information we will display
    as an overview. At this point, we just want to be able to display a list of companies
    that users can then drill down into. In the following listing, we define an enumeration
    for the `IndustryType`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在遵循与之前 API 相同的公式。我们首先创建一个可以返回的记录，其中包含我们将显示为概览的一些公司信息。在这个阶段，我们只想能够显示公司列表，用户可以进一步深入了解。在下面的列表中，我们定义了一个
    `IndustryType` 枚举。
- en: Listing 10.10  The `IndustryType` enumeration
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10  `IndustryType` 枚举
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We define a `CompanyOverviewRecord` as shown in the following listing. While
    you have seen most of this code before, we do include a regular expression to
    verify the image is a valid format for displaying on the page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `CompanyOverviewRecord`，如下面的列表所示。虽然你之前已经看到了大部分代码，但我们包括了一个正则表达式来验证图像是页面显示的有效格式。
- en: Listing 10.11  The `CompanyOverview` Record
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11  `CompanyOverview` 记录
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 We use the IndustryType to help with validation.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们使用 `IndustryType` 来帮助进行验证。'
- en: '#2 States that the logo should be Base64'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 声明标志应为 Base64 编码'
- en: '#3 Enforces the correct format with a regular expression'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用正则表达式强制执行正确的格式'
- en: Next, we create a class to handle any SQL calls dealing with companies. The
    following listing shows the simple `SELECT` statement using a `row_factory` of
    `class_row`. In such cases where we are simply returning the data and not performing
    data manipulation, we could also use the `dict_row` just as easily—the choice
    really depends on our application needs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个类来处理与公司相关的任何 SQL 调用。下面的列表显示了使用 `row_factory` 的简单 `SELECT` 语句 `class_row`。在这种情况下，我们只是返回数据而不进行数据操作，我们也可以同样容易地使用
    `dict_row`——选择实际上取决于我们的应用程序需求。
- en: Listing 10.12  `CompaniesSql` class
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12  `CompaniesSql` 类
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Retrieves the database connection and sets the row_factory to a class_row
    for the CompanyOverviewRecord'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取数据库连接并将 `row_factory` 设置为 `class_row` 以用于 `CompanyOverviewRecord`'
- en: '#2 Limits the fields we are returning; we prefer specific fields rather than
    “*”.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 限制我们返回的字段；我们更喜欢特定的字段而不是“*”。'
- en: '#3 Returns all records'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回所有记录'
- en: We are almost there! Now we need to add the endpoint. We have built the pieces
    starting from the bottom as we feel that makes things more reasonable as we develop
    the API. However, we could have started with defining the endpoint, drilling down
    to details of retrieving the data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！现在我们需要添加端点。我们从底部开始构建，因为我们觉得这样在开发 API 时会更合理。然而，我们也可以从定义端点开始，深入到检索数据的细节。
- en: Listing 10.13  Getting the endpoint for all companies
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13  获取所有公司的端点
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 We assign a prefix for all the endpoints.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们为所有端点分配一个前缀。'
- en: '#2 Standard documentation for the API'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 API 的标准文档'
- en: '#3 Our annotation to provide some audit information for the API'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们使用的注解为 API 提供一些审计信息'
- en: '#4 Defines the function and that it will return a list of CompanyOverviewRecords'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义了函数，它将返回一个 `CompanyOverviewRecords` 列表'
- en: '#5 The SQL call for getting all companies'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 获取所有公司的 SQL 调用'
- en: Finally, we only need to add the router to our main.py. We do a little refactoring
    to add the routers into an array and loop through them instead of having multiple
    `include_router` statements. The following listing shows the refactoring results.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要将路由器添加到我们的main.py中。我们进行了一些重构，将路由器添加到数组中并通过循环而不是多个`include_router`语句来处理。以下列表显示了重构的结果。
- en: Listing 10.14  Refactored `app.include_router`
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.14  重构`app.include_router`
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 Defines an array of routers'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义路由器数组'
- en: '#2 Loops through them and includes each of them, which prevents the somewhat
    redundant include_router statements'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历它们并将每个都包含在内，这防止了有些冗余的include_router语句'
- en: With that, we have a passing test, but we should not stop here. It is important
    to validate the data being returned as well, not only that we received a valid
    response code of `200`. We should take a moment to think about what else needs
    to be validated to feel confident in publishing the code with a passing test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们通过了测试，但不应止步于此。验证返回的数据同样重要，而不仅仅是收到有效的响应代码`200`。我们应该花点时间思考还需要验证什么，以便在通过测试后自信地发布代码。
- en: In this case, we could receive a `200`-response code but not receive any companies.
    If the database has been populated with company data, should we check whether
    those company names exist? Or maybe there is a subset of those companies? We only
    want to drive home the point that the purpose of testing is to have confidence
    in the code we have written. Even if we do not intend to publish our code to production
    after successful automated testing, having a test suite that covers and tests
    our code so thoroughly that we feel confident in publishing it is a valuable goal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会收到`200`响应代码，但没有收到任何公司。如果数据库已经填充了公司数据，我们应该检查这些公司名称是否存在？或者可能是一部分这些公司？我们只想强调测试的目的是对所编写的代码有信心。即使我们无意在成功自动测试后发布代码到生产环境，拥有一个覆盖并彻底测试我们代码的测试套件，使我们能够自信地发布它，也是一个有价值的目标。
- en: On the side note, in addition to the ability to read companies from the database,
    for a fully functioning dashboard, we also need the ability to add, update, and
    delete. This would be a great time to take a break from reading, pull down one
    of the project versions, and get busy with some full stack development!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，除了从数据库中读取公司的能力外，对于一个完全功能的仪表板，我们还需要添加、更新和删除的能力。这将是休息一下、拉取项目的一个版本、忙于一些全栈开发的好时机！
- en: 10.2.4 User interface
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 用户界面
- en: The first step in creating the user interface is to add a button to NavButtons.tsx
    so that we can navigate to the new page. Finding an appropriate icon should be
    the hardest part of this process. Luckily, Material UI has more than enough icons
    to choose from.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户界面的第一步是在NavButtons.tsx中添加一个按钮，以便我们可以导航到新页面。找到合适的图标应该是这个过程中最困难的部分。幸运的是，Material
    UI提供了足够多的图标供选择。
- en: Listing 10.15  NavButtons.tsx
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.15  NavButtons.tsx
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 When the navigation button is clicked, we navigate to the companies page.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当导航按钮被点击时，我们导航到公司页面。'
- en: '#2 Defines the icon to display'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义要显示的图标'
- en: '#3 Sets the text to Companies'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 设置文本为“公司”'
- en: When navigating to the company page, there will be a list of companies provided.
    We use the same pattern as for other pages. The page.tsx makes the API call retrieve
    the information about the companies, and we pass it to another component that
    does the actual work to display it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航到公司页面时，将提供公司列表。我们使用与其他页面相同的模式。page.tsx调用API检索公司信息，并将其传递给另一个组件以实际显示它。
- en: Listing 10.16  The `CompanyListing` page
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.16  `CompanyListing`页面
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 Defines a function for the page'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义页面函数'
- en: '#2 Variable to store the companies; defaulted to an empty array'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 存储公司的变量；默认为空数组'
- en: '#3 The URL for the API; defaults to an empty string when the environment variable
    is not defined'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 API的URL；当环境变量未定义时默认为空字符串'
- en: '#4 API call'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 API调用'
- en: '#5 When the response is successful, sets the companies from the response data'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 当响应成功时，从响应数据中设置公司'
- en: '#6 Passes the companies down to the CompaniesListing'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 将公司传递给CompaniesListing'
- en: The `CompaniesListing` component, shown in the following listing, adds several
    new items that we have not used. The `onRowClick` for the DataGrid element allows
    us to click anywhere on the row and navigate to details about that company and
    the row height property so that we can see the company images a bit better. We
    also created an `ImageBase64` to encapsulate some of the needed pieces to display
    an image.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中显示的 `CompaniesListing` 组件添加了几个我们没有使用的新项目。DataGrid 元素的 `onRowClick` 允许我们在行的任何地方点击并导航到该公司的详细信息，以及行高属性，这样我们可以更好地查看公司图像。我们还创建了一个
    `ImageBase64` 来封装显示图像所需的一些组件。
- en: Listing 10.17  The `CompanyListing` component
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.17  `CompanyListing` 组件
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 Defines the properties for this component'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义此组件的属性'
- en: '#2 The function defines the properties as Readonly.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 函数将属性定义为 Readonly。'
- en: '#3 Obtains a router object so that we can navigate as necessary'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 获取一个路由对象，以便我们可以按需导航'
- en: '#4 Columns definitions for the DataGrid'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 DataGrid 的列定义'
- en: '#5 An image element that can display the company logo'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 一个可以显示公司标志的图像元素'
- en: '#6 Defines the row click method that executes when a row is clicked and takes
    us to the company dashboard'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 定义当行被点击时执行的行点击方法，并带我们到公司仪表板'
- en: '#7 Uses onRowClick to handle the user clicking a row on the DataGrid'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 使用 onRowClick 处理用户在 DataGrid 中点击行'
- en: The `ImageBase64` is straightforward—we have a routine to ensure that the image
    is in the correct format, as seen in the following listing. This allows us to
    perform validation, and we return an empty string if we do not have a correctly
    formatted string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageBase64` 很简单——我们有一个程序来确保图像处于正确的格式，如下面的列表所示。这允许我们执行验证，如果没有正确格式的字符串，我们返回一个空字符串。'
- en: Listing 10.18  `Base64` image
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.18  `Base64` 图像
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 A function to ensure we have a src string formatted correctly to display
    the image in the source tag. If not, we return an empty string, which will display
    the alt tags for the image.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一个函数，确保我们有一个格式正确的 src 字符串以在源标签中显示图像。如果没有，我们返回一个空字符串，这将显示图像的 alt 标签。'
- en: '#2 Defines the component to allow for multiple properties and default values
    if they are not passed'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义组件以允许有多个属性和默认值，如果未传递则使用默认值'
- en: '#3 Assigns the result of the function call to isBase64Image to imageSource'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将函数调用的结果分配给 isBase64Image 并赋值给 imageSource'
- en: '#4 There is no img component; instead, the appropriate parameters are passed
    to a Box element.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 没有img组件；相反，适当的参数传递给一个 Box 元素。'
- en: We could certainly have just used a `Box` element in our component or page,
    but wrapping the element and treating it as its own component has some benefits.
    We can use this tactic in multiple areas and enforce consistency throughout the
    code. Having a dedicated `ImageBase64` may be a too specific. We could create
    a more general element and pass a type to it that determines the type of `src`
    we are using and performs the necessary validation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以在我们的组件或页面上直接使用 `Box` 元素，但将元素包装并作为其自身的组件处理有一些好处。我们可以在多个区域使用这种策略，并在整个代码中强制一致性。拥有一个专门的
    `ImageBase64` 可能过于具体。我们可以创建一个更通用的元素，并传递一个类型给它，该类型确定我们使用的 `src` 类型并执行必要的验证。
- en: At this point, we have the database structure to store company information and
    the APIs to access the information about the company. We have also created a component
    capable of listing our companies, as shown in figure 10.2
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了存储公司信息的数据库结构和访问公司信息的 API。我们还创建了一个能够列出我们公司的组件，如图 10.2 所示。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH10_F02_Kardell.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](../Images/CH10_F02_Kardell.png)'
- en: Figure 10.2  Component for listing the companies
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2  列出公司的组件
- en: Now that we can view the companies in our database, we begin putting our company
    dashboard together.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在数据库中查看公司，我们开始组装我们的公司仪表板。
- en: 10.3 Company dashboard
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 公司仪表板
- en: With a way to navigate to a listing of companies in place, we want to be able
    to display a company-level dashboard. This feature will allow us to create a few
    other components that—although not necessarily unique to companies (we could incorporate
    versions of these components at the file level)—can provide information specific
    to companies and present other directions for our application to grow.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了导航到公司列表的方法之后，我们希望能够显示一个公司级别的仪表板。这个功能将允许我们创建一些其他组件——尽管这些组件不一定仅针对公司（我们可以在文件级别集成这些组件的版本）——可以提供特定于公司的信息，并为我们的应用程序的增长提供其他方向。
- en: 10.3.1 Navigation for the company dashboard
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a way to view all the companies, we want to be able to drill down and get
    to the company dashboard. The structure required to support the company listing
    and dashboard is shown in listing 10.19.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.19  UI structure for companies
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 This page will contain the company specific dashboard; the [companyID] will
    be the UUID of the company.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This is the page that displays the company listing shown in figure 10.2.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: With the page structure set up, we only need to create an empty dashboard page
    that can be populated with the company-specific components. We can use our file-level
    dashboard as a template.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.20  Empty company dashboard
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Gets the Company ID from the URL; this is possible because of the file-based
    routing being used and the directory we defined as [companyId].'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Stores the company'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Retrieves the company details'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Placeholder for the dashboard to verify navigation'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: While we can now navigate to the dashboard and retrieve company details, the
    dashboard is a little barren. However, before we can start creating dashboard
    components, we need ACH batches for the companies. The next section shows how
    to produce ACH files with company-specific data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2 Creating ACH files for our companies
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already created BDD-style tests to generate ACH files for our dashboard.
    Thankfully, we can use the same code to create files specifically for our companies.
    The following listing shows a sample scenario we wrote to create a test file for
    building the company dashboard. We used ChatGPT only for getting some original
    names that might be appropriate for the company’s customers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.21  Creating a file for Elemental Resources Inc.
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we only have to ensure that our company name is not too long as this could
    offset the record. In our original code, we made sure that the field itself was
    padded out to 16 characters when too short. Now, we have the opposite problem
    where we entered a field with 22 characters. The following listing shows a simple
    piece of code that can be used to truncate the company name.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.22  Truncating and padding the company name
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It may be tempting to go through the code and find all those areas that look
    like they should be truncating strings as well. If you go down that route, make
    sure to leave enough time for testing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: To fix or not to fix?
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We encountered similar production problems before and had to make the call on
    whether we needed to expand the scope of the story (e.g., where an invalid amount
    was reported on a particular field). The user story was originally written to
    fix the single field reported as incorrect; however, after researching the problem
    and finding the root cause, it was discovered that the problematic pattern was
    used in several other places in the program. Due to the problem causing invalid
    data being sent to a third party, it was decided to update the story and expand
    the scope (i.e., increase the story points) so that the problem could be addressed
    in full.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: With company data and specific company ACH files loaded into the database, we
    can start building the dashboard.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Company Information component
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component we want to build is a screen with more details about the
    company. These will only be some additional details that can be edited as needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We create the required `Pydantic` class, which is used to return the data. We
    are returning more information in the `CompanyDetailRecord` than we need to display
    because the data will also be passed to a form where all the data will be updateable.
    The following listing shows the `CompanyDetailRecord` where we pass back the arrays
    of `Address` and `Phone` objects. The company has a one-to-many relationship for
    the `Address` and `Phone` types, so it is possible to have more than one row.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.23  The `CompanyDetailRecord` field
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 An array of Address objects used to store addresses for the company'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '#2 An array of Phone objects used to store phone numbers for the company'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Because the address and phone records are arrays, we find that building the
    `CompanyDetailRecord` is somewhat more complicated than our previous data retrievals.
    This is because, before, we used to simply pull a record from the database and
    map it to the object. Now, we have multiple rows from multiple tables that we
    need to handle.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: We could follow several approaches, but we want to stay with a single query
    like we did in the past. However, depending on our query design, this will potentially
    duplicate fields in the company table. Returning duplicated data is not the end
    of the world; however, it is an indicator that there is some room for improvement.
    After all, we have taken great pains not to carelessly return all fields by simply
    using an asterisk (which can result in returning fields we have no intention of
    using). The duplication may be of concern for performance reasons, as well as
    for causing confusion among developers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious, but for each address and phone number, the query in listing
    10.24 will return a row. So, if we have two addresses and three phone numbers,
    we will receive five rows from the query. Given the expected number of addresses
    and phone numbers, this is not extremely problematic at this point. We do have
    a relatively large amount of data being returned for the image, but as mentioned
    before, storing data as a `Base64`-encoded string was a matter of convenience.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we use `LEFT` `JOIN` as we have no guarantee that companies will
    have addresses or phones populated. Had we used `INNER` `JOIN`, companies would
    have required addresses and phone numbers to be returned by the query. While having
    company records without an address/phone is not likely, it is not impossible.
    Perhaps the initial record was set up but—for business reasons—the address was
    not populated (maybe there was no official documentation for their address), or
    perhaps, fields did not come over properly during a conversion or migration.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.24  Query to return company details
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 We organized selected fields by their respective tables, and these are from
    the companies table.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '#2 These fields are from the company address table.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '#3 These fields are from the company phone table.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '#4 We use a LEFT JOIN because records are not required to be in these tables.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Limiting our details by the company, with %s being a placeholder'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We have multiple rows and will need the application logic to ensure the duplicated
    data is not passed back. The following listing shows the full method to accomplish
    this. We must loop through each record and use a hash to ensure that `id` has
    not been encountered before.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.25  Returning company details
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Fetches all rows for our SQL query'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '#2 If no details are found, this is an error and is reported as such.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Sets up empty hashes to store our data'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Loops through each row that was returned'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Creates an Address object as necessary'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Creates a Phone object when we have a phone number not encountered before'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '#7 We can just reference the company fields from our first row.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Creates an array from our hash'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Creates an object using the company_data'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: While this code works as expected, we can also condense the resulting dataset
    by using more complicated SQL. We have explored CTE in Postgres in previous examples
    and can use some of the JSON processing available in Postgres as well. The tradeoff
    is that our SQL may become less portable, but JSON processing is available for
    other major databases, such as MySQL, with some slight modifications. The following
    listing shows the updated SQL.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.26  Getting company data using Postgres CTE
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#1 Uses the JSON_AGG and JSON_BUILD_OBJECT to create an array of addresses
    for the company'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses the company_addresses table'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Selects only the records for our company'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Groups the records by company_id'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Uses the JSON_AGG and JSON_BUILD_OBJECT to create an array of phones for
    the company'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Uses the JSON_AGG and'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: JSON_BUILD_OBJECT to create an array of phones for the company
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Uses COALESCE to return an empty JSON array when there are no records in
    the table'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The application becomes more streamlined, as shown in the following listing.
    We can use `**` to unpack the returned JSON into keyword arguments passed to their
    respective objects, thus creating a list of elements.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.27  Python code to return the data
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Loops through the data returned to create appropriate array'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Assigns them to the company_data hash'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a CompanyDetailRecord object using the hash we created'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Several factors should always be considered when choosing one path over another.
    This selection may depend on the application and data involved. Performing profiling
    on the application and doing `EXPLAIN` `ANALYZE` on the SQL queries are some of
    the ways to determine which method performs better. A human factor is also involved;
    it takes into consideration which version is clearer and easier to maintain. Either
    way, we can now retrieve and display customer data!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Company Information form challenge
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because we are prepopulating the company information, and completing a form
    covers much of the same material laid out in previous chapters, we believe this
    is another good opportunity to take a break and put together a form to display
    the company information. You may create something from scratch, find a template,
    or use generative AI to see if things can be done faster that way. Using generative
    AI is a good way to get started. Try feeding the SQL tables or interfaces defined
    for the fields to see whether it can generate the boilerplate code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: With a basic form in place, we move to a component showing recent company batches.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Recent Batches component
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we navigate to the company dashboard, we want to be able to get an idea
    of activity for the company. A great way to see the activity is listing the batches
    found for the company. Being able to pull batch information will require us to
    have some knowledge of the ACH layout for batches because we need to gather some
    information from both the batch header (type 5) and the batch control (type 8)
    records. Figure 10.3 shows an example of the component we will be building.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a company profile  Description automatically generated](../Images/CH10_F03_Kardell.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3  Recent company batches
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To build the Recent Batches component, we follow three easy steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Create an API endpoint in FastAPI.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the SQL query to gather the required data.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the returned data in a MUI DataGrid.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10.5.1 Implementing the recent batches API
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whereas we could build an endpoint that is related to other company functions,
    we will instead implement this function as a search. While doing so is certainly
    a preference for our individual approach, we feel that rather than having something
    such as `/companies/{company_id}/batches`, we will achieve more flexibility if
    we just create an endpoint similar to our transaction search from the previous
    chapter. Therefore, we create an endpoint of `/api/v1/files/batches/search` and
    use it. The following listing from the files.py generates our API endpoint.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.28  Batches search endpoint
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The endpoint should be straightforward by now. The `get_batches` routine follows
    a flow very similar to that in our transaction search. We support a few different
    search methods right from the get-go because we ignore the YAGNI principle from
    chapter 3\. While this is usually something we stay away from, rules are meant
    to be broken. Since this routine is based on the transaction search, it won’t
    take too much effort to code this up to make it available (of course, testing
    is another matter). The following listing shows the initial `get_batches` method.
    While these patterns will likely be useful in the future, for now, we are interested
    in when we do not match any of the previous patterns and will instead search using
    company’s UUID. Recall that when we are on the company dashboard, we have the
    company’s UUID in the URL. So, this will be easy to pass as a query parameter
    for the search.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.29  The `get_batches` method
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 We created the ability to search for batches using many different methods,
    even though we are only interested in searching by the UUID at this point.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The call for `_get_batches_using_company_uuid` is simple. As with our previous
    search queries, we have pulled the selection logic out of the query into a shared
    method since each of these search methods shares the same selection logic and
    only differs in how we filter the results.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the selection criteria are going to be the biggest and most important
    part of this search effort. The query needs to pull together a few different tables
    to build the search response. Listing 10.30 shows the SQL we used. Note that most
    of the tables are `INNER JOIN`s, but the companies table is using a `LEFT` `JOIN`
    because there is no guarantee that the company name exists in our database.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We know that ACH files can contain batches from companies that may or may not
    be our customers. Because it is entirely possible that our search results may
    return a batch for a specified company not defined in our database, the query
    may fail to return any results. We use the Postgres `COALESCE` command to pull
    the name from the company table. If that is `NULL`, we will use the record from
    the batch header and, finally, an empty string. The following listing shows the
    SQL query.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.30  SQL query
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '#1 We use the name as we have it in our database, as displayed on the batch
    header, or an empty string.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We use a LEFT JOIN but must use ON instead of USING since the fields we
    want to join are not named the same.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The results of our query are stored in the `BatchSearchResponse` object in api/batch_search_response.py
    and is a standard Pydantic data model that we will not elaborate on since we have
    defined a fair amount of these already.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 10.5.2 Displaying recent batches
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This UI component is simple and is responsible for making an API call to get
    data and display the results in a DataGrid. The main thing to consider is whether
    we truly want the component to be responsible for making the API call. We have
    changed our approach when handling different components. When multiple components
    are on a page and use similar data, we pass that data to the components to minimize
    server calls, hoping to reduce latency and provide a better UX. In this case,
    the data is specific to this component, so we keep everything contained in the
    component. We can envision that this may become problematic if we were to allow
    users customize components on the dashboard, but some redesign would be required,
    and we will cross that bridge once we get there.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.31 shows the basics of the UI component. We use the `renderCell`
    attribute of the MUI DataGrid to provide clickable View links that take a user
    directly to the file or batch. We also use the `formatCurrency` method whenever
    we need to format a currency. Also, note how we can use our search API with the
    parameter `companyId` that was passed in. So, in this case, the search is programmatically
    driven and not necessarily done via the user input like when searching for transactions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.31  The `RecentCompanyBatches` Component
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '#1 The useRouter enables the component to navigate to other pages.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Stores the search response'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses Axios to retrieve data from our endpoint'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Creates a hyperlink that allows us to navigate to the file containing the
    batch'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Creates a hyperlink that allows us to navigate directly to the batch'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Reuses our formatCurrency routine'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Passes the required fields to create our grid; we also need to specify an
    ID for the row because we do not have a field named ID.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can show users current activity for the company, which is very useful
    and provides an at-a-glance UX. If a customer were to call for ACH support, they
    are mostly likely calling about something that happened recently. Being able to
    quickly jump to a particular file is going to be important. The next component
    will provide another way to help customers stay on top of their ACH files.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Expected Files component
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful component for our company dashboard is a component that allows
    users to keep track of any expected ACH files for a company. A company may want
    a financial institution to process files on a set schedule, and if the particular
    file has not arrived, then someone needs to be alerted and follow up. For instance,
    if the financial institution’s customer expects to see their paycheck on the 15th,,
    then the bank better make sure it is processed before that date.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This component displays a simple list and an indicator of whether the file has
    been loaded. We will be using the filename as the basis for whether a file has
    been loaded. It is common for financial institutions, data centers, and similar
    to rely on naming conventions to help facilitate various checks and balances,
    so using a filename for our component is not a unique approach to our dashboard.
    Of course, we could also expand the conditions to match any other constraints
    that might be useful from an ACH perspective—whether it is the company ID or totals
    from the batch.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Although we are approaching this problem from the company perspective, it would
    also be incorporated from a more general perspective (e.g., a financial institution
    will also expect files on a set schedule). Figure 10.4 shows an example of the
    component.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH10_F04_Kardell.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4  Expected Files component
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We build the Expected Files component using the following steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Define the database table and type.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the API endpoint.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the data using a MUI DataGrid.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10.6.1 Storing expected files
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our database, we create another database table named `company_expected_files`
    to store a list of filenames. We also create a `SCHEDULE_TYPE` like before to
    limit the possible values in the field. The table will only be responsible for
    holding the data necessary to determine whether the file should be found. There
    may be cases where an external job would make the determination and update a flag
    in the table. That is not required in our case, and we can rely on the API call
    to return the additional flag.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The following listing shows the creation of the table and type. We also use
    the `last_file_date`, which has to be maintained to be adjusted. We need to revise
    our file-upload logic to update this field.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.32  Creating the type and table for expected files
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '#1 Although it is not required, we define a UUID that the record could be referenced
    by.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The key is actually the company and filename as we only want to have one
    filename per company.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: We take similar steps to populate the database with some data to see the component
    in action. Listing 10.33 shows the `INSERT` for the `company_expected_files` table.
    We can insert these records for each company by using a `SELECT` statement to
    select the `company_id` field based on the `tax_id_number` for the company. Remember
    that the `company_id` is set dynamically by the database when the record is inserted.
    We could also choose to insert the record with a known UUID, but using the preceding
    approach allows us to work with the data as we expect to see it in production
    and prepare ourselves for the times when we do not have the luxury of inserting
    a known field in our test.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.33  Inserting records into the expected files table
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#1 Gets the company_id by searching companies by the tax_id_number'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: With our database set up, we can now work on the logic that will power the `ExpectedFiles`
    component.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 10.6.2 Implementing the expected files API
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the data for expected files loaded into the database, we need to be able
    to retrieve it, and we also need to be able to update the `last_file_date` when
    a file is uploaded.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we did was start with a test to work on building the required
    SQL logic. Again, we utilized Testcontainers to run our `docker_compose` container
    for the duration of the test.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.34 shows the basic structure of our test file. As part of the test,
    we created a basic `CompanySearchSql` class to search for companies by their `tax_id_number`
    or `ach_company_id` number. The need for such a class is another result of the
    database dynamically assigning the UUID. To avoid scope creep, we only built enough
    functionality to get a single company, but it could easily be incorporated into
    a search page or company page so that when we have hundreds or thousands of customers,
    we do not have to page through them all.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.34  Test for the `ExpectedFilesSql` class
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 Uses Testcontainers and DockerCompose to build the container and start only
    the Postgres service. There is no need to start CloudBeaver for a temporary test.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures the container is started and stopped for our test'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses CompanySearchSql to get the company UUID'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Makes sure we actually find something'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Runs the SQL that we want to test'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Makes the necessary assertions to ensure the method worked'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: With our unit test in place, we are free to build the logic behind the `get_expected_files_for_company`.
    The `SQL` query creates two additional fields that are not stored directly in
    the database. These fields are a Boolean value for whether the file has been loaded
    and the `next_file_date`, which is the next time we expect to see the file according
    to the file’s schedule. For now, we do not consider filtering our results by the
    date simply because that makes testing a bit more difficult. So, we are returning
    all the data. This does not necessarily make sense for the component when the
    current objective is to show files that were expected today. However, it works
    well enough to demonstrate the intent of the functionality. We could expand this
    component or create a new one that shows files for the coming week, gets the number
    of files expected, and similar. The `SQL` query utilizes the `INTERVAL` function,
    which makes it easy to compute the given time interval. The following listing
    shows the `SQL` statement.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.35  SQL for the Expected Files component
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Uses a CTE to determine when the file is next expected'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Determines whether the file was loaded'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we revise the posting of a file to update the `last_file_date` and
    `updated_at` fields for the table. This approach works well for now—when expected
    files are loaded, the date will increment accordingly and everything will function
    normally. However, problems arise when files are not uploaded. Perhaps the expected
    file does not need to be loaded that day–maybe it was a company holiday. For that
    reason, many financial institutions do not process files on weekends. When a file
    is loaded on a Friday, it may be necessary to adjust the next expected day to
    Monday instead of a Saturday. Handling these edge cases or addressing our users’
    additional needs helps make our software more robust. The following listing shows
    the addition of updating the necessary dates for our expected files.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.36  Updating the dates for our expected files
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '#1 Once parsing of the file is completed, we can update the date.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The logic of updating the dates can be kept simple for now. The `updated_at`
    is just for audit purposes, and determining when the file was uploaded. The last
    time the file was uploaded was also at the time of the update, so we use the function
    `NOW` for both updates. The following listing shows the simple update logic used
    by the `update_last_file_date` mehod.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.37  Simple update logic
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#1 Updates the table to indicate the file has been uploaded'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Things would get more complicated if we wanted to always keep the last file
    date set to a Monday and the processing fell on a weekend. This is an important
    problem because financial institutions may not be open on the weekend (or federal
    holidays), and it may not be appropriate to process files on those days. We certainly
    do not want to be enjoying our Sunday afternoon only to have numerous alerts come
    in, showing the files are missing! The following listing assumes a daily interval,
    but we could easily change this dynamic as needed.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.38  Default to Monday as needed
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '#1 If the date falls on a Sunday or Saturday, adds the appropriate number of
    days to force it to Monday. Be aware that this does not work if Monday is a holiday
    and the financial institution is closed. That would take some additional effort.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: While we are not overly concerned about addressing the field `last_file_date`,
    we should begin to see some of the problems that may occur with scheduled tasks,
    especially when we must consider what happens when files are not loaded. It is
    unlikely that our application should have to directly address this, and—ironically
    enough—there may be another scheduled job that needs to run and clean the database.
    For now, we can retrieve the needed data from the database, so let’s proceed with
    creating the UI side of our component.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 10.6.3 Displaying the expected files
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heavy lifting should have been done on the backend. The UI component simply
    needs to display the information and an icon dependent on the `file_loaded` Boolean
    that is returned as part of the response. The most interesting part of the UI
    component (considering we have done this many times by now) is the ternary statement
    we use to decide whether to display a `TaskAlt` or a `RadioButtonUnchecked` icon.
    Otherwise, it is the typical flow of adding the component to the page.tsx and
    having the component retrieve the necessary data and display it in the DataGrid.
    The following listing shows the UI component.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.39  The `ExpectedFiles` component
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '#1 We use a ternary statement to determine which icon to display.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: That completes the expected files component. We started by defining the required
    database table and a custom type to support the scheduling of expected files.
    Then we created a unit test with Testcontainers so that we could get a fresh database
    for each run. This approach allowed us to work out the needed SQL to return the
    data required for our component. Finally, we called the API from our UI and formatted
    the data to display it to the user.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look to add another component that can help companies monitor and control
    suspicious activity with company limits.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Company Limits component
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This component is centered around proactive monitoring for the company. We would
    like the company to be able to set limits that would trigger alerts and possibly
    prevent transactions from being posted should those limits be hit. This can help
    companies identify and deal with transactions or activity that may be outside
    of normal behavior.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a credit card  Description automatically generated](../Images/CH10_F05_Kardell.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5  Company Limits component
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As a business, if you expect less than, say, $10,000 of debit activity in a
    day, and suddenly, there is a $15,000 batch being posted for your company, you
    likely want to be alerted about that activity. In principle, this is a straightforward
    component that lists totals for the day and compares them to a limit set by the
    company or the bank—functionality that needs to be built out in a future sprint.
    In practice, we need to handle alerting the customer, allowing for processing
    when the company is okay with exceeding the limit, and rejecting the file load
    otherwise. Figure 10.5 shows the Company Limits component we will be implementing.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'We work on creating this component using the following steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Create the database table.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the API endpoint.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the returned information
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to the user.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 10.7.1 Storing the company limits
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a new table to store limits for the company. As with previous tables,
    this table will use a foreign key that references the company ID from the companies
    table. Remember that the use of the foreign key helps us maintain referential
    integrity for the database. The `ON` `DELETE` `CASCADE` and `ON` `UPDATE` `CASCADE`
    will ensure the record is removed when the company is deleted or changed accordingly
    if updated. Not every company needs to have limits, so we will keep that in mind
    as we create queries which utilize this table.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.40  Company Limits table
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '#1 Keeping track of when records are created and updated can help with auditing.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: There are a few approaches to implementing this functionality, and we will use
    a basic one that can be expanded as needed. The basic approach will not require
    us to store the totals. Instead we rely on the API to gather the totals and determine
    whether they are exceeded. This means that our logic will be executed when the
    company dashboard is displayed and when the file has finished loading so that
    we can add an associated exception. Remember from chapter 8 that if we want to
    add an exception, we will have to add it to the database along with any recovery
    options if desired. The following listing shows how the general_ach_data.sql was
    updated to insert these records.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.41  Setting up the exception data
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#1 We can add a new exception code for our company limits condition.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '#2 It is helpful to provide the users with some guidance on what to do when
    an exception is encountered.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: We also set up the data for the company limits so that there is existing data
    in the database. The following listing shows the simple insertion into the database
    table.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.42  Inserting records for the company limit
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That should be all we need to get up and running with company limits. The next
    section will show you how to update APIs so that you can work with the table.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 10.7.2 Implementing the company limits API
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a minute to think about what we would like to accomplish with the company
    limits API. Of course, we need to be able to retrieve what the limits are set
    to, but we will also want to determine what the current totals are for the company
    and a Boolean flag to indicate whether the limits have been exceeded. As mentioned,
    when designing the database tables, we decided not to store the current totals
    for the debits and credits, although we certainly could have created those fields
    and updated them as we loaded them.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: A potential drawback in this case is that depending on when/where we decide
    to do this check, we may have limited ability to narrow down the problem for the
    user. We should take a moment to think about where the exception can be written.
    For example, we just added a check for the expected files right after the file
    was loaded. Should we put this check in the same place? That may be our first
    inclination since we just added similar code. However, by putting it there, we
    miss out on being able to identify which batch is responsible for causing the
    company limit to be exceeded as we do not access the record numbers at that point,
    and it makes it difficult to put the actual batch header on the exception. The
    following listing shows that we included the exception during the processing of
    the batch control record.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.43  Adding the exception
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '#1 Checks whether we exceeded the company limits'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Calls the insert_record method from AchExceptionsSql to insert the record'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '#3 This is our standard exception schema. It is the first time we actually
    use the ach_batch_id, although there are plenty of exceptions we need it for.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: We write out our new `COMPANY_LIMITS_EXCEEDED` exception when a file exceeds
    company limits. This means that we need to define the `CompanyLimitsSql` class
    and a method to determine whether the file exceeds the company limits. We can
    tell from the use of the method that it just needs to return a Boolean value to
    determine whether this causes an exception. The method itself is straightforward,
    with the usual getting of the connection running a SQL query and fetching the
    results. The following listing shows the method details.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.44  Determining whether a file exceeded company limits
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '#1 Creates a CTE to select the batch totals'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sums the credits and debits'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '#3 We only need to return something.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Selects the file and sums'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '#5 We want to return a Boolean, so the “is not None” helps us return True/False.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The previous listing helps us determine whether we need to write an exception,
    but we also need to define a method that will be used with the UI. This is similar
    to the previous SQL with the addition of the actual fields for the limits, the
    current totals, and flags indicating whether the limit was exceeded. We prefer
    to return explicit flags for the UI to use rather than have the UI rely on making
    the determination itself. The following listing shows the SQL used to return the
    required information for our `get_company_limits` method.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.45  Query for the totals, limits, and flags
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '#1 Returns the current debit/credit totals; defaulting to zero when no batches
    are found'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Returns flags to indicate whether limits have been exceeded'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: There is just some minor housekeeping to create the API endpoint and the class
    that holds the response for the UI, but there is plenty of existing code to reference
    for these tasks. In the next section, we finish adding the company limits to the
    dashboard.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 10.7.3 Displaying the company limits
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in figure 10.5, the component itself is straightforward as we are
    just trying to convey to the user in the simplest terms whether the limits have
    been exceeded. We do want to add a little more visual appeal to the component
    by displaying the amount as red when it exceeds the limit and green otherwise.
    The following listing shows the basics of setting this feature up.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.46  Company credits and debit limits
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '#1 Colors the field red when the field has been exceeded'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Colors the field green when the field is within range'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The other aspects of the UI for the company limits already fall into place because
    we are using the existing logic for exceptions. So, that means that the file is
    automatically flagged as having an exception when viewing the dashboard, and the
    exception is returned to the DataGrid when viewing the exceptions. This does bring
    up a problem with viewing the exception for this company limit. We see the ACH
    batch control record (type 8), but we cannot easily tell which company it was
    dealing with. Even though we did save the batch header UUID as part of creating
    the exception, this was the first time we ever used it. It would be nice to update
    our code to include some batch header information when viewing an exception. Let’s
    use this opportunity to make a few changes to the exceptions and exception detail
    screens.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: First, the simplest change is to drop the column for the error code from the
    exceptions screen. From a developer’s perspective, this move makes sense, but
    it can be confusing and does not add any value to the UX, especially since end-users
    have the description the code translates to.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Next, the details for the exception consisted of only the unparsed record, which
    used a generic alert component we created for other purposes. Now that we have
    some experience in creating a modal to display details as we did with the audit
    details in chapter 9, we can use those skills to build a more detailed screen.
    We can work on displaying the details we already have (we can move the error code
    to this screen if we want), as well as information we have not used yet, such
    as the recovery action. Figure 10.6 shows the exception details modal we ended
    up with.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a computer screen  Description automatically generated](../Images/CH10_F06_Kardell.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6  Exception details modal
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `AchExceptionDetailsResponse` will have to be updated so that it returns
    the required information—the company name if available and a recovery action.
    If we have access to the records, there is certainly an opportunity to return
    a lot more information, but in the interest of bringing back the YAGNI principle
    (chapter 3), and as a reminder of KISS (Keep It Simple, Stupid), we only return
    what we need at the moment.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: The main work that we need to do is update the SQL statement for the `get_exception_detail_response`.
    We have to pull in extra tables to get the company name and recovery options.
    Keep in mind that we are not guaranteed to have recovery options nor are we guaranteed
    to have a company name. This means that we will want to avoid using an `INNER`
    `JOIN`. Instead, we will use a `LEFT` `JOIN` as in previous cases where we needed
    to keep the rows on one side of the query even when there were no matching records
    in the subsequent parts. The following listing shows the additional SQL logic
    that needs to be included. Note that since we have saved the parsed header record
    ID, we do not have to do a lot of joins to get to the record like in previous
    queries, where we had to start at the file level and drill down.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.47  Updates to get more exception details
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '#1 These fields are new to our query and select the company name if available
    and any recovery steps.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Joins the new tables. Again, we need to use LEFT JOIN because we are not
    guaranteed data will exist in tables.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: With the fields now included in our response, we can make the necessary updates
    to the UI to include them as well.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.48  Using the `ExceptionsModal`
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '#1 Includes the ExceptionsModal and the required parameters'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: The `ExceptionsModal` takes care of formatting the `exceptionData` and is based
    on what we did before for our `AuditModal` in chapter 9\. We will not display
    the company name with this component if it is an empty string, and we would like
    to provide a default recovery option of None Provided if no recovery options were
    available. Depending on the situation, it can often be beneficial to display a
    confirmation or message that validates this is an expected situation—sort of a
    21st-century “This page intentionally left blank” message. It may make sense not
    to include the company name if the problem is not directly dealing with a company
    (although a case could be made for referencing the batch for any entry exceptions
    as well). However, hiding the recovery options may make users think something
    has gone wrong, especially when they may depend on referring to recovery options.
    The following listing shows the basics of the modal. Since the query to return
    the exception detail uses the `COALESCE` function, we are guaranteed to return
    at the very least an empty string for the company name, so we use that knowledge
    to check whether the label and field should be displayed. In addition, we use
    `??` to default the recovery text when nothing has been provided.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.49  The `ExceptionsModal` Component
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '#1 Conditionally includes the company name if something was returned'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Always prints something for the recovery steps, even if it is just something
    to let users know they are on their own'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Only slight adjustments to the Exceptions component are necessary to ensure
    that data is passed properly to the new modal. The following listing shows the
    updated Exceptions component. The biggest change here is simply passing a function
    that will set the open state to `False` when the modal button is clicked.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.50  The Exceptions component
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '#1 No longer needed because it does not add anything useful for the user'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Includes the ExceptionsModal'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: So, we have now built a company dashboard that provides information that can
    ensure correct/desired files are loaded, show recent batches for the company,
    and send alerts when activity does not match the company’s expectations.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sprint planning in this chapter focused on building key components—company information,
    recent batches, expected files, and company limits—emphasizing the importance
    of comprehensive data-structure design.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A company-level dashboard was created to address the need for storing and displaying
    detailed company information beyond the initial project scope.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of building robust company data management systems that provide
    a framework for enhancing ACH-processing services for business customers who need
    detailed batch information was highlighted.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing foundational company information tables as blockers stressed their
    dependency on further development and the consideration of early work on some
    components to reduce modifications.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generative AI can help create meaningful test data quickly, which enhances productivity
    by generating more than typical name and address information, including logos.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a company dashboard demonstrated the necessity of organizing UI
    structures for efficient navigation and detailed data presentation for specific
    company metrics.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating detailed UI components for company overviews highlighted the value
    of user-friendly interfaces that facilitate seamless navigation and interaction
    at the company level.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an API for company data retrieval reinforced the importance of well-structured
    responses and validation mechanisms for dynamic user inter­action with dashboards.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing recent batch components highlighted the importance of flexible search
    functions for batch data retrieval to meet diverse business needs.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating expected file components stressed the need for alerting mechanisms
    and schedule compliance to ensure timely processing of crucial documents and mitigate
    risks.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proactive monitoring of ACH files was explored to shift from reactive to pro­active
    measures for improved customer service.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Company limit components emphasized configurable alerts and thresholds to safeguard
    against unauthorized or unexpected financial transactions.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding exception functionality, such as alert generation, can help us notify
    customers through various channels if limits are exceeded.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Testcontainers enhances testing reliability by ensuring isolated environments,
    eliminating dependency on developer-specific configurations, and allowing robust
    and portable tests.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
