- en: 10 Company information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 公司信息
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Adding functionality to support a company dashboard
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加支持公司仪表板的功能
- en: Adding a Company Information component
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加公司信息组件
- en: Adding a Recent ACH Batches component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加最近ACH批次组件
- en: Adding an Expected Files component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加预期文件组件
- en: Adding a Company Limits component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加公司限制组件
- en: This chapter looks at another iteration during our program increment. The business
    had previously mapped out the additional functionality regarding the storing and
    displaying of company information. Basically, the business is now requesting a
    dashboard at the company level. In addition, users have provided some input on
    additional functionality they would like to see implemented, which was not in
    the original scope of the project, and the business has asked us to include it
    as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节探讨了我们在程序增量过程中的另一个迭代。业务部门之前已经规划了关于存储和显示公司信息的附加功能。基本上，业务部门现在要求一个公司级别的仪表板。此外，用户还提供了一些关于他们希望看到实施的附加功能的反馈，这些功能最初不在项目范围内，业务部门要求我们也将其包括在内。
- en: 10.1 Sprint planning
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 赛跑计划
- en: 'In this sprint, we create a dashboard that focuses on data at the company level.
    In addition to tables and APIs, there are four additional components that our
    team must create during this sprint:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次赛跑中，我们创建了一个关注公司层面数据的仪表板。除了表格和API之外，我们的团队在此期间必须创建以下四个额外组件：
- en: Company information
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司信息
- en: Recent batches
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近批次
- en: Expected files
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期文件
- en: Company limits
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司限制
- en: The company information tables are identified as blockers in our sprint because
    they must be designed and built before working on the components. It may be possible
    to start with some other components with little to no rework, as many of the tables
    for enhancements—such as the Expected Files component—only have a foreign key
    requirement back to the company ID. In such situations, it may be okay to start
    working without the foreign key, but other changes such as displaying customer
    information will require tables built to a certain extent. Figure 10.1 shows the
    Gantt chart created using PlantUML.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 公司信息表在我们的赛跑中被识别为阻碍因素，因为它们必须在开始构建组件之前设计和构建。可能有可能从一些其他组件开始，几乎不需要重做，因为许多增强功能的表——如预期文件组件——只需要回到公司ID的外键要求。在这种情况下，可能可以开始工作而不需要外键，但其他更改，如显示客户信息，将需要构建到一定程度的表。图10.1显示了使用PlantUML创建的甘特图。
- en: '![](../Images/CH10_F01_Kardell.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F01_Kardell.png)'
- en: Figure 10.1  ACH dashboard enhancement timeline
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1 ACH仪表板增强时间线
- en: 10.2 Company Information
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 公司信息
- en: As stated previously, this sprint is all about working with companies. Each
    ACH file consists of batches with various entry and addenda records. These batches
    are associated with companies. If the companies are customers of our financial
    institution, we have an opportunity to provide various reports and controls around
    them. It is important to understand that the batches are not necessarily from
    companies associated with our institution—they may be from another company or
    partners we work with to deliver transactions to the institution. The company
    dashboard and components we build for it will provide additional ACH-processing
    services to our customers. While these components can be indispensable to the
    company as they provide the potential for additional auditing, alerts, and controls,
    they are not part of the ACH standard.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这次赛跑完全是关于与公司合作。每个ACH文件都包含各种条目和附加记录的批次。这些批次与公司相关联。如果这些公司是我们金融机构的客户，我们就有机会提供各种关于它们的报告和控制。重要的是要理解，这些批次不一定来自与我们机构相关的公司——它们可能来自其他公司或我们与之合作的伙伴，以将交易交付给机构。我们为该仪表板构建的公司仪表板和组件将为我们的客户提供额外的ACH处理服务。虽然这些组件对公司来说可能不可或缺，因为它们提供了额外的审计、警报和控制的可能性，但它们并不是ACH标准的一部分。
- en: We have to create database tables and APIs to support storing and accessing
    the company information in our database. The companies are business customers
    of our financial institution, and as such, we want to provide them with additional
    information and controls of ACH files that are beyond what may be typically needed
    for a personal customer. For instance, processing ACH batches for our personal
    customers usually results in posting paychecks and other prearranged payments
    or debits. From an individual’s perspective, there is no interest in the batch
    information and statistics except that the resulting transaction within the batch
    posts to their account correctly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建数据库表和API来支持在数据库中存储和访问公司信息。这些公司是我们金融机构的商业客户，因此我们希望为他们提供超出通常可能需要的个人客户之外的信息和控制ACH文件。例如，为我们个人客户处理ACH批次通常会导致发布工资和其他预先安排的支付或借记。从个人的角度来看，除了批次内的交易正确记入其账户之外，他们对批次信息和统计数据没有兴趣。
- en: If we contrast that to business customers (companies), they may very well be
    interested in the batch information because they will be able to tell the totals
    for all transactions within the batch. Similar to personal customers managing
    their account balances for individual transactions, companies need to be aware
    of all the transactions within the batch because they affect the company.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此与商业客户（公司）进行对比，他们可能非常关注批次信息，因为他们将能够知道批次内所有交易的总额。与个人客户管理单个交易的账户余额类似，公司需要了解批次内的所有交易，因为这些交易会影响公司。
- en: While we may receive and process ACH batches from companies that are not customers
    of our financial institution, in cases where they are, we want to provide additional
    details about the batch. By creating database tables for these companies, we also
    open the possibility to originate files in addition to receiving files to process,
    as we have been doing throughout the project. Originating ACH files is beyond
    the scope of the current development, but it is something that we could look at
    to enhance our project as a logical next step in building a fully functional ACH
    system. We will be populating our company tables with dummy data to give ourselves
    something to work with throughout the chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可能会从不是我们金融机构客户的公司接收和处理ACH批次，但在他们是客户的情况下，我们希望提供关于批次的额外详细信息。通过为这些公司创建数据库表，我们也打开了除了接收要处理的文件外，还可以生成文件的可能性，正如我们在整个项目中一直在做的那样。生成ACH文件超出了当前开发的范围，但它是我们可以考虑的，以增强我们的项目，作为构建一个完全功能的ACH系统的逻辑下一步。我们将用虚拟数据填充我们的公司表，以便我们在本章中有所作为。
- en: '10.2.1 Database design: Company information'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 数据库设计：公司信息
- en: In addition to the `audit_log` in chapter 9 (listing 9.20) and the `bank_routing_numbers`
    table in chapter 8, we had to add many tables that were not specifically ACH related.
    With supporting company information, we now get to add a few more tables and supporting
    types. First, it makes sense to start with the company table and see what we need
    to keep track of.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第9章（列表9.20）中的`audit_log`和第8章中的`bank_routing_numbers`表之外，我们不得不添加许多与ACH无关的表。有了支持公司信息，我们现在可以添加更多表和支持类型。首先，从公司表开始，看看我们需要跟踪什么是有意义的。
- en: Listing 10.1 introduces a couple of custom types into our database. For both
    the `tax_id_type` and `industry` fields, we created new custom types to provide
    some validation and assist with data entry. These custom types help enforce the
    values of data we expect to be present in the field, which prevents entering erroneous
    data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1向我们的数据库中引入了几种自定义类型。对于`tax_id_type`和`industry`字段，我们创建了新的自定义类型以提供一些验证并协助数据录入。这些自定义类型有助于强制执行我们期望在字段中存在的数据值，从而防止输入错误数据。
- en: The `tax_id_type` and `tax_id_number` are correalted because in the United States,
    there is more than just the Social Security Number (SSN) that individuals are
    assigned, such as Employer Identification Number (EIN) and Individual Tax Identification
    Number (ITIN) just to name a few. So, we give the field a more general name instead
    of simply calling it `ssn` or `ein`. We default to `EIN` because companies are
    more likely to use an EIN number.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`tax_id_type`和`tax_id_number`是相关的，因为在美利坚合众国，个人被分配的不仅仅是社会保险号（SSN），例如雇主识别号（EIN）和个人税务识别号（ITIN）等。因此，我们给字段一个更通用的名字，而不是简单地称之为`ssn`或`ein`。我们默认为`EIN`，因为公司更有可能使用EIN号码。'
- en: The `industry` is used for reporting purposes so that various reporting and
    marketing campaigns can filter out industries when users wish to drill down or
    create reports based on industries. The `logo` field is used to store an image
    for the company so that the image can be loaded onto the company page as necessary
    and only serves to make the pages and reporting a bit nicer. We use a new type
    `BYTEA`, which can store binary data. While we would benefit from having the logo
    stored outside the database in terms of UI performance, being able to keep things
    within the database prevents us from having to introduce other technologies such
    as AWS S3 or a CDN.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`行业`字段用于报告目的，以便各种报告和营销活动可以在用户希望按行业钻取或创建报告时过滤行业。`logo`字段用于存储公司的图像，以便在需要时将图像加载到公司页面上，并且仅用于使页面和报告看起来更美观。我们使用了一种新的类型`BYTEA`，可以存储二进制数据。虽然将标志存储在数据库外对于UI性能会有所帮助，但能够将所有内容保持在数据库中可以防止我们引入其他技术，如AWS
    S3或CDN。'
- en: Listing 10.1 shows the `create` `table` statement. The `ach_company_id` is used
    to identify the company within ACH. This field corresponds to the company identification
    field on the batch header record (type 5) in an ACH system. While it is common
    to use the EIN number or some variation of it, using it is not obligatory. We
    only need to keep in mind that the field is 10 positions long and should be padded
    with leading zeros when the file is created to maintain file formatting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1显示了`create` `table`语句。`ach_company_id`用于在ACH中识别公司。此字段对应于ACH系统中批量头记录（类型5）上的公司识别字段。虽然通常使用EIN号码或其变体，但使用它不是强制性的。我们只需要记住该字段长度为10位，在创建文件时应使用前导零进行填充，以保持文件格式。
- en: Listing 10.1  Table to store company details
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1  存储公司详情的表
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 Defines the tax_id_type with a default value of EIN since, most likely,
    this will be the type of value used'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了具有默认值EIN的`tax_id_type`，因为，很可能是将使用这种类型的值'
- en: '#2 The company identification number used on the ACH type 5 record (batch header)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在ACH类型5记录（批量头）上使用的公司识别号'
- en: '#3 Many companies have a DUNS number, required for many services when registering
    as a company.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 许多公司有一个DUNS号码，在作为公司注册时，许多服务都需要这个号码。'
- en: '#4 We store the logo as BYTEA so that we can upload an image to the database.
    Typically, this is a URL for the location where the image is stored. Storing it
    in our database was only for convenience.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 我们将标志存储为BYTEA，这样我们就可以将图像上传到数据库。通常，这是一个存储图像位置的URL。将图像存储在我们的数据库中只是为了方便。'
- en: The custom types in the previous listing need to be defined before creating
    the table. Creating the types is a straightforward process, and having these custom
    types helps us with an additional level of validation for the database and fields.
    The approach of course can vary, depending on our application’s needs. For instance,
    it would also be acceptable to store these as strings in the database, or perhaps
    as a numeric value, while having the labels stored in another location.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列表中的自定义类型需要在创建表之前定义。创建类型是一个简单的过程，并且拥有这些自定义类型可以帮助我们在数据库和字段上增加一个额外的验证级别。当然，这种方法可以根据我们的应用程序需求而变化。例如，将这些值作为字符串存储在数据库中，或者可能作为数值存储，同时将标签存储在另一个位置，这也是可以接受的。
- en: Depending on several factors (company policy, team members, application, database,
    etc.) it may be preferable to store the values in another table rather than defining
    a type in the database to avoid database change requests. Since we have limited
    values, and there is no need for them to change very often, we are comfortable
    with defining them as types. The following listing shows creating of our `industry_type`
    and `tin_type`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据几个因素（公司政策、团队成员、应用程序、数据库等），可能更倾向于将值存储在另一个表中，而不是在数据库中定义类型，以避免数据库变更请求。由于我们的值有限，而且它们不需要经常更改，所以我们很乐意将它们定义为类型。以下列表显示了我们的`industry_type`和`tin_type`的创建。
- en: Listing 10.2  The `industry_type` and `tin_type`
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2  `industry_type`和`tin_type`
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As shown, creating a type to store values is simple. Another concern we may
    have—which is also a reason why team members may argue for using separate tables—is
    the ability to extract the list of valid values (e.g., if we wanted to build a
    dynamic drop-down of the valid values for the `tin_type` on the UI side). The
    following listing shows how to extract the labels for an `ENUM` type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，创建一个存储值的类型很简单。我们可能关心的另一个问题——这也是团队成员可能争论使用单独表的原因——是提取有效值列表的能力（例如，如果我们想在 UI
    端构建 `tin_type` 的动态下拉列表）。以下列表显示了如何提取 `ENUM` 类型的标签。
- en: Listing 10.3  Returning the labels for an `ENUM` in Postgres
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3  在 Postgres 中返回 `ENUM` 的标签
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Returns the label for our ENUM'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 返回我们的 ENUM 的标签'
- en: '#2 Postgres tables needed to return the ENUM label'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 需要返回 ENUM 标签的 Postgres 表'
- en: '#3 The specific ENUM type we are interested in'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们感兴趣的特定 ENUM 类型'
- en: Once we have our company table in place, we can create an address table. It
    will show two addresses—the mailing and a street address—which we define with
    `address_type`. The rest of the table is standard in terms of what we need to
    store. We allow four lines for an address to cover apartment/floor numbers or
    additional information, plus other standard fields such as city, state, and zip.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了公司表，我们就可以创建一个地址表。它将显示两个地址——邮寄地址和街道地址——我们使用 `address_type` 来定义。表中的其余部分在需要存储的内容方面是标准的。我们允许地址有四行，以覆盖公寓/楼层编号或其他信息，以及城市、州和邮政编码等标准字段。
- en: Listing 10.4  The `address_type` and table
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4  `address_type` 及其表
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Defines possible mailing address types'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义可能的邮寄地址类型'
- en: '#2 This record is tied to the company, so a foreign key is defined.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 此记录与公司相关联，因此定义了外键。'
- en: '#3 Defaults the address_type to a mailing address'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 默认地址类型为邮寄地址'
- en: '#4 Standard address lines with room for department or floor numbers'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 标准地址行，留有部门或楼层编号的空间'
- en: '#5 Standard address lines'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 标准地址行'
- en: '#6 Fields that can help with auditing'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 可帮助审计的字段'
- en: '#7 Prevents more than one type of address for a company by defining a primary
    key that also uses the address_type'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 通过定义一个同时使用地址类型的唯一主键来防止公司有超过一个地址'
- en: We also created a table named `company_phone` to store phone numbers for the
    company. Again, we define a `phone_type` to identify different categories of phones.
    We also define a primary key of the company and phone type so that each company
    can have only one type of phone defined. Another restriction is to have unique
    `phone_number` and `extension` so that a phone number cannot be reused.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为 `company_phone` 的表来存储公司的电话号码。同样，我们定义了一个 `phone_type` 来标识不同的电话类别。我们还定义了公司和电话类型的唯一主键，以便每个公司只能定义一种电话类型。另一个限制是确保
    `phone_number` 和 `extension` 的唯一性，以便电话号码不能被重复使用。
- en: Listing 10.5  The `company_phone` type and table
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5  `company_phone` 类型及其表
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Defines possible values for types of phones'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了电话类型的可能值'
- en: '#2 The table is associated with the company table with a foreign key.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 该表通过外键与公司表相关联。'
- en: '#3 Phone number fields'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 电话号码字段'
- en: '#4 Audit fields'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 审计字段'
- en: '#5 Prevents having more than one type of phone per company'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 防止每个公司有超过一种电话类型'
- en: '#6 Prevents more than one phone number from being used'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 防止使用超过一个电话号码'
- en: We should now have more than enough database structure to support companies
    in our ACH dashboard. Much of this information is not strictly necessary when
    working with ACH files, but the additional information will be useful for expanding
    our project with different functionality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有足够的数据库结构来支持我们在 ACH 仪表板中的公司。当处理 ACH 文件时，其中大部分信息并非绝对必要，但额外的信息将有助于我们扩展项目以实现不同的功能。
- en: 10.2.2 Using generative AI to generate mock data
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 使用生成式 AI 生成模拟数据
- en: 'We can use generative AI to help boost our productivity by creating some test
    data for our companies. Using the industries we defined for our SQL type `industry_type`,
    we can instruct ChatGPT to do the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成式 AI 通过为我们的公司创建一些测试数据来帮助我们提高生产力。使用我们为 SQL 类型 `industry_type` 定义的行业，我们可以指示
    ChatGPT 执行以下操作：
- en: '**![image](../Images/Prompt-Icon.png)** Given this list of industries “''basic
    materials,’ . . . ''utilities’,” create fake company names, address information,
    and logos for each industry.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](../Images/Prompt-Icon.png)** 给定以下行业列表“‘基础材料’，……‘公用事业’”，为每个行业创建虚假的公司名称、地址信息和标志。'
- en: 'We were provided with company names such as Elemental Resource Inc. with the
    address of 123 Mineral Lane, Boulder, CO 80301\. We also asked for randomly generated
    EIN and DUNS numbers. It is also possible to see whether ChatGPT can share with
    us any interesting phone numbers that we can include in our data. For instance,
    here are two amusing ones if you have anyone on your team who likes Phil Collins
    or Hall and Oates:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了公司名称，例如Elemental Resource Inc.，地址为123 Mineral Lane，Boulder，CO 80301。我们还要求随机生成的EIN和DUNS号码。也有可能看到ChatGPT能否与我们分享一些有趣的电话号码，我们可以将其包含在我们的数据中。例如，如果你团队里有喜欢Phil
    Collins或Hall and Oates的人，这里有两个有趣的号码：
- en: 424-888-PHIL (7445), known as the Phil Call-Ins Hotline, where you can listen
    to songs from Phil Collins.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 424-888-PHIL (7445)，被称为Phil Call-Ins热线，在这里你可以听到Phil Collins的歌曲。
- en: 719-266-OATES (2837), known as the Callin Oates Hotline, where you can listen
    to a variety of songs from Hall and Oates.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 719-266-OATES (2837)，被称为Callin Oates热线，在这里你可以听到Hall and Oates的各种歌曲。
- en: While having some fun test data can brighten our day, we need to get all that
    data incorporated into SQL as well. Up until this point, we have been keeping
    all our SQL in the init.sql in the Dockerfile to create tables and data. With
    the need to input the generated company data, we want to do a bit of restructuring.
    We create a subfolder named `sql` and move all the `SQL` commands that currently
    exist in init.sql, while breaking them up into different files. It should be easier
    now to manage and update our SQL as necessary. The following listing shows the
    new structure of our Docker folders.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些有趣的测试数据可以让我们的日子变得愉快，但我们还需要将这些数据全部整合到SQL中。到目前为止，我们一直将所有SQL保存在Dockerfile中的init.sql中，以创建表和数据。由于需要输入生成的公司数据，我们想要进行一些结构调整。我们创建了一个名为`sql`的子文件夹，并将目前存在于init.sql中的所有`SQL`命令移动到该文件夹中，同时将它们拆分成不同的文件。现在应该更容易管理和更新我们的SQL，根据需要。以下列表显示了我们的Docker文件夹的新结构。
- en: Listing 10.6  Docker folder structure for the database
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6  数据库的Docker文件夹结构
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we update init.sql so that it references the new files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新init.sql文件，使其引用新的文件。
- en: Listing 10.7  Updating the init.sql file
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7  更新init.sql文件
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Includes the creation of tables'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 包括创建表的操作。'
- en: '#2 Includes general ACH data such as exception information'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 包括一般的ACH数据，如异常信息。'
- en: '#3 Each company can be stored in its own file.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 每家公司可以存储在自己的文件中。'
- en: Each company is added with the following SQL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每家公司都使用以下SQL语句添加。
- en: Listing 10.8  Adding a company
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8  添加公司
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Creates a variable saved_uuid as we need it for the other inserts to satisfy
    the foreign key constraint'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建一个名为saved_uuid的变量，因为我们需要在其他插入操作中用它来满足外键约束。'
- en: '#2 Uses a CTE to insert the company'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用CTE（公用表表达式）来插入公司。'
- en: '#3 Inserts a record with our test data'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 插入包含我们的测试数据的记录。'
- en: '#4 Returns the company_id assigned by the database'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 返回数据库分配的company_id。'
- en: '#5 Uses our CTE to save the company_id into our saved_uuid'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用我们的CTE将company_id保存到我们的saved_uuid中。'
- en: '#6 Inserts the address using the stored company ID'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用存储的公司ID插入地址。'
- en: '#7 Inserts the phone using the stored company ID'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 使用存储的公司ID插入电话。'
- en: We can tell ChatGPT to use the previous listing as a template to insert the
    company data it generated previously. Having ChatGPT generate some of this setup
    code makes it easier to get some default companies added to the database. We certainly
    could have done it ourselves, but it would have been somewhat tedious and error
    prone as we copied/pasted the data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以告诉ChatGPT使用之前的列表作为模板来插入它之前生成的公司数据。让ChatGPT生成一些这样的设置代码，使得将一些默认公司添加到数据库中变得更容易。我们当然可以自己完成它，但这会有些繁琐且容易出错，因为我们复制/粘贴了数据。
- en: 10.2.3 API design
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 API设计
- en: We start with a simple unit test with a new twist to ensure that we can get
    a `200` `HTTP` response code, which will indicate we are reaching the endpoint
    successfully. As we have seen, we have default companies that are loaded into
    the database when our container is started. Typically, we have been clearing our
    database for each test using `SqlUtils().truncate_all(),` and if we wanted to
    avoid truncating a table, we would need to update that method to exclude that
    particular table. Running our tests in this fashion also required the containers
    to be up and running.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的单元测试开始，加入一些新变化以确保我们可以得到`200` `HTTP`响应码，这将表明我们已成功到达端点。正如我们所见，当我们的容器启动时，我们默认的公司会被加载到数据库中。通常，我们会在每次测试中使用`SqlUtils().truncate_all()`来清空我们的数据库，如果我们想避免截断某个表，我们需要更新那个方法以排除那个特定的表。以这种方式运行我们的测试也要求容器处于运行状态。
- en: We will now create a test that uses Testcontainers to start and stop our containers
    so that we receive a fresh database every time. This makes the test self-contained,
    which is perfect for when we must move our project into a CI/CD environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个测试，使用 Testcontainers 启动和停止我们的容器，以便每次都能收到一个新的数据库。这使得测试自包含，这对于我们必须将项目移入
    CI/CD 环境来说非常完美。
- en: Listing 10.9  Initial unit test with Testcontainers
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9  使用 Testcontainers 的初始单元测试
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Defines a fixture to make test calls'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个用于测试调用的工具'
- en: '#2 Defines the container using Docker Compose because we have been using it
    throughout the project. Everything is set up as expected.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用 Docker Compose 定义容器，因为我们一直在整个项目中使用它。一切如预期设置。'
- en: '#3 Defines an IP address for our record'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义了我们记录的 IP 地址'
- en: '#4 Defines a test that validates we return successfully; further validation
    can be done for the response as well.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义了一个测试，验证我们是否成功返回；还可以对响应进行进一步验证。'
- en: We now have a way to run tests in an isolated environment. The more we isolate
    our tests and keep them self-contained, the easier it will be for the rest of
    the team to run them in their own environment. That way, we can avoid the WOMM
    (Works on My Machine) problems—a common theme in software development.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种在隔离环境中运行测试的方法。我们越能隔离测试并保持其自包含，其他团队成员在自己的环境中运行它们就会越容易。这样，我们可以避免“在我的机器上工作”（WOMM）问题——这是软件开发中一个常见的主题。
- en: We now follow the same formula as for previous APIs. We first create a record
    that we can return and that contains some company information we will display
    as an overview. At this point, we just want to be able to display a list of companies
    that users can then drill down into. In the following listing, we define an enumeration
    for the `IndustryType`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在遵循与之前 API 相同的公式。我们首先创建一个可以返回的记录，其中包含我们将显示为概览的一些公司信息。在这个阶段，我们只想能够显示公司列表，用户可以进一步深入了解。在下面的列表中，我们定义了一个
    `IndustryType` 枚举。
- en: Listing 10.10  The `IndustryType` enumeration
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10  `IndustryType` 枚举
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We define a `CompanyOverviewRecord` as shown in the following listing. While
    you have seen most of this code before, we do include a regular expression to
    verify the image is a valid format for displaying on the page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `CompanyOverviewRecord`，如下面的列表所示。虽然你之前已经看到了大部分代码，但我们包括了一个正则表达式来验证图像是页面显示的有效格式。
- en: Listing 10.11  The `CompanyOverview` Record
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11  `CompanyOverview` 记录
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 We use the IndustryType to help with validation.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们使用 `IndustryType` 来帮助进行验证。'
- en: '#2 States that the logo should be Base64'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 声明标志应为 Base64 编码'
- en: '#3 Enforces the correct format with a regular expression'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用正则表达式强制执行正确的格式'
- en: Next, we create a class to handle any SQL calls dealing with companies. The
    following listing shows the simple `SELECT` statement using a `row_factory` of
    `class_row`. In such cases where we are simply returning the data and not performing
    data manipulation, we could also use the `dict_row` just as easily—the choice
    really depends on our application needs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个类来处理与公司相关的任何 SQL 调用。下面的列表显示了使用 `row_factory` 的简单 `SELECT` 语句 `class_row`。在这种情况下，我们只是返回数据而不进行数据操作，我们也可以同样容易地使用
    `dict_row`——选择实际上取决于我们的应用程序需求。
- en: Listing 10.12  `CompaniesSql` class
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12  `CompaniesSql` 类
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Retrieves the database connection and sets the row_factory to a class_row
    for the CompanyOverviewRecord'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取数据库连接并将 `row_factory` 设置为 `class_row` 以用于 `CompanyOverviewRecord`'
- en: '#2 Limits the fields we are returning; we prefer specific fields rather than
    “*”.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 限制我们返回的字段；我们更喜欢特定的字段而不是“*”。'
- en: '#3 Returns all records'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回所有记录'
- en: We are almost there! Now we need to add the endpoint. We have built the pieces
    starting from the bottom as we feel that makes things more reasonable as we develop
    the API. However, we could have started with defining the endpoint, drilling down
    to details of retrieving the data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！现在我们需要添加端点。我们从底部开始构建，因为我们觉得这样在开发 API 时会更合理。然而，我们也可以从定义端点开始，深入到检索数据的细节。
- en: Listing 10.13  Getting the endpoint for all companies
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13  获取所有公司的端点
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 We assign a prefix for all the endpoints.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们为所有端点分配一个前缀。'
- en: '#2 Standard documentation for the API'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 API 的标准文档'
- en: '#3 Our annotation to provide some audit information for the API'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们使用的注解为 API 提供一些审计信息'
- en: '#4 Defines the function and that it will return a list of CompanyOverviewRecords'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义了函数，它将返回一个 `CompanyOverviewRecords` 列表'
- en: '#5 The SQL call for getting all companies'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 获取所有公司的 SQL 调用'
- en: Finally, we only need to add the router to our main.py. We do a little refactoring
    to add the routers into an array and loop through them instead of having multiple
    `include_router` statements. The following listing shows the refactoring results.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要将路由器添加到我们的main.py中。我们进行了一些重构，将路由器添加到数组中并通过循环而不是多个`include_router`语句来处理。以下列表显示了重构的结果。
- en: Listing 10.14  Refactored `app.include_router`
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.14  重构`app.include_router`
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 Defines an array of routers'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义路由器数组'
- en: '#2 Loops through them and includes each of them, which prevents the somewhat
    redundant include_router statements'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历它们并将每个都包含在内，这防止了有些冗余的include_router语句'
- en: With that, we have a passing test, but we should not stop here. It is important
    to validate the data being returned as well, not only that we received a valid
    response code of `200`. We should take a moment to think about what else needs
    to be validated to feel confident in publishing the code with a passing test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们通过了测试，但不应止步于此。验证返回的数据同样重要，而不仅仅是收到有效的响应代码`200`。我们应该花点时间思考还需要验证什么，以便在通过测试后自信地发布代码。
- en: In this case, we could receive a `200`-response code but not receive any companies.
    If the database has been populated with company data, should we check whether
    those company names exist? Or maybe there is a subset of those companies? We only
    want to drive home the point that the purpose of testing is to have confidence
    in the code we have written. Even if we do not intend to publish our code to production
    after successful automated testing, having a test suite that covers and tests
    our code so thoroughly that we feel confident in publishing it is a valuable goal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会收到`200`响应代码，但没有收到任何公司。如果数据库已经填充了公司数据，我们应该检查这些公司名称是否存在？或者可能是一部分这些公司？我们只想强调测试的目的是对所编写的代码有信心。即使我们无意在成功自动测试后发布代码到生产环境，拥有一个覆盖并彻底测试我们代码的测试套件，使我们能够自信地发布它，也是一个有价值的目标。
- en: On the side note, in addition to the ability to read companies from the database,
    for a fully functioning dashboard, we also need the ability to add, update, and
    delete. This would be a great time to take a break from reading, pull down one
    of the project versions, and get busy with some full stack development!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，除了从数据库中读取公司的能力外，对于一个完全功能的仪表板，我们还需要添加、更新和删除的能力。这将是休息一下、拉取项目的一个版本、忙于一些全栈开发的好时机！
- en: 10.2.4 User interface
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 用户界面
- en: The first step in creating the user interface is to add a button to NavButtons.tsx
    so that we can navigate to the new page. Finding an appropriate icon should be
    the hardest part of this process. Luckily, Material UI has more than enough icons
    to choose from.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户界面的第一步是在NavButtons.tsx中添加一个按钮，以便我们可以导航到新页面。找到合适的图标应该是这个过程中最困难的部分。幸运的是，Material
    UI提供了足够多的图标供选择。
- en: Listing 10.15  NavButtons.tsx
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.15  NavButtons.tsx
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 When the navigation button is clicked, we navigate to the companies page.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当导航按钮被点击时，我们导航到公司页面。'
- en: '#2 Defines the icon to display'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义要显示的图标'
- en: '#3 Sets the text to Companies'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 设置文本为“公司”'
- en: When navigating to the company page, there will be a list of companies provided.
    We use the same pattern as for other pages. The page.tsx makes the API call retrieve
    the information about the companies, and we pass it to another component that
    does the actual work to display it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航到公司页面时，将提供公司列表。我们使用与其他页面相同的模式。page.tsx调用API检索公司信息，并将其传递给另一个组件以实际显示它。
- en: Listing 10.16  The `CompanyListing` page
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.16  `CompanyListing`页面
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 Defines a function for the page'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义页面函数'
- en: '#2 Variable to store the companies; defaulted to an empty array'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 存储公司的变量；默认为空数组'
- en: '#3 The URL for the API; defaults to an empty string when the environment variable
    is not defined'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 API的URL；当环境变量未定义时默认为空字符串'
- en: '#4 API call'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 API调用'
- en: '#5 When the response is successful, sets the companies from the response data'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 当响应成功时，从响应数据中设置公司'
- en: '#6 Passes the companies down to the CompaniesListing'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 将公司传递给CompaniesListing'
- en: The `CompaniesListing` component, shown in the following listing, adds several
    new items that we have not used. The `onRowClick` for the DataGrid element allows
    us to click anywhere on the row and navigate to details about that company and
    the row height property so that we can see the company images a bit better. We
    also created an `ImageBase64` to encapsulate some of the needed pieces to display
    an image.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中显示的 `CompaniesListing` 组件添加了几个我们没有使用的新项目。DataGrid 元素的 `onRowClick` 允许我们在行的任何地方点击并导航到该公司的详细信息，以及行高属性，这样我们可以更好地查看公司图像。我们还创建了一个
    `ImageBase64` 来封装显示图像所需的一些组件。
- en: Listing 10.17  The `CompanyListing` component
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.17  `CompanyListing` 组件
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 Defines the properties for this component'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义此组件的属性'
- en: '#2 The function defines the properties as Readonly.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 函数将属性定义为 Readonly。'
- en: '#3 Obtains a router object so that we can navigate as necessary'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 获取一个路由对象，以便我们可以按需导航'
- en: '#4 Columns definitions for the DataGrid'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 DataGrid 的列定义'
- en: '#5 An image element that can display the company logo'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 一个可以显示公司标志的图像元素'
- en: '#6 Defines the row click method that executes when a row is clicked and takes
    us to the company dashboard'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 定义当行被点击时执行的行点击方法，并带我们到公司仪表板'
- en: '#7 Uses onRowClick to handle the user clicking a row on the DataGrid'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 使用 onRowClick 处理用户在 DataGrid 中点击行'
- en: The `ImageBase64` is straightforward—we have a routine to ensure that the image
    is in the correct format, as seen in the following listing. This allows us to
    perform validation, and we return an empty string if we do not have a correctly
    formatted string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageBase64` 很简单——我们有一个程序来确保图像处于正确的格式，如下面的列表所示。这允许我们执行验证，如果没有正确格式的字符串，我们返回一个空字符串。'
- en: Listing 10.18  `Base64` image
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.18  `Base64` 图像
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 A function to ensure we have a src string formatted correctly to display
    the image in the source tag. If not, we return an empty string, which will display
    the alt tags for the image.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一个函数，确保我们有一个格式正确的 src 字符串以在源标签中显示图像。如果没有，我们返回一个空字符串，这将显示图像的 alt 标签。'
- en: '#2 Defines the component to allow for multiple properties and default values
    if they are not passed'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义组件以允许有多个属性和默认值，如果未传递则使用默认值'
- en: '#3 Assigns the result of the function call to isBase64Image to imageSource'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将函数调用的结果分配给 isBase64Image 并赋值给 imageSource'
- en: '#4 There is no img component; instead, the appropriate parameters are passed
    to a Box element.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 没有img组件；相反，适当的参数传递给一个 Box 元素。'
- en: We could certainly have just used a `Box` element in our component or page,
    but wrapping the element and treating it as its own component has some benefits.
    We can use this tactic in multiple areas and enforce consistency throughout the
    code. Having a dedicated `ImageBase64` may be a too specific. We could create
    a more general element and pass a type to it that determines the type of `src`
    we are using and performs the necessary validation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以在我们的组件或页面上直接使用 `Box` 元素，但将元素包装并作为其自身的组件处理有一些好处。我们可以在多个区域使用这种策略，并在整个代码中强制一致性。拥有一个专门的
    `ImageBase64` 可能过于具体。我们可以创建一个更通用的元素，并传递一个类型给它，该类型确定我们使用的 `src` 类型并执行必要的验证。
- en: At this point, we have the database structure to store company information and
    the APIs to access the information about the company. We have also created a component
    capable of listing our companies, as shown in figure 10.2
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了存储公司信息的数据库结构和访问公司信息的 API。我们还创建了一个能够列出我们公司的组件，如图 10.2 所示。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH10_F02_Kardell.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](../Images/CH10_F02_Kardell.png)'
- en: Figure 10.2  Component for listing the companies
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2  列出公司的组件
- en: Now that we can view the companies in our database, we begin putting our company
    dashboard together.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在数据库中查看公司，我们开始组装我们的公司仪表板。
- en: 10.3 Company dashboard
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 公司仪表板
- en: With a way to navigate to a listing of companies in place, we want to be able
    to display a company-level dashboard. This feature will allow us to create a few
    other components that—although not necessarily unique to companies (we could incorporate
    versions of these components at the file level)—can provide information specific
    to companies and present other directions for our application to grow.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了导航到公司列表的方法之后，我们希望能够显示一个公司级别的仪表板。这个功能将允许我们创建一些其他组件——尽管这些组件不一定仅针对公司（我们可以在文件级别集成这些组件的版本）——可以提供特定于公司的信息，并为我们的应用程序的增长提供其他方向。
- en: 10.3.1 Navigation for the company dashboard
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 公司仪表板的导航
- en: With a way to view all the companies, we want to be able to drill down and get
    to the company dashboard. The structure required to support the company listing
    and dashboard is shown in listing 10.19.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看所有公司的方法，我们希望能够深入挖掘并到达公司仪表板。支持公司列表和仪表板的所需结构在列表 10.19 中显示。
- en: Listing 10.19  UI structure for companies
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.19  公司的 UI 结构
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 This page will contain the company specific dashboard; the [companyID] will
    be the UUID of the company.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 此页面将包含特定公司的仪表板；[companyID] 将是公司的 UUID。'
- en: '#2 This is the page that displays the company listing shown in figure 10.2.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是显示在图 10.2 中的公司列表页面。'
- en: With the page structure set up, we only need to create an empty dashboard page
    that can be populated with the company-specific components. We can use our file-level
    dashboard as a template.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面结构设置完成后，我们只需要创建一个空白的仪表板页面，该页面可以填充特定公司的组件。我们可以使用我们的文件级仪表板作为模板。
- en: Listing 10.20  Empty company dashboard
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.20  空公司仪表板
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Gets the Company ID from the URL; this is possible because of the file-based
    routing being used and the directory we defined as [companyId].'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从 URL 中获取公司 ID；这是由于我们使用的基于文件的路由和定义的 [companyId] 目录所实现的。'
- en: '#2 Stores the company'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 存储公司'
- en: '#3 Retrieves the company details'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 获取公司详细信息'
- en: '#4 Placeholder for the dashboard to verify navigation'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 仪表板占位符以验证导航'
- en: While we can now navigate to the dashboard and retrieve company details, the
    dashboard is a little barren. However, before we can start creating dashboard
    components, we need ACH batches for the companies. The next section shows how
    to produce ACH files with company-specific data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在可以导航到仪表板并获取公司详细信息，但仪表板略显空旷。然而，在我们开始创建仪表板组件之前，我们需要为公司准备 ACH 批次。下一节将展示如何使用公司特定数据生成
    ACH 文件。
- en: 10.3.2 Creating ACH files for our companies
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 为我们的公司创建 ACH 文件
- en: We have already created BDD-style tests to generate ACH files for our dashboard.
    Thankfully, we can use the same code to create files specifically for our companies.
    The following listing shows a sample scenario we wrote to create a test file for
    building the company dashboard. We used ChatGPT only for getting some original
    names that might be appropriate for the company’s customers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了用于生成仪表板 ACH 文件的 BDD 风格测试。幸运的是，我们可以使用相同的代码来为我们的公司创建特定文件。以下列表显示了我们编写的用于创建构建公司仪表板测试文件的示例场景。我们仅使用
    ChatGPT 获取一些可能适合公司客户的原始名称。
- en: Listing 10.21  Creating a file for Elemental Resources Inc.
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.21  为 Elemental Resources Inc. 创建文件
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we only have to ensure that our company name is not too long as this could
    offset the record. In our original code, we made sure that the field itself was
    padded out to 16 characters when too short. Now, we have the opposite problem
    where we entered a field with 22 characters. The following listing shows a simple
    piece of code that can be used to truncate the company name.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需确保我们的公司名称不要太长，因为这可能会影响记录。在我们的原始代码中，我们确保当字段太短时，该字段本身被填充到 16 个字符。现在，我们遇到了相反的问题，我们输入了一个
    22 个字符的字段。以下列表显示了一块简单的代码，可以用来截断公司名称。
- en: Listing 10.22  Truncating and padding the company name
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.22  截断和填充公司名称
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It may be tempting to go through the code and find all those areas that look
    like they should be truncating strings as well. If you go down that route, make
    sure to leave enough time for testing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱使你遍历代码并找到所有看起来应该截断字符串的区域。如果你选择这条路，请确保为测试留出足够的时间。
- en: To fix or not to fix?
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 是修复还是不修复？
- en: We encountered similar production problems before and had to make the call on
    whether we needed to expand the scope of the story (e.g., where an invalid amount
    was reported on a particular field). The user story was originally written to
    fix the single field reported as incorrect; however, after researching the problem
    and finding the root cause, it was discovered that the problematic pattern was
    used in several other places in the program. Due to the problem causing invalid
    data being sent to a third party, it was decided to update the story and expand
    the scope (i.e., increase the story points) so that the problem could be addressed
    in full.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前遇到过类似的生产问题，并不得不决定是否需要扩大故事的范围（例如，在特定字段上报告了无效金额）。用户故事最初是为了修复报告为错误的单个字段而编写的；然而，在研究问题和找到根本原因后，我们发现问题模式在程序的其他几个地方也被使用。由于导致向第三方发送无效数据的问题，我们决定更新故事并扩大范围（即增加故事点），以便全面解决问题。
- en: With company data and specific company ACH files loaded into the database, we
    can start building the dashboard.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将公司数据和特定的公司ACH文件加载到数据库后，我们可以开始构建仪表板。
- en: 10.4 Company Information component
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 公司信息组件
- en: The first component we want to build is a screen with more details about the
    company. These will only be some additional details that can be edited as needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要构建的第一个组件是一个包含更多公司详细信息的屏幕。这些信息将只是一些可以按需编辑的附加信息。
- en: We create the required `Pydantic` class, which is used to return the data. We
    are returning more information in the `CompanyDetailRecord` than we need to display
    because the data will also be passed to a form where all the data will be updateable.
    The following listing shows the `CompanyDetailRecord` where we pass back the arrays
    of `Address` and `Phone` objects. The company has a one-to-many relationship for
    the `Address` and `Phone` types, so it is possible to have more than one row.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了所需的`Pydantic`类，用于返回数据。我们在`CompanyDetailRecord`中返回比我们需要显示更多的信息，因为数据还将传递到一个所有数据都可以更新的表单中。以下列表显示了返回`Address`和`Phone`对象数组的`CompanyDetailRecord`。公司对于`Address`和`Phone`类型有一个一对多关系，因此可能有多行。
- en: Listing 10.23  The `CompanyDetailRecord` field
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.23  `CompanyDetailRecord`字段
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 An array of Address objects used to store addresses for the company'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用数组存储公司地址的Address对象'
- en: '#2 An array of Phone objects used to store phone numbers for the company'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用数组存储公司电话号码的Phone对象'
- en: Because the address and phone records are arrays, we find that building the
    `CompanyDetailRecord` is somewhat more complicated than our previous data retrievals.
    This is because, before, we used to simply pull a record from the database and
    map it to the object. Now, we have multiple rows from multiple tables that we
    need to handle.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地址和电话记录是数组，我们发现构建`CompanyDetailRecord`比我们之前的数据检索要复杂一些。这是因为，以前，我们只是从数据库中拉取一个记录并将其映射到对象。现在，我们需要处理来自多个表的多行数据。
- en: We could follow several approaches, but we want to stay with a single query
    like we did in the past. However, depending on our query design, this will potentially
    duplicate fields in the company table. Returning duplicated data is not the end
    of the world; however, it is an indicator that there is some room for improvement.
    After all, we have taken great pains not to carelessly return all fields by simply
    using an asterisk (which can result in returning fields we have no intention of
    using). The duplication may be of concern for performance reasons, as well as
    for causing confusion among developers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循几种方法，但我们希望保持与过去一样的单一查询。然而，根据我们的查询设计，这可能会在公司表中重复字段。返回重复数据并不是世界末日；然而，这是一个表明有改进空间的指标。毕竟，我们非常小心，没有简单地使用星号（这可能导致返回我们无意使用的字段）。重复数据可能会因为性能原因而引起关注，也可能导致开发人员之间的混淆。
- en: It may not be obvious, but for each address and phone number, the query in listing
    10.24 will return a row. So, if we have two addresses and three phone numbers,
    we will receive five rows from the query. Given the expected number of addresses
    and phone numbers, this is not extremely problematic at this point. We do have
    a relatively large amount of data being returned for the image, but as mentioned
    before, storing data as a `Base64`-encoded string was a matter of convenience.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能并不明显，但对于每个地址和电话号码，列表10.24中的查询将返回一行。因此，如果我们有两个地址和三个电话号码，我们将从查询中接收到五行。考虑到预期的地址和电话号码数量，这一点在此阶段并不极端有问题。我们确实返回了相对大量的图像数据，但如前所述，将数据存储为`Base64`编码的字符串是出于方便考虑。
- en: Furthermore, we use `LEFT` `JOIN` as we have no guarantee that companies will
    have addresses or phones populated. Had we used `INNER` `JOIN`, companies would
    have required addresses and phone numbers to be returned by the query. While having
    company records without an address/phone is not likely, it is not impossible.
    Perhaps the initial record was set up but—for business reasons—the address was
    not populated (maybe there was no official documentation for their address), or
    perhaps, fields did not come over properly during a conversion or migration.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`LEFT JOIN`，因为我们无法保证公司会有地址或电话信息。如果我们使用`INNER JOIN`，公司需要查询返回地址和电话号码。虽然没有地址/电话的公司记录不太可能，但并非不可能。也许最初的记录已经设置好了，但由于商业原因，地址没有填写（可能没有官方的地址文件），或者也许在转换或迁移过程中，字段没有正确传输。
- en: Listing 10.24  Query to return company details
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.24  查询以返回公司详细信息
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 We organized selected fields by their respective tables, and these are from
    the companies table.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们根据各自的表组织了选定的字段，这些字段来自公司表。'
- en: '#2 These fields are from the company address table.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这些字段来自公司地址表。'
- en: '#3 These fields are from the company phone table.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这些字段来自公司电话表。'
- en: '#4 We use a LEFT JOIN because records are not required to be in these tables.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 我们使用LEFT JOIN，因为记录不需要在这些表中。'
- en: '#5 Limiting our details by the company, with %s being a placeholder'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 通过公司限制我们的详细信息，其中%s是一个占位符'
- en: We have multiple rows and will need the application logic to ensure the duplicated
    data is not passed back. The following listing shows the full method to accomplish
    this. We must loop through each record and use a hash to ensure that `id` has
    not been encountered before.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个行，需要应用逻辑来确保重复的数据不会被返回。以下列表显示了完成此任务的全方法。我们必须遍历每个记录，并使用哈希来确保`id`之前没有被遇到。
- en: Listing 10.25  Returning company details
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.25  返回公司详细信息
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Fetches all rows for our SQL query'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取我们SQL查询的所有行'
- en: '#2 If no details are found, this is an error and is reported as such.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果没有找到详细信息，这是一个错误，并以此方式报告。'
- en: '#3 Sets up empty hashes to store our data'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 设置空的哈希来存储我们的数据'
- en: '#4 Loops through each row that was returned'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 遍历返回的每一行'
- en: '#5 Creates an Address object as necessary'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 在需要时创建一个地址对象'
- en: '#6 Creates a Phone object when we have a phone number not encountered before'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 当我们遇到一个之前未遇到的电话号码时创建一个电话对象'
- en: '#7 We can just reference the company fields from our first row.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 我们可以直接引用第一行的公司字段。'
- en: '#8 Creates an array from our hash'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 从我们的哈希中创建一个数组'
- en: '#9 Creates an object using the company_data'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 使用公司数据创建一个对象'
- en: While this code works as expected, we can also condense the resulting dataset
    by using more complicated SQL. We have explored CTE in Postgres in previous examples
    and can use some of the JSON processing available in Postgres as well. The tradeoff
    is that our SQL may become less portable, but JSON processing is available for
    other major databases, such as MySQL, with some slight modifications. The following
    listing shows the updated SQL.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码按预期工作，但我们可以通过使用更复杂的SQL来压缩结果数据集。我们已经在之前的示例中探讨了Postgres中的CTE，并且可以使用Postgres中的一些JSON处理功能。权衡是，我们的SQL可能变得不太便携，但JSON处理在MySQL等主要数据库中也是可用的，只需稍作修改。以下列表显示了更新的SQL。
- en: Listing 10.26  Getting company data using Postgres CTE
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.26  使用Postgres CTE获取公司数据
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#1 Uses the JSON_AGG and JSON_BUILD_OBJECT to create an array of addresses
    for the company'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用`JSON_AGG`和`JSON_BUILD_OBJECT`创建公司的地址数组'
- en: '#2 Uses the company_addresses table'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用`company_addresses`表'
- en: '#3 Selects only the records for our company'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 仅选择我们公司的记录'
- en: '#4 Groups the records by company_id'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 按公司_id对记录进行分组'
- en: '#5 Uses the JSON_AGG and JSON_BUILD_OBJECT to create an array of phones for
    the company'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用`JSON_AGG`和`JSON_BUILD_OBJECT`创建公司的电话数组'
- en: '#6 Uses the JSON_AGG and'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用 JSON_AGG 和'
- en: JSON_BUILD_OBJECT to create an array of phones for the company
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: JSON_BUILD_OBJECT 创建公司的电话数组
- en: '#7 Uses COALESCE to return an empty JSON array when there are no records in
    the table'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 使用 COALESCE 在表中没有记录时返回一个空的 JSON 数组'
- en: The application becomes more streamlined, as shown in the following listing.
    We can use `**` to unpack the returned JSON into keyword arguments passed to their
    respective objects, thus creating a list of elements.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序变得更加流畅，如下面的列表所示。我们可以使用 `**` 将返回的 JSON 解包成传递给相应对象的键值参数，从而创建一个元素列表。
- en: Listing 10.27  Python code to return the data
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.27 返回数据的 Python 代码
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Loops through the data returned to create appropriate array'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历返回的数据以创建适当的数组'
- en: '#2 Assigns them to the company_data hash'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将它们分配给 company_data 哈希'
- en: '#3 Creates a CompanyDetailRecord object using the hash we created'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用我们创建的哈希创建一个 CompanyDetailRecord 对象'
- en: Several factors should always be considered when choosing one path over another.
    This selection may depend on the application and data involved. Performing profiling
    on the application and doing `EXPLAIN` `ANALYZE` on the SQL queries are some of
    the ways to determine which method performs better. A human factor is also involved;
    it takes into consideration which version is clearer and easier to maintain. Either
    way, we can now retrieve and display customer data!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择一条路径而不是另一条路径时，应始终考虑几个因素。此选择可能取决于应用程序和数据。对应用程序进行配置文件分析以及在 SQL 查询上执行 `EXPLAIN`
    `ANALYZE` 是确定哪种方法表现更好的几种方法之一。还涉及人为因素；它考虑了哪个版本更清晰且更容易维护。无论如何，我们现在可以检索并显示客户数据！
- en: Company Information form challenge
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 公司信息表挑战
- en: Because we are prepopulating the company information, and completing a form
    covers much of the same material laid out in previous chapters, we believe this
    is another good opportunity to take a break and put together a form to display
    the company information. You may create something from scratch, find a template,
    or use generative AI to see if things can be done faster that way. Using generative
    AI is a good way to get started. Try feeding the SQL tables or interfaces defined
    for the fields to see whether it can generate the boilerplate code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在预填充公司信息，并且完成表单涵盖了之前章节中布置的大部分材料，我们认为这是另一个很好的机会停下来，制作一个表单来显示公司信息。你可以从头开始创建，找到一个模板，或者使用生成式
    AI 来看看是否可以通过这种方式更快地完成。使用生成式 AI 是一个很好的开始方式。尝试向 SQL 表或为字段定义的接口提供数据，看看它是否可以生成样板代码。
- en: With a basic form in place, we move to a component showing recent company batches.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本表单就位后，我们转向显示最近公司批次的组件。
- en: 10.5 Recent Batches component
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 最近批次组件
- en: When we navigate to the company dashboard, we want to be able to get an idea
    of activity for the company. A great way to see the activity is listing the batches
    found for the company. Being able to pull batch information will require us to
    have some knowledge of the ACH layout for batches because we need to gather some
    information from both the batch header (type 5) and the batch control (type 8)
    records. Figure 10.3 shows an example of the component we will be building.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导航到公司仪表板时，我们希望能够了解公司的活动情况。查看为公司找到的批次是一种很好的查看活动的方式。能够提取批次信息将需要我们了解 ACH 批次布局的某些知识，因为我们需要从批次标题（类型
    5）和批次控制（类型 8）记录中收集一些信息。图 10.3 显示了我们将要构建的组件示例。
- en: '![A screenshot of a company profile  Description automatically generated](../Images/CH10_F03_Kardell.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![公司简介截图  自动生成的描述](../Images/CH10_F03_Kardell.png)'
- en: Figure 10.3  Recent company batches
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3 最近公司批次
- en: 'To build the Recent Batches component, we follow three easy steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建最近批次组件，我们遵循三个简单的步骤：
- en: Create an API endpoint in FastAPI.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 FastAPI 中创建一个 API 端点。
- en: Write the SQL query to gather the required data.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 SQL 查询以收集所需数据。
- en: Display the returned data in a MUI DataGrid.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MUI DataGrid 中显示返回的数据。
- en: 10.5.1 Implementing the recent batches API
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 实现最近批次 API
- en: Whereas we could build an endpoint that is related to other company functions,
    we will instead implement this function as a search. While doing so is certainly
    a preference for our individual approach, we feel that rather than having something
    such as `/companies/{company_id}/batches`, we will achieve more flexibility if
    we just create an endpoint similar to our transaction search from the previous
    chapter. Therefore, we create an endpoint of `/api/v1/files/batches/search` and
    use it. The following listing from the files.py generates our API endpoint.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以构建一个与公司其他功能相关的端点，但我们将实现这个功能作为搜索。虽然这样做确实是我们个人方法的偏好，但我们认为，而不是有像`/companies/{company_id}/batches`这样的东西，如果我们只创建一个类似于上一章中交易搜索的端点，我们将获得更多的灵活性。因此，我们创建了一个`/api/v1/files/batches/search`的端点并使用它。下面的列表来自files.py生成了我们的API端点。
- en: Listing 10.28  Batches search endpoint
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.28 批次搜索端点
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The endpoint should be straightforward by now. The `get_batches` routine follows
    a flow very similar to that in our transaction search. We support a few different
    search methods right from the get-go because we ignore the YAGNI principle from
    chapter 3\. While this is usually something we stay away from, rules are meant
    to be broken. Since this routine is based on the transaction search, it won’t
    take too much effort to code this up to make it available (of course, testing
    is another matter). The following listing shows the initial `get_batches` method.
    While these patterns will likely be useful in the future, for now, we are interested
    in when we do not match any of the previous patterns and will instead search using
    company’s UUID. Recall that when we are on the company dashboard, we have the
    company’s UUID in the URL. So, this will be easy to pass as a query parameter
    for the search.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，端点应该是直接的。`get_batches`例程遵循与我们交易搜索中非常相似的流程。我们从一开始就支持几种不同的搜索方法，因为我们忽略了第3章中的YAGNI原则。虽然这通常是我们要避免的事情，但规则是为了被打破的。因为这个例程是基于交易搜索的，所以将其编码成可用形式不会花费太多精力（当然，测试又是另一回事）。下面的列表显示了初始的`get_batches`方法。虽然这些模式将来可能会很有用，但现在我们感兴趣的是当我们不匹配任何之前的模式时，我们将使用公司的UUID进行搜索。回想一下，当我们处于公司仪表板时，我们在URL中就有公司的UUID。所以，这将很容易作为查询参数传递给搜索。
- en: Listing 10.29  The `get_batches` method
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.29 `get_batches`方法
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 We created the ability to search for batches using many different methods,
    even though we are only interested in searching by the UUID at this point.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们创建了使用许多不同方法搜索批次的能力，尽管我们现在只对通过UUID进行搜索感兴趣。'
- en: The call for `_get_batches_using_company_uuid` is simple. As with our previous
    search queries, we have pulled the selection logic out of the query into a shared
    method since each of these search methods shares the same selection logic and
    only differs in how we filter the results.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对`_get_batches_using_company_uuid`的调用很简单。就像我们之前的搜索查询一样，我们已经将选择逻辑从查询中提取出来到一个共享方法中，因为每个这些搜索方法都共享相同的选择逻辑，只是在过滤结果的方式上有所不同。
- en: Of course, the selection criteria are going to be the biggest and most important
    part of this search effort. The query needs to pull together a few different tables
    to build the search response. Listing 10.30 shows the SQL we used. Note that most
    of the tables are `INNER JOIN`s, but the companies table is using a `LEFT` `JOIN`
    because there is no guarantee that the company name exists in our database.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，选择标准将是这次搜索工作的最大和最重要的部分。查询需要汇总几个不同的表来构建搜索响应。列表10.30显示了我们所使用的SQL语句。请注意，大多数表都是使用`INNER
    JOIN`，但公司表使用的是`LEFT JOIN`，因为无法保证公司名称存在于我们的数据库中。
- en: We know that ACH files can contain batches from companies that may or may not
    be our customers. Because it is entirely possible that our search results may
    return a batch for a specified company not defined in our database, the query
    may fail to return any results. We use the Postgres `COALESCE` command to pull
    the name from the company table. If that is `NULL`, we will use the record from
    the batch header and, finally, an empty string. The following listing shows the
    SQL query.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道ACH文件可以包含来自可能或可能不是我们客户的公司的批次。因为完全有可能我们的搜索结果可能返回一个指定公司未在我们的数据库中定义的批次，所以查询可能无法返回任何结果。我们使用Postgres的`COALESCE`命令从公司表中提取名称。如果它是`NULL`，我们将使用批次标题中的记录，最后是一个空字符串。下面的列表显示了SQL查询。
- en: Listing 10.30  SQL query
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.30 SQL查询
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '#1 We use the name as we have it in our database, as displayed on the batch
    header, or an empty string.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们使用我们在数据库中拥有的名称，就像在批次标题上显示的那样，或者一个空字符串。'
- en: '#2 We use a LEFT JOIN but must use ON instead of USING since the fields we
    want to join are not named the same.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们使用LEFT JOIN，但必须使用ON而不是USING，因为我们想要连接的字段名称并不相同。'
- en: The results of our query are stored in the `BatchSearchResponse` object in api/batch_search_response.py
    and is a standard Pydantic data model that we will not elaborate on since we have
    defined a fair amount of these already.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查询的结果存储在`api/batch_search_response.py`中的`BatchSearchResponse`对象中，它是一个标准的Pydantic数据模型，我们不会详细说明，因为我们已经定义了相当多的这些模型。
- en: 10.5.2 Displaying recent batches
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 显示最近批次
- en: This UI component is simple and is responsible for making an API call to get
    data and display the results in a DataGrid. The main thing to consider is whether
    we truly want the component to be responsible for making the API call. We have
    changed our approach when handling different components. When multiple components
    are on a page and use similar data, we pass that data to the components to minimize
    server calls, hoping to reduce latency and provide a better UX. In this case,
    the data is specific to this component, so we keep everything contained in the
    component. We can envision that this may become problematic if we were to allow
    users customize components on the dashboard, but some redesign would be required,
    and we will cross that bridge once we get there.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI组件很简单，负责通过API调用获取数据并在DataGrid中显示结果。需要考虑的主要问题是，我们是否真的希望组件负责进行API调用。我们在处理不同组件时改变了我们的方法。当多个组件在页面上并且使用相似的数据时，我们将数据传递给组件以最小化服务器调用，希望减少延迟并提供更好的用户体验。在这种情况下，数据是针对此组件的，所以我们保持所有内容都在组件中。我们可以设想，如果我们允许用户在仪表板上自定义组件，这可能会成为问题，但需要进行一些重新设计，我们将在到达那里时再解决。
- en: Listing 10.31 shows the basics of the UI component. We use the `renderCell`
    attribute of the MUI DataGrid to provide clickable View links that take a user
    directly to the file or batch. We also use the `formatCurrency` method whenever
    we need to format a currency. Also, note how we can use our search API with the
    parameter `companyId` that was passed in. So, in this case, the search is programmatically
    driven and not necessarily done via the user input like when searching for transactions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.31展示了UI组件的基本知识。我们使用MUI DataGrid的`renderCell`属性来提供可点击的视图链接，这些链接可以直接将用户带到文件或批次。我们还在需要格式化货币时使用`formatCurrency`方法。此外，请注意我们如何使用带有传递的`companyId`参数的我们的搜索API。因此，在这种情况下，搜索是由程序驱动的，而不是像搜索交易时那样通过用户输入来完成的。
- en: Listing 10.31  The `RecentCompanyBatches` Component
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.31  `RecentCompanyBatches`组件
- en: '[PRE30]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '#1 The useRouter enables the component to navigate to other pages.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `useRouter`使组件能够导航到其他页面。'
- en: '#2 Stores the search response'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 存储搜索响应'
- en: '#3 Uses Axios to retrieve data from our endpoint'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用Axios从我们的端点检索数据'
- en: '#4 Creates a hyperlink that allows us to navigate to the file containing the
    batch'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 创建一个超链接，允许我们导航到包含批次的文件'
- en: '#5 Creates a hyperlink that allows us to navigate directly to the batch'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 创建一个超链接，允许我们直接导航到批次'
- en: '#6 Reuses our formatCurrency routine'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 重复使用我们的`formatCurrency`程序'
- en: '#7 Passes the required fields to create our grid; we also need to specify an
    ID for the row because we do not have a field named ID.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 将所需字段传递给创建我们的网格；我们还需要指定行的ID，因为我们没有名为ID的字段。'
- en: Now, we can show users current activity for the company, which is very useful
    and provides an at-a-glance UX. If a customer were to call for ACH support, they
    are mostly likely calling about something that happened recently. Being able to
    quickly jump to a particular file is going to be important. The next component
    will provide another way to help customers stay on top of their ACH files.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向用户展示公司的当前活动，这非常有用，并提供了一个一目了然的用户体验。如果客户需要ACH支持，他们很可能是关于最近发生的事情。能够快速跳转到特定的文件将非常重要。下一个组件将提供另一种帮助客户跟踪他们的ACH文件的方法。
- en: 10.6 Expected Files component
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 预期文件组件
- en: Another useful component for our company dashboard is a component that allows
    users to keep track of any expected ACH files for a company. A company may want
    a financial institution to process files on a set schedule, and if the particular
    file has not arrived, then someone needs to be alerted and follow up. For instance,
    if the financial institution’s customer expects to see their paycheck on the 15th,,
    then the bank better make sure it is processed before that date.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公司仪表板中另一个有用的组件是允许用户跟踪公司任何预期ACH文件的组件。公司可能希望金融机构按照一定的日程安排处理文件，如果特定的文件没有到达，那么就需要有人被提醒并跟进。例如，如果金融机构的客户期望在15号看到他们的工资单，那么银行最好确保在那天之前处理完毕。
- en: This component displays a simple list and an indicator of whether the file has
    been loaded. We will be using the filename as the basis for whether a file has
    been loaded. It is common for financial institutions, data centers, and similar
    to rely on naming conventions to help facilitate various checks and balances,
    so using a filename for our component is not a unique approach to our dashboard.
    Of course, we could also expand the conditions to match any other constraints
    that might be useful from an ACH perspective—whether it is the company ID or totals
    from the batch.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件显示一个简单的列表和文件是否已加载的指示器。我们将使用文件名作为文件是否已加载的基础。对于金融机构、数据中心和类似机构来说，依赖命名约定来帮助促进各种检查和平衡是很常见的，因此在我们的组件中使用文件名并不是我们仪表板中独特的方法。当然，我们也可以扩展条件以匹配任何可能从ACH角度有用的其他约束——无论是公司ID还是批次的总数。
- en: Although we are approaching this problem from the company perspective, it would
    also be incorporated from a more general perspective (e.g., a financial institution
    will also expect files on a set schedule). Figure 10.4 shows an example of the
    component.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们是从公司角度来接近这个问题，但也会从更一般的角度（例如，金融机构也会期望按照一定的日程安排文件）来考虑。图10.4展示了组件的一个示例。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH10_F04_Kardell.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成](../Images/CH10_F04_Kardell.png)'
- en: Figure 10.4  Expected Files component
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4 期望文件组件
- en: 'We build the Expected Files component using the following steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下步骤构建期望文件组件：
- en: Define the database table and type.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义数据库表和类型。
- en: Define the API endpoint.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义API端点。
- en: Display the data using a MUI DataGrid.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MUI DataGrid显示数据。
- en: 10.6.1 Storing expected files
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.1 存储期望文件
- en: For our database, we create another database table named `company_expected_files`
    to store a list of filenames. We also create a `SCHEDULE_TYPE` like before to
    limit the possible values in the field. The table will only be responsible for
    holding the data necessary to determine whether the file should be found. There
    may be cases where an external job would make the determination and update a flag
    in the table. That is not required in our case, and we can rely on the API call
    to return the additional flag.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数据库，我们创建了一个名为`company_expected_files`的另一个数据库表来存储文件名列表。我们之前也创建了一个`SCHEDULE_TYPE`来限制字段中的可能值。该表将只负责持有确定文件是否应该被找到所需的数据。可能存在外部作业会做出决定并在表中更新标志的情况。在我们的情况下，这不是必需的，我们可以依赖API调用返回额外的标志。
- en: The following listing shows the creation of the table and type. We also use
    the `last_file_date`, which has to be maintained to be adjusted. We need to revise
    our file-upload logic to update this field.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了创建表格和类型的步骤。我们还使用了`last_file_date`，这个日期需要维护并调整。我们需要修改我们的文件上传逻辑来更新这个字段。
- en: Listing 10.32  Creating the type and table for expected files
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.32  创建期望文件的类型和表
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '#1 Although it is not required, we define a UUID that the record could be referenced
    by.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 虽然不是必需的，但我们定义了一个UUID，记录可以通过它来引用。'
- en: '#2 The key is actually the company and filename as we only want to have one
    filename per company.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 关键实际上是公司和文件名，因为我们只想每个公司有一个文件名。'
- en: We take similar steps to populate the database with some data to see the component
    in action. Listing 10.33 shows the `INSERT` for the `company_expected_files` table.
    We can insert these records for each company by using a `SELECT` statement to
    select the `company_id` field based on the `tax_id_number` for the company. Remember
    that the `company_id` is set dynamically by the database when the record is inserted.
    We could also choose to insert the record with a known UUID, but using the preceding
    approach allows us to work with the data as we expect to see it in production
    and prepare ourselves for the times when we do not have the luxury of inserting
    a known field in our test.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取类似的步骤向数据库中填充一些数据，以查看组件的实际运行情况。列表10.33显示了`company_expected_files`表的`INSERT`操作。我们可以通过使用`SELECT`语句根据公司的`tax_id_number`选择`company_id`字段来为每个公司插入这些记录。请记住，`company_id`是在记录插入时由数据库动态设置的。我们也可以选择使用已知的UUID插入记录，但使用前面的方法允许我们以我们预期在生产中看到的数据方式工作，并为我们没有在测试中插入已知字段的情况做好准备。
- en: Listing 10.33  Inserting records into the expected files table
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.33  向预期的文件表插入记录
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#1 Gets the company_id by searching companies by the tax_id_number'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 通过搜索公司的税号来获取`company_id`'
- en: With our database set up, we can now work on the logic that will power the `ExpectedFiles`
    component.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好数据库后，我们现在可以着手构建将驱动`ExpectedFiles`组件的逻辑。
- en: 10.6.2 Implementing the expected files API
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.2 实现预期的文件API
- en: With the data for expected files loaded into the database, we need to be able
    to retrieve it, and we also need to be able to update the `last_file_date` when
    a file is uploaded.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当预期的文件数据加载到数据库中后，我们需要能够检索它，并且当文件上传时，我们还需要能够更新`last_file_date`。
- en: The first thing we did was start with a test to work on building the required
    SQL logic. Again, we utilized Testcontainers to run our `docker_compose` container
    for the duration of the test.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先进行的是构建所需SQL逻辑的测试。同样，我们利用Testcontainers在测试期间运行我们的`docker_compose`容器。
- en: Listing 10.34 shows the basic structure of our test file. As part of the test,
    we created a basic `CompanySearchSql` class to search for companies by their `tax_id_number`
    or `ach_company_id` number. The need for such a class is another result of the
    database dynamically assigning the UUID. To avoid scope creep, we only built enough
    functionality to get a single company, but it could easily be incorporated into
    a search page or company page so that when we have hundreds or thousands of customers,
    we do not have to page through them all.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.34展示了我们的测试文件的基本结构。作为测试的一部分，我们创建了一个基本的`CompanySearchSql`类，用于通过公司的`tax_id_number`或`ach_company_id`编号来搜索公司。需要此类的一个原因是因为数据库动态分配UUID。为了避免范围蔓延，我们只构建了足够的功能来获取单个公司，但它可以很容易地集成到搜索页面或公司页面，这样当我们有数百或数千个客户时，我们不必逐页浏览它们。
- en: Listing 10.34  Test for the `ExpectedFilesSql` class
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.34  测试`ExpectedFilesSql`类
- en: '[PRE33]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 Uses Testcontainers and DockerCompose to build the container and start only
    the Postgres service. There is no need to start CloudBeaver for a temporary test.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用Testcontainers和DockerCompose构建容器并仅启动Postgres服务。对于临时测试，无需启动CloudBeaver。'
- en: '#2 Ensures the container is started and stopped for our test'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 确保容器为我们的测试启动和停止'
- en: '#3 Uses CompanySearchSql to get the company UUID'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用`CompanySearchSql`获取公司UUID'
- en: '#4 Makes sure we actually find something'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 确保我们确实找到了某些内容'
- en: '#5 Runs the SQL that we want to test'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 运行我们想要测试的SQL'
- en: '#6 Makes the necessary assertions to ensure the method worked'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 进行必要的断言以确保方法有效'
- en: With our unit test in place, we are free to build the logic behind the `get_expected_files_for_company`.
    The `SQL` query creates two additional fields that are not stored directly in
    the database. These fields are a Boolean value for whether the file has been loaded
    and the `next_file_date`, which is the next time we expect to see the file according
    to the file’s schedule. For now, we do not consider filtering our results by the
    date simply because that makes testing a bit more difficult. So, we are returning
    all the data. This does not necessarily make sense for the component when the
    current objective is to show files that were expected today. However, it works
    well enough to demonstrate the intent of the functionality. We could expand this
    component or create a new one that shows files for the coming week, gets the number
    of files expected, and similar. The `SQL` query utilizes the `INTERVAL` function,
    which makes it easy to compute the given time interval. The following listing
    shows the `SQL` statement.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单元测试就绪后，我们可以自由构建`get_expected_files_for_company`背后的逻辑。`SQL`查询创建了两个不直接存储在数据库中的额外字段。这些字段是一个布尔值，表示文件是否已加载，以及`next_file_date`，这是我们根据文件的计划预期下次看到文件的时间。目前，我们不考虑按日期过滤我们的结果，因为这会使测试变得稍微困难一些。因此，我们返回所有数据。这并不一定对组件有意义，因为当前的目标是显示今天预期的文件。然而，这足以展示功能意图。我们可以扩展此组件或创建一个新的组件，显示下周的文件，获取预期的文件数量，等等。`SQL`查询使用了`INTERVAL`函数，这使得计算给定的时间间隔变得容易。以下列表显示了`SQL`语句。
- en: Listing 10.35  SQL for the Expected Files component
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.35  为预期文件组件的SQL语句
- en: '[PRE34]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Uses a CTE to determine when the file is next expected'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用CTE（公用表表达式）确定文件下次预期的日期'
- en: '#2 Determines whether the file was loaded'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 确定文件是否已加载'
- en: Finally, we revise the posting of a file to update the `last_file_date` and
    `updated_at` fields for the table. This approach works well for now—when expected
    files are loaded, the date will increment accordingly and everything will function
    normally. However, problems arise when files are not uploaded. Perhaps the expected
    file does not need to be loaded that day–maybe it was a company holiday. For that
    reason, many financial institutions do not process files on weekends. When a file
    is loaded on a Friday, it may be necessary to adjust the next expected day to
    Monday instead of a Saturday. Handling these edge cases or addressing our users’
    additional needs helps make our software more robust. The following listing shows
    the addition of updating the necessary dates for our expected files.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们修改文件的发布以更新表中的`last_file_date`和`updated_at`字段。这种方法目前效果良好——当预期文件加载时，日期将相应增加，一切将正常工作。然而，当文件未上传时会出现问题。也许预期的文件那天不需要加载——可能那天是公司假日。因此，许多金融机构在周末不处理文件。当文件在周五加载时，可能需要将下次预期的日期调整为周一而不是周六。处理这些边缘情况或满足用户额外需求有助于使我们的软件更加健壮。以下列表显示了为预期文件更新必要日期的添加。 '
- en: Listing 10.36  Updating the dates for our expected files
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.36  更新预期文件的日期
- en: '[PRE35]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '#1 Once parsing of the file is completed, we can update the date.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一旦文件解析完成，我们就可以更新日期。'
- en: The logic of updating the dates can be kept simple for now. The `updated_at`
    is just for audit purposes, and determining when the file was uploaded. The last
    time the file was uploaded was also at the time of the update, so we use the function
    `NOW` for both updates. The following listing shows the simple update logic used
    by the `update_last_file_date` mehod.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 更新日期的逻辑目前可以保持简单。`updated_at`仅用于审计目的，用于确定文件上传的时间。文件上次上传的时间也是在更新时，因此我们使用`NOW`函数进行两次更新。以下列表显示了`update_last_file_date`方法使用的简单更新逻辑。
- en: Listing 10.37  Simple update logic
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.37  简单的更新逻辑
- en: '[PRE36]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#1 Updates the table to indicate the file has been uploaded'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 更新表以指示文件已上传'
- en: Things would get more complicated if we wanted to always keep the last file
    date set to a Monday and the processing fell on a weekend. This is an important
    problem because financial institutions may not be open on the weekend (or federal
    holidays), and it may not be appropriate to process files on those days. We certainly
    do not want to be enjoying our Sunday afternoon only to have numerous alerts come
    in, showing the files are missing! The following listing assumes a daily interval,
    but we could easily change this dynamic as needed.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望始终保持最后文件的日期设置为星期一，而处理工作落在周末，事情将会变得更加复杂。这是一个重要的问题，因为金融机构可能在周末（或联邦假日）不开放，而且在这些日子里处理文件可能并不合适。我们当然不希望只在周日午后享受时光，却突然收到大量警报，显示文件丢失！以下列表假定有一个日间隔，但我们可以根据需要轻松地改变这种动态。
- en: Listing 10.38  Default to Monday as needed
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.38  根据需要默认设置为星期一
- en: '[PRE37]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '#1 If the date falls on a Sunday or Saturday, adds the appropriate number of
    days to force it to Monday. Be aware that this does not work if Monday is a holiday
    and the financial institution is closed. That would take some additional effort.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果日期落在星期日或星期六，则添加适当的天数以强制将其变为星期一。请注意，如果星期一是一个假日且金融机构关闭，这就不起作用了。这需要额外的努力。'
- en: While we are not overly concerned about addressing the field `last_file_date`,
    we should begin to see some of the problems that may occur with scheduled tasks,
    especially when we must consider what happens when files are not loaded. It is
    unlikely that our application should have to directly address this, and—ironically
    enough—there may be another scheduled job that needs to run and clean the database.
    For now, we can retrieve the needed data from the database, so let’s proceed with
    creating the UI side of our component.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们并不特别关注解决`last_file_date`字段，但我们应该开始看到与计划任务可能出现的某些问题，尤其是在我们必须考虑文件未加载时的情况。我们的应用程序可能不需要直接处理这个问题，而且——讽刺的是——可能还有另一个计划任务需要运行并清理数据库。目前，我们可以从数据库中检索所需的数据，因此让我们继续创建组件的UI部分。
- en: 10.6.3 Displaying the expected files
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.3 显示预期文件
- en: The heavy lifting should have been done on the backend. The UI component simply
    needs to display the information and an icon dependent on the `file_loaded` Boolean
    that is returned as part of the response. The most interesting part of the UI
    component (considering we have done this many times by now) is the ternary statement
    we use to decide whether to display a `TaskAlt` or a `RadioButtonUnchecked` icon.
    Otherwise, it is the typical flow of adding the component to the page.tsx and
    having the component retrieve the necessary data and display it in the DataGrid.
    The following listing shows the UI component.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 重量级的工作应该在后端完成。UI组件只需显示信息和返回响应作为部分返回的`file_loaded`布尔值相关的图标。UI组件最有趣的部分（考虑到我们现在已经做了很多次）是我们用来决定是否显示`TaskAlt`或`RadioButtonUnchecked`图标的条件表达式。否则，它就是典型的将组件添加到page.tsx页面并让组件检索必要数据并在DataGrid中显示数据的流程。以下列表显示了UI组件。
- en: Listing 10.39  The `ExpectedFiles` component
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.39  `ExpectedFiles`组件
- en: '[PRE38]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '#1 We use a ternary statement to determine which icon to display.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们使用三元表达式来确定要显示哪个图标。'
- en: That completes the expected files component. We started by defining the required
    database table and a custom type to support the scheduling of expected files.
    Then we created a unit test with Testcontainers so that we could get a fresh database
    for each run. This approach allowed us to work out the needed SQL to return the
    data required for our component. Finally, we called the API from our UI and formatted
    the data to display it to the user.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了预期文件组件。我们首先定义了所需的数据库表和自定义类型以支持预期文件的调度。然后我们使用Testcontainers创建了一个单元测试，以便每次运行都能获得一个新的数据库。这种方法使我们能够确定返回我们组件所需数据的SQL。最后，我们从我们的UI中调用API，并格式化数据以显示给用户。
- en: Next, we look to add another component that can help companies monitor and control
    suspicious activity with company limits.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望添加另一个组件，可以帮助公司监控和控制可疑活动，使用公司限制。
- en: 10.7 Company Limits component
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 公司限制组件
- en: This component is centered around proactive monitoring for the company. We would
    like the company to be able to set limits that would trigger alerts and possibly
    prevent transactions from being posted should those limits be hit. This can help
    companies identify and deal with transactions or activity that may be outside
    of normal behavior.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件围绕公司的主动监控。我们希望公司能够设置触发警报并可能阻止达到这些限制的交易的限制。这可以帮助公司识别和处理可能超出正常行为的交易或活动。
- en: '![A screenshot of a credit card  Description automatically generated](../Images/CH10_F05_Kardell.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![信用卡截图  自动生成的描述](../Images/CH10_F05_Kardell.png)'
- en: Figure 10.5  Company Limits component
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5  公司限制组件
- en: As a business, if you expect less than, say, $10,000 of debit activity in a
    day, and suddenly, there is a $15,000 batch being posted for your company, you
    likely want to be alerted about that activity. In principle, this is a straightforward
    component that lists totals for the day and compares them to a limit set by the
    company or the bank—functionality that needs to be built out in a future sprint.
    In practice, we need to handle alerting the customer, allowing for processing
    when the company is okay with exceeding the limit, and rejecting the file load
    otherwise. Figure 10.5 shows the Company Limits component we will be implementing.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家企业，如果你预计一天内的借记活动少于，比如说，10,000美元，而突然，你的公司有15,000美元的交易批次正在发布，你很可能希望被通知这一活动。原则上，这是一个简单的组件，列出了当天的总额，并将其与公司或银行设定的限制进行比较——这是需要在未来的冲刺中构建的功能。在实践中，我们需要处理向客户发出警报，允许在公司在超出限制的情况下进行处理，否则拒绝文件加载。图10.5显示了我们将要实施的公司限制组件。
- en: 'We work on creating this component using the following steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下步骤创建此组件：
- en: Create the database table.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库表。
- en: Define the API endpoint.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义API端点。
- en: Display the returned information
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示返回的信息
- en: to the user.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 供用户使用。
- en: 10.7.1 Storing the company limits
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.1 存储公司限制
- en: We need a new table to store limits for the company. As with previous tables,
    this table will use a foreign key that references the company ID from the companies
    table. Remember that the use of the foreign key helps us maintain referential
    integrity for the database. The `ON` `DELETE` `CASCADE` and `ON` `UPDATE` `CASCADE`
    will ensure the record is removed when the company is deleted or changed accordingly
    if updated. Not every company needs to have limits, so we will keep that in mind
    as we create queries which utilize this table.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新表来存储公司的限制。与之前的表一样，此表将使用外键，该外键引用来自companies表的公司ID。记住，外键的使用帮助我们维护数据库的引用完整性。`ON
    DELETE CASCADE`和`ON UPDATE CASCADE`将确保在删除公司或相应地更新时删除记录。并非每个公司都需要限制，因此我们在创建使用此表的查询时要注意这一点。
- en: Listing 10.40  Company Limits table
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.40  公司限制表
- en: '[PRE39]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '#1 Keeping track of when records are created and updated can help with auditing.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 跟踪记录的创建和更新时间可以帮助审计。'
- en: There are a few approaches to implementing this functionality, and we will use
    a basic one that can be expanded as needed. The basic approach will not require
    us to store the totals. Instead we rely on the API to gather the totals and determine
    whether they are exceeded. This means that our logic will be executed when the
    company dashboard is displayed and when the file has finished loading so that
    we can add an associated exception. Remember from chapter 8 that if we want to
    add an exception, we will have to add it to the database along with any recovery
    options if desired. The following listing shows how the general_ach_data.sql was
    updated to insert these records.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此功能有几种方法，我们将使用一种基本方法，可以根据需要扩展。基本方法将不需要我们存储总额。相反，我们依赖API来收集总额并确定是否超出。这意味着我们的逻辑将在公司仪表板显示时以及文件加载完成后执行，以便我们可以添加相关的异常。记住，从第8章中我们知道，如果我们想添加异常，我们必须将其添加到数据库中，如果需要，还可以添加任何恢复选项。以下列表显示了如何更新general_ach_data.sql以插入这些记录。
- en: Listing 10.41  Setting up the exception data
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.41  设置异常数据
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#1 We can add a new exception code for our company limits condition.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们可以为我们的公司限制条件添加一个新的异常代码。'
- en: '#2 It is helpful to provide the users with some guidance on what to do when
    an exception is encountered.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当遇到异常时，为用户提供一些指导是有帮助的。'
- en: We also set up the data for the company limits so that there is existing data
    in the database. The following listing shows the simple insertion into the database
    table.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了公司限制的数据，以便数据库中已有数据。以下列表显示了简单地将数据插入到数据库表中。
- en: Listing 10.42  Inserting records for the company limit
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.42  插入公司限制记录
- en: '[PRE41]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That should be all we need to get up and running with company limits. The next
    section will show you how to update APIs so that you can work with the table.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就应该能够启动并运行公司限制了。下一节将展示如何更新API，以便您可以与该表一起工作。
- en: 10.7.2 Implementing the company limits API
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.2 实现公司限制API
- en: Take a minute to think about what we would like to accomplish with the company
    limits API. Of course, we need to be able to retrieve what the limits are set
    to, but we will also want to determine what the current totals are for the company
    and a Boolean flag to indicate whether the limits have been exceeded. As mentioned,
    when designing the database tables, we decided not to store the current totals
    for the debits and credits, although we certainly could have created those fields
    and updated them as we loaded them.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 花一分钟时间思考一下我们希望通过公司限制API实现什么。当然，我们需要能够检索出限制设置为何，但我们还希望确定公司当前的总数以及一个布尔标志来指示是否超过了限制。正如之前提到的，在设计数据库表时，我们决定不存储借方和贷方的当前总数，尽管我们当然可以创建这些字段并在加载时更新它们。
- en: A potential drawback in this case is that depending on when/where we decide
    to do this check, we may have limited ability to narrow down the problem for the
    user. We should take a moment to think about where the exception can be written.
    For example, we just added a check for the expected files right after the file
    was loaded. Should we put this check in the same place? That may be our first
    inclination since we just added similar code. However, by putting it there, we
    miss out on being able to identify which batch is responsible for causing the
    company limit to be exceeded as we do not access the record numbers at that point,
    and it makes it difficult to put the actual batch header on the exception. The
    following listing shows that we included the exception during the processing of
    the batch control record.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个潜在的缺点是，根据我们决定何时何地执行此检查，我们可能有限的能力来缩小用户的问题。我们应该花点时间思考异常可以写入的位置。例如，我们就在文件加载后立即添加了对预期文件的检查。我们应该把检查放在同一个地方吗？这可能就是我们的第一反应，因为我们刚刚添加了类似的代码。然而，把检查放在那里，我们就无法识别出导致公司限制超过的批次，因为我们当时没有访问记录号，这还使得在异常上放置实际的批次标题变得困难。以下列表显示了我们在处理批次控制记录时包含了异常。
- en: Listing 10.43  Adding the exception
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.43  添加异常
- en: '[PRE42]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '#1 Checks whether we exceeded the company limits'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 检查是否超过了公司限制'
- en: '#2 Calls the insert_record method from AchExceptionsSql to insert the record'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 从AchExceptionsSql调用insert_record方法来插入记录'
- en: '#3 This is our standard exception schema. It is the first time we actually
    use the ach_batch_id, although there are plenty of exceptions we need it for.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这是我们标准的异常架构。这是我们第一次实际使用ach_batch_id，尽管我们有很多异常需要它。'
- en: We write out our new `COMPANY_LIMITS_EXCEEDED` exception when a file exceeds
    company limits. This means that we need to define the `CompanyLimitsSql` class
    and a method to determine whether the file exceeds the company limits. We can
    tell from the use of the method that it just needs to return a Boolean value to
    determine whether this causes an exception. The method itself is straightforward,
    with the usual getting of the connection running a SQL query and fetching the
    results. The following listing shows the method details.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件超过公司限制时，我们记录新的`COMPANY_LIMITS_EXCEEDED`异常。这意味着我们需要定义`CompanyLimitsSql`类和一个方法来确定文件是否超过公司限制。我们可以从方法的使用中看出，它只需要返回一个布尔值来决定是否引发异常。该方法本身很简单，包括通常的获取连接、运行SQL查询和获取结果。以下列表显示了方法细节。
- en: Listing 10.44  Determining whether a file exceeded company limits
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.44  确定文件是否超过公司限制
- en: '[PRE43]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '#1 Creates a CTE to select the batch totals'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建一个CTE来选择批次总数'
- en: '#2 Sums the credits and debits'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 求借方和贷方的总和'
- en: '#3 We only need to return something.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们只需要返回一些内容。'
- en: '#4 Selects the file and sums'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 选择文件并求和'
- en: '#5 We want to return a Boolean, so the “is not None” helps us return True/False.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 我们希望返回一个布尔值，所以“is not None”帮助我们返回True/False。'
- en: The previous listing helps us determine whether we need to write an exception,
    but we also need to define a method that will be used with the UI. This is similar
    to the previous SQL with the addition of the actual fields for the limits, the
    current totals, and flags indicating whether the limit was exceeded. We prefer
    to return explicit flags for the UI to use rather than have the UI rely on making
    the determination itself. The following listing shows the SQL used to return the
    required information for our `get_company_limits` method.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表帮助我们确定是否需要编写异常，但我们还需要定义一个将用于UI的方法。这与之前的SQL类似，增加了实际的限制字段、当前总额和指示是否超过限制的标志。我们更喜欢返回显式的标志供UI使用，而不是让UI自己做出判断。以下列表显示了用于返回`get_company_limits`方法所需信息的SQL。
- en: Listing 10.45  Query for the totals, limits, and flags
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.45  查询总额、限制和标志
- en: '[PRE44]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '#1 Returns the current debit/credit totals; defaulting to zero when no batches
    are found'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 返回当前的借记/贷记总额；如果没有找到批量，则默认为零'
- en: '#2 Returns flags to indicate whether limits have been exceeded'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 返回标志以指示是否已超过限制'
- en: There is just some minor housekeeping to create the API endpoint and the class
    that holds the response for the UI, but there is plenty of existing code to reference
    for these tasks. In the next section, we finish adding the company limits to the
    dashboard.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 只需做一些简单的维护工作来创建API端点和包含UI响应的类，但已有大量现有代码可以参考这些任务。在下一节中，我们将完成将公司限制添加到仪表板的工作。
- en: 10.7.3 Displaying the company limits
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.3 显示公司限制
- en: As we saw in figure 10.5, the component itself is straightforward as we are
    just trying to convey to the user in the simplest terms whether the limits have
    been exceeded. We do want to add a little more visual appeal to the component
    by displaying the amount as red when it exceeds the limit and green otherwise.
    The following listing shows the basics of setting this feature up.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图10.5中看到的，组件本身很简单，我们只是试图用最简单的术语向用户传达是否已超过限制。我们确实想通过在超过限制时显示红色金额，否则显示绿色，为组件添加一些视觉吸引力。以下列表显示了设置此功能的基礎。
- en: Listing 10.46  Company credits and debit limits
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.46  公司信用和借记限制
- en: '[PRE45]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '#1 Colors the field red when the field has been exceeded'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当字段被超过时，将字段着色为红色'
- en: '#2 Colors the field green when the field is within range'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当字段在范围内时，将字段着色为绿色'
- en: The other aspects of the UI for the company limits already fall into place because
    we are using the existing logic for exceptions. So, that means that the file is
    automatically flagged as having an exception when viewing the dashboard, and the
    exception is returned to the DataGrid when viewing the exceptions. This does bring
    up a problem with viewing the exception for this company limit. We see the ACH
    batch control record (type 8), but we cannot easily tell which company it was
    dealing with. Even though we did save the batch header UUID as part of creating
    the exception, this was the first time we ever used it. It would be nice to update
    our code to include some batch header information when viewing an exception. Let’s
    use this opportunity to make a few changes to the exceptions and exception detail
    screens.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 公司界面中限制的其他方面已经就绪，因为我们正在使用现有的异常逻辑。这意味着在查看仪表板时，文件会自动标记为存在异常，并且在查看异常时，异常会被返回到DataGrid中。这确实为查看此公司限制的异常带来了一些问题。我们看到ACH批量控制记录（类型8），但无法轻易判断它处理的是哪家公司。尽管我们在创建异常时保存了批量头UUID作为一部分，但这是我们第一次使用它。如果能更新我们的代码，在查看异常时包含一些批量头信息，那就太好了。让我们利用这个机会对异常和异常详情屏幕进行一些修改。
- en: First, the simplest change is to drop the column for the error code from the
    exceptions screen. From a developer’s perspective, this move makes sense, but
    it can be confusing and does not add any value to the UX, especially since end-users
    have the description the code translates to.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最简单的更改是从异常屏幕中删除错误代码列。从开发者的角度来看，这个动作是有意义的，但它可能会造成混淆，并且对用户体验没有增加任何价值，特别是由于最终用户已经有了代码所转换的描述。
- en: Next, the details for the exception consisted of only the unparsed record, which
    used a generic alert component we created for other purposes. Now that we have
    some experience in creating a modal to display details as we did with the audit
    details in chapter 9, we can use those skills to build a more detailed screen.
    We can work on displaying the details we already have (we can move the error code
    to this screen if we want), as well as information we have not used yet, such
    as the recovery action. Figure 10.6 shows the exception details modal we ended
    up with.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，异常的详情仅包括未解析的记录，它使用了我们为其他目的创建的通用警报组件。现在，我们有一些创建模态来显示详情的经验，就像在第 9 章中显示审计详情一样，我们可以使用这些技能构建一个更详细的屏幕。我们可以处理显示我们已有的详情（如果我们想的话，可以将错误代码移动到这个屏幕上），以及我们尚未使用的信息，例如恢复操作。图
    10.6 显示了我们最终得到的异常详情模态。
- en: '![A close-up of a computer screen  Description automatically generated](../Images/CH10_F06_Kardell.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕的特写  自动生成的描述](../Images/CH10_F06_Kardell.png)'
- en: Figure 10.6  Exception details modal
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6  异常详情模态
- en: The `AchExceptionDetailsResponse` will have to be updated so that it returns
    the required information—the company name if available and a recovery action.
    If we have access to the records, there is certainly an opportunity to return
    a lot more information, but in the interest of bringing back the YAGNI principle
    (chapter 3), and as a reminder of KISS (Keep It Simple, Stupid), we only return
    what we need at the moment.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`AchExceptionDetailsResponse` 将需要更新，以便返回所需的信息——如果有的话，公司名称和恢复操作。如果我们有权访问记录，当然有机会返回更多信息，但出于对
    YAGNI 原则（第 3 章）的考虑，以及作为 KISS（保持简单，傻瓜）的提醒，我们目前只返回所需的信息。'
- en: The main work that we need to do is update the SQL statement for the `get_exception_detail_response`.
    We have to pull in extra tables to get the company name and recovery options.
    Keep in mind that we are not guaranteed to have recovery options nor are we guaranteed
    to have a company name. This means that we will want to avoid using an `INNER`
    `JOIN`. Instead, we will use a `LEFT` `JOIN` as in previous cases where we needed
    to keep the rows on one side of the query even when there were no matching records
    in the subsequent parts. The following listing shows the additional SQL logic
    that needs to be included. Note that since we have saved the parsed header record
    ID, we do not have to do a lot of joins to get to the record like in previous
    queries, where we had to start at the file level and drill down.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的主要工作是更新 `get_exception_detail_response` 的 SQL 语句。我们必须引入额外的表来获取公司名称和恢复选项。请注意，我们无法保证有恢复选项，也无法保证有公司名称。这意味着我们将想避免使用
    `INNER` `JOIN`。相反，我们将使用 `LEFT` `JOIN`，就像在之前的案例中，即使后续部分没有匹配的记录，我们也需要保留查询的一侧的行。以下列表显示了需要包含的附加
    SQL 逻辑。请注意，由于我们已经保存了解析的标题记录 ID，我们不需要像在之前的查询中那样进行很多连接，那时我们必须从文件级别开始并向下钻取。
- en: Listing 10.47  Updates to get more exception details
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.47  更新以获取更多异常详情
- en: '[PRE46]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '#1 These fields are new to our query and select the company name if available
    and any recovery steps.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这些字段对我们查询来说是新的，如果可用，则选择公司名称和任何恢复步骤。'
- en: '#2 Joins the new tables. Again, we need to use LEFT JOIN because we are not
    guaranteed data will exist in tables.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 连接新的表。同样，我们需要使用 LEFT JOIN，因为我们无法保证数据将存在于表中。'
- en: With the fields now included in our response, we can make the necessary updates
    to the UI to include them as well.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在响应中包含了字段，我们可以更新 UI 以包括它们。
- en: Listing 10.48  Using the `ExceptionsModal`
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.48  使用 `ExceptionsModal`
- en: '[PRE47]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '#1 Includes the ExceptionsModal and the required parameters'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 包含 ExceptionsModal 和所需的参数'
- en: The `ExceptionsModal` takes care of formatting the `exceptionData` and is based
    on what we did before for our `AuditModal` in chapter 9\. We will not display
    the company name with this component if it is an empty string, and we would like
    to provide a default recovery option of None Provided if no recovery options were
    available. Depending on the situation, it can often be beneficial to display a
    confirmation or message that validates this is an expected situation—sort of a
    21st-century “This page intentionally left blank” message. It may make sense not
    to include the company name if the problem is not directly dealing with a company
    (although a case could be made for referencing the batch for any entry exceptions
    as well). However, hiding the recovery options may make users think something
    has gone wrong, especially when they may depend on referring to recovery options.
    The following listing shows the basics of the modal. Since the query to return
    the exception detail uses the `COALESCE` function, we are guaranteed to return
    at the very least an empty string for the company name, so we use that knowledge
    to check whether the label and field should be displayed. In addition, we use
    `??` to default the recovery text when nothing has been provided.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionsModal` 负责格式化 `exceptionData`，并基于我们在第9章中为 `AuditModal` 所做的操作。如果该组件是一个空字符串，我们不会显示公司名称，并且如果没有任何恢复选项，我们希望提供一个默认的恢复选项“未提供”。根据情况，有时显示一个确认或消息来验证这是一个预期的情况——有点像21世纪的“此页有意留白”消息。如果问题不是直接涉及公司（尽管可以提出将批次引用为任何条目异常的理由），则可能不包含公司名称是有意义的。然而，隐藏恢复选项可能会让用户认为出了问题，尤其是当它们可能依赖于参考恢复选项时。以下列表显示了模态的基本内容。由于查询返回异常详情使用的是
    `COALESCE` 函数，我们保证至少返回一个空字符串作为公司名称，因此我们利用这一知识来检查标签和字段是否应该显示。此外，我们使用 `??` 在没有提供任何内容时默认恢复文本。'
- en: Listing 10.49  The `ExceptionsModal` Component
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.49  `ExceptionsModal` 组件
- en: '[PRE48]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '#1 Conditionally includes the company name if something was returned'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 条件性地包含公司名称，如果返回了某些内容'
- en: '#2 Always prints something for the recovery steps, even if it is just something
    to let users know they are on their own'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 总是打印恢复步骤的内容，即使只是让用户知道他们可以自行处理'
- en: Only slight adjustments to the Exceptions component are necessary to ensure
    that data is passed properly to the new modal. The following listing shows the
    updated Exceptions component. The biggest change here is simply passing a function
    that will set the open state to `False` when the modal button is clicked.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要对异常组件进行轻微调整，以确保数据正确传递到新的模态。以下列表显示了更新的异常组件。这里最大的变化仅仅是传递一个函数，当模态按钮被点击时，该函数将设置打开状态为
    `False`。
- en: Listing 10.50  The Exceptions component
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.50  异常组件
- en: '[PRE49]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '#1 No longer needed because it does not add anything useful for the user'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 不再需要，因为它对用户没有提供任何有用的功能'
- en: '#2 Includes the ExceptionsModal'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 包含异常模态'
- en: So, we have now built a company dashboard that provides information that can
    ensure correct/desired files are loaded, show recent batches for the company,
    and send alerts when activity does not match the company’s expectations.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经构建了一个公司仪表板，可以提供确保正确/所需文件被加载的信息，显示公司的近期批次，并在活动不符合公司预期时发送警报。
- en: Summary
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Sprint planning in this chapter focused on building key components—company information,
    recent batches, expected files, and company limits—emphasizing the importance
    of comprehensive data-structure design.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的冲刺计划专注于构建关键组件——公司信息、近期批次、预期文件和公司限制，强调了全面数据结构设计的重要性。
- en: A company-level dashboard was created to address the need for storing and displaying
    detailed company information beyond the initial project scope.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个公司级仪表板，以解决在初始项目范围之外存储和显示详细公司信息的需求。
- en: The importance of building robust company data management systems that provide
    a framework for enhancing ACH-processing services for business customers who need
    detailed batch information was highlighted.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调了构建健壮的公司数据管理系统的重要性，该系统为需要详细批次信息的企业客户提供增强ACH处理服务的框架。
- en: Designing foundational company information tables as blockers stressed their
    dependency on further development and the consideration of early work on some
    components to reduce modifications.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基础公司信息表设计为阻塞器，强调了它们对进一步开发的依赖性，并考虑在早期对某些组件进行工作以减少修改。
- en: Generative AI can help create meaningful test data quickly, which enhances productivity
    by generating more than typical name and address information, including logos.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成式 AI 可以快速创建有意义的测试数据，通过生成比典型的姓名和地址信息更多的内容（包括标志），从而提高生产力。
- en: Implementing a company dashboard demonstrated the necessity of organizing UI
    structures for efficient navigation and detailed data presentation for specific
    company metrics.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施公司仪表板展示了组织 UI 结构以实现高效导航和针对特定公司指标的详细数据展示的必要性。
- en: Creating detailed UI components for company overviews highlighted the value
    of user-friendly interfaces that facilitate seamless navigation and interaction
    at the company level.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为公司概述创建详细的 UI 组件突出了用户友好界面的重要性，这些界面有助于在公司层面实现无缝导航和交互。
- en: Designing an API for company data retrieval reinforced the importance of well-structured
    responses and validation mechanisms for dynamic user inter­action with dashboards.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用于公司数据检索的 API 强调了结构良好的响应和验证机制对于与仪表板动态用户交互的重要性。
- en: Developing recent batch components highlighted the importance of flexible search
    functions for batch data retrieval to meet diverse business needs.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发最近批次组件突出了灵活的搜索功能对于批量数据检索的重要性，以满足多样化的业务需求。
- en: Creating expected file components stressed the need for alerting mechanisms
    and schedule compliance to ensure timely processing of crucial documents and mitigate
    risks.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建预期文件组件强调了警报机制和调度合规性的必要性，以确保及时处理关键文件并降低风险。
- en: Proactive monitoring of ACH files was explored to shift from reactive to pro­active
    measures for improved customer service.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索对 ACH 文件进行主动监控，以从被动措施转变为主动措施，从而改善客户服务。
- en: Company limit components emphasized configurable alerts and thresholds to safeguard
    against unauthorized or unexpected financial transactions.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司限制组件强调了可配置警报和阈值，以防止未经授权或意外的财务交易。
- en: Expanding exception functionality, such as alert generation, can help us notify
    customers through various channels if limits are exceeded.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展异常功能，如警报生成，可以帮助我们在超过限制时通过各种渠道通知客户。
- en: Utilizing Testcontainers enhances testing reliability by ensuring isolated environments,
    eliminating dependency on developer-specific configurations, and allowing robust
    and portable tests.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Testcontainers 通过确保隔离环境、消除对开发者特定配置的依赖，以及允许进行强大且可移植的测试，增强了测试可靠性。
