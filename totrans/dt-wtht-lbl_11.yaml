- en: 9 Autoencoders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introducing autoencoders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training of autoencoders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of autoencoders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python code using TensorFlow and Keras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of intense complexities, intense simplicities emerge.—Winston Churchill
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the preceding chapter, we explored the concepts of deep learning. In this
    chapter, we start with unsupervised deep learning. Autoencoders are the very first
    topic. We will first cover the basics of autoencoders, what are they, and how
    we train them. We then get into the different types of autoencoders followed by
    a Python code on the implementation. Welcome to the ninth chapter, and all the
    very best!
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Technical toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will continue to use the same version of Python and Jupyter Notebook as
    we have used so far. The codes and datasets used in this chapter have been checked
    in at the GitHub location. You need to install a couple of Python libraries in
    this chapter: `tensorflow` and `keras`.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Feature learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Predictive modeling is quite an interesting topic. Across various domains and
    business functions, predictive modeling is used for various purposes like predicting
    the sales for a business in the next year, the amount of rainfall expected, whether
    the incoming credit card transaction is fraud or not, whether the customer will
    make a purchase or not, and so on. The use cases are many, and all the aforementioned
    use cases fall under supervised learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE  The datasets that we use have variables or attributes. They are also called
    characteristics or features.
  prefs: []
  type: TYPE_NORMAL
- en: While we wish to create these predictive models, we are also interested in understanding
    the variables that are useful for making the prediction. Let’s consider a case
    where a bank wants to predict if an incoming transaction is fraudulent or not.
    In such a scenario, the bank will wish to know which factors are significant to
    identify an incoming transaction as fraud. Factors that might be considered include
    the amount of the transaction, the time of the transaction, the origin/source
    of the transaction, etc. The variables that are important for making a prediction
    are called *significant variables*.
  prefs: []
  type: TYPE_NORMAL
- en: To create a machine learning–based predictive model, *feature engineering* is
    used. Feature engineering, otherwise known as feature extraction, is the process
    of extracting features from the raw data to improve the overall quality of the
    model and enhance the accuracy as compared to a model where only raw data is fed
    to the machine learning model.
  prefs: []
  type: TYPE_NORMAL
- en: Feature engineering can be done using domain understanding, various manual methods,
    and a few automated methods too. One such method is known as feature learning.
    Feature learning is the set of techniques that help a solution automatically discover
    the representations required for feature detection. With the help of feature learning,
    manual feature engineering is not required. The effect of feature learning is
    much more relevant for datasets where images, text, audio, and video are being
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Feature learning can be both supervised and unsupervised. For supervised feature
    learning, neural networks are the best example. For unsupervised feature learning,
    we have examples like matrix factorization, clustering algorithms, and autoencoders.
    We have already covered clustering and matrix factorization. In this chapter,
    we start with an introduction to autoencoders.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Introducing autoencoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we start with any data science problem, data plays the most significant
    role. A dataset that has a lot of noise is one of the biggest challenges in data
    science and machine learning. There are quite a few solutions available now, and
    autoencoders are one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, an autoencoder is a type of artificial neural network, and it is
    used to learn the data encodings. Autoencoders are typically used for dimensionality
    reduction methods. They can also be used as generative models, which can create
    synthetic data that is like the old data. For example, if we do not have a good
    amount of data to train machine learning, we can use generated synthetic data
    to train the models.
  prefs: []
  type: TYPE_NORMAL
- en: Autoencoders are feed-forward neural networks, and they compress the input into
    a lower dimensional code and then try to reconstruct the output from this representation.
    The objective of an autoencoder is to learn the lower dimensional representation
    (also sometimes known as encoding) for a high-dimensional dataset. Recall from
    the previous chapters principal component analysis (PCA). Autoencoders can be
    thought of as a generalization for PCA. PCA is a linear method whereas autoencoders
    can learn nonlinear relationships as well. Hence, autoencoders are required for
    dimensionality reduction solutions wherein they capture the most significant attributes
    from the input data.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Components of autoencoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The architecture of an autoencoder is quite simple to understand. An autoencoder
    consists of three parts: an encoder, a bottleneck or a code, and a decoder, as
    shown in figure 9.1\. In simple terms, an encoder compresses the input data, a
    bottleneck or code contains this compressed information, and the decoder decompresses
    the knowledge and hence reconstructs this data back to its original form. Once
    the decompression has been done and the data has been reconstructed to its encoded
    form, the input and output can be compared.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH09_F01_Verdhan.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 Structure of an autoencoder with an encoder, a bottleneck, and a
    decoder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s study these components in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Encoder*—The input data passes through the encoder. An encoder is nothing
    but a fully connected artificial neural network. It compresses the input data
    into an encoded representation, and in the process the output generated is reduced
    in size. An encoder compresses the input data into a compressed module known as
    a bottleneck.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bottleneck*—The bottleneck can be considered the brain of the encoder. It
    contains the compressed information representations, and it is the job of the
    bottleneck to allow only the most important information to pass through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Decoder*—The information received from the bottleneck is decompressed by a
    decoder. It re-creates the data back to its original or encoded form. Once the
    job of the decoder is done, the actual values are compared with the decompressed
    values created by the decoder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few important points about autoencoders to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a loss of information in autoencoders when the decompression is done
    as compared to the original inputs. So when the compressed data is decompressed,
    there is a loss as compared to the original data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoencoders are specific to datasets. This means that an algorithm that is
    trained on images of flowers will not work on images of traffic signals and vice
    versa. This is because the features the autoencoder learned will be specific to
    flowers only. So we can say that autoencoders are only able to compress the data
    similar to the one used for training.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is relatively easier to train specialized instances of algorithms to perform
    well on specific types of inputs. We just need representative training datasets
    to train the autoencoder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.5 Training of autoencoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that if there is no correlation between the variables
    in the data, then it is really difficult to compress and subsequently decompress
    the input data. For us to create a meaningful solution, there should be some level
    of relationship or correlation between the variables in the input data. To create
    an autoencoder, we require an encoding method, a decoding method, and a loss function
    to compare the actual versus decompressed values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The input data passes through the encoder module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The encoder compresses the input of a model into a compact bottleneck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bottleneck restricts the flow of information and allows only important information
    to pass through; hence, a bottleneck is sometimes referred to as *knowledge-representation*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The decoder decompresses the information and re-creates the data back to its
    original or encoded form. This encoder-decoder architecture is quite efficient
    in getting the most significant attributes from the input data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The objective of the solution is to generate an output identical to the input.
    Generally, the decoder architecture is a mirror image of the coder architecture.
    This is not mandatory but is generally followed. We ensure that the dimensionality
    of the input and outputs are the same.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE  If you do not know the meaning of hyperparameter, refer to the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define four hyperparameters for training an autoencoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code size*—This is perhaps the most significant hyperparameter. It represents
    the number of nodes in the middle layer. This decides the compression of the data
    and can also act as a regularization term. The less the value of code size, the
    more compressed the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parameter*—This denotes the depth of the autoencoder. A model that has more
    depth is obviously more complex and will have a longer processing time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Number of nodes per layer*—This is the weight used per layer. It generally
    decreases with every subsequent layer as the input becomes smaller across the
    layers. It increases back in the decoder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Loss function used*—If the input values are in the [0,1] range, binary cross-entropy
    is preferred; otherwise, mean squared error is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have covered the hyperparameters used in training autoencoders. The training
    process is similar to backpropagation, which we have already covered.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Application of autoencoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Autoencoders are capable of solving a number of problems inherent to unsupervised
    learning. Major applications for autoencoders include
  prefs: []
  type: TYPE_NORMAL
- en: '*Dimensionality reduction*—Sometimes autoencoders can learn more complex data
    projections than PCA and other techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Anomaly detection*—The error or the reconstruction error (error between the
    actual data and the reconstructed data) can be used to detect the anomalies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data compression*—It is difficult to beat the basic solutions like JPEG by
    training the algorithm. Moreover, since autoencoders are data specific, they can
    use only the types of datasets they have been trained upon. If we wish to enhance
    the capacity to include more data types and make it more general, then the amount
    of the training data required will be too high, and obviously, the time required
    will be high too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Other applications*—These include drug discovery, machine translation, image
    denoising, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are still not a lot of practical implementations of autoencoders in the
    real world. This is due to a multitude of reasons like the nonavailability of
    datasets, infrastructure, readiness of various systems, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Types of autoencoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are five main types of autoencoders. A brief description of the different
    types of encoders is given next. We have kept the section mathematically light
    and skipped the math behind the scenes as it is quite complex to understand. For
    curious readers, the papers listed in section 9.10 can explain the mathematics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Undercomplete autoencoders*—An undercomplete autoencoder is the simplest form
    of an autoencoder. It simply takes an input dataset and then reconstructs the
    same dataset again from the compressed bottleneck region. By penalizing the neural
    network as per the reconstruction error, the model will learn the most significant
    attributes of the data. By learning the most important attributes, the model will
    be able to reconstruct the original data from the compressed state. As we know,
    there is a loss when the compressed data is reconstructed; this loss is called
    *reconstruction* loss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undercomplete autoencoders are unsupervised in nature as they do not have any
    target label to train. Such types of autoencoders are used for dimensionality
    reduction. Recall in chapter 2 we discussed dimensionality reduction (PCA), and
    in chapter 6, we discussed the advanced dimensionality reduction algorithms (t-distributed
    stochastic neighbor embedding and multidimensional scaling). See figure 9.2.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH09_F02_Verdhan.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 The performance starts to improve with more dimensions but decreases
    after some time. The curse of dimensionality is a real problem when it comes to
    creating sound data science solutions.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Dimensionality reduction is possible using undercomplete autoencoders as the
    bottleneck is created, which is the compressed form of the input data. This compressed
    data can be decompressed back with the aid of the network. Recall in chapter 3
    we explained that PCA provides a linear combination of the input variables. For
    more details and to refresh your memory on PCA, please refer to chapter 3\. We
    know that PCA tries to get a low-dimensional hyperplane to describe the original
    dataset; undercomplete autoencoders can also learn nonlinear relationships. The
    difference is shown in figure 9.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH09_F03_Verdhan.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 PCA is linear in nature while autoencoders are nonlinear. This is
    the core difference between the two algorithms.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Interestingly, if all the nonlinear activation functions are removed from the
    undercomplete autoencoder and only linear layers are used, the autoencoder is
    equivalent to a PCA only. To make the autoencoder generalize and not memorize
    the training data, an undercomplete autoencoder is regulated and fine-tuned by
    the size of the bottleneck. It allows the solution to not memorize the training
    data and generalize very well.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE  If a machine learning model works very well on the training data but does
    not work on the unseen test data, it is called overfitting.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sparse autoencoders*—Sparse autoencoders are similar to undercomplete autoencoders
    except they use a different methodology to tackle overfitting. Conceptually, a
    sparse autoencoder changes the number of nodes at each of the hidden layer and
    keeps it flexible. Since it is not possible to have a neural network capable of
    a flexible number of neurons, the loss function is customized for it. In the loss
    function, a term is introduced that captures the number of activated neurons.
    The penalty term is proportional to the number of activated neurons. The higher
    the number of activated neurons, the higher the penalty. This penalty is called
    the *sparsity function*. Using the penalty, it is possible to reduce the number
    of activated neurons; hence the penalty is lower, and the network is able to tackle
    the problem of overfitting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contractive autoencoders*—Contractive autoencoders work on a similar concept
    as other autoencoders. They consider that the inputs that are quite similar should
    be encoded the same. Hence, they should have the same latent space representation.
    It means that there should not be much difference between the input data and the
    latent space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Denoizing autoencoders**—*Denoizing means removing the noise, and that is
    the precise task of denoizing autoencoders. They do not take an image as an input;
    instead they take a noisy version of an image as an input as shown in figure 9.4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![figure](../Images/CH09_F04_Verdhan.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 An original image, noisy output, and the outputs from the autoencoder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The process of denoizing the autoencoder is depicted in figure 9.5\. The original
    image is changed by adding noise to it. This noisy image is fed to the encoder-decoder
    architecture and the output received is compared to the original image. The autoencoder
    learns the representation of the image, which is used to remove the noise; this
    is achieved by mapping the input image into a lower dimensional manifold.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/CH09_F05_Verdhan.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 The process of denoizing in an autoencoder. It starts with the original
    image; noise is added, which results in a noisy image, and then it is fed to the
    autoencoder.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can use denoizing autoencoders for nonlinear dimensionality reduction.
  prefs: []
  type: TYPE_NORMAL
- en: '*Variational autoencoders*—A standard autoencoder model represents the input
    in a compressed form using the bottleneck. A variation is probabilistic generative
    models (usually Gaussian) over latent variables, which only need neural networks
    as a part of their overall structure. They are trained using expectation-maximization
    meta-algorithms. The mathematical details are beyond the scope of this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.8 Python implementation of autoencoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create two versions of an autoencoder. The code has been taken from the
    official source at the Keras website ([https://blog.keras.io/building-autoencoders-in-keras.html](https://blog.keras.io/building-autoencoders-in-keras.html))
    and has been modified for our usage. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '2\. Create our network architecture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '3\. Add more details to the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '4\. Load the datasets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '5\. Create the train and test the datasets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '6\. Fit the model (see figure 9.6):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/CH09_F06_Verdhan.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 Fitting the model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '7\. Test it on the test dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '8\. Plot the results. You can see the original image and final output (see
    figure 9.7):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/CH09_F07_Verdhan.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 The original image (bottom) and the final outcome (top)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 9.9 Concluding thoughts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deep learning is a powerful tool. With a sound business problem and a quality
    dataset, we can create a lot of innovative solutions. Autoencoders are only one
    type of such solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we started with feature engineering, which allows us to extract
    the most significant features from a dataset. Then we moved to autoencoders. Autoencoders
    are a type of neural network only used to learn efficient coding of unlabeled
    datasets. Autoencoders can be applied to many business problems like facial recognition,
    anomaly detection, image recognition, drug discovery, machine translation, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 9.10 Practical next steps and suggested readings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following provides suggestions for what to do next and offers some helpful
    reading:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the blog at [https://mng.bz/qxaw](https://mng.bz/qxaw).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Study the following papers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hinton, G. E., Krizhevsky, A., and Wang, S. D. (2011). Transforming Auto-encoders.
    [https://mng.bz/7p99](https://mng.bz/7p99)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bank, D., Koenigstein, N., and Giryes, R. (2020). Autoencoders. [https://arxiv.org/abs/2003.05991](https://arxiv.org/abs/2003.05991)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Michelucci, U. (2020). An Introduction to Autoencoders. [https://arxiv.org/abs/2201.03898](https://arxiv.org/abs/2201.03898)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: See the good code and dataset available on the TensorFlow official page. [https://mng.bz/mGQr](https://mng.bz/mGQr).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Predictive modeling is used in various domains to make future predictions using
    supervised learning algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key aspects of predictive modeling involve identifying significant variables
    or features for accurate predictions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature engineering enhances model accuracy by extracting useful features from
    raw data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature learning automates feature detection, suitable for datasets like images,
    text, and audio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoencoders are a type of neural network used for data encoding, dimensionality
    reduction, and generating synthetic data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture of autoencoders includes encoder, bottleneck, and decoder components
    for data compression and reconstruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoencoders face information loss, are dataset-specific, and are suitable for
    precise applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training autoencoders requires encoding, decoding, and defining hyperparameters
    such as code size and loss function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major applications include dimensionality reduction, anomaly detection, and
    data compression, among others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of autoencoders include undercomplete, sparse, contractive, denoizing,
    and variational.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparse and contractive autoencoders address overfitting using different methodologies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python implementation of basic autoencoder architecture involves the Keras
    library for encoding and decoding data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
