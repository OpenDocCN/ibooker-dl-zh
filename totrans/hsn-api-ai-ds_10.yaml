- en: Chapter 8\. What Data Scientists Should Know About APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with APIs for data science is a necessary skill set for all data scientists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nate Rosidi, KDnuggets
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'API expertise is critical to being an effective data scientist. But a data
    scientist can’t become an expert in every API specialty—​the field of APIs is
    nearly as wide as the field of data science. Thankfully, you don’t need to master
    every API specialty if you use the *building-block approach*: mastering one or
    two API-related skills at a time, and stacking additional skills on top of those
    as your skills grow. In my experience, the best way to acquire these building
    blocks is through hands-on coding projects that you share with the world for fast
    feedback. (That’s where the *hands-on* part of this book’s title comes from.)'
  prefs: []
  type: TYPE_NORMAL
- en: The following are some of the most useful building-block skills for data scientists.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Variety of API Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out in the wild, there are a few major API architectural styles that you may
    come across. [Chapter 2](ch02.html#chapter_2) discussed why an API provider might
    create a REST, GraphQL, or gRPC API. As an API consumer, you need to be flexible.
    This section explains how you can use whatever API style is available.
  prefs: []
  type: TYPE_NORMAL
- en: The most common API style is REST or RESTful. (For simplicity, I will use the
    terms interchangeably in this chapter.) A REST API has multiple *endpoints*, which
    are combinations of HTTP verbs and URLs. For example, to read league information
    from a football API, you might use an HTTP GET verb and the URL *[*https://api.sportsworldcentral.com/v0/leagues*](https://api.sportsworldcentral.com/v0/leagues)*.
    To create a new league, you might use a POST verb with the same URL, and pass
    along information to it in the HTTP body.
  prefs: []
  type: TYPE_NORMAL
- en: A web browser is an easy way to send a GET request to an API. For example, to
    query a fantasy football API for a specific football player record with a `player_id`
    of 1491, you could open your web browser to a fantasy sports API at *[*https://api.sportsworldcentral.com/v0/players/1491*](https://api.sportsworldcentral.com/v0/players/1491)*
    and get a result like [Figure 8-1](#get_request_ch8). This is an HTTP GET.
  prefs: []
  type: TYPE_NORMAL
- en: '![Get request of a REST API](assets/haad_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. GET request of a REST API
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To make the same request with Python, you can use the httpx library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This API returns data in JSON format, and it contains the standard fields that
    are available for this API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you called this API from the web browser or from Python, you executed
    an HTTP GET verb, which is used for reading information from an API. If you wanted
    to call a REST API to take other actions, you might use HTTP verbs such as POST,
    PUT, or DELETE. You will notice that REST APIs have separate endpoints for each
    action. For instance, this API would have separate endpoints to get a list of
    players or teams. The API defines the fields in the response, and they are the
    same for each request.
  prefs: []
  type: TYPE_NORMAL
- en: Another architectural style that is useful for data science is GraphQL, which
    has several differences from REST. Where REST APIs have multiple endpoints, a
    GraphQL API has only one. Where REST APIs return the same fields each time an
    endpoint is called, GraphQL allows the consumer to define what fields they want.
    Where REST uses an HTTP GET when reading data, GraphQL uses an HTTP POST. Since
    a web browser by default sends an HTTP GET, you can’t directly call a GraphQL
    API in the browser. However, some GraphQL APIs provide a web interface that allows
    you to query the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a request to a GraphQL API in Python, you can send a query in a POST
    command using the httpx library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is returned in JSON format and contains only the fields that you requested
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: (Thanks to Trevor Blades for his [sample GraphQL API and the example code](https://github.com/trevorblades/countries).)
  prefs: []
  type: TYPE_NORMAL
- en: The last API architectural style that I will mention is gRPC, and it is quite
    a bit different from REST or GraphQL. gRPC enables cross-language *remote procedure
    calls*, which means that your program code can call an external gRPC service like
    a local one. Data scientists are most likely to use gRPC when calling a machine
    learning model, such as a large language model.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC uses a data format called *protocol buffers* instead of JSON, and it uses
    HTTP/2, which is a different communications protocol from the HTTP/1 protocol
    that is typically used by GraphQL and REST. These two differences allow gRPC to
    have very fast communication and support two-way data streaming instead of the
    request/response communication that the other two APIs use.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code examples for calling a gRPC API are a bit too complicated to
    show in this introductory section, but a [Python quickstart](https://oreil.ly/nhwZ1)
    is available if you would like to learn more about this.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most APIs use HTTP, so it helps to learn more about it. The first tip is pretty
    simple: only use APIs with *HTTPS* in the URL—this means that all the API traffic
    will be encrypted in transit.'
  prefs: []
  type: TYPE_NORMAL
- en: Two more HTTP items to understand are HTTP verbs and HTTP status codes. HTTP
    verbs are called *methods* by the [official HTTP standards document](https://oreil.ly/m5TTp),
    which says a method “indicates the purpose for which the client has made this
    request and what is expected by the client as a successful result.”
  prefs: []
  type: TYPE_NORMAL
- en: When you call an API in a web browser, you are using a GET method, which asks
    for a read-only copy of a resource or list of resources. [Table 8-1](#HTTP_verb_table_ch8)
    lists common HTTP verbs that are used for REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. HTTP verbs and REST API usage
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb (method) | Use with APIs | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GET | Read a resource or list of resources. | GET *api.sportsworldcentral.com.com/players/*
    |'
  prefs: []
  type: TYPE_TB
- en: '| POST | Create a new resource. | PUT *api.sportsworldcentral.com.com/team/*
    |'
  prefs: []
  type: TYPE_TB
- en: '| PUT | Update an existing resource. | PUT *api.sportsworldcentral.com.com/players/1234*
    |'
  prefs: []
  type: TYPE_TB
- en: '| DELETE | Remove an existing resource. | DELETE *api.sportsworldcentral.com.com/players/1234*
    |'
  prefs: []
  type: TYPE_TB
- en: With the GET and DELETE requests in [Table 8-1](#HTTP_verb_table_ch8), the information
    in the URL is sufficient to perform the command, but POST and PUT would need information
    for creating or updating the player. This is the purpose of the HTTP message body.
    For APIs, the body contains JSON or XML data that the API uses to perform the
    action. As mentioned earlier, for GraphQL APIs, you always send a POST request,
    and the body of the message contains the query that you are sending to the API.
  prefs: []
  type: TYPE_NORMAL
- en: When the request is processed by the API’s server, it returns an HTTP response,
    which has a *status code*, a numeric code that tells you if it was able to process
    your request. If all goes well, the response will have a status code of 200—meaning
    success—and the data you asked for if you were expecting any. Success doesn’t
    always occur, and [Table 8-2](#HTTP_status_code_table_ch8) lists some other status
    codes you may encounter when calling APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. HTTP status codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Status code | Typical meaning for API calls |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2XX | Status codes beginning with 2 indicate success. |'
  prefs: []
  type: TYPE_TB
- en: '| 200 OK | The request was successful. |'
  prefs: []
  type: TYPE_TB
- en: '| 201 Created | A POST method successfully created a resource. |'
  prefs: []
  type: TYPE_TB
- en: '| 3XX | Status codes beginning with 3 indicate redirection. |'
  prefs: []
  type: TYPE_TB
- en: '| 301 or 308 Moved Permanently | The API address has moved permanently, so
    you should change your API call. |'
  prefs: []
  type: TYPE_TB
- en: '| 302 Moved Found | The API address redirected temporarily. Keep using the
    address you used. |'
  prefs: []
  type: TYPE_TB
- en: '| 4XX | Status codes beginning with 4 indicate client error. |'
  prefs: []
  type: TYPE_TB
- en: '| 400 Bad Request | Your request has an error or invalid request. |'
  prefs: []
  type: TYPE_TB
- en: '| 401 Unauthorized | Invalid credentials to make the API call. |'
  prefs: []
  type: TYPE_TB
- en: '| 404 Not Found | The resource doesn’t exist or the address is wrong. |'
  prefs: []
  type: TYPE_TB
- en: '| 5XX | Status codes beginning with 5 indicate server error. |'
  prefs: []
  type: TYPE_TB
- en: '| 500 Internal Server Error | Something failed unexpectedly on the server.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 503 Service Unavailable | Temporary issue with service. Retry may be appropriate.
    |'
  prefs: []
  type: TYPE_TB
- en: The [official HTTP standards document](https://oreil.ly/rfc_1) gives more detailed
    information about the status codes.
  prefs: []
  type: TYPE_NORMAL
- en: How to Consume APIs Responsibly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code samples earlier in this chapter show that APIs can be called easily
    with a few lines of code. This ease of use is probably one of the reasons that
    APIs have become so widespread in software development and data science.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when using APIs for real-world analysis and applications, there are additional
    items you need to consider, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the terms of service.
  prefs: []
  type: TYPE_NORMAL
- en: When using a new API, start by reading the terms of service. This will tell
    you up front what expectations and requirements the API providers have for you
    to use their API. For example, the [MyFantasyLeague API terms of service](https://oreil.ly/X3Jcf)
    state that the APIs are free to use, but they can’t be used to cheat in your fantasy
    league or harvest user data. Terms of service often list the default rate limiting
    that is in place, for example, saying that no user should make more than 1,000
    API requests per hour. This prevents one user from swamping the service, or even
    the API provider’s website if they are hosted on the same infrastructure. MyFantasyLeague
    doesn’t list specific rate limits but forbids users from overloading the service
    (even by accident) and requests that users cache slow-changing data locally to
    reduce network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Handle retries gently.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to enable an automated retry process in cases of temporary errors
    that may occur on the server side. To avoid overwhelming the service (and possibly
    getting your access disabled), consider implementing a backoff and retry process,
    as discussed in [Chapter 7](ch07.html#chapter_7).
  prefs: []
  type: TYPE_NORMAL
- en: Handle credentials safely.
  prefs: []
  type: TYPE_NORMAL
- en: Most API publishers have some method of registering users for their APIs, even
    if access is free. This allows them to monitor how you are using their APIs and
    contact you about upcoming changes to their APIs. There are a variety of API authentication
    methods used by API providers, such as usernames, passwords, API keys, secret
    keys, tokens, and others. All API credentials should be stored securely and implemented
    in your code using a secrets manager or environment variables. Credentials should
    never be stored in program code or in files that will be included in a code repository.
    If credentials get exposed somehow, deactivate them immediately and get new ones.
    Google includes additional tips in [“Best practices for securely using API keys”](https://oreil.ly/E_WRf).
  prefs: []
  type: TYPE_NORMAL
- en: Validate inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: As an API consumer, you should handle data you receive from APIs carefully,
    and consider risks such as *SQL injection*, which is when bad actors try to send
    destructive SQL commands in fields where data is expected. You should also ensure
    that the data you send to APIs fits data types they expect.
  prefs: []
  type: TYPE_NORMAL
- en: Log and diagnose errors.
  prefs: []
  type: TYPE_NORMAL
- en: If you consume an API in a recurring data pipeline, you need to handle and log
    errors. Your code should handle logging in an organized fashion, to track error
    messages and informational messages. This will be useful to debug any issues that
    you encounter and be able to verify previous executions of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Separation of Concerns: Using SDKs or Creating API Clients'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important principle in software development is *separation of concerns* (SoC),
    which means that a computer program should be broken up into chunks that perform
    a specific task. Consuming APIs responsibly may involve some fairly complicated
    logic, and code calling APIs should be separated from the rest of your code. For
    data scientists who like to build large projects in a single Jupyter Notebook,
    this may be a hard habit to adjust to. But the time it takes to implement will
    save you headaches in operation.
  prefs: []
  type: TYPE_NORMAL
- en: If the API provider publishes an SDK, you should use that. SDKs can provide
    advanced features that are created to work with a specific API. Many times, they
    are published on the [PyPI package repository](https://pypi.org) and can be installed
    using `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Python SDK created in [Chapter 7](ch07.html#chapter_7) for
    the SportsWorldCentral API could be published on PyPI. [Figure 8-2](#swcpy_pypi_ch8)
    shows how this SDK would look on the PyPI repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example SDK on PyPI](assets/haad_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Example SDK on PyPI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To use this SDK to call the API, the following Python code would be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The SDK is simple to call, but it includes advanced features such as backoff
    and retry, data validation, error handling, and logging. This is an example of
    the benefits that come from using an SDK when one is available.
  prefs: []
  type: TYPE_NORMAL
- en: If no SDK is available, you can separate your own API-calling code into a standalone
    client. You can implement the same type of functionality that an API provider’s
    SDK would contain, but it is code you will need to maintain. In [Chapter 9](ch09.html#chapter_9),
    you will create a Python client for the SWC API and use it in a Jupyter Notebook.
    You will reuse this client in [Chapter 11](ch11.html#chapter_11) to call the SWC
    API in a Streamlit data app. This demonstrates how separating your API-calling
    code into a client file saves time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: How to Build APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data scientists increasingly need to build APIs to share the work they are doing.
    For instance, you may have custom metrics you have created and you would like
    to make them available for other data scientists to use in their work. An API
    is an efficient and useful way to share this data. In addition to sharing data,
    you may have a statistical model or machine learning model that you would like
    to make available. You can create an API as an *inference endpoint*, which allows
    users to use the model to predict outcomes based on data they submit. You will
    learn this in [Chapter 12](ch12.html#chapter_12). Even if you are primarily a
    user of APIs rather than a builder, you can benefit by building a few APIs yourself
    to view from the other side of the desk. [Part I](part01.html#part_1) of this
    book is entirely focused on building APIs—check it out if you haven’t already!
  prefs: []
  type: TYPE_NORMAL
- en: How to Test APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing APIs is critical for API producers and consumers. API producers will
    perform testing throughout their development, deployment, and maintenance phases
    of hosting an API. They are responsible for ensuring that an API is reliable and
    that it lives up to customer expectations and any *service level agreements* (SLAs),
    which are formal agreements that producers make with consumers about uptime, performance,
    or other aspects of API service. API consumers will need to test APIs before using
    them in their systems to ensure that they work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: '[Postman recommends](https://oreil.ly/aET_m) four major types of API testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Contract testing
  prefs: []
  type: TYPE_NORMAL
- en: Verifies the format and behavior of each endpoint
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs: []
  type: TYPE_NORMAL
- en: Confirms the behavior of an individual endpoint
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs: []
  type: TYPE_NORMAL
- en: Tests workflows that use multiple endpoints
  prefs: []
  type: TYPE_NORMAL
- en: Load testing
  prefs: []
  type: TYPE_NORMAL
- en: Verifies performance items such as the number of concurrent requests that can
    be processed at peak times and the response time for individual requests
  prefs: []
  type: TYPE_NORMAL
- en: The pytest library is a Python testing library that is straightforward to use.
    Chapters [3](ch03.html#chapter_3) and [4](ch04.html#chapter_4) show how to use
    it to test SQLAlchemy database code and FastAPI APIs. One Python load-testing
    library is [Locust](https://locust.io). [Figure 8-3](#locust_test_ch8) shows an
    example Locust load test measuring the number of requests per second that an API
    can process with multiple concurrent users.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example Locust load test report](assets/haad_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. Example Locust load test report
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are additional types of testing beyond these four. The agile testing quadrants
    from Janet Gregory and Lisa Crispin provide a big-picture view of testing. Comprehensive
    testing includes technology-facing tests such as unit testing and performance
    testing and business-facing tests such as prototyping and usability tests. Don’t
    forget to include your API documentation and SDKs in your testing. To learn more
    about the four quadrants, read [“Quick Tools for Agile Testing”](https://oreil.ly/j1ihN).
  prefs: []
  type: TYPE_NORMAL
- en: API Deployment and Containerization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To share an API, you have to deploy it. The typical deployment model for APIs
    is using a cloud host, although if your users are strictly internal, you may be
    deploying to an on-premises server. Many cloud hosts support *containerization*,
    which is packaging your program code into a reusable package that can be run locally
    or on another server or cloud provider. Docker is the most prevalent containerization
    software. [Chapter 6](ch06.html#chapter_6) demonstrates deploying your API to
    two different clouds and containerizing your API with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Using Version Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version control is a way of tracking what changes have been made to a codebase,
    and it allows multiple people to work on the same code easily.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Catherine Nelson, *Software Engineering for Data Scientists* (O’Reilly, 2024)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This item isn’t limited to working with APIs—​it is a foundational skill that
    all data scientists will benefit from. Managing your code with version control
    will save hours of frustration when you’re working alone and really makes things
    easier when you’re working as a team. This part of the book continues the use
    of GitHub as the version control repository for your code and a place to showcase
    your work. You will also perform all of your development in GitHub Codespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Your Part II Portfolio Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this part of the book, you will create a portfolio project that demonstrates
    your ability to create analytics and other data science products that use APIs
    as a source. Here is an overview of the work ahead of you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html#chapter_9): Using APIs in data analytics products using
    Jupyter Notebooks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html#chapter_10): Using APIs in data pipelines using Apache
    Airflow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.html#chapter_11): Using APIs in a Streamlit data application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these tasks will enable you to showcase your API and data science skills
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you go through each chapter in this part, follow the instructions and create
    the code yourself. You’ll learn much more by doing this than reading alone. If
    you run into any trouble, the files in the *\complete* folder are available to
    check your work. If you would like to complete the chapters out of order, you
    can also use the completed files from the previous chapters as the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Your GitHub Codespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you did in [Part I](part01.html#part_1), you will use GitHub Codespaces for
    all the code you develop. If you didn’t create a GitHub account yet, do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the Part II Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the Part II code examples are contained in [this book’s GitHub repository](https://github.com/handsonapibook/api-book-part-two).
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone the repository, log in to GitHub and go to the [Import Repository
    page](https://github.com/new/import). Enter the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The URL for your source repository*: **`[*https://github.com/handsonapibook/api-book-part-two*](https://github.com/handsonapibook/api-book-part-two)`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your username for your source code repository*: Leave blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your access token or password for your source code repository*: Leave blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Repository name*: **`analytics-project`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Public*: Select this so that you can share the results of the work you are
    doing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Begin Import. The import process will begin and the message “Preparing
    your new repository” will be displayed. After several minutes, you will receive
    an email notifying you that your import has finished. Follow the link to your
    new cloned repository.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Your GitHub Codespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your new repository, click the Code button and select the Codespaces tab.
    Click “Create codespace on main.” You should see a page with the status “Setting
    up your codespace.” Your Codespace window will be opened as the setup continues.
    When the setup completes, your display will look similar to [Figure 8-4](#codespace_setup_complete_ch9).
  prefs: []
  type: TYPE_NORMAL
- en: '![GitHub Codespace for Part 2](assets/haad_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. GitHub Codespace for Part II
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Your Codespace is now created with the cloned repository. This is the environment
    you will be using for this part of the book. Open the [GitHub Codespaces page](https://github.com/codespaces)
    to make a couple of updates. Scroll down the page to find this new Codespace,
    click the ellipsis to the right of the name, and select Rename. Enter the name
    **Part II Portfolio project codespace** and click Save. You should see the message
    “Your codespace *Part II Portfolio project codespace* has been updated.” Click
    the ellipsis again and then click the ribbon next to “Auto-delete codespace” to
    turn off auto-deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To save screen real estate, I have trimmed the directory listing in the terminal
    prompt of the Codespace used in the examples. You can do this in your Codespace
    by editing the */home/codespace/.bashrc* file in VS Code. Find the `export PROMPT_DIRTRIM`
    statement and set it to `export PROMPT_DIRTRIM=1`. To load the values the first
    time, execute this terminal command: `source ~/.bashrc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the SportsWorldCentral (SWC) API Locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you work through the projects in Part II, you will be calling version 0.2
    of the SportsWorldCentral (SWC) API, which is in the */api* folder. Version 0.2
    has a few endpoints that you did not create in [Part I](part01.html#part_1) of
    the book. These were created to demonstrate additional functionality in data science
    and AI projects. It also has additional sample data added. You will run the API
    in your Codespace and then call it from projects that you create in Jupyter, Airflow,
    and Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-3\. Updated endpoints for the SWC Fantasy Football API v0.2
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoint description | HTTP verb | URL | Update made |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read week list | GET | */v0/weeks/* | New endpoint with max potential scoring
    |'
  prefs: []
  type: TYPE_TB
- en: '| Read counts | GET | */v0/counts/* | Added week count |'
  prefs: []
  type: TYPE_TB
- en: '| Read team list | GET | */v0/teams/* | Added `weekly_scores` for each team
    |'
  prefs: []
  type: TYPE_TB
- en: '| Read league list | GET | */v0/leagues/* | Added league size to calculate
    max scoring |'
  prefs: []
  type: TYPE_TB
- en: '| Read individual league | GET | */v0/leagues/{league_id}* | Added league size
    |'
  prefs: []
  type: TYPE_TB
- en: 'In the terminal, install the required libraries in your Codespace as shown,
    using the *requirements.txt* file that is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the FastAPI CLI was loaded so that you can run your API from the
    command line as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch the API from the command line as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see several messages from the FastAPI CLI, ending with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will see a dialog stating “Your application running on port 8000 is available,”
    as shown in [Figure 8-5](#make_api_public_ch8). Click Make Public.
  prefs: []
  type: TYPE_NORMAL
- en: '![Make API Public](assets/haad_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. Makeing the API public
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The API is now running in Codespaces with a public port. To view the API in
    the browser, click Ports in the terminal and hover your cursor over Port 8000,
    as shown in [Figure 8-6](#api_running_public_port_8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Open API on public address](assets/haad_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. Open API on a public address
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click the globe icon. The browser will show a base URL that ends in *app.github.dev*
    that contains the response from your API running on Codespaces. You should see
    the following health check message in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Your API is running publicly in the cloud. Copy this base URL. You will use
    it in later chapters to connect to your API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Later chapters in Part II will instruct you to launch your API in Codespaces.
    Follow these instructions to run the API. The API will need to be restarted each
    time you reconnect to Codespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about the features of REST, GraphQL, and gRPC, read [Chapter 2](ch02.html#chapter_2).
  prefs: []
  type: TYPE_NORMAL
- en: To learn about creating data APIs, read [Part I](part01.html#part_1) (and create
    a portfolio project).
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to package API client code and create SDKs, read [Chapter 7](ch07.html#chapter_7).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered some of the basic topics that data scientists need to know
    about APIs. You learned about major API architectural styles, including REST,
    GraphQL, and gRPC. You learned the basics of HTTP verbs and status codes. You
    learned about using APIs responsibly and the benefits of an SDK. Finally, you
    saw the value of learning to build, test, and deploy your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.html#chapter_9), you will start to dig into the details
    of these topics as you use APIs in data analytics.
  prefs: []
  type: TYPE_NORMAL
