- en: Chapter 8\. What Data Scientists Should Know About APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章\. 数据科学家应该了解的API
- en: Working with APIs for data science is a necessary skill set for all data scientists.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与API一起工作对于所有数据科学家来说是一项必要的技能集。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nate Rosidi, KDnuggets
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Nate Rosidi，KDnuggets
- en: 'API expertise is critical to being an effective data scientist. But a data
    scientist can’t become an expert in every API specialty—​the field of APIs is
    nearly as wide as the field of data science. Thankfully, you don’t need to master
    every API specialty if you use the *building-block approach*: mastering one or
    two API-related skills at a time, and stacking additional skills on top of those
    as your skills grow. In my experience, the best way to acquire these building
    blocks is through hands-on coding projects that you share with the world for fast
    feedback. (That’s where the *hands-on* part of this book’s title comes from.)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: API专业知识对于成为一名有效的数据科学家至关重要。但数据科学家不能成为每个API专业领域的专家——API领域几乎与数据科学领域一样广泛。幸运的是，如果您使用**模块化方法**，您不需要掌握每个API专业领域的知识：一次掌握一到两个API相关技能，并在您的技能增长时在这些技能之上堆叠额外的技能。根据我的经验，获取这些模块的最佳方式是通过与世界分享的动手编码项目，以获得快速反馈。（这就是本书标题中“动手”部分的原因。）
- en: The following are some of the most useful building-block skills for data scientists.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些对数据科学家最有用的模块化技能。
- en: Using a Variety of API Styles
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多种API风格
- en: Out in the wild, there are a few major API architectural styles that you may
    come across. [Chapter 2](ch02.html#chapter_2) discussed why an API provider might
    create a REST, GraphQL, or gRPC API. As an API consumer, you need to be flexible.
    This section explains how you can use whatever API style is available.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外，您可能会遇到几种主要的API架构风格。[第2章](ch02.html#chapter_2)讨论了为什么API提供商可能会创建REST、GraphQL或gRPC
    API。作为API消费者，您需要灵活。本节解释了您如何使用可用的任何API风格。
- en: The most common API style is REST or RESTful. (For simplicity, I will use the
    terms interchangeably in this chapter.) A REST API has multiple *endpoints*, which
    are combinations of HTTP verbs and URLs. For example, to read league information
    from a football API, you might use an HTTP GET verb and the URL *[*https://api.sportsworldcentral.com/v0/leagues*](https://api.sportsworldcentral.com/v0/leagues)*.
    To create a new league, you might use a POST verb with the same URL, and pass
    along information to it in the HTTP body.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的API风格是REST或RESTful。（为了简化，我在本章中将这两个术语交替使用。）REST API有多个**端点**，它们是HTTP动词和URL的组合。例如，要从足球API读取联赛信息，你可能使用HTTP
    GET动词和URL **[https://api.sportsworldcentral.com/v0/leagues](https://api.sportsworldcentral.com/v0/leagues)**。要创建一个新的联赛，你可能使用与相同URL的POST动词，并在HTTP正文中传递信息。
- en: A web browser is an easy way to send a GET request to an API. For example, to
    query a fantasy football API for a specific football player record with a `player_id`
    of 1491, you could open your web browser to a fantasy sports API at *[*https://api.sportsworldcentral.com/v0/players/1491*](https://api.sportsworldcentral.com/v0/players/1491)*
    and get a result like [Figure 8-1](#get_request_ch8). This is an HTTP GET.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网页浏览器是向API发送GET请求的一种简单方式。例如，要查询具有`player_id`为1491的特定足球球员记录的幻想足球API，您可以在网页浏览器中打开一个位于**[https://api.sportsworldcentral.com/v0/players/1491](https://api.sportsworldcentral.com/v0/players/1491)**的幻想体育API，并得到如图8-1所示的结果。这是一个HTTP
    GET请求。
- en: '![Get request of a REST API](assets/haad_0801.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![REST API的GET请求](assets/haad_0801.png)'
- en: Figure 8-1\. GET request of a REST API
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1\. REST API的GET请求
- en: 'To make the same request with Python, you can use the httpx library as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python以相同的方式发出请求，您可以使用httpx库如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This API returns data in JSON format, and it contains the standard fields that
    are available for this API endpoint.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此API以JSON格式返回数据，并包含此API端点可用的标准字段。
- en: Whether you called this API from the web browser or from Python, you executed
    an HTTP GET verb, which is used for reading information from an API. If you wanted
    to call a REST API to take other actions, you might use HTTP verbs such as POST,
    PUT, or DELETE. You will notice that REST APIs have separate endpoints for each
    action. For instance, this API would have separate endpoints to get a list of
    players or teams. The API defines the fields in the response, and they are the
    same for each request.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是从网页浏览器还是从Python调用此API，您都执行了HTTP GET动词，该动词用于从API读取信息。如果您想调用REST API执行其他操作，您可能使用HTTP动词，如POST、PUT或DELETE。您会注意到REST
    API为每个操作都有单独的端点。例如，此API将具有用于获取玩家或队伍列表的单独端点。API定义了响应中的字段，并且它们对每个请求都是相同的。
- en: Another architectural style that is useful for data science is GraphQL, which
    has several differences from REST. Where REST APIs have multiple endpoints, a
    GraphQL API has only one. Where REST APIs return the same fields each time an
    endpoint is called, GraphQL allows the consumer to define what fields they want.
    Where REST uses an HTTP GET when reading data, GraphQL uses an HTTP POST. Since
    a web browser by default sends an HTTP GET, you can’t directly call a GraphQL
    API in the browser. However, some GraphQL APIs provide a web interface that allows
    you to query the API.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种对数据科学有用的架构风格是 GraphQL，它与 REST 有几个不同之处。REST API 有多个端点，而 GraphQL API 只有一个端点。REST
    API 每次调用端点时都返回相同的字段，而 GraphQL 允许消费者定义他们想要的字段。REST 在读取数据时使用 HTTP GET，而 GraphQL
    使用 HTTP POST。由于默认情况下网络浏览器发送 HTTP GET，因此你无法直接在浏览器中调用 GraphQL API。然而，一些 GraphQL
    API 提供了一个网络界面，允许你查询该 API。
- en: 'To make a request to a GraphQL API in Python, you can send a query in a POST
    command using the httpx library as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中向 GraphQL API 发送请求，你可以使用 httpx 库通过 POST 命令发送查询，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The data is returned in JSON format and contains only the fields that you requested
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以 JSON 格式返回，并且只包含你请求的字段，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (Thanks to Trevor Blades for his [sample GraphQL API and the example code](https://github.com/trevorblades/countries).)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: (感谢 Trevor Blades 提供的 [示例 GraphQL API 和示例代码](https://github.com/trevorblades/countries)。)
- en: The last API architectural style that I will mention is gRPC, and it is quite
    a bit different from REST or GraphQL. gRPC enables cross-language *remote procedure
    calls*, which means that your program code can call an external gRPC service like
    a local one. Data scientists are most likely to use gRPC when calling a machine
    learning model, such as a large language model.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要提到的最后一个 API 架构风格是 gRPC，它与 REST 或 GraphQL 有很大不同。gRPC 允许跨语言的 *远程过程调用*，这意味着你的程序代码可以像调用本地服务一样调用外部的
    gRPC 服务。数据科学家在调用机器学习模型，如大型语言模型时，最有可能使用 gRPC。
- en: gRPC uses a data format called *protocol buffers* instead of JSON, and it uses
    HTTP/2, which is a different communications protocol from the HTTP/1 protocol
    that is typically used by GraphQL and REST. These two differences allow gRPC to
    have very fast communication and support two-way data streaming instead of the
    request/response communication that the other two APIs use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用一种称为 *协议缓冲区* 的数据格式，而不是 JSON，并且它使用 HTTP/2，这是一种与 GraphQL 和 REST 通常使用的 HTTP/1
    协议不同的通信协议。这两个差异使得 gRPC 能够实现非常快速的通信并支持双向数据流，而不是其他两个 API 所使用的请求/响应通信。
- en: The Python code examples for calling a gRPC API are a bit too complicated to
    show in this introductory section, but a [Python quickstart](https://oreil.ly/nhwZ1)
    is available if you would like to learn more about this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 gRPC API 的 Python 代码示例在这个介绍性章节中过于复杂，无法展示，但如果你想了解更多关于这个的信息，一个 [Python 快速入门](https://oreil.ly/nhwZ1)
    是可用的。
- en: HTTP Basics
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 基础
- en: 'Most APIs use HTTP, so it helps to learn more about it. The first tip is pretty
    simple: only use APIs with *HTTPS* in the URL—this means that all the API traffic
    will be encrypted in transit.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 API 使用 HTTP，因此了解它很有帮助。第一个技巧很简单：只使用 URL 中的 *HTTPS* API——这意味着所有 API 流量在传输过程中都将被加密。
- en: Two more HTTP items to understand are HTTP verbs and HTTP status codes. HTTP
    verbs are called *methods* by the [official HTTP standards document](https://oreil.ly/m5TTp),
    which says a method “indicates the purpose for which the client has made this
    request and what is expected by the client as a successful result.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 需要了解的两个更多 HTTP 项是 HTTP 动词和 HTTP 状态码。HTTP 动词在 [官方 HTTP 标准文档](https://oreil.ly/m5TTp)中被称作
    *方法*，该文档表示方法“指示客户端请求的目的以及客户端期望的成功结果。”
- en: When you call an API in a web browser, you are using a GET method, which asks
    for a read-only copy of a resource or list of resources. [Table 8-1](#HTTP_verb_table_ch8)
    lists common HTTP verbs that are used for REST APIs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网络浏览器中调用 API 时，你正在使用 GET 方法，该方法请求资源的只读副本或资源列表。[表 8-1](#HTTP_verb_table_ch8)
    列出了用于 REST API 的常见 HTTP 动词。
- en: Table 8-1\. HTTP verbs and REST API usage
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. HTTP 动词和 REST API 使用
- en: '| HTTP verb (method) | Use with APIs | Example |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 动词（方法） | 与 API 一起使用 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| GET | Read a resource or list of resources. | GET *api.sportsworldcentral.com.com/players/*
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| GET | 读取资源或资源列表。 | GET **api.sportsworldcentral.com.com/players/** |'
- en: '| POST | Create a new resource. | PUT *api.sportsworldcentral.com.com/team/*
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| POST | 创建一个新的资源。 | PUT **api.sportsworldcentral.com.com/team/** |'
- en: '| PUT | Update an existing resource. | PUT *api.sportsworldcentral.com.com/players/1234*
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| PUT | 更新现有的资源。 | PUT **api.sportsworldcentral.com.com/players/1234** |'
- en: '| DELETE | Remove an existing resource. | DELETE *api.sportsworldcentral.com.com/players/1234*
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | 删除现有资源。 | DELETE *api.sportsworldcentral.com.com/players/1234* |'
- en: With the GET and DELETE requests in [Table 8-1](#HTTP_verb_table_ch8), the information
    in the URL is sufficient to perform the command, but POST and PUT would need information
    for creating or updating the player. This is the purpose of the HTTP message body.
    For APIs, the body contains JSON or XML data that the API uses to perform the
    action. As mentioned earlier, for GraphQL APIs, you always send a POST request,
    and the body of the message contains the query that you are sending to the API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表8-1](#HTTP_verb_table_ch8)中的GET和DELETE请求中，URL中的信息足以执行命令，但POST和PUT需要信息来创建或更新玩家。这就是HTTP消息体的目的。对于API，消息体包含API用于执行操作的JSON或XML数据。如前所述，对于GraphQL
    API，你始终发送POST请求，消息体包含你发送给API的查询。
- en: When the request is processed by the API’s server, it returns an HTTP response,
    which has a *status code*, a numeric code that tells you if it was able to process
    your request. If all goes well, the response will have a status code of 200—meaning
    success—and the data you asked for if you were expecting any. Success doesn’t
    always occur, and [Table 8-2](#HTTP_status_code_table_ch8) lists some other status
    codes you may encounter when calling APIs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求由API服务器处理时，它会返回一个HTTP响应，其中包含一个*状态码*，这是一个数字代码，告诉您它是否能够处理您的请求。如果一切顺利，响应将具有状态码200——表示成功——如果您期望任何数据，则会返回您请求的数据。成功并不总是发生，[表8-2](#HTTP_status_code_table_ch8)列出了在调用API时可能遇到的某些其他状态码。
- en: Table 8-2\. HTTP status codes
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-2\. HTTP状态码
- en: '| Status code | Typical meaning for API calls |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | API调用中的典型含义 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2XX | Status codes beginning with 2 indicate success. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 2XX | 以2开头的状态码表示成功。 |'
- en: '| 200 OK | The request was successful. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 200 OK | 请求成功。 |'
- en: '| 201 Created | A POST method successfully created a resource. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 201 已创建 | POST方法成功创建了一个资源。 |'
- en: '| 3XX | Status codes beginning with 3 indicate redirection. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 3XX | 以3开头的状态码表示重定向。 |'
- en: '| 301 or 308 Moved Permanently | The API address has moved permanently, so
    you should change your API call. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 301或308 永久移动 | API地址已永久移动，因此你应该更改你的API调用。 |'
- en: '| 302 Moved Found | The API address redirected temporarily. Keep using the
    address you used. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 302 找到移动 | API地址临时重定向。继续使用您使用的地址。 |'
- en: '| 4XX | Status codes beginning with 4 indicate client error. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 4XX | 以4开头的状态码表示客户端错误。 |'
- en: '| 400 Bad Request | Your request has an error or invalid request. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 400 错误请求 | 您的请求有错误或无效请求。 |'
- en: '| 401 Unauthorized | Invalid credentials to make the API call. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 401 未授权 | 进行API调用时凭证无效。 |'
- en: '| 404 Not Found | The resource doesn’t exist or the address is wrong. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 404 未找到 | 资源不存在或地址错误。 |'
- en: '| 5XX | Status codes beginning with 5 indicate server error. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 5XX | 以5开头的状态码表示服务器错误。 |'
- en: '| 500 Internal Server Error | Something failed unexpectedly on the server.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 500 内部服务器错误 | 服务器上发生意外失败。 |'
- en: '| 503 Service Unavailable | Temporary issue with service. Retry may be appropriate.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 503 服务不可用 | 服务存在暂时性问题。重试可能合适。 |'
- en: The [official HTTP standards document](https://oreil.ly/rfc_1) gives more detailed
    information about the status codes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[官方HTTP标准文档](https://oreil.ly/rfc_1)提供了关于状态码的更详细信息。'
- en: How to Consume APIs Responsibly
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负责任地消费API
- en: The code samples earlier in this chapter show that APIs can be called easily
    with a few lines of code. This ease of use is probably one of the reasons that
    APIs have become so widespread in software development and data science.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面提供的代码示例表明，API可以通过几行代码轻松调用。这种易用性可能是API在软件开发和数据科学中变得如此普遍的原因之一。
- en: 'But when using APIs for real-world analysis and applications, there are additional
    items you need to consider, including the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但在使用API进行实际分析和应用时，需要考虑额外的项目，包括以下内容：
- en: Follow the terms of service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守服务条款。
- en: When using a new API, start by reading the terms of service. This will tell
    you up front what expectations and requirements the API providers have for you
    to use their API. For example, the [MyFantasyLeague API terms of service](https://oreil.ly/X3Jcf)
    state that the APIs are free to use, but they can’t be used to cheat in your fantasy
    league or harvest user data. Terms of service often list the default rate limiting
    that is in place, for example, saying that no user should make more than 1,000
    API requests per hour. This prevents one user from swamping the service, or even
    the API provider’s website if they are hosted on the same infrastructure. MyFantasyLeague
    doesn’t list specific rate limits but forbids users from overloading the service
    (even by accident) and requests that users cache slow-changing data locally to
    reduce network traffic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用新的API时，首先阅读服务条款。这将提前告诉您API提供商对您使用他们的API有什么期望和要求。例如，[MyFantasyLeague API服务条款](https://oreil.ly/X3Jcf)声明API是免费使用的，但不能用于在您的幻想联赛中作弊或收集用户数据。服务条款通常会列出默认的速率限制，例如，表示用户每小时不应发出超过1,000次API请求。这防止了一个用户淹没服务，或者如果它们托管在相同的基础设施上，甚至可能淹没API提供商的网站。MyFantasyLeague没有列出具体的速率限制，但禁止用户过载服务（即使是不小心造成的）并要求用户将缓慢变化的数据本地缓存以减少网络流量。
- en: Handle retries gently.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 轻柔地处理重试。
- en: You may want to enable an automated retry process in cases of temporary errors
    that may occur on the server side. To avoid overwhelming the service (and possibly
    getting your access disabled), consider implementing a backoff and retry process,
    as discussed in [Chapter 7](ch07.html#chapter_7).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端可能出现的临时错误情况下，您可能希望启用自动重试过程。为了避免服务过载（并可能使您的访问权限被禁用），请考虑实施退避和重试过程，如第7章[第7章](ch07.html#chapter_7)中所述。
- en: Handle credentials safely.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 安全地处理凭证。
- en: Most API publishers have some method of registering users for their APIs, even
    if access is free. This allows them to monitor how you are using their APIs and
    contact you about upcoming changes to their APIs. There are a variety of API authentication
    methods used by API providers, such as usernames, passwords, API keys, secret
    keys, tokens, and others. All API credentials should be stored securely and implemented
    in your code using a secrets manager or environment variables. Credentials should
    never be stored in program code or in files that will be included in a code repository.
    If credentials get exposed somehow, deactivate them immediately and get new ones.
    Google includes additional tips in [“Best practices for securely using API keys”](https://oreil.ly/E_WRf).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数API发布者都有一些方法为他们的API注册用户，即使访问是免费的。这使他们能够监控您如何使用他们的API，并就他们API的即将到来的更改与您联系。API提供商使用各种API身份验证方法，例如用户名、密码、API密钥、密钥、令牌等。所有API凭证都应安全存储，并在代码中使用密钥管理器或环境变量实现。凭证绝不应存储在程序代码中或包含在代码库中的文件中。如果凭证以某种方式被泄露，应立即停用它们并获取新的凭证。Google在[“安全使用API密钥的最佳实践”](https://oreil.ly/E_WRf)中提供了额外的提示。
- en: Validate inputs and outputs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 验证输入和输出。
- en: As an API consumer, you should handle data you receive from APIs carefully,
    and consider risks such as *SQL injection*, which is when bad actors try to send
    destructive SQL commands in fields where data is expected. You should also ensure
    that the data you send to APIs fits data types they expect.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为API消费者，您应该小心处理从API接收到的数据，并考虑风险，例如*SQL注入*，这是当恶意行为者试图在预期数据字段中发送破坏性的SQL命令时。您还应该确保发送给API的数据符合它们期望的数据类型。
- en: Log and diagnose errors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记录和诊断错误。
- en: If you consume an API in a recurring data pipeline, you need to handle and log
    errors. Your code should handle logging in an organized fashion, to track error
    messages and informational messages. This will be useful to debug any issues that
    you encounter and be able to verify previous executions of your code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您在重复数据管道中消费API，您需要处理和记录错误。您的代码应该以有组织的方式处理日志记录，以跟踪错误消息和信息性消息。这将有助于调试您遇到的任何问题，并能够验证您代码的先前执行。 '
- en: 'Separation of Concerns: Using SDKs or Creating API Clients'
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点的分离：使用SDK或创建API客户端
- en: An important principle in software development is *separation of concerns* (SoC),
    which means that a computer program should be broken up into chunks that perform
    a specific task. Consuming APIs responsibly may involve some fairly complicated
    logic, and code calling APIs should be separated from the rest of your code. For
    data scientists who like to build large projects in a single Jupyter Notebook,
    this may be a hard habit to adjust to. But the time it takes to implement will
    save you headaches in operation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的一个重要原则是 *关注点分离*（SoC），这意味着计算机程序应该被分解成执行特定任务的块。负责任地使用 API 可能会涉及一些相当复杂的逻辑，调用
    API 的代码应该与你的其他代码分离。对于喜欢在单个 Jupyter Notebook 中构建大型项目的数据科学家来说，这可能是一个难以调整的习惯。但实现所需的时间将节省你在操作中的麻烦。
- en: If the API provider publishes an SDK, you should use that. SDKs can provide
    advanced features that are created to work with a specific API. Many times, they
    are published on the [PyPI package repository](https://pypi.org) and can be installed
    using `pip`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 API 提供商发布了 SDK，你应该使用它。SDK 可以提供为与特定 API 一起使用而创建的高级功能。很多时候，它们发布在 [PyPI 软件包仓库](https://pypi.org)
    上，并可以使用 `pip` 进行安装。
- en: For example, the Python SDK created in [Chapter 7](ch07.html#chapter_7) for
    the SportsWorldCentral API could be published on PyPI. [Figure 8-2](#swcpy_pypi_ch8)
    shows how this SDK would look on the PyPI repository.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为 SportsWorldCentral API 在 [第 7 章](ch07.html#chapter_7) 中创建的 Python SDK 可以发布在
    PyPI 上。[图 8-2](#swcpy_pypi_ch8) 展示了此 SDK 在 PyPI 仓库中的样子。
- en: '![Example SDK on PyPI](assets/haad_0802.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![PyPI 上的示例 SDK](assets/haad_0802.png)'
- en: Figure 8-2\. Example SDK on PyPI
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. PyPI 上的示例 SDK
- en: 'To use this SDK to call the API, the following Python code would be used:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此 SDK 调用 API，以下 Python 代码将被使用：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The SDK is simple to call, but it includes advanced features such as backoff
    and retry, data validation, error handling, and logging. This is an example of
    the benefits that come from using an SDK when one is available.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 调用简单，但它包括诸如回退和重试、数据验证、错误处理和日志记录等高级功能。这是当有 SDK 可用时的好处示例。
- en: If no SDK is available, you can separate your own API-calling code into a standalone
    client. You can implement the same type of functionality that an API provider’s
    SDK would contain, but it is code you will need to maintain. In [Chapter 9](ch09.html#chapter_9),
    you will create a Python client for the SWC API and use it in a Jupyter Notebook.
    You will reuse this client in [Chapter 11](ch11.html#chapter_11) to call the SWC
    API in a Streamlit data app. This demonstrates how separating your API-calling
    code into a client file saves time and effort.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 SDK 可用，你可以将你自己的 API 调用代码分离成一个独立的客户端。你可以实现 API 提供商的 SDK 将包含的相同类型的功能，但这将是你需要维护的代码。你将在
    [第 9 章](ch09.html#chapter_9) 中创建 SWC API 的 Python 客户端，并在 Jupyter Notebook 中使用它。你将在
    [第 11 章](ch11.html#chapter_11) 中重用此客户端，在 Streamlit 数据应用中调用 SWC API。这展示了如何将你的 API
    调用代码分离到客户端文件中可以节省时间和精力。
- en: How to Build APIs
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何构建 API
- en: Data scientists increasingly need to build APIs to share the work they are doing.
    For instance, you may have custom metrics you have created and you would like
    to make them available for other data scientists to use in their work. An API
    is an efficient and useful way to share this data. In addition to sharing data,
    you may have a statistical model or machine learning model that you would like
    to make available. You can create an API as an *inference endpoint*, which allows
    users to use the model to predict outcomes based on data they submit. You will
    learn this in [Chapter 12](ch12.html#chapter_12). Even if you are primarily a
    user of APIs rather than a builder, you can benefit by building a few APIs yourself
    to view from the other side of the desk. [Part I](part01.html#part_1) of this
    book is entirely focused on building APIs—check it out if you haven’t already!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家越来越需要构建 API 来分享他们正在进行的工作。例如，你可能已经创建了自定义指标，并希望让其他数据科学家能够在他们的工作中使用这些指标。API
    是共享这些数据的一种高效且实用的方式。除了共享数据之外，你可能还有一个你希望使其可用的统计模型或机器学习模型。你可以创建一个作为 *推理端点* 的 API，允许用户使用他们提交的数据来预测结果。你将在
    [第 12 章](ch12.html#chapter_12) 中学习这一点。即使你主要是 API 的使用者而不是构建者，通过自己构建一些 API 来从桌子的另一边观察，你也能从中受益。[本书的第一部分](part01.html#part_1)
    完全专注于构建 API——如果你还没有看过，不妨去看看！
- en: How to Test APIs
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何测试 API
- en: Testing APIs is critical for API producers and consumers. API producers will
    perform testing throughout their development, deployment, and maintenance phases
    of hosting an API. They are responsible for ensuring that an API is reliable and
    that it lives up to customer expectations and any *service level agreements* (SLAs),
    which are formal agreements that producers make with consumers about uptime, performance,
    or other aspects of API service. API consumers will need to test APIs before using
    them in their systems to ensure that they work as intended.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对 API 进行测试对于 API 生产者和消费者至关重要。API 生产者将在他们的 API 开发、部署和维护阶段进行测试。他们负责确保 API 的可靠性，并满足客户期望以及任何
    *服务级别协议*（SLAs），这些是生产者与消费者就正常运行时间、性能或其他 API 服务方面达成的正式协议。API 消费者在使用 API 之前需要对其进行测试，以确保它们按预期工作。
- en: '[Postman recommends](https://oreil.ly/aET_m) four major types of API testing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[Postman 推荐的](https://oreil.ly/aET_m) 四种主要类型的 API 测试：'
- en: Contract testing
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 合同测试
- en: Verifies the format and behavior of each endpoint
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 验证每个端点的格式和行为
- en: Unit testing
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: Confirms the behavior of an individual endpoint
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 确认单个端点的行为
- en: End-to-end testing
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Tests workflows that use multiple endpoints
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用多个端点的流程
- en: Load testing
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试
- en: Verifies performance items such as the number of concurrent requests that can
    be processed at peak times and the response time for individual requests
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 验证性能指标，例如在高峰时段可以处理的并发请求数量和单个请求的响应时间
- en: The pytest library is a Python testing library that is straightforward to use.
    Chapters [3](ch03.html#chapter_3) and [4](ch04.html#chapter_4) show how to use
    it to test SQLAlchemy database code and FastAPI APIs. One Python load-testing
    library is [Locust](https://locust.io). [Figure 8-3](#locust_test_ch8) shows an
    example Locust load test measuring the number of requests per second that an API
    can process with multiple concurrent users.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: pytest 库是一个易于使用的 Python 测试库。第 [3](ch03.html#chapter_3) 章和 [4](ch04.html#chapter_4)
    章展示了如何使用它来测试 SQLAlchemy 数据库代码和 FastAPI API。一个 Python 压力测试库是 [Locust](https://locust.io)。[图
    8-3](#locust_test_ch8) 展示了一个 Locust 压力测试示例，测量 API 在多个并发用户下每秒可以处理多少个请求。
- en: '![Example Locust load test report](assets/haad_0803.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![示例 Locust 压力测试报告](assets/haad_0803.png)'
- en: Figure 8-3\. Example Locust load test report
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. 示例 Locust 压力测试报告
- en: There are additional types of testing beyond these four. The agile testing quadrants
    from Janet Gregory and Lisa Crispin provide a big-picture view of testing. Comprehensive
    testing includes technology-facing tests such as unit testing and performance
    testing and business-facing tests such as prototyping and usability tests. Don’t
    forget to include your API documentation and SDKs in your testing. To learn more
    about the four quadrants, read [“Quick Tools for Agile Testing”](https://oreil.ly/j1ihN).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这四种类型之外，还有其他类型的测试。珍妮特·格雷戈里和丽莎·克里平的敏捷测试象限提供了一个宏观的测试视角。全面测试包括面向技术的测试，如单元测试和性能测试，以及面向业务的测试，如原型设计和可用性测试。不要忘记将您的
    API 文档和 SDK 包含在测试中。要了解更多关于四个象限的信息，请阅读“敏捷测试的快速工具”（https://oreil.ly/j1ihN）。
- en: API Deployment and Containerization
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 部署和容器化
- en: To share an API, you have to deploy it. The typical deployment model for APIs
    is using a cloud host, although if your users are strictly internal, you may be
    deploying to an on-premises server. Many cloud hosts support *containerization*,
    which is packaging your program code into a reusable package that can be run locally
    or on another server or cloud provider. Docker is the most prevalent containerization
    software. [Chapter 6](ch06.html#chapter_6) demonstrates deploying your API to
    two different clouds and containerizing your API with Docker.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要共享 API，您必须部署它。API 的典型部署模型是使用云主机，尽管如果您的用户是严格内部用户，您可能需要部署到本地服务器。许多云主机支持 *容器化*，即将您的程序代码打包成一个可重复使用的包，可以在本地或另一台服务器或云提供商上运行。Docker
    是最流行的容器化软件。[第 6](ch06.html#chapter_6) 章展示了如何将您的 API 部署到两个不同的云平台，并使用 Docker 容器化您的
    API。
- en: Using Version Control
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本控制
- en: Version control is a way of tracking what changes have been made to a codebase,
    and it allows multiple people to work on the same code easily.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 版本控制是一种跟踪代码库中已进行更改的方式，并允许多个人轻松地对同一代码进行工作。
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Catherine Nelson, *Software Engineering for Data Scientists* (O’Reilly, 2024)
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 凯瑟琳·尼尔森，《数据科学家软件工程》（O’Reilly，2024）
- en: This item isn’t limited to working with APIs—​it is a foundational skill that
    all data scientists will benefit from. Managing your code with version control
    will save hours of frustration when you’re working alone and really makes things
    easier when you’re working as a team. This part of the book continues the use
    of GitHub as the version control repository for your code and a place to showcase
    your work. You will also perform all of your development in GitHub Codespaces.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目不仅限于与API一起工作——它是一项所有数据科学家都将受益的基础技能。使用版本控制管理您的代码，当您单独工作时可以节省数小时的不满，当您作为团队工作时，这会使事情变得更容易。本书的这一部分继续使用GitHub作为您的代码版本控制仓库和展示您工作的场所。您也将所有开发工作都在GitHub
    Codespaces中完成。
- en: Introducing Your Part II Portfolio Project
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍您的第二部分项目组合
- en: 'In this part of the book, you will create a portfolio project that demonstrates
    your ability to create analytics and other data science products that use APIs
    as a source. Here is an overview of the work ahead of you:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，您将创建一个项目组合，以展示您创建使用API作为数据源的分析和其他数据科学产品的能力。以下是您接下来要完成的工作概述：
- en: '[Chapter 9](ch09.html#chapter_9): Using APIs in data analytics products using
    Jupyter Notebooks'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html#chapter_9)：使用Jupyter Notebooks在数据分析产品中使用API'
- en: '[Chapter 10](ch10.html#chapter_10): Using APIs in data pipelines using Apache
    Airflow'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html#chapter_10)：使用Apache Airflow在数据管道中使用API'
- en: '[Chapter 11](ch11.html#chapter_11): Using APIs in a Streamlit data application'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11章](ch11.html#chapter_11)：在Streamlit数据应用中使用API'
- en: Each of these tasks will enable you to showcase your API and data science skills
    differently.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务中的每一个都将使您能够以不同的方式展示您的API和数据科学技能。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: As you go through each chapter in this part, follow the instructions and create
    the code yourself. You’ll learn much more by doing this than reading alone. If
    you run into any trouble, the files in the *\complete* folder are available to
    check your work. If you would like to complete the chapters out of order, you
    can also use the completed files from the previous chapters as the starting point.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在您浏览本部分的每一章时，请遵循说明并自行编写代码。通过这样做，您会比单独阅读学到更多。如果您遇到任何问题，*\complete*文件夹中的文件可供您检查工作。如果您想按顺序完成章节，您也可以使用前几章的完成文件作为起点。
- en: Getting Started with Your GitHub Codespace
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用您的GitHub Codespace
- en: As you did in [Part I](part01.html#part_1), you will use GitHub Codespaces for
    all the code you develop. If you didn’t create a GitHub account yet, do that now.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第一部分](part01.html#part_1)中所做的那样，您将使用GitHub Codespaces来开发所有代码。如果您还没有创建GitHub账户，请现在创建一个。
- en: Cloning the Part II Repository
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆第二部分仓库
- en: All of the Part II code examples are contained in [this book’s GitHub repository](https://github.com/handsonapibook/api-book-part-two).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分的所有代码示例都包含在本书的GitHub仓库中[这里](https://github.com/handsonapibook/api-book-part-two)。
- en: 'To clone the repository, log in to GitHub and go to the [Import Repository
    page](https://github.com/new/import). Enter the following information:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要克隆仓库，请登录GitHub并转到[导入仓库页面](https://github.com/new/import)。输入以下信息：
- en: '*The URL for your source repository*: **`[*https://github.com/handsonapibook/api-book-part-two*](https://github.com/handsonapibook/api-book-part-two)`**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的源代码仓库的URL*：**`[*https://github.com/handsonapibook/api-book-part-two*](https://github.com/handsonapibook/api-book-part-two)`**'
- en: '*Your username for your source code repository*: Leave blank.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的源代码仓库的用户名*：留空。'
- en: '*Your access token or password for your source code repository*: Leave blank.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的源代码仓库的访问令牌或密码*：留空。'
- en: '*Repository name*: **`analytics-project`**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仓库名称*：**`analytics-project`**'
- en: '*Public*: Select this so that you can share the results of the work you are
    doing.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公开*：选择此选项，以便您可以分享您正在完成的工作的结果。'
- en: Click Begin Import. The import process will begin and the message “Preparing
    your new repository” will be displayed. After several minutes, you will receive
    an email notifying you that your import has finished. Follow the link to your
    new cloned repository.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“开始导入”。导入过程将开始，并显示“准备您的新的仓库”的消息。几分钟后，您将收到一封电子邮件通知您导入已完成。点击链接访问您的新克隆仓库。
- en: Launching Your GitHub Codespace
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动您的GitHub Codespace
- en: In your new repository, click the Code button and select the Codespaces tab.
    Click “Create codespace on main.” You should see a page with the status “Setting
    up your codespace.” Your Codespace window will be opened as the setup continues.
    When the setup completes, your display will look similar to [Figure 8-4](#codespace_setup_complete_ch9).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的新仓库中，点击代码按钮并选择 Codespaces 选项卡。点击“在主分支上创建 codespace”。您应该会看到一个状态为“设置您的 codespace”的页面。当设置完成时，您的
    Codespace 窗口将打开。设置完成后，您的显示将类似于 [图 8-4](#codespace_setup_complete_ch9)。
- en: '![GitHub Codespace for Part 2](assets/haad_0804.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![第二部分 GitHub Codespace](assets/haad_0804.png)'
- en: Figure 8-4\. GitHub Codespace for Part II
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. 第二部分的 GitHub Codespace
- en: Your Codespace is now created with the cloned repository. This is the environment
    you will be using for this part of the book. Open the [GitHub Codespaces page](https://github.com/codespaces)
    to make a couple of updates. Scroll down the page to find this new Codespace,
    click the ellipsis to the right of the name, and select Rename. Enter the name
    **Part II Portfolio project codespace** and click Save. You should see the message
    “Your codespace *Part II Portfolio project codespace* has been updated.” Click
    the ellipsis again and then click the ribbon next to “Auto-delete codespace” to
    turn off auto-deletion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Codespace 已创建，并克隆了仓库。这是您将用于本书这一部分的开发环境。打开 [GitHub Codespaces 页面](https://github.com/codespaces)
    进行一些更新。滚动页面以找到这个新的 Codespace，点击名称右侧的省略号，并选择重命名。输入名称 **第二部分投资组合项目 codespace** 并点击保存。您应该会看到消息“您的
    codespace *第二部分投资组合项目 codespace* 已更新。”再次点击省略号，然后点击“自动删除 codespace”旁边的彩带以关闭自动删除功能。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'To save screen real estate, I have trimmed the directory listing in the terminal
    prompt of the Codespace used in the examples. You can do this in your Codespace
    by editing the */home/codespace/.bashrc* file in VS Code. Find the `export PROMPT_DIRTRIM`
    statement and set it to `export PROMPT_DIRTRIM=1`. To load the values the first
    time, execute this terminal command: `source ~/.bashrc`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省屏幕空间，我在示例中使用的 Codespace 的终端提示符中的目录列表进行了裁剪。您可以在您的 Codespace 中通过编辑 VS Code
    中的 */home/codespace/.bashrc* 文件来实现这一点。找到 `export PROMPT_DIRTRIM` 语句并将其设置为 `export
    PROMPT_DIRTRIM=1`。要首次加载这些值，请执行以下终端命令：`source ~/.bashrc`。
- en: Running the SportsWorldCentral (SWC) API Locally
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行 SportsWorldCentral (SWC) API
- en: As you work through the projects in Part II, you will be calling version 0.2
    of the SportsWorldCentral (SWC) API, which is in the */api* folder. Version 0.2
    has a few endpoints that you did not create in [Part I](part01.html#part_1) of
    the book. These were created to demonstrate additional functionality in data science
    and AI projects. It also has additional sample data added. You will run the API
    in your Codespace and then call it from projects that you create in Jupyter, Airflow,
    and Streamlit.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成第二部分的项目时，您将调用 SportsWorldCentral (SWC) API 的 0.2 版本，该版本位于 */api* 文件夹中。0.2
    版本有几个端点，您在书的 [第一部分](part01.html#part_1) 中没有创建。这些端点是为了展示数据科学和 AI 项目中的附加功能而创建的。它还添加了额外的示例数据。您将在您的
    Codespace 中运行 API，然后从您在 Jupyter、Airflow 和 Streamlit 中创建的项目中调用它。
- en: Table 8-3\. Updated endpoints for the SWC Fantasy Football API v0.2
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-3\. SWC 梦想足球 API v0.2 更新的端点
- en: '| Endpoint description | HTTP verb | URL | Update made |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 端点描述 | HTTP 动词 | URL | 更新内容 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Read week list | GET | */v0/weeks/* | New endpoint with max potential scoring
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 阅读周列表 | GET | */v0/weeks/* | 新增具有最大潜在得分的端点 |'
- en: '| Read counts | GET | */v0/counts/* | Added week count |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 阅读计数 | GET | */v0/counts/* | 添加周计数 |'
- en: '| Read team list | GET | */v0/teams/* | Added `weekly_scores` for each team
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 阅读团队列表 | GET | */v0/teams/* | 为每个团队添加 `weekly_scores` |'
- en: '| Read league list | GET | */v0/leagues/* | Added league size to calculate
    max scoring |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 阅读联赛列表 | GET | */v0/leagues/* | 添加联赛规模以计算最大得分 |'
- en: '| Read individual league | GET | */v0/leagues/{league_id}* | Added league size
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 阅读单个联赛 | GET | */v0/leagues/{league_id}* | 添加联赛规模 |'
- en: 'In the terminal, install the required libraries in your Codespace as shown,
    using the *requirements.txt* file that is provided:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，按照所示使用提供的 *requirements.txt* 文件安装所需的库：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Verify that the FastAPI CLI was loaded so that you can run your API from the
    command line as shown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 FastAPI CLI 是否已加载，以便您可以从命令行运行您的 API，如下所示：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now launch the API from the command line as shown:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下所示从命令行启动 API：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will see several messages from the FastAPI CLI, ending with the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到来自 FastAPI CLI 的几条消息，最后以以下内容结束：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will see a dialog stating “Your application running on port 8000 is available,”
    as shown in [Figure 8-5](#make_api_public_ch8). Click Make Public.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个对话框，显示“您的运行在端口8000的应用程序可供访问”，如图[图8-5](#make_api_public_ch8)所示。点击“公开”。
- en: '![Make API Public](assets/haad_0805.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![公开API](assets/haad_0805.png)'
- en: Figure 8-5\. Makeing the API public
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-5\. 使API公开
- en: The API is now running in Codespaces with a public port. To view the API in
    the browser, click Ports in the terminal and hover your cursor over Port 8000,
    as shown in [Figure 8-6](#api_running_public_port_8).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: API现在在Codespaces中以公共端口运行。要在浏览器中查看API，请在终端中点击“端口”，并将鼠标悬停在8000端口上，如图[图8-6](#api_running_public_port_8)所示。
- en: '![Open API on public address](assets/haad_0806.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![公共地址上的开放API](assets/haad_0806.png)'
- en: Figure 8-6\. Open API on a public address
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-6\. 公共地址上的开放API
- en: 'Click the globe icon. The browser will show a base URL that ends in *app.github.dev*
    that contains the response from your API running on Codespaces. You should see
    the following health check message in your web browser:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 点击地球图标。浏览器将显示以*app.github.dev*结尾的基本URL，其中包含在Codespaces上运行的API的响应。您应该在您的网络浏览器中看到以下健康检查消息：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Your API is running publicly in the cloud. Copy this base URL. You will use
    it in later chapters to connect to your API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API正在云中公开运行。复制此基本URL。您将在后续章节中使用它来连接到您的API。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Later chapters in Part II will instruct you to launch your API in Codespaces.
    Follow these instructions to run the API. The API will need to be restarted each
    time you reconnect to Codespaces.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分后面的章节将指导您在Codespaces中启动API。按照以下说明运行API。每次您重新连接到Codespaces时，都需要重新启动API。
- en: Additional Resources
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: To learn more about the features of REST, GraphQL, and gRPC, read [Chapter 2](ch02.html#chapter_2).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于REST、GraphQL和gRPC的功能，请阅读[第2章](ch02.html#chapter_2)。
- en: To learn about creating data APIs, read [Part I](part01.html#part_1) (and create
    a portfolio project).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何创建数据API，请阅读[第一部分](part01.html#part_1)（并创建一个项目组合）。
- en: To learn how to package API client code and create SDKs, read [Chapter 7](ch07.html#chapter_7).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何打包API客户端代码并创建SDK，请阅读[第7章](ch07.html#chapter_7)。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered some of the basic topics that data scientists need to know
    about APIs. You learned about major API architectural styles, including REST,
    GraphQL, and gRPC. You learned the basics of HTTP verbs and status codes. You
    learned about using APIs responsibly and the benefits of an SDK. Finally, you
    saw the value of learning to build, test, and deploy your APIs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了数据科学家需要了解的一些关于API的基本主题。您了解了主要的API架构风格，包括REST、GraphQL和gRPC。您学习了HTTP动词和状态码的基础知识。您了解了负责任地使用API以及SDK的好处。最后，您看到了学习构建、测试和部署API的价值。
- en: In [Chapter 9](ch09.html#chapter_9), you will start to dig into the details
    of these topics as you use APIs in data analytics.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html#chapter_9)中，您将开始深入了解这些主题的细节，同时使用API进行数据分析。
