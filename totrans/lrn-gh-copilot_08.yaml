- en: Chapter 7\. Keeping Copilot Timely and Relevant
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章：保持Copilot及时和相关性
- en: The range of functionality and interactivity provided by GitHub Copilot is truly
    impressive. However, the responses it generates can sometimes be less impressive
    (and less useful) if they are not timely and relevant. As good as the AI can be,
    at times you may need to take extra steps to *steer* it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot提供的功能范围和交互性真正令人印象深刻。然而，如果它们不及时且不相关，它生成的响应有时可能不那么令人印象深刻（也不那么有用）。尽管AI可能很好，但有时您可能需要采取额外步骤来*引导*它。
- en: For example, in certain instances, you may need to direct Copilot to focus on
    certain portions of your content to get targeted answers. Or you may need to augment
    its training to get responses more relevant to your codebase. And you may need
    to pay extra attention to be aware when Copilot is suggesting code that may be
    out of date or referencing features that are no longer supported.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在某些情况下，您可能需要指示Copilot关注您内容中的特定部分以获得针对性的答案。或者您可能需要增强其训练以获得与您的代码库更相关的响应。您可能还需要特别注意，以便在Copilot建议的代码可能过时或引用不再受支持的特性时能够意识到。
- en: In this chapter, we’re going to look at how to manage interaction with Copilot
    in these situations. You can leverage certain strategies and functionality to
    help ensure relevancy and timeliness in your interactions with Copilot. Certain
    approaches can compensate when Copilot may not be aware of recent changes or referencing
    the right sources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在这些情况下管理与Copilot的交互。您可以利用某些策略和功能来帮助确保与Copilot的交互具有相关性和及时性。某些方法可以在Copilot可能没有意识到最近的变化或引用正确的来源时进行补偿。
- en: 'All of this is aimed at helping Copilot have the most usable set of context
    in order to provide the most useful responses for what we’re asking of it. In
    the next few pages, we’ll look at the following areas related to Copilot’s use
    of context:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些旨在帮助Copilot拥有最可用的上下文集，以便为我们所请求的提供最有用的响应。在接下来的几页中，我们将探讨与Copilot使用上下文相关的以下领域：
- en: Where context originates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文起源
- en: How timeliness and relevancy may be affected
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 及时性和相关性可能受到的影响
- en: User-based coping strategies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户的应对策略
- en: Adding context to make code more relevant
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加上下文以使代码更具相关性
- en: By its very definition, *generative* implies generating new content in part
    based on gathering and processing context. So, let’s start with a reminder of
    where the context that Copilot uses comes from.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其定义，*生成性*意味着在部分基于收集和处理上下文的基础上生成新内容。因此，让我们先回顾一下Copilot使用的上下文来源。
- en: Where Context Originates
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文起源
- en: As we’ve discussed in previous chapters, in the IDE, Copilot draws context from
    your immediate working environment—specifically, from the files you have in your
    workspace and the content associated with them. This includes typical items like
    the name of the file, the comments in them, and the code before and after the
    cursor. But Copilot also draws from more dynamic interactions, such as whether
    or not you accepted its last code suggestion. And by automatically creating an
    index of your repository, Copilot gains a larger understanding of your project.
    Copilot can also be directed to take other content into consideration.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中讨论的那样，在IDE中，Copilot从您的即时工作环境中获取上下文——具体来说，是从您工作区中的文件及其相关内容中获取。这包括典型的项目，如文件名、其中的注释以及光标前后方的代码。但Copilot还可以从更动态的交互中获取信息，例如您是否接受了它最后的代码建议。通过自动创建您的仓库索引，Copilot可以更深入地理解您的项目。Copilot还可以被指示考虑其他内容。
- en: For quickly generating coding suggestions in your IDE/editor, targeting the
    files you have open is a useful strategy used by Copilot. The focus allows it
    to quickly get a good sense of what is presumably most important (since you have
    those files readily accessible).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在IDE/编辑器中快速生成编码建议，针对您打开的文件是一种Copilot使用的有用策略。这种关注使它能够快速获得一个良好的感觉，了解哪些内容可能是最重要的（因为您可以轻松访问这些文件）。
- en: In this *inline* mode, Copilot uses multiple strategies to ensure a fast response.
    The client (extension installed in your interface) asks the model for very few
    suggestions (one to three). Copilot is aggressive in caching results and adapts
    the suggestions if you continue typing. It also has some built-in checks, preventing
    sending requests if you are typing in the middle of a line, for example, unless
    there is whitespace to the right of the cursor. Then the index we’ve discussed
    is updated based on changes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在此*内联*模式下，Copilot使用多种策略来确保快速响应。客户端（安装在您界面中的扩展）向模型请求非常少的建议（一到三个）。Copilot在缓存结果方面非常积极，并在您继续输入时调整建议。它还有一些内置的检查，例如，如果您在行中输入时，它会阻止发送请求，除非光标右侧有空格。然后，我们讨论的索引会根据变化进行更新。
- en: In this mode, scoring also happens to determine whether the prompt assembled
    to send to the model is even worthwhile (worth invoking the model). This decision
    is based on factors like previous responses to suggestions. This approach helps
    exclude repetitive prompts or ones that already exist in the code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，评分还会决定要发送给模型的提示是否甚至值得（值得调用模型）。此决定基于诸如对建议的先前响应等因素。这种方法有助于排除重复的提示或已在代码中存在的提示。
- en: Most of these same strategies are not needed when you switch to the chat interface.
    Within that, Copilot has more time to come up with responses, and so more completion
    suggestions can be requested by the client. For gathering context when working
    in this interface, you can also be more directive of where to get the context.
    Copilot includes methods like chat variables and chat participants (as discussed
    in [Chapter 3](ch03.html#ch03) and other chapters) to focus Copilot on particular
    items.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当您切换到聊天界面时，大多数这些策略都不需要。在此界面中，Copilot有更多时间来生成响应，因此客户端可以请求更多的完成建议。在处理此界面时收集上下文时，您还可以更具体地指示从哪里获取上下文。Copilot包括聊天变量和聊天参与者（如第3章和其他章节中所述）等方法，以使Copilot专注于特定项目。
- en: Regardless of where the user is working, the client collects the context, processes
    it into a prompt, and sends it to the model you’ve selected. After doing some
    quick validation of what the model returns and generating the requested set of
    responses, those are then displayed to the user. The responses can include multiple
    options in the IDE if multiple completion suggestions were available.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不论用户在何处工作，客户端都会收集上下文，将其处理成提示，并发送到您选择的模型。在快速验证模型返回的内容并生成所需的一系列响应后，这些响应将显示给用户。如果有多项完成建议可用，响应可以在IDE中包括多个选项。
- en: The *quick validation* just referred to involves quickly looking for patterns
    in the response that are repetitive or might indicate a security issue (such as
    hardcoded credentials). These are beneficial checks, but they don’t prevent other
    factors that may lead to relevancy and timeliness being off. Let’s look at some
    of those other factors next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚才提到的快速验证，它涉及快速查找响应中的重复模式或可能表明安全问题（如硬编码凭据）的模式。这些检查是有益的，但它们不能防止可能导致相关性和及时性偏差的其他因素。接下来，让我们看看这些其他因素。
- en: How Timeliness and Relevancy May Be Affected
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 及时性和相关性可能受到影响的方式
- en: 'When you first open up Copilot’s chat interface, you get a notification:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次打开Copilot的聊天界面时，您会收到一个通知：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This disclaimer is a reminder that generative AI can be inaccurate and problematic.
    Ultimately, it’s up to the user to ensure that the generated content is correct
    and relevant. (This is also why you should always use standard validation methods
    like testing and code reviews to check any content produced with the assistance
    of the AI.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此免责声明是对生成式AI可能不准确和存在问题的提醒。最终，确保生成的内容正确且相关的是用户的责任。（这也是为什么您应该始终使用标准验证方法，如测试和代码审查，来检查任何使用AI辅助生成的内容的理由。）
- en: 'The disclaimer is necessary because several kinds of challenges can affect
    the timeliness and relevancy of Copilot’s suggestions and responses. These include
    the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 免责声明是必要的，因为多种挑战可能会影响Copilot的建议和响应的及时性和相关性。以下是一些可能的影响因素：
- en: Training cutoffs
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练截止日期
- en: Hallucinations
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幻觉
- en: Lack of real-time validation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏实时验证
- en: Mistaken context
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的上下文
- en: Let’s look at each of these in more detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些。
- en: Training Cutoffs
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练截止日期
- en: LLMs are trained on data that is current as of the time the training occurs.
    Beyond that date, the model has no *built-in* knowledge of changes that have occurred
    in the areas it was trained in. The further away from the training cutoff your
    use of the tool occurs, the more likely some of the responses and suggestions
    will be out of date. This can manifest as Copilot producing deprecated code or
    code that was more relevant for a previous version of a framework or language.
    And, of course, results will vary depending on which model you choose to use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: LLMs 是在训练发生时数据最新的情况下进行训练的。在此日期之后，模型对其训练领域发生的任何变化都没有*内置*知识。您使用该工具的时间距离训练截止日期越远，某些响应和建议过时的可能性就越大。这可能导致
    Copilot 生成已弃用的代码或适用于框架或语言旧版本的代码。当然，结果将取决于您选择使用哪个模型。
- en: Training Frequency
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练频率
- en: If you’re wondering why these models aren’t kept more up to date, it’s important
    to understand that they have billions of parameters and huge corpora of data to
    process for any training. This requires significant compute cost and time to accomplish.
    So, updates to the wider underlying training are expensive in multiple ways.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么这些模型没有保持更及时更新，重要的是要理解它们拥有数十亿个参数和巨大的数据集需要处理以进行任何训练。这需要大量的计算成本和时间来完成。因此，对更广泛的基础训练的更新在多个方面都是昂贵的。
- en: Let’s look at a simple example of challenges that may occur from training cutoffs
    (as surfaced through Copilot as of the time of this writing). We’ll ask Copilot
    to write a function to seed a random number generator in Go ([Figure 7-1](#asking-copilot-to-cre)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，说明训练截止日期可能带来的挑战（如本写作时 Copilot 表现出的）。我们将请求 Copilot 编写一个在 Go 中为随机数生成器设置种子的函数（[图
    7-1](#asking-copilot-to-cre)）。
- en: '![](assets/lghc_0701.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0701.png)'
- en: Figure 7-1\. Asking Copilot to create a random number generator in Go
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. 请求 Copilot 在 Go 中创建一个随机数生成器
- en: While this looks fine and is syntactically correct, there is a problem. The
    `Seed` function was [deprecated in Go](https://oreil.ly/D2hpj) as of version 1.20\.
    Let’s see if Copilot understands that this is deprecated. We can ask it in the
    Chat interface “Is the Seed function deprecated in Go?” The response, as shown
    in [Figure 7-2](#asking-copilot-if-the), shows that, based on the model’s training,
    it doesn’t have the information that the function is deprecated.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来没问题，并且语法正确，但存在一个问题。`Seed` 函数自 1.20 版本起在 Go 中已被[弃用](https://oreil.ly/D2hpj)。让我们看看
    Copilot 是否理解这一点。我们可以在聊天界面中询问它：“Go 中的 `Seed` 函数是否已弃用？” 响应，如图 7-2 所示，显示基于模型的训练，它没有关于该函数已弃用的信息。
- en: '![](assets/lghc_0702.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0702.png)'
- en: Figure 7-2\. Asking Copilot if the `Seed` function is deprecated
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 询问 Copilot `Seed` 函数是否已弃用
- en: So although the function is no longer meant to be used, Copilot was not aware
    of that. This illustrates the point about the training cutoff. We’ll look at some
    ways to deal with these kind of challenges later in the chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该函数不再打算使用，但 Copilot 并未意识到这一点。这说明了关于训练截止日期的观点。我们将在本章后面探讨一些处理这类挑战的方法。
- en: Out-of-date results represent one category of problems; results would have been
    valid at one time but no longer are. Another category of issues arises when results
    look valid for the current context but may not reflect real data or references.These
    are known as *hallucinations*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 过时的结果代表一类问题；结果曾经是有效的，但现在已经不再有效。当结果看起来在当前上下文中有效，但可能不反映真实数据或引用时，就会出现另一类问题。这些被称为*幻觉*。
- en: Hallucinations
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幻觉
- en: LLMs are subject to creating responses with data that looks legitimate but isn’t.
    These are referred to as *hallucinations*. In general chat interfaces, this can
    take the form of referencing nonexistent items or stating as fact things that
    simply aren’t true. In more critical systems, such as threat detection, an AI
    model may flag something as a threat when it is not.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: LLMs 易于创建看似合法但实际上并非如此的数据响应。这些被称为*幻觉*。在一般聊天界面中，这可以表现为引用不存在的项目或陈述为事实的事情实际上并不真实。在更关键的系统中，例如威胁检测，AI
    模型可能会将某些内容标记为威胁，而实际上并非如此。
- en: 'In the context of coding, hallucinations can take several forms:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码的上下文中，幻觉可以采取几种形式：
- en: Coding suggestions that may reference identifiers (names, variables, constants,
    etc.) or related code that does not exist
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能引用不存在标识符（名称、变量、常量等）或相关代码的建议
- en: Generated data that may not be accurate
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不准确生成的数据
- en: Functions or methods that don’t exist
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不存在的函数或方法
- en: Incorrect library or API usage (or use of libraries or APIs that don’t exist
    at all)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的库或 API 使用（或使用根本不存在的库或 API）
- en: Made-up types or classes
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编造的类型或类
- en: Plausible but incorrect business logic
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能但错误的业务逻辑
- en: Bad assumptions about surrounding code
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对周围代码的糟糕假设
- en: Tests that don’t actually test the intended behavior
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上没有测试预期行为的测试
- en: While hallucinations in the first category can certainly still occur in output
    produced from Copilot, they seem less common now than in Copilot’s early days
    due to improvements with the underlying models. These kinds of hallucinations
    (referencing identifiers or code that doesn’t exist) tend to be more obvious and
    can usually be caught quickly by user reviews. If these hallucinations do end
    up getting accepted and overlooked, compilers, linters, or other tools that check
    syntax will likely flag them at some point.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第一类中的幻觉在 Copilot 早期可能仍然会出现在输出中，但由于底层模型的改进，它们现在似乎比 Copilot 早期更为少见。这类幻觉（引用不存在标识符或代码）通常更为明显，并且通常可以通过用户审查迅速捕捉到。如果这些幻觉最终被接受并忽略，编译器、代码检查器或其他检查语法的工具可能会在某个时候标记它们。
- en: The second type of hallucination (involving generated data) is more subtle.
    It occurs in part because there is no real-time automatic validation of generated
    data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的幻觉（涉及生成数据）更为微妙。部分原因是由于没有对生成数据进行实时自动验证。
- en: Lack of Real-Time Validation
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏实时验证
- en: Generated data that Copilot returns may not be accurate. Copilot itself sometimes
    reminds you of that, as shown in [Figure 7-4](#copilot-disclaimer-on). In this
    case, we asked Copilot to generate a mapping of area codes to states. After completing
    the tasks, Copilot adds the disclaimer that “The above code is just a placeholder
    and may not represent the actual area codes for each state.”
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 返回的生成数据可能不准确。Copilot 本身有时会提醒您这一点，如图[图 7-4](#copilot-disclaimer-on)所示。在这种情况下，我们要求
    Copilot 生成一个区号到州的映射。完成任务后，Copilot 添加了声明：“上述代码仅作为占位符，可能不代表每个州的实际区号。”
- en: '![](assets/lghc_0704.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0704.png)'
- en: Figure 7-4\. A Copilot disclaimer on the accuracy of the generated data
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. 关于生成数据准确性的 Copilot 声明
- en: 'Why is this the case? Keep these four points in mind:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会是这种情况？请记住以下四点：
- en: Copilot is trained on data which may or may not contain accurate, actual values.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot 在可能包含或不包含准确、实际值的数据上进行了训练。
- en: Copilot is generating results to match syntax and structure.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot 正在生成结果以匹配语法和结构。
- en: Copilot does not run code that it generates and doesn’t validate logic.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot 不会运行它生成的代码，也不会验证逻辑。
- en: Copilot does not have mechanisms to look up and check data to see if it is accurate
    or up-to-date.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot 没有查找和检查数据以查看其是否准确或最新的机制。
- en: The first three items are self-explanatory. The fourth item indicates that Copilot
    has no mechanism to cross-check results it generates against other sources such
    as the web. While some AI techniques can leverage tools to do this, they are not
    integrated with Copilot for the purpose of validating responses from the model.
    The data may be correct, but there is no guarantee. In short, Copilot has no way
    of knowing if something is true or false.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前三项是显而易见的。第四项表明 Copilot 没有机制将其生成的结果与其他来源（如网络）进行交叉检查。虽然一些 AI 技术可以利用工具来做这件事，但它们并没有与
    Copilot 集成以验证模型的响应。数据可能是正确的，但没有保证。简而言之，Copilot 没有办法知道某件事是真是假。
- en: For this reason, you should not assume correctness when using information generated
    by Copilot. Data generation from Copilot is better suited for content that needs
    correct form but not necessarily correct values, like testing scenarios.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用 Copilot 生成的信息时，您不应假设其正确性。从 Copilot 生成数据更适合需要正确形式但不一定需要正确值的内容，例如测试场景。
- en: Copilot Extensions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copilot 扩展
- en: You can create Copilot Extensions that call APIs or other tools to get more
    relevant, up-to-date information for particular use cases. You can either find
    an existing extension that already addresses what you’re looking to do or build
    your own. Copilot Extensions are covered in detail in [Chapter 10](ch10.html#ch10).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建 Copilot 扩展，以调用 API 或其他工具来获取针对特定用例的更相关、更及时的信息。您可以选择找到一个现有的扩展，该扩展已经解决了您想要解决的问题，或者自己构建一个。Copilot
    扩展在[第 10 章](ch10.html#ch10)中有详细说明。
- en: Another challenge you may encounter is having Copilot use context you did not
    intend for it to reference for its responses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能遇到的另一个挑战是 Copilot 使用您未打算让它参考的上下文来生成回答。
- en: Misplaced Context
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文错误
- en: Most of the time, when you are chatting with Copilot in the IDE’s chat interface,
    you will have a file active in the editor. You may also have a portion of it selected.
    In those cases, Copilot assumes this is the main context that any open-ended questions
    (such as “How do I test this?”) refer to.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当你通过 IDE 的聊天界面与 Copilot 聊天时，你会在编辑器中有一个活动文件。你也许还选中了文件的一部分。在这些情况下，Copilot
    假设这是任何开放性问题（例如“我该如何测试这个？”）所指的主要上下文。
- en: Having Copilot use that specific content may be exactly what you intend. Or
    you might have intended for Copilot to respond based on a different file or a
    different portion of the active file. If Copilot assumes a different context,
    Copilot’s answers may not be what you are looking for.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Copilot 那个特定内容可能正是你想要的。或者你可能希望 Copilot 根据不同的文件或活动文件的不同部分来响应。如果 Copilot 假设了不同的上下文，Copilot
    的答案可能不是你想要的。
- en: Imagine you are using multiple languages or frameworks in a project and have
    context set that doesn’t align with your prompt. Such a project is shown in [Figure 7-5](#wrong-context-for-pro).
    In this project, we have a Python file (*fibonacci.py*) and one written in Go
    (*prime.go*), as shown in the upper left of the IDE.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在一个项目中使用多种语言或框架，并且上下文设置与你的提示不匹配。这种项目在 [图 7-5](#wrong-context-for-pro) 中展示。在这个项目中，我们有一个
    Python 文件（*fibonacci.py*）和一个用 Go 编写的文件（*prime.go*），如 IDE 上方左图所示。
- en: With the Python file selected (and thus used as context), we ask Copilot, “How
    do I test the Go code here?” Copilot responds by telling us about the mismatch
    between the context and the prompt. It then provides information about how to
    do Python testing to align with the active file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在选中 Python 文件（因此用作上下文）的情况下，我们询问 Copilot，“我该如何测试这里的 Go 代码？”Copilot 通过告诉我们上下文与提示之间的不匹配来响应。然后它提供了关于如何进行
    Python 测试以与活动文件保持一致的信息。
- en: '![](assets/lghc_0705.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0705.png)'
- en: Figure 7-5\. Indicating the wrong context for a prompt
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. 提示中指示错误的上下文
- en: Another type of issue can arise when no context is implied.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有暗示上下文时，可能会出现另一种类型的问题。
- en: Missing Context
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺少上下文
- en: If we prompt Copilot and have no files open in the workspace and nothing else
    in the prompt for it to draw on, Copilot will usually offer a more generic response.
    For example, assume we have a workspace with Go code to implement a Kubernetes
    operator, and we have no files actively open and nothing selected. Now, we prompt
    Copilot in chat with “How can I test the Go code here?”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提示 Copilot，且工作区中没有打开的文件，也没有其他内容供其参考，Copilot 通常会提供一个更通用的响应。例如，假设我们有一个包含 Go
    代码以实现 Kubernetes 操作符的工作区，我们没有打开任何文件，也没有选中任何内容。现在，我们在聊天中提示 Copilot，“我该如何测试这里的 Go
    代码？”
- en: Because no context is indicated, Copilot either will tell you to select context
    or will supply a response about how you can answer the question generally. [Figure 7-6](#generic-advice-per-mi)
    shows an example response for the case we just discussed. Here, Copilot provides
    guidance on how to test Go code generally.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有指明上下文，Copilot要么会告诉你选择上下文，要么会提供一个关于如何一般性地回答问题的响应。[图 7-6](#generic-advice-per-mi)
    展示了我们刚刚讨论的案例的示例响应。在这里，Copilot 提供了如何一般性地测试 Go 代码的指导。
- en: '![](assets/lghc_0706.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0706.png)'
- en: Figure 7-6\. Generic advice per missing context
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. 缺少上下文时的通用建议
- en: This type of response also happens for other types of queries, such as trying
    to determine where imports are used in the codebase ([Figure 7-7](#another-example)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的响应也适用于其他类型的查询，例如尝试确定代码库中导入的使用位置（[图 7-7](#another-example)）。
- en: '![](assets/lghc_0707.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0707.png)'
- en: Figure 7-7\. Another example of a generic response
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-7\. 通用响应的另一个示例
- en: The bottom line is that without enough implicit context (open files) or explicit
    context (references supplied in the prompt), Copilot defaults to generic answers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 核心问题是，如果没有足够的隐含上下文（打开的文件）或显含上下文（在提示中提供的引用），Copilot 将默认提供通用答案。
- en: When you start working with Copilot for any length of time, you will run into
    these classes of issues. The impact will vary depending on your particular situation.
    Fortunately, you, as a user, can employ a few strategies when you encounter these
    scenarios.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始长时间使用 Copilot 时，你将遇到这些问题类别。影响将根据你的具体情况而变化。幸运的是，当你作为用户遇到这些情况时，你可以采取一些策略。
- en: User-Based Coping Strategies
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户的应对策略
- en: 'In general, we have three strategies to help when Copilot’s responses are not
    as accurate or timely as we may need:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们有三种策略可以帮助当 Copilot 的响应不如我们需要的那么准确或及时时：
- en: Explicitly telling Copilot what to use for context
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确告诉 Copilot 使用什么作为上下文
- en: Changing the model
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改模型
- en: Augmenting the data that Copilot has available for context
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强Copilot可用于上下文的可用数据
- en: Let’s look at each of these in turn.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些内容。
- en: Telling Copilot What to Use for Context
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 告诉Copilot用于上下文的内容
- en: As we outlined earlier in this chapter, absent more explicit direction, Copilot
    tries to gather context from what’s being actively used in the editor. If we are
    working directly in the editor, this may be correct in most cases. However, when
    we are working with the chat interface, we may want to have Copilot focus on other
    parts of the project or answer a generic question such as “Where is X used?”
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面概述的，如果没有更明确的指示，Copilot会尝试从编辑器中正在积极使用的内容中收集上下文。如果我们直接在编辑器中工作，这可能在大多数情况下是正确的。然而，当我们使用聊天界面工作时，我们可能希望Copilot关注项目的其他部分或回答一个通用问题，例如“X在哪里使用？”
- en: Since we are dealing with the chat interface, we can leverage Copilot’s built-in
    features of chat participants and chat variables. These features were covered
    in detail in [Chapter 3](ch03.html#ch03). Here, we’ll provide a simple reminder
    of how to use them to help with cases like these.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是聊天界面，我们可以利用Copilot内置的聊天参与者和聊天变量功能。这些功能在[第3章](ch03.html#ch03)中已有详细说明。在这里，我们将提供如何使用它们的简单提醒，以帮助处理这类情况。
- en: The chat participants have knowledge of different domains that Copilot may need
    to work with, including the overall workspace, the terminal, and VS Code. When
    we use a participant in a query, it steers Copilot to use that domain for context
    with the prompt.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天参与者了解Copilot可能需要与之交互的不同领域，包括整体工作空间、终端和VS Code。当我们在一个查询中使用参与者时，它将Copilot引导到使用该领域作为提示的上下文。
- en: In an earlier section, when we were looking at a project, we asked Copilot,
    “Where are imports used in this code?” We got a generic response telling us the
    steps to find imports for any Go project rather than for our project. The same
    was true for the “How can I test the Go code here?” prompt. Copilot responded
    with generic instructions for how we could determine the information for ourselves.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期部分，当我们查看项目时，我们询问Copilot，“在此代码中导入在哪里使用？”我们得到了一个通用响应，告诉我们如何为任何Go项目找到导入步骤，而不是为我们自己的项目。对于“我如何测试这里的Go代码？”提示也是如此。Copilot以如何自行确定信息的通用说明进行了回应。
- en: However, if instead we explicitly use the `@workspace` participant in the prompt,
    Copilot provides information from the files we have as part of the workspace (see
    [Figure 7-8](#context-with-workspa)). The prompt is “@workspace Where are imports
    used in this code?” This matches the original intent.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们明确在提示中使用 `@workspace` 参与者，Copilot会提供作为工作空间一部分的文件信息（见[图7-8](#context-with-workspa)）。提示是“@workspace
    在此代码中哪里使用了导入？”这与原始意图相匹配。
- en: '![](assets/lghc_0708.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0708.png)'
- en: Figure 7-8\. Context with `@workspace`
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-8\. 使用 `@workspace` 的上下文
- en: You can also implicitly direct Copilot to use `@workspace`. Certain keywords
    or phrases in your prompt can trigger Copilot to add `@workspace` to the prompt.
    For instance, we can modify our previous prompt about testing to “How can I test
    the Go code in this project?” The reference to *project* is enough for Copilot
    to understand that we mean the larger context. It then automatically runs our
    prompt by using `@workspace` and the shortcut command `/setupTests`, as shown
    in [Figure 7-9](#implicitly-using-wor).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以隐式指导Copilot使用 `@workspace`。您的提示中的某些关键词或短语可以触发Copilot将 `@workspace` 添加到提示中。例如，我们可以修改我们之前的测试提示为“我如何测试这个项目中的Go代码？”对“项目”的提及足以让Copilot理解我们的意图是指更大的上下文。然后它自动通过使用
    `@workspace` 和快捷命令 `/setupTests` 来运行我们的提示，如[图7-9](#implicitly-using-wor)所示。
- en: '![](assets/lghc_0709.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0709.png)'
- en: Figure 7-9\. Implicitly using `@workspace` based on the prompt text
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-9\. 根据提示文本隐式使用 `@workspace`
- en: If we need to further zero in on content, we can include one of the chat variables
    in the prompt to specify context, like `#file` or `#selection`. For example, we
    can specifically ask Copilot how to test the code in a file in our project by
    using the `#file` chat variable (see [Figure 7-10](#testing-go-with-file)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要进一步聚焦于内容，我们可以在提示中包含一个聊天变量来指定上下文，例如 `#file` 或 `#selection`。例如，我们可以通过使用
    `#file` 聊天变量（见[图7-10](#testing-go-with-file)）来具体询问Copilot如何测试我们项目中的文件代码。
- en: '![](assets/lghc_0710.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0710.png)'
- en: Figure 7-10\. Testing Go with the `#file` chat variable
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-10\. 使用 `#file` 聊天变量测试Go
- en: Specifying Chat Variables and Arguments
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定聊天变量和参数
- en: Simply typing in chat variables and arguments directly does not always work.
    What does always work is starting to type the chat variable (#) and then selecting
    the chat variable from the pop-up list by using the arrow keys to move, if needed,
    and the Enter key to select one. You should make sure to select any intended files
    from the list that pops up.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在聊天变量和参数中键入并不总是有效。始终有效的是开始键入聊天变量（#），然后使用箭头键移动（如果需要），并使用Enter键选择一个。你应该确保从弹出的列表中选择任何预期的文件。
- en: Notice that by using the `#file` chat variable, we did not need to have the
    file actually open or active in the editor. This mechanism then affords you a
    way to direct Copilot to the relevant content in the project for context. This
    overrides Copilot’s default mechanisms for determining which content you want.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过使用`#file`聊天变量，我们不需要在编辑器中实际打开或激活文件。这种机制为你提供了一种指导Copilot指向项目中的相关内容以获取上下文的方法。这覆盖了Copilot确定你想要的内容的默认机制。
- en: Even with a directed context, Copilot may still respond with out-of-date code
    or information, depending on when the model was trained. Or the responses it returns
    may not seem as relevant or comprehensive as you want. But since Copilot provides
    multiple models to choose from, there may be a simple way to deal with that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在有指导性的上下文中，Copilot也可能仍然会返回过时的代码或信息，这取决于模型的训练时间。或者它返回的响应可能不如你希望的那样相关或全面。但既然Copilot提供了多个模型可供选择，可能有一种简单的方法来处理这种情况。
- en: Changing the Model
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改模型
- en: Copilot allows you to choose from more than one AI model for code suggestions
    and chat responses. Each model will have its pros and cons. For example, some
    models may be better at code generation. In addition, each model will have been
    trained at a different point in time, so newer models will be more up-to-date
    and less likely to produce deprecated code than older models.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot允许你从多个AI模型中选择代码建议和聊天响应。每个模型都有自己的优缺点。例如，一些模型可能在代码生成方面表现更好。此外，每个模型都是在不同的时间点进行训练的，因此较新的模型将更更新，并且比旧模型更不可能生成已弃用的代码。
- en: As a reminder, changing models in the chat interface is easy. You just select
    the model name that you want to use from the drop-down list in whichever chat
    interface you’re using. See [Figure 7-11](#switching-models-in-t) for an example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，在聊天界面中更改模型非常简单。你只需从你正在使用的聊天界面的下拉列表中选择你想要使用的模型名称。参见[图7-11](#switching-models-in-t)以获取示例。
- en: '![](assets/lghc_0711.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0711.png)'
- en: Figure 7-11\. Switching models in the chat interface
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-11\. 在聊天界面中切换模型
- en: Earlier in the chapter, we showed an example of Copilot generating a random
    number function by using a deprecated method ([Figure 7-1](#asking-copilot-to-cre)).
    This was generated with the GPT-4o model.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们展示了Copilot通过使用已弃用的方法生成随机数函数的示例（[图7-1](#asking-copilot-to-cre)）。这是使用GPT-4o模型生成的。
- en: If we switch instead to a more recent model, such as Gemini 2.5 Pro, and issue
    the same prompt, Copilot produces code using the newer standard `rand.NewSource`
    function instead of trying to use the deprecated `rand.Seed` function. Also, if
    we query Copilot about whether the *Seed* function is deprecated in the main chat
    area, it correctly responds that the `rand.Seed` function is deprecated as of
    Go 1.20\. [Figure 7-12](#using-a-newer-model-r) shows the response from using
    the newer model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改用更近期的模型，例如Gemini 2.5 Pro，并发出相同的提示，Copilot将使用较新的标准`rand.NewSource`函数来生成代码，而不是尝试使用已弃用的`rand.Seed`函数。此外，如果我们向Copilot询问在主聊天区域中`Seed`函数是否已弃用，它将正确地回应说`rand.Seed`函数自Go
    1.20起已弃用。[图7-12](#using-a-newer-model-r)展示了使用较新模型的响应。
- en: '![](assets/lghc_0712.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0712.png)'
- en: Figure 7-12\. Using a newer model results in correct code and response
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-12\. 使用较新模型导致生成正确的代码和响应
- en: If you choose a different model, how do you know whether it will be more up
    to date? Typically, the models list will be updated as newer models become available—usually
    marked as *Preview* for some period of time. But you can also do some simple searching
    on the web or with a site like [Hugging Face](http://huggingface.co) to find which
    models are more recent.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择不同的模型，你如何知道它是否会更更新？通常，当有新模型可用时，模型列表将会更新——通常在一段时间内标记为*预览*。但你也可以在网络上或使用类似[Hugging
    Face](http://huggingface.co)的网站进行一些简单的搜索，以找到哪些模型更新。
- en: You can also try querying the model itself through Copilot to find out more
    about which version of something was current when the model was being trained.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以尝试通过Copilot查询模型本身，以了解更多关于在模型训练时某个版本的当前情况。
- en: Querying the Model to Determine Which Version Is Current
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询模型以确定当前版本
- en: Still looking at the example where Copilot generated deprecated code, let’s
    see what other details we can find to help. Since Copilot didn’t recognize that
    the function was deprecated, it would be useful to know what version of Go Copilot
    thinks is current. We can ask it in the chat interface with a simple “As of your
    last training date, what was the current version of Go?” prompt, as shown in [Figure 7-13](#asking-copilot-which).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在查看Copilot生成已弃用代码的示例，让我们看看我们还能找到哪些其他细节来帮助。由于Copilot没有识别出该函数已被弃用，了解Copilot认为的当前Go版本将是有用的。我们可以在聊天界面中通过简单的提示“截至您上次训练日期，当前的Go版本是什么？”来询问它，如图7-13所示。
- en: '![](assets/lghc_0713.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0713.png)'
- en: Figure 7-13\. Asking Copilot which version of Go is current
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-13\. 询问Copilot当前的Go版本
- en: Framing the Question Appropriately
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适当提问
- en: The question we asked Copilot was framed as “As of your last training date....”
    This is deliberate. If we simply asked Copilot, “What version of Go is current?,”
    it would likely tell us how to find the information ourselves about our local
    Go installation instead.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向Copilot提出的问题是以“截至您上次训练日期....”的形式提出的。这是故意的。如果我们简单地问Copilot，“当前的Go版本是什么？”，它可能会告诉我们如何自己找到关于本地Go安装的信息。
- en: The model that is active in Copilot responds that its last training update was
    in October 2023—and that, as of that date, the latest stable version of Go *was*
    1.21.1.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Copilot中活跃的模型回应说，其最后的训练更新是在2023年10月——并且截至该日期，Go的最新稳定版本是1.21.1。
- en: An obvious question that comes up is why, if Copilot knew about 1.21.1 as the
    most recent version, it still does not recognize that something was deprecated
    in 1.20\. Keep in mind the question we asked Copilot was which version was current
    when the model was last trained, not which version was used in the repositories
    when it was trained. In fact, if you ask Copilot a similar question via comments
    inline in the editor multiple times, you will likely get a different answer (see
    [Figure 7-14](#asking-copilot-which2)). The reason for the differences is that
    the answer returned in the editor is based on version references present in the
    training data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的问题是，如果Copilot知道1.21.1是最新版本，为什么它仍然没有识别出在1.20中有什么被弃用。请记住，我们问Copilot的问题是模型上次训练时的当前版本，而不是训练时在仓库中使用的版本。实际上，如果您通过编辑器中的注释多次以类似的方式询问Copilot，您可能会得到不同的答案（参见[图7-14](#asking-copilot-which2)）。差异的原因是编辑器中返回的答案是基于训练数据中的版本引用。
- en: '![](assets/lghc_0714.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0714.png)'
- en: Figure 7-14\. Asking Copilot which version of Go is current in the editor
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-14\. 在编辑器中询问Copilot当前的Go版本
- en: So, assuming the answer returned by the chat query is the most recent version
    that the model knows about, but the model was trained on various other versions,
    what does that buy you?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设聊天查询返回的答案是模型所知的最新版本，但模型是在各种其他版本上训练的，这能给您带来什么？
- en: What the version information returned in the chat tells you is the most recent
    version that could be represented in the model’s training data. So, any code generated
    strictly from the model’s training will not incorporate any deprecations or use
    any new features or version-specific changes since that version.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天中返回的版本信息告诉您的是模型训练数据中可以表示的最新版本。因此，任何严格从模型训练数据生成的代码将不会包含任何弃用项，也不会使用任何新功能或特定版本的更改。
- en: Query Results May Vary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询结果可能不同
- en: Not all models may return a discrete answer for the *latest version* question.
    Some models may just respond that they don’t have access to that information or
    suggest you look up what the latest version is.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有模型都可能对“最新版本”问题返回离散答案。一些模型可能只是回应他们无法访问该信息，或者建议您查找最新版本。
- en: We can extend Copilot to have capabilities to find out information about the
    latest versions of languages or platforms. [Chapter 10](ch10.html#ch10) guides
    you through implementing an extension to find out the latest version of Go as
    an example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Copilot扩展到具有查找语言或平台最新版本信息的能力。[第10章](ch10.html#ch10)以查找Go最新版本为例，指导您实现一个扩展。
- en: When you have this awareness, you can take measures to help Copilot understand
    updates by switching to a different model or via the method we discuss in the
    next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有这种意识时，您可以通过切换到不同的模型或通过我们在下一节中讨论的方法来采取措施帮助Copilot理解更新。
- en: Premium Requests
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 付费请求
- en: While switching models may be a good option to address certain issues, remember
    that use of some advanced models count as *premium requests.* Using these models
    can use up quotas faster and incur additional costs on some plans.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然切换模型可能是解决某些问题的好方法，但请记住，使用一些高级模型算作*付费请求*。使用这些模型可能会更快地消耗配额，并在某些计划上产生额外的费用。
- en: What if you can’t avoid the AI producing deprecated or incomplete code because
    you’re restricted to a particular model or because the models that you use do
    not have training on a newer feature? You can use one other approach to get Copilot
    to generate the kind of code you want with the context you need.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您因为受限于特定模型或因为您使用的模型没有对新功能进行训练而无法避免AI生成弃用或不完整的代码，您可以采用另一种方法来让Copilot根据您需要的上下文生成您想要的代码类型。
- en: Guiding Copilot by Example
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过示例引导Copilot
- en: Looking at our deprecation example again, Copilot created a function to seed
    a random number generator by using a deprecated method ([Figure 7-15](#created-function-usin)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再次审视我们的弃用示例，Copilot通过使用已弃用的方法创建了一个用于初始化随机数生成器的函数（[图7-15](#created-function-usin)）。
- en: '![](assets/lghc_0715.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图7-15](assets/lghc_0715.png)'
- en: Figure 7-15\. A function created using a deprecated method
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-15. 使用已弃用方法创建的函数
- en: If we want to get Copilot to produce code that is using the replacement for
    the deprecation, we can teach it by example. We can take the updated code snippet
    from the [Go documentation](https://oreil.ly/4vDIl) and temporarily paste it into
    the same file in our workspace. (Or we could paste it into a prompt if we’re using
    the chat interface.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让Copilot生成使用弃用替换的代码，我们可以通过示例来教会它。我们可以从[Go文档](https://oreil.ly/4vDIl)中获取更新的代码片段，并将其临时粘贴到我们工作区中的同一文件中。（或者，如果我们使用的是聊天界面，我们也可以将其粘贴到提示中。）
- en: After that, if we repeat our prompt, Copilot will generate updated code that
    is based on the code snippet we included ([Figure 7-16](#updated-code-generate)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，如果我们重复我们的提示，Copilot将根据我们包含的代码片段生成更新后的代码（[图7-16](#updated-code-generate)）。
- en: '![](assets/lghc_0716.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图7-16](assets/lghc_0716.png)'
- en: Figure 7-16\. Updated code generated with the code example in place
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-16. 使用代码示例更新生成的代码
- en: Obviously, this is a very simple example. In this case, Copilot essentially
    copied the code verbatim. But, regardless, the end result was still what we needed.
    After getting the desired result, the example code can then be removed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个非常简单的例子。在这种情况下，Copilot基本上是逐字复制了代码。但是，无论如何，最终结果仍然是我们需要的结果。在得到期望的结果后，示例代码可以被移除。
- en: Making Updated Code Available
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使更新后的代码可用
- en: In some cases, for Copilot to draw on separate content, it may be enough to
    put the content in another file that is opened in your IDE. In other cases, it
    may be necessary to put the content directly in the file that you’re working with.
    If that is the case, you can add in the content and then remove it when the code
    generation is correct.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，为了让Copilot能够引用独立的内容，可能只需要将内容放入另一个在您的IDE中打开的文件中。在其他情况下，可能需要在您正在工作的文件中直接放入内容。如果是这种情况，您可以在代码生成正确后添加内容并移除它。
- en: The examples in this section have focused on ways to deal with questions and
    challenges with content already generated by Copilot. However, you can also employ
    similar strategies before Copilot generates results to get better results up front.
    We’ll look more at that aspect in the last section of this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例主要关注处理Copilot已生成内容的疑问和挑战的方法。然而，您也可以在Copilot生成结果之前采用类似的策略，以获得更好的初始结果。我们将在本章的最后部分更详细地探讨这一点。
- en: Adding Context to Make Code More Relevant
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加上下文以使代码更具相关性
- en: In addition to compensating for deprecations and missing new features, additional
    content that you supply to Copilot can help in another way. When you provide more
    detailed context in terms of definitions or coding examples that are relevant
    to your project, Copilot can draw on those to generate more thorough, richer,
    and relevant coding suggestions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了补偿弃用和缺失的新功能外，您提供给Copilot的额外内容还可以以另一种方式帮助。当您提供更多与项目相关的定义或编码示例的详细上下文时，Copilot可以利用这些内容生成更全面、更丰富、更相关的编码建议。
- en: 'As an example, let’s look at creating some SQL content with Copilot. Revisiting
    a previous example, suppose we are working on implementing a system to manage
    university courses, students, instructors, registrations, etc. Without any other
    context, let’s ask Copilot to create a general `SELECT` statement to get students
    enrolled in a course. We can do this as simply as adding an SQL comment like this
    in the editor: `**-- define a select statement to get all the students enrolled
    in a course**`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说明，让我们看看如何使用Copilot创建一些SQL内容。回顾先前的例子，假设我们正在实施一个管理系统，用于管理大学课程、学生、讲师、注册等。在没有其他上下文的情况下，让我们让Copilot创建一个通用的`SELECT`语句来获取选修某门课程的学生。我们可以在编辑器中简单地添加一个SQL注释来实现这一点：`**--
    定义一个SELECT语句以获取所有选修某门课程的学生**`。
- en: 'Given this generic directive and no other context, Copilot will produce a reasonable,
    generalized query like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个通用指令和没有其他上下文，Copilot将生成一个合理的、通用的查询，如下所示：
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is nothing wrong with this query. It is perfectly valid given the limited
    context we’ve provided for Copilot. Assuming that we have the corresponding table
    and field names in place in our schema, this would work fine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询没有问题。考虑到我们为Copilot提供的有限上下文，它是完全有效的。假设我们在我们的模式中有相应的表和字段名称，这将运行良好。
- en: However, suppose we already have a more extensive set of databases in place
    for our system (with appropriate tables, data, etc.). We would really like Copilot
    to generate suggestions that are relevant to those and use the elements that we
    already have defined. How can we accomplish this?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们已经在系统中建立了一个更广泛的数据库集合（包括适当的表、数据等）。我们真的希望Copilot生成与这些相关的建议，并使用我们已定义的元素。我们如何实现这一点？
- en: The mechanism for doing this is similar to what we did for the deprecation example
    in the last section, adding more context for Copilot to pick up in the workspace.
    In this case, while we don’t have a way for Copilot to dynamically examine our
    data stores, indices, or stored procedures, we can provide a static representation
    of them via the schema definitions. We can use either an original SQL definition
    if we have one or a dump of the schemas from the existing content. A portion of
    a file that we might use is shown in [Figure 7-17](#example-extended-sche).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的机制与我们在上一节中为弃用示例所做的类似，为Copilot在工作区中提供更多上下文。在这种情况下，虽然我们没有让Copilot动态检查我们的数据存储、索引或存储过程的方法，但我们可以通过模式定义提供它们的静态表示。我们可以使用原始的SQL定义（如果有的话）或现有内容的模式转储。我们可能使用的文件部分如图7-17所示[图7-17](#example-extended-sche)。
- en: '![](assets/lghc_0717.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0717.png)'
- en: Figure 7-17\. Example extended schema definitions to use for context
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-17\. 用于上下文的示例扩展模式定义
- en: This file has specific tables defined for the domains we’re working with, along
    with relevant fields, keys, etc.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件为我们在其中工作的领域定义了特定的表，以及相关的字段、键等。
- en: 'Let’s add this file to our workspace so that it is part of our project and
    open it in the editor. Copilot now has this additional context available to draw
    from. We can go back and provide the same directive in comment form as before: `--
    define a select statement to get all the students enrolled in a course`. This
    time, Copilot produces the following response:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此文件添加到我们的工作区，使其成为我们项目的一部分，并在编辑器中打开它。现在，Copilot有了这个额外的上下文可供参考。我们可以回到之前以注释形式提供的相同指令：`--
    定义一个SELECT语句以获取所有选修某门课程的学生`。这一次，Copilot生成了以下响应：
- en: '[PRE2]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that now, with the additional context from the other file available in
    the workspace, Copilot produced a much richer, more detailed, and more relevant
    query. It also used specific table and field names provided in the other file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在，由于工作区中其他文件提供的附加上下文，Copilot生成了一个更丰富、更详细、更相关的查询。它还使用了其他文件中提供的特定表和字段名称。
- en: The key here is that Copilot prioritizes the context you’re using in the IDE
    for deciding how to generate code. Leveraging this kind of approach is a useful
    and simple strategy to getting much more usable and pertinent coding suggestions
    and answers from Copilot than would be possible if you simply relied on the model’s
    training data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，Copilot优先考虑你在IDE中使用的上下文来决定如何生成代码。利用这种方法的策略是获取比仅依赖模型训练数据更多可用和相关的编码建议和答案的有用且简单策略。
- en: Adding the Additional File as Context
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将附加文件作为上下文添加
- en: In the SQL example shown here, we added the file as an additional one in the
    workspace and opened it in the IDE. We did not take the contents of the file and
    paste it into the active file as we did for the deprecation example. While we
    could have done that, it was not necessary here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示的 SQL 示例中，我们将文件作为工作空间中的附加文件添加，并在 IDE 中打开它。我们没有像在弃用示例中那样将文件内容复制并粘贴到活动文件中。虽然我们可以这样做，但在这里并不必要。
- en: Depending on the use case, you may find that one or the other of these two approaches
    (inserting content directly into the active file or opening the content as a *peer*
    file) works better for you. You can always start by opening the content as a peer
    file and trying that. If you don’t get the expected results, then you can add
    the content directly into the active file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用例，您可能会发现这两种方法（直接将内容插入活动文件或以 *同伴* 文件的形式打开内容）中的一种更适合您。您始终可以从将内容作为同伴文件打开并尝试开始。如果您没有得到预期的结果，然后您可以直接将内容添加到活动文件中。
- en: Another option is to paste relevant examples directly into Copilot Chat for
    it to work from—if the scope of the example is a good fit for that.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将相关示例直接粘贴到 Copilot Chat 中，以便它从中工作——如果示例的范围适合这样做的话。
- en: If you are adding content into the IDE either as a new file or an addition to
    an existing file, be sure to save the changes before querying or prompting Copilot.
    Copilot relies on persisted (saved) content in the workspace to draw on for context.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在将内容添加到 IDE 中，无论是作为新文件还是现有文件的补充，在查询或提示 Copilot 之前，请确保保存更改。Copilot 依赖于工作空间中持久化（已保存）的内容来提取上下文。
- en: The point is that adding richer context up front for Copilot can produce improved
    results in the form of suggestions or completions. In some cases, it may be more
    time-consuming to generate files like the schema one we used here, but the trade-off
    is less time and effort remediating Copilot’s suggestions to get to the detail
    you need.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，为 Copilot 提供更丰富的上下文可以产生改进的结果，形式为建议或补全。在某些情况下，生成像我们这里使用的模式文件这样的文件可能需要更多时间，但权衡是减少时间和精力来修复
    Copilot 的建议，以获得您需要的详细信息。
- en: Conclusion
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we’ve covered the various aspects about how Copilot determines
    context for its code suggestions and responses, why those may not be up-to-date
    or accurate, and some ways you can help deal with those situations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Copilot 确定代码建议和响应上下文的各个方面，为什么这些可能不是最新的或准确的，以及一些可以帮助处理这些情况的方法。
- en: Copilot’s core context comes from the training in the underlying models it uses.
    Since these models are only as current as the point in time when they were last
    trained, they are missing any updates or changes in the languages and frameworks
    that were not part of their training. In addition, the content they were trained
    on will be using older versions of tooling. So, suggestions or responses generated
    from those can be substantially out of date. This is a key aspect to be aware
    of and watch out for. One possible quick fix for this is to switch to an updated
    model if one is available.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 的核心上下文来自其使用的底层模型的训练。由于这些模型只更新到它们最后一次训练的时间点，因此它们缺少任何未包含在训练中的语言和框架的更新或变化。此外，它们训练的内容将使用工具的较旧版本。因此，从这些生成的建议或响应可能严重过时。这是需要注意并警惕的关键方面。一个可能的快速修复方法是如果可用，切换到更新的模型。
- en: Fortunately, Copilot also pulls in context from the available content in the
    editor and workspace you’re using. This context is prioritized over the training
    data since it reflects what you are doing and using currently. Because of this
    approach, you can provide Copilot with more up-to-date and more relevant context
    to draw on. You do this by including your own relevant content in the IDE and
    workspace. This can be done in most cases by having a file with relevant information
    open in the IDE. For more explicit direction, the relevant information can be
    added to the current file for as long as needed for Copilot to draw from.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Copilot 也会从您正在使用的编辑器和工作空间中可用的内容中提取上下文。由于这反映了您当前正在做什么和使用什么，因此这种上下文优先于训练数据。正因为如此，您可以向
    Copilot 提供更多最新和更相关的上下文来参考。您可以通过在 IDE 和工作空间中包含自己的相关内容来实现这一点。在大多数情况下，这可以通过在 IDE
    中打开包含相关信息的文件来完成。为了更明确地指导，相关信息可以添加到当前文件中，直到 Copilot 需要从中提取信息为止。
- en: GitHub Copilot also includes ways to focus the AI on specific content you have.
    Chat participants can define overall context areas for Copilot to answer questions
    and respond about. The current set of participants include ones for VS Code, the
    active terminal, and your workspace.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot 还包括了一些方法来聚焦 AI 在特定的内容上。聊天参与者可以为 Copilot 定义整体上下文区域，以便回答问题和做出回应。当前的参与者包括
    VS Code、活动终端和你的工作空间。
- en: At a more detailed level, you can steer Copilot’s context to particular items
    within your workspace via chat variables. Examples include the current selection
    in the editor, the content open in the editor, the last command in the terminal,
    and more.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细的层面上，你可以通过聊天变量来引导 Copilot 的上下文到工作空间中的特定项目。例如，包括编辑器中的当前选择、编辑器中打开的内容、终端中的最后一条命令等等。
- en: In this chapter, you learned how to supply more context for GitHub Copilot when
    you’re working with SQL. This is an example of a nontypical language/framework
    that you can also use Copilot for. The next chapter explores more examples of
    how to use Copilot for such nontypical areas.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在处理 SQL 时为 GitHub Copilot 提供更多上下文。这是一个非典型语言/框架的例子，你同样可以使用 Copilot。下一章将探讨更多关于如何在这些非典型领域使用
    Copilot 的例子。
