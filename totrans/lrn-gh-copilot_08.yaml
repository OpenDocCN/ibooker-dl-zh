- en: Chapter 7\. Keeping Copilot Timely and Relevant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The range of functionality and interactivity provided by GitHub Copilot is truly
    impressive. However, the responses it generates can sometimes be less impressive
    (and less useful) if they are not timely and relevant. As good as the AI can be,
    at times you may need to take extra steps to *steer* it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in certain instances, you may need to direct Copilot to focus on
    certain portions of your content to get targeted answers. Or you may need to augment
    its training to get responses more relevant to your codebase. And you may need
    to pay extra attention to be aware when Copilot is suggesting code that may be
    out of date or referencing features that are no longer supported.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to look at how to manage interaction with Copilot
    in these situations. You can leverage certain strategies and functionality to
    help ensure relevancy and timeliness in your interactions with Copilot. Certain
    approaches can compensate when Copilot may not be aware of recent changes or referencing
    the right sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this is aimed at helping Copilot have the most usable set of context
    in order to provide the most useful responses for what we’re asking of it. In
    the next few pages, we’ll look at the following areas related to Copilot’s use
    of context:'
  prefs: []
  type: TYPE_NORMAL
- en: Where context originates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How timeliness and relevancy may be affected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-based coping strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding context to make code more relevant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By its very definition, *generative* implies generating new content in part
    based on gathering and processing context. So, let’s start with a reminder of
    where the context that Copilot uses comes from.
  prefs: []
  type: TYPE_NORMAL
- en: Where Context Originates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve discussed in previous chapters, in the IDE, Copilot draws context from
    your immediate working environment—specifically, from the files you have in your
    workspace and the content associated with them. This includes typical items like
    the name of the file, the comments in them, and the code before and after the
    cursor. But Copilot also draws from more dynamic interactions, such as whether
    or not you accepted its last code suggestion. And by automatically creating an
    index of your repository, Copilot gains a larger understanding of your project.
    Copilot can also be directed to take other content into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: For quickly generating coding suggestions in your IDE/editor, targeting the
    files you have open is a useful strategy used by Copilot. The focus allows it
    to quickly get a good sense of what is presumably most important (since you have
    those files readily accessible).
  prefs: []
  type: TYPE_NORMAL
- en: In this *inline* mode, Copilot uses multiple strategies to ensure a fast response.
    The client (extension installed in your interface) asks the model for very few
    suggestions (one to three). Copilot is aggressive in caching results and adapts
    the suggestions if you continue typing. It also has some built-in checks, preventing
    sending requests if you are typing in the middle of a line, for example, unless
    there is whitespace to the right of the cursor. Then the index we’ve discussed
    is updated based on changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this mode, scoring also happens to determine whether the prompt assembled
    to send to the model is even worthwhile (worth invoking the model). This decision
    is based on factors like previous responses to suggestions. This approach helps
    exclude repetitive prompts or ones that already exist in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these same strategies are not needed when you switch to the chat interface.
    Within that, Copilot has more time to come up with responses, and so more completion
    suggestions can be requested by the client. For gathering context when working
    in this interface, you can also be more directive of where to get the context.
    Copilot includes methods like chat variables and chat participants (as discussed
    in [Chapter 3](ch03.html#ch03) and other chapters) to focus Copilot on particular
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of where the user is working, the client collects the context, processes
    it into a prompt, and sends it to the model you’ve selected. After doing some
    quick validation of what the model returns and generating the requested set of
    responses, those are then displayed to the user. The responses can include multiple
    options in the IDE if multiple completion suggestions were available.
  prefs: []
  type: TYPE_NORMAL
- en: The *quick validation* just referred to involves quickly looking for patterns
    in the response that are repetitive or might indicate a security issue (such as
    hardcoded credentials). These are beneficial checks, but they don’t prevent other
    factors that may lead to relevancy and timeliness being off. Let’s look at some
    of those other factors next.
  prefs: []
  type: TYPE_NORMAL
- en: How Timeliness and Relevancy May Be Affected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you first open up Copilot’s chat interface, you get a notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This disclaimer is a reminder that generative AI can be inaccurate and problematic.
    Ultimately, it’s up to the user to ensure that the generated content is correct
    and relevant. (This is also why you should always use standard validation methods
    like testing and code reviews to check any content produced with the assistance
    of the AI.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The disclaimer is necessary because several kinds of challenges can affect
    the timeliness and relevancy of Copilot’s suggestions and responses. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Training cutoffs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hallucinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of real-time validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mistaken context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each of these in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Training Cutoffs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LLMs are trained on data that is current as of the time the training occurs.
    Beyond that date, the model has no *built-in* knowledge of changes that have occurred
    in the areas it was trained in. The further away from the training cutoff your
    use of the tool occurs, the more likely some of the responses and suggestions
    will be out of date. This can manifest as Copilot producing deprecated code or
    code that was more relevant for a previous version of a framework or language.
    And, of course, results will vary depending on which model you choose to use.
  prefs: []
  type: TYPE_NORMAL
- en: Training Frequency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re wondering why these models aren’t kept more up to date, it’s important
    to understand that they have billions of parameters and huge corpora of data to
    process for any training. This requires significant compute cost and time to accomplish.
    So, updates to the wider underlying training are expensive in multiple ways.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a simple example of challenges that may occur from training cutoffs
    (as surfaced through Copilot as of the time of this writing). We’ll ask Copilot
    to write a function to seed a random number generator in Go ([Figure 7-1](#asking-copilot-to-cre)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Asking Copilot to create a random number generator in Go
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While this looks fine and is syntactically correct, there is a problem. The
    `Seed` function was [deprecated in Go](https://oreil.ly/D2hpj) as of version 1.20\.
    Let’s see if Copilot understands that this is deprecated. We can ask it in the
    Chat interface “Is the Seed function deprecated in Go?” The response, as shown
    in [Figure 7-2](#asking-copilot-if-the), shows that, based on the model’s training,
    it doesn’t have the information that the function is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Asking Copilot if the `Seed` function is deprecated
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So although the function is no longer meant to be used, Copilot was not aware
    of that. This illustrates the point about the training cutoff. We’ll look at some
    ways to deal with these kind of challenges later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-date results represent one category of problems; results would have been
    valid at one time but no longer are. Another category of issues arises when results
    look valid for the current context but may not reflect real data or references.These
    are known as *hallucinations*.
  prefs: []
  type: TYPE_NORMAL
- en: Hallucinations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LLMs are subject to creating responses with data that looks legitimate but isn’t.
    These are referred to as *hallucinations*. In general chat interfaces, this can
    take the form of referencing nonexistent items or stating as fact things that
    simply aren’t true. In more critical systems, such as threat detection, an AI
    model may flag something as a threat when it is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of coding, hallucinations can take several forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Coding suggestions that may reference identifiers (names, variables, constants,
    etc.) or related code that does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generated data that may not be accurate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions or methods that don’t exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect library or API usage (or use of libraries or APIs that don’t exist
    at all)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made-up types or classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plausible but incorrect business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad assumptions about surrounding code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests that don’t actually test the intended behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While hallucinations in the first category can certainly still occur in output
    produced from Copilot, they seem less common now than in Copilot’s early days
    due to improvements with the underlying models. These kinds of hallucinations
    (referencing identifiers or code that doesn’t exist) tend to be more obvious and
    can usually be caught quickly by user reviews. If these hallucinations do end
    up getting accepted and overlooked, compilers, linters, or other tools that check
    syntax will likely flag them at some point.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of hallucination (involving generated data) is more subtle.
    It occurs in part because there is no real-time automatic validation of generated
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of Real-Time Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generated data that Copilot returns may not be accurate. Copilot itself sometimes
    reminds you of that, as shown in [Figure 7-4](#copilot-disclaimer-on). In this
    case, we asked Copilot to generate a mapping of area codes to states. After completing
    the tasks, Copilot adds the disclaimer that “The above code is just a placeholder
    and may not represent the actual area codes for each state.”
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. A Copilot disclaimer on the accuracy of the generated data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Why is this the case? Keep these four points in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Copilot is trained on data which may or may not contain accurate, actual values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot is generating results to match syntax and structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot does not run code that it generates and doesn’t validate logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot does not have mechanisms to look up and check data to see if it is accurate
    or up-to-date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three items are self-explanatory. The fourth item indicates that Copilot
    has no mechanism to cross-check results it generates against other sources such
    as the web. While some AI techniques can leverage tools to do this, they are not
    integrated with Copilot for the purpose of validating responses from the model.
    The data may be correct, but there is no guarantee. In short, Copilot has no way
    of knowing if something is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you should not assume correctness when using information generated
    by Copilot. Data generation from Copilot is better suited for content that needs
    correct form but not necessarily correct values, like testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create Copilot Extensions that call APIs or other tools to get more
    relevant, up-to-date information for particular use cases. You can either find
    an existing extension that already addresses what you’re looking to do or build
    your own. Copilot Extensions are covered in detail in [Chapter 10](ch10.html#ch10).
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge you may encounter is having Copilot use context you did not
    intend for it to reference for its responses.
  prefs: []
  type: TYPE_NORMAL
- en: Misplaced Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, when you are chatting with Copilot in the IDE’s chat interface,
    you will have a file active in the editor. You may also have a portion of it selected.
    In those cases, Copilot assumes this is the main context that any open-ended questions
    (such as “How do I test this?”) refer to.
  prefs: []
  type: TYPE_NORMAL
- en: Having Copilot use that specific content may be exactly what you intend. Or
    you might have intended for Copilot to respond based on a different file or a
    different portion of the active file. If Copilot assumes a different context,
    Copilot’s answers may not be what you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are using multiple languages or frameworks in a project and have
    context set that doesn’t align with your prompt. Such a project is shown in [Figure 7-5](#wrong-context-for-pro).
    In this project, we have a Python file (*fibonacci.py*) and one written in Go
    (*prime.go*), as shown in the upper left of the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: With the Python file selected (and thus used as context), we ask Copilot, “How
    do I test the Go code here?” Copilot responds by telling us about the mismatch
    between the context and the prompt. It then provides information about how to
    do Python testing to align with the active file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. Indicating the wrong context for a prompt
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another type of issue can arise when no context is implied.
  prefs: []
  type: TYPE_NORMAL
- en: Missing Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we prompt Copilot and have no files open in the workspace and nothing else
    in the prompt for it to draw on, Copilot will usually offer a more generic response.
    For example, assume we have a workspace with Go code to implement a Kubernetes
    operator, and we have no files actively open and nothing selected. Now, we prompt
    Copilot in chat with “How can I test the Go code here?”
  prefs: []
  type: TYPE_NORMAL
- en: Because no context is indicated, Copilot either will tell you to select context
    or will supply a response about how you can answer the question generally. [Figure 7-6](#generic-advice-per-mi)
    shows an example response for the case we just discussed. Here, Copilot provides
    guidance on how to test Go code generally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. Generic advice per missing context
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This type of response also happens for other types of queries, such as trying
    to determine where imports are used in the codebase ([Figure 7-7](#another-example)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. Another example of a generic response
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The bottom line is that without enough implicit context (open files) or explicit
    context (references supplied in the prompt), Copilot defaults to generic answers.
  prefs: []
  type: TYPE_NORMAL
- en: When you start working with Copilot for any length of time, you will run into
    these classes of issues. The impact will vary depending on your particular situation.
    Fortunately, you, as a user, can employ a few strategies when you encounter these
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: User-Based Coping Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, we have three strategies to help when Copilot’s responses are not
    as accurate or timely as we may need:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly telling Copilot what to use for context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmenting the data that Copilot has available for context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Telling Copilot What to Use for Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we outlined earlier in this chapter, absent more explicit direction, Copilot
    tries to gather context from what’s being actively used in the editor. If we are
    working directly in the editor, this may be correct in most cases. However, when
    we are working with the chat interface, we may want to have Copilot focus on other
    parts of the project or answer a generic question such as “Where is X used?”
  prefs: []
  type: TYPE_NORMAL
- en: Since we are dealing with the chat interface, we can leverage Copilot’s built-in
    features of chat participants and chat variables. These features were covered
    in detail in [Chapter 3](ch03.html#ch03). Here, we’ll provide a simple reminder
    of how to use them to help with cases like these.
  prefs: []
  type: TYPE_NORMAL
- en: The chat participants have knowledge of different domains that Copilot may need
    to work with, including the overall workspace, the terminal, and VS Code. When
    we use a participant in a query, it steers Copilot to use that domain for context
    with the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: In an earlier section, when we were looking at a project, we asked Copilot,
    “Where are imports used in this code?” We got a generic response telling us the
    steps to find imports for any Go project rather than for our project. The same
    was true for the “How can I test the Go code here?” prompt. Copilot responded
    with generic instructions for how we could determine the information for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: However, if instead we explicitly use the `@workspace` participant in the prompt,
    Copilot provides information from the files we have as part of the workspace (see
    [Figure 7-8](#context-with-workspa)). The prompt is “@workspace Where are imports
    used in this code?” This matches the original intent.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. Context with `@workspace`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also implicitly direct Copilot to use `@workspace`. Certain keywords
    or phrases in your prompt can trigger Copilot to add `@workspace` to the prompt.
    For instance, we can modify our previous prompt about testing to “How can I test
    the Go code in this project?” The reference to *project* is enough for Copilot
    to understand that we mean the larger context. It then automatically runs our
    prompt by using `@workspace` and the shortcut command `/setupTests`, as shown
    in [Figure 7-9](#implicitly-using-wor).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9\. Implicitly using `@workspace` based on the prompt text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we need to further zero in on content, we can include one of the chat variables
    in the prompt to specify context, like `#file` or `#selection`. For example, we
    can specifically ask Copilot how to test the code in a file in our project by
    using the `#file` chat variable (see [Figure 7-10](#testing-go-with-file)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0710.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-10\. Testing Go with the `#file` chat variable
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Specifying Chat Variables and Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply typing in chat variables and arguments directly does not always work.
    What does always work is starting to type the chat variable (#) and then selecting
    the chat variable from the pop-up list by using the arrow keys to move, if needed,
    and the Enter key to select one. You should make sure to select any intended files
    from the list that pops up.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that by using the `#file` chat variable, we did not need to have the
    file actually open or active in the editor. This mechanism then affords you a
    way to direct Copilot to the relevant content in the project for context. This
    overrides Copilot’s default mechanisms for determining which content you want.
  prefs: []
  type: TYPE_NORMAL
- en: Even with a directed context, Copilot may still respond with out-of-date code
    or information, depending on when the model was trained. Or the responses it returns
    may not seem as relevant or comprehensive as you want. But since Copilot provides
    multiple models to choose from, there may be a simple way to deal with that.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copilot allows you to choose from more than one AI model for code suggestions
    and chat responses. Each model will have its pros and cons. For example, some
    models may be better at code generation. In addition, each model will have been
    trained at a different point in time, so newer models will be more up-to-date
    and less likely to produce deprecated code than older models.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, changing models in the chat interface is easy. You just select
    the model name that you want to use from the drop-down list in whichever chat
    interface you’re using. See [Figure 7-11](#switching-models-in-t) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-11\. Switching models in the chat interface
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Earlier in the chapter, we showed an example of Copilot generating a random
    number function by using a deprecated method ([Figure 7-1](#asking-copilot-to-cre)).
    This was generated with the GPT-4o model.
  prefs: []
  type: TYPE_NORMAL
- en: If we switch instead to a more recent model, such as Gemini 2.5 Pro, and issue
    the same prompt, Copilot produces code using the newer standard `rand.NewSource`
    function instead of trying to use the deprecated `rand.Seed` function. Also, if
    we query Copilot about whether the *Seed* function is deprecated in the main chat
    area, it correctly responds that the `rand.Seed` function is deprecated as of
    Go 1.20\. [Figure 7-12](#using-a-newer-model-r) shows the response from using
    the newer model.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0712.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-12\. Using a newer model results in correct code and response
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you choose a different model, how do you know whether it will be more up
    to date? Typically, the models list will be updated as newer models become available—usually
    marked as *Preview* for some period of time. But you can also do some simple searching
    on the web or with a site like [Hugging Face](http://huggingface.co) to find which
    models are more recent.
  prefs: []
  type: TYPE_NORMAL
- en: You can also try querying the model itself through Copilot to find out more
    about which version of something was current when the model was being trained.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the Model to Determine Which Version Is Current
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Still looking at the example where Copilot generated deprecated code, let’s
    see what other details we can find to help. Since Copilot didn’t recognize that
    the function was deprecated, it would be useful to know what version of Go Copilot
    thinks is current. We can ask it in the chat interface with a simple “As of your
    last training date, what was the current version of Go?” prompt, as shown in [Figure 7-13](#asking-copilot-which).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0713.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-13\. Asking Copilot which version of Go is current
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Framing the Question Appropriately
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The question we asked Copilot was framed as “As of your last training date....”
    This is deliberate. If we simply asked Copilot, “What version of Go is current?,”
    it would likely tell us how to find the information ourselves about our local
    Go installation instead.
  prefs: []
  type: TYPE_NORMAL
- en: The model that is active in Copilot responds that its last training update was
    in October 2023—and that, as of that date, the latest stable version of Go *was*
    1.21.1.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious question that comes up is why, if Copilot knew about 1.21.1 as the
    most recent version, it still does not recognize that something was deprecated
    in 1.20\. Keep in mind the question we asked Copilot was which version was current
    when the model was last trained, not which version was used in the repositories
    when it was trained. In fact, if you ask Copilot a similar question via comments
    inline in the editor multiple times, you will likely get a different answer (see
    [Figure 7-14](#asking-copilot-which2)). The reason for the differences is that
    the answer returned in the editor is based on version references present in the
    training data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0714.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-14\. Asking Copilot which version of Go is current in the editor
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, assuming the answer returned by the chat query is the most recent version
    that the model knows about, but the model was trained on various other versions,
    what does that buy you?
  prefs: []
  type: TYPE_NORMAL
- en: What the version information returned in the chat tells you is the most recent
    version that could be represented in the model’s training data. So, any code generated
    strictly from the model’s training will not incorporate any deprecations or use
    any new features or version-specific changes since that version.
  prefs: []
  type: TYPE_NORMAL
- en: Query Results May Vary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all models may return a discrete answer for the *latest version* question.
    Some models may just respond that they don’t have access to that information or
    suggest you look up what the latest version is.
  prefs: []
  type: TYPE_NORMAL
- en: We can extend Copilot to have capabilities to find out information about the
    latest versions of languages or platforms. [Chapter 10](ch10.html#ch10) guides
    you through implementing an extension to find out the latest version of Go as
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: When you have this awareness, you can take measures to help Copilot understand
    updates by switching to a different model or via the method we discuss in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Premium Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While switching models may be a good option to address certain issues, remember
    that use of some advanced models count as *premium requests.* Using these models
    can use up quotas faster and incur additional costs on some plans.
  prefs: []
  type: TYPE_NORMAL
- en: What if you can’t avoid the AI producing deprecated or incomplete code because
    you’re restricted to a particular model or because the models that you use do
    not have training on a newer feature? You can use one other approach to get Copilot
    to generate the kind of code you want with the context you need.
  prefs: []
  type: TYPE_NORMAL
- en: Guiding Copilot by Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at our deprecation example again, Copilot created a function to seed
    a random number generator by using a deprecated method ([Figure 7-15](#created-function-usin)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0715.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-15\. A function created using a deprecated method
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we want to get Copilot to produce code that is using the replacement for
    the deprecation, we can teach it by example. We can take the updated code snippet
    from the [Go documentation](https://oreil.ly/4vDIl) and temporarily paste it into
    the same file in our workspace. (Or we could paste it into a prompt if we’re using
    the chat interface.)
  prefs: []
  type: TYPE_NORMAL
- en: After that, if we repeat our prompt, Copilot will generate updated code that
    is based on the code snippet we included ([Figure 7-16](#updated-code-generate)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0716.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-16\. Updated code generated with the code example in place
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Obviously, this is a very simple example. In this case, Copilot essentially
    copied the code verbatim. But, regardless, the end result was still what we needed.
    After getting the desired result, the example code can then be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Making Updated Code Available
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, for Copilot to draw on separate content, it may be enough to
    put the content in another file that is opened in your IDE. In other cases, it
    may be necessary to put the content directly in the file that you’re working with.
    If that is the case, you can add in the content and then remove it when the code
    generation is correct.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section have focused on ways to deal with questions and
    challenges with content already generated by Copilot. However, you can also employ
    similar strategies before Copilot generates results to get better results up front.
    We’ll look more at that aspect in the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Context to Make Code More Relevant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to compensating for deprecations and missing new features, additional
    content that you supply to Copilot can help in another way. When you provide more
    detailed context in terms of definitions or coding examples that are relevant
    to your project, Copilot can draw on those to generate more thorough, richer,
    and relevant coding suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s look at creating some SQL content with Copilot. Revisiting
    a previous example, suppose we are working on implementing a system to manage
    university courses, students, instructors, registrations, etc. Without any other
    context, let’s ask Copilot to create a general `SELECT` statement to get students
    enrolled in a course. We can do this as simply as adding an SQL comment like this
    in the editor: `**-- define a select statement to get all the students enrolled
    in a course**`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this generic directive and no other context, Copilot will produce a reasonable,
    generalized query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing wrong with this query. It is perfectly valid given the limited
    context we’ve provided for Copilot. Assuming that we have the corresponding table
    and field names in place in our schema, this would work fine.
  prefs: []
  type: TYPE_NORMAL
- en: However, suppose we already have a more extensive set of databases in place
    for our system (with appropriate tables, data, etc.). We would really like Copilot
    to generate suggestions that are relevant to those and use the elements that we
    already have defined. How can we accomplish this?
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism for doing this is similar to what we did for the deprecation example
    in the last section, adding more context for Copilot to pick up in the workspace.
    In this case, while we don’t have a way for Copilot to dynamically examine our
    data stores, indices, or stored procedures, we can provide a static representation
    of them via the schema definitions. We can use either an original SQL definition
    if we have one or a dump of the schemas from the existing content. A portion of
    a file that we might use is shown in [Figure 7-17](#example-extended-sche).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0717.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-17\. Example extended schema definitions to use for context
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This file has specific tables defined for the domains we’re working with, along
    with relevant fields, keys, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add this file to our workspace so that it is part of our project and
    open it in the editor. Copilot now has this additional context available to draw
    from. We can go back and provide the same directive in comment form as before: `--
    define a select statement to get all the students enrolled in a course`. This
    time, Copilot produces the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that now, with the additional context from the other file available in
    the workspace, Copilot produced a much richer, more detailed, and more relevant
    query. It also used specific table and field names provided in the other file.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that Copilot prioritizes the context you’re using in the IDE
    for deciding how to generate code. Leveraging this kind of approach is a useful
    and simple strategy to getting much more usable and pertinent coding suggestions
    and answers from Copilot than would be possible if you simply relied on the model’s
    training data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Additional File as Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the SQL example shown here, we added the file as an additional one in the
    workspace and opened it in the IDE. We did not take the contents of the file and
    paste it into the active file as we did for the deprecation example. While we
    could have done that, it was not necessary here.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the use case, you may find that one or the other of these two approaches
    (inserting content directly into the active file or opening the content as a *peer*
    file) works better for you. You can always start by opening the content as a peer
    file and trying that. If you don’t get the expected results, then you can add
    the content directly into the active file.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to paste relevant examples directly into Copilot Chat for
    it to work from—if the scope of the example is a good fit for that.
  prefs: []
  type: TYPE_NORMAL
- en: If you are adding content into the IDE either as a new file or an addition to
    an existing file, be sure to save the changes before querying or prompting Copilot.
    Copilot relies on persisted (saved) content in the workspace to draw on for context.
  prefs: []
  type: TYPE_NORMAL
- en: The point is that adding richer context up front for Copilot can produce improved
    results in the form of suggestions or completions. In some cases, it may be more
    time-consuming to generate files like the schema one we used here, but the trade-off
    is less time and effort remediating Copilot’s suggestions to get to the detail
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve covered the various aspects about how Copilot determines
    context for its code suggestions and responses, why those may not be up-to-date
    or accurate, and some ways you can help deal with those situations.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot’s core context comes from the training in the underlying models it uses.
    Since these models are only as current as the point in time when they were last
    trained, they are missing any updates or changes in the languages and frameworks
    that were not part of their training. In addition, the content they were trained
    on will be using older versions of tooling. So, suggestions or responses generated
    from those can be substantially out of date. This is a key aspect to be aware
    of and watch out for. One possible quick fix for this is to switch to an updated
    model if one is available.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Copilot also pulls in context from the available content in the
    editor and workspace you’re using. This context is prioritized over the training
    data since it reflects what you are doing and using currently. Because of this
    approach, you can provide Copilot with more up-to-date and more relevant context
    to draw on. You do this by including your own relevant content in the IDE and
    workspace. This can be done in most cases by having a file with relevant information
    open in the IDE. For more explicit direction, the relevant information can be
    added to the current file for as long as needed for Copilot to draw from.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Copilot also includes ways to focus the AI on specific content you have.
    Chat participants can define overall context areas for Copilot to answer questions
    and respond about. The current set of participants include ones for VS Code, the
    active terminal, and your workspace.
  prefs: []
  type: TYPE_NORMAL
- en: At a more detailed level, you can steer Copilot’s context to particular items
    within your workspace via chat variables. Examples include the current selection
    in the editor, the content open in the editor, the last command in the terminal,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to supply more context for GitHub Copilot when
    you’re working with SQL. This is an example of a nontypical language/framework
    that you can also use Copilot for. The next chapter explores more examples of
    how to use Copilot for such nontypical areas.
  prefs: []
  type: TYPE_NORMAL
