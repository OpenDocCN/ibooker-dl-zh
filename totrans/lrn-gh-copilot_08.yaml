- en: Chapter 7\. Keeping Copilot Timely and Relevant
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章：保持Copilot及时和相关性
- en: The range of functionality and interactivity provided by GitHub Copilot is truly
    impressive. However, the responses it generates can sometimes be less impressive
    (and less useful) if they are not timely and relevant. As good as the AI can be,
    at times you may need to take extra steps to *steer* it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot提供的功能范围和交互性真正令人印象深刻。然而，如果它们不及时且不相关，它生成的响应有时可能不那么令人印象深刻（也不那么有用）。尽管AI可能很好，但有时您可能需要采取额外步骤来*引导*它。
- en: For example, in certain instances, you may need to direct Copilot to focus on
    certain portions of your content to get targeted answers. Or you may need to augment
    its training to get responses more relevant to your codebase. And you may need
    to pay extra attention to be aware when Copilot is suggesting code that may be
    out of date or referencing features that are no longer supported.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在某些情况下，您可能需要指示Copilot关注您内容中的特定部分以获得针对性的答案。或者您可能需要增强其训练以获得与您的代码库更相关的响应。您可能还需要特别注意，以便在Copilot建议的代码可能过时或引用不再受支持的特性时能够意识到。
- en: In this chapter, we’re going to look at how to manage interaction with Copilot
    in these situations. You can leverage certain strategies and functionality to
    help ensure relevancy and timeliness in your interactions with Copilot. Certain
    approaches can compensate when Copilot may not be aware of recent changes or referencing
    the right sources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在这些情况下管理与Copilot的交互。您可以利用某些策略和功能来帮助确保与Copilot的交互具有相关性和及时性。某些方法可以在Copilot可能没有意识到最近的变化或引用正确的来源时进行补偿。
- en: 'All of this is aimed at helping Copilot have the most usable set of context
    in order to provide the most useful responses for what we’re asking of it. In
    the next few pages, we’ll look at the following areas related to Copilot’s use
    of context:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些旨在帮助Copilot拥有最可用的上下文集，以便为我们所请求的提供最有用的响应。在接下来的几页中，我们将探讨与Copilot使用上下文相关的以下领域：
- en: Where context originates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文起源
- en: How timeliness and relevancy may be affected
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 及时性和相关性可能受到的影响
- en: User-based coping strategies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户的应对策略
- en: Adding context to make code more relevant
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加上下文以使代码更具相关性
- en: By its very definition, *generative* implies generating new content in part
    based on gathering and processing context. So, let’s start with a reminder of
    where the context that Copilot uses comes from.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其定义，*生成性*意味着在部分基于收集和处理上下文的基础上生成新内容。因此，让我们先回顾一下Copilot使用的上下文来源。
- en: Where Context Originates
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文起源
- en: As we’ve discussed in previous chapters, in the IDE, Copilot draws context from
    your immediate working environment—specifically, from the files you have in your
    workspace and the content associated with them. This includes typical items like
    the name of the file, the comments in them, and the code before and after the
    cursor. But Copilot also draws from more dynamic interactions, such as whether
    or not you accepted its last code suggestion. And by automatically creating an
    index of your repository, Copilot gains a larger understanding of your project.
    Copilot can also be directed to take other content into consideration.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中讨论的那样，在IDE中，Copilot从您的即时工作环境中获取上下文——具体来说，是从您工作区中的文件及其相关内容中获取。这包括典型的项目，如文件名、其中的注释以及光标前后方的代码。但Copilot还可以从更动态的交互中获取信息，例如您是否接受了它最后的代码建议。通过自动创建您的仓库索引，Copilot可以更深入地理解您的项目。Copilot还可以被指示考虑其他内容。
- en: For quickly generating coding suggestions in your IDE/editor, targeting the
    files you have open is a useful strategy used by Copilot. The focus allows it
    to quickly get a good sense of what is presumably most important (since you have
    those files readily accessible).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在IDE/编辑器中快速生成编码建议，针对您打开的文件是一种Copilot使用的有用策略。这种关注使它能够快速获得一个良好的感觉，了解哪些内容可能是最重要的（因为您可以轻松访问这些文件）。
- en: In this *inline* mode, Copilot uses multiple strategies to ensure a fast response.
    The client (extension installed in your interface) asks the model for very few
    suggestions (one to three). Copilot is aggressive in caching results and adapts
    the suggestions if you continue typing. It also has some built-in checks, preventing
    sending requests if you are typing in the middle of a line, for example, unless
    there is whitespace to the right of the cursor. Then the index we’ve discussed
    is updated based on changes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: In this mode, scoring also happens to determine whether the prompt assembled
    to send to the model is even worthwhile (worth invoking the model). This decision
    is based on factors like previous responses to suggestions. This approach helps
    exclude repetitive prompts or ones that already exist in the code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Most of these same strategies are not needed when you switch to the chat interface.
    Within that, Copilot has more time to come up with responses, and so more completion
    suggestions can be requested by the client. For gathering context when working
    in this interface, you can also be more directive of where to get the context.
    Copilot includes methods like chat variables and chat participants (as discussed
    in [Chapter 3](ch03.html#ch03) and other chapters) to focus Copilot on particular
    items.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of where the user is working, the client collects the context, processes
    it into a prompt, and sends it to the model you’ve selected. After doing some
    quick validation of what the model returns and generating the requested set of
    responses, those are then displayed to the user. The responses can include multiple
    options in the IDE if multiple completion suggestions were available.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The *quick validation* just referred to involves quickly looking for patterns
    in the response that are repetitive or might indicate a security issue (such as
    hardcoded credentials). These are beneficial checks, but they don’t prevent other
    factors that may lead to relevancy and timeliness being off. Let’s look at some
    of those other factors next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: How Timeliness and Relevancy May Be Affected
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you first open up Copilot’s chat interface, you get a notification:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This disclaimer is a reminder that generative AI can be inaccurate and problematic.
    Ultimately, it’s up to the user to ensure that the generated content is correct
    and relevant. (This is also why you should always use standard validation methods
    like testing and code reviews to check any content produced with the assistance
    of the AI.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The disclaimer is necessary because several kinds of challenges can affect
    the timeliness and relevancy of Copilot’s suggestions and responses. These include
    the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Training cutoffs
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hallucinations
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of real-time validation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mistaken context
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each of these in more detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Training Cutoffs
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LLMs are trained on data that is current as of the time the training occurs.
    Beyond that date, the model has no *built-in* knowledge of changes that have occurred
    in the areas it was trained in. The further away from the training cutoff your
    use of the tool occurs, the more likely some of the responses and suggestions
    will be out of date. This can manifest as Copilot producing deprecated code or
    code that was more relevant for a previous version of a framework or language.
    And, of course, results will vary depending on which model you choose to use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Training Frequency
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re wondering why these models aren’t kept more up to date, it’s important
    to understand that they have billions of parameters and huge corpora of data to
    process for any training. This requires significant compute cost and time to accomplish.
    So, updates to the wider underlying training are expensive in multiple ways.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a simple example of challenges that may occur from training cutoffs
    (as surfaced through Copilot as of the time of this writing). We’ll ask Copilot
    to write a function to seed a random number generator in Go ([Figure 7-1](#asking-copilot-to-cre)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0701.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Asking Copilot to create a random number generator in Go
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While this looks fine and is syntactically correct, there is a problem. The
    `Seed` function was [deprecated in Go](https://oreil.ly/D2hpj) as of version 1.20\.
    Let’s see if Copilot understands that this is deprecated. We can ask it in the
    Chat interface “Is the Seed function deprecated in Go?” The response, as shown
    in [Figure 7-2](#asking-copilot-if-the), shows that, based on the model’s training,
    it doesn’t have the information that the function is deprecated.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0702.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Asking Copilot if the `Seed` function is deprecated
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So although the function is no longer meant to be used, Copilot was not aware
    of that. This illustrates the point about the training cutoff. We’ll look at some
    ways to deal with these kind of challenges later in the chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-date results represent one category of problems; results would have been
    valid at one time but no longer are. Another category of issues arises when results
    look valid for the current context but may not reflect real data or references.These
    are known as *hallucinations*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Hallucinations
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LLMs are subject to creating responses with data that looks legitimate but isn’t.
    These are referred to as *hallucinations*. In general chat interfaces, this can
    take the form of referencing nonexistent items or stating as fact things that
    simply aren’t true. In more critical systems, such as threat detection, an AI
    model may flag something as a threat when it is not.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of coding, hallucinations can take several forms:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Coding suggestions that may reference identifiers (names, variables, constants,
    etc.) or related code that does not exist
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generated data that may not be accurate
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions or methods that don’t exist
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect library or API usage (or use of libraries or APIs that don’t exist
    at all)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made-up types or classes
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plausible but incorrect business logic
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad assumptions about surrounding code
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests that don’t actually test the intended behavior
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While hallucinations in the first category can certainly still occur in output
    produced from Copilot, they seem less common now than in Copilot’s early days
    due to improvements with the underlying models. These kinds of hallucinations
    (referencing identifiers or code that doesn’t exist) tend to be more obvious and
    can usually be caught quickly by user reviews. If these hallucinations do end
    up getting accepted and overlooked, compilers, linters, or other tools that check
    syntax will likely flag them at some point.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The second type of hallucination (involving generated data) is more subtle.
    It occurs in part because there is no real-time automatic validation of generated
    data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Lack of Real-Time Validation
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generated data that Copilot returns may not be accurate. Copilot itself sometimes
    reminds you of that, as shown in [Figure 7-4](#copilot-disclaimer-on). In this
    case, we asked Copilot to generate a mapping of area codes to states. After completing
    the tasks, Copilot adds the disclaimer that “The above code is just a placeholder
    and may not represent the actual area codes for each state.”
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0704.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. A Copilot disclaimer on the accuracy of the generated data
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Why is this the case? Keep these four points in mind:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Copilot is trained on data which may or may not contain accurate, actual values.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot is generating results to match syntax and structure.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot does not run code that it generates and doesn’t validate logic.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot does not have mechanisms to look up and check data to see if it is accurate
    or up-to-date.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three items are self-explanatory. The fourth item indicates that Copilot
    has no mechanism to cross-check results it generates against other sources such
    as the web. While some AI techniques can leverage tools to do this, they are not
    integrated with Copilot for the purpose of validating responses from the model.
    The data may be correct, but there is no guarantee. In short, Copilot has no way
    of knowing if something is true or false.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you should not assume correctness when using information generated
    by Copilot. Data generation from Copilot is better suited for content that needs
    correct form but not necessarily correct values, like testing scenarios.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Copilot Extensions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create Copilot Extensions that call APIs or other tools to get more
    relevant, up-to-date information for particular use cases. You can either find
    an existing extension that already addresses what you’re looking to do or build
    your own. Copilot Extensions are covered in detail in [Chapter 10](ch10.html#ch10).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge you may encounter is having Copilot use context you did not
    intend for it to reference for its responses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Misplaced Context
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, when you are chatting with Copilot in the IDE’s chat interface,
    you will have a file active in the editor. You may also have a portion of it selected.
    In those cases, Copilot assumes this is the main context that any open-ended questions
    (such as “How do I test this?”) refer to.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Having Copilot use that specific content may be exactly what you intend. Or
    you might have intended for Copilot to respond based on a different file or a
    different portion of the active file. If Copilot assumes a different context,
    Copilot’s answers may not be what you are looking for.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are using multiple languages or frameworks in a project and have
    context set that doesn’t align with your prompt. Such a project is shown in [Figure 7-5](#wrong-context-for-pro).
    In this project, we have a Python file (*fibonacci.py*) and one written in Go
    (*prime.go*), as shown in the upper left of the IDE.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: With the Python file selected (and thus used as context), we ask Copilot, “How
    do I test the Go code here?” Copilot responds by telling us about the mismatch
    between the context and the prompt. It then provides information about how to
    do Python testing to align with the active file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0705.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. Indicating the wrong context for a prompt
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another type of issue can arise when no context is implied.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Missing Context
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we prompt Copilot and have no files open in the workspace and nothing else
    in the prompt for it to draw on, Copilot will usually offer a more generic response.
    For example, assume we have a workspace with Go code to implement a Kubernetes
    operator, and we have no files actively open and nothing selected. Now, we prompt
    Copilot in chat with “How can I test the Go code here?”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Because no context is indicated, Copilot either will tell you to select context
    or will supply a response about how you can answer the question generally. [Figure 7-6](#generic-advice-per-mi)
    shows an example response for the case we just discussed. Here, Copilot provides
    guidance on how to test Go code generally.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0706.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. Generic advice per missing context
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This type of response also happens for other types of queries, such as trying
    to determine where imports are used in the codebase ([Figure 7-7](#another-example)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0707.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. Another example of a generic response
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The bottom line is that without enough implicit context (open files) or explicit
    context (references supplied in the prompt), Copilot defaults to generic answers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: When you start working with Copilot for any length of time, you will run into
    these classes of issues. The impact will vary depending on your particular situation.
    Fortunately, you, as a user, can employ a few strategies when you encounter these
    scenarios.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: User-Based Coping Strategies
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, we have three strategies to help when Copilot’s responses are not
    as accurate or timely as we may need:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly telling Copilot what to use for context
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the model
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmenting the data that Copilot has available for context
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each of these in turn.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Telling Copilot What to Use for Context
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we outlined earlier in this chapter, absent more explicit direction, Copilot
    tries to gather context from what’s being actively used in the editor. If we are
    working directly in the editor, this may be correct in most cases. However, when
    we are working with the chat interface, we may want to have Copilot focus on other
    parts of the project or answer a generic question such as “Where is X used?”
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Since we are dealing with the chat interface, we can leverage Copilot’s built-in
    features of chat participants and chat variables. These features were covered
    in detail in [Chapter 3](ch03.html#ch03). Here, we’ll provide a simple reminder
    of how to use them to help with cases like these.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The chat participants have knowledge of different domains that Copilot may need
    to work with, including the overall workspace, the terminal, and VS Code. When
    we use a participant in a query, it steers Copilot to use that domain for context
    with the prompt.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: In an earlier section, when we were looking at a project, we asked Copilot,
    “Where are imports used in this code?” We got a generic response telling us the
    steps to find imports for any Go project rather than for our project. The same
    was true for the “How can I test the Go code here?” prompt. Copilot responded
    with generic instructions for how we could determine the information for ourselves.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: However, if instead we explicitly use the `@workspace` participant in the prompt,
    Copilot provides information from the files we have as part of the workspace (see
    [Figure 7-8](#context-with-workspa)). The prompt is “@workspace Where are imports
    used in this code?” This matches the original intent.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0708.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. Context with `@workspace`
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also implicitly direct Copilot to use `@workspace`. Certain keywords
    or phrases in your prompt can trigger Copilot to add `@workspace` to the prompt.
    For instance, we can modify our previous prompt about testing to “How can I test
    the Go code in this project?” The reference to *project* is enough for Copilot
    to understand that we mean the larger context. It then automatically runs our
    prompt by using `@workspace` and the shortcut command `/setupTests`, as shown
    in [Figure 7-9](#implicitly-using-wor).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0709.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9\. Implicitly using `@workspace` based on the prompt text
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we need to further zero in on content, we can include one of the chat variables
    in the prompt to specify context, like `#file` or `#selection`. For example, we
    can specifically ask Copilot how to test the code in a file in our project by
    using the `#file` chat variable (see [Figure 7-10](#testing-go-with-file)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0710.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: Figure 7-10\. Testing Go with the `#file` chat variable
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Specifying Chat Variables and Arguments
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply typing in chat variables and arguments directly does not always work.
    What does always work is starting to type the chat variable (#) and then selecting
    the chat variable from the pop-up list by using the arrow keys to move, if needed,
    and the Enter key to select one. You should make sure to select any intended files
    from the list that pops up.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Notice that by using the `#file` chat variable, we did not need to have the
    file actually open or active in the editor. This mechanism then affords you a
    way to direct Copilot to the relevant content in the project for context. This
    overrides Copilot’s default mechanisms for determining which content you want.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Even with a directed context, Copilot may still respond with out-of-date code
    or information, depending on when the model was trained. Or the responses it returns
    may not seem as relevant or comprehensive as you want. But since Copilot provides
    multiple models to choose from, there may be a simple way to deal with that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Model
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copilot allows you to choose from more than one AI model for code suggestions
    and chat responses. Each model will have its pros and cons. For example, some
    models may be better at code generation. In addition, each model will have been
    trained at a different point in time, so newer models will be more up-to-date
    and less likely to produce deprecated code than older models.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, changing models in the chat interface is easy. You just select
    the model name that you want to use from the drop-down list in whichever chat
    interface you’re using. See [Figure 7-11](#switching-models-in-t) for an example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0711.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 7-11\. Switching models in the chat interface
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Earlier in the chapter, we showed an example of Copilot generating a random
    number function by using a deprecated method ([Figure 7-1](#asking-copilot-to-cre)).
    This was generated with the GPT-4o model.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: If we switch instead to a more recent model, such as Gemini 2.5 Pro, and issue
    the same prompt, Copilot produces code using the newer standard `rand.NewSource`
    function instead of trying to use the deprecated `rand.Seed` function. Also, if
    we query Copilot about whether the *Seed* function is deprecated in the main chat
    area, it correctly responds that the `rand.Seed` function is deprecated as of
    Go 1.20\. [Figure 7-12](#using-a-newer-model-r) shows the response from using
    the newer model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0712.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Figure 7-12\. Using a newer model results in correct code and response
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you choose a different model, how do you know whether it will be more up
    to date? Typically, the models list will be updated as newer models become available—usually
    marked as *Preview* for some period of time. But you can also do some simple searching
    on the web or with a site like [Hugging Face](http://huggingface.co) to find which
    models are more recent.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: You can also try querying the model itself through Copilot to find out more
    about which version of something was current when the model was being trained.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Querying the Model to Determine Which Version Is Current
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Still looking at the example where Copilot generated deprecated code, let’s
    see what other details we can find to help. Since Copilot didn’t recognize that
    the function was deprecated, it would be useful to know what version of Go Copilot
    thinks is current. We can ask it in the chat interface with a simple “As of your
    last training date, what was the current version of Go?” prompt, as shown in [Figure 7-13](#asking-copilot-which).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0713.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 7-13\. Asking Copilot which version of Go is current
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Framing the Question Appropriately
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The question we asked Copilot was framed as “As of your last training date....”
    This is deliberate. If we simply asked Copilot, “What version of Go is current?,”
    it would likely tell us how to find the information ourselves about our local
    Go installation instead.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The model that is active in Copilot responds that its last training update was
    in October 2023—and that, as of that date, the latest stable version of Go *was*
    1.21.1.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: An obvious question that comes up is why, if Copilot knew about 1.21.1 as the
    most recent version, it still does not recognize that something was deprecated
    in 1.20\. Keep in mind the question we asked Copilot was which version was current
    when the model was last trained, not which version was used in the repositories
    when it was trained. In fact, if you ask Copilot a similar question via comments
    inline in the editor multiple times, you will likely get a different answer (see
    [Figure 7-14](#asking-copilot-which2)). The reason for the differences is that
    the answer returned in the editor is based on version references present in the
    training data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0714.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Figure 7-14\. Asking Copilot which version of Go is current in the editor
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, assuming the answer returned by the chat query is the most recent version
    that the model knows about, but the model was trained on various other versions,
    what does that buy you?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: What the version information returned in the chat tells you is the most recent
    version that could be represented in the model’s training data. So, any code generated
    strictly from the model’s training will not incorporate any deprecations or use
    any new features or version-specific changes since that version.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Query Results May Vary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all models may return a discrete answer for the *latest version* question.
    Some models may just respond that they don’t have access to that information or
    suggest you look up what the latest version is.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: We can extend Copilot to have capabilities to find out information about the
    latest versions of languages or platforms. [Chapter 10](ch10.html#ch10) guides
    you through implementing an extension to find out the latest version of Go as
    an example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: When you have this awareness, you can take measures to help Copilot understand
    updates by switching to a different model or via the method we discuss in the
    next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Premium Requests
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While switching models may be a good option to address certain issues, remember
    that use of some advanced models count as *premium requests.* Using these models
    can use up quotas faster and incur additional costs on some plans.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: What if you can’t avoid the AI producing deprecated or incomplete code because
    you’re restricted to a particular model or because the models that you use do
    not have training on a newer feature? You can use one other approach to get Copilot
    to generate the kind of code you want with the context you need.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Guiding Copilot by Example
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at our deprecation example again, Copilot created a function to seed
    a random number generator by using a deprecated method ([Figure 7-15](#created-function-usin)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0715.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Figure 7-15\. A function created using a deprecated method
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we want to get Copilot to produce code that is using the replacement for
    the deprecation, we can teach it by example. We can take the updated code snippet
    from the [Go documentation](https://oreil.ly/4vDIl) and temporarily paste it into
    the same file in our workspace. (Or we could paste it into a prompt if we’re using
    the chat interface.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: After that, if we repeat our prompt, Copilot will generate updated code that
    is based on the code snippet we included ([Figure 7-16](#updated-code-generate)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0716.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Figure 7-16\. Updated code generated with the code example in place
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Obviously, this is a very simple example. In this case, Copilot essentially
    copied the code verbatim. But, regardless, the end result was still what we needed.
    After getting the desired result, the example code can then be removed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Making Updated Code Available
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, for Copilot to draw on separate content, it may be enough to
    put the content in another file that is opened in your IDE. In other cases, it
    may be necessary to put the content directly in the file that you’re working with.
    If that is the case, you can add in the content and then remove it when the code
    generation is correct.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section have focused on ways to deal with questions and
    challenges with content already generated by Copilot. However, you can also employ
    similar strategies before Copilot generates results to get better results up front.
    We’ll look more at that aspect in the last section of this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Adding Context to Make Code More Relevant
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to compensating for deprecations and missing new features, additional
    content that you supply to Copilot can help in another way. When you provide more
    detailed context in terms of definitions or coding examples that are relevant
    to your project, Copilot can draw on those to generate more thorough, richer,
    and relevant coding suggestions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s look at creating some SQL content with Copilot. Revisiting
    a previous example, suppose we are working on implementing a system to manage
    university courses, students, instructors, registrations, etc. Without any other
    context, let’s ask Copilot to create a general `SELECT` statement to get students
    enrolled in a course. We can do this as simply as adding an SQL comment like this
    in the editor: `**-- define a select statement to get all the students enrolled
    in a course**`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说明，让我们看看如何使用Copilot创建一些SQL内容。回顾先前的例子，假设我们正在实施一个管理系统，用于管理大学课程、学生、讲师、注册等。在没有其他上下文的情况下，让我们让Copilot创建一个通用的`SELECT`语句来获取选修某门课程的学生。我们可以在编辑器中简单地添加一个SQL注释来实现这一点：`**--
    定义一个SELECT语句以获取所有选修某门课程的学生**`。
- en: 'Given this generic directive and no other context, Copilot will produce a reasonable,
    generalized query like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个通用指令和没有其他上下文，Copilot将生成一个合理的、通用的查询，如下所示：
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is nothing wrong with this query. It is perfectly valid given the limited
    context we’ve provided for Copilot. Assuming that we have the corresponding table
    and field names in place in our schema, this would work fine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询没有问题。考虑到我们为Copilot提供的有限上下文，它是完全有效的。假设我们在我们的模式中有相应的表和字段名称，这将运行良好。
- en: However, suppose we already have a more extensive set of databases in place
    for our system (with appropriate tables, data, etc.). We would really like Copilot
    to generate suggestions that are relevant to those and use the elements that we
    already have defined. How can we accomplish this?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们已经在系统中建立了一个更广泛的数据库集合（包括适当的表、数据等）。我们真的希望Copilot生成与这些相关的建议，并使用我们已定义的元素。我们如何实现这一点？
- en: The mechanism for doing this is similar to what we did for the deprecation example
    in the last section, adding more context for Copilot to pick up in the workspace.
    In this case, while we don’t have a way for Copilot to dynamically examine our
    data stores, indices, or stored procedures, we can provide a static representation
    of them via the schema definitions. We can use either an original SQL definition
    if we have one or a dump of the schemas from the existing content. A portion of
    a file that we might use is shown in [Figure 7-17](#example-extended-sche).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的机制与我们在上一节中为弃用示例所做的类似，为Copilot在工作区中提供更多上下文。在这种情况下，虽然我们没有让Copilot动态检查我们的数据存储、索引或存储过程的方法，但我们可以通过模式定义提供它们的静态表示。我们可以使用原始的SQL定义（如果有的话）或现有内容的模式转储。我们可能使用的文件部分如图7-17所示[图7-17](#example-extended-sche)。
- en: '![](assets/lghc_0717.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_0717.png)'
- en: Figure 7-17\. Example extended schema definitions to use for context
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-17\. 用于上下文的示例扩展模式定义
- en: This file has specific tables defined for the domains we’re working with, along
    with relevant fields, keys, etc.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件为我们在其中工作的领域定义了特定的表，以及相关的字段、键等。
- en: 'Let’s add this file to our workspace so that it is part of our project and
    open it in the editor. Copilot now has this additional context available to draw
    from. We can go back and provide the same directive in comment form as before: `--
    define a select statement to get all the students enrolled in a course`. This
    time, Copilot produces the following response:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此文件添加到我们的工作区，使其成为我们项目的一部分，并在编辑器中打开它。现在，Copilot有了这个额外的上下文可供参考。我们可以回到之前以注释形式提供的相同指令：`--
    定义一个SELECT语句以获取所有选修某门课程的学生`。这一次，Copilot生成了以下响应：
- en: '[PRE2]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that now, with the additional context from the other file available in
    the workspace, Copilot produced a much richer, more detailed, and more relevant
    query. It also used specific table and field names provided in the other file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在，由于工作区中其他文件提供的附加上下文，Copilot生成了一个更丰富、更详细、更相关的查询。它还使用了其他文件中提供的特定表和字段名称。
- en: The key here is that Copilot prioritizes the context you’re using in the IDE
    for deciding how to generate code. Leveraging this kind of approach is a useful
    and simple strategy to getting much more usable and pertinent coding suggestions
    and answers from Copilot than would be possible if you simply relied on the model’s
    training data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，Copilot优先考虑你在IDE中使用的上下文来决定如何生成代码。利用这种方法的策略是获取比仅依赖模型训练数据更多可用和相关的编码建议和答案的有用且简单策略。
- en: Adding the Additional File as Context
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将附加文件作为上下文添加
- en: In the SQL example shown here, we added the file as an additional one in the
    workspace and opened it in the IDE. We did not take the contents of the file and
    paste it into the active file as we did for the deprecation example. While we
    could have done that, it was not necessary here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示的 SQL 示例中，我们将文件作为工作空间中的附加文件添加，并在 IDE 中打开它。我们没有像在弃用示例中那样将文件内容复制并粘贴到活动文件中。虽然我们可以这样做，但在这里并不必要。
- en: Depending on the use case, you may find that one or the other of these two approaches
    (inserting content directly into the active file or opening the content as a *peer*
    file) works better for you. You can always start by opening the content as a peer
    file and trying that. If you don’t get the expected results, then you can add
    the content directly into the active file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用例，您可能会发现这两种方法（直接将内容插入活动文件或以 *同伴* 文件的形式打开内容）中的一种更适合您。您始终可以从将内容作为同伴文件打开并尝试开始。如果您没有得到预期的结果，然后您可以直接将内容添加到活动文件中。
- en: Another option is to paste relevant examples directly into Copilot Chat for
    it to work from—if the scope of the example is a good fit for that.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将相关示例直接粘贴到 Copilot Chat 中，以便它从中工作——如果示例的范围适合这样做的话。
- en: If you are adding content into the IDE either as a new file or an addition to
    an existing file, be sure to save the changes before querying or prompting Copilot.
    Copilot relies on persisted (saved) content in the workspace to draw on for context.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在将内容添加到 IDE 中，无论是作为新文件还是现有文件的补充，在查询或提示 Copilot 之前，请确保保存更改。Copilot 依赖于工作空间中持久化（已保存）的内容来提取上下文。
- en: The point is that adding richer context up front for Copilot can produce improved
    results in the form of suggestions or completions. In some cases, it may be more
    time-consuming to generate files like the schema one we used here, but the trade-off
    is less time and effort remediating Copilot’s suggestions to get to the detail
    you need.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，为 Copilot 提供更丰富的上下文可以产生改进的结果，形式为建议或补全。在某些情况下，生成像我们这里使用的模式文件这样的文件可能需要更多时间，但权衡是减少时间和精力来修复
    Copilot 的建议，以获得您需要的详细信息。
- en: Conclusion
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we’ve covered the various aspects about how Copilot determines
    context for its code suggestions and responses, why those may not be up-to-date
    or accurate, and some ways you can help deal with those situations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Copilot 确定代码建议和响应上下文的各个方面，为什么这些可能不是最新的或准确的，以及一些可以帮助处理这些情况的方法。
- en: Copilot’s core context comes from the training in the underlying models it uses.
    Since these models are only as current as the point in time when they were last
    trained, they are missing any updates or changes in the languages and frameworks
    that were not part of their training. In addition, the content they were trained
    on will be using older versions of tooling. So, suggestions or responses generated
    from those can be substantially out of date. This is a key aspect to be aware
    of and watch out for. One possible quick fix for this is to switch to an updated
    model if one is available.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 的核心上下文来自其使用的底层模型的训练。由于这些模型只更新到它们最后一次训练的时间点，因此它们缺少任何未包含在训练中的语言和框架的更新或变化。此外，它们训练的内容将使用工具的较旧版本。因此，从这些生成的建议或响应可能严重过时。这是需要注意并警惕的关键方面。一个可能的快速修复方法是如果可用，切换到更新的模型。
- en: Fortunately, Copilot also pulls in context from the available content in the
    editor and workspace you’re using. This context is prioritized over the training
    data since it reflects what you are doing and using currently. Because of this
    approach, you can provide Copilot with more up-to-date and more relevant context
    to draw on. You do this by including your own relevant content in the IDE and
    workspace. This can be done in most cases by having a file with relevant information
    open in the IDE. For more explicit direction, the relevant information can be
    added to the current file for as long as needed for Copilot to draw from.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Copilot 也会从您正在使用的编辑器和工作空间中可用的内容中提取上下文。由于这反映了您当前正在做什么和使用什么，因此这种上下文优先于训练数据。正因为如此，您可以向
    Copilot 提供更多最新和更相关的上下文来参考。您可以通过在 IDE 和工作空间中包含自己的相关内容来实现这一点。在大多数情况下，这可以通过在 IDE
    中打开包含相关信息的文件来完成。为了更明确地指导，相关信息可以添加到当前文件中，直到 Copilot 需要从中提取信息为止。
- en: GitHub Copilot also includes ways to focus the AI on specific content you have.
    Chat participants can define overall context areas for Copilot to answer questions
    and respond about. The current set of participants include ones for VS Code, the
    active terminal, and your workspace.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot 还包括了一些方法来聚焦 AI 在特定的内容上。聊天参与者可以为 Copilot 定义整体上下文区域，以便回答问题和做出回应。当前的参与者包括
    VS Code、活动终端和你的工作空间。
- en: At a more detailed level, you can steer Copilot’s context to particular items
    within your workspace via chat variables. Examples include the current selection
    in the editor, the content open in the editor, the last command in the terminal,
    and more.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细的层面上，你可以通过聊天变量来引导 Copilot 的上下文到工作空间中的特定项目。例如，包括编辑器中的当前选择、编辑器中打开的内容、终端中的最后一条命令等等。
- en: In this chapter, you learned how to supply more context for GitHub Copilot when
    you’re working with SQL. This is an example of a nontypical language/framework
    that you can also use Copilot for. The next chapter explores more examples of
    how to use Copilot for such nontypical areas.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在处理 SQL 时为 GitHub Copilot 提供更多上下文。这是一个非典型语言/框架的例子，你同样可以使用 Copilot。下一章将探讨更多关于如何在这些非典型领域使用
    Copilot 的例子。
