["```py\n!pip install matplotlib\n```", "```py\nheights = [189, 170, 189, 163, 183, 171, 185,\n           168, 173, 183, 173, 173, 175, 178,\n           183, 193, 178, 173, 174, 183, 183,\n           180, 168, 180, 170, 178, 182, 180,\n           183, 178, 182, 188, 175, 179, 183,\n           193, 182, 183, 177, 185, 188, 188,\n           182, 185, 191, 183]\n```", "```py\nimport torch\nheights_tensor = torch.tensor(heights,      ①\n           dtype=torch.float64)             ②\n```", "```py\nt1=torch.IntTensor([1, 2, 3])    ①\nt2=torch.tensor([1, 2, 3],\n             dtype=torch.int)    ②\nprint(t1)\nprint(t2)\n```", "```py\ntensor([1, 2, 3], dtype=torch.int32)\ntensor([1, 2, 3], dtype=torch.int32)\n```", "```py\ntensor1 = torch.zeros(2, 3)\nprint(tensor1)\n```", "```py\ntensor([[0., 0., 0.],\n        [0., 0., 0.]])\n```", "```py\ntensor2 = torch.ones(1,4,5)\nprint(tensor2)\n```", "```py\ntensor([[[1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1.]]])\n```", "```py\nimport numpy as np\n\nnparr=np.array(range(10))\npt_tensor=torch.tensor(nparr, dtype=torch.int)\nprint(pt_tensor)\n```", "```py\ntensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=torch.int32)\n```", "```py\nheight = heights_tensor[2]\nprint(height)\n```", "```py\ntensor(189., dtype=torch.float64)\n```", "```py\nheight = heights_tensor[-2]\nprint(height)\n```", "```py\ntensor(191., dtype=torch.float64)\n```", "```py\nfive_heights = heights_tensor[-5:]\nprint(five_heights)\n```", "```py\ntensor([188., 182., 185., 191., 183.], dtype=torch.float64)\n```", "```py\nprint(heights_tensor.shape)\n```", "```py\ntorch.Size([46])\n```", "```py\nheights_in_feet = heights_tensor / 30.48\nprint(heights_in_feet)\n```", "```py\ntensor([6.2008, 5.5774, 6.2008, 5.3478, 6.0039, 5.6102, 6.0696, …\n        6.0039], dtype=torch.float64)\n```", "```py\nheights_2_measures = torch.cat(\n    [heights_tensor,heights_in_feet], dim=0)\nprint(heights_2_measures.shape)\n```", "```py\ntorch.Size([92])\n```", "```py\nheights_reshaped = heights_2_measures.reshape(2, 46)\n```", "```py\nprint(heights_reshaped[1,-2])\n```", "```py\ntensor(6.2664, dtype=torch.float64)\n```", "```py\nprint(torch.median(heights_reshaped[0,:]))\n```", "```py\ntensor(182., dtype=torch.float64)\n```", "```py\nprint(torch.mean(heights_reshaped,dim=1))\n```", "```py\ntensor([180.0652,   5.9077], dtype=torch.float64)\n```", "```py\nvalues, indices = torch.max(heights_reshaped, dim=1)\nprint(values)\nprint(indices)\n```", "```py\ntensor([193.0000,   6.3320], dtype=torch.float64)\ntensor([15, 15])\n```", "```py\nimport torch\nimport torch.nn as nn\nimport torchvision\nimport torchvision.transforms as T\n\ntorch.manual_seed(42)\ntransform=T.Compose([             ①\n    T.ToTensor(),                 ②\n    T.Normalize([0.5],[0.5])])    ③\n```", "```py\ntrain_set=torchvision.datasets.FashionMNIST(    ①\n    root=\".\",                                   ②\n    train=True,                                 ③\n    download=True,                              ④\n    transform=transform)                        ⑤\ntest_set=torchvision.datasets.FashionMNIST(root=\".\",\n    train=False,download=True,transform=transform)\n```", "```py\nprint(train_set[0])\n```", "```py\ntext_labels=['t-shirt', 'trouser', 'pullover', 'dress', 'coat',\n             'sandal', 'shirt', 'sneaker', 'bag', 'ankle boot']\n```", "```py\n!pip install matplotlib\nimport matplotlib.pyplot as plt\n\nplt.figure(dpi=300,figsize=(8,4))\nfor i in range(24):\n    ax=plt.subplot(3, 8, i + 1)                 ①\n    img=train_set[i][0]                         ②\n    img=img/2+0.5                               ③\n    img=img.reshape(28, 28)                     ④\n    plt.imshow(img,\n               cmap=\"binary\")\n    plt.axis('off')\n    plt.title(text_labels[train_set[i][1]],     ⑤\n        fontsize=8)\nplt.show()\n```", "```py\nbinary_train_set=[x for x in train_set if x[1] in [0,9]]\nbinary_test_set=[x for x in test_set if x[1] in [0,9]]\n```", "```py\nbatch_size=64\nbinary_train_loader=torch.utils.data.DataLoader(\n    binary_train_set,                                ①\n    batch_size=batch_size,                           ②\n    shuffle=True)                                    ③\nbinary_test_loader=torch.utils.data.DataLoader(\n    binary_test_set,                                 ④\n    batch_size=batch_size,shuffle=True)\n```", "```py\nimport torch.nn as nn\n\ndevice=\"cuda\" if torch.cuda.is_available() else \"cpu\"  ①\n\nbinary_model=nn.Sequential(                            ②\n    nn.Linear(28*28,256),                              ③\n    nn.ReLU(),                                         ④\n    nn.Linear(256,128),\n    nn.ReLU(),\n    nn.Linear(128,32),\n    nn.ReLU(),\n    nn.Linear(32,1),\n    nn.Dropout(p=0.25),\n    nn.Sigmoid()).to(device)                           ⑤\n```", "```py\nlr=0.001\noptimizer=torch.optim.Adam(binary_model.parameters(),lr=lr)\nloss_fn=nn.BCELoss()\n```", "```py\nfor i in range(50):                                    ①\n    tloss=0\n    for imgs,labels in binary_train_loader:            ②\n        imgs=imgs.reshape(-1,28*28)                    ③\n        imgs=imgs.to(device)\n        labels=torch.FloatTensor(\\\n          [x if x==0 else 1 for x in labels])          ④\n        labels=labels.reshape(-1,1).to(device)\n        preds=binary_model(imgs)    \n        loss=loss_fn(preds,labels)                     ⑤\n        optimizer.zero_grad()\n        loss.backward()                                ⑥\n        optimizer.step()\n        tloss+=loss.detach()\n    tloss=tloss/n\n    print(f\"at epoch {i}, loss is {tloss}\")\n```", "```py\nimport numpy as np\nresults=[]\nfor imgs,labels in binary_test_loader:                     ①\n    imgs=imgs.reshape(-1,28*28).to(device)\n    labels=(labels/9).reshape(-1,1).to(device)\n    preds=binary_model(imgs)\n    pred10=torch.where(preds>0.5,1,0)                      ②\n    correct=(pred10==labels)                               ③\n    results.append(correct.detach().cpu()\\\n      .numpy().mean())                                     ④\naccuracy=np.array(results).mean()                          ⑤\nprint(f\"the accuracy of the predictions is {accuracy}\")\n```", "```py\ntrain_set,val_set=torch.utils.data.random_split(\\\n    train_set,[50000,10000])\n```", "```py\ntrain_loader=torch.utils.data.DataLoader(\n    train_set,    \n    batch_size=batch_size,   \n    shuffle=True)   \nval_loader=torch.utils.data.DataLoader(\n    val_set,    \n    batch_size=batch_size,   \n    shuffle=True)\ntest_loader=torch.utils.data.DataLoader(\n    test_set,    \n    batch_size=batch_size,   \n    shuffle=True)\n```", "```py\nclass EarlyStop:\n    def __init__(self, patience=10):         ①\n        self.patience = patience\n        self.steps = 0\n        self.min_loss = float('inf')\n    def stop(self, val_loss):                ②\n        if val_loss < self.min_loss:         ③\n            self.min_loss = val_loss\n            self.steps = 0\n        elif val_loss >= self.min_loss:      ④\n            self.steps += 1\n        if self.steps >= self.patience:\n            return True\n        else:\n            return False\nstopper=EarlyStop()\n```", "```py\nmodel=nn.Sequential(\n    nn.Linear(28*28,256),\n    nn.ReLU(),\n    nn.Linear(256,128),\n    nn.ReLU(),\n    nn.Linear(128,64),\n    nn.ReLU(),\n    nn.Linear(64,10)                         ①\n    ).to(device)                             ②\n```", "```py\nlr=0.001\noptimizer=torch.optim.Adam(model.parameters(),lr=lr)\nloss_fn=nn.CrossEntropyLoss()\n```", "```py\ndef train_epoch():\n    tloss=0\n    for n,(imgs,labels) in enumerate(train_loader):    \n        imgs=imgs.reshape(-1,28*28).to(device)\n        labels=labels.reshape(-1,).to(device)\n        preds=model(imgs)    \n        loss=loss_fn(preds,labels)\n        optimizer.zero_grad()\n        loss.backward()    \n        optimizer.step()\n        tloss+=loss.detach()\n    return tloss/n\n```", "```py\ndef val_epoch():\n    vloss=0\n    for n,(imgs,labels) in enumerate(val_loader):    \n        imgs=imgs.reshape(-1,28*28).to(device)\n        labels=labels.reshape(-1,).to(device)\n        preds=model(imgs)    \n        loss=loss_fn(preds,labels)    \n        vloss+=loss.detach()\n    return vloss/n\n```", "```py\nfor i in range(1,101):    \n    tloss=train_epoch()\n    vloss=val_epoch()\n    print(f\"at epoch {i}, tloss is {tloss}, vloss is {vloss}\")\n    if stopper.stop(vloss)==True:             \n        break  \n```", "```py\nplt.figure(dpi=300,figsize=(5,1))\nfor i in range(5):                                          ①\n    ax=plt.subplot(1,5, i + 1)\n    img=test_set[i][0]    \n    label=test_set[i][1]\n    img=img/2+0.5    \n    img=img.reshape(28, 28)    \n    plt.imshow(img, cmap=\"binary\")\n    plt.axis('off')\n    plt.title(text_labels[label]+f\"; {label}\", fontsize=8)\nplt.show()\nfor i in range(5):\n    img,label = test_set[i]                                 ②\n    img=img.reshape(-1,28*28).to(device)\n    pred=model(img)                                         ③\n    index_pred=torch.argmax(pred,dim=1)                     ④\n    idx=index_pred.item()\n    print(f\"the label is {label}; the prediction is {idx}\") ⑤ \n```", "```py\nthe label is 9; the prediction is 9\nthe label is 2; the prediction is 2\nthe label is 1; the prediction is 1\nthe label is 1; the prediction is 1\nthe label is 6; the prediction is 6\n```", "```py\nresults=[]\n\nfor imgs,labels in test_loader:                             ①\n    imgs=imgs.reshape(-1,28*28).to(device)\n    labels=(labels).reshape(-1,).to(device)\n    preds=model(imgs)                                       ②\n    pred10=torch.argmax(preds,dim=1)                        ③\n    correct=(pred10==labels)                                ④\n    results.append(correct.detach().cpu().numpy().mean())\n\naccuracy=np.array(results).mean()                           ⑤\nprint(f\"the accuracy of the predictions is {accuracy}\") \n```", "```py\nthe accuracy of the predictions is 0.8819665605095541\n```"]