- en: 10 Other swarm intelligence algorithms to explore
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 其他要探索的群智能算法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Getting familiar with ant colony optimization metaheuristics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉蚁群优化元启发式算法
- en: Understanding different variants of ant colony optimization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解蚁群优化的不同变体
- en: Understanding artificial bee colony
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解人工蜂群
- en: Applying these swarm intelligence algorithms to solve continuous and discrete
    optimization problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些群智能算法应用于解决连续和离散优化问题
- en: 'In the previous chapter, we looked at the particle swarm optimization (PSO)
    algorithm, but ant colony optimization (ACO) and artificial bee colony (ABC) are
    other widely used swarm intelligence algorithms, drawing inspiration from ants
    and bees to tackle diverse optimization problems. Let’s revisit the treasure hunting
    mission and assume you still want to follow a cooperative and iterative approach
    to find the treasure (which is the best solution in the case of an optimization
    problem). You and your friends are divided into two groups: the ant group and
    the bee group. Each group has its own unique way of finding the treasure, using
    ant colony optimization or the artificial bee colony algorithm. You can join either
    of these two groups.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了粒子群优化（PSO）算法，但蚁群优化（ACO）和人工蜂群（ABC）也是其他广泛使用的群智能算法，它们从蚂蚁和蜜蜂那里汲取灵感来解决各种优化问题。让我们重新审视寻宝任务，并假设你仍然想采用一种合作和迭代的途径来找到宝藏（在优化问题的情况下，这是最佳解决方案）。你和你的朋友们被分为两个小组：蚂蚁小组和蜜蜂小组。每个小组都有自己独特的寻找宝藏的方式，使用蚁群优化或人工蜂群算法。你可以加入这两个小组中的任何一个。
- en: As treasure-hunting ants, you and some of your friends will start at the base
    camp and explore different paths to find the treasure. As you explore, each of
    you leaves a trail of special chalk (pheromones) behind. The more promising the
    path, the more chalk you leave on that path. When your friends find your chalk
    trail, they can decide to follow it or to explore a new path. Over time, the most
    promising paths will have the strongest chalk trails, and eventually the whole
    group will converge on the path that leads to the treasure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为寻宝的蚂蚁，你和你的朋友们将从基地营出发，探索不同的路径以找到宝藏。在探索过程中，你们每个人都会在身后留下特殊的粉笔（信息素）痕迹。路径越有希望，你在这条路径上留下的粉笔就越多。当你的朋友们找到你的粉笔痕迹时，他们可以决定跟随它或者探索一条新的路径。随着时间的推移，最有希望的路径将会有最强的粉笔痕迹，最终整个群体将汇聚到通往宝藏的路径上。
- en: As treasure-hunting bees, you’ll use a different approach. You have forager
    bees and scout bees. Forager bees concentrate on searching nearby areas, while
    scout bees fly out and randomly explore the island, searching for clues leading
    to the treasure. When a bee finds a promising clue, it returns to the base camp
    and performs a “waggle dance” to communicate the location and quality of the clue
    to the other friends (onlooker bees). This process continues until the group finds
    the best path to the treasure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为寻宝的蜜蜂，你将采用不同的方法。你有觅食蜂和侦察蜂。觅食蜂专注于搜索附近区域，而侦察蜂飞出去随机探索岛屿，寻找通往宝藏的线索。当一只蜜蜂找到有希望的线索时，它会返回基地营并执行“摇摆舞”来向其他朋友（旁观蜂）传达线索的位置和质量。这个过程会一直持续到群体找到通往宝藏的最佳路径。
- en: This chapter presents ant colony optimization and artificial bee colony as swarm
    intelligence algorithms. The open traveling salesman problem, function optimization,
    routing problem, pump design, and a supply-demand problem are discussed in this
    chapter and its supplementary exercises in appendix C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了蚁群优化和人工蜂群优化作为群智能算法。本章讨论了开放旅行商问题、函数优化、路由问题、泵设计以及供需问题，并在附录C的补充练习中进行了讨论。
- en: 10.1 Nature’s tiny problem-solvers
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 自然界的微小问题解决者
- en: Ants are tiny creatures that can solve complex problems better than some humans.
    Ants may be small, but when they work together in a colony, they can accomplish
    some incredible feats. During foraging, they can find the shortest path to a food
    source, build intricate tunnels, and even take down prey much larger than themselves!
    During nest construction, some ants cut leaves from plants and trees, others forage
    for leaves hundreds of meters away from their nest to construct highways to and
    from their foraging sites, and yet other ants form chains of their own bodies,
    allowing them to cross wide gaps and pull stiff leaves together to form a nest.
    In the latter case, the worker ants form a chain along the edge of the leaf and
    pull the edges together by shortening the chain one ant at a time. Once the leaf
    edges are in place, weaver ants hold one larva each in their mandibles and gently
    squeeze the larva to produce silk, which is used to glue the leaf edges together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁是微小的生物，它们解决复杂问题的能力甚至超过某些人类。蚂蚁可能体积小，但当他们作为一个群体工作时，他们可以完成一些令人难以置信的壮举。在觅食过程中，它们可以找到通往食物来源的最短路径，建造复杂的隧道，甚至捕食比它们自身大得多的猎物！在巢穴建造过程中，一些蚂蚁从植物和树木上剪下叶子，其他蚂蚁在距离巢穴数百米远的地方觅食叶子，以建造通往觅食地点的高速公路，还有其他蚂蚁用自己的身体形成链条，使它们能够跨越宽阔的缝隙，并将硬叶拉在一起形成巢穴。在后一种情况下，工蚁沿着叶子的边缘形成链条，并一次缩短一个蚂蚁的链条来拉紧叶子的边缘。一旦叶子边缘就位，织叶蚁用它们的颚各夹住一个幼虫，并轻轻挤压幼虫以产生丝线，这种丝线被用来粘合叶子的边缘。
- en: Fascinating facts about the mighty ant
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于强大的蚂蚁的有趣事实
- en: Ants appeared on earth some 100 million years ago, making them one of the oldest
    groups of insects on the planet.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁在大约一亿年前出现在地球上，使它们成为地球上最古老的昆虫群体之一。
- en: Ants have a current total population estimated at 10^(16) individuals. It is
    estimated that the total weight of ants is in the same order of magnitude as the
    total weight of human beings.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁的当前总估计人口为10的16次方个体。据估计，蚂蚁的总重量与人类的总重量处于同一数量级。
- en: Ants are incredibly strong for their size. Some species can carry objects that
    are 50 times their body weight! To put that in perspective, this is like a human
    carrying a car!
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁对于它们的体型来说非常强壮。一些种类可以携带重量是它们自身体重50倍的物体！为了更直观地理解这一点，这就像一个人携带一辆汽车一样！
- en: About 2% of all insects are social. There are around 12,000 different types
    of ants, and most ants are social insects.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约2%的昆虫是社会的。大约有12,000种不同的蚂蚁，大多数蚂蚁都是社会性昆虫。
- en: Ants are considered the densest population in the world. They live in colonies
    of 30 to millions of individuals. Some colonies like Formica Yesensis have approximately
    1,080,000 queens and 306,000,000 workers and live in 45,000 nests connected to
    each other over an area of 2.7 square kilometers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁被认为是世界上人口密度最高的生物。它们生活在由30个到数百万个个体组成的群体中。一些群体，如Formica Yesensis，大约有1,080,000个蚁后和306,000,000个工蚁，生活在2.7平方公里的区域内，45,000个巢穴相互连接。
- en: Ants use pheromones as their primary medium of stigmergic communication. However,
    ants also use other forms of communication, including visual, auditory, and tactile
    communication. For example, some species of ants use sound to communicate with
    each other. These sounds can range from simple clicks and pops to more complex
    signals that convey information about food sources, nest locations, and other
    important information. Some species of ants produce sounds in the audible range
    of humans (20Hz to 20kHz). For example, leafcutter ants are known to produce a
    clicking sound when they communicate with each other. The frequency of these clicks
    can range from 1 to 10 kilohertz. Other species of ants produce sounds that are
    beyond the range of human hearing. For example, some species of army ants produce
    ultrasonic sounds that can be used to locate prey or communicate with each other.
    If you’re interested, take a look at the “What Sound Does an Ant Make?” video
    on YouTube ([http://mng.bz/aEKo](http://mng.bz/aEKo)).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁使用信息素作为它们主要的聚群通信媒介。然而，蚂蚁还使用其他形式的通信，包括视觉、听觉和触觉通信。例如，一些蚂蚁种类使用声音来相互沟通。这些声音可以从简单的点击声和爆裂声到更复杂的信号，这些信号传达有关食物来源、巢穴位置和其他重要信息。一些蚂蚁种类产生的声音在人类的可听范围内（20Hz到20kHz）。例如，切叶蚁在相互沟通时会产生点击声。这些点击声的频率可以从1到10千赫兹。其他蚂蚁种类产生的声音超出了人类的听觉范围。例如，一些军蚁产生超声波，可以用来定位猎物或相互沟通。如果你感兴趣，可以在YouTube上查看“蚂蚁发出什么声音？”的视频（[http://mng.bz/aEKo](http://mng.bz/aEKo)）。
- en: An ant is a simple stimulus-response creature that is incapable of achieving
    complex tasks alone. However, as a colony, ants show an amazing capability to
    perform complex tasks without any planning, a central controller, centralized
    supervision, or direct communication. Ants employ an indirect communication mechanism
    known as stigmergic communication. *Stigmergy* is a concept introduced by the
    French biologist Pierre-Paul Grassé in 1959 as an indirect method of communication
    among social insects involving environmental modifications. These environmental
    modifications serve as external or shared memory between the insects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁是一种简单的刺激-反应生物，单独无法完成复杂任务。然而，作为一个群体，蚂蚁展现出惊人的能力，能够在没有任何计划、中央控制器、集中监督或直接沟通的情况下执行复杂任务。蚂蚁采用一种称为群居通信的间接沟通机制。*群居性*是法国生物学家皮埃尔-保罗·格雷斯在1959年提出的一个概念，它是一种涉及环境修改的社会性昆虫之间的间接沟通方法。这些环境修改作为昆虫之间的外部或共享记忆。
- en: Ants use pheromones as their primary medium of stigmergic communication. As
    they travel to and from a food source, they deposit pheromones along their path.
    Other ants can detect these pheromones, which influences their decision-making
    when choosing a path. This allows ants to work together as a cohesive unit and
    accomplish complex tasks such as finding the shortest path from the nest to a
    food source and vice versa. The absence of direct communication or a central controller
    makes the actions of ants seem almost as if they are coordinated by some form
    of collective intelligence. In essence, the phenomenon of stigmergic communication
    allows social insects like ants to use their collective knowledge and behavior
    to achieve tasks beyond their individual abilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁使用信息素作为它们主要的群居通信媒介。当它们往返于食物来源地时，会在路径上留下信息素。其他蚂蚁可以检测到这些信息素，这会影响它们在选择路径时的决策。这使得蚂蚁能够作为一个紧密的单元共同工作，完成诸如从巢穴到食物来源地以及相反方向的最短路径寻找等复杂任务。没有直接的沟通或中央控制器使得蚂蚁的行动看起来几乎像是某种形式的集体智慧所协调。本质上，群居通信的现象使得像蚂蚁这样的社会性昆虫能够利用它们的集体知识和行为来完成超出个体能力的任务。
- en: Ant colony optimization (ACO) is inspired by the foraging behavior of ants.
    As they forage for food, ants initially explore randomly around the nest area.
    Once an ant discovers a food source, it carries some of the food back to the nest
    while laying a pheromone trail along its path. Other ants then follow the pheromone
    trail to the food source, as illustrated in figure 10.1\. As more and more ants
    follow the pheromone trail to the food source, the intensity of the pheromone
    trail increases, making it more attractive to other ants. In contrast, because
    pheromone trails are not fixed and will gradually evaporate over time, the pheromone
    trail on the longer path will evaporate. Eventually, a single pheromone trail
    becomes dominant, and most of the ants follow this trail to and from the food
    source. In this way, ants can find the shortest path between the nest and the
    food source through a process of collective or swarm intelligence.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁群体优化（ACO）灵感来源于蚂蚁的觅食行为。当它们觅食时，蚂蚁最初会在巢穴区域周围随机探索。一旦蚂蚁发现食物来源，它会携带一些食物返回巢穴，同时在路径上留下信息素轨迹。然后其他蚂蚁会跟随信息素轨迹到达食物来源，如图10.1所示。随着越来越多的蚂蚁跟随信息素轨迹到达食物来源，信息素轨迹的强度增加，对其他蚂蚁更具吸引力。相反，由于信息素轨迹不是固定的，并且会随着时间的推移逐渐蒸发，较长路径上的信息素轨迹会蒸发。最终，一条单独的信息素轨迹变得主导，大部分蚂蚁都会跟随这条轨迹往返于食物来源地。通过这种方式，蚂蚁可以通过集体或群体智能的过程找到巢穴和食物来源地之间的最短路径。
- en: '![](../Images/CH10_F01_Khamis.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F01_Khamis.png)'
- en: Figure 10.1 Ant foregoing process. A foraging ant deposits a pheromone trail
    along the path it takes on its way back to the nest. Other ants will likely follow
    the path with a stronger pheromone trail to reach the discovered food source.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 蚂蚁觅食过程。觅食的蚂蚁在其返回巢穴的路径上留下信息素轨迹。其他蚂蚁很可能会跟随具有更强信息素轨迹的路径，以到达发现的食品来源。
- en: 'As I explained in the previous chapter, the majority of the research carried
    out on swarm intelligence algorithms was initially based on experimental observations.
    To understand the collective behavior of ants during food foraging and to derive
    heuristics for the ACO algorithm, two famous experiments were conducted: the binary
    bridge experiment and the bridges with non-equal lengths experiment.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一章中解释的，对群体智能算法的研究大多数最初是基于实验观察。为了理解蚂蚁在觅食过程中的集体行为，并为ACO算法推导启发式方法，进行了两个著名的实验：二进制桥梁实验和长度不等桥梁实验。
- en: The binary bridge experiment was designed to observe the behavior of ants when
    presented with two equal-length bridges connecting their nest to a food source
    (figure 10.2a). The experiment aimed to investigate how ants determine the best
    path to use and how they adapt their behavior over time. Initially, the ants chose
    one of the two bridges randomly. As the ants traveled back and forth between the
    nest and the food source, they deposited pheromones along the path they took.
    As time progressed, more ants followed the path with the higher concentration
    of pheromones, which made the path even more attractive to other ants. Eventually,
    one of the two bridges became dominant, and most of the ants used it to travel
    between the nest and the food source. The ants’ decision-making process was based
    on the principle of positive feedback, where the ants reinforced the path with
    the highest pheromone concentration, making it even more attractive to other ants.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制桥梁实验是为了观察蚂蚁在面临两条连接巢穴到食物源等长的桥梁时的行为（图10.2a）。实验旨在研究蚂蚁如何确定最佳路径以及它们如何随时间调整行为。最初，蚂蚁随机选择两条桥梁中的一条。随着蚂蚁在巢穴和食物源之间往返，它们会在所走的路径上留下信息素。随着时间的推移，更多的蚂蚁跟随信息素浓度更高的路径，这使得路径对其他蚂蚁更具吸引力。最终，两条桥梁中的一条成为主导，大多数蚂蚁使用它来在巢穴和食物源之间旅行。蚂蚁的决策过程基于正反馈原理，蚂蚁强化了信息素浓度最高的路径，使其对其他蚂蚁更具吸引力。
- en: '![](../Images/CH10_F02_Khamis.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F02_Khamis.png)'
- en: Figure 10.2 a) Binary bridge experiment; b) bridges with non-equal lengths experiment
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 a) 二进制桥梁实验；b) 长度不等桥梁实验
- en: The bridges with non-equal lengths experiment (figure 10.2b) is an extension
    of the binary bridge experiment with one branch of the bridge being longer than
    the other. The goal of this experiment was to observe how ants adapted their behavior
    when presented with two paths of different lengths. The experiment showed that
    ants tended to select the shorter path over the longer one. This was because ants
    traveling on the shorter path returned to the nest earlier than those on the longer
    path. As a result, the pheromone trail on the shorter path was reinforced sooner
    than that on the longer path, making it more attractive to other ants. This reinforcement
    behavior is called *autocatalytic behavior*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 长度不等桥梁实验（图10.2b）是二进制桥梁实验的扩展，其中桥梁的一支比另一支长。这个实验的目的是观察蚂蚁在面临两条不同长度的路径时的行为调整。实验表明，蚂蚁倾向于选择较短的路径而不是较长的路径。这是因为沿着较短路径旅行的蚂蚁比沿着较长路径旅行的蚂蚁更早返回巢穴。因此，较短路径上的信息素路径比较长路径上的信息素路径更快得到强化，使其对其他蚂蚁更具吸引力。这种强化行为被称为*自催化行为*。
- en: 'The role of pheromones in the collective behavior of ants can be summarized
    in the following key points:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 信息素在蚂蚁的集体行为中的作用可以总结为以下要点：
- en: The pheromone trail acts as a collective memory for the ants to communicate
    through by sensing and recording their foraging experience.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息素路径作为蚂蚁通过感知和记录它们的觅食经验来沟通的集体记忆。
- en: The pheromone trail evaporates over time, introducing changes in the environment
    that can influence the ants’ behavior.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，信息素路径会蒸发，引入环境变化，这些变化可以影响蚂蚁的行为。
- en: The concentration of pheromones on the trail represents a feedback signal that
    influences the ants’ decision-making process.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径上的信息素浓度代表了一个反馈信号，它影响着蚂蚁的决策过程。
- en: Let’s now dive deep into ACO metaheuristics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们深入探讨ACO元启发式算法。
- en: 10.2 ACO metaheuristics
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 ACO元启发式算法
- en: Ant colony optimization (ACO) mimics the behavior of real ant colonies by having
    a group of “artificial ants” search for the best solution to a problem. These
    artificial ants leave “pheromone trails” to communicate with each other, just
    like real ants do, and eventually converge on the best solution.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁群优化（ACO）通过一组“人工蚂蚁”搜索问题的最佳解决方案来模拟真实蚂蚁群体的行为。这些人工蚂蚁留下“信息素路径”来相互沟通，就像真实蚂蚁一样，最终收敛到最佳解决方案。
- en: 'To simulate the behavior of ants, let’s assume we have a nest and a food source
    connected through two paths with different lengths *L[1]* and *L[2]*, as in the
    case of the bridges with non-equal lengths. Let’s now assign a computational parameter
    *τ* to represent the pheromone deposited by the ants. We’ll initially assign equal
    values of pheromones to each path: *τ[1]* = *τ[2]* as shown in figure 10.3\. We
    then start by placing *m* ants at the nest. Let’s assume that these artificial
    ants exactly mimic the real ants and take decisions based on the pheromone concentration,
    but without any knowledge of the lengths of the paths. For each ant *k*, this
    ant traverses path 1 with probability'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟蚂蚁的行为，让我们假设我们有一个巢穴和一个通过两条不同长度 *L[1]* 和 *L[2]* 连接的食物来源，就像长度不等的桥梁的情况。现在，让我们分配一个计算参数
    *τ* 来表示蚂蚁留下的信息素。我们最初将相同的信息素值分配给每条路径：*τ[1]* = *τ[2]*，如图10.3所示。然后，我们开始在巢穴放置 *m*
    只蚂蚁。让我们假设这些人工蚂蚁完全模仿真实蚂蚁，并根据信息素浓度做出决策，但没有路径长度的任何知识。对于每只蚂蚁 *k*，这只蚂蚁以概率穿越路径1：
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F02_Khamis-EQ01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F02_Khamis-EQ01.png)'
- en: '| 10.1 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 10.1 |'
- en: This ant thus traverses path 2 with a probability *p*[2] = 1 – *p*[1].
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这只蚂蚁以概率 *p*[2] = 1 – *p*[1]穿越路径2。
- en: '![](../Images/CH10_F03_Khamis.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F03_Khamis.png)'
- en: Figure 10.3 ACO simulation
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 ACO模拟
- en: 'As *τ[1]* = *τ[2]*, the ant *k* will randomly pick one of the two paths, as
    both have same probability to of being traversed. After traversing the selected
    paths, pheromone concentration on each path needs to be updated. This pheromone
    update includes two phases: evaporation and deposit. During the evaporation phase,
    the pheromone concentration τ is decremented as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *τ[1]* = *τ[2]*，蚂蚁 *k* 将随机选择两条路径之一，因为两条路径被穿越的概率相同。在穿越所选路径后，每条路径上的信息素浓度需要更新。这种信息素更新包括两个阶段：蒸发和沉积。在蒸发阶段，信息素浓度
    τ 按以下方式递减：
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F03_Khamis-EQ02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F03_Khamis-EQ02.png)'
- en: '| 10.2 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 10.2 |'
- en: where ρ specifies the rate of evaporation. Figure 10.4 shows the effect of the
    pheromone evaporation rate during the foraging process based on a NetLogo simulation.
    NetLogo is a multi-agent programmable modeling environment used to simulate natural
    and social phenomena. It allows users to create, experiment with, and analyze
    simulations of complex systems, such as ecosystems, economies, and social networks.
    The foraging behavior of ants is shown in NetLogo’s Ants model ([https://ccl.northwestern.edu/netlogo/models/Ants](https://ccl.northwestern.edu/netlogo/models/Ants)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ρ 指定了蒸发率。图10.4显示了基于NetLogo模拟的觅食过程中信息素蒸发率的影响。NetLogo是一个多智能体可编程建模环境，用于模拟自然和社会现象。它允许用户创建、实验和分析复杂系统的模拟，如生态系统、经济和社会网络。蚂蚁的觅食行为在NetLogo的蚂蚁模型（[https://ccl.northwestern.edu/netlogo/models/Ants](https://ccl.northwestern.edu/netlogo/models/Ants)）中显示。
- en: '![](../Images/CH10_F04_Khamis.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F04_Khamis.png)'
- en: Figure 10.4 Effect of evaporation rate during the food foraging process. In
    the simulation, the ants initiate their search for food from the central nest,
    which is surrounded by three food sources shown as blobs. The pheromone trails
    are shown in white. Upon discovering a food item, an ant transports it back to
    the nest, leaving behind a chemical trail. This trail is then followed by other
    ants that pick up the scent, directing them toward the food source. As more ants
    continue to retrieve food, they strengthen the chemical trail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 食物觅食过程中蒸发率的影响。在模拟中，蚂蚁从中心巢穴开始寻找食物，巢穴周围有三个以块状表示的食物来源。信息素路径用白色表示。蚂蚁发现食物后，将其运回巢穴，留下化学路径。然后，其他蚂蚁跟随这条路径，嗅到气味，将其引导到食物来源。随着更多蚂蚁继续取回食物，它们会加强化学路径。
- en: As you can see, if the evaporation rate is set to 0, the pheromone trail will
    never evaporate, and the ants will follow the same path repeatedly. This will
    cause the ants to become trapped in a local optimum, and they will not be able
    to explore other paths or find a better solution. On the other hand, if the evaporation
    rate is set to 1, the pheromone trail will evaporate at the maximum rate, which
    means the ants will not be able to follow any trail, and they will be forced to
    explore the environment randomly. This can result in slow convergence to the optimal
    solution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果蒸发率设置为0，信息素路径将永远不会蒸发，蚂蚁将反复跟随相同的路径。这将导致蚂蚁陷入局部最优，它们将无法探索其他路径或找到更好的解决方案。另一方面，如果蒸发率设置为1，信息素路径将以最大速率蒸发，这意味着蚂蚁将无法跟随任何路径，它们将被迫随机探索环境。这可能导致缓慢收敛到最优解。
- en: 'During the deposit phase, each ant leaves more pheromones on its traversed
    path. Figure 10.5 shows the different methods used for pheromone updates:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在沉积阶段，每只蚂蚁在其经过的路径上留下更多的信息素。图10.5展示了用于信息素更新的不同方法：
- en: '*Online step-by-step pheromone update*—Each ant deposits a certain amount of
    pheromones on the path it has traversed. This will increase the probability of
    another ant choosing the same edge:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在线逐步信息素更新*—每只蚂蚁在其经过的路径上沉积一定量的信息素。这将增加另一只蚂蚁选择相同边的概率：'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F04_Khamis-EQ03.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_Khamis-EQ03.png)'
- en: '| 10.3 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 10.3 |'
- en: There are different approaches for choosing the value of Δ*τ*. Following the
    *ant density model*, the ant adds a constant amount *Q* to each traversed edge.
    This means that the final pheromone added to the edge will be proportional to
    the number of ants choosing it. The higher the density of the traffic on the edge,
    the more desirable that edge becomes as a component of the final solution. This
    method does not take the quality of the solution (i.e., the edge length) into
    account. In the *ant quantity model*, the amount of pheromones deposited is proportional
    to the quality of the solution obtained by the ant. For example, an ant traversing
    between node *i* and *j* will deposit a quantity *Q*/*d[ij]*, where *d[ij]* is
    the distance between *i* and *j*. In this case, only local information, *d[ij]*,
    is used to update pheromone concentrations. Lower cost edges are made more desirable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择Δ*τ*值的方法有多种。遵循*蚂蚁密度模型*，蚂蚁将一个常数量*Q*加到每个经过的边上。这意味着最终添加到边上的信息素将与选择该边的蚂蚁数量成比例。边上交通密度越高，该边作为最终解决方案组成部分的吸引力就越大。这种方法不考虑解决方案的质量（即边长）。在*蚂蚁数量模型*中，沉积的信息素量与蚂蚁获得的解决方案质量成比例。例如，蚂蚁在节点*i*和*j*之间穿越时，将沉积量*Q*/*d[ij]*，其中*d[ij]*是*i*和*j*之间的距离。在这种情况下，只使用局部信息*d[ij]*来更新信息素浓度。成本较低的边被赋予更高的吸引力。
- en: '*Online delayed pheromone update (or ant cycle model)*–Once the ant constructs
    the solution, it retraces its steps and updates the pheromones trails on the edges
    it has traversed based on the quality of the solution. The amount of pheromones
    deposited is determined by the quality of the solution obtained by the ant as
    follows:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在线延迟信息素更新（或蚂蚁循环模型）*—一旦蚂蚁构建了解决方案，它将重新走一遍路径，并根据解决方案的质量更新其经过的边上的信息素路径。沉积的信息素量由蚂蚁获得解决方案的质量决定如下：'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F04_Khamis-EQ04.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_Khamis-EQ04.png)'
- en: '| 10.4 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 10.4 |'
- en: where *Q* is a constant and *L^k* is the length of the path constructed by ant
    *k*. For each edge (*i*,*j*) of the corresponding path, and after all the ants
    have completed their tours, the total amount of pheromones deposited will be
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*Q*是一个常数，*L^k*是蚂蚁*k*构建的路径长度。对于对应路径的每个边(*i*,*j*)，在所有蚂蚁完成它们的巡回之后，沉积的总信息素量将是
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F04_Khamis-EQ05.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_Khamis-EQ05.png)'
- en: '| 10.5 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 10.5 |'
- en: where *m* is the number of ants.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*m*是蚂蚁的数量。
- en: '![](../Images/CH10_F05_Khamis.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F05_Khamis.png)'
- en: Figure 10.5 Pheromone update methods
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 信息素更新方法
- en: In summary, with online step-by-step pheromone update, the ant updates the pheromone
    trail *τ[ij]* on the edge (*i*,*j*) when moving from node *i* to node *j*. In
    online delayed pheromone update, once a path is constructed, the ant can retrace
    the same path backward and update the pheromone trails on the traversed edges.
    Which method you choose depends on the specific problem being solved. Any combination
    of online step-by-step pheromone updates and online delayed pheromone updates
    is also possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在在线逐步信息素更新中，蚂蚁在从节点*i*移动到节点*j*时，会在边(*i*,*j*)上更新信息素轨迹*τ[ij]*。在在线延迟信息素更新中，一旦构建了一条路径，蚂蚁可以沿着相同的路径反向追踪并更新经过的边上的信息素轨迹。选择哪种方法取决于要解决的问题。在线逐步信息素更新和在线延迟信息素更新的任何组合也是可能的。
- en: 10.3 ACO variants
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 ACO变体
- en: ACO has been used to solve a wide range of optimization problems, such as vehicle
    routing problems, scheduling problems, and optimal assignment problems. Over the
    years, several variants of the algorithm have been developed, as shown in figure
    10.6.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ACO已被用于解决各种优化问题，如车辆路径问题、调度问题和最优分配问题。多年来，已经开发了该算法的几个变体，如图10.6所示。
- en: '![](../Images/CH10_F06_Khamis.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F06_Khamis.png)'
- en: Figure 10.6 Examples of ACO variants
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 ACO变体的示例
- en: These variants have different strengths and weaknesses, and the choice of variant
    depends on the specific problem being solved. In the following subsections, we
    will discuss some of these variants.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变体有不同的优缺点，变体的选择取决于要解决的问题的具体情况。在以下小节中，我们将讨论这些变体中的一些。
- en: 10.3.1 Simple ACO
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 简单ACO
- en: Simple ACO (SACO) is an algorithmic implementation of the double bridge experiment.
    Consider the problem of finding the shortest path between two nodes on a graph,
    as shown in figure 10.7.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 简单ACO（SACO）是双桥实验的算法实现。考虑在图上找到两个节点之间最短路径的问题，如图10.7所示。
- en: '![](../Images/CH10_F07_Khamis.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F07_Khamis.png)'
- en: Figure 10.7 Shortest path problem
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 最短路径问题
- en: Let’s solve this problem using SACO. On each edge, we’ll assign a small random
    value to indicate the initial pheromone concentration, *τ[ij]*(0). Then we’ll
    place a number of ants, *k* = 1,…,*m* on the source node.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用SACO来解决这个问题。在每条边上，我们将分配一个小的随机值来表示初始信息素浓度，*τ[ij]*(0)。然后，我们将放置一定数量的蚂蚁，*k*
    = 1，…，*m*在源节点上。
- en: 'For each iteration of SACO, each ant will incrementally construct a path (solution)
    to the destination node. Initially, an ant will randomly select which edge to
    follow next. Later, each ant will execute a decision policy to determine the next
    edge of the path. At each node *i*, the ant has a choice to move to any of the
    *j* nodes connected to it, based on the following transition probability:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SACO的每一次迭代，每只蚂蚁都会逐步构建到目标节点的路径（解）。最初，蚂蚁会随机选择下一步要跟随的边。后来，每只蚂蚁将执行决策策略以确定路径的下一个边。在每个节点*i*，蚂蚁可以选择移动到与之相连的任何*j*个节点，基于以下转换概率：
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F07_Khamis-EQ06.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F07_Khamis-EQ06.png)'
- en: '| 10.6 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 10.6 |'
- en: where
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '*N[i]^k* is the set of feasible nodes connected to node *i*, with respect to
    ant *k*.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N[i]^k*是相对于蚂蚁*k*与节点*i*相连的可行节点集合。'
- en: '*τ[ij]* is the amount of pheromones deposited for transition from state *i*
    to *j*.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*τ[ij]*是从状态*i*到状态*j*沉积的信息素量。'
- en: '*η[ij]* is a heuristic value that represents the desirability of state transition
    *ij* (a priori knowledge, typically 1/*d[ij]*, where *d* is the distance).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*η[ij]*是一个启发式值，表示状态转换*ij*（先验知识，通常是1/*d[ij]*，其中*d*是距离）的期望性。'
- en: '*α* ≥ 0 is a parameter that controls the influence of *τ[ij]*. *α* is used
    to amplify the influence of the pheromone. Large values of *α* give excessive
    importance to the pheromone, especially the initial random pheromones, which may
    lead to rapid convergence to suboptimal paths.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*α* ≥ 0是一个参数，用于控制*τ[ij]*的影响。*α*用于放大信息素的影响。*α*的较大值会给信息素赋予过多的重视，尤其是初始的随机信息素，这可能导致快速收敛到次优路径。'
- en: '*β* ≤ 1 is a parameter that controls the influence of the desirability of the
    edge *η[ij]*.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*β* ≤ 1是一个参数，用于控制边*η[ij]*的期望性的影响。'
- en: In the shortest path problem, assume that we use five ants, an initial pheromone
    value of 0.5, and *α* = *β* = 1. The first ant (*k* = 1), placed at the source
    node, has two neighboring nodes {2,3}, as shown in figure 10.8.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在最短路径问题中，假设我们使用五只蚂蚁，初始信息素值为0.5，*α* = *β* = 1。第一只蚂蚁（*k* = 1），放置在源节点，有两个相邻节点{2,3}，如图10.8所示。
- en: '![](../Images/CH10_F08_Khamis.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F08_Khamis.png)'
- en: Figure 10.8 The first ant is at source node 1 with neighbors 2 and 3\. There
    are two numbers on each edge separated by a colon. The first number represents
    the length of the edge, and the second represents the current pheromone concentration
    on the edge.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 第一只蚂蚁位于源节点1，其邻居为2和3。每条边上都有两个用冒号分隔的数字。第一个数字代表边的长度，第二个数字代表边上的当前信息素浓度。
- en: 'Considering the inverse of the edge length as edge desirability, this ant needs
    to choose between nodes 2 and 3 by applying the transition probability as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑边长倒数作为边的吸引力，这只蚂蚁需要通过以下转换概率在节点2和3之间进行选择：
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F08_Khamis-EQ07.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F08_Khamis-EQ07.png)'
- en: '| 10.7 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 10.7 |'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F08_Khamis-EQ08.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F08_Khamis-EQ08.png)'
- en: '| 10.8 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 10.8 |'
- en: where *p*[12]¹ is the probability of node 2 being selected by ant 1 at node
    1, and *p*[13]¹ is the probability of node 3 being selected. We then generate
    a random number *r* between 0 and 1\. If *p*[13]¹ ≥ *r*, we select node 3; otherwise,
    we select 2\. As node 3 has the highest probability of being selected, it will
    most likely be selected.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *p*[12]¹ 是蚂蚁1在节点1选择节点2的概率，*p*[13]¹ 是选择节点3的概率。然后我们在0到1之间生成一个随机数 *r*。如果 *p*[13]¹
    ≥ *r*，我们选择节点3；否则，我们选择2。由于节点3被选中的概率最高，它最有可能被选中。
- en: Moving forward, the first ant is now at node 3 and needs to decide between the
    adjacent nodes 2 and 4 following the same transition probability, which results
    in *p[32]*¹ = 0.29 and *p[34]*¹ = 0.71. Let’s assume that node 4 is selected.
    The ant is now at node 4 and needs to decide between the adjacent nodes 2 and
    5 following the same transition probability, which results in *p*[42]¹ = 0.6 and
    *p*[45]¹ = 0.4. Let’s assume that node 5 is selected, based on the generated random
    number. Figure 10.9 shows the path completed by the first ant in the first iteration
    with length *L*¹(*t* = 1) = 3 + 2 + 6 = 11. Each ant will generate its own path
    following the same steps.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，第一只蚂蚁现在位于节点3，需要根据相同的转换概率在相邻节点2和4之间进行选择，这导致 *p[32]*¹ = 0.29 和 *p[34]*¹ =
    0.71。假设选择了节点4。蚂蚁现在位于节点4，需要根据相同的转换概率在相邻节点2和5之间进行选择，这导致 *p*[42]¹ = 0.6 和 *p*[45]¹
    = 0.4。假设根据生成的随机数选择了节点5。图10.9显示了第一只蚂蚁在第一次迭代中完成的路径，长度 *L*¹(*t* = 1) = 3 + 2 + 6
    = 11。每只蚂蚁将按照相同的步骤生成自己的路径。
- en: '![](../Images/CH10_F09_Khamis.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F09_Khamis.png)'
- en: Figure 10.9 The path constructed by the first ant. Each of the other four ants
    will similarly construct a path.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 第一只蚂蚁构建的路径。其他四只蚂蚁将类似地构建路径。
- en: Before starting a new iteration, the pheromones need to be updated. Following
    equation 10.2 and assuming that the evaporation rate ρ is 0.7, the new pheromone
    value will be
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新的迭代之前，需要更新信息素。根据方程10.2并假设蒸发率 ρ 为0.7，新的信息素值将是
- en: '|'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F09_Khamis-EQ09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F09_Khamis-EQ09.png)'
- en: '| 10.9 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 10.9 |'
- en: Pheromones are also deposited. If the first ant *k* = 1 is selected to deposit
    pheromones based on the costs of the paths found by each ant, it enforces the
    edges {1,3), {3,4}, and {4,5} with the value *Q*/*L*¹ = 1/11 following the online
    delayed pheromone update model. Figure 10.10 shows the updated pheromone values
    on each edge.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 信息素也会被沉积。如果第一只蚂蚁 *k* = 1 根据每只蚂蚁找到的路径的成本来选择沉积信息素，它将根据在线延迟信息素更新模型，以 *Q*/*L*¹ =
    1/11 的值强制执行边 {1,3}、{3,4} 和 {4,5}。图10.10显示了每条边上的更新信息素值。
- en: '![](../Images/CH10_F10_Khamis.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F10_Khamis.png)'
- en: Figure 10.10 Updated pheromone concentrations
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 更新的信息素浓度
- en: In this simple example, over three iterations, the ants find the shortest path
    1 → 3 → 4 → 5. In the following sections, we’ll discuss the ant system (AS) algorithm,
    ant colony system (ACS) algorithm, and max–min ant system (MMAS) algorithm as
    ACO variants proposed to deal with SACO limitations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，经过三次迭代，蚂蚁找到了最短路径 1 → 3 → 4 → 5。在接下来的章节中，我们将讨论蚂蚁系统（AS）算法、蚁群系统（ACS）算法和最大-最小蚂蚁系统（MMAS）算法作为ACO变体，这些算法被提出以处理SACO的限制。
- en: 10.3.2 Ant system
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 蚂蚁系统
- en: The ant system (AS) algorithm improves on SACO by adding a memory capability
    via a tabu list. This list, or ant memory, identifies the already-visited nodes.
    The transition probability used in AS is the same as in equation 10.6\. As an
    ant visits a new node, that node is added to the ant’s tabu list for a predefined
    number of iterations. And as in SACO, after an ant completes a path, the pheromone
    on each edge is updated. The ant density, ant quantity, and ant cycle models can
    be used to update the pheromones. As previously explained, in the ant density
    and ant quantity models, ants deposit pheromones while building, whereas in the
    ant cycle model, ants deposit pheromones after they have built a complete path.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.3 Ant colony system
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ant colony system (ACS) algorithm is an extension of the AS algorithm with
    a modified transition rule that utilizes an elitist strategy. This strategy, known
    as the *pseudo-random proportional action rule*, is designed to improve the efficiency
    and effectiveness of the algorithm. The pseudo-random proportional action rule
    used in ACS is based on the idea that the best solutions found by the ants should
    be given more weight in the decision-making process. In ACS, a random number *r*
    is generated, and the parameter *r*[o] ∈ [0,1] is predefined. An ant *k*, located
    at node *i*, selects the next node *j* to move to using the following decision
    rule with a double function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: If *r* ≤ *r[o]*, the ant selects node *j*
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F10_Khamis-EQ10.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: '| 10.10 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: 'Else, a node is probabilistically selected (using a roulette wheel method,
    for example, which you learned about in chapter 7) according to the following
    transition probability:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F10_Khamis-EQ11.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Notice that compared to the transition probability of SACO (equation 10.6),
    the parameter that controls the influence of the pheromone concentration is *α*
    = 1 in ACS. The parameter *r[0]* is used to balance the exploration–exploitation
    trade-off. When *r* ≤ *r*[0], the decision rule exploits the knowledge available
    about the problem by favoring the best edge, and when *r* > *r*[0], the algorithm
    explores. Properly tuning *r[0]* allows us to strike a balance between exploration
    and exploitation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In the previous shortest path example, assume that the ant is at node 4 and
    needs to choose node 2 or 5 following the ACS decision rule (figure 10.11). Let’s
    assume that we have the values *r[o]* = 0.5, *β* = 1, and *η[ij]* = 1 / *d[ij]*.
    Let’s now generate a random number *r*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: If *r* ≤ *r[o]*, the ant will select node
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F10_Khamis-EQ12.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: '| 10.11 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: 'If *r* > *r[o]*, the ant will select a node with maximum transition probability:
    *p*[45]¹ = 0.6 and *p*[42]¹ = 0.4 as calculated before in section 10.3.1 with
    *α* = 1. Using the roulette wheel method, node 2 or node 5 may be selected.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F11_Khamis.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 The ant at node 4 selects the next node (2 or 5) following the
    ACS elitist strategy.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in AS, the pheromone reinforcement process in ACS is exclusively performed
    by the ant with the global-best solution, which corresponds to the best path found
    so far. However, relying solely on the global-best solution to dictate pheromone
    deposition may cause the search to converge too rapidly around the global-best
    solution to date, hindering exploration of other potentially better solutions.
    The max–min ant system (MMAS) algorithm was developed to address this issue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.4 Max–min ant system
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ACS can experience premature stagnation, which occurs when all ants follow the
    same path and little exploration is done. This issue is especially prevalent in
    complex problems, where the search space is large and the optimal solution is
    difficult to find. To overcome this problem, the max–min ant system (MMAS) was
    proposed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: MMAS employs the iteration-best path instead of the global-best path for pheromone
    updates. Pheromone trails are only updated using the online delayed pheromone
    update model, where the edges that were traversed by the best ant in the current
    iteration receive additional pheromones. Since the best paths can vary significantly
    between iterations, this approach promotes a higher degree of exploration throughout
    the search space compared to ACS. Hybrid strategies can also be implemented, in
    which the iteration-best path is primarily utilized to encourage exploration,
    while the global-best path is incorporated periodically.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In MMAS, the pheromone concentrations are constrained within an upper bound
    (*τ[max]*) and lower bound (*τ[min]*), ensuring that the search remains focused
    yet flexible. The pheromone trails are initialized to their maximum value *τ[max]*,
    and if the algorithm reaches a stagnation point, all pheromone concentrations
    are reset to the maximum value. Following this reset, the iteration-best path
    is exclusively used for a limited number of iterations. The values for *τ[min]*
    and *τ[max]* are typically determined through experimentation, although they could
    also be computed analytically if the optimal solution is known.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.5 Solving open TSP with ACO
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now implement the ACO algorithm to solve open TSP, considering the 20
    major US cities. Our objective is to find the shortest route that a salesperson
    can follow to visit each of these 20 cities once, starting from New York City
    and without returning to the home city.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by defining a `cities` dictionary that contains the names of the
    20 US cities and their latitude and longitude coordinates. We’ll then use a nested
    loop to calculate the distance between each pair of cities using the `haversine`
    distance formula, storing the results in the `distance_matrix` dictionary. The
    `haversine` distance is used because it takes into account the earth’s curvature,
    providing accurate distance measurements between two points on the earth’s surface
    (see the “Haversine distance” sidebar in section 4.3.3 for more details). The
    `cost_function` is defined to calculate the total distance of a path. It takes
    a list of city indices (`path`) and a distance matrix (`distances`) as input arguments.
    The function then iterates through the path, summing the distance between each
    consecutive pair of cities. The total path distance is then returned. This code
    is shown in the next listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.1 Solving shortest path problem using ACO
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Define latitude and longitude for 20 major US cities.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: ② Create a haversine distance matrix based on latitude and longitude coordinates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: ③ Inter-city values
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: ④ City names
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Define the cost function that represents the path length.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation of listing 10.1, the next code snippet presents a function
    called `ant_tour` that takes two arguments: `pheromones`, representing the pheromone
    levels between cities, and `distances`, representing the distances between cities.
    It initializes a `paths` array to store paths for each ant, and it iterates over
    each ant in the specified range of ants. For each ant, it initializes a path starting
    from New York City. It enters a `while` loop that continues until all cities are
    visited. Within the `while` loop, it selects the current city as the last city
    in the path. It then calculates the probabilities for choosing the next city based
    on the pheromone levels and the inverse of the distances between the current city
    and unvisited cities. The probabilities are calculated using equation 10.6\. The
    next city is chosen using the `random.choices` function, based on the normalized
    probabilities. The chosen next city is removed from the list of unvisited cities,
    and it is appended to the path:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Initialize an array to store paths for each ant.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: ② Start each ant's path from New York City.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: ③ Initialize a set of unvisited cities.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: ④ Remove New York City from unvisited cities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Continue building the path until all cities are visited.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Calculate the probabilities for moving to each unvisited city.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Normalize the probabilities.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Choose the next city based on probabilities.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Remove the chosen city from the set of unvisited cities.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Add the chosen city to the path.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: ⑪ Store the completed path for the current ant.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Once all the cities have been visited, the path for the current ant is stored
    in the `paths` array. After all the ants have completed their paths, the function
    returns the `paths` array containing the optimal tours found by each ant.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `update_pheromones` function is used to update the pheromone
    levels based on the distances and paths of the ants:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Initialize a matrix to store the changes in pheromone levels.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: ② Update pheromones based on the paths taken by the ants.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: ③ Get the indices of the cities in the current path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: ④ Update the pheromone level between the current and next city.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Evaporate existing pheromones, add the changes in pheromones, and return the
    updated pheromones.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'This function takes two arguments: `paths`, representing the paths taken by
    ants, and `pheromones`, representing the current pheromone levels on edges between
    cities. It initializes a matrix `delta_pheromones` to store the changes in pheromone
    levels. This matrix has the same shape as the `pheromones` matrix. It iterates
    over each ant in the specified range of ants. Within the loop, it iterates over
    each city in the ant''s path (except the last city). For each pair of consecutive
    cities, it updates the `delta_pheromones` matrix by adding a value based on the
    inverse of the cost of the ant''s path. After the inner loop, it calculates the
    updated pheromones by combining the existing pheromones, considering evaporation,
    and adding the changes stored in `delta_pheromones`. Finally, it returns the matrix
    of updated pheromones.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation, the following code snippet shows the `run_ACO` function,
    which takes the following inputs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '`distances`—A 2D array (matrix) that stores the distances between cities'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ants`—The number of ants to use in the algorithm'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterations`—The number of iterations'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha`—A parameter that controls the influence of the pheromone trail on the
    ant’s decision'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beta`—A parameter that controls the influence of the distance to the next
    city on the ant’s decision'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`evaporation_rate`—The rate at which pheromones evaporate from the paths'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Q`—A constant used in the calculation of the amount of pheromones deposited
    by the ants'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This function returns the `best_path` and `best_distance`, representing the
    optimal solution found by the ACO algorithm:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Initialize the pheromones array.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: ② Generate paths for each ant.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: ③ Calculate the total distance for each path.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: ④ Find the index of the path with the minimum distance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Update the pheromones.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Return the best path and distance found during the iterations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now apply ACO to solve the shortest path problem using the following
    parameters:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Set ACO parameters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: ② Run ACO with the defined parameters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the randomness included in the algorithm, your solution may vary. The
    following path is what was generated when I ran the solver:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding path is shown in figure 10.12\. The complete version of listing
    10.1 is available in the book’s GitHub repo, which also contains the code to generate
    this visualization.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F12_Khamis.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 Shortest path obtained by ACO
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike genetic algorithms and particle swarm optimization algorithms, there
    are no well-developed and comprehensive Python packages for ACO metaheuristics.
    The ACOpy project (https://acopy.readthedocs.io/en/latest/index.html) provides
    an implementation of ACO and can be installed using pip as follows: `pip install
    acopy`. As a continuation of listing 10.1, let’s use ACOpy to solve the shortest
    path problem.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by importing the `acopy` and `networkx` libraries. A graph, `G`,
    is created where the nodes represent cities and the edges represent the distances
    between them. The `distance_matrix` contains the distances between each pair of
    cities. The loops iterate over all pairs of cities, adding an edge between each
    pair of cities to the graph, with the weight of the edge being the distance between
    the cities. Self-loop edges (edges that connect a node to itself) are then removed
    from the graph:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The parameters for the ACO algorithm are then defined: `evaporation_rate`,
    `iterations`, and `Q`, as explained previously. An ACO solver is created with
    the specified `evaporation_rate` and `Q`. The `acopy.Colony` object is initialized
    with `alpha` and `beta` parameters. The algorithm then iterates for the specified
    number of iterations. In each iteration, the solver’s `solve` method is used to
    find a tour whose path is a list of edges. For each edge in the path, the code
    determines the city that hasn’t been added to the `path_indices` list yet and
    adds it. Finally, the path of the tour is updated to be the `path_indices` list,
    which is a list of city names instead of edges:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① ACO parameters
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: ② Set up the ACO solver.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set up the ACO colony with alpha and beta parameters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: ④ Run the ACO algorithm.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Start with city 0 (New York City).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Add the other node from the edge that is not already in the path.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Return the ordered list of city names included in the path.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now print the obtained path and its length as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `best_path` variable is set to the `path` property of the `tour` object
    obtained by the `acopy` solver. This path is a list of cities that represents
    the shortest route found. The `best_distance` variable is set to the `cost` property
    of the `tour` object, which is the total distance (or cost) of the best path.
    The `Route` variable is a string that joins all the cities in `best_path` with
    an arrow (`→`) in between, representing the sequence of cities to visit in the
    optimal tour. Finally, the `print` statements display the best route and its total
    distance. A path like the following will be generated after running the solver:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The obtained path is shown in figure 10.13\. The complete version of listing
    10.1 available in the book’s GitHub repo contains the code to generate this visualization.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F13_Khamis.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 Shortest path obtained by ACOpy
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth mentioning that ACO, like many other stochastic optimization algorithms,
    contains elements of randomness. The randomness in ACO comes from two main sources:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '*Initial conditions*—At the start of the algorithm, the ants are usually placed
    at random positions unless the start position is predefined, such as in the case
    of TSP where ants start from a predetermined home city. This means that in scenarios
    where random positions are used, each ant starts exploring from a different city,
    leading to diverse paths.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Path selection*—As the ants move from city to city, they probabilistically
    choose which city to visit next. This choice is influenced by the amount of pheromones
    on the path to a city and the distance to the city. Even if two ants are in the
    same city and have the same information, they might still choose different cities
    to visit next due to this probabilistic choice.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This inherent randomness means that each run of the ACO algorithm can produce
    different results. However, over multiple runs, ACO should consistently find near-optimal
    solutions, even if they are not always the exact same solution.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will delve into another fascinating algorithm that
    is a product of swarm intelligence. This algorithm again takes its inspiration
    from the natural world, specifically the food-seeking behavior of honeybees. You’ll
    soon understand how this bee-inspired algorithm operates and how it can be applied
    in a computational context.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 From hive to optimization
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Honeybees are remarkable social insects known for their extraordinary cooperation.
    They build hives capable of accommodating approximately 30,000 bees, all working
    together harmoniously. Each bee has a designated task, such as producing wax,
    creating honey, making bee-bread, forming combs, or bringing water to the cells
    and mixing it with honey. Young bees typically handle tasks outside the hive,
    while elder bees focus on indoor duties.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Honeybee colonies operate as goal-oriented decision-making systems, with their
    functions directed by the decentralized control and actions of individual bees.
    The cooperation between honeybees during the foraging process leads to advantageous
    behaviors that optimize the hive’s overall fitness. By using individual foragers,
    honeybee colonies aim to minimize the cost/benefit ratio, rather than expending
    energy searching in all directions indiscriminately. They concentrate their foraging
    efforts on the most rewarding patches, while disregarding those of lesser quality.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Observations have shown that when colony food resources are scarce, foragers
    exhibit increased recruitment behaviors, characterized by changes in their dance
    patterns upon returning to the hive. This enhanced recruitment serves to mobilize
    more nestmates to exploit available food sources. In addition to foraging, honeybees
    also cooperate in various other tasks, such as hive construction, hive thermoregulation,
    and colony defense, showcasing their exceptional teamwork skills.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Discover the fascinating world of honeybees
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Honeybees are the most well-known and important insects that produce food consumed
    by humans.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honeybee colonies consist of a single queen, hundreds of male drones, and 20,000
    to 80,000 female worker bees.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single worker bee may visit 50 to 1,000 flowers per day. Bees from the same
    hive can visit up to 225,000 flowers in one day. Honeybees can fly at speeds of
    21 to 28 km/h (13–17 mph) and can have a foraging area up to 70 km² (27 mi²).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honeybees can maintain a constant temperature of about 33°C (91°F) in their
    hive, regardless of the outside temperature.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honeybees choose the hexagonal shape for their honeycomb cells to hold the queen
    bee’s eggs and store the pollen and honey the worker bees bring to the hive.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hexagonal structure has several advantages, such as efficient use of space
    (creating the maximum number of cells that can be built in a given area), structural
    strength (it’s strong and stable), material efficiency (it uses less beeswax),
    and optimal angle (a slight tilt, ~13 degrees from horizontal, to prevent honey
    from spilling out of the cells while still allowing bees to move around easily).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honeybees communicate with each other through complex dance moves called “waggle
    dances,” explained in “The Waggle Dance of the Honeybee,” a video from Georgia
    Tech College of Computing ([http://mng.bz/gvxx](http://mng.bz/gvxx)).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The artificial bee colony (ABC) algorithm is a swarm intelligence algorithm
    based on the foraging behavior of honeybees. Specifically, it is inspired by the
    way honeybees search for food sources and communicate their findings to optimize
    the gathering of resources. Let’s first look at how honeybees forage for food.
    Figure 10.14 illustrates the steps of their foraging behavior.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F14_Khamis.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 Foraging behavior of honeybees
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The foraging behavior can be summarized in the following steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '*Initialization*—Forager bees (employed bees) and scout bees begin their foraging
    for food sources. Forager bees usually gather resources from known sources around
    the hive to meet the colony’s immediate needs. Scout bees locate new food sources
    to ensure the colony’s long-term survival, especially if the food sources around
    the hive start to deplete. Scout bees only represent a small percentage of colony
    members, but they save the colony many wasted miles of flight trying to locate
    abundant new food sources. It is worth noting that forager bees and scout bees
    are both worker bees (female bees). A worker bee can switch roles from being a
    forager to a scout, depending on the colony’s needs and food source availability.
    In summary, forager bees concentrate on exploiting the available resources while
    scout bees focus on exploring to discover new resources.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Exploration*—Forager bees leave the hive and start searching for food sources,
    such as flowers with nectar and pollen, in the surrounding area. Scout bees explore
    areas farther away to discover new food sources.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Detection*—When a suitable food source is found, the worker bee lands on the
    flower and begins to collect nectar in her honey stomach or gathers pollen on
    her hind legs.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Memorization*—The bee takes note of the food source’s location, including
    its distance and direction from the hive, as well as the flower type and quality.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Return to the hive*—Once the worker bee has collected enough resources or
    her honey stomach is full, she flies back to the hive. Upon reaching the hive,
    the forager bee transfers the nectar to a house bee, who then processes and stores
    it as honey. Pollen is similarly offloaded to other bees for storage and later
    use as food.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Communication*—The worker bee performs a waggle dance on the hive’s dance
    floor to share the location information with her nestmates (aka *onlooker bees*).
    The dance communicates the direction, distance, and quality of the food source.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Recruitment*—Onlooker bees observe the waggle dance and decode the information
    about the food source’s location. These bees then fly out to collect the resources.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Repeat*—The worker bee continues to visit the same food source until it is
    depleted or another bee recruits her to a more promising source. In either case,
    she repeats the foraging process to ensure the colony’s needs are met.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let’s look at the ABC algorithm in more detail.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Exploring the artificial bee colony algorithm
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The artificial bee colony (ABC) algorithm, proposed by Dervis Karaboga in 2005
    [1], simulates the roles of three types of bees: employed bees (foragers), onlooker
    bees, and scout bees. Algorithm 10.1 shows the steps of the ABC algorithm.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 10.1 Artificial bee colony algorithm
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the ABC algorithm simulates the honeybee foraging behaviors
    to explore and exploit the search space, balancing global exploration (diversity)
    and local exploitation (convergence) to efficiently solve optimization problems.
    In the ABC algorithm, the three types of bees have the following complementary
    roles:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '*Employed bees (foragers)—*These bees exploit the current food sources, meaning
    they search around their current position (searching the neighborhood) to find
    better solutions. These bees perform a local search (intensification), which refines
    the current best solutions.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Onlooker bees*—These bees also contribute to exploitation. They probabilistically
    choose food sources depending on the fitness of the solutions found by the employed
    bees. They are more likely to choose better solutions (food sources with more
    nectar) for further exploitation.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scout bees*—These bees perform the exploration. If a food source is exhausted
    (if the solution cannot be improved after a certain number of iterations), the
    employed bee associated with that food source becomes a scout bee. Scout bees
    perform a global search (diversification) by abandoning the exhausted food source
    and randomly searching for new food sources in the problem space. This process
    prevents the algorithm from getting stuck in local optima by exploring new regions
    of the search space.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the ABC algorithm, communication between the bees is simulated by sharing
    the fitness values of solutions among employed and onlooker bees, guiding them
    toward better solutions. The ABC algorithm adopts a fitness-proportionate selection
    process inspired by how bees choose food sources based on their quality. In the
    algorithm, employed bees and onlooker bees select solutions with a probability
    proportional to their fitness, promoting better solutions to be explored more
    frequently.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how we can use ABC to solve optimization problems, let’s consider
    minimizing the Rosenbrock function using ABC. The Rosenbrock function, also referred
    to as the *valley* or *banana function*, is a popular test problem for gradient-based
    optimization algorithms. This function has *n* dimensions and takes the following
    general form:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F14_Khamis-EQ13.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: '| 10.12 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: The function is usually evaluated on the hypercube x*[i]* ∈ [–5, 10] for all
    *i* = 1,...,*n*, but the domain may be restricted to x*[i]* ∈ [–2.048, 2.048]
    for all *i* = 1,...,*n*. This function has a global minimum at *f*(*x*^*) = 0.0
    located at (1,...,1).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the 2D Rosenbrock function that takes the following form:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F14_Khamis-EQ14.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '| 10.13 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: Figure 10.15 shows the 2D surface of Rosenbrock function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F15_Khamis.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 The 2D surface plot of the Rosenbrock function. The dot indicates
    the global minimum of this function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how we can minimize this function using ABC:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '*Initialization phase*—Let’s assume that we have a swarm of *N* = 6 bees. Each
    bee tries to find a candidate solution, and each solution *i* in the population
    consists of a position vector *X[mi]* = {*x[mi], y[mi]*} where *X[mi]* ∈ [–2.048,
    2.048] and *m* = 1,…,*N*. *X[mi]* represents a potential solution to the optimization
    problem. The position of the employed bees is randomly determined within the boundaries.
    These initial solutions can be generated using the following formula:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F15_Khamis-EQ15.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: '| 10.14 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: where *l[i]* and *u[i]* are the lower and upper bounds of the decision variables.
    Let’s assume the initial positions (represented as (*x, y*)) shown in table 10.1.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 Initial food sources
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '| Candidate solution *X[m]* | Objective function *f[m](**X[m]**)* |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| *X*[1] = (–1.04,0.11) | 98.56 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| *X*[2] = (–1.61,–1.98) | 2097.22 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| *X*[3] = (1.82,1.22) | 438.49 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| *X*[4] = (–1.64,1.92) | 66.20 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| *X*[5] = (0.77,0.04) | 30.62 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| *X*[6] = (–0.66,1.59) | 136.02 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '*Employed bee phase*—In the employed bee phase, each bee generates a new solution
    in the neighborhood of its current solution using the following formula:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F15_Khamis-EQ16.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: '| 10.15 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: where *v[mj]* is the new solution, *x[mi]* is the current solution, *ϕ[mi]*
    is a random number between –1 and 1, and *x[ki]* is a randomly chosen solution
    different from the current solution. Let’s assume that all *ϕ[mi]* are –0.9 for
    simplicity, and for each bee, we choose the solution of bee 1 to calculate the
    new solutions. The best bee, in the initial population (table 10.1), bee 5, can
    also be used. We then calculate the new fitness values shown in table 10.2.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.2 New food sources
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '| Candidate solution *X[m]* | Objective function *f[m]*(*X[m]*) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| *X*[1] = (–1.04,0.11) | 98.56 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| *X*[2] = (–1.10,–0.10) | 174.02 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| *X*[3] = (–0.75,0.22) | 15.15 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| *X*[4] = (–1.10,0.29) | 88.87 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| *X*[5] = (–0.86,0.10) | 43.76 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| *X*[6] = (–1.00,0.26) | 59.66 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '*Onlooker bee phase*—The onlooker bees observe the dance of the employed bees
    and choose a food source depending on the nectar amount (the *fitness value*).
    If the new solution has a better fitness value, it is remembered as a global variable,
    and the position is updated. Otherwise, the old position is retained. The probability
    value *p[m]*, with which *X[m]* is chosen by an onlooker bee, can be calculated
    by using the following formula:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F15_Khamis-EQ17.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: '| 10.16 |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: 'where *fit[m]*(*X[m]*) is the fitness value of the solution, which can be calculated
    using the following expression:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F15_Khamis-EQ18.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: '| 10.17 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: where *f[m]*(*X[m]*) is the objective function of solution *X[m]*. Table 10.3
    shows the solution fitness calculations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.3 Solution fitness calculations
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '| Candidate solution *X[m]* | Objective function *f[m]*(*X[m]**)* | Fitness
    *fit[m]*(*X[m]*) | Probability of selection *p[m]* |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| *X*[1] = (–1.04,0.11) | 98.56 | 0.010 | 0.08 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| *X*[2] = (–1.10,–0.10) | 174.02 | 0.006 | 0.04 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| *X*[3] = (–0.75,0.22) | 15.15 | 0.062 | 0.49 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| *X*[4] = (–1.10,0.29) | 88.87 | 0.011 | 0.09 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| *X*[5] = (–0.86,0.10) | 43.76 | 0.022 | 0.18 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| *X*[6] = (–1.00,0.26) | 59.66 | 0.016 | 0.13 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: In this example, the food source discovered by bee 3 is most likely to be chosen.
    After a food source *X[m]* for an onlooker bee is probabilistically chosen, a
    neighborhood source *v[m]* is determined by using equation 10.15, and its fitness
    value is computed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '*Scout bee phase*—If a position cannot be improved further through a predetermined
    number of cycles or trials (called the *limit*), that position is abandoned and
    the bee becomes a scout, searching for a new random position, which can be generated
    by equation 10.14.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now see how we can implement ABC in Python to solve this problem. In the
    next listing, we start by importing the libraries we’ll use and defining the `rosenbrock_function`.
    This function takes as an argument a candidate solution (x, y) to the Rosenbrock
    function and returns its value.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.2 Solving Rosenbrock function optimization using ABC
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As a continuation of listing 10.2, we’ll create a `Bee` that contains the following
    attributes:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '`position`—The position of the bee in the search space (solution)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fitness`—The fitness of the bee’s current position (the value of the Rosenbrock
    function at the current position)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`counter`—A counter to track the number of unsuccessful trials (iterations
    without improvement in the bee’s fitness):'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we need a function to generate a `Bee` with a random position and calculate
    its fitness using the Rosenbrock function:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following function will update the position of a given bee using the position
    of a partner bee. If the new position has a better fitness value, the bee’s position,
    fitness, and counter are updated. Otherwise, the counter is incremented:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Determine which element of the bee’s position will be updated.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: ② Clip to ensure it stays within a specified range.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll define an `abc_algorithm` function to implement the ABC algorithm
    with the following input parameters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '`dimensions`—The number of dimensions of the problem, which is 2 for the Rosenbrock
    function'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_bees`—The total number of bees in the colony'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_iter`—The maximum number of iterations the algorithm should run'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_trials`—The maximum number of unsuccessful cycles or trials (iterations
    without improvement) allowed before a bee becomes a scout bee:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Generate an initial population of bees.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: ② Find the bee with the best fitness value.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: ③ Perform the employed bees phase.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: ④ Perform the onlooker bees phase.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Calculate the selection probability according equations 16 and 17.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Perform the scout bees phase.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Check if each bee’s counter exceeds max_trials.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Update best_bee with the new best bee.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Return best_bee, which represents the optimal solution.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can set up the parameters of the ABC algorithm and apply it to solve
    the problem:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Define the problem dimensions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: ② Set the number of bees.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the maximum number of iterations used as a stopping criterion.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the maximum number of unsuccessful trials (iterations without improvement)
    allowed before a bee becomes a scout bee.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Run the ABC algorithm with the parameters specified and store the best bee
    (the one with the minimum fitness value) in the best_bee variable.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the position of best_bee, which represents the solution and its fitness,
    which is the value of the Rosenbrock function at the best solution.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will produce output like the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In contrast to genetic algorithms and particle swarm optimization algorithms,
    the availability of well-established and comprehensive Python packages specifically
    designed for the ABC algorithm is relatively limited. However, there is a Python
    library called MEALPY that offers implementations of population-based metaheuristic
    algorithms, including ABC. You can install MEALPY using `pip install mealpy`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'As a continuation of listing 10.2, the following code snippet demonstrates
    using the `OriginalABC` class from the MEALPY library to minimize the Rosenbrock
    function:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Import the solver from MEALPY library.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the problem using dictionary.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: ③ Set the number of epochs (iterations).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the population size.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set the limit on the number of unsuccessful trials before a scout bee is triggered.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Create an instance of the algorithm class.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Run the algorithm.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Print the results.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the `OriginalABC` class from the `mealpy.swarm_based.ABC`
    module, which is the implementation of the ABC algorithm provided by the MEALPY
    library. We then define the problem dictionary, which contains the cost function
    (`fit_func`), lower bound (`lb`), upper bound (`ub`), and whether this is a minimization
    or maximization problem (`minmax`). The number of epochs (iterations), population
    size, and the limit on the number of unsuccessful trials before a scout bee is
    triggered are set. We then create an instance of the `OriginalABC` class, initialized
    with the specified parameters. The `solve()` method is called on the `model` object,
    passing the `problem_dict` as an argument. It performs the ABC algorithm optimization
    process on the defined problem and returns the best solution and fitness value.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code will produce a solution like the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Figure 10.16 shows the solution obtained by the ABC solver, ABC MEALPLY, and
    the ACO solver implemented as part of the complete listing 10.2.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH10_F16_Khamis.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 The Rosenbrock function contour and solutions using the ABC and
    ACO algorithms
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the ABC, ABC MEALPY, and ACO solutions are all close to the
    optimal solution of this function. With parameter tuning, an optimal solution
    can be reached by these algorithms. You can use the code in listing 10.2 to experiment
    with different algorithm parameter settings and different problem dimensions.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes the fourth part of this book. In this part, we’ve delved
    deep into the fascinating world of swarm intelligence, exploring how simple entities,
    like birds in particle swarm optimization (PSO), ants in ant colony optimization
    (ACO), and bees in the artificial bee colony (ABC) algorithm, can collectively
    perform complex tasks. These nature-inspired algorithms elegantly balance exploration
    and exploitation to find optimal or near-optimal solutions to complex optimization
    problems.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: As we move forward, we’ll transition to the domain of machine learning. In the
    last part of this book, we’ll look at machine learning methods specifically tailored
    for search and optimization. We’ll explore cutting-edge techniques, such as graph
    neural networks, attention mechanisms, self-organizing maps, and reinforcement
    learning, and investigate their applications in search and optimization.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ant colony optimization (ACO) is a population-based algorithm inspired by the
    foraging behavior of ants. Simple ACO (SACO), ant system (AS), ant colony system
    (ACS), and max–min ant system (MMAS) are examples of ACO metaheuristics algorithms.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During foraging, ants discover good solutions, which influence the decisions
    of other ants. Over time, the pheromone trails intensify along the paths of better
    solutions, attracting more ants to explore those paths. This is called autocatalytic
    behavior.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pheromone updates include two phases: evaporation and deposit. During the evaporation
    phase, the pheromone concentration is decreased. Ants can deposit pheromones during
    the construction of a solution, using the online step-by-step pheromone update
    method, or after the solution has been built, by revisiting all the states visited
    during the construction process, using the online delayed pheromone update method.
    In some cases, both methods can be used together.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ant system (AS) improves on simple ACO by adding a memory capability in the
    form of a tabu list.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ant colony system (ACS) algorithm is an extension of the AS algorithm with
    a modified transition rule that utilizes an elitist strategy.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The max–min ant system (MMAS) addresses the limitations of AS and ACS by using
    the iteration-best path for pheromone updates, encouraging exploration and constraining
    pheromone values between minimum and maximum values. This approach reduces the
    risk of premature stagnation and improves performance by balancing exploration
    and exploitation.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The artificial bee colony (ABC) algorithm is a population-based search algorithm
    inspired by the foraging behavior of honeybees. The ABC algorithm manages the
    balance between exploration and exploitation through its three types of bees (employed
    bees, onlooker bees, and scout bees), each of which perform different complementary
    roles.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inherent randomness in stochastic optimization algorithms due to initial
    conditions and the probabilistic decision-making process is not necessarily a
    bad thing. It can help the algorithm avoid getting stuck in local optima—solutions
    that are the best in their immediate vicinity but are not the best overall. By
    occasionally taking less promising paths, the algorithm can explore more of the
    solution space and has a better chance of finding the global optimum—the best
    possible solution.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
