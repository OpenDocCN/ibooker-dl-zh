- en: 10 Other swarm intelligence algorithms to explore
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 其他要探索的群智能算法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Getting familiar with ant colony optimization metaheuristics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉蚁群优化元启发式算法
- en: Understanding different variants of ant colony optimization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解蚁群优化的不同变体
- en: Understanding artificial bee colony
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解人工蜂群
- en: Applying these swarm intelligence algorithms to solve continuous and discrete
    optimization problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些群智能算法应用于解决连续和离散优化问题
- en: 'In the previous chapter, we looked at the particle swarm optimization (PSO)
    algorithm, but ant colony optimization (ACO) and artificial bee colony (ABC) are
    other widely used swarm intelligence algorithms, drawing inspiration from ants
    and bees to tackle diverse optimization problems. Let’s revisit the treasure hunting
    mission and assume you still want to follow a cooperative and iterative approach
    to find the treasure (which is the best solution in the case of an optimization
    problem). You and your friends are divided into two groups: the ant group and
    the bee group. Each group has its own unique way of finding the treasure, using
    ant colony optimization or the artificial bee colony algorithm. You can join either
    of these two groups.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了粒子群优化（PSO）算法，但蚁群优化（ACO）和人工蜂群（ABC）也是其他广泛使用的群智能算法，它们从蚂蚁和蜜蜂那里汲取灵感来解决各种优化问题。让我们重新审视寻宝任务，并假设你仍然想采用一种合作和迭代的途径来找到宝藏（在优化问题的情况下，这是最佳解决方案）。你和你的朋友们被分为两个小组：蚂蚁小组和蜜蜂小组。每个小组都有自己独特的寻找宝藏的方式，使用蚁群优化或人工蜂群算法。你可以加入这两个小组中的任何一个。
- en: As treasure-hunting ants, you and some of your friends will start at the base
    camp and explore different paths to find the treasure. As you explore, each of
    you leaves a trail of special chalk (pheromones) behind. The more promising the
    path, the more chalk you leave on that path. When your friends find your chalk
    trail, they can decide to follow it or to explore a new path. Over time, the most
    promising paths will have the strongest chalk trails, and eventually the whole
    group will converge on the path that leads to the treasure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为寻宝的蚂蚁，你和你的朋友们将从基地营出发，探索不同的路径以找到宝藏。在探索过程中，你们每个人都会在身后留下特殊的粉笔（信息素）痕迹。路径越有希望，你在这条路径上留下的粉笔就越多。当你的朋友们找到你的粉笔痕迹时，他们可以决定跟随它或者探索一条新的路径。随着时间的推移，最有希望的路径将会有最强的粉笔痕迹，最终整个群体将汇聚到通往宝藏的路径上。
- en: As treasure-hunting bees, you’ll use a different approach. You have forager
    bees and scout bees. Forager bees concentrate on searching nearby areas, while
    scout bees fly out and randomly explore the island, searching for clues leading
    to the treasure. When a bee finds a promising clue, it returns to the base camp
    and performs a “waggle dance” to communicate the location and quality of the clue
    to the other friends (onlooker bees). This process continues until the group finds
    the best path to the treasure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为寻宝的蜜蜂，你将采用不同的方法。你有觅食蜂和侦察蜂。觅食蜂专注于搜索附近区域，而侦察蜂飞出去随机探索岛屿，寻找通往宝藏的线索。当一只蜜蜂找到有希望的线索时，它会返回基地营并执行“摇摆舞”来向其他朋友（旁观蜂）传达线索的位置和质量。这个过程会一直持续到群体找到通往宝藏的最佳路径。
- en: This chapter presents ant colony optimization and artificial bee colony as swarm
    intelligence algorithms. The open traveling salesman problem, function optimization,
    routing problem, pump design, and a supply-demand problem are discussed in this
    chapter and its supplementary exercises in appendix C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了蚁群优化和人工蜂群优化作为群智能算法。本章讨论了开放旅行商问题、函数优化、路由问题、泵设计以及供需问题，并在附录C的补充练习中进行了讨论。
- en: 10.1 Nature’s tiny problem-solvers
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 自然界的微小问题解决者
- en: Ants are tiny creatures that can solve complex problems better than some humans.
    Ants may be small, but when they work together in a colony, they can accomplish
    some incredible feats. During foraging, they can find the shortest path to a food
    source, build intricate tunnels, and even take down prey much larger than themselves!
    During nest construction, some ants cut leaves from plants and trees, others forage
    for leaves hundreds of meters away from their nest to construct highways to and
    from their foraging sites, and yet other ants form chains of their own bodies,
    allowing them to cross wide gaps and pull stiff leaves together to form a nest.
    In the latter case, the worker ants form a chain along the edge of the leaf and
    pull the edges together by shortening the chain one ant at a time. Once the leaf
    edges are in place, weaver ants hold one larva each in their mandibles and gently
    squeeze the larva to produce silk, which is used to glue the leaf edges together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁是微小的生物，它们解决复杂问题的能力甚至超过某些人类。蚂蚁可能体积小，但当他们作为一个群体工作时，他们可以完成一些令人难以置信的壮举。在觅食过程中，它们可以找到通往食物来源的最短路径，建造复杂的隧道，甚至捕食比它们自身大得多的猎物！在巢穴建造过程中，一些蚂蚁从植物和树木上剪下叶子，其他蚂蚁在距离巢穴数百米远的地方觅食叶子，以建造通往觅食地点的高速公路，还有其他蚂蚁用自己的身体形成链条，使它们能够跨越宽阔的缝隙，并将硬叶拉在一起形成巢穴。在后一种情况下，工蚁沿着叶子的边缘形成链条，并一次缩短一个蚂蚁的链条来拉紧叶子的边缘。一旦叶子边缘就位，织叶蚁用它们的颚各夹住一个幼虫，并轻轻挤压幼虫以产生丝线，这种丝线被用来粘合叶子的边缘。
- en: Fascinating facts about the mighty ant
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于强大的蚂蚁的有趣事实
- en: Ants appeared on earth some 100 million years ago, making them one of the oldest
    groups of insects on the planet.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁在大约一亿年前出现在地球上，使它们成为地球上最古老的昆虫群体之一。
- en: Ants have a current total population estimated at 10^(16) individuals. It is
    estimated that the total weight of ants is in the same order of magnitude as the
    total weight of human beings.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁的当前总估计人口为10的16次方个体。据估计，蚂蚁的总重量与人类的总重量处于同一数量级。
- en: Ants are incredibly strong for their size. Some species can carry objects that
    are 50 times their body weight! To put that in perspective, this is like a human
    carrying a car!
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁对于它们的体型来说非常强壮。一些种类可以携带重量是它们自身体重50倍的物体！为了更直观地理解这一点，这就像一个人携带一辆汽车一样！
- en: About 2% of all insects are social. There are around 12,000 different types
    of ants, and most ants are social insects.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约2%的昆虫是社会的。大约有12,000种不同的蚂蚁，大多数蚂蚁都是社会性昆虫。
- en: Ants are considered the densest population in the world. They live in colonies
    of 30 to millions of individuals. Some colonies like Formica Yesensis have approximately
    1,080,000 queens and 306,000,000 workers and live in 45,000 nests connected to
    each other over an area of 2.7 square kilometers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁被认为是世界上人口密度最高的生物。它们生活在由30个到数百万个个体组成的群体中。一些群体，如Formica Yesensis，大约有1,080,000个蚁后和306,000,000个工蚁，生活在2.7平方公里的区域内，45,000个巢穴相互连接。
- en: Ants use pheromones as their primary medium of stigmergic communication. However,
    ants also use other forms of communication, including visual, auditory, and tactile
    communication. For example, some species of ants use sound to communicate with
    each other. These sounds can range from simple clicks and pops to more complex
    signals that convey information about food sources, nest locations, and other
    important information. Some species of ants produce sounds in the audible range
    of humans (20Hz to 20kHz). For example, leafcutter ants are known to produce a
    clicking sound when they communicate with each other. The frequency of these clicks
    can range from 1 to 10 kilohertz. Other species of ants produce sounds that are
    beyond the range of human hearing. For example, some species of army ants produce
    ultrasonic sounds that can be used to locate prey or communicate with each other.
    If you’re interested, take a look at the “What Sound Does an Ant Make?” video
    on YouTube ([http://mng.bz/aEKo](http://mng.bz/aEKo)).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁使用信息素作为它们主要的聚群通信媒介。然而，蚂蚁还使用其他形式的通信，包括视觉、听觉和触觉通信。例如，一些蚂蚁种类使用声音来相互沟通。这些声音可以从简单的点击声和爆裂声到更复杂的信号，这些信号传达有关食物来源、巢穴位置和其他重要信息。一些蚂蚁种类产生的声音在人类的可听范围内（20Hz到20kHz）。例如，切叶蚁在相互沟通时会产生点击声。这些点击声的频率可以从1到10千赫兹。其他蚂蚁种类产生的声音超出了人类的听觉范围。例如，一些军蚁产生超声波，可以用来定位猎物或相互沟通。如果你感兴趣，可以在YouTube上查看“蚂蚁发出什么声音？”的视频（[http://mng.bz/aEKo](http://mng.bz/aEKo)）。
- en: An ant is a simple stimulus-response creature that is incapable of achieving
    complex tasks alone. However, as a colony, ants show an amazing capability to
    perform complex tasks without any planning, a central controller, centralized
    supervision, or direct communication. Ants employ an indirect communication mechanism
    known as stigmergic communication. *Stigmergy* is a concept introduced by the
    French biologist Pierre-Paul Grassé in 1959 as an indirect method of communication
    among social insects involving environmental modifications. These environmental
    modifications serve as external or shared memory between the insects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁是一种简单的刺激-反应生物，单独无法完成复杂任务。然而，作为一个群体，蚂蚁展现出惊人的能力，能够在没有任何计划、中央控制器、集中监督或直接沟通的情况下执行复杂任务。蚂蚁采用一种称为群居通信的间接沟通机制。*群居性*是法国生物学家皮埃尔-保罗·格雷斯在1959年提出的一个概念，它是一种涉及环境修改的社会性昆虫之间的间接沟通方法。这些环境修改作为昆虫之间的外部或共享记忆。
- en: Ants use pheromones as their primary medium of stigmergic communication. As
    they travel to and from a food source, they deposit pheromones along their path.
    Other ants can detect these pheromones, which influences their decision-making
    when choosing a path. This allows ants to work together as a cohesive unit and
    accomplish complex tasks such as finding the shortest path from the nest to a
    food source and vice versa. The absence of direct communication or a central controller
    makes the actions of ants seem almost as if they are coordinated by some form
    of collective intelligence. In essence, the phenomenon of stigmergic communication
    allows social insects like ants to use their collective knowledge and behavior
    to achieve tasks beyond their individual abilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁使用信息素作为它们主要的群居通信媒介。当它们往返于食物来源地时，会在路径上留下信息素。其他蚂蚁可以检测到这些信息素，这会影响它们在选择路径时的决策。这使得蚂蚁能够作为一个紧密的单元共同工作，完成诸如从巢穴到食物来源地以及相反方向的最短路径寻找等复杂任务。没有直接的沟通或中央控制器使得蚂蚁的行动看起来几乎像是某种形式的集体智慧所协调。本质上，群居通信的现象使得像蚂蚁这样的社会性昆虫能够利用它们的集体知识和行为来完成超出个体能力的任务。
- en: Ant colony optimization (ACO) is inspired by the foraging behavior of ants.
    As they forage for food, ants initially explore randomly around the nest area.
    Once an ant discovers a food source, it carries some of the food back to the nest
    while laying a pheromone trail along its path. Other ants then follow the pheromone
    trail to the food source, as illustrated in figure 10.1\. As more and more ants
    follow the pheromone trail to the food source, the intensity of the pheromone
    trail increases, making it more attractive to other ants. In contrast, because
    pheromone trails are not fixed and will gradually evaporate over time, the pheromone
    trail on the longer path will evaporate. Eventually, a single pheromone trail
    becomes dominant, and most of the ants follow this trail to and from the food
    source. In this way, ants can find the shortest path between the nest and the
    food source through a process of collective or swarm intelligence.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁群体优化（ACO）灵感来源于蚂蚁的觅食行为。当它们觅食时，蚂蚁最初会在巢穴区域周围随机探索。一旦蚂蚁发现食物来源，它会携带一些食物返回巢穴，同时在路径上留下信息素轨迹。然后其他蚂蚁会跟随信息素轨迹到达食物来源，如图10.1所示。随着越来越多的蚂蚁跟随信息素轨迹到达食物来源，信息素轨迹的强度增加，对其他蚂蚁更具吸引力。相反，由于信息素轨迹不是固定的，并且会随着时间的推移逐渐蒸发，较长路径上的信息素轨迹会蒸发。最终，一条单独的信息素轨迹变得主导，大部分蚂蚁都会跟随这条轨迹往返于食物来源地。通过这种方式，蚂蚁可以通过集体或群体智能的过程找到巢穴和食物来源地之间的最短路径。
- en: '![](../Images/CH10_F01_Khamis.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F01_Khamis.png)'
- en: Figure 10.1 Ant foregoing process. A foraging ant deposits a pheromone trail
    along the path it takes on its way back to the nest. Other ants will likely follow
    the path with a stronger pheromone trail to reach the discovered food source.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 蚂蚁觅食过程。觅食的蚂蚁在其返回巢穴的路径上留下信息素轨迹。其他蚂蚁很可能会跟随具有更强信息素轨迹的路径，以到达发现的食品来源。
- en: 'As I explained in the previous chapter, the majority of the research carried
    out on swarm intelligence algorithms was initially based on experimental observations.
    To understand the collective behavior of ants during food foraging and to derive
    heuristics for the ACO algorithm, two famous experiments were conducted: the binary
    bridge experiment and the bridges with non-equal lengths experiment.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一章中解释的，对群体智能算法的研究大多数最初是基于实验观察。为了理解蚂蚁在觅食过程中的集体行为，并为ACO算法推导启发式方法，进行了两个著名的实验：二进制桥梁实验和长度不等桥梁实验。
- en: The binary bridge experiment was designed to observe the behavior of ants when
    presented with two equal-length bridges connecting their nest to a food source
    (figure 10.2a). The experiment aimed to investigate how ants determine the best
    path to use and how they adapt their behavior over time. Initially, the ants chose
    one of the two bridges randomly. As the ants traveled back and forth between the
    nest and the food source, they deposited pheromones along the path they took.
    As time progressed, more ants followed the path with the higher concentration
    of pheromones, which made the path even more attractive to other ants. Eventually,
    one of the two bridges became dominant, and most of the ants used it to travel
    between the nest and the food source. The ants’ decision-making process was based
    on the principle of positive feedback, where the ants reinforced the path with
    the highest pheromone concentration, making it even more attractive to other ants.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制桥梁实验是为了观察蚂蚁在面临两条连接巢穴到食物源等长的桥梁时的行为（图10.2a）。实验旨在研究蚂蚁如何确定最佳路径以及它们如何随时间调整行为。最初，蚂蚁随机选择两条桥梁中的一条。随着蚂蚁在巢穴和食物源之间往返，它们会在所走的路径上留下信息素。随着时间的推移，更多的蚂蚁跟随信息素浓度更高的路径，这使得路径对其他蚂蚁更具吸引力。最终，两条桥梁中的一条成为主导，大多数蚂蚁使用它来在巢穴和食物源之间旅行。蚂蚁的决策过程基于正反馈原理，蚂蚁强化了信息素浓度最高的路径，使其对其他蚂蚁更具吸引力。
- en: '![](../Images/CH10_F02_Khamis.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F02_Khamis.png)'
- en: Figure 10.2 a) Binary bridge experiment; b) bridges with non-equal lengths experiment
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 a) 二进制桥梁实验；b) 长度不等桥梁实验
- en: The bridges with non-equal lengths experiment (figure 10.2b) is an extension
    of the binary bridge experiment with one branch of the bridge being longer than
    the other. The goal of this experiment was to observe how ants adapted their behavior
    when presented with two paths of different lengths. The experiment showed that
    ants tended to select the shorter path over the longer one. This was because ants
    traveling on the shorter path returned to the nest earlier than those on the longer
    path. As a result, the pheromone trail on the shorter path was reinforced sooner
    than that on the longer path, making it more attractive to other ants. This reinforcement
    behavior is called *autocatalytic behavior*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 长度不等桥梁实验（图10.2b）是二进制桥梁实验的扩展，其中桥梁的一支比另一支长。这个实验的目的是观察蚂蚁在面临两条不同长度的路径时的行为调整。实验表明，蚂蚁倾向于选择较短的路径而不是较长的路径。这是因为沿着较短路径旅行的蚂蚁比沿着较长路径旅行的蚂蚁更早返回巢穴。因此，较短路径上的信息素路径比较长路径上的信息素路径更快得到强化，使其对其他蚂蚁更具吸引力。这种强化行为被称为*自催化行为*。
- en: 'The role of pheromones in the collective behavior of ants can be summarized
    in the following key points:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 信息素在蚂蚁的集体行为中的作用可以总结为以下要点：
- en: The pheromone trail acts as a collective memory for the ants to communicate
    through by sensing and recording their foraging experience.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息素路径作为蚂蚁通过感知和记录它们的觅食经验来沟通的集体记忆。
- en: The pheromone trail evaporates over time, introducing changes in the environment
    that can influence the ants’ behavior.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，信息素路径会蒸发，引入环境变化，这些变化可以影响蚂蚁的行为。
- en: The concentration of pheromones on the trail represents a feedback signal that
    influences the ants’ decision-making process.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径上的信息素浓度代表了一个反馈信号，它影响着蚂蚁的决策过程。
- en: Let’s now dive deep into ACO metaheuristics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们深入探讨ACO元启发式算法。
- en: 10.2 ACO metaheuristics
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 ACO元启发式算法
- en: Ant colony optimization (ACO) mimics the behavior of real ant colonies by having
    a group of “artificial ants” search for the best solution to a problem. These
    artificial ants leave “pheromone trails” to communicate with each other, just
    like real ants do, and eventually converge on the best solution.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁群优化（ACO）通过一组“人工蚂蚁”搜索问题的最佳解决方案来模拟真实蚂蚁群体的行为。这些人工蚂蚁留下“信息素路径”来相互沟通，就像真实蚂蚁一样，最终收敛到最佳解决方案。
- en: 'To simulate the behavior of ants, let’s assume we have a nest and a food source
    connected through two paths with different lengths *L[1]* and *L[2]*, as in the
    case of the bridges with non-equal lengths. Let’s now assign a computational parameter
    *τ* to represent the pheromone deposited by the ants. We’ll initially assign equal
    values of pheromones to each path: *τ[1]* = *τ[2]* as shown in figure 10.3\. We
    then start by placing *m* ants at the nest. Let’s assume that these artificial
    ants exactly mimic the real ants and take decisions based on the pheromone concentration,
    but without any knowledge of the lengths of the paths. For each ant *k*, this
    ant traverses path 1 with probability'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟蚂蚁的行为，让我们假设我们有一个巢穴和一个通过两条不同长度 *L[1]* 和 *L[2]* 连接的食物来源，就像长度不等的桥梁的情况。现在，让我们分配一个计算参数
    *τ* 来表示蚂蚁留下的信息素。我们最初将相同的信息素值分配给每条路径：*τ[1]* = *τ[2]*，如图10.3所示。然后，我们开始在巢穴放置 *m*
    只蚂蚁。让我们假设这些人工蚂蚁完全模仿真实蚂蚁，并根据信息素浓度做出决策，但没有路径长度的任何知识。对于每只蚂蚁 *k*，这只蚂蚁以概率穿越路径1：
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F02_Khamis-EQ01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F02_Khamis-EQ01.png)'
- en: '| 10.1 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 10.1 |'
- en: This ant thus traverses path 2 with a probability *p*[2] = 1 – *p*[1].
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这只蚂蚁以概率 *p*[2] = 1 – *p*[1]穿越路径2。
- en: '![](../Images/CH10_F03_Khamis.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F03_Khamis.png)'
- en: Figure 10.3 ACO simulation
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 ACO模拟
- en: 'As *τ[1]* = *τ[2]*, the ant *k* will randomly pick one of the two paths, as
    both have same probability to of being traversed. After traversing the selected
    paths, pheromone concentration on each path needs to be updated. This pheromone
    update includes two phases: evaporation and deposit. During the evaporation phase,
    the pheromone concentration τ is decremented as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *τ[1]* = *τ[2]*，蚂蚁 *k* 将随机选择两条路径之一，因为两条路径被穿越的概率相同。在穿越所选路径后，每条路径上的信息素浓度需要更新。这种信息素更新包括两个阶段：蒸发和沉积。在蒸发阶段，信息素浓度
    τ 按以下方式递减：
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F03_Khamis-EQ02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F03_Khamis-EQ02.png)'
- en: '| 10.2 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 10.2 |'
- en: where ρ specifies the rate of evaporation. Figure 10.4 shows the effect of the
    pheromone evaporation rate during the foraging process based on a NetLogo simulation.
    NetLogo is a multi-agent programmable modeling environment used to simulate natural
    and social phenomena. It allows users to create, experiment with, and analyze
    simulations of complex systems, such as ecosystems, economies, and social networks.
    The foraging behavior of ants is shown in NetLogo’s Ants model ([https://ccl.northwestern.edu/netlogo/models/Ants](https://ccl.northwestern.edu/netlogo/models/Ants)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ρ 指定了蒸发率。图10.4显示了基于NetLogo模拟的觅食过程中信息素蒸发率的影响。NetLogo是一个多智能体可编程建模环境，用于模拟自然和社会现象。它允许用户创建、实验和分析复杂系统的模拟，如生态系统、经济和社会网络。蚂蚁的觅食行为在NetLogo的蚂蚁模型（[https://ccl.northwestern.edu/netlogo/models/Ants](https://ccl.northwestern.edu/netlogo/models/Ants)）中显示。
- en: '![](../Images/CH10_F04_Khamis.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F04_Khamis.png)'
- en: Figure 10.4 Effect of evaporation rate during the food foraging process. In
    the simulation, the ants initiate their search for food from the central nest,
    which is surrounded by three food sources shown as blobs. The pheromone trails
    are shown in white. Upon discovering a food item, an ant transports it back to
    the nest, leaving behind a chemical trail. This trail is then followed by other
    ants that pick up the scent, directing them toward the food source. As more ants
    continue to retrieve food, they strengthen the chemical trail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 食物觅食过程中蒸发率的影响。在模拟中，蚂蚁从中心巢穴开始寻找食物，巢穴周围有三个以块状表示的食物来源。信息素路径用白色表示。蚂蚁发现食物后，将其运回巢穴，留下化学路径。然后，其他蚂蚁跟随这条路径，嗅到气味，将其引导到食物来源。随着更多蚂蚁继续取回食物，它们会加强化学路径。
- en: As you can see, if the evaporation rate is set to 0, the pheromone trail will
    never evaporate, and the ants will follow the same path repeatedly. This will
    cause the ants to become trapped in a local optimum, and they will not be able
    to explore other paths or find a better solution. On the other hand, if the evaporation
    rate is set to 1, the pheromone trail will evaporate at the maximum rate, which
    means the ants will not be able to follow any trail, and they will be forced to
    explore the environment randomly. This can result in slow convergence to the optimal
    solution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果蒸发率设置为0，信息素路径将永远不会蒸发，蚂蚁将反复跟随相同的路径。这将导致蚂蚁陷入局部最优，它们将无法探索其他路径或找到更好的解决方案。另一方面，如果蒸发率设置为1，信息素路径将以最大速率蒸发，这意味着蚂蚁将无法跟随任何路径，它们将被迫随机探索环境。这可能导致缓慢收敛到最优解。
- en: 'During the deposit phase, each ant leaves more pheromones on its traversed
    path. Figure 10.5 shows the different methods used for pheromone updates:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在沉积阶段，每只蚂蚁在其经过的路径上留下更多的信息素。图10.5展示了用于信息素更新的不同方法：
- en: '*Online step-by-step pheromone update*—Each ant deposits a certain amount of
    pheromones on the path it has traversed. This will increase the probability of
    another ant choosing the same edge:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在线逐步信息素更新*—每只蚂蚁在其经过的路径上沉积一定量的信息素。这将增加另一只蚂蚁选择相同边的概率：'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F04_Khamis-EQ03.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_Khamis-EQ03.png)'
- en: '| 10.3 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 10.3 |'
- en: There are different approaches for choosing the value of Δ*τ*. Following the
    *ant density model*, the ant adds a constant amount *Q* to each traversed edge.
    This means that the final pheromone added to the edge will be proportional to
    the number of ants choosing it. The higher the density of the traffic on the edge,
    the more desirable that edge becomes as a component of the final solution. This
    method does not take the quality of the solution (i.e., the edge length) into
    account. In the *ant quantity model*, the amount of pheromones deposited is proportional
    to the quality of the solution obtained by the ant. For example, an ant traversing
    between node *i* and *j* will deposit a quantity *Q*/*d[ij]*, where *d[ij]* is
    the distance between *i* and *j*. In this case, only local information, *d[ij]*,
    is used to update pheromone concentrations. Lower cost edges are made more desirable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择Δ*τ*值的方法有多种。遵循*蚂蚁密度模型*，蚂蚁将一个常数量*Q*加到每个经过的边上。这意味着最终添加到边上的信息素将与选择该边的蚂蚁数量成比例。边上交通密度越高，该边作为最终解决方案组成部分的吸引力就越大。这种方法不考虑解决方案的质量（即边长）。在*蚂蚁数量模型*中，沉积的信息素量与蚂蚁获得的解决方案质量成比例。例如，蚂蚁在节点*i*和*j*之间穿越时，将沉积量*Q*/*d[ij]*，其中*d[ij]*是*i*和*j*之间的距离。在这种情况下，只使用局部信息*d[ij]*来更新信息素浓度。成本较低的边被赋予更高的吸引力。
- en: '*Online delayed pheromone update (or ant cycle model)*–Once the ant constructs
    the solution, it retraces its steps and updates the pheromones trails on the edges
    it has traversed based on the quality of the solution. The amount of pheromones
    deposited is determined by the quality of the solution obtained by the ant as
    follows:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在线延迟信息素更新（或蚂蚁循环模型）*—一旦蚂蚁构建了解决方案，它将重新走一遍路径，并根据解决方案的质量更新其经过的边上的信息素路径。沉积的信息素量由蚂蚁获得解决方案的质量决定如下：'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F04_Khamis-EQ04.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_Khamis-EQ04.png)'
- en: '| 10.4 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 10.4 |'
- en: where *Q* is a constant and *L^k* is the length of the path constructed by ant
    *k*. For each edge (*i*,*j*) of the corresponding path, and after all the ants
    have completed their tours, the total amount of pheromones deposited will be
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*Q*是一个常数，*L^k*是蚂蚁*k*构建的路径长度。对于对应路径的每个边(*i*,*j*)，在所有蚂蚁完成它们的巡回之后，沉积的总信息素量将是
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F04_Khamis-EQ05.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_Khamis-EQ05.png)'
- en: '| 10.5 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 10.5 |'
- en: where *m* is the number of ants.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*m*是蚂蚁的数量。
- en: '![](../Images/CH10_F05_Khamis.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F05_Khamis.png)'
- en: Figure 10.5 Pheromone update methods
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 信息素更新方法
- en: In summary, with online step-by-step pheromone update, the ant updates the pheromone
    trail *τ[ij]* on the edge (*i*,*j*) when moving from node *i* to node *j*. In
    online delayed pheromone update, once a path is constructed, the ant can retrace
    the same path backward and update the pheromone trails on the traversed edges.
    Which method you choose depends on the specific problem being solved. Any combination
    of online step-by-step pheromone updates and online delayed pheromone updates
    is also possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在在线逐步信息素更新中，蚂蚁在从节点*i*移动到节点*j*时，会在边(*i*,*j*)上更新信息素轨迹*τ[ij]*。在在线延迟信息素更新中，一旦构建了一条路径，蚂蚁可以沿着相同的路径反向追踪并更新经过的边上的信息素轨迹。选择哪种方法取决于要解决的问题。在线逐步信息素更新和在线延迟信息素更新的任何组合也是可能的。
- en: 10.3 ACO variants
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 ACO变体
- en: ACO has been used to solve a wide range of optimization problems, such as vehicle
    routing problems, scheduling problems, and optimal assignment problems. Over the
    years, several variants of the algorithm have been developed, as shown in figure
    10.6.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ACO已被用于解决各种优化问题，如车辆路径问题、调度问题和最优分配问题。多年来，已经开发了该算法的几个变体，如图10.6所示。
- en: '![](../Images/CH10_F06_Khamis.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F06_Khamis.png)'
- en: Figure 10.6 Examples of ACO variants
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 ACO变体的示例
- en: These variants have different strengths and weaknesses, and the choice of variant
    depends on the specific problem being solved. In the following subsections, we
    will discuss some of these variants.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变体有不同的优缺点，变体的选择取决于要解决的问题的具体情况。在以下小节中，我们将讨论这些变体中的一些。
- en: 10.3.1 Simple ACO
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 简单ACO
- en: Simple ACO (SACO) is an algorithmic implementation of the double bridge experiment.
    Consider the problem of finding the shortest path between two nodes on a graph,
    as shown in figure 10.7.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 简单ACO（SACO）是双桥实验的算法实现。考虑在图上找到两个节点之间最短路径的问题，如图10.7所示。
- en: '![](../Images/CH10_F07_Khamis.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F07_Khamis.png)'
- en: Figure 10.7 Shortest path problem
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 最短路径问题
- en: Let’s solve this problem using SACO. On each edge, we’ll assign a small random
    value to indicate the initial pheromone concentration, *τ[ij]*(0). Then we’ll
    place a number of ants, *k* = 1,…,*m* on the source node.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用SACO来解决这个问题。在每条边上，我们将分配一个小的随机值来表示初始信息素浓度，*τ[ij]*(0)。然后，我们将放置一定数量的蚂蚁，*k*
    = 1，…，*m*在源节点上。
- en: 'For each iteration of SACO, each ant will incrementally construct a path (solution)
    to the destination node. Initially, an ant will randomly select which edge to
    follow next. Later, each ant will execute a decision policy to determine the next
    edge of the path. At each node *i*, the ant has a choice to move to any of the
    *j* nodes connected to it, based on the following transition probability:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SACO的每一次迭代，每只蚂蚁都会逐步构建到目标节点的路径（解）。最初，蚂蚁会随机选择下一步要跟随的边。后来，每只蚂蚁将执行决策策略以确定路径的下一个边。在每个节点*i*，蚂蚁可以选择移动到与之相连的任何*j*个节点，基于以下转换概率：
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F07_Khamis-EQ06.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F07_Khamis-EQ06.png)'
- en: '| 10.6 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 10.6 |'
- en: where
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '*N[i]^k* is the set of feasible nodes connected to node *i*, with respect to
    ant *k*.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N[i]^k*是相对于蚂蚁*k*与节点*i*相连的可行节点集合。'
- en: '*τ[ij]* is the amount of pheromones deposited for transition from state *i*
    to *j*.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*τ[ij]*是从状态*i*到状态*j*沉积的信息素量。'
- en: '*η[ij]* is a heuristic value that represents the desirability of state transition
    *ij* (a priori knowledge, typically 1/*d[ij]*, where *d* is the distance).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*η[ij]*是一个启发式值，表示状态转换*ij*（先验知识，通常是1/*d[ij]*，其中*d*是距离）的期望性。'
- en: '*α* ≥ 0 is a parameter that controls the influence of *τ[ij]*. *α* is used
    to amplify the influence of the pheromone. Large values of *α* give excessive
    importance to the pheromone, especially the initial random pheromones, which may
    lead to rapid convergence to suboptimal paths.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*α* ≥ 0是一个参数，用于控制*τ[ij]*的影响。*α*用于放大信息素的影响。*α*的较大值会给信息素赋予过多的重视，尤其是初始的随机信息素，这可能导致快速收敛到次优路径。'
- en: '*β* ≤ 1 is a parameter that controls the influence of the desirability of the
    edge *η[ij]*.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*β* ≤ 1是一个参数，用于控制边*η[ij]*的期望性的影响。'
- en: In the shortest path problem, assume that we use five ants, an initial pheromone
    value of 0.5, and *α* = *β* = 1. The first ant (*k* = 1), placed at the source
    node, has two neighboring nodes {2,3}, as shown in figure 10.8.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在最短路径问题中，假设我们使用五只蚂蚁，初始信息素值为0.5，*α* = *β* = 1。第一只蚂蚁（*k* = 1），放置在源节点，有两个相邻节点{2,3}，如图10.8所示。
- en: '![](../Images/CH10_F08_Khamis.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F08_Khamis.png)'
- en: Figure 10.8 The first ant is at source node 1 with neighbors 2 and 3\. There
    are two numbers on each edge separated by a colon. The first number represents
    the length of the edge, and the second represents the current pheromone concentration
    on the edge.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 第一只蚂蚁位于源节点1，其邻居为2和3。每条边上都有两个用冒号分隔的数字。第一个数字代表边的长度，第二个数字代表边上的当前信息素浓度。
- en: 'Considering the inverse of the edge length as edge desirability, this ant needs
    to choose between nodes 2 and 3 by applying the transition probability as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑边长倒数作为边的吸引力，这只蚂蚁需要通过以下转换概率在节点2和3之间进行选择：
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F08_Khamis-EQ07.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F08_Khamis-EQ07.png)'
- en: '| 10.7 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 10.7 |'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F08_Khamis-EQ08.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F08_Khamis-EQ08.png)'
- en: '| 10.8 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 10.8 |'
- en: where *p*[12]¹ is the probability of node 2 being selected by ant 1 at node
    1, and *p*[13]¹ is the probability of node 3 being selected. We then generate
    a random number *r* between 0 and 1\. If *p*[13]¹ ≥ *r*, we select node 3; otherwise,
    we select 2\. As node 3 has the highest probability of being selected, it will
    most likely be selected.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *p*[12]¹ 是蚂蚁1在节点1选择节点2的概率，*p*[13]¹ 是选择节点3的概率。然后我们在0到1之间生成一个随机数 *r*。如果 *p*[13]¹
    ≥ *r*，我们选择节点3；否则，我们选择2。由于节点3被选中的概率最高，它最有可能被选中。
- en: Moving forward, the first ant is now at node 3 and needs to decide between the
    adjacent nodes 2 and 4 following the same transition probability, which results
    in *p[32]*¹ = 0.29 and *p[34]*¹ = 0.71. Let’s assume that node 4 is selected.
    The ant is now at node 4 and needs to decide between the adjacent nodes 2 and
    5 following the same transition probability, which results in *p*[42]¹ = 0.6 and
    *p*[45]¹ = 0.4. Let’s assume that node 5 is selected, based on the generated random
    number. Figure 10.9 shows the path completed by the first ant in the first iteration
    with length *L*¹(*t* = 1) = 3 + 2 + 6 = 11. Each ant will generate its own path
    following the same steps.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，第一只蚂蚁现在位于节点3，需要根据相同的转换概率在相邻节点2和4之间进行选择，这导致 *p[32]*¹ = 0.29 和 *p[34]*¹ =
    0.71。假设选择了节点4。蚂蚁现在位于节点4，需要根据相同的转换概率在相邻节点2和5之间进行选择，这导致 *p*[42]¹ = 0.6 和 *p*[45]¹
    = 0.4。假设根据生成的随机数选择了节点5。图10.9显示了第一只蚂蚁在第一次迭代中完成的路径，长度 *L*¹(*t* = 1) = 3 + 2 + 6
    = 11。每只蚂蚁将按照相同的步骤生成自己的路径。
- en: '![](../Images/CH10_F09_Khamis.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F09_Khamis.png)'
- en: Figure 10.9 The path constructed by the first ant. Each of the other four ants
    will similarly construct a path.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 第一只蚂蚁构建的路径。其他四只蚂蚁将类似地构建路径。
- en: Before starting a new iteration, the pheromones need to be updated. Following
    equation 10.2 and assuming that the evaporation rate ρ is 0.7, the new pheromone
    value will be
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新的迭代之前，需要更新信息素。根据方程10.2并假设蒸发率 ρ 为0.7，新的信息素值将是
- en: '|'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F09_Khamis-EQ09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F09_Khamis-EQ09.png)'
- en: '| 10.9 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 10.9 |'
- en: Pheromones are also deposited. If the first ant *k* = 1 is selected to deposit
    pheromones based on the costs of the paths found by each ant, it enforces the
    edges {1,3), {3,4}, and {4,5} with the value *Q*/*L*¹ = 1/11 following the online
    delayed pheromone update model. Figure 10.10 shows the updated pheromone values
    on each edge.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 信息素也会被沉积。如果第一只蚂蚁 *k* = 1 根据每只蚂蚁找到的路径的成本来选择沉积信息素，它将根据在线延迟信息素更新模型，以 *Q*/*L*¹ =
    1/11 的值强制执行边 {1,3}、{3,4} 和 {4,5}。图10.10显示了每条边上的更新信息素值。
- en: '![](../Images/CH10_F10_Khamis.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F10_Khamis.png)'
- en: Figure 10.10 Updated pheromone concentrations
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 更新的信息素浓度
- en: In this simple example, over three iterations, the ants find the shortest path
    1 → 3 → 4 → 5. In the following sections, we’ll discuss the ant system (AS) algorithm,
    ant colony system (ACS) algorithm, and max–min ant system (MMAS) algorithm as
    ACO variants proposed to deal with SACO limitations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，经过三次迭代，蚂蚁找到了最短路径 1 → 3 → 4 → 5。在接下来的章节中，我们将讨论蚂蚁系统（AS）算法、蚁群系统（ACS）算法和最大-最小蚂蚁系统（MMAS）算法作为ACO变体，这些算法被提出以处理SACO的限制。
- en: 10.3.2 Ant system
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 蚂蚁系统
- en: The ant system (AS) algorithm improves on SACO by adding a memory capability
    via a tabu list. This list, or ant memory, identifies the already-visited nodes.
    The transition probability used in AS is the same as in equation 10.6\. As an
    ant visits a new node, that node is added to the ant’s tabu list for a predefined
    number of iterations. And as in SACO, after an ant completes a path, the pheromone
    on each edge is updated. The ant density, ant quantity, and ant cycle models can
    be used to update the pheromones. As previously explained, in the ant density
    and ant quantity models, ants deposit pheromones while building, whereas in the
    ant cycle model, ants deposit pheromones after they have built a complete path.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁系统（AS）算法通过添加一个禁忌列表来增加记忆能力，从而改进了SACO算法。这个列表，或者说是蚂蚁的记忆，标识了已经访问过的节点。AS中使用的转移概率与方程10.6中的相同。当蚂蚁访问一个新节点时，该节点会被添加到蚂蚁的禁忌列表中，持续一定数量的迭代。和在SACO中一样，当蚂蚁完成一条路径后，每条边上的信息素都会被更新。蚂蚁密度、蚂蚁数量和蚂蚁循环模型可以用来更新信息素。正如之前解释的，在蚂蚁密度和蚂蚁数量模型中，蚂蚁在构建过程中会沉积信息素，而在蚂蚁循环模型中，蚂蚁在构建完整路径后会沉积信息素。
- en: 10.3.3 Ant colony system
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 蚂蚁群体系统
- en: 'The ant colony system (ACS) algorithm is an extension of the AS algorithm with
    a modified transition rule that utilizes an elitist strategy. This strategy, known
    as the *pseudo-random proportional action rule*, is designed to improve the efficiency
    and effectiveness of the algorithm. The pseudo-random proportional action rule
    used in ACS is based on the idea that the best solutions found by the ants should
    be given more weight in the decision-making process. In ACS, a random number *r*
    is generated, and the parameter *r*[o] ∈ [0,1] is predefined. An ant *k*, located
    at node *i*, selects the next node *j* to move to using the following decision
    rule with a double function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁群体系统（ACS）算法是AS算法的一个扩展，它使用了一个修改过的转移规则，并利用了精英策略。这种策略被称为*伪随机比例行动规则*，旨在提高算法的效率和有效性。ACS中使用的伪随机比例行动规则基于这样的想法：蚂蚁找到的最佳解应该更多地影响决策过程。在ACS中，生成一个随机数
    *r*，参数 *r*[o] ∈ [0,1] 是预定义的。位于节点 *i* 的蚂蚁 *k* 使用以下具有双重功能的决策规则选择下一个要移动到的节点 *j*：
- en: If *r* ≤ *r[o]*, the ant selects node *j*
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *r* ≤ *r[o]*，蚂蚁会选择节点 *j*
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F10_Khamis-EQ10.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F10_Khamis-EQ10.png)'
- en: '| 10.10 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 10.10 |'
- en: 'Else, a node is probabilistically selected (using a roulette wheel method,
    for example, which you learned about in chapter 7) according to the following
    transition probability:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，根据以下转移概率以概率方式选择一个节点（例如，使用在第7章中学到的轮盘赌方法）：
- en: '![](../Images/CH10_F10_Khamis-EQ11.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F10_Khamis-EQ11.png)'
- en: Notice that compared to the transition probability of SACO (equation 10.6),
    the parameter that controls the influence of the pheromone concentration is *α*
    = 1 in ACS. The parameter *r[0]* is used to balance the exploration–exploitation
    trade-off. When *r* ≤ *r*[0], the decision rule exploits the knowledge available
    about the problem by favoring the best edge, and when *r* > *r*[0], the algorithm
    explores. Properly tuning *r[0]* allows us to strike a balance between exploration
    and exploitation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与SACO的转移概率（方程10.6）相比，ACS中控制信息素浓度影响的参数 *α* = 1。参数 *r[0]* 用于平衡探索-利用的权衡。当 *r*
    ≤ *r*[0] 时，决策规则通过优先选择最佳边来利用关于问题的现有知识，而当 *r* > *r*[0] 时，算法进行探索。适当地调整 *r[0]* 可以在探索和利用之间取得平衡。
- en: In the previous shortest path example, assume that the ant is at node 4 and
    needs to choose node 2 or 5 following the ACS decision rule (figure 10.11). Let’s
    assume that we have the values *r[o]* = 0.5, *β* = 1, and *η[ij]* = 1 / *d[ij]*.
    Let’s now generate a random number *r*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 shortest path 示例中，假设蚂蚁位于节点4，需要根据ACS决策规则（图10.11）选择节点2或5。假设我们有 *r[o]* = 0.5,
    *β* = 1, 和 *η[ij]* = 1 / *d[ij]*。现在让我们生成一个随机数 *r*。
- en: If *r* ≤ *r[o]*, the ant will select node
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *r* ≤ *r[o]*，蚂蚁将选择节点
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F10_Khamis-EQ12.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F10_Khamis-EQ12.png)'
- en: '| 10.11 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 10.11 |'
- en: 'If *r* > *r[o]*, the ant will select a node with maximum transition probability:
    *p*[45]¹ = 0.6 and *p*[42]¹ = 0.4 as calculated before in section 10.3.1 with
    *α* = 1. Using the roulette wheel method, node 2 or node 5 may be selected.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *r* > *r[o]*，蚂蚁将选择具有最大转移概率的节点：*p*[45]¹ = 0.6 和 *p*[42]¹ = 0.4，如之前在10.3.1节中计算，*α*
    = 1。使用轮盘赌方法，节点2或节点5可能被选中。
- en: '![](../Images/CH10_F11_Khamis.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F11_Khamis.png)'
- en: Figure 10.11 The ant at node 4 selects the next node (2 or 5) following the
    ACS elitist strategy.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 蚂蚁在节点4根据ACS精英策略选择下一个节点（2或5）。
- en: Unlike in AS, the pheromone reinforcement process in ACS is exclusively performed
    by the ant with the global-best solution, which corresponds to the best path found
    so far. However, relying solely on the global-best solution to dictate pheromone
    deposition may cause the search to converge too rapidly around the global-best
    solution to date, hindering exploration of other potentially better solutions.
    The max–min ant system (MMAS) algorithm was developed to address this issue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与AS不同，ACS中的信息素强化过程仅由具有全局最佳解的蚂蚁执行，这对应于迄今为止找到的最佳路径。然而，仅依靠全局最佳解来指导信息素沉积可能会导致搜索过于迅速地收敛到迄今为止的全局最佳解，阻碍了对其他潜在更好解决方案的探索。为了解决这个问题，开发了最大-最小蚁群系统（MMAS）算法。
- en: 10.3.4 Max–min ant system
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 最大-最小蚁群系统
- en: ACS can experience premature stagnation, which occurs when all ants follow the
    same path and little exploration is done. This issue is especially prevalent in
    complex problems, where the search space is large and the optimal solution is
    difficult to find. To overcome this problem, the max–min ant system (MMAS) was
    proposed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ACS可能会遇到过早停滞的问题，这发生在所有蚂蚁都遵循相同路径且探索很少的情况下。这个问题在复杂问题中尤为普遍，其中搜索空间很大，最优解难以找到。为了克服这个问题，提出了最大-最小蚁群系统（MMAS）。
- en: MMAS employs the iteration-best path instead of the global-best path for pheromone
    updates. Pheromone trails are only updated using the online delayed pheromone
    update model, where the edges that were traversed by the best ant in the current
    iteration receive additional pheromones. Since the best paths can vary significantly
    between iterations, this approach promotes a higher degree of exploration throughout
    the search space compared to ACS. Hybrid strategies can also be implemented, in
    which the iteration-best path is primarily utilized to encourage exploration,
    while the global-best path is incorporated periodically.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MMAS使用迭代最佳路径而不是全局最佳路径来更新信息素。信息素路径仅使用在线延迟信息素更新模型进行更新，其中当前迭代中最佳蚂蚁所经过的边会接收额外的信息素。由于最佳路径在迭代之间可能差异很大，这种方法与ACS相比，在整个搜索空间中促进了更高程度的探索。也可以实现混合策略，其中迭代最佳路径主要用于鼓励探索，而全局最佳路径则定期纳入。
- en: In MMAS, the pheromone concentrations are constrained within an upper bound
    (*τ[max]*) and lower bound (*τ[min]*), ensuring that the search remains focused
    yet flexible. The pheromone trails are initialized to their maximum value *τ[max]*,
    and if the algorithm reaches a stagnation point, all pheromone concentrations
    are reset to the maximum value. Following this reset, the iteration-best path
    is exclusively used for a limited number of iterations. The values for *τ[min]*
    and *τ[max]* are typically determined through experimentation, although they could
    also be computed analytically if the optimal solution is known.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在MMAS中，信息素浓度被限制在上下界(*τ[max]*)和(*τ[min]*)之间，确保搜索既保持专注又具有灵活性。信息素路径被初始化为最大值*τ[max]*，如果算法达到停滞点，所有信息素浓度将被重置为最大值。在此重置之后，仅使用迭代最佳路径进行有限的迭代次数。*τ[min]*和*τ[max]*的值通常通过实验确定，尽管如果已知最优解，它们也可以通过解析计算得出。
- en: 10.3.5 Solving open TSP with ACO
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 使用ACO解决开放TSP问题
- en: Let’s now implement the ACO algorithm to solve open TSP, considering the 20
    major US cities. Our objective is to find the shortest route that a salesperson
    can follow to visit each of these 20 cities once, starting from New York City
    and without returning to the home city.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现ACO算法来解决开放TSP问题，考虑20个主要美国城市。我们的目标是找到销售人员可以遵循的最短路线，以访问这20个城市中的每一个，从纽约市出发，且不返回到家乡城市。
- en: We’ll start by defining a `cities` dictionary that contains the names of the
    20 US cities and their latitude and longitude coordinates. We’ll then use a nested
    loop to calculate the distance between each pair of cities using the `haversine`
    distance formula, storing the results in the `distance_matrix` dictionary. The
    `haversine` distance is used because it takes into account the earth’s curvature,
    providing accurate distance measurements between two points on the earth’s surface
    (see the “Haversine distance” sidebar in section 4.3.3 for more details). The
    `cost_function` is defined to calculate the total distance of a path. It takes
    a list of city indices (`path`) and a distance matrix (`distances`) as input arguments.
    The function then iterates through the path, summing the distance between each
    consecutive pair of cities. The total path distance is then returned. This code
    is shown in the next listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个包含20个美国城市名称及其纬度和经度坐标的`cities`字典。然后，我们将使用嵌套循环计算每对城市之间的距离，使用`haversine`距离公式，并将结果存储在`distance_matrix`字典中。`haversine`距离被使用，因为它考虑了地球的曲率，提供了地球表面上两点之间准确的距离测量（有关更多详细信息，请参阅第4.3.3节中的“Haversine距离”侧边栏）。`cost_function`被定义为计算路径的总距离。它接受城市索引列表（`path`）和距离矩阵（`distances`）作为输入参数。然后函数遍历路径，计算每对连续城市之间的距离。然后返回总路径距离。此代码在下一列表中展示。
- en: Listing 10.1 Solving shortest path problem using ACO
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 使用ACO解决最短路径问题
- en: '[PRE0]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Define latitude and longitude for 20 major US cities.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义20个主要美国城市的纬度和经度。
- en: ② Create a haversine distance matrix based on latitude and longitude coordinates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ② 基于纬度和经度坐标创建一个哈夫曼距离矩阵。
- en: ③ Inter-city values
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 城市间值
- en: ④ City names
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 城市名称
- en: ⑤ Define the cost function that represents the path length.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义表示路径长度的成本函数。
- en: 'As a continuation of listing 10.1, the next code snippet presents a function
    called `ant_tour` that takes two arguments: `pheromones`, representing the pheromone
    levels between cities, and `distances`, representing the distances between cities.
    It initializes a `paths` array to store paths for each ant, and it iterates over
    each ant in the specified range of ants. For each ant, it initializes a path starting
    from New York City. It enters a `while` loop that continues until all cities are
    visited. Within the `while` loop, it selects the current city as the last city
    in the path. It then calculates the probabilities for choosing the next city based
    on the pheromone levels and the inverse of the distances between the current city
    and unvisited cities. The probabilities are calculated using equation 10.6\. The
    next city is chosen using the `random.choices` function, based on the normalized
    probabilities. The chosen next city is removed from the list of unvisited cities,
    and it is appended to the path:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表10.1的延续，接下来的代码片段展示了一个名为`ant_tour`的函数，它接受两个参数：`pheromones`，表示城市间的信息素水平，以及`distances`，表示城市间的距离。它初始化一个`paths`数组以存储每个蚂蚁的路径，并遍历指定的蚂蚁范围。对于每个蚂蚁，它从纽约市开始初始化一个路径。它进入一个`while`循环，直到所有城市都被访问。在`while`循环中，它将当前城市作为路径中的最后一个城市。然后，它根据信息素水平和当前城市与未访问城市之间的距离的倒数计算选择下一个城市的概率。概率使用方程10.6计算。下一个城市使用基于归一化概率的`random.choices`函数选择。选定的下一个城市将从未访问城市列表中移除，并将其追加到路径中：
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Initialize an array to store paths for each ant.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化一个数组以存储每个蚂蚁的路径。
- en: ② Start each ant's path from New York City.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从纽约市开始每个蚂蚁的路径。
- en: ③ Initialize a set of unvisited cities.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 初始化一组未访问城市。
- en: ④ Remove New York City from unvisited cities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 从未访问城市中移除纽约市。
- en: ⑤ Continue building the path until all cities are visited.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 继续构建路径，直到所有城市都被访问。
- en: ⑥ Calculate the probabilities for moving to each unvisited city.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 计算移动到每个未访问城市的概率。
- en: ⑦ Normalize the probabilities.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 归一化概率。
- en: ⑧ Choose the next city based on probabilities.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 根据概率选择下一个城市。
- en: ⑨ Remove the chosen city from the set of unvisited cities.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 从未访问城市集合中移除选定的城市。
- en: ⑩ Add the chosen city to the path.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 将选定的城市添加到路径中。
- en: ⑪ Store the completed path for the current ant.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 为当前蚂蚁存储完成路径。
- en: Once all the cities have been visited, the path for the current ant is stored
    in the `paths` array. After all the ants have completed their paths, the function
    returns the `paths` array containing the optimal tours found by each ant.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有城市都被访问过，当前蚂蚁的路径将被存储在`paths`数组中。当所有蚂蚁完成它们的路径后，函数返回包含每个蚂蚁找到的最优路线的`paths`数组。
- en: 'The following `update_pheromones` function is used to update the pheromone
    levels based on the distances and paths of the ants:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`update_pheromones`函数用于根据蚂蚁的距离和路径更新信息素水平：
- en: '[PRE2]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Initialize a matrix to store the changes in pheromone levels.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化一个矩阵以存储信息素水平的变化。
- en: ② Update pheromones based on the paths taken by the ants.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ② 根据蚂蚁走过的路径更新信息素。
- en: ③ Get the indices of the cities in the current path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 获取当前路径中城市的索引。
- en: ④ Update the pheromone level between the current and next city.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 更新当前城市和下一个城市之间的信息素水平。
- en: ⑤ Evaporate existing pheromones, add the changes in pheromones, and return the
    updated pheromones.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 蒸发现有信息素，添加信息素的变化，并返回更新后的信息素。
- en: 'This function takes two arguments: `paths`, representing the paths taken by
    ants, and `pheromones`, representing the current pheromone levels on edges between
    cities. It initializes a matrix `delta_pheromones` to store the changes in pheromone
    levels. This matrix has the same shape as the `pheromones` matrix. It iterates
    over each ant in the specified range of ants. Within the loop, it iterates over
    each city in the ant''s path (except the last city). For each pair of consecutive
    cities, it updates the `delta_pheromones` matrix by adding a value based on the
    inverse of the cost of the ant''s path. After the inner loop, it calculates the
    updated pheromones by combining the existing pheromones, considering evaporation,
    and adding the changes stored in `delta_pheromones`. Finally, it returns the matrix
    of updated pheromones.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个参数：`paths`，表示蚂蚁走过的路径，以及`pheromones`，表示城市之间边上的当前信息素水平。它初始化一个名为`delta_pheromones`的矩阵来存储信息素水平的变化。此矩阵的形状与`pheromones`矩阵相同。它遍历指定范围内的每个蚂蚁。在循环内部，它遍历蚂蚁路径中的每个城市（除了最后一个城市）。对于每对连续城市，它通过添加基于蚂蚁路径成本的倒数来更新`delta_pheromones`矩阵。在内循环之后，它通过结合现有信息素、考虑蒸发并添加存储在`delta_pheromones`中的变化来计算更新的信息素。最后，它返回更新后的信息素矩阵。
- en: 'As a continuation, the following code snippet shows the `run_ACO` function,
    which takes the following inputs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为延续，以下代码片段显示了`run_ACO`函数，它接受以下输入：
- en: '`distances`—A 2D array (matrix) that stores the distances between cities'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distances`—一个二维数组（矩阵），存储城市之间的距离'
- en: '`ants`—The number of ants to use in the algorithm'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ants`—算法中使用的蚂蚁数量'
- en: '`iterations`—The number of iterations'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterations`—迭代次数'
- en: '`alpha`—A parameter that controls the influence of the pheromone trail on the
    ant’s decision'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`—一个参数，用于控制信息素轨迹对蚂蚁决策的影响'
- en: '`beta`—A parameter that controls the influence of the distance to the next
    city on the ant’s decision'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beta`—一个参数，用于控制下一个城市距离对蚂蚁决策的影响'
- en: '`evaporation_rate`—The rate at which pheromones evaporate from the paths'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaporation_rate`—信息素从路径中蒸发的速率'
- en: '`Q`—A constant used in the calculation of the amount of pheromones deposited
    by the ants'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q`—在计算蚂蚁沉积信息素量时使用的常数'
- en: 'This function returns the `best_path` and `best_distance`, representing the
    optimal solution found by the ACO algorithm:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回`best_path`和`best_distance`，代表蚁群优化算法找到的最优解：
- en: '[PRE3]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Initialize the pheromones array.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化信息素数组。
- en: ② Generate paths for each ant.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为每个蚂蚁生成路径。
- en: ③ Calculate the total distance for each path.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 计算每条路径的总距离。
- en: ④ Find the index of the path with the minimum distance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 找到距离最短的路径索引。
- en: ⑤ Update the pheromones.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 更新信息素。
- en: ⑥ Return the best path and distance found during the iterations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 返回迭代过程中找到的最佳路径和距离。
- en: 'Let’s now apply ACO to solve the shortest path problem using the following
    parameters:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下参数将蚁群优化算法（ACO）应用于解决最短路径问题：
- en: '[PRE4]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Set ACO parameters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置ACO参数。
- en: ② Run ACO with the defined parameters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用定义的参数运行蚁群优化算法（ACO）。
- en: 'Given the randomness included in the algorithm, your solution may vary. The
    following path is what was generated when I ran the solver:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法中包含随机性，您的解决方案可能会有所不同。以下路径是在我运行求解器时生成的：
- en: '[PRE5]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding path is shown in figure 10.12\. The complete version of listing
    10.1 is available in the book’s GitHub repo, which also contains the code to generate
    this visualization.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的路径在图10.12中显示。列表10.1的完整版本可在本书的GitHub仓库中找到，其中还包含生成此可视化的代码。
- en: '![](../Images/CH10_F12_Khamis.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F12_Khamis.png)'
- en: Figure 10.12 Shortest path obtained by ACO
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 蚁群优化算法获得的最短路径
- en: 'Unlike genetic algorithms and particle swarm optimization algorithms, there
    are no well-developed and comprehensive Python packages for ACO metaheuristics.
    The ACOpy project (https://acopy.readthedocs.io/en/latest/index.html) provides
    an implementation of ACO and can be installed using pip as follows: `pip install
    acopy`. As a continuation of listing 10.1, let’s use ACOpy to solve the shortest
    path problem.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与遗传算法和粒子群优化算法不同，ACO元启发式算法没有成熟和全面的Python包。ACOpy项目（https://acopy.readthedocs.io/en/latest/index.html）提供了一个ACO的实现，可以使用pip安装，如下所示：`pip
    install acopy`。作为列表10.1的延续，让我们使用ACOpy来解决最短路径问题。
- en: 'We’ll start by importing the `acopy` and `networkx` libraries. A graph, `G`,
    is created where the nodes represent cities and the edges represent the distances
    between them. The `distance_matrix` contains the distances between each pair of
    cities. The loops iterate over all pairs of cities, adding an edge between each
    pair of cities to the graph, with the weight of the edge being the distance between
    the cities. Self-loop edges (edges that connect a node to itself) are then removed
    from the graph:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`acopy`和`networkx`库。创建一个图`G`，其中节点代表城市，边代表它们之间的距离。`distance_matrix`包含每对城市之间的距离。循环遍历所有城市对，在图中为每对城市添加一条边，边的权重是城市之间的距离。然后从图中删除自环边（连接节点到自身的边）：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The parameters for the ACO algorithm are then defined: `evaporation_rate`,
    `iterations`, and `Q`, as explained previously. An ACO solver is created with
    the specified `evaporation_rate` and `Q`. The `acopy.Colony` object is initialized
    with `alpha` and `beta` parameters. The algorithm then iterates for the specified
    number of iterations. In each iteration, the solver’s `solve` method is used to
    find a tour whose path is a list of edges. For each edge in the path, the code
    determines the city that hasn’t been added to the `path_indices` list yet and
    adds it. Finally, the path of the tour is updated to be the `path_indices` list,
    which is a list of city names instead of edges:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义ACO算法的参数：`evaporation_rate`（蒸发率）、`iterations`（迭代次数）和`Q`，如前所述。创建一个具有指定`evaporation_rate`和`Q`的ACO求解器。使用`alpha`和`beta`参数初始化`acopy.Colony`对象。然后算法按照指定的迭代次数进行迭代。在每次迭代中，使用求解器的`solve`方法找到一个路径，该路径是一个边的列表。对于路径中的每条边，代码确定尚未添加到`path_indices`列表中的城市，并将其添加进去。最后，将旅行路径更新为`path_indices`列表，该列表是城市名称的列表，而不是边的列表：
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① ACO parameters
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ① ACO参数
- en: ② Set up the ACO solver.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置ACO求解器。
- en: ③ Set up the ACO colony with alpha and beta parameters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用alpha和beta参数设置ACO群体。
- en: ④ Run the ACO algorithm.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 运行ACO算法。
- en: ⑤ Start with city 0 (New York City).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 从城市0（纽约市）开始。
- en: ⑥ Add the other node from the edge that is not already in the path.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 添加路径中尚未包含的边的另一个节点。
- en: ⑦ Return the ordered list of city names included in the path.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 返回包含在路径中的城市名称的有序列表。
- en: 'Let’s now print the obtained path and its length as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们按照以下方式打印出获得路径及其长度：
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `best_path` variable is set to the `path` property of the `tour` object
    obtained by the `acopy` solver. This path is a list of cities that represents
    the shortest route found. The `best_distance` variable is set to the `cost` property
    of the `tour` object, which is the total distance (or cost) of the best path.
    The `Route` variable is a string that joins all the cities in `best_path` with
    an arrow (`→`) in between, representing the sequence of cities to visit in the
    optimal tour. Finally, the `print` statements display the best route and its total
    distance. A path like the following will be generated after running the solver:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`best_path`变量被设置为通过`acopy`求解器获得的`tour`对象的`path`属性。这条路径代表找到的最短路线的城市列表。`best_distance`变量被设置为`tour`对象的`cost`属性，即最佳路径的总距离（或成本）。`Route`变量是一个字符串，它将`best_path`中的所有城市通过箭头（`→`）连接起来，表示在最佳旅行中的访问城市顺序。最后，`print`语句显示最佳路线及其总距离。在运行求解器后，将生成如下路径：'
- en: '[PRE9]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The obtained path is shown in figure 10.13\. The complete version of listing
    10.1 available in the book’s GitHub repo contains the code to generate this visualization.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的路径如图10.13所示。书中GitHub仓库中可用的列表10.1的完整版本包含生成此可视化的代码。
- en: '![](../Images/CH10_F13_Khamis.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F13_Khamis.png)'
- en: Figure 10.13 Shortest path obtained by ACOpy
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 ACOpy获得的最短路径
- en: 'It’s worth mentioning that ACO, like many other stochastic optimization algorithms,
    contains elements of randomness. The randomness in ACO comes from two main sources:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，ACO（蚁群优化算法）与其他许多随机优化算法一样，包含随机性元素。ACO中的随机性主要来源于两个方面：
- en: '*Initial conditions*—At the start of the algorithm, the ants are usually placed
    at random positions unless the start position is predefined, such as in the case
    of TSP where ants start from a predetermined home city. This means that in scenarios
    where random positions are used, each ant starts exploring from a different city,
    leading to diverse paths.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始条件*——在算法开始时，蚂蚁通常被放置在随机位置，除非起始位置是预定义的，例如在TSP的情况下，蚂蚁从预定的家乡城市开始。这意味着在随机位置被使用的情况下，每只蚂蚁都会从不同的城市开始探索，导致路径的多样性。'
- en: '*Path selection*—As the ants move from city to city, they probabilistically
    choose which city to visit next. This choice is influenced by the amount of pheromones
    on the path to a city and the distance to the city. Even if two ants are in the
    same city and have the same information, they might still choose different cities
    to visit next due to this probabilistic choice.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路径选择*——随着蚂蚁从一个城市移动到另一个城市，它们会概率性地选择下一个要访问的城市。这个选择受到通往城市路径上信息素的量和城市距离的影响。即使两只蚂蚁在同一城市并且拥有相同的信息，它们也可能因为这种概率性选择而选择不同的城市进行访问。 '
- en: This inherent randomness means that each run of the ACO algorithm can produce
    different results. However, over multiple runs, ACO should consistently find near-optimal
    solutions, even if they are not always the exact same solution.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种固有的随机性意味着ACO算法的每次运行都可以产生不同的结果。然而，在多次运行中，ACO应该始终找到近似最优解，即使它们并不总是完全相同的解。
- en: In the following section, we will delve into another fascinating algorithm that
    is a product of swarm intelligence. This algorithm again takes its inspiration
    from the natural world, specifically the food-seeking behavior of honeybees. You’ll
    soon understand how this bee-inspired algorithm operates and how it can be applied
    in a computational context.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨另一个由群体智能产生的迷人算法。这个算法再次从自然界中汲取灵感，特别是蜜蜂寻找食物的行为。你很快就会了解这个受蜜蜂启发的算法是如何运作的，以及它如何在计算环境中得到应用。
- en: 10.4 From hive to optimization
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 从蜂巢到优化
- en: Honeybees are remarkable social insects known for their extraordinary cooperation.
    They build hives capable of accommodating approximately 30,000 bees, all working
    together harmoniously. Each bee has a designated task, such as producing wax,
    creating honey, making bee-bread, forming combs, or bringing water to the cells
    and mixing it with honey. Young bees typically handle tasks outside the hive,
    while elder bees focus on indoor duties.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 蜜蜂是著名的社交昆虫，以其非凡的合作而闻名。它们建造的蜂巢可以容纳大约30,000只蜜蜂，所有蜜蜂和谐共处。每只蜜蜂都有指定的任务，例如生产蜂蜡、制作蜂蜜、制作蜂粮、形成蜂房或把水带到蜂房并与蜂蜜混合。年轻的蜜蜂通常处理蜂巢外的任务，而年老的蜜蜂则专注于室内工作。
- en: Honeybee colonies operate as goal-oriented decision-making systems, with their
    functions directed by the decentralized control and actions of individual bees.
    The cooperation between honeybees during the foraging process leads to advantageous
    behaviors that optimize the hive’s overall fitness. By using individual foragers,
    honeybee colonies aim to minimize the cost/benefit ratio, rather than expending
    energy searching in all directions indiscriminately. They concentrate their foraging
    efforts on the most rewarding patches, while disregarding those of lesser quality.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 蜜蜂群体作为目标导向的决策系统运作，其功能由单个蜜蜂的分散控制和行动所指导。在觅食过程中，蜜蜂之间的合作产生了有利于蜂巢整体适应性的行为。通过使用单个觅食者，蜜蜂群体旨在最小化成本/收益比，而不是无差别地在所有方向上消耗能量进行搜索。他们将觅食努力集中在最有回报的区域，而忽略那些质量较差的区域。
- en: Observations have shown that when colony food resources are scarce, foragers
    exhibit increased recruitment behaviors, characterized by changes in their dance
    patterns upon returning to the hive. This enhanced recruitment serves to mobilize
    more nestmates to exploit available food sources. In addition to foraging, honeybees
    also cooperate in various other tasks, such as hive construction, hive thermoregulation,
    and colony defense, showcasing their exceptional teamwork skills.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 观察表明，当蜂群食物资源稀缺时，觅食者会表现出增加招募行为的特征，这表现在它们返回蜂巢后舞蹈模式的变化。这种增强的招募有助于动员更多的巢居者去利用可用的食物来源。除了觅食外，蜜蜂还参与各种其他任务，如蜂巢建设、蜂巢温度调节和蜂群防御，展示了它们非凡的团队合作技能。
- en: Discover the fascinating world of honeybees
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 探索蜜蜂的迷人世界
- en: Honeybees are the most well-known and important insects that produce food consumed
    by humans.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜜蜂是人们最熟知且最重要的生产人类食用食物的昆虫。
- en: Honeybee colonies consist of a single queen, hundreds of male drones, and 20,000
    to 80,000 female worker bees.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜜蜂群体由一只蜂王、数百只雄性工蜂和20,000到80,000只雌性工蜂组成。
- en: A single worker bee may visit 50 to 1,000 flowers per day. Bees from the same
    hive can visit up to 225,000 flowers in one day. Honeybees can fly at speeds of
    21 to 28 km/h (13–17 mph) and can have a foraging area up to 70 km² (27 mi²).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个工蜂每天可能访问50到1,000朵花。同一蜂巢的蜜蜂一天内可以访问多达225,000朵花。蜜蜂可以以21到28公里/小时（13-17英里/小时）的速度飞行，觅食区域可达70平方公里（27平方英里）。
- en: Honeybees can maintain a constant temperature of about 33°C (91°F) in their
    hive, regardless of the outside temperature.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜜蜂可以在蜂巢中维持大约33°C（91°F）的恒定温度，无论外界温度如何。
- en: Honeybees choose the hexagonal shape for their honeycomb cells to hold the queen
    bee’s eggs and store the pollen and honey the worker bees bring to the hive.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜜蜂选择六角形形状来建造蜂巢，以存放蜂王的卵和储存工蜂带到蜂巢的花粉和蜂蜜。
- en: The hexagonal structure has several advantages, such as efficient use of space
    (creating the maximum number of cells that can be built in a given area), structural
    strength (it’s strong and stable), material efficiency (it uses less beeswax),
    and optimal angle (a slight tilt, ~13 degrees from horizontal, to prevent honey
    from spilling out of the cells while still allowing bees to move around easily).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六角形结构有几个优点，例如空间利用效率高（在给定区域内能建造的最大数量的蜂房），结构强度大（坚固且稳定），材料效率高（使用较少的蜂蜡），以及最佳角度（略微倾斜，大约13度从水平线，以防止蜂蜜从蜂房中溢出，同时允许蜜蜂轻松移动）。
- en: Honeybees communicate with each other through complex dance moves called “waggle
    dances,” explained in “The Waggle Dance of the Honeybee,” a video from Georgia
    Tech College of Computing ([http://mng.bz/gvxx](http://mng.bz/gvxx)).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜜蜂通过复杂的舞蹈动作“摇摆舞”相互沟通，这在乔治亚理工学院计算机学院的视频《蜜蜂的摇摆舞》（[http://mng.bz/gvxx](http://mng.bz/gvxx)）中有解释。
- en: The artificial bee colony (ABC) algorithm is a swarm intelligence algorithm
    based on the foraging behavior of honeybees. Specifically, it is inspired by the
    way honeybees search for food sources and communicate their findings to optimize
    the gathering of resources. Let’s first look at how honeybees forage for food.
    Figure 10.14 illustrates the steps of their foraging behavior.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 人工蜂群（ABC）算法是一种基于蜜蜂觅食行为的群体智能算法。具体来说，它受到蜜蜂寻找食物来源和将发现传达给其他蜜蜂以优化资源收集方式的影响。让我们首先看看蜜蜂是如何觅食食物的。图10.14展示了它们觅食行为的步骤。
- en: '![](../Images/CH10_F14_Khamis.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F14_Khamis.png)'
- en: Figure 10.14 Foraging behavior of honeybees
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 蜜蜂的觅食行为
- en: 'The foraging behavior can be summarized in the following steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 觅食行为可以总结为以下步骤：
- en: '*Initialization*—Forager bees (employed bees) and scout bees begin their foraging
    for food sources. Forager bees usually gather resources from known sources around
    the hive to meet the colony’s immediate needs. Scout bees locate new food sources
    to ensure the colony’s long-term survival, especially if the food sources around
    the hive start to deplete. Scout bees only represent a small percentage of colony
    members, but they save the colony many wasted miles of flight trying to locate
    abundant new food sources. It is worth noting that forager bees and scout bees
    are both worker bees (female bees). A worker bee can switch roles from being a
    forager to a scout, depending on the colony’s needs and food source availability.
    In summary, forager bees concentrate on exploiting the available resources while
    scout bees focus on exploring to discover new resources.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*初始化*——觅食蜂（被雇佣的蜂）和侦察蜂开始寻找食物来源。觅食蜂通常从蜂巢周围的已知来源收集资源以满足蜂群的即时需求。侦察蜂定位新的食物来源以确保蜂群的长期生存，特别是如果蜂巢周围的食物来源开始枯竭。侦察蜂只占蜂群成员的一小部分，但它们为蜂群节省了许多寻找丰富新食物来源的飞行距离。值得注意的是，觅食蜂和侦察蜂都是工蜂（雌蜂）。根据蜂群的需求和食物来源的可用性，工蜂可以从觅食蜂转变为侦察蜂。总之，觅食蜂专注于利用现有资源，而侦察蜂则专注于探索以发现新资源。'
- en: '*Exploration*—Forager bees leave the hive and start searching for food sources,
    such as flowers with nectar and pollen, in the surrounding area. Scout bees explore
    areas farther away to discover new food sources.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*探索*——觅食蜂离开蜂巢开始寻找食物来源，如周围的花朵中的花蜜和花粉。侦察蜂探索更远的地方以发现新的食物来源。'
- en: '*Detection*—When a suitable food source is found, the worker bee lands on the
    flower and begins to collect nectar in her honey stomach or gathers pollen on
    her hind legs.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*检测*—当找到合适食物来源时，工蜂降落在花朵上，并开始在她的蜜胃中收集花蜜或在她的后腿上收集花粉。'
- en: '*Memorization*—The bee takes note of the food source’s location, including
    its distance and direction from the hive, as well as the flower type and quality.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*记忆*—蜜蜂会注意食物来源的位置，包括其与蜂巢的距离和方向，以及花朵的类型和质量。'
- en: '*Return to the hive*—Once the worker bee has collected enough resources or
    her honey stomach is full, she flies back to the hive. Upon reaching the hive,
    the forager bee transfers the nectar to a house bee, who then processes and stores
    it as honey. Pollen is similarly offloaded to other bees for storage and later
    use as food.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*返回蜂巢*—一旦工蜂收集了足够的资源或她的蜜胃已满，她就会飞回蜂巢。到达蜂巢后，觅食蜂将花蜜转移到巢蜂，然后巢蜂对其进行处理并储存为蜂蜜。花粉也会类似地卸载到其他蜜蜂，以储存并作为食物在以后使用。'
- en: '*Communication*—The worker bee performs a waggle dance on the hive’s dance
    floor to share the location information with her nestmates (aka *onlooker bees*).
    The dance communicates the direction, distance, and quality of the food source.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*沟通*—工蜂在蜂巢的舞蹈地板上跳摇摆舞，与她的巢伴（即*旁观蜂*）分享位置信息。这种舞蹈传达了食物来源的方向、距离和质量。'
- en: '*Recruitment*—Onlooker bees observe the waggle dance and decode the information
    about the food source’s location. These bees then fly out to collect the resources.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*招募*—旁观蜂观察摇摆舞并解码关于食物来源位置的信息。然后这些蜜蜂飞出去收集资源。'
- en: '*Repeat*—The worker bee continues to visit the same food source until it is
    depleted or another bee recruits her to a more promising source. In either case,
    she repeats the foraging process to ensure the colony’s needs are met.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*重复*—工蜂会继续访问同一个食物来源，直到其耗尽或另一只蜜蜂将她招募到更有希望的食物来源。在两种情况下，她都会重复觅食过程，以确保满足蜂群的需求。'
- en: Now let’s look at the ABC algorithm in more detail.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地看看ABC算法。
- en: 10.5 Exploring the artificial bee colony algorithm
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 探索人工蜂群算法
- en: 'The artificial bee colony (ABC) algorithm, proposed by Dervis Karaboga in 2005
    [1], simulates the roles of three types of bees: employed bees (foragers), onlooker
    bees, and scout bees. Algorithm 10.1 shows the steps of the ABC algorithm.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 人工蜂群（ABC）算法是由Dervis Karaboga于2005年[1]提出的，它模拟了三种蜜蜂的角色：雇佣蜂（觅食者）、旁观蜂和侦察蜂。算法10.1展示了ABC算法的步骤。
- en: Algorithm 10.1 Artificial bee colony algorithm
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 算法10.1 人工蜂群算法
- en: '[PRE10]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the ABC algorithm simulates the honeybee foraging behaviors
    to explore and exploit the search space, balancing global exploration (diversity)
    and local exploitation (convergence) to efficiently solve optimization problems.
    In the ABC algorithm, the three types of bees have the following complementary
    roles:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，ABC算法模拟了蜜蜂的觅食行为来探索和利用搜索空间，平衡全局探索（多样性）和局部利用（收敛），以有效地解决优化问题。在ABC算法中，三种类型的蜜蜂具有以下互补的角色：
- en: '*Employed bees (foragers)—*These bees exploit the current food sources, meaning
    they search around their current position (searching the neighborhood) to find
    better solutions. These bees perform a local search (intensification), which refines
    the current best solutions.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*雇佣蜂（觅食者）—*这些蜜蜂利用当前的食物来源，这意味着它们在其当前位置周围搜索（搜索邻域）以找到更好的解决方案。这些蜜蜂执行局部搜索（强化），以细化当前的最佳解决方案。'
- en: '*Onlooker bees*—These bees also contribute to exploitation. They probabilistically
    choose food sources depending on the fitness of the solutions found by the employed
    bees. They are more likely to choose better solutions (food sources with more
    nectar) for further exploitation.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旁观蜂*—这些蜜蜂也参与了利用。它们根据雇佣蜂找到的解决方案的适应性概率选择食物来源。它们更有可能选择更好的解决方案（含有更多花蜜的食物来源）以进行进一步的利用。'
- en: '*Scout bees*—These bees perform the exploration. If a food source is exhausted
    (if the solution cannot be improved after a certain number of iterations), the
    employed bee associated with that food source becomes a scout bee. Scout bees
    perform a global search (diversification) by abandoning the exhausted food source
    and randomly searching for new food sources in the problem space. This process
    prevents the algorithm from getting stuck in local optima by exploring new regions
    of the search space.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*侦察蜂*—这些蜜蜂执行探索任务。如果一个食物源耗尽（如果在一定数量的迭代后无法改进解决方案），与该食物源相关的工蜂就会变成侦察蜂。侦察蜂通过放弃耗尽的食物源并在问题空间中随机搜索新的食物源来执行全局搜索（多样化）。这个过程通过探索搜索空间的新区域来防止算法陷入局部最优。'
- en: In the ABC algorithm, communication between the bees is simulated by sharing
    the fitness values of solutions among employed and onlooker bees, guiding them
    toward better solutions. The ABC algorithm adopts a fitness-proportionate selection
    process inspired by how bees choose food sources based on their quality. In the
    algorithm, employed bees and onlooker bees select solutions with a probability
    proportional to their fitness, promoting better solutions to be explored more
    frequently.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在ABC算法中，通过在工蜂和观察蜂之间共享解决方案的适应度值来模拟蜜蜂之间的通信，引导它们向更好的解决方案前进。ABC算法采用了一种受蜜蜂根据食物质量选择食物源的方式启发的适应度比例选择过程。在算法中，工蜂和观察蜂以与它们的适应度成比例的概率选择解决方案，从而促进更好的解决方案被更频繁地探索。
- en: 'To understand how we can use ABC to solve optimization problems, let’s consider
    minimizing the Rosenbrock function using ABC. The Rosenbrock function, also referred
    to as the *valley* or *banana function*, is a popular test problem for gradient-based
    optimization algorithms. This function has *n* dimensions and takes the following
    general form:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们如何使用ABC算法来解决优化问题，让我们考虑使用ABC算法最小化Rosenbrock函数。Rosenbrock函数，也称为*山谷*或*香蕉函数*，是梯度优化算法的流行测试问题。该函数具有
    *n* 个维度，具有以下一般形式：
- en: '|'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F14_Khamis-EQ13.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH10_F14_Khamis-EQ13.png)'
- en: '| 10.12 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 10.12 |'
- en: The function is usually evaluated on the hypercube x*[i]* ∈ [–5, 10] for all
    *i* = 1,...,*n*, but the domain may be restricted to x*[i]* ∈ [–2.048, 2.048]
    for all *i* = 1,...,*n*. This function has a global minimum at *f*(*x*^*) = 0.0
    located at (1,...,1).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通常在超立方体 x*[i]* ∈ [–5, 10] 上对所有 *i* = 1,...,*n* 进行评估，但域可能限制为 x*[i]* ∈ [–2.048,
    2.048] 对所有 *i* = 1,...,*n*。该函数的全局最小值位于 *f*(*x*^*) = 0.0，位置在 (1,...,1)。
- en: 'Let’s consider the 2D Rosenbrock function that takes the following form:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下形式的二维Rosenbrock函数：
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F14_Khamis-EQ14.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH10_F14_Khamis-EQ14.png)'
- en: '| 10.13 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 10.13 |'
- en: Figure 10.15 shows the 2D surface of Rosenbrock function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15显示了Rosenbrock函数的二维表面。
- en: '![](../Images/CH10_F15_Khamis.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH10_F15_Khamis.png)'
- en: Figure 10.15 The 2D surface plot of the Rosenbrock function. The dot indicates
    the global minimum of this function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 Rosenbrock函数的二维表面图。点表示该函数的全局最小值。
- en: 'Let’s look at how we can minimize this function using ABC:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用ABC算法来最小化这个函数：
- en: '*Initialization phase*—Let’s assume that we have a swarm of *N* = 6 bees. Each
    bee tries to find a candidate solution, and each solution *i* in the population
    consists of a position vector *X[mi]* = {*x[mi], y[mi]*} where *X[mi]* ∈ [–2.048,
    2.048] and *m* = 1,…,*N*. *X[mi]* represents a potential solution to the optimization
    problem. The position of the employed bees is randomly determined within the boundaries.
    These initial solutions can be generated using the following formula:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化阶段*—假设我们有一群 *N* = 6 只蜜蜂。每只蜜蜂都试图找到一个候选解，种群中的每个解决方案 *i* 由位置向量 *X[mi]* = {*x[mi],
    y[mi]*} 组成，其中 *X[mi]* ∈ [–2.048, 2.048] 且 *m* = 1,…,*N*。*X[mi]* 代表优化问题的潜在解。工蜂的位置在边界内随机确定。这些初始解可以使用以下公式生成：'
- en: '|'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F15_Khamis-EQ15.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH10_F15_Khamis-EQ15.png)'
- en: '| 10.14 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 10.14 |'
- en: where *l[i]* and *u[i]* are the lower and upper bounds of the decision variables.
    Let’s assume the initial positions (represented as (*x, y*)) shown in table 10.1.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *l[i]* 和 *u[i]* 是决策变量的下界和上界。让我们假设初始位置（如表10.1所示）为 (*x, y*)。
- en: Table 10.1 Initial food sources
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 初始食物源
- en: '| Candidate solution *X[m]* | Objective function *f[m](**X[m]**)* |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 候选解 *X[m]* | 目标函数 *f[m](**X[m]**)* |'
- en: '| --- | --- |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *X*[1] = (–1.04,0.11) | 98.56 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| *X*[1] = (–1.04,0.11) | 98.56 |'
- en: '| *X*[2] = (–1.61,–1.98) | 2097.22 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| *X*[2] = (–1.61,–1.98) | 2097.22 |'
- en: '| *X*[3] = (1.82,1.22) | 438.49 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| *X*[3] = (1.82,1.22) | 438.49 |'
- en: '| *X*[4] = (–1.64,1.92) | 66.20 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| *X*[4] = (–1.64,1.92) | 66.20 |'
- en: '| *X*[5] = (0.77,0.04) | 30.62 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| *X*[5] = (0.77,0.04) | 30.62 |'
- en: '| *X*[6] = (–0.66,1.59) | 136.02 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| *X*[6] = (–0.66,1.59) | 136.02 |'
- en: '*Employed bee phase*—In the employed bee phase, each bee generates a new solution
    in the neighborhood of its current solution using the following formula:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*雇用蜂阶段*—在雇用蜂阶段，每只蜂在其当前解的邻域内使用以下公式生成一个新的解：'
- en: '|'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F15_Khamis-EQ16.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F15_Khamis-EQ16.png)'
- en: '| 10.15 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 10.15 |'
- en: where *v[mj]* is the new solution, *x[mi]* is the current solution, *ϕ[mi]*
    is a random number between –1 and 1, and *x[ki]* is a randomly chosen solution
    different from the current solution. Let’s assume that all *ϕ[mi]* are –0.9 for
    simplicity, and for each bee, we choose the solution of bee 1 to calculate the
    new solutions. The best bee, in the initial population (table 10.1), bee 5, can
    also be used. We then calculate the new fitness values shown in table 10.2.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *v[mj]* 是新解，*x[mi]* 是当前解，*ϕ[mi]* 是介于 –1 和 1 之间的随机数，*x[ki]* 是与当前解不同的随机选择的解。为了简化，我们假设所有
    *ϕ[mi]* 都是 –0.9，并且对于每只蜂，我们选择蜂1的解来计算新解。初始种群（表10.1）中的最佳蜂，即蜂5，也可以使用。然后我们计算表10.2中显示的新适应度值。
- en: Table 10.2 New food sources
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2 新食源
- en: '| Candidate solution *X[m]* | Objective function *f[m]*(*X[m]*) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 候选解 *X[m]* | 目标函数 *f[m]*(*X[m]*) |'
- en: '| --- | --- |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *X*[1] = (–1.04,0.11) | 98.56 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| *X*[1] = (–1.04,0.11) | 98.56 |'
- en: '| *X*[2] = (–1.10,–0.10) | 174.02 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| *X*[2] = (–1.10,–0.10) | 174.02 |'
- en: '| *X*[3] = (–0.75,0.22) | 15.15 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| *X*[3] = (–0.75,0.22) | 15.15 |'
- en: '| *X*[4] = (–1.10,0.29) | 88.87 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| *X*[4] = (–1.10,0.29) | 88.87 |'
- en: '| *X*[5] = (–0.86,0.10) | 43.76 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| *X*[5] = (–0.86,0.10) | 43.76 |'
- en: '| *X*[6] = (–1.00,0.26) | 59.66 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| *X*[6] = (–1.00,0.26) | 59.66 |'
- en: '*Onlooker bee phase*—The onlooker bees observe the dance of the employed bees
    and choose a food source depending on the nectar amount (the *fitness value*).
    If the new solution has a better fitness value, it is remembered as a global variable,
    and the position is updated. Otherwise, the old position is retained. The probability
    value *p[m]*, with which *X[m]* is chosen by an onlooker bee, can be calculated
    by using the following formula:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*观察蜂阶段*—观察蜂观察雇用蜂的舞蹈，并根据花蜜量（*适应度值*）选择食源。如果新解有更好的适应度值，它将被记住作为全局变量，并更新位置。否则，保留旧位置。观察蜂选择
    *X[m]* 的概率值 *p[m]* 可以通过以下公式计算：'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F15_Khamis-EQ17.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F15_Khamis-EQ17.png)'
- en: '| 10.16 |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 10.16 |'
- en: 'where *fit[m]*(*X[m]*) is the fitness value of the solution, which can be calculated
    using the following expression:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *fit[m]*(*X[m]*) 是解的适应度值，可以使用以下表达式计算：
- en: '|'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH10_F15_Khamis-EQ18.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F15_Khamis-EQ18.png)'
- en: '| 10.17 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 10.17 |'
- en: where *f[m]*(*X[m]*) is the objective function of solution *X[m]*. Table 10.3
    shows the solution fitness calculations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *f[m]*(*X[m]*) 是解 *X[m]* 的目标函数。表10.3显示了解适应度计算。
- en: Table 10.3 Solution fitness calculations
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.3 解适应度计算
- en: '| Candidate solution *X[m]* | Objective function *f[m]*(*X[m]**)* | Fitness
    *fit[m]*(*X[m]*) | Probability of selection *p[m]* |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 候选解 *X[m]* | 目标函数 *f[m]*(*X[m]**)* | 适应度 *fit[m]*(*X[m]*) | 选择概率 *p[m]* |'
- en: '| --- | --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *X*[1] = (–1.04,0.11) | 98.56 | 0.010 | 0.08 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| *X*[1] = (–1.04,0.11) | 98.56 | 0.010 | 0.08 |'
- en: '| *X*[2] = (–1.10,–0.10) | 174.02 | 0.006 | 0.04 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| *X*[2] = (–1.10,–0.10) | 174.02 | 0.006 | 0.04 |'
- en: '| *X*[3] = (–0.75,0.22) | 15.15 | 0.062 | 0.49 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| *X*[3] = (–0.75,0.22) | 15.15 | 0.062 | 0.49 |'
- en: '| *X*[4] = (–1.10,0.29) | 88.87 | 0.011 | 0.09 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| *X*[4] = (–1.10,0.29) | 88.87 | 0.011 | 0.09 |'
- en: '| *X*[5] = (–0.86,0.10) | 43.76 | 0.022 | 0.18 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| *X*[5] = (–0.86,0.10) | 43.76 | 0.022 | 0.18 |'
- en: '| *X*[6] = (–1.00,0.26) | 59.66 | 0.016 | 0.13 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| *X*[6] = (–1.00,0.26) | 59.66 | 0.016 | 0.13 |'
- en: In this example, the food source discovered by bee 3 is most likely to be chosen.
    After a food source *X[m]* for an onlooker bee is probabilistically chosen, a
    neighborhood source *v[m]* is determined by using equation 10.15, and its fitness
    value is computed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，蜂3发现的食源最有可能被选中。在为观察蜂选择一个食源 *X[m]* 后，通过使用方程10.15确定一个邻域源 *v[m]*，并计算其适应度值。
- en: '*Scout bee phase*—If a position cannot be improved further through a predetermined
    number of cycles or trials (called the *limit*), that position is abandoned and
    the bee becomes a scout, searching for a new random position, which can be generated
    by equation 10.14.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*侦察蜂阶段*—如果通过预定的循环或试验次数（称为 *限制*）无法进一步改善位置，那么该位置将被放弃，蜂变成侦察蜂，寻找新的随机位置，这可以通过方程10.14生成。'
- en: Let’s now see how we can implement ABC in Python to solve this problem. In the
    next listing, we start by importing the libraries we’ll use and defining the `rosenbrock_function`.
    This function takes as an argument a candidate solution (x, y) to the Rosenbrock
    function and returns its value.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何用Python实现ABC来解决这个问题。在下一个列表中，我们首先导入我们将使用的库，并定义`rosenbrock_function`。此函数将Rosenbrock函数的候选解（x，y）作为参数，并返回其值。
- en: Listing 10.2 Solving Rosenbrock function optimization using ABC
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 使用ABC解决Rosenbrock函数优化
- en: '[PRE11]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As a continuation of listing 10.2, we’ll create a `Bee` that contains the following
    attributes:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对列表10.2的延续，我们将创建一个包含以下属性的`Bee`：
- en: '`position`—The position of the bee in the search space (solution)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`—蜜蜂在搜索空间中的位置（解）'
- en: '`fitness`—The fitness of the bee’s current position (the value of the Rosenbrock
    function at the current position)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fitness`—蜜蜂当前位置的适应度（当前位置Rosenbrock函数的值）'
- en: '`counter`—A counter to track the number of unsuccessful trials (iterations
    without improvement in the bee’s fitness):'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counter`—一个计数器，用于跟踪失败的尝试次数（蜜蜂适应度没有改进的迭代）：'
- en: '[PRE12]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we need a function to generate a `Bee` with a random position and calculate
    its fitness using the Rosenbrock function:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个函数来生成具有随机位置的`Bee`，并使用Rosenbrock函数计算其适应度：
- en: '[PRE13]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following function will update the position of a given bee using the position
    of a partner bee. If the new position has a better fitness value, the bee’s position,
    fitness, and counter are updated. Otherwise, the counter is incremented:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将使用伙伴蜜蜂的位置更新给定蜜蜂的位置。如果新位置具有更好的适应度值，蜜蜂的位置、适应度和计数器将更新。否则，计数器将增加：
- en: '[PRE14]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Determine which element of the bee’s position will be updated.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ① 确定蜜蜂位置中哪个元素将被更新。
- en: ② Clip to ensure it stays within a specified range.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ② 剪切以确保它保持在指定的范围内。
- en: 'Next, we’ll define an `abc_algorithm` function to implement the ABC algorithm
    with the following input parameters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个`abc_algorithm`函数来实现ABC算法，以下为其输入参数：
- en: '`dimensions`—The number of dimensions of the problem, which is 2 for the Rosenbrock
    function'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dimensions`—问题的维度数，对于Rosenbrock函数是2'
- en: '`num_bees`—The total number of bees in the colony'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_bees`—蜂群中蜜蜂的总数'
- en: '`max_iter`—The maximum number of iterations the algorithm should run'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_iter`—算法应运行的最大迭代次数'
- en: '`max_trials`—The maximum number of unsuccessful cycles or trials (iterations
    without improvement) allowed before a bee becomes a scout bee:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_trials`—在蜜蜂成为侦察蜂之前允许的最大失败循环或尝试次数（没有改进的迭代）：'
- en: '[PRE15]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Generate an initial population of bees.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ① 生成蜜蜂的初始种群。
- en: ② Find the bee with the best fitness value.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ② 找到具有最佳适应度值的蜜蜂。
- en: ③ Perform the employed bees phase.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 执行雇佣蜜蜂阶段。
- en: ④ Perform the onlooker bees phase.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 执行观察者蜜蜂阶段。
- en: ⑤ Calculate the selection probability according equations 16 and 17.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 根据方程16和17计算选择概率。
- en: ⑥ Perform the scout bees phase.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 执行侦察蜜蜂阶段。
- en: ⑦ Check if each bee’s counter exceeds max_trials.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 检查每只蜜蜂的计数器是否超过max_trials。
- en: ⑧ Update best_bee with the new best bee.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用新的最佳蜜蜂更新best_bee。
- en: ⑨ Return best_bee, which represents the optimal solution.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 返回best_bee，它代表最优解。
- en: 'Now we can set up the parameters of the ABC algorithm and apply it to solve
    the problem:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置ABC算法的参数，并将其应用于解决问题：
- en: '[PRE16]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Define the problem dimensions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义问题维度。
- en: ② Set the number of bees.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置蜜蜂的数量。
- en: ③ Set the maximum number of iterations used as a stopping criterion.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置最大迭代次数作为停止标准。
- en: ④ Set the maximum number of unsuccessful trials (iterations without improvement)
    allowed before a bee becomes a scout bee.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置在蜜蜂成为侦察蜂之前允许的最大失败尝试次数（没有改进的迭代）。
- en: ⑤ Run the ABC algorithm with the parameters specified and store the best bee
    (the one with the minimum fitness value) in the best_bee variable.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用指定的参数运行ABC算法，并将最佳蜜蜂（具有最小适应度值的蜜蜂）存储在best_bee变量中。
- en: ⑥ Print the position of best_bee, which represents the solution and its fitness,
    which is the value of the Rosenbrock function at the best solution.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印best_bee的位置，它代表解及其适应度，即最佳解处的Rosenbrock函数值。
- en: 'This code will produce output like the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将产生如下输出：
- en: '[PRE17]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In contrast to genetic algorithms and particle swarm optimization algorithms,
    the availability of well-established and comprehensive Python packages specifically
    designed for the ABC algorithm is relatively limited. However, there is a Python
    library called MEALPY that offers implementations of population-based metaheuristic
    algorithms, including ABC. You can install MEALPY using `pip install mealpy`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与遗传算法和粒子群优化算法相比，专门为ABC算法设计的、建立良好且全面的Python包相对较少。然而，有一个名为MEALPY的Python库提供了基于种群的元启发式算法的实现，包括ABC。您可以使用`pip
    install mealpy`来安装MEALPY。
- en: 'As a continuation of listing 10.2, the following code snippet demonstrates
    using the `OriginalABC` class from the MEALPY library to minimize the Rosenbrock
    function:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 作为10.2列表的延续，以下代码片段展示了如何使用MEALPY库中的`OriginalABC`类来最小化Rosenbrock函数：
- en: '[PRE18]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Import the solver from MEALPY library.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从MEALPY库导入求解器。
- en: ② Define the problem using dictionary.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用字典定义问题。
- en: ③ Set the number of epochs (iterations).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置epoch（迭代）的数量。
- en: ④ Set the population size.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置种群大小。
- en: ⑤ Set the limit on the number of unsuccessful trials before a scout bee is triggered.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置触发侦察蜂之前的失败尝试次数限制。
- en: ⑥ Create an instance of the algorithm class.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 创建算法类的实例。
- en: ⑦ Run the algorithm.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 运行算法。
- en: ⑧ Print the results.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 打印结果。
- en: We start by importing the `OriginalABC` class from the `mealpy.swarm_based.ABC`
    module, which is the implementation of the ABC algorithm provided by the MEALPY
    library. We then define the problem dictionary, which contains the cost function
    (`fit_func`), lower bound (`lb`), upper bound (`ub`), and whether this is a minimization
    or maximization problem (`minmax`). The number of epochs (iterations), population
    size, and the limit on the number of unsuccessful trials before a scout bee is
    triggered are set. We then create an instance of the `OriginalABC` class, initialized
    with the specified parameters. The `solve()` method is called on the `model` object,
    passing the `problem_dict` as an argument. It performs the ABC algorithm optimization
    process on the defined problem and returns the best solution and fitness value.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从`mealpy.swarm_based.ABC`模块导入`OriginalABC`类，这是MEALPY库提供的ABC算法的实现。然后我们定义问题字典，其中包含成本函数（`fit_func`）、下界（`lb`）、上界（`ub`）以及这是一个最小化还是最大化问题（`minmax`）。设置epoch（迭代）的数量、种群大小以及触发侦察蜂之前的失败尝试次数限制。然后我们创建`OriginalABC`类的实例，并使用指定的参数进行初始化。在`model`对象上调用`solve()`方法，将`problem_dict`作为参数传递。它对定义的问题执行ABC算法优化过程，并返回最佳解和适应度值。
- en: 'Running this code will produce a solution like the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生如下所示的解决方案：
- en: '[PRE19]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Figure 10.16 shows the solution obtained by the ABC solver, ABC MEALPLY, and
    the ACO solver implemented as part of the complete listing 10.2.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16显示了ABC求解器、ABC MEALPLY和作为完整列表10.2一部分实现的ACO求解器获得的解决方案。
- en: '![](../Images/CH10_F16_Khamis.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F16_Khamis.png)'
- en: Figure 10.16 The Rosenbrock function contour and solutions using the ABC and
    ACO algorithms
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 使用ABC和ACO算法的Rosenbrock函数等高线和解决方案
- en: As you can see, the ABC, ABC MEALPY, and ACO solutions are all close to the
    optimal solution of this function. With parameter tuning, an optimal solution
    can be reached by these algorithms. You can use the code in listing 10.2 to experiment
    with different algorithm parameter settings and different problem dimensions.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，ABC、ABC MEALPY和ACO的解决方案都接近此函数的最优解。通过参数调整，这些算法可以达到最优解。您可以使用10.2列表中的代码来尝试不同的算法参数设置和不同的问题维度。
- en: This chapter concludes the fourth part of this book. In this part, we’ve delved
    deep into the fascinating world of swarm intelligence, exploring how simple entities,
    like birds in particle swarm optimization (PSO), ants in ant colony optimization
    (ACO), and bees in the artificial bee colony (ABC) algorithm, can collectively
    perform complex tasks. These nature-inspired algorithms elegantly balance exploration
    and exploitation to find optimal or near-optimal solutions to complex optimization
    problems.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书的第四部分。在这一部分，我们深入探讨了群智能的迷人世界，探讨了像粒子群优化（PSO）中的鸟、蚁群优化（ACO）中的蚂蚁和人工蜂群（ABC）算法中的蜜蜂这样的简单实体如何集体执行复杂任务。这些受自然界启发的算法巧妙地平衡了探索和利用，以找到复杂优化问题的最优或近似最优解。
- en: As we move forward, we’ll transition to the domain of machine learning. In the
    last part of this book, we’ll look at machine learning methods specifically tailored
    for search and optimization. We’ll explore cutting-edge techniques, such as graph
    neural networks, attention mechanisms, self-organizing maps, and reinforcement
    learning, and investigate their applications in search and optimization.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们将过渡到机器学习的领域。在这本书的最后一部分，我们将探讨专门针对搜索和优化的机器学习方法。我们将探索前沿技术，如图神经网络、注意力机制、自组织映射和强化学习，并研究它们在搜索和优化中的应用。
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Ant colony optimization (ACO) is a population-based algorithm inspired by the
    foraging behavior of ants. Simple ACO (SACO), ant system (AS), ant colony system
    (ACS), and max–min ant system (MMAS) are examples of ACO metaheuristics algorithms.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁群优化（ACO）是一种受蚂蚁觅食行为启发的基于种群的算法。简单的蚁群优化（SACO）、蚂蚁系统（AS）、蚂蚁群系统（ACS）和最大-最小蚂蚁系统（MMAS）是
    ACO 元启发式算法的例子。
- en: During foraging, ants discover good solutions, which influence the decisions
    of other ants. Over time, the pheromone trails intensify along the paths of better
    solutions, attracting more ants to explore those paths. This is called autocatalytic
    behavior.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在觅食过程中，蚂蚁发现好的解决方案，这会影响其他蚂蚁的决策。随着时间的推移，信息素路径沿着更好解决方案的路径增强，吸引更多蚂蚁探索这些路径。这被称为自催化行为。
- en: 'Pheromone updates include two phases: evaporation and deposit. During the evaporation
    phase, the pheromone concentration is decreased. Ants can deposit pheromones during
    the construction of a solution, using the online step-by-step pheromone update
    method, or after the solution has been built, by revisiting all the states visited
    during the construction process, using the online delayed pheromone update method.
    In some cases, both methods can be used together.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息素更新包括两个阶段：蒸发和沉积。在蒸发阶段，信息素浓度降低。蚂蚁可以在构建解决方案的过程中沉积信息素，使用在线逐步信息素更新方法，或者解决方案构建完成后，通过重新访问构建过程中访问的所有状态，使用在线延迟信息素更新方法。在某些情况下，两种方法可以同时使用。
- en: Ant system (AS) improves on simple ACO by adding a memory capability in the
    form of a tabu list.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁系统（AS）通过添加禁忌表的形式的内存能力来改进简单的蚁群优化（ACO）。
- en: The ant colony system (ACS) algorithm is an extension of the AS algorithm with
    a modified transition rule that utilizes an elitist strategy.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁群系统（ACS）算法是 AS 算法的扩展，它使用了一种修改后的转换规则，并利用了精英策略。
- en: The max–min ant system (MMAS) addresses the limitations of AS and ACS by using
    the iteration-best path for pheromone updates, encouraging exploration and constraining
    pheromone values between minimum and maximum values. This approach reduces the
    risk of premature stagnation and improves performance by balancing exploration
    and exploitation.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大-最小蚂蚁系统（MMAS）通过使用迭代最佳路径进行信息素更新，鼓励探索并限制信息素值在最小和最大值之间，解决了蚂蚁系统（AS）和蚂蚁系统协同优化（ACS）的局限性。这种方法减少了过早停滞的风险，并通过平衡探索和利用来提高性能。
- en: The artificial bee colony (ABC) algorithm is a population-based search algorithm
    inspired by the foraging behavior of honeybees. The ABC algorithm manages the
    balance between exploration and exploitation through its three types of bees (employed
    bees, onlooker bees, and scout bees), each of which perform different complementary
    roles.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工蜂群（ABC）算法是一种受蜜蜂觅食行为启发的基于种群的搜索算法。ABC算法通过其三种蜜蜂（工蜂、观察蜂和侦察蜂）来管理探索和利用之间的平衡，每种蜜蜂都执行不同的互补角色。
- en: The inherent randomness in stochastic optimization algorithms due to initial
    conditions and the probabilistic decision-making process is not necessarily a
    bad thing. It can help the algorithm avoid getting stuck in local optima—solutions
    that are the best in their immediate vicinity but are not the best overall. By
    occasionally taking less promising paths, the algorithm can explore more of the
    solution space and has a better chance of finding the global optimum—the best
    possible solution.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于初始条件和概率决策过程的不确定性，随机优化算法中的固有随机性并不一定是坏事。它可以帮助算法避免陷入局部最优——在它们 immediate vicinity
    中是最好的解决方案，但不是整体上最好的解决方案。通过偶尔选择不太有希望的路径，算法可以探索更多的解决方案空间，并更有可能找到全局最优——最佳可能的解决方案。
