["```py\nbash scripts/download_music_data.sh\n```", "```py\nimport music21\n\nfile = \"/app/data/bach-cello/cs1-2all.mid\"\nexample_score = music21.converter.parse(file).chordify()\n```", "```py\ndef create_dataset(elements):\n    ds = (\n        tf.data.Dataset.from_tensor_slices(elements)\n        .batch(BATCH_SIZE, drop_remainder = True)\n        .shuffle(1000)\n    )\n    vectorize_layer = layers.TextVectorization(\n        standardize = None, output_mode=\"int\"\n    )\n    vectorize_layer.adapt(ds)\n    vocab = vectorize_layer.get_vocabulary()\n    return ds, vectorize_layer, vocab\n\nnotes_seq_ds, notes_vectorize_layer, notes_vocab = create_dataset(notes)\ndurations_seq_ds, durations_vectorize_layer, durations_vocab = create_dataset(\n    durations\n)\nseq_ds = tf.data.Dataset.zip((notes_seq_ds, durations_seq_ds))\n```", "```py\nclass TokenAndPositionEmbedding(layers.Layer):\n    def __init__(self, vocab_size, embed_dim):\n        super(TokenAndPositionEmbedding, self).__init__()\n        self.vocab_size = vocab_size\n        self.embed_dim = embed_dim\n        self.token_emb = layers.Embedding(input_dim=vocab_size, output_dim=embed_dim)\n        self.pos_emb = keras_nlp.layers.SinePositionEncoding()\n\n    def call(self, x):\n        embedding = self.token_emb(x)\n        positions = self.pos_emb(embedding)\n        return embedding + positions\n```", "```py\nbash scripts/download_bach_chorale_data.sh\n```", "```py\n[BATCH_SIZE, N_BARS, N_STEPS_PER_BAR, N_PITCHES, N_TRACKS]\n```", "```py\nBATCH_SIZE = 64\nN_BARS = 2\nN_STEPS_PER_BAR = 16\nN_PITCHES = 84\nN_TRACKS = 4\n```", "```py\ndef conv_t(x, f, k, s, a, p, bn):\n    x = layers.Conv2DTranspose(\n                filters = f\n                , kernel_size = k\n                , padding = p\n                , strides = s\n                , kernel_initializer = initializer\n                )(x)\n    if bn:\n        x = layers.BatchNormalization(momentum = 0.9)(x)\n\n    x = layers.Activation(a)(x)\n    return x\n\ndef TemporalNetwork():\n    input_layer = layers.Input(shape=(Z_DIM,), name='temporal_input') ![1](Images/1.png)\n    x = layers.Reshape([1,1,Z_DIM])(input_layer) ![2](Images/2.png)\n    x = conv_t(\n        x, f=1024, k=(2,1), s=(1,1), a = 'relu', p = 'valid', bn = True\n    ) ![3](Images/3.png)\n    x = conv_t(\n        x, f=Z_DIM, k=(N_BARS - 1,1), s=(1,1), a = 'relu', p = 'valid', bn = True\n    )\n    output_layer = layers.Reshape([N_BARS, Z_DIM])(x) ![4](Images/4.png)\n    return models.Model(input_layer, output_layer)\n```", "```py\ndef BarGenerator():\n\n    input_layer = layers.Input(shape=(Z_DIM * 4,), name='bar_generator_input') ![1](Images/1.png)\n\n    x = layers.Dense(1024)(input_layer) ![2](Images/2.png)\n    x = layers.BatchNormalization(momentum = 0.9)(x)\n    x = layers.Activation('relu')(x)\n    x = layers.Reshape([2,1,512])(x)\n\n    x = conv_t(x, f=512, k=(2,1), s=(2,1), a= 'relu',  p = 'same', bn = True) ![3](Images/3.png)\n    x = conv_t(x, f=256, k=(2,1), s=(2,1), a= 'relu', p = 'same', bn = True)\n    x = conv_t(x, f=256, k=(2,1), s=(2,1), a= 'relu', p = 'same', bn = True)\n    x = conv_t(x, f=256, k=(1,7), s=(1,7), a= 'relu', p = 'same', bn = True) ![4](Images/4.png)\n    x = conv_t(x, f=1, k=(1,12), s=(1,12), a= 'tanh', p = 'same', bn = False) ![5](Images/5.png)\n\n    output_layer = layers.Reshape([1, N_STEPS_PER_BAR , N_PITCHES ,1])(x) ![6](Images/6.png)\n\n    return models.Model(input_layer, output_layer)\n```", "```py\ndef Generator():\n    chords_input = layers.Input(shape=(Z_DIM,), name='chords_input') ![1](Images/1.png)\n    style_input = layers.Input(shape=(Z_DIM,), name='style_input')\n    melody_input = layers.Input(shape=(N_TRACKS, Z_DIM), name='melody_input')\n    groove_input = layers.Input(shape=(N_TRACKS, Z_DIM), name='groove_input')\n\n    chords_tempNetwork = TemporalNetwork() ![2](Images/2.png)\n    chords_over_time = chords_tempNetwork(chords_input)\n\n    melody_over_time = [None] * N_TRACKS\n    melody_tempNetwork = [None] * N_TRACKS\n    for track in range(N_TRACKS):\n        melody_tempNetwork[track] = TemporalNetwork() ![3](Images/3.png)\n        melody_track = layers.Lambda(lambda x, track = track: x[:,track,:])(\n            melody_input\n        )\n        melody_over_time[track] = melody_tempNetwork[track](melody_track)\n\n    barGen = [None] * N_TRACKS\n    for track in range(N_TRACKS):\n        barGen[track] = BarGenerator() ![4](Images/4.png)\n\n    bars_output = [None] * N_BARS\n    c = [None] * N_BARS\n    for bar in range(N_BARS): ![5](Images/5.png)\n        track_output = [None] * N_TRACKS\n\n        c[bar] = layers.Lambda(lambda x, bar = bar: x[:,bar,:])(chords_over_time)\n        s = style_input\n\n        for track in range(N_TRACKS):\n\n            m = layers.Lambda(lambda x, bar = bar: x[:,bar,:])(\n                melody_over_time[track]\n            )\n            g = layers.Lambda(lambda x, track = track: x[:,track,:])(\n                groove_input\n            )\n\n            z_input = layers.Concatenate(\n                axis = 1, name = 'total_input_bar_{}_track_{}'.format(bar, track)\n            )([c[bar],s,m,g])\n\n            track_output[track] = barGen[track](z_input)\n\n        bars_output[bar] = layers.Concatenate(axis = -1)(track_output)\n\n    generator_output = layers.Concatenate(axis = 1, name = 'concat_bars')(\n        bars_output\n    ) ![6](Images/6.png)\n\n    return models.Model(\n        [chords_input, style_input, melody_input, groove_input], generator_output\n    ) ![7](Images/7.png)\n\ngenerator = Generator()\n```", "```py\ndef conv(x, f, k, s, p):\n    x = layers.Conv3D(filters = f\n                , kernel_size = k\n                , padding = p\n                , strides = s\n                , kernel_initializer = initializer\n                )(x)\n    x = layers.LeakyReLU()(x)\n    return x\n\ndef Critic():\n    critic_input = layers.Input(\n        shape=(N_BARS, N_STEPS_PER_BAR, N_PITCHES, N_TRACKS),\n        name='critic_input'\n    ) ![1](Images/1.png)\n\n    x = critic_input\n    x = conv(x, f=128, k = (2,1,1), s = (1,1,1), p = 'valid') ![2](Images/2.png)\n    x = conv(x, f=128, k = (N_BARS - 1,1,1), s = (1,1,1), p = 'valid')\n\n    x = conv(x, f=128, k = (1,1,12), s = (1,1,12), p = 'same') ![3](Images/3.png)\n    x = conv(x, f=128, k = (1,1,7), s = (1,1,7), p = 'same')\n\n    x = conv(x, f=128, k = (1,2,1), s = (1,2,1), p = 'same') ![4](Images/4.png)\n    x = conv(x, f=128, k = (1,2,1), s = (1,2,1), p = 'same')\n    x = conv(x, f=256, k = (1,4,1), s = (1,2,1), p = 'same')\n    x = conv(x, f=512, k = (1,3,1), s = (1,2,1), p = 'same')\n\n    x = layers.Flatten()(x)\n\n    x = layers.Dense(1024, kernel_initializer = initializer)(x)\n    x = layers.LeakyReLU()(x)\n\n    critic_output = layers.Dense(\n        1, activation=None, kernel_initializer = initializer\n    )(x) ![5](Images/5.png)\n\n    return models.Model(critic_input, critic_output)\n\ncritic = Critic()\n```"]