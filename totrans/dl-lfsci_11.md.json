["```py\n`from` `rdkit` `import` `Chem`             `# RDKit libraries for chemistry functions` \n`from` `rdkit.Chem` `import` `Draw`        `# Drawing chemical structures` \n`import` `pandas` `as` `pd`                `# Dealing with data in tables` \n`from` `rdkit.Chem` `import` `PandasTools` `# Manipulating chemical data` \n`from` `rdkit.Chem` `import` `Descriptors` `# Calculating molecular descriptors` \n`from` `rdkit.Chem` `import` `rdmolops`    `# Additional molecular properties` \n`import` `seaborn` `as` `sns`              `# Making graphs` \n```", "```py\n`active_df` `=` `pd``.``read_CSV``(`\"mk01/actives_final.ism\"`,``header``=``None``,``sep``=`\" \"`)`\n`active_rows``,``active_cols` `=` `active_df``.``shape`\n`active_df``.``columns` `=` `[`\"SMILES\"`,`\"ID\"`,`\"ChEMBL_ID\"`]`\n`active_df``[`\"label\"`]` `=` `[`\"Active\"`]``*``active_rows`\n`PandasTools``.``AddMoleculeColumnToFrame``(``active_df``,`\"SMILES\"`,`\"Mol\"`)`\n```", "```py\ndef add_property_columns_to_df(df_in):\ndf_in[\"mw\"] = [Descriptors.MolWt(mol) for mol in\ndf_in.Mol]\ndf_in[\"logP\"] = [Descriptors.MolLogP(mol) for mol in\ndf_in.Mol]\ndf_in[\"charge\"] = [rdmolops.GetFormalCharge(mol) for mol\nin df_in.Mol]\n\n```", "```py\n`add_property_columns_to_df``(``active_df``)`\n```", "```py\n`active_df``.``head``(``)`\n```", "```py\n`decoy_df` `=` `pd``.``read_CSV``(`\"mk01/decoys_final.ism\"`,``header``=``None``,``sep``=`\" \"`)`\n`decoy_df``.``columns` `=` `[`\"SMILES\"`,`\"ID\"`]`\n`decoy_rows``,` `decoy_cols` `=` `decoy_df``.``shape`\n`decoy_df``[`\"label\"`]` `=` `[`\"Decoy\"`]``*``decoy_rows`\n`PandasTools``.``AddMoleculeColumnToFrame``(``decoy_df``,`\"SMILES\"`,`\"Mol\"`)`\n`add_property_columns_to_df``(``decoy_df``)`\n```", "```py\n`tmp_df` `=` `active_df``.``append``(``decoy_df``)`\n```", "```py\n`sns``.``violinplot``(``tmp_df``[`\"label\"`]``,``tmp_df``[`\"mw\"`]``)`\n```", "```py\n`sns``.``violinplot``(``tmp_df``[`\"label\"`]``,``tmp_df``[`\"logP\"`]``)`\n```", "```py\n`sns``.``violinplot``(``new_tmp_df``[`\"label\"`]``,``new_tmp_df``[`\"charge\"`]``)`\n```", "```py\n`charged` `=` `decoy_df``[``decoy_df``[`\"charge\"`]` `!=` `0``]`\n```", "```py\n`charged``.``shape``[``0``]``/``decoy_df``.``shape``[``0``]`\n```", "```py\n`from` `neutralize` `import` `NeutraliseCharges`\n```", "```py\n`revised_decoy_df` `=` `decoy_df``[``[`\"SMILES\"`,`\"ID\"`,`\"label\"`]``]``.``copy``(``)`\n```", "```py\nrevised_decoy_df[\"SMILES\"] = [NeutraliseCharges(x)[0] for x\nin revised_decoy_df[\"SMILES\"]]\n\n```", "```py\n`PandasTools``.``AddMoleculeColumnToFrame``(``revised_decoy_df``,`\"SMILES\"`,`\"Mol\"`)`\n`add_property_columns_to_df``(``revised_decoy_df``)`\n```", "```py\n`new_tmp_df` `=` `active_df``.``append``(``revised_decoy_df``)`\n```", "```py\n`sns``.``violinplot``(``new_tmp_df``[`\"label\"`]``,``new_tmp_df``[`\"charge\"`]``)`\n```", "```py\n`charged` `=` `revised_decoy_df``[``revised_decoy_df``[`\"charge\"`]` `!=` `0``]`\n`charged``.``shape``[``0``]``/``revised_decoy_df``.``shape``[``0``]`\n```", "```py\n`active_df``[`\"is_active\"`]` `=` `[``1``]` `*` `active_df``.``shape``[``0``]`\n`revised_decoy_df``[`\"is_active\"`]` `=` `[``0``]` `*` `revised_decoy_df``.``shape``[``0``]`\n`combined_df` `=` `active_df``.``append``(``revised_decoy_df``)``[``[`\"SMILES\"`,`\"ID\"`,`\"is_active\"`]``]`\n`combined_df``.``head``(``)`\n```", "```py\n`combined_df``.``to_csv``(`\"dude_erk1_mk01.CSV\",index=False)\n\n```", "```py\n`import` `deepchem` `as` `dc`                      `# DeepChem libraries`\n`from` `deepchem.models` `import` `GraphConvModel` `# Graph convolutions` \n`import` `numpy` `as` `np`                         `# NumPy for numeric operations` \n`import` `sys`                                 `# Error handling` \n`import` `pandas` `as` `pd`                        `# Data table manipulation` \n`import` `seaborn` `as` `sns`                      `# Seaborn library for plotting` \n`from` `rdkit.Chem` `import` `PandasTools`         `# Chemical structures in Pandas` \n```", "```py\ndef generate_graph_conv_model():\nbatch_size = 128\nmodel = GraphConvModel(1, batch_size=batch_size,\nmode='classification',\nmodel_dir=\"/tmp/mk01/model_dir\")\nreturn model\u200b\n```", "```py\ndataset_file = \"dude_erk2_mk01.CSV\"\ntasks = [\"is_active\"]\nfeaturizer = dc.feat.ConvMolFeaturizer()\nloader = dc.data.CSVLoader(tasks=tasks,\nsmiles_field=\"SMILES\",\nfeaturizer=featurizer)\ndataset = loader.featurize(dataset_file, shard_size=8192)\n\n```", "```py\n`splitter` `=` `dc``.``splits``.``RandomSplitter``(``)`\n```", "```py\nmetrics = [\ndc.metrics.Metric(dc.metrics.matthews_corrcoef, np.mean,\nmode=\"classification\")]\n\n```", "```py\ntraining_score_list = []\nvalidation_score_list = []\ntransformers = []\ncv_folds = 10\nfor i in range(0, cv_folds):\nmodel = generate_graph_conv_model()\nres = splitter.train_valid_test_split(dataset)\ntrain_dataset, valid_dataset, test_dataset = res\nmodel.fit(train_dataset)\ntrain_scores = model.evaluate(train_dataset, metrics,\ntransformers)\ntraining_score_list.append(\ntrain_scores[\"mean-matthews_corrcoef\"])\nvalidation_scores = model.evaluate(valid_dataset,\nmetrics,\ntransformers)\nvalidation_score_list.append(\nvalidation_scores[\"mean-matthews_corrcoef\"])\nprint(training_score_list)\nprint(validation_score_list)\n\n```", "```py\nsns.boxplot(\n[\"training\"] * cv_folds + [\"validation\"] * cv_folds,\ntraining_score_list + validation_score_list)\n\n```", "```py\n`pred` `=` `[``x``.``flatten``(``)` `for` `x` `in` `model``.``predict``(``valid_dataset``)``]`\n```", "```py\n`pred_df` `=` `pd``.``DataFrame``(``pred``,``columns``=``[`\"neg\"`,`\"pos\"`]``)`\n```", "```py\n`pred_df``[`\"active\"`]` `=` `[``int``(``x``)` `for` `x` `in` `valid_dataset``.``y``]`\n`pred_df``[`\"SMILES\"`]` `=` `valid_dataset``.``ids`\n```", "```py\n`sns``.``boxplot``(``pred_df``.``active``,``pred_df``.``pos``)`\n```", "```py\n`false_negative_df` `=` `pred_df``.``query``(`\"active == 1 & pos < 0.5\"`)``.``copy``(``)`\n```", "```py\nPandasTools.AddMoleculeColumnToFrame(false_negative_df,\n\"SMILES\", \"Mol\")\n\n```", "```py\nfalse_negative_df\n```", "```py\nfalse_positive_df = pred_df.query(\n    \"active == 0 & pos > 0.5\").copy()\nPandasTools.AddMoleculeColumnToFrame(false_positive_df,\n                                     \"SMILES\", \"Mol\")\nfalse_positive_df\n```", "```py\n`model``.``fit``(``dataset``)`\n\n```", "```py\n`model``.``save``(``)`\n\n```", "```py\nrd_filters.py -h\n```", "```py\nUsage:\nrd_filters.py $ **filter --in INPUT_FILE --prefix PREFIX [--rules RULES_FILE_NAME] \n[--alerts ALERT_FILE_NAME][--np NUM_CORES]**\nrd_filters.py $ **template --out TEMPLATE_FILE [--rules RULES_FILE_NAME]**\nOptions:\n--in INPUT_FILE input file name\n--prefix PREFIX prefix for output file names\n--rules RULES_FILE_NAME name of the rules JSON file\n--alerts ALERTS_FILE_NAME name of the structural alerts file\n--np NUM_CORES the number of cpu cores to use (default is all)\n--out TEMPLATE_FILE parameter template file name \n```", "```py\n`rd_filters``.``py` `filter` `-``-``in` `zinc_100k``.``smi` `-``-``prefix` `zinc`\n```", "```py\nusing 24 cores\nUsing alerts from Inpharmatica\nWrote SMILES for molecules passing filters to zinc.smi\nWrote detailed data to zinc.CSV\n68752 of 100000 passed filters 68.8%\nElapsed time 15.89 seconds \n```", "```py\nimport pandas as pd\ndf = pd.read_CSV(\"zinc.CSV\")\ndf.head()\n```", "```py\n`from` `collections` `import` `Counter`\n`count_list` `=` `list``(``Counter``(``df``.``FILTER``)``.``items``(``)``)`\n`count_df` `=` `pd``.``DataFrame``(``count_list``,``columns``=``[`\"Rule\"`,`\"Count\"`]``)`\n`count_df``.``sort_values``(`\"Count\"`,``inplace``=``True``,``ascending``=``False``)`\n`count_df``.``head``(``)`\n```", "```py\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\n\nmol_list = [Chem.MolFromSmiles(x) for x in smiles_list]\ndicarbonyl = Chem.MolFromSmarts('*C(=O)C(=O)*')\nmatch_list = [mol.GetSubstructMatch(dicarbonyl) for mol in\n              mol_list]\nDraw.MolsToGridImage(mol_list,\n                     highlightAtomLists=match_list,\n                     molsPerRow=5)\n\n```", "```py\n`import` `deepchem` `as` `dc`                           `# DeepChem libraries`\n`import` `pandas` `as` `pd`                             `# Pandas for tables`\n`from` `rdkit.Chem` `import` `PandasTools``,` `Draw`        `# Chemistry in Pandas`\n`from` `rdkit` `import` `DataStructs`                   `# For fingerprint handling`\n`from` `rdkit.ML.Cluster` `import` `Butina`             `# Cluster molecules`\n`from` `rdkit.Chem` `import` `rdMolDescriptors` `as` `rdmd` `# Descriptors`\n`import` `seaborn` `as` `sns`                           `# Plotting`\n```", "```py\n`model` `=` `dc``.``models``.``TensorGraph``.``load_from_dir``(`\"\"/tmp/mk01/model_dir\"\"`)`\n```", "```py\n`featurizer` `=` `dc``.``feat``.``ConvMolFeaturizer``(``)`\n```", "```py\ndf = pd.read_CSV(\"zinc.smi\",sep=\" \",header=None)\ndf.columns=[\"SMILES\",\"Name\"]\nrows,cols = df.shape\n# Just add add a dummy column to keep the featurizer happy\ndf[\"Val\"] = [0] * rows \n```", "```py\n`df``.``head``(``)`\n```", "```py\n`infile_name` `=` \"zinc_filtered.CSV\"\n`df``.``to_CSV``(``infile_name``,``index``=``False``)`\n```", "```py\nloader = dc.data.CSVLoader(tasks=['Val'],\n                           smiles_field=\"SMILES\",\n                           featurizer=featurizer)\ndataset = loader.featurize(infile_name, shard_size=8192)\n\n```", "```py\n`pred` `=` `model``.``predict``(``dataset``)`\n```", "```py\npred_df = pd.DataFrame([x.flatten() for x in pred],\ncolumns=[\"Neg\", \"Pos\"]\n\n```", "```py\ncombo_df = df.join(pred_df, how=\"outer\")\ncombo_df.sort_values(\"Pos\", inplace=True, ascending=False)\n```", "```py\nDraw.MolsToGridImage(combo_df.Mol[:10], molsPerRow=5,\n                    legends=[\"%.2f\" % x for x in combo_df.Pos[:10]])\n```", "```py\ndef butina_cluster(mol_list, cutoff=0.35):\n    fp_list = [\n        rdmd.GetMorganFingerprintAsBitVect(m, 3, nBits=2048)\n        for m in mol_list]\n    dists = []\n    nfps = len(fp_list)\n    for i in range(1, nfps):\n        sims = DataStructs.BulkTanimotoSimilarity(\n            fp_list[i], fp_list[:i])\n        dists.extend([1 - x for x in sims])\n    mol_clusters = Butina.ClusterData(dists, nfps, cutoff,\n                                      isDistData=True)\n    cluster_id_list = [0] * nfps\n    for idx, cluster in enumerate(mol_clusters, 1):\n        for member in cluster:\n            cluster_id_list[member] = idx\n    return cluster_id_list\u200b\n\n```", "```py\n`best_100_df` `=` `combo_df``.``head``(``100``)``.``copy``(``)`\n```", "```py\nbest_100_df[\"Cluster\"] = butina_cluster(best_100_df.Mol)\nbest_100_df.head()\n```", "```py\n`len``(``best_100_df``.``Cluster``.``unique``(``)``)`\n```", "```py\nbest_cluster_rep_df = best_100_df.drop_duplicates(\"Cluster\")\n```", "```py\nbest_cluster_rep_df.shape\n```", "```py\nbest_cluster_rep_df.to_CSV(\"best_cluster_represenatives.CSV\")\n```"]