- en: 2 A deeper look at search and optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 深入了解搜索和优化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Classifying optimization problems based on different criteria
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据不同标准对优化问题进行分类
- en: Classifying search and optimization algorithms based on the way the search space
    is explored and how deterministic the algorithm is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据搜索空间探索方式和算法的确定性对搜索和优化算法进行分类
- en: Introducing heuristics, metaheuristics, and heuristic search strategies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍启发式算法、元启发式算法和启发式搜索策略
- en: A first look at nature-inspired search and optimization algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次了解受自然启发的搜索和优化算法
- en: Before we dive into the problems and algorithms that I hinted at in chapter
    1, it will be useful to be clear about how we talk about these problems and algorithms.
    Classifying problems allows us to group similar problems together and potentially
    exploit existing solutions. For example, a traveling salesman problem involving
    geographic values (i.e., cities and roads) may be used as a model to find the
    minimum length of wires connecting pins in a very large-scale integration (VLSI)
    design. The same can be said for classifying the algorithms themselves, as grouping
    algorithms with similar properties can allow us to easily identify the right algorithm
    to solve a problem and meet expectations, such as the quality of the solution
    and the permissible search time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨第1章中提到的问题和算法之前，弄清楚我们如何讨论这些问题和算法将是有用的。对问题进行分类使我们能够将类似的问题分组，并可能利用现有的解决方案。例如，一个涉及地理值（即城市和道路）的旅行商问题可能被用作模型来找到连接引脚的最小长度，这在超大规模集成电路（VLSI）设计中是非常大的。同样，对算法本身进行分类也是有益的，因为将具有相似属性的算法分组可以让我们轻松地识别出解决特定问题的正确算法，并满足期望，例如解决方案的质量和允许的搜索时间。
- en: Throughout this chapter, we’ll discuss common classifications of optimization
    problems and algorithms. Heuristics and metaheuristics will also be introduced
    as general algorithmic frameworks or high-level strategies that guide the search
    process. Many of these strategies are inspired by nature, so we’ll shed some light
    on nature-inspired algorithms. Let’s start by discussing how we can classify optimization
    problems based on different criteria.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论优化问题和算法的常见分类。启发式算法和元启发式算法也将作为指导搜索过程的通用算法框架或高级策略进行介绍。许多这些策略都受到自然的启发，因此我们将对受自然启发的算法进行一些探讨。让我们首先讨论如何根据不同的标准对优化问题进行分类。
- en: 2.1 Classifying optimization problems
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 优化问题的分类
- en: Optimization is everywhere! In everyday life, you’ll face different kinds of
    optimization problems. For example, you may like to set the thermostat to a certain
    temperature to stay comfortable and at the same time save energy. You may select
    light fixtures and adjust the light levels to reduce energy costs. When you start
    driving your electric vehicle (EV), you may search for the fastest or most energy-efficient
    route to your destination. Before arriving at your destination, you may look for
    a parking spot that is affordable, provides the shortest walking distance to your
    destination, offers EV charging, and is preferably underground. These optimization
    problems have different levels of complexity that mainly depend on the type of
    problem. As mentioned in the previous chapter, the process of optimization involves
    selecting decision variables from a given feasible search space in such a way
    as to optimize (minimize or maximize) a given objective function or, in some cases,
    multiple objective functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 优化无处不在！在日常生活中，你会遇到各种优化问题。例如，你可能喜欢将恒温器设置到一定的温度，以保持舒适并同时节省能源。你可能选择灯具并调整灯光水平以降低能源成本。当你开始驾驶电动汽车（EV）时，你可能寻找最快或最节能的路线到达目的地。在你到达目的地之前，你可能寻找一个价格合理、提供最短步行距离到达目的地、提供电动汽车充电且最好是地下停车场的停车位。这些优化问题的复杂程度不同，主要取决于问题的类型。正如前一章所述，优化过程涉及从给定的可行搜索空间中选择决策变量，以便优化（最小化或最大化）给定的目标函数，或者在某些情况下，多个目标函数。
- en: 'Optimization problems are characterized by three main components: decision
    variables or design vectors, objective functions or criteria to be optimized,
    and a set of hard and soft constraints to be satisfied. The nature of these three
    components, the permissible time allowed for solving the problem, and the expected
    quality of the solutions lead to different types of optimization problems, as
    shown in figure 2.1.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题由三个主要组成部分特征化：决策变量或设计向量、要优化的目标函数或标准，以及需要满足的一组硬约束和软约束。这三个组成部分的性质、解决问题允许的时间以及预期解决方案的质量导致不同类型的优化问题，如图2.1所示。
- en: '![](../Images/CH02_F01_Khamis.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_Khamis.png)'
- en: Figure 2.1 Optimization problem classification—an optimization problem can be
    broken down into its constituent parts, which form the basis for classifying such
    problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 优化问题分类——一个优化问题可以分解为其组成部分，这些组成部分是此类问题分类的基础。
- en: The following subsections explain these types in greater detail and provide
    examples of each type of optimization problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将更详细地解释这些类型，并为每种优化问题提供示例。
- en: 2.1.1 Number and type of decision variables
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 决策变量的数量和类型
- en: Based on the number of decision variables, optimization problems can be broadly
    grouped into univariate (single variable) or multivariate (multiple variable)
    problems. For example, vehicle speed, acceleration, and tire pressure are among
    the parameters that effect a vehicle’s fuel economy, where fuel economy refers
    to how far a vehicle can travel on a specific amount of fuel. According to the
    US Department of Energy, controlling the speed and acceleration of a vehicle can
    improve its fuel economy by 15% to 30% at highway speeds and 10% to 40% in stop-and-go
    traffic. A study by the US National Highway Traffic Safety Administration (NHTSA)
    found that a 1% decrease in tire pressure correlated to a 0.3% reduction in fuel
    economy. If we are only looking for the optimal vehicle speed for maximum fuel
    economy, the problem is a univariate optimization problem. Finding the optimal
    speed and acceleration for maximum fuel economy is a bivariate optimization problem,
    whereas finding optimal speed, acceleration, and tire pressure is a multivariate
    problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据决策变量的数量，优化问题可以广泛分为单变量（单变量）或多变量（多变量）问题。例如，车辆速度、加速度和轮胎压力是影响车辆燃油经济的参数之一，其中燃油经济性指的是车辆在特定燃料量下能行驶多远。根据美国能源部，控制车辆的速度和加速度可以在高速公路上提高其燃油经济性15%至30%，在走走停停的交通中提高10%至40%。美国国家公路交通安全管理局（NHTSA）的一项研究发现，轮胎压力降低1%与燃油经济性降低0.3%相关。如果我们只寻找最大燃油经济性的最优车辆速度，则该问题是单变量优化问题。寻找最大燃油经济性的最优速度和加速度是双变量优化问题，而寻找最优速度、加速度和轮胎压力是多变量问题。
- en: Problem classification also varies according to the type of decision variables.
    A continuous problem involves continuous-valued variables, where *x*[j] ∈ R. In
    contrast, if *x*[j] ∈ Z, the problem is an integer or discrete optimization problem.
    A mixed-integer problem has both continuous-valued and integer-valued variables.
    For example, optimizing elevator speed and acceleration (continuous variables)
    and the sequence of picking up passengers (a discrete variable) is a mixed-integer
    problem. Problems where the solutions are sets, combinations, or permutations
    of integer-valued variables are referred to as combinatorial optimization problems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 问题分类也根据决策变量的类型而变化。连续问题涉及连续值变量，其中 *x*[j] ∈ R。相比之下，如果 *x*[j] ∈ Z，则问题是整数或离散优化问题。混合整数问题既有连续值变量也有整数值变量。例如，优化电梯速度和加速度（连续变量）以及乘客上下车的顺序（一个离散变量）是一个混合整数问题。解决方案是整数值变量的集合、组合或排列的问题被称为组合优化问题。
- en: Combination vs. permutation
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 组合与排列
- en: Combinatorics is the branch of mathematics studying both the combination and
    permutation of a set of elements. The main difference between combination and
    permutation is the order. If the order of the elements doesn’t matter, it is a
    combination, and if the order does matter, it is a permutation. Thus, permutations
    are ordered combinations. Depending on whether repetition of the elements is allowed
    or not, we can have different forms of combinations and permutations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 组合数学是研究一组元素组合和排列的数学分支。组合与排列的主要区别在于顺序。如果元素的顺序不重要，则它是组合；如果顺序很重要，则它是排列。因此，排列是有序组合。根据是否允许元素重复，我们可以有不同的组合和排列形式。
- en: '![](../Images/CH02_F01_UN01_Khamis.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_UN01_Khamis.png)'
- en: Combinations and permutations—permutations respect order and are thus ordered
    combinations. Both combinations and permutations have variants with and without
    repetition.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 组合和排列——排列尊重顺序，因此是按顺序排列的组合。组合和排列都有带重复和不带重复的变体。
- en: 'For example, assume we are designing a fitness plan that includes multiple
    fitness activities. Five types of exercises can be included in the fitness plan:
    jogging, swimming, biking, yoga, and aerobics. In a weekly plan, if we choose
    only three of these five exercises, and repetition is allowed, the number of possible
    combinations will be (*n* + *r* – 1)! / *r*!(*n* – 1)! = (5 + 3 – 1)! / 3!(5 –
    1)! = 7! / (3! × 4!) = 35. This means we can generate 35 different fitness plans
    by selecting three of the available five exercises and by allowing repetition.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在设计一个包含多个健身活动的健身计划。健身计划中可以包含五种类型的练习：慢跑、游泳、骑自行车、瑜伽和有氧运动。在一周的计划中，如果我们只选择这五种练习中的三种，并且允许重复，可能的组合数将是(*n*
    + *r* – 1)! / *r*!(*n* – 1)! = (5 + 3 – 1)! / 3!(5 – 1)! = 7! / (3! × 4!) = 35。这意味着我们可以通过选择五种可用练习中的三种并允许重复来生成35种不同的健身计划。
- en: However, if repetition is not allowed, the number of possible combinations will
    be *C*(*n*,*r*) = *n*! / *r*!(*n* – *r*)! = 5! / (3! × 2!) = 10. This formula
    is often called “*n* choose *r*” (such as “5 choose 3”), and it’s also known as
    the *binomial coefficient*. This means that we can generate only 10 plans if we
    don’t want to repeat any of the exercises.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果不允许重复，可能的组合数将是*C*(*n*,*r*) = *n*! / *r*!(*n* – *r*)! = 5! / (3! × 2!) =
    10。这个公式通常被称为“*n*选*r*”（例如“5选3”），它也被称为二项式系数。这意味着如果我们不想重复任何练习，我们只能生成10个计划。
- en: In both combination with and without repetition, the fitness plan doesn’t include
    the order of performing the included exercises. If we respect specific order,
    the plan will take the form of a permutation. If repeating exercises is allowed,
    the number of possible permutations when selecting three of the five available
    exercises will be *n*^r = 5³ = 125. However, if repetition is not allowed, the
    number of possible permutations will be *P*(*n*,*r*) = *n*! / (*n* – *r*)! = 5!
    / (5 – 3)! = 60.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在带重复和不带重复的组合中，健身计划不包括包含的练习的执行顺序。如果我们尊重特定的顺序，计划将采取排列的形式。如果允许重复练习，选择三个可用练习的可能排列数将是*n*^r
    = 5³ = 125。然而，如果不允许重复，可能的排列数将是*P*(*n*,*r*) = *n*! / (*n* – *r*)! = 5! / (5 – 3)!
    = 60。
- en: 'Combinatorics can be implemented fairly easily in Python when coding from scratch,
    but there are excellent libraries available, such as SymPy, an open source Python
    library for symbolic mathematics. Its capabilities include, but are not limited
    to, statistics, physics, geometry, calculus, equation solving, combinatorics,
    discrete math, cryptography, and parsing. For example, the binomial coefficient
    can be calculated in SymPy using the following simple code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当从头开始编写代码时，组合学在Python中可以相当容易地实现，但也有一些优秀的库可用，例如SymPy，这是一个开源的Python符号数学库。它的功能包括但不限于统计学、物理学、几何学、微积分、方程求解、组合学、离散数学、密码学和解析。例如，可以使用以下简单的代码在SymPy中计算二项式系数：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: See appendix A and the documentation for SymPy for more on implementing combinatorics
    in Python.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于在Python中实现组合学的信息，请参阅附录A和SymPy的文档。
- en: The traveling salesman problem (TSP) is a common example of a combinational
    problem whose solution is a permutation—a sequence of cities to be visited. In
    TSP, given *n* cities, a traveling salesman must visit all the cities and then
    return home, making a loop (a round trip). The salesman would like to travel in
    the most efficient way (such as the fastest, cheapest, or shortest route).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商问题（TSP）是组合问题的一个常见例子，其解决方案是一个排列——要访问的城市序列。在TSP中，给定*n*个城市，旅行商必须访问所有城市然后返回家中，形成一个循环（往返）。旅行商希望以最有效的方式旅行（例如最快的、最便宜的或最短的路程）。
- en: TSP can be subdivided into *symmetric TSP* (STSP) and *asymmetric TSP* (ATSP).
    In STSP, the distance between two cities is the same in both directions, forming
    an undirected graph. This symmetry halves the number of possible solutions. ATSP
    is a strict generalization of the symmetric version. In ATSP, paths may not exist
    in both directions, or the distances might be different, forming a directed graph.
    Traffic collisions, one-way streets, bridges, and airfares for cities with different
    departure and arrival fees are examples of how this symmetry could break down.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TSP可以分为*对称TSP*（STSP）和*非对称TSP*（ATSP）。在STSP中，两个城市之间的距离在两个方向上是相同的，形成一个无向图。这种对称性将可能的解决方案数量减半。ATSP是对称版本的严格推广。在ATSP中，路径可能不是双向的，或者距离可能不同，形成一个有向图。交通碰撞、单行道、桥梁以及不同出发和到达费用的城市的机票价格都是这种对称性可能崩溃的例子。
- en: The search space in TSP is very large. For example, let’s assume the salesman
    is to visit the 13 major cities in the Greater Toronto Area (GTA), as illustrated
    in figure 2.2\. The naive solution’s complexity is *O*(*n*!). This means that
    there are *n*! = 13! = 6,227,020,800 possible tours in the case of ATSP. This
    is a huge search space in both STSP and ATSP. However, dynamic programming (DP)
    algorithms enable reduced complexity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TSP中的搜索空间非常大。例如，假设销售人员需要访问大多伦多地区（GTA）的13个主要城市，如图2.2所示。朴素解的复杂度是*O*(*n*!)。这意味着在ATSP的情况下，有*n*!
    = 13! = 6,227,020,800种可能的旅行路线。在STSP和ATSP中，这都是一个非常大的搜索空间。然而，动态规划（DP）算法能够降低复杂度。
- en: '![](../Images/CH02_F02_Khamis.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_Khamis.png)'
- en: Figure 2.2 TSP in the Greater Toronto Area (GTA). The traveling salesman must
    visit all 13 cities and wishes to select the “best” path, whether that be based
    on distance, time, or some other criterion.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 大多伦多地区（GTA）的TSP。旅行销售人员必须访问所有13个城市，并希望选择“最佳”路径，无论这是基于距离、时间还是其他标准。
- en: Dynamic programming is a method of solving optimization problems by breaking
    them down into smaller subproblems and solving each subproblem independently.
    For example, the complexity of the Bellman-Held-Karp algorithm [1] is *O*(2*^n*
    × *n*²). There are other solvers and algorithms with different levels of computational
    complexity and approximation ratios such as the Concorde TSP solver, the 2-opt
    and 3-opt algorithms, branch and bound algorithms, the Christofides algorithm
    (or Christofides–Serdyukov algorithm), the Lin-Kernighan algorithm, metaheuristics-based
    algorithms, graph neural networks, and deep reinforcement learning methods. For
    example, the Christofides algorithm [2] is a polynomial-time approximation algorithm
    that produces a solution to TSP that is guaranteed to be no more than 50% longer
    than the optimal solution with a time complexity of *O*(*n*³). See appendix A
    for the solution of TSP using the Christofides algorithm implemented with the
    NetworkX package. We will discuss how to solve TSP using a number of these algorithms
    throughout this book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划是一种通过将问题分解成更小的子问题并独立解决每个子问题来解决问题的方法。例如，Bellman-Held-Karp算法[1]的复杂度是*O*(2*^n*
    × *n*²)。还有其他具有不同计算复杂度和近似比率的求解器和算法，如Concorde TSP求解器、2-opt和3-opt算法、分支和界限算法、Christofides算法（或Christofides-Serdyukov算法）、Lin-Kernighan算法、基于元启发式的算法、图神经网络和深度强化学习方法。例如，Christofides算法[2]是一个多项式时间近似算法，它产生的TSP解决方案保证不会比最优解长50%，时间复杂度为*O*(*n*³)。有关使用NetworkX包实现的Christofides算法解决TSP的解决方案，请参阅附录A。我们将在本书中讨论如何使用这些算法中的许多来解决TSP。
- en: A wide range of discrete optimization problems can be modeled as TSP. These
    problems include, but are not limited to, microchip manufacturing, permutation
    flow shop scheduling, arranging school bus routes for children in a school district,
    assigning routes for airplanes, transporting farming equipment, scheduling of
    service calls, meal delivery, and routing trucks for parcel delivery and pickup.
    For example, the capacitated vehicle routing problem (CVRP) is a generalization
    of TSP where one has to serve a set of customers using a fleet of vehicles based
    at a common depot. Each customer has a certain demand for goods that are initially
    located at the depot. The task is to design vehicle routes starting and ending
    at the depot such that all customer demands are fulfilled. Later in this book,
    we’ll look at several examples of solving TSP and its variants using stochastic
    approaches.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛的离散优化问题可以建模为TSP。这些问题包括但不限于微芯片制造、排列流程车间调度、为学校区域内的儿童安排校车路线、分配飞机路线、运输农业设备、服务调用调度、餐食配送以及包裹配送和取件的卡车路线规划。例如，容量车辆路径问题（CVRP）是TSP的一种推广，其中必须使用位于一个共同仓库的车辆车队为一系列客户提供服务。每个客户对位于仓库的某些商品有一定的需求。任务是设计从仓库开始和结束的车辆路线，以满足所有客户的需求。在本书的后续章节中，我们将探讨使用随机方法解决TSP及其变体的几个示例。
- en: Problem types
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 问题类型
- en: Decision problems are foundational in the study of algorithmic complexity. Generally
    speaking, a decision problem is a type of problem that requires determining whether
    a given input satisfies a certain property or condition. This problem can be answered
    with a simple “yes” or “no.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 决策问题是算法复杂性研究的基础。一般来说，决策问题是一种需要确定给定输入是否满足某种属性或条件的类型的问题。这个问题可以用简单的“是”或“否”来回答。
- en: Decision problems are commonly classified based on their levels of complexity.
    These classes can also be applied to optimization problems, given that optimization
    problems can be converted into decision-making problems. For example, an optimization
    problem whose objective is to find an optimal or near-optimal solution within
    a feasible search space can be paraphrased as a decision-making problem that answers
    the question “Is there an optimal or a near-optimal solution within the feasible
    search space?” The answer will be “yes” or “no,” or “true” or “false”.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 决策问题通常根据其复杂度水平进行分类。这些类别也可以应用于优化问题，因为优化问题可以被转换为决策问题。例如，一个优化问题的目标是找到一个在可行搜索空间内的最优或近似最优解，可以改写为一个决策问题，回答的问题是“在可行搜索空间内是否存在最优或近似最优解？”答案将是“是”或“否”，或者“真”或“假”。
- en: A generally accepted notion of an algorithm’s efficiency is that its running
    time is polynomial. This means that the time or the computational cost to solve
    the problem can be described by a polynomial function of the size of the input
    for the algorithm. For example, in the context of TSP, the size of the input would
    typically be the number of cities that the salesperson needs to visit. Problems
    that can be solved in polynomial time are known as *tractable*. The following
    figure shows different types of problems and gives examples of commonly used benchmarks
    (toy problems) and real-life applications of each type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个算法效率的普遍接受的观点是它的运行时间是多项式。这意味着解决问题所需的时间或计算成本可以用算法输入大小的多项式函数来描述。例如，在TSP的背景下，输入的大小通常是销售人员需要访问的城市数量。可以在多项式时间内解决的问题被称为*可解的*。以下图显示了不同类型的问题，并给出了常用基准（玩具问题）和每种类型的实际应用示例。
- en: '![](../Images/CH02_F02_UN02_Khamis.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_UN02_Khamis.png)'
- en: Problem classes based on hardness and completeness. Problems can be categorized
    into NP-hard, NP-complete, NP, or P.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于难度和完整性的问题类别。问题可以被分类为NP-hard、NP-complete、NP或P。
- en: For example, a complexity class P represents all decision problems that can
    be solved in polynomial time by deterministic algorithms (i.e., algorithms that
    do not guess at a solution). The NP or nondeterministic polynomial problems are
    those whose solutions are hard to find but easy to verify and are solved by a
    nondeterministic algorithm in polynomial time. NP-complete problems are those
    that are both NP-hard and verifiable in polynomial time. Finally, a problem is
    NP-hard if it is at least as hard as the hardest problem in NP-complete. NP-hard
    problems are usually solved by approximation or heuristic solvers, as it is hard
    to find efficient exact algorithms to solve such problems.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，复杂性类 P 代表所有可以通过确定性算法（即不猜测解决方案的算法）在多项式时间内解决的问题。NP 或非确定性多项式问题是指解决方案难以找到但容易验证，并且可以通过非确定性算法在多项式时间内解决的问题。NP-complete
    问题既是 NP-hard 又可以在多项式时间内验证的问题。最后，如果一个问题是 NP-hard，那么它至少与 NP-complete 中最困难的问题一样难。NP-hard
    问题通常通过近似或启发式求解器来解决，因为找到解决此类问题的有效精确算法很困难。
- en: Clustering is a type of combinatorial problem whose solution takes the form
    of a combination where the order doesn’t matter. In clustering, given *n* objects,
    we need to group them in *k* groups (clusters) such that all objects in a single
    group or cluster have a “natural” relation to one another, and objects not in
    the same group are somehow different. This means that the objects will be grouped
    based on some similarity or dissimilarity metric.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类是一种组合问题，其解决方案的形式是一种组合，其中顺序不重要。在聚类中，给定 *n* 个对象，我们需要将它们分成 *k* 组（聚类），使得单个组或聚类中的所有对象彼此之间都有一个“自然”的关系，而不同组的对象在某种程度上是不同的。这意味着对象将根据某些相似性或差异性度量进行分组。
- en: '*Stirling numbers* can be used for counting partitions and permutations in
    combinatorial problems. Stirling numbers of the *first kind* count permutations
    according to their number of cycles, while Stirling numbers of the *second kind*
    represent the number of ways we can partition a set of objects into non-empty
    subsets. The following formula is for a Stirling number of the second kind (a
    *Stirling partition number*), and it gives the number of ways you can partition
    a set of *n* objects into *k* non-empty subsets in the context of our clustering
    problem:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*斯特林数*可以用于计数组合问题中的划分和排列。第一类斯特林数根据它们的循环数来计数排列，而第二类斯特林数表示将一组对象划分成非空子集的方法数。以下公式是第二类斯特林数（即
    *斯特林划分数*），它给出了在聚类问题的背景下，将 *n* 个对象划分成 *k* 个非空子集的方法数：'
- en: '|'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH02_F02_UN02_Khamis-EQ01.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F02_UN02_Khamis-EQ01.png)'
- en: '| 2.1 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 2.1 |'
- en: Let’s consider smart cart clustering as an example. Shopping and luggage carts
    are commonly found in shopping malls and large airports. Shoppers or travelers
    pick up these carts at designated points and leave them in arbitrary places. It
    is a considerable task to re-collect them, and it is therefore beneficial if a
    “smarter” version of these carts could draw themselves together automatically
    to the nearest assembly points, as illustrated in figure 2.3.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以智能购物车聚类为例。购物和行李车在购物中心和大型机场中很常见。购物者或旅客在指定地点取走这些购物车，并将它们随意放置。重新收集它们是一项相当艰巨的任务，因此如果这些购物车能够自动聚集到最近的集合点，就像图
    2.3 所示的那样，这将是有益的。
- en: '![](../Images/CH02_F03_Khamis.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F03_Khamis.png)'
- en: Figure 2.3 Smart cart clustering. Unused shopping or luggage carts congregate
    near designated assembly points to make collection and redistribution easier.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 智能购物车聚类。未使用的购物或行李车聚集在指定的集合点，以便于收集和重新分配。
- en: In practice, this problem is considered an NP-hard problem, as the search space
    can be very large based on the numbers of available carts and assembly points.
    To cluster these carts effectively, the centers of clustering (the *centroids*)
    must be found. The carts in each cluster will then be directed to the assembly
    point closest to the centroids.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这个问题被认为是一个 NP-hard 问题，因为基于可用购物车和集合点的数量，搜索空间可以非常大。为了有效地聚类这些购物车，必须找到聚类的中心（即
    *质心*）。然后，每个聚类中的购物车将被引导到离质心最近的集合点。
- en: 'For example, assume that 50 carts are to be clustered around four assembly
    points. This means that *n* = 50 and *k* = 4. Stirling numbers can be generated
    using the SymPy library. To do so, simply call the `stirling` function on two
    numbers, *n* and *k*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有50个车需要围绕四个装配点进行分组。这意味着 *n* = 50 和 *k* = 4。可以使用SymPy库生成斯特林数。要做到这一点，只需在两个数字
    *n* 和 *k* 上调用 `stirling` 函数：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result is 5.3 × 10^(28), and if *n* is increased to 100, the number becomes
    6.7 × 10^(58). Enumerating all possible partitions for large problems is not feasible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 5.3 × 10^(28)，如果 *n* 增加到100，这个数字变为 6.7 × 10^(58)。对于大问题，枚举所有可能的划分是不切实际的。
- en: 2.1.2 Landscape and number of objective functions
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 景观和目标函数的数量
- en: An objective function’s *landscape* represents the distribution of the function’s
    values in the feasible search space. In this landscape, you’ll find the optimal
    solution or the global minima in the lowest valley, assuming you are dealing with
    a minimization problem, or at the highest peak in the case of a maximization problem.
    According to the landscape of the objective function, if there is only one clear
    global optimal solution, the problem is *unimodal* (e.g., convex and concave functions).
    In a *multimodal* problem, more than one optimum exists. The objective function
    is called *deceptive* when the global minimum lies in a very narrow valley and
    there is also a strong local minimum with a wide basin of attraction, such that
    the value of this objective function is close to the value of an objective function
    at the global minimum [3]. Figure 2.4 is a 3D visualization of the landscapes
    of unimodal, multimodal, and deceptive functions generated using Python in the
    next listing. The complete listing is available in the GitHub repo for the book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数的 *景观* 代表函数值在可行搜索空间中的分布。在这个景观中，你会找到最优解或全局最小值在最低谷，假设你处理的是一个最小化问题，或者在高峰处，如果是最大化问题。根据目标函数的景观，如果只有一个清晰的全球最优解，则问题为
    *单峰*（例如，凸和凹函数）。在 *多峰* 问题中，存在多个最优解。当全局最小值位于一个非常狭窄的谷地，并且还存在一个具有宽吸引盆地的强局部最小值时，目标函数被称为
    *欺骗性*，这样这个目标函数的值就接近全局最小值处的目标函数值 [3]。图2.4是使用Python在下一列表中生成的单峰、多峰和欺骗性函数的3D可视化。完整的列表可在本书的GitHub仓库中找到。
- en: Listing 2.1 Examples of objective functions
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 目标函数的例子
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Unimodal function
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ① 单峰函数
- en: ② Multimodal function
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ② 多峰函数
- en: ③ Deceptive function
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 欺骗性函数
- en: '![](../Images/CH02_F04_Khamis.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F04_Khamis.png)'
- en: Figure 2.4 Unimodal, multimodal, and deceptive functions. Unimodal functions
    have one global optimum, whereas multimodal functions can have many. Deceptive
    functions contain false optima close to the value of an objective function at
    a global minimum, which can cause some algorithms to get stuck.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 单峰、多峰和欺骗性函数。单峰函数有一个全局最优解，而多峰函数可以有多个。欺骗性函数包含接近全局最小值处目标函数值的虚假最优解，这可能导致某些算法陷入困境。
- en: If the quantity to be optimized is expressed using only one objective function,
    the problem is referred to as a mono-objective or single-objective optimization
    problem (such as convex or concave functions). A multi-objective optimization
    problem specifies multiple objectives to be simultaneously optimized. Problems
    without an explicit objective function are called constraint-satisfaction problems
    (CSPs). The goal in this case is to find a solution that satisfies a given set
    of constraints.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要优化的量仅使用一个目标函数来表示，则该问题被称为单目标或单目标优化问题（例如凸或凹函数）。多目标优化问题指定了要同时优化的多个目标。没有显式目标函数的问题称为约束满足问题（CSPs）。在这种情况下，目标是找到一个满足给定约束集的解。
- en: The *n*-queen problem is an example of a CSP. In this problem, the aim is to
    put *n* queens on an *n* × *n* board with no two queens on the same row, column,
    or diagonal, as illustrated in figure 2.5\. In this 4-queen problem, there are
    5 conflicts in the first state ({Q1,Q2}, {Q1,Q3}, {Q2,Q3}, {Q2,Q4}, and {Q3,Q4}).
    After moving Q4, the number of conflicts reduces by 2, and after moving Q3, the
    number of conflicts is only 1, which is between Q1 and Q2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* 后宫问题是一个约束满足问题的例子。在这个问题中，目标是把 *n* 个皇后放在 *n* × *n* 的棋盘上，且没有两个皇后在同一行、列或对角线上，如图2.5所示。在这个4皇后问题中，初始状态下有5个冲突（{Q1,Q2},
    {Q1,Q3}, {Q2,Q3}, {Q2,Q4}, 和 {Q3,Q4}）。移动Q4后，冲突数减少2，移动Q3后，冲突数只有1，这是Q1和Q2之间的冲突。'
- en: '![](../Images/CH02_F05_Khamis.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F05_Khamis.png)'
- en: Figure 2.5 The *n*-queen problem. This problem has no objective function, only
    a set of constraints that must be satisfied.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 *n*-后问题。这个问题没有目标函数，只有必须满足的一组约束。
- en: If we keep moving or placing the pieces, we can reach the goal state where the
    number of conflicts is 0, which means that no queen could attack any other queen
    horizontally, vertically, or diagonally. The next listing is a Python implementation
    of the 4-queen problem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续移动或放置棋子，我们可以达到一个目标状态，其中冲突的数量为0，这意味着没有一枚棋后可以攻击任何其他棋后，无论是水平、垂直还是对角线方向。下面的列表展示了4后问题的Python实现。
- en: Listing 2.2 *n*-queen CSP
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 *n*-后CSP
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Create an n x n board.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个n x n棋盘。
- en: ② Check for a queen on the same row.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ② 检查同一行的棋后。
- en: ③ Check for queens on the diagonals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 检查对角线上的棋后。
- en: ④ The piece can be placed in this column.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 棋子可以放置在这个列中。
- en: ⑤ The piece cannot be placed in this column.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 棋子不能放置在这个列中。
- en: In the preceding listing, the `can_attack` function detects if a newly placed
    piece can attack a previously placed piece. A piece can attack another piece if
    it is in the same row, column, or diagonal. Figure 2.6 shows the solution obtained
    after six steps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，`can_attack`函数检测新放置的棋子是否可以攻击之前放置的棋子。如果一枚棋子在同一行、同一列或同一对角线上，它可以攻击另一枚棋子。图2.6显示了六步后获得的解决方案。
- en: '![](../Images/CH02_F06_Khamis.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F06_Khamis.png)'
- en: Figure 2.6 *n*-queen solution
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 *n*-后解决方案
- en: The first piece is trivially placed in the first position. The second piece
    must be placed either in the third or fourth position, as the first two can be
    attacked. By placing it in the third position, however, the third piece cannot
    be placed. Thus, the first piece is removed (the board is “slid” one column over),
    and we try again. This continues until a solution is found.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一枚棋子可以简单地放在第一个位置。第二枚棋子必须放在第三个或第四个位置，因为前两个位置可以被攻击。然而，将棋子放在第三个位置时，第三枚棋子就无法放置。因此，第一枚棋子被移除（棋盘“滑动”一列），然后我们再次尝试。这个过程会一直持续到找到解决方案。
- en: 'The full code for this problem, including the code used to generate visualizations,
    can be found in the code file for listing 2.2, available in the book’s GitHub
    repo. The solution algorithm is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的完整代码，包括用于生成可视化的代码，可以在列表2.2的代码文件中找到，该文件位于书的GitHub仓库中。解决方案算法如下：
- en: Moving from top to bottom in a column, the algorithm attempts to place the piece
    while avoiding conflicts. For the first column, this will default to Q1 = 0.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列中从上到下移动，算法尝试放置棋子同时避免冲突。对于第一列，这默认为Q1 = 0。
- en: Moving to the next column, if a piece cannot be placed at row 0, it will be
    placed at row 1, and so on.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到下一列，如果棋子不能放在第0行，它将被放在第1行，依此类推。
- en: When a piece has been placed, the algorithm moves to the next column.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当放置一枚棋子后，算法移动到下一列。
- en: If it is impossible to place a piece in a given column, the first column of
    the entire board is removed, and the current column is reattempted.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在给定的列中无法放置棋子，整个棋盘的第一列将被移除，然后重新尝试当前列。
- en: Constraint programming solvers available in Google OR-Tools can also be used
    to solve this *n* × *n* queen problem. The next listing shows the steps of the
    solution using OR-Tools.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Google OR-Tools中可用的约束编程求解器也可以用来解决这个*n* × *n*后问题。下面的列表展示了使用OR-Tools的解决方案步骤。
- en: Listing 2.3 Solving the *n*-queen problem using OR-Tools
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 使用OR-Tools解决*n*-后问题
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Import a constraint programming solver that uses SAT (satisfiability) methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入使用SAT（可满足性）方法的约束编程求解器。
- en: ② Set the board size for the n x n queen problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为n x n后问题设置棋盘大小。
- en: ③ Define a solver.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义求解器。
- en: ④ Define the variables. The array index represents the column, and the value
    is the row.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义变量。数组索引表示列，值表示行。
- en: '⑤ Define the constraint: all rows must be different.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义约束：所有行必须不同。
- en: ⑥ Solve the model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 解决模型。
- en: '⑦ Define the constraint: no two queens can be on the same diagonal.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 定义约束：没有两枚棋后可以位于同一对角线上。
- en: ⑧ Visualize the solution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 可视化解决方案。
- en: Running this code produces the output in figure 2.7\. More information about
    Google OR-Tools is available in appendix A.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生图2.7中的输出。有关Google OR-Tools的更多信息，请参阅附录A。
- en: '![](../Images/CH02_F07_Khamis.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F07_Khamis.png)'
- en: Figure 2.7 The *n*-queen solution using OR-Tools
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 使用OR-Tools的*n*-后解决方案
- en: 2.1.3 Constraints
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 约束
- en: Constrained problems have hard or soft constraints for equality, inequality,
    or both. Hard constraints must be satisfied, while soft constraints are nice to
    satisfy (but are not mandatory). If there are no constraints to be considered,
    aside from the boundary constraints, the problem is an unconstrained optimization
    problem.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 约束问题具有等式、不等式或两者的硬约束或软约束。硬约束必须满足，而软约束则很好满足（但不是强制性的）。如果没有需要考虑的约束，除了边界约束之外，问题就是一个无约束优化问题。
- en: Let’s revisit the ticket pricing problem introduced in section 1.3.1\. There
    is a wide range of derivative-based solvers in Python that can handle such kinds
    of differentiable mathematical optimization problems (see appendix A). The next
    listing shows how you can solve this simple ticket pricing problem using SciPy.
    SciPy is a library containing valuable tools for all things computation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在1.3.1节中引入的门票定价问题。Python中有许多基于导数的求解器可以处理这类可微数学优化问题（参见附录A）。下面的列表显示了如何使用SciPy解决这个简单的门票定价问题。SciPy是一个包含所有计算工具的宝贵库。
- en: Listing 2.4 Optimal ticket pricing
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 门票定价优化
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① The objective function, required by minimize_scalar to be a minimization function
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ① 目标函数，由 minimize_scalar 所需的最小化函数
- en: ② The bounded method is the constrained minimization procedure that finds the
    solution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ② 有界方法是寻找解的约束最小化过程。
- en: 'Running this code produces the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code finds the optimal ticket price in the range between $0 and $250 that
    maximizes the profit. As you may have noticed, the profit formula is converted
    into a minimization problem by adding a negative sign in the objective function
    to match with the `minimize` function in `scipy.optimize`. A minus sign is added
    in the `print` function to convert it back into profit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在0到250美元的范围内找到最优门票价格，以最大化利润。如您所注意到的，利润公式通过在目标函数中添加负号转换为最小化问题，以匹配 `scipy.optimize`
    中的 `minimize` 函数。在 `print` 函数中添加负号，将其转换回利润。
- en: 'What if we imposed an equality constraint on this problem? Let’s assume that
    due to incredible international demand for our event, we are now considering using
    a different event planning company and opening up virtual attendance for our conference
    so that international guests can also participate. Interested participants can
    now choose between attending the event in person or joining via a live stream.
    All participants, whether in-person or virtual, will receive a physical welcome
    package, which is limited to 10,000 units. Thus, in order to ensure a “full” event,
    we must either sell 10,000 in-person tickets, 10,000 virtual tickets, or some
    combination thereof. The new event company is charging us a $1,000,000 flat rate
    for the event, so we want to sell as many tickets as possible (exactly 10,000).
    The following equation is associated with this problem:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这个问题施加一个等式约束会怎样呢？假设由于对我们活动的国际需求难以置信，我们现在正在考虑使用不同的活动策划公司，并为我们的会议开放虚拟参会，以便国际客人也能参加。感兴趣的参与者现在可以选择亲自参加活动或通过直播加入。所有参与者，无论是亲自参加还是虚拟参加，都将收到一个实物欢迎礼包，该礼包限量10,000份。因此，为了确保活动“满员”，我们必须要么卖出10,000张亲自参加的门票，要么卖出10,000张虚拟门票，或者两者的组合。新的活动公司对我们活动的收费是100万美元的固定费用，因此我们希望卖出尽可能多的门票（正好是10,000张）。与这个问题相关联的以下方程式：
- en: Let *x* be the number of physical ticket sales, and let *y* be the number of
    virtual ticket sales. Additionally, let *f*(*x*,*y*) be the function for profits
    generated from the event, where
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *x* 为实物门票销售数量，设 *y* 为虚拟门票销售数量。此外，设 *f*(*x*,*y*) 为从活动产生的利润函数，其中
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH02_F07_Khamis-EQ02.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F07_Khamis-EQ02.png)'
- en: '| 2.2 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 2.2 |'
- en: Essentially, we earn $155 profit on in-person attendance, and the profit for
    online attendance is $70, but it increases by some amount with the more physical
    attendance we have (let’s say that as the event looks “more crowded,” we can charge
    more for online attendees).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们通过亲自参加获得155美元的利润，而在线参加的利润是70美元，但随着我们拥有的实物参加人数的增加而增加（让我们假设，当活动看起来“更拥挤”时，我们可以对在线参与者收取更高的费用）。
- en: Suppose we add a constraint function, *x* + *y* ≤ 10000, which shows that the
    combined ticket sales cannot exceed 10,000\. The problem is now a bivariate mono-objective
    constrained optimization problem. It is possible to convert this constrained optimization
    problem to an unconstrained optimization using the Lagrange multiplier, λ. We
    can use SymPy to implement Lagrange multipliers and solve for the optimal mix
    of virtual and physical ticket sales. The idea is to convert the constrained optimization
    problem defined by the objective function *f*(*x*,*y*) with an equality constraint
    *g*(*x*,*y*) into an unconstrained optimization problem using the Lagrangian function
    *L*(*x*,y,λ) = *f*(*x*,*y*) + *λg*(*x*,*y*). This function combines an objective
    function and constraints, enabling constrained optimization problems to be formulated
    as unconstrained problems through the use of Lagrange multipliers. To do so, we
    take the partial derivatives of the objective functions and the constraints, with
    respect to the decision variables *x* and *y*, to form the unconstrained optimization
    equations to be used by the SymPy solver, as illustrated in figure 2.8.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们添加一个约束函数，*x* + *y* ≤ 10000，这表明组合票销售不能超过 10,000。现在问题变成了一个双变量单目标约束优化问题。可以使用拉格朗日乘数
    λ 将这个约束优化问题转换为无约束优化。我们可以使用 SymPy 实现拉格朗日乘数并求解虚拟和实物票销售的优化组合。思路是将由目标函数 *f*(*x*,*y*)
    和等式约束 *g*(*x*,*y*) 定义的约束优化问题转换为使用拉格朗日函数 *L*(*x*,y,λ) = *f*(*x*,*y*) + *λg*(*x*,*y*)
    的无约束优化问题。这个函数结合了目标函数和约束条件，使得可以通过使用拉格朗日乘数将约束优化问题表述为无约束问题。为此，我们取目标函数和约束条件关于决策变量
    *x* 和 *y* 的偏导数，以形成 SymPy 求解器使用的无约束优化方程，如图 2.8 所示。
- en: '![](../Images/CH02_F08_Khamis.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F08_Khamis.png)'
- en: Figure 2.8 Steps for solving the ticket pricing problem using the Lagrange method
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 使用拉格朗日方法解决票价问题的步骤
- en: The next listing shows the Python implementation using SymPy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了使用 SymPy 的 Python 实现。
- en: Listing 2.5 Maximizing profits using Lagrange multipliers
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 使用拉格朗日乘数最大化利润
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Define the decision variables.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义决策变量。
- en: ② Define the ticket pricing objective function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义票价目标函数。
- en: ③ Define the equality constraint.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义等式约束。
- en: ④ Lagrange multiplier
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 拉格朗日乘数
- en: ⑤ Lagrangian function
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 拉格朗日函数
- en: ⑥ Equations to the solver
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 方程式求解器
- en: ⑦ Solve these three equations in three variables (x,y,lambda) using SymPy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用 SymPy 在三个变量（x,y,lambda）中求解这三个方程。
- en: By solving the preceding three equations, we get *x* and *y* values that correspond
    to the optimized quantities for virtual and physical ticket sales. With the code
    in listing 2.5, we can see that the best result is to sell 6,424 in-person tickets
    and 3,576 online tickets. This results in a maximum profit of $2,087,260.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过求解前面的三个方程，我们得到 *x* 和 *y* 的值，这些值对应于虚拟和实物票销售的优化数量。通过列表 2.5 中的代码，我们可以看到最佳结果是销售
    6,424 张现场票和 3,576 张在线票。这导致最大利润为 $2,087,260。
- en: 2.1.4 Linearity of objective functions and constraints
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 目标函数和约束条件的线性
- en: If all the objective functions and associated constraint conditions are linear,
    the optimization problem is categorized as a *linear optimization problem* or
    *linear programming problem* (LPP or LP), where the goal is to find the optimal
    value of a linear function subject to linear constraints. Blending problems are
    a typical application of mixed integer linear programming (MILP), where a number
    of ingredients are to be blended or mixed to obtain a product with certain characteristics
    or properties. In the animal feed mix problem described in Paul Jensen’s *Operations
    Research Models and Methods* [4], the optimum amounts of three ingredients in
    an animal feed mix need to be determined. The possible ingredients, their nutritive
    contents (in kilograms of nutrient per kilograms of ingredient), and the unit
    costs are shown in table 2.1.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有目标函数和相关约束条件都是线性的，则优化问题被归类为 *线性优化问题* 或 *线性规划问题*（LPP 或 LP），其目标是找到在线性约束下线性函数的最优值。混合问题是混合整数线性规划（MILP）的典型应用，其中需要将多种成分混合或混合以获得具有特定特性或属性的产品。在保罗·詹森的《运筹学模型与方法》[4]中描述的动物饲料混合问题中，需要确定动物饲料混合中三种成分的最佳数量。可能的成分、它们的营养含量（每千克成分的营养千克数）和单位成本如表
    2.1 所示。
- en: Table 2.1 Animal feed mix problem
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 动物饲料混合问题
- en: '| Ingredients | Nutritive content and price of ingredients |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 成分 | 成分营养含量和价格 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Calcium (kg/kg) | Protein (kg/kg) | Fiber (kg/kg) | Unit cost (cents/kg)
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 钙（kg/kg） | 蛋白质（kg/kg） | 纤维（kg/kg） | 单位成本（美分/kg） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Corn | 0.001 | 0.09 | 0.02 | 30.5 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 玉米 | 0.001 | 0.09 | 0.02 | 30.5 |'
- en: '| Limestone | 0.38 | 0.0 | 0.0 | 10.0 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 石灰石 | 0.38 | 0.0 | 0.0 | 10.0 |'
- en: '| Soybean meal | 0.002 | 0.50 | 0.08 | 90.0 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 大豆粕 | 0.002 | 0.50 | 0.08 | 90.0 |'
- en: 'The mixture must meet the following restrictions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 混合物必须满足以下限制条件：
- en: Calcium—At least 0.8% but not more than 1.2%
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钙含量——至少 0.8%，但不超过 1.2%
- en: Protein—At least 22%
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋白质——至少 22%
- en: Fiber—At most 5%
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纤维——最多 5%
- en: The problem is to find the mixture that satisfies these constraints while minimizing
    cost. The decision variables are *x*[1], *x*[2], and *x*[3], which are proportions
    of limestone, corn, and soybean meal respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是要找到满足这些约束条件的同时最小化成本的最佳混合物。决策变量是 *x*[1]、*x*[2] 和 *x*[3]，分别代表石灰石、玉米和大豆粕的比例。
- en: 'The objective function *f* = 30.5*x*[1] + 10*x*[2] + 90*x*[3] needs to be minimized,
    subject to the following constraints:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数 *f* = 30.5*x*[1] + 10*x*[2] + 90*x*[3] 需要被最小化，同时满足以下约束条件：
- en: 'Calcium limits: 0.008 ≤ 0.001*x*[1] + 0.38*x*[2] + 0.002*x*[3] ≤ 0.012'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钙含量限制：0.008 ≤ 0.001*x*[1] + 0.38*x*[2] + 0.002*x*[3] ≤ 0.012
- en: 'Protein constraint: 0.09*x*[1] + 0.5*x*[3] ≥ 0.22'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋白质约束：0.09*x*[1] + 0.5*x*[3] ≥ 0.22
- en: 'Fiber constraint: 0.02*x*[1] + 0.08*x*[3] <= 0.05'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纤维约束：0.02*x*[1] + 0.08*x*[3] <= 0.05
- en: 'Non-negativity restriction: *x*[1], *x*[2], *x*[2] ≥ 0'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非负性限制：*x*[1]、*x*[2]、*x*[2] ≥ 0
- en: 'Conservation: *x*[1] + *x*[2] + *x*[2] = 1'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保守性：*x*[1] + *x*[2] + *x*[2] = 1
- en: In this problem, both the objective function and the constraints are linear,
    so it is an LPP. There are several Python libraries that can be used to solve
    mathematical optimization problems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，目标函数和约束条件都是线性的，因此它是一个线性规划问题。有几个 Python 库可以用来解决数学优化问题。
- en: We’ll try solving the animal feed mix problem using PuLP. PuLP is a Python linear
    programming library that allows users to define linear programming problems and
    solve them using optimization algorithms such as COIN-OR’s linear and integer
    programming solvers. See appendix A for more information about PuLP and other
    mathematical programming solvers. The next listing shows the steps for solving
    the animal feed mix problem using PuLP.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用 PuLP 解决动物饲料混合问题。PuLP 是一个 Python 线性规划库，允许用户定义线性规划问题并使用优化算法（如 COIN-OR
    的线性整数规划求解器）来解决问题。有关 PuLP 和其他数学规划求解器的更多信息，请参阅附录 A。下一个列表显示了使用 PuLP 解决动物饲料混合问题的步骤。
- en: Listing 2.6 Solving a linear programming problem using PuLP
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 使用 PuLP 解决线性规划问题
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Create a linear programming model.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个线性规划模型。
- en: ② Define three variables that represent the percentages of corn, limestone,
    and soybean meal in the mixture.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义三个变量，代表混合物中玉米、石灰石和大豆粕的百分比。
- en: ③ Define the total cost as theobjective function to be minimized.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将总成本定义为要最小化的目标函数。
- en: ④ Add the constraints.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 添加约束条件。
- en: ⑤ Solve the problem using PuLP’s choice of solver.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用 PuLP 的选择求解器解决问题。
- en: ⑥ Print the results (the optimal percentages of the ingredients and the cost
    of the mixture per kg)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印结果（原料的最佳百分比和每公斤混合物的成本）
- en: 'As you can see in this listing, we start by importing PuLP and creating a model
    as a linear programming problem. We then define LP variables with the associated
    parameters, such as name, lower bound, and upper bound for each variable’s range
    and the type of variable (e.g., integer, binary, or continuous). A solver is then
    used to solve the problem. PuLP supports several solvers, such as GLPK, GUROBI,
    CPLEX, and MOSEK. The default solver in PuLP is Cbc (COIN-OR branch and cut).
    Running this code gives the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如此列表所示，我们首先导入 PuLP 并创建一个作为线性规划问题的模型。然后定义与每个变量相关的参数，例如变量的名称、范围的下限和上限以及变量的类型（例如，整数、二元或连续）。然后使用求解器来解决问题。PuLP
    支持多个求解器，如 GLPK、GUROBI、CPLEX 和 MOSEK。PuLP 的默认求解器是 Cbc（COIN-OR 分支和切割）。运行此代码将给出以下输出：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If one of the objective functions, or at least one of the constraints, is nonlinear,
    the problem is considered a nonlinear optimization problem or nonlinear programming
    problem (NLP), and it’s harder to solve than a linear problem. A special case
    of NLP, when the objective function is quadratic, is called quadratic programming
    (QP). For example, the plant layout problem (PLP) or facility location problem
    (FLP) is a quadratic assignment problem (QAP) that aims at assigning different
    facilities (departments) *F* to different locations *L* in order to minimize a
    given function cost, such as the total material handling cost, as shown in figure
    2.9\.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH02_F09_Khamis.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 Plant layout problem—what is the optimal location for each department
    that minimizes the overall material handling costs?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Assume that ω[ij] is the frequency of interaction or the flow of products between
    these facilities and *d[f(i)f(j)]* is the distance between facilities *i* and
    *j*. The material handling cost (MHC) is
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '| MHC[ij] = flow × distance = 𝜔[ij] × *d[f]*[(]*[i]*[)]*[f]*[(]*[j]*[)] | 2.3
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: and the total material handling cost (TMHC) is the summation of all the material
    handling costs inside the material handling cost matrix. In matrix notation, the
    problem can be formulated as
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Find *X* which minimizes *trace*(*WXDX^T*)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: where *X* represents the assignment vector, *W* is the flow matrix, and *D*
    is the distance matrix. Trace is the sum of elements on the main diagonal (from
    the upper left to the lower right) of the resultant material handling cost matrix.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In a more general case, NLP includes nonlinear objective functions, or at least
    nonlinear constraints, of any form. For example, imagine you’re designing a landmine
    detection and disposal unmanned ground vehicle (UGV) [5]. In outdoor applications
    like humanitarian demining, UGVs should be able to navigate through rough terrain.
    Sandy soils, rocky terrain with obstacles, steep inclines, ditches, and culverts
    can be difficult for vehicles to negotiate. The locomotion systems of such vehicles
    need to carefully designed to guarantee motion fluidity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Assume that you are in charge of finding optimal values for wheel parameters
    (e.g., diameter, width, and loading) that will
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Minimize the wheel sinkage, which is the maximum amount the wheel sinks in the
    soil that it is moving on
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize motion resistance, which is the overall resistance faced by the UGV
    unit due to the different components of resistance (compaction, gravitational,
    etc.)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize drive torque, which is the driving torque required from the actuating
    motors for each wheel
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize drive power, which is the driving power required from the actuating
    motors for each wheel
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximize the slope negotiability, which represents the maximum slope that can
    be climbed by the UGV unit considering its weight and the soil parameters.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to availability in the market or manufacturing concerns and costs, the
    wheel diameter should be in the range of 4 to 8.2 inches, wheel width should be
    in the range of 3 to 5 inches, and wheel loading should be in the range of 22
    to 24 pounds per wheel. This wheel design problem (figure 2.10) can be stated
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于市场供应或制造方面的考虑和成本，轮径应在 4 至 8.2 英寸的范围内，轮宽应在 3 至 5 英寸的范围内，轮载应在每轮 22 至 24 磅的范围内。这个轮设计问题（图
    2.10）可以表述如下：
- en: Find *X* which optimizes *ƒ*, subject to a possible set of boundary constraints,
    where *X* is a vector that is composed of a number of decision variables such
    as
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 *X*，使其优化 *ƒ*，同时满足一组可能的边界约束，其中 *X* 是由多个决策变量组成的向量，例如
- en: '*x*[1] = wheel diameter, *x*[1] ∈ [4, 8.2]'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*[1] = 轮径，*x*[1] ∈ [4, 8.2]'
- en: '*x*[2] = wheel width, *x*[2] ∈ [3, 5]'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*[2] = 轮宽，*x*[2] ∈ [3, 5]'
- en: '*x*[3] = wheel loading, *x*[2] ∈ [22, 24]'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*[3] = 轮载，*x*[2] ∈ [22, 24]'
- en: 'We can also consider the objective functions *ƒ*={*ƒ*[1], *ƒ*[2],…}. For example,
    the function for wheel sinkage might look like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以考虑目标函数 *ƒ*={*ƒ*[1]，*ƒ*[2]，…}。例如，轮沉降的函数可能看起来像这样：
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH02_F09_Khamis-EQ05.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F09_Khamis-EQ05.png)'
- en: '| 2.4 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 2.4 |'
- en: where *n* is the exponent of sinkage, *k*[c] is the cohesive modulus of soil
    deformation, and *k*[φ] is the frictional modulus of soil deformation. This problem
    is considered to be nonlinear because the objective function is nonlinear.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *n* 是沉降的指数，*k*[c] 是土壤变形的粘聚力模量，*k*[φ] 是土壤变形的摩擦模量。这个问题被认为是非线性的，因为目标函数是非线性的。
- en: '![](../Images/CH02_F10_Khamis.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F10_Khamis.png)'
- en: Figure 2.10 The MineProbe wheel design problem [5]
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 MineProbe 轮设计问题 [5]
- en: The catenary problem discussed in Veselić’s “Finite catenary and the method
    of Lagrange” article [6] is another example of a nonlinear optimization problem.
    A catenary is a flexible hanging object composed of multiple parts, such as a
    chain or telephone cable (figure 2.11). In this problem, we are provided with
    *n* homogenous beams, with lengths *d*[1], *d*[2], … *d*[n] > 0 and masses *m*[1],
    *m*[2], … *m*[n] > 0, which are connected by *n* + 1 joints *G*[0], *G*[2], …
    *G*[n] [+ 1]. The location of each joint is represented by the Cartesian coordinates
    (*x[i]*,*y[i]*,*z[i]*). The ends of the catenary are *G*[0] and *G*[n] [+ 1],
    which both have the same *y* and *z* values (they are at the same height and in
    line with each other).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Veselić 在“有限悬链线和拉格朗日方法”文章 [6] 中讨论的悬链线问题是一个非线性优化问题的另一个例子。悬链线是由多个部分组成的柔性悬挂物体，如链条或电话线（图
    2.11）。在这个问题中，我们提供了 *n* 个同质梁，长度为 *d*[1]，*d*[2]，… *d*[n] > 0，质量为 *m*[1]，*m*[2]，…
    *m*[n] > 0，它们通过 *n* + 1 个节点 *G*[0]，*G*[2]，… *G*[n] [+ 1] 连接。每个节点的位置由笛卡尔坐标 (*x[i]*,*y[i]*,*z[i]*)
    表示。悬链线的两端是 *G*[0] 和 *G*[n] [+ 1]，它们都具有相同的 *y* 和 *z* 值（它们在同一高度上，并且彼此对齐）。
- en: '![](../Images/CH02_F11_Khamis.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F11_Khamis.png)'
- en: Figure 2.11 Finite catenary problem—the catenary (or chain) is suspended from
    two points, G[0] and G[n] [+ 1].
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 有限悬链线问题——悬链线（或链条）从两个点 G[0] 和 G[n] [+ 1] 悬挂。
- en: 'Assuming that the beam lengths and masses are predefined parameters, our goal
    is to look for stable equilibrium positions in the field of gravity—those positions
    where the potential energy is minimized. The potential energy to be minimized
    is defined as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设梁长和质量是预定义的参数，我们的目标是寻找重力场中的稳定平衡位置——那些使势能最小化的位置。要最小化的势能定义如下：
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH02_F11_Khamis-EQ06.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F11_Khamis-EQ06.png)'
- en: '| 2.5 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 2.5 |'
- en: 'subject to the following constraints:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 满足以下约束条件：
- en: '|'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH02_F11_Khamis-EQ07.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F11_Khamis-EQ07.png)'
- en: '| 2.6 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 2.6 |'
- en: where *γ* is the gravitational constant. The nonlinearity of the constraints
    makes this problem nonlinear, despite having a linear objective function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *γ* 是重力常数。尽管目标函数是线性的，但约束的非线性使得这个问题是非线性的。
- en: 2.1.5 Expected quality and permissible time for the solution
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 解决方案的期望质量和允许时间
- en: 'Optimization problems can also be categorized according to the expected quality
    of the solutions and the time allowed to find the solutions. Figure 2.12 shows
    three main types of problems: design problems (strategic functions), planning
    problems (tactical functions), and control problems (operational functions).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题也可以根据期望的解决方案质量和找到解决方案所允许的时间进行分类。图 2.12 展示了三种主要类型的问题：设计问题（战略函数）、计划问题（战术函数）和控制问题（操作函数）。
- en: '![](../Images/CH02_F12_Khamis.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F12_Khamis.png)'
- en: Figure 2.12 Qualities of solutions vs. search time. Some types of problems require
    fast computations but do not require incredibly accurate results, while others
    (such as design problems) allow more processing time in return for higher accuracy.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 解决方案的质量与搜索时间的关系。某些类型的问题需要快速计算，但不需要极其精确的结果，而其他问题（如设计问题）则可以通过更长的处理时间来换取更高的精度。
- en: In *design problems*, time is not as important as the quality of the solution,
    and users are willing to wait (sometimes even a few days) to get an optimal, or
    near-optimal, result. These problems can be solved offline, and the optimization
    process is usually carried out only once in a long time. Examples of design problems
    include vehicle design, class scheduling, asset allocation, resource planning,
    assembly line balancing, inventory management, flight scheduling, and political
    districting.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在*设计问题*中，时间并不像解决方案的质量那样重要，用户愿意等待（有时甚至几天）以获得最优或近似最优的结果。这些问题可以在离线状态下解决，并且优化过程通常在很长时间内只进行一次。设计问题的例子包括车辆设计、课程安排、资产分配、资源规划、生产线平衡、库存管理、航班安排和政治区域划分。
- en: 'Let’s discuss political districting as a design problem in more detail. Districting
    is the problem of grouping small geographic areas, called *basic units*, into
    larger geographic clusters, called *districts*, in such a way that the latter
    are acceptable according to relevant planning criteria [7]. Typical examples of
    basic units are customers, streets, or zip code areas. The planning criteria may
    include the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论政治区域划分作为设计问题。区域划分是将称为*基本单元*的小地理区域分组到称为*区域*的较大地理集群中的问题，以便后者根据相关规划标准[7]是可接受的。基本单元的典型例子是客户、街道或邮政编码区域。规划标准可能包括以下内容：
- en: Balance or equity in terms of demographic background, equitable size, balanced
    workload, equal sales potential, or the number of customers
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在人口背景、公平规模、平衡工作量、相等销售潜力或客户数量方面的平衡或公平
- en: Contiguity to enable traveling between the basic units of the district without
    having to leave the district
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续性，以便在无需离开区域的情况下在区域的基本单元之间旅行
- en: Compactness to allow for round- or square-shaped undistorted districts without
    holes
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧凑性，以便在不产生空洞的情况下允许圆形或方形无畸变的区域
- en: Respect of boundaries, such as administrative boundaries, railroads, rivers,
    or mountains
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尊重边界，例如行政边界、铁路、河流或山脉
- en: Socio-economic heterogeneity, to allow for better representation of residents
    with different incomes, ethnicities, concerns, or views
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社会经济异质性，以便更好地代表不同收入、民族、关注点或观点的居民
- en: Political districting, school districting, districting for health services,
    districting for EV charging stations, districting for micro-mobility stations
    (e.g., for e-bikes and e-scooters), and districting for sales or delivery are
    all examples of districting problems.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 政治区域划分、学区划分、健康服务区域划分、电动汽车充电站区域划分、微型移动站点（例如，电动自行车和电动滑板车）区域划分以及销售或配送区域划分都是区域划分问题的例子。
- en: Political districting is a problem that has plagued societies since the advent
    of representative democracy in the Roman Republic. In a representative democracy,
    officials are nominated and elected to represent the interests of the people who
    elected them. In order to have a greater say when deciding on matters that concern
    the entire state, the party system came about, which defines political platforms
    that nominees use to differentiate themselves from their competitors. Manipulating
    the shapes of electoral districts to determine the outcome of elections is called
    *gerrymandering* (named after the early nineteenth century Massachusetts governor
    Elbridge Gerry who redrew the map of the Senate’s districts in 1810 in order to
    weaken the opposing federalist party). Figure 2.13 shows how manipulating the
    shapes of the districts can sway the vote in favor of a decision that otherwise
    wouldn’t have won.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 政治区域划分是自罗马共和国代表民主制度出现以来一直困扰着社会的问题。在代表民主制度中，官员被提名和选举出来代表选举他们的民众的利益。为了在决定涉及整个国家的事务时拥有更大的发言权，出现了政党制度，该制度定义了候选人用来与竞争对手区分自己的政治平台。操纵选举区的形状以决定选举结果的行为被称为*操纵选区*（以19世纪初的马萨诸塞州州长Elbridge
    Gerry命名，他在1810年重新绘制了参议院的区域地图，以削弱反对联邦党的力量）。图2.13显示了如何通过操纵区域的形状来使投票偏向于一个本不会获胜的决定。
- en: '![](../Images/CH02_F13_Khamis.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F13_Khamis.png)'
- en: Figure 2.13 Example of gerrymandering. The two major political parties, Shield
    and Bell, try to gain an advantage by manipulating the district boundaries to
    suppress undesired interests and promote their own.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 选举操纵的例子。两个主要政党，盾牌和钟铃，试图通过操纵选区边界来获得优势，压制不希望的利益并促进自己的利益。
- en: An effective and transparent political districting strategy is needed to avoid
    gerrymandering and generate a solution that preserves the integrity of individual
    subdistricts and divides the population into almost equal voting populations in
    a reproducible way. In many countries, electoral districts are reviewed from time
    to time to reflect changes and movements in the country’s population. For example,
    the Constitution of Canada requires that federal electoral districts be reviewed
    after each 10-year census.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个有效且透明的政治选区划分策略，以避免选举操纵并生成一个在可重复的方式下保护个别子区完整性并将人口划分为几乎相等的投票人口的解决方案。在许多国家，选区会定期审查，以反映国家人口的变化和流动。例如，加拿大的宪法要求在每10年的人口普查后审查联邦选区。
- en: Political districting is defined as aggregating *n* subregions of a territory
    into *m* electoral districts subject to constraints such as
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 政治选区划分是指将一个领土的 *n* 个子区域聚合为 *m* 个选区，并受到诸如
- en: The districts should have near-equal voting population.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选区应具有近乎相等的投票人口。
- en: The socioeconomic homogeneity inside each district, as well as the integrity
    of different communities, should be maximized.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个选区内的社会经济同质性以及不同社区的完整性应最大化。
- en: The districts have to be compact, and the subregions of each district have to
    be contiguous.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选区必须紧凑，每个选区的子区域必须连续。
- en: Subregions should be considered as indivisible political units, and their boundaries
    should be respected.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将子区域视为不可分割的政治单位，并尊重其边界。
- en: 'The problem can be formulated as an optimization problem in which a function
    that quantifies the preceding factors is maximized. Here is an example of this
    function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题可以表述为一个优化问题，其中最大化一个量化上述因素的函数。以下是这个函数的一个例子：
- en: '| *F*(*x*) = *α*[pop]*ƒ*[pop](*x*) + *α*[comp]*ƒ*[comp](*x*) + *α*[soc]*ƒ*[soc](*x*)
    + *α*[sim]*ƒ*[sim](*x*) | 2.7 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| *F*(*x*) = *α*[pop]*ƒ*[pop](*x*) + *α*[comp]*ƒ*[comp](*x*) + *α*[soc]*ƒ*[soc](*x*)
    + *α*[sim]*ƒ*[sim](*x*) | 2.7 |'
- en: where *x* is a solution to the problem or the electoral districts, α[i] are
    user-specified multipliers 0 ≤ α[i] ≤ 1, and *ƒ*[pop], *ƒ*[comp], *ƒ*[soc], *ƒ*[int],
    and *ƒ*[sim] are functions that quantify the population equality, compactness
    of districts, socioeconomic homogeneity, integrity of different communities, and
    similarity to existing districts respectively. In the upcoming chapters, I will
    show you how we can use offline optimization algorithms to handle optimal multicriteria
    assignment design problems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *x* 是问题的解决方案或选区，α[i] 是用户指定的乘数 0 ≤ α[i] ≤ 1，而 *ƒ*[pop]、*ƒ*[comp]、*ƒ*[soc]、*ƒ*[int]
    和 *ƒ*[sim] 是量化人口平等、选区紧凑性、社会经济同质性、不同社区完整性和与现有选区的相似性的函数。在接下来的章节中，我将向您展示我们如何使用离线优化算法来处理最优多标准分配设计问题。
- en: '*Planning problems* need to be solved faster than design problems, in a time
    span from a few seconds to a few minutes. To find a solution in such a short time,
    optimality is usually traded for speed. Examples of planning problems include
    vehicle motion planning, emergency vehicle dispatching and routing, patient admission
    scheduling, surgery scheduling, and crew scheduling. Let’s consider the ride-sharing
    problem as an example of a planning problem.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*规划问题*需要比设计问题更快地解决，时间跨度从几秒到几分钟。要在如此短的时间内找到解决方案，通常需要牺牲最优性以换取速度。规划问题的例子包括车辆运动规划、紧急车辆调度和路线规划、患者入院安排、手术安排以及机组人员安排。让我们以拼车问题作为一个规划问题的例子。'
- en: Ride-sharing involves a fleet of pay-per-use vehicles and a set of passengers
    with predefined pick-up and drop-off points (figure 2.14). The dispatch service
    needs to assign a set of passengers in a specific order to each driver to achieve
    a set of objectives. This ride-sharing problem is a multi-objective constrained
    optimization problem. A noncomprehensive list of optimization goals for ride-sharing
    includes
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 拼车涉及一支按使用付费的车辆车队和一组具有预定义的接车和下车点的乘客（图2.14）。调度服务需要按照特定顺序为每位司机分配一组乘客，以实现一系列目标。这个拼车问题是一个多目标约束优化问题。拼车优化的非详尽列表包括
- en: Minimizing the total travel distance or time of drivers’ trips
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化驾驶员行程的总旅行距离或时间
- en: Minimizing the total travel time of passengers’ trips
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化乘客行程的总旅行时间
- en: Maximizing the number of matched (served) requests
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化匹配（服务）请求的数量
- en: Minimizing the cost of the drivers’ trips
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化司机行程的成本
- en: Minimizing the cost of the passengers’ trips
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化乘客行程的成本
- en: Maximizing the drivers’ earnings
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化司机的收入
- en: Minimizing passengers’ waiting time
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化乘客的等待时间
- en: Minimizing the total number of drivers required
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化所需的司机总数
- en: '![](../Images/CH02_F14_Khamis.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F14_Khamis.png)'
- en: Figure 2.14 Ride-sharing problem—this planning problem needs to be solved in
    a shorter amount of time, as delays could mean lost trips and a bad user experience.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 共享出行问题——这个规划问题需要在更短的时间内解决，因为延误可能导致行程丢失和糟糕的用户体验。
- en: For the ride-sharing problem, both the search time and the quality of the solutions
    are important. On many popular ride-sharing platforms, dozens if not hundreds
    of users may simultaneously be searching for rides at the same place in a given
    district. Overly costly and time-consuming solutions would lead to higher operating
    costs (i.e., employing more drivers than necessary or calling in drivers from
    other districts) as well as the potential for lost business (bad user experiences
    may dissuade passengers from using the platform a second time) and high driver
    turnover.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享出行问题，搜索时间和解决方案的质量都很重要。在许多流行的共享出行平台上，数十甚至数百名用户可能同时在同一地区的同一地点寻找乘车。过于昂贵和耗时解决方案会导致更高的运营成本（即雇佣比必要的更多司机或从其他地区调用司机）以及潜在的业务损失（糟糕的用户体验可能会阻止乘客再次使用该平台）和高司机流失率。
- en: In practice, the assignment of drivers to passengers goes well beyond the distance
    between passenger and driver—it may also include factors such as driver reliability,
    passenger rating, vehicle type, and pickup and destination location types. For
    example, a customer going to the airport may request a larger vehicle to accommodate
    luggage. In the upcoming chapters, we will discuss how to solve planning problems
    using different search and optimization algorithms.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，司机分配给乘客的任务远远超出了乘客与司机之间的距离——它可能还包括诸如司机可靠性、乘客评分、车辆类型以及接车和目的地位置类型等因素。例如，前往机场的客户可能要求一辆更大的车辆来容纳行李。在接下来的章节中，我们将讨论如何使用不同的搜索和优化算法来解决规划问题。
- en: '*Control problems* require very fast solutions in real time. In most cases,
    this means a time span from a millisecond to a few seconds. Vehicle lateral or
    longitudinal motion control, surgical robot motion control, disruptions management,
    and ad hoc communication relaying are examples of control problems. Online optimization
    algorithms are required to handle these kinds of problems. Optimization tasks
    in both planning and control problems are often carried out repetitively—new orders
    will, for instance, continuously arrive in a production facility and need to be
    scheduled to machines in a way that minimizes the waiting time for all jobs.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制问题*需要非常快速的实时解决方案。在大多数情况下，这意味着从毫秒到几秒的时间跨度。车辆横向或纵向运动控制、手术机器人运动控制、中断管理以及临时通信中继都是控制问题的例子。需要在线优化算法来处理这些问题。规划和控制问题中的优化任务通常需要重复执行——例如，新订单将不断到达生产设施，需要以最小化所有工作的等待时间为方式安排到机器上。'
- en: 'Imagine a real-world situation where a swarm of unmanned aerial vehicles (UAVs)
    or micro aerial vehicles (MAVs) is deployed to search for victims trapped on untraversable
    terrain after a natural disaster, like an earthquake, avalanche, tsunami, tornado,
    wildfire, etc. The mission consists of two phases: a search phase and a relay
    phase. During the search phase, the MAVs will conduct a search according to the
    deployment algorithm. When a target is found, the swarm of MAVs will self-organize
    to utilize their range-limited communication capabilities and set up an ad hoc
    communication relay network between the victim and the base station, as illustrated
    in figure 2.15.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个现实世界的情况，其中一群无人机（UAV）或微型空中车辆（MAV）被部署在自然灾害（如地震、雪崩、海啸、龙卷风、野火等）后搜索被困在不可通行的地形上的受害者。任务分为两个阶段：搜索阶段和接力阶段。在搜索阶段，MAV将根据部署算法进行搜索。当发现目标时，MAV群将自我组织，利用它们有限的通信能力，在受害者和基站之间建立一个临时的通信中继网络，如图2.15所示。
- en: '![](../Images/CH02_F15_Khamis.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F15_Khamis.png)'
- en: Figure 2.15 Communication relaying problem—a swarm of MAVs must form an ad hoc
    communication relay between a base station and a trapped victim. The movement
    of the MAVs is a control problem that must be solved repeatedly, multiple times
    per second. In this case, speed is more important than accuracy, as minor errors
    can be immediately corrected during the next cycle.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15通信中继问题——一群微型飞行器必须在基站和被困受害者之间形成一个临时的通信中继。微型飞行器的移动是一个需要反复解决的控制问题，每秒可能需要多次。在这种情况下，速度比精度更重要，因为小错误可以在下一个周期立即纠正。
- en: 'During the search phase, MAVs can be deployed to maximize the area covered.
    After they detect a victim, the MAVs can be repositioned to maximize the victim’s
    visibility. The ad hoc communication relay network is then established to maximize
    the radio coverage in the swarm and find the shortest path between the MAV that
    detected the victim and the base station, given the following assumptions:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索阶段，微型飞行器可以被部署以最大化覆盖面积。一旦它们检测到受害者，微型飞行器可以被重新定位以最大化受害者的可见性。随后建立临时的通信中继网络，以最大化群体中的无线电覆盖范围，并找到检测到受害者的微型飞行器和基站之间的最短路径，前提是以下假设：
- en: 'MAVs are capable of situational awareness by combining data from three noise-prone
    sensors: a magnetic compass for direction, a speedometer for speed, and an altimeter
    for altitude.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型飞行器可以通过结合来自三个易受噪声干扰的传感器的数据来实现态势感知：一个指南针用于方向，一个速度表用于速度，一个高度计用于高度。
- en: MAVs are capable of communicating via a standard protocol such as IEEE 802.11b
    with a limited range of 100 m.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型飞行器可以通过IEEE 802.11b等标准协议进行通信，其通信范围有限，约为100米。
- en: MAVs are capable of relaying ground signals as well as controlling signals sent
    among MAVs.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型飞行器能够中继地面信号，以及控制微型飞行器之间发送的信号。
- en: MAVs have enough onboard power to sustain 30 minutes of continuous flight, at
    which point they must return to the base to recharge. However, the amount of flight
    time varies depending on the amount of signaling completed during flight.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型飞行器（MAVs）拥有足够的机载电力来维持30分钟的连续飞行，在此之后它们必须返回基地进行充电。然而，飞行时间取决于飞行过程中完成的信号量。
- en: MAVs are capable of quickly accelerating to a constant flight speed of 10 m/s.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型飞行器能够迅速加速到恒定的飞行速度10米/秒。
- en: MAVs are not capable of hovering and have a minimum turn radius of approximately
    10 m.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型飞行器不能悬停，并且最小转弯半径约为10米。
- en: For control problems such as MAV repositioning, search time is of paramount
    importance. As the MAVs cannot hover and thus must remain in constant motion,
    delayed decisions may lead to unexpected situations, such as mid-air collisions
    or a loss of signal. As instructions are sent (or repeated) every few milliseconds,
    each MAV must be able to decide its next move within that span of time. A MAV
    must account not only for its current position, target position, and velocity,
    but must also consider obstacles, communications signal strength, wind, and other
    environmental effects. Minor errors are acceptable, as they can be corrected in
    subsequent searches. In the upcoming chapters, we will discuss how to solve control
    problems like this.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于如微型飞行器重新定位这样的控制问题，搜索时间至关重要。由于微型飞行器不能悬停，因此必须保持持续运动，延迟的决策可能导致意外情况，例如空中碰撞或信号丢失。由于指令每几毫秒就会发送（或重复），每个微型飞行器必须能够在那个时间段内决定其下一步行动。微型飞行器不仅要考虑其当前位置、目标位置和速度，还必须考虑障碍物、通信信号强度、风速和其他环境因素。小错误是可以接受的，因为它们可以在后续搜索中纠正。在接下来的章节中，我们将讨论如何解决这类控制问题。
- en: This book will largely focus on complex, ill-structured problems that cannot
    be handled by traditional mathematical optimization or derivative-based solvers.
    We’ll look at examples of design, planning and control problems in various domains.
    Next, let’s take a look at how search and optimization algorithms are classified.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将主要关注复杂、结构不良的问题，这些问题无法通过传统的数学优化或基于导数的求解器来处理。我们将探讨各个领域中的设计、规划和控制问题的例子。接下来，让我们看看搜索和优化算法是如何进行分类的。
- en: 2.2 Classifying search and optimization algorithms
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 对搜索和优化算法进行分类
- en: 'When we search, we try to examine different states to find a path from the
    start (initial) state to the goal state. Often, an optimization algorithm searches
    for an optimum solution by iteratively transforming a current state or a candidate
    solution into a new, hopefully better, solution. Search algorithms can be classified
    based on the way the search space is explored:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行搜索时，我们试图检查不同的状态，以找到从起始（初始）状态到目标状态的一条路径。通常，优化算法通过迭代地将当前状态或候选解转换成一个新的、希望更好的解来寻找最优解。搜索算法可以根据探索搜索空间的方式分类：
- en: '*Local search* uses only local information about the search space surrounding
    the current solution to produce new solutions. Since only local information is
    used, local search algorithms (also known as local optimizers) locate local optima
    (which may or may not be global optima).'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*局部搜索* 仅使用关于当前解周围搜索空间的信息来产生新的解。由于只使用局部信息，局部搜索算法（也称为局部优化器）定位局部最优解（这些解可能是或可能不是全局最优解）。'
- en: '*Global search* uses more information about the search space to locate global
    optima.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全局搜索* 使用更多关于搜索空间的信息来定位全局最优解。'
- en: In other words, global search algorithms explore the entire search space, while
    local search algorithms only exploit neighborhoods.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，全局搜索算法会探索整个搜索空间，而局部搜索算法只利用邻域信息。
- en: 'Yet another classification distinguishes between deterministic and stochastic
    algorithms, as illustrated in figure 2.16:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分类区分了确定性和随机算法，如图2.16所示：
- en: '*Deterministic algorithms* follow a rigorous procedure in their path, and both
    the values of their design variables and their functions are repeatable. From
    the same starting point, they will follow the same path, whether you run the program
    today or tomorrow. Examples include, but are not limited to, graphical methods,
    gradient and Hessian-based methods, penalty methods, gradient projection methods,
    and graph search methods. Graph search methods can be further subdivided into
    blind search methods (e.g., depth-first, breadth-first, or Dijkstra) and informed
    search methods (e.g., hill climbing, beam search, best-first, A*, or contraction
    hierarchies). Deterministic methods are covered in part 1 of this book.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定性算法* 在其路径上遵循严格的程序，它们的设计变量值和函数都是可重复的。从相同的起始点出发，无论你今天还是明天运行程序，它们都会遵循相同的路径。例子包括但不限于图形方法、基于梯度和Hessian的方法、惩罚方法、梯度投影方法和图搜索方法。图搜索方法可以进一步细分为盲搜索方法（例如，深度优先、广度优先或Dijkstra）和信息搜索方法（例如，爬山法、束搜索、最佳优先、A*或收缩层次）。确定性方法在本书的第1部分有所介绍。'
- en: '*Stochastic algorithms* explicitly use randomness in their parameters or decision-making
    process or both. For example, genetic algorithms use some random or pseudo-random
    numbers, resulting in individual paths that are not exactly repeatable. With stochastic
    algorithms, the time taken to obtain an optimal solution cannot be accurately
    foretold. Solutions do not always get better, and stochastic algorithms sometimes
    miss the opportunity to find optimal solutions. This behavior can be advantageous,
    however, because it can prevent them from becoming trapped in local optima. Examples
    of stochastic algorithms include tabu search, simulated annealing, genetic algorithms,
    differential evolution algorithms, particle swarm optimization, ant colony optimization,
    artificial bee colony, firefly algorithm, etc. Most statistical machine learning
    algorithms are stochastic because they make use of randomness during the learning
    stage and they make predictions during the inference stage with a certain level
    of uncertainty. Moreover, some machine learning models are, like people, unpredictable.
    Models trained using human behavior-based data as independent variables are more
    likely to be unpredictable than those trained using independent variables that
    strictly follow physical laws. For example, the human intent recognition model
    is less predictable than a model that predicts the stress-strain curve of a material.
    Due to the uncertainty associated with machine learning predictions, machine learning–based
    algorithms used to solve optimization problems can be considered stochastic methods.
    Stochastic algorithms are covered in parts 2 to 5 of this book.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机算法*在它们的参数或决策过程中明确使用随机性，或者两者都使用。例如，遗传算法使用一些随机数或伪随机数，导致个体路径不可精确重复。使用随机算法，获得最优解所需的时间无法准确预测。解决方案并不总是变得更好，随机算法有时会错过找到最优解的机会。然而，这种行为可能是有利的，因为它可以防止它们陷入局部最优。随机算法的例子包括禁忌搜索、模拟退火、遗传算法、差分进化算法、粒子群优化、蚁群优化、人工蜂群、萤火虫算法等。大多数统计机器学习算法都是随机的，因为它们在学习的阶段利用随机性，并在推理阶段以一定的不确定性进行预测。此外，一些机器学习模型，就像人一样，是不可预测的。使用基于人类行为数据作为独立变量的模型比使用严格遵循物理定律的独立变量训练的模型更有可能不可预测。例如，人类意图识别模型比预测材料应力-应变曲线的模型更不可预测。由于机器学习预测的不确定性，用于解决优化问题的基于机器学习的算法可以被认为是随机方法。本书的第2至5部分涵盖了随机算法。 '
- en: '![](../Images/CH02_F16_Khamis.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH02_F16_Khamis.png)'
- en: Figure 2.16 Deterministic vs. stochastic algorithms. Deterministic algorithms
    follow a set procedure, and the results are repeatable, while stochastic searches
    have elements of randomness built into the algorithms.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 确定性算法与随机算法。确定性算法遵循一套既定的程序，其结果是可重复的，而随机搜索算法则将随机性元素构建到算法中。
- en: Treasure-hunting mission
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 寻宝任务
- en: The search for an optimal solution in a given search space can be likened to
    a treasure-hunting mission. Imagine you and a group of friends decided to visit
    an island looking for pirate treasure.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的搜索空间中寻找最优解可以比作寻宝任务。想象一下你和一群朋友决定去一个岛屿寻找海盗宝藏。
- en: All the areas on the island (except the active volcano area) correspond to the
    feasible search space of the optimization problem. The treasure corresponds to
    the optimal solution in this feasible space. You and your friends are the “search
    agents” launched to search for the solution, each following different search approaches.
    If you don’t have any information that can guide you while searching, you are
    following a blind (uninformed) search approach, which is usually inefficient and
    time-consuming. If you know that the pirates used to hide the treasure in elevated
    spots, you could then directly climb up the steepest cliff and try to reach the
    highest peak. This scenario corresponds to the classic hill-climbing technique
    (informed search). Uninformed and informed search algorithms are presented in
    the next two chapters. You could also follow a trial-and-error approach, looking
    for hints and repeatedly moving from one place to another plausible place until
    you find the treasure. This corresponds to trajectory-based search, which we’ll
    discuss in part 2 of the book.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to take the risk of getting nothing and decide to share information
    with your friends instead of treasure-hunting alone, you will be following a population-based
    search approach. While working in a team, you may notice that some treasure hunters
    show better performance than others. In this case, only better-performing hunters
    can be kept, and new ones can be recruited to replace the lesser-performing hunters.
    This is akin to evolutionary algorithms, such as genetic algorithms, where the
    fittest hunters survive. Genetic algorithms are covered in part 3 of the book.
    Alternatively, you and other friends can try to emulate the success of the outperforming
    hunters in each area of the treasure island without getting rid of any team members
    and without recruiting new ones. This scenario uses the so-called swarm intelligence
    and corresponds to population-based optimization algorithms such as particle swarm
    optimization, ant colony optimization, and artificial bee colony algorithm. These
    algorithms will be discussed in part 4 of the book.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: You alone, or with the help of your friends, can build a mental model based
    on historical data of previous and similar treasure-hunting missions, or you can
    train a reward predictor based on trial-and-error interaction with the treasure
    island (search space), taking the strength of the metal detector signal as a reward
    indicator. After a few iterations, you will learn to maximize the reward from
    the predictor and improve your behavior until you fulfill the desired goal and
    find the treasure. This corresponds to a machine learning–based approach, which
    we’ll discuss in part 5 of this book.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Heuristics and metaheuristics
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Heuristics* (also known as *mental shortcuts* or *rules of thumb*) are solution
    strategies, seeking methods, or rules that can facilitate finding acceptable (optimal
    or near-optimal) solutions to a complex problem in a practical time. Despite the
    fact that heuristics can seek near-optimal solutions at a reasonable computational
    cost, they cannot guarantee either feasibility or degree of optimality.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: “Eureka! Eureka!”
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The word *heuristic* comes from the Greek word *heuriskein*, which means “to
    find or discover.” The past tense of this verb, *eureka*, was used by the Greek
    mathematician, physicist, engineer, astronomer, and inventor Archimedes. Archimedes
    was contracted to detect fraud in the manufacture of a golden crown, and he accepted
    the challenge. During a subsequent visit to the public baths, he had a revelation.
    As his body submerged in the water, he observed that the more he sank, the more
    water was displaced, offering an exact measure of his volume. Realizing the principle
    at play, he deduced that a crown containing silver, being less dense than pure
    gold, would need to have greater volume to match the weight of a pure gold crown.
    Consequently, it would displace more water. Recognizing the solution, Archimedes
    leaped out of the bath and hurried home, exclaiming “Eureka! Eureka!” which translates
    to “I’ve found it! I’ve found it!”
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The term metaheuristic is a combination of two Greek words: *meta*, which means
    “beyond, on a higher level,” and *heuristics*. It’s a term coined by Fred Glover,
    inventor of the tabu search (discussed in chapter 6) to refer to high-level strategies
    used to guide and modify other heuristics to enhance their performance. The goal
    of metaheuristics is to efficiently explore the search space in order to find
    optimal or near-optimal solutions. Metaheuristics may incorporate mechanisms to
    achieve a trade-off between exploration (diversification) and exploitation (intensification)
    of the search space to avoid getting trapped in confined areas of the search space
    while also finding optimal or near-optimal solutions in a reasonable amount of
    time. Finding this balance of exploration and exploitation is crucial in heuristics,
    as discussed in section 1.5\. Metaheuristic algorithms are often global optimizers
    that can be applied to different linear and nonlinear optimization problems with
    relatively few modifications for specific problems. These algorithms are often
    robust and can handle different problem sizes, problem instances, and random variables.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we have 6 objects with different sizes (2, 4, 3, 6, 5, and
    1) and we need to pack them into a minimum number of bins. Each bin has a limited
    size of 7, so the total size of the objects in the bin should be 7 or less. If
    we have *n* objects, there are *n*! possible ways of packing the objects. The
    minimum number of bins we need is the *lower bound*. To calculate this lower bound,
    we need to find the total number of object sizes (2 + 4 + 3 + 6 + 5 + 1 = 21).
    The lower bound is 21 / 7 = 3 bins. This means that we need at least 3 bins to
    pack these objects. Figure 2.17 illustrates two heuristics that can be used to
    solve this bin packing problem.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH02_F17_Khamis.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 Handling the bin packing problem using first-fit and first-fit decreasing
    heuristics
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: First-fit heuristics pack the objects following their order without taking into
    consideration their sizes. This results in the need for four bins that are not
    fully utilized, as there are seven spaces left in three of these bins. If we apply
    the first-fit decreasing heuristic, we will order the objects based on their sizes
    and pack them following this order. This heuristic allows us to pack all the objects
    in three fully utilized bins, which is the lower bound.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, all the objects have the same height. However, in a
    more generalized version, let’s consider objects with different widths and heights,
    as illustrated in figure 2.18\. Applying heuristics such as smallest-first can
    allow us to load the container much faster. Some heuristics do not guarantee optimality;
    for example, the largest-first heuristic gives a suboptimal solution, as one object
    is left out. This can be considered an infeasible solution if we need to load
    all the objects into the container, or it will be a suboptimal solution if the
    objective is to load as many objects as possible.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH02_F18_Khamis.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 Bin packing problem. Using heuristics allows us to solve the problem
    much faster than with a brute-force approach. However, some heuristic functions
    may result in infeasible or suboptimal solutions, and they do not guarantee optimality.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem in Python, let’s first define the objects, the containers,
    and what it means to place an object inside a container. For the sake of simplicity,
    the following listing avoids custom classes and uses `numpy` arrays instead.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.7 Bin packing problem
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Define the dimensions of the container, and initialize the numpy array to
    0s.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: ② Represent objects to be placed as [width, height].
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: ③ The fit function places objects into the container, either through direct
    placement, shifting, or rotation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The `fit` function attempts to write a value to a 2D slice of the container,
    provided there are no values in that slice already (the sum is 0). If that fails,
    it shifts along the container from top to bottom, from left to right, and tries
    again. As a last resort, it tries the same thing but with the object rotated by
    90 degrees.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'The first heuristic prioritizes fitting by object area in descending order:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Sort elements by area in descending order.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: ② Some objects may not fit; we can keep track of them using a list.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: ③ Visualize the filled container.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The output of this code is shown in figure 2.19\. The code for visualizing this
    result is included in the full code files for listing 2.7, available in the book’s
    GitHub repo.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH02_F19_Khamis.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 Bin packing using the largest-first heuristic—one object has been
    excluded, as it does not fit in the remaining space.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The second heuristic sorts first by width and then by total area, in ascending
    order:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Sort by width as primary key, and then by area in ascending order.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: ② Visualize the solution.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The `smallest_width_first` heuristic manages to successfully fit all the objects
    into the container, as shown in figure 2.20.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH02_F20_Khamis.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 Bin packing problem using the smallest-first heuristic—all five
    objects have been successfully placed in the container.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Different heuristic search strategies can be used to generate candidate solutions.
    These strategies include, but are not limited to, search by repeated solution
    construction (e.g., graph search and ant colony optimization), search by repeated
    solution modification (e.g., tabu search, simulated annealing, genetic algorithm,
    and particle swarm optimization), and search by repeated solution recombination
    (e.g., genetic algorithm and differential evolution).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Let’s reconsider the cargo bike loading problem discussed in section 1.3.3\.
    We can order the items to be delivered based on their efficiency (profit per kg),
    as shown in table 2.2.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.2 Packages ranked by efficiency. The efficiency of a package is defined
    as the profit per kilogram.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '| Item | Weight (kg) | Profit ($) | Efficiency ($/kg) |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| 10 | 7.8 | 20.9 | 2.68 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| 7 | 4.9 | 10.3 | 2.10 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| 4 | 10 | 12.12 | 1.21 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| 1 | 14.6 | 14.54 | 1 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| 8 | 16.5 | 13.5 | 0.82 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| 6 | 9.6 | 7.4 | 0.77 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| 2 | 20 | 15.26 | 0.76 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| 9 | 8.77 | 6.6 | 0.75 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| 3 | 8.5 | 5.8 | 0.68 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| 5 | 13 | 8.2 | 0.63 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: Using a search strategy based on the *repeated solution construction* heuristic,
    we can start by applying a greedy principle and pick items based on their efficiency
    until we reach the maximum payload of the cargo bike (100 kg) as a hard constraint.
    The steps for this are shown in table 2.3.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.3 Repeated solution construction—packages are added to the bike until
    the maximum capacity is reached.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Item | Add? | Total weight (kg) | Total profit ($) |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| 1 | 10 | Yes | 7.8 | 20.9 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| 2 | 7 | Yes | 12.7 | 31.2 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| 3 | 4 | Yes | 22.7 | 43.32 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | Yes | 37.3 | 57.86 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| 5 | 8 | Yes | 53.8 | 71.36 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 | Yes | 63.4 | 78.76 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| 7 | 2 | Yes | 83.4 | 94.02 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| 8 | 9 | Yes | 92.17 | 100.62 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| 9 | 3 | No | (100.67) | - |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| 10 | 5 | No | (113.67) | - |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: 'We obtain the following subset of items: 10, 7, 4, 1, 8, 6, 2, and 9\. This
    can also be written as (1,1,0,1,0,1,1,1,1,1), which when read from left to right
    shows that we include items 1, 2, 4, 6, 7, 8, 9, and 10 (and exclude items 3 and
    5). This results in a total profit of $100.62 and a weight of 92.17 kg. We can
    generate more solutions by repeating the process of adding objects, starting with
    an empty container.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating one or more solutions completely from scratch, we could
    also think about ways of modifying an existing feasible solution—this is a *repeated
    solution modification*-*based* heuristic search strategy. Consider the previous
    solution generated for the cargo-bike problem: (1,1,0,1,0,1,1,1,1,1). We know
    that this feasible solution is not optimal, but how can we improve it? We could
    do so by removing item 9 from the cargo bike and adding item 5\. This process
    of removing and adding results in a new solution, (1,1,0,1,1,1,1,1,0,1), with
    a total profit of $102.22 and a weight of 96.4 kg.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is to combine existing solutions to generate new solutions
    to progress in the search space—this is *repeated solution recombination*. Suppose
    the following two solutions are given:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '*S*[1] = (1,1,1,1,1,0,0,1,0,1) with a weight of 75.8 kg and a profit of $75.78'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S*[2] = (0,1,0,1,1,0,1,1,1,1) with a weight of 80.97 kg and a profit of $86.88'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As illustrated in figure 2.21, we can take the configuration of the first two
    items of *S*[1] and the last eight items of *S*[2] to get a new solution. This
    means that we include items 1, 2, 4, 5, 7, 8, 9, and 10 in the new solution and
    exclude items 3 and 6\. This yields a new solution: *S*[3] = (1,1,0,1,1,0,1,1,1,1)
    with a weight of 95.57 kg and a higher profit of $101.42.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH02_F21_Khamis.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 Repeated solution recombination—taking the first two elements of
    S[1] and adding the last eight elements of S[2] yields a new, better solution.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Nature-inspired algorithms
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nature is the ultimate source of inspiration. Problems in nature are usually
    ill-structured, dynamic, partially observable, nonlinear, multimodal, and multi-objective
    with hard and soft constraints and with no or limited access to global information.
    Nature-inspired algorithms are computational models that mimic or reverse engineer
    the intelligent behaviors observed in nature. Examples include molecular dynamics,
    cooperative foraging, division of labor, self-replication, immunity, biological
    evolution, learning, flocking, schooling, and self-organization, just to name
    just a few.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Molecular dynamics (the science of simulating the motions of a system of particles)
    and thermal annealing inspired scientists to create an optimization algorithm
    called *simulated annealing*, which we’ll discuss in chapter 5\. Evolutionary
    computing algorithms such as genetic algorithm (GA), genetic programming (GP),
    evolutionary programming (EP), evolutionary strategies (ES), differential evolution
    (DE), cultural algorithms (CA), and co-evolution (CoE) are inspired by evolutionary
    biology (the study of the evolutionary processes) and biological evolution. Part
    3 of this book will cover a number of evolutionary computing algorithms.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Ethology (the study of animal behavior) is the main source of inspiration for
    swarm intelligence algorithms such as particle swarm optimization (PSO), ant colony
    optimization (ACO), artificial bee colony (ABC), firefly algorithm (FA), bat algorithm
    (BA), social spider optimization (SSO), butterfly optimization algorithm (BOA),
    dragonfly algorithm (DA), krill herd (KH), shuffled frog leaping algorithm (SFLA),
    fish school search (FSS), dolphin partner optimization (DPO), dolphin swarm optimization
    algorithm (DSOA), cat swarm optimization (CSO), monkey search algorithm (MSA),
    lion optimization algorithm (LOA), cuckoo search (CS), cuckoo optimization algorithm
    (COA), wolf search algorithm (WSA), and grey wolf optimizer (GWO). Swarm intelligence-based
    optimization algorithms are covered in part 4 of this book.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Neural networks (NNs) are computational models inspired by the structure and
    functioning of biological neural networks. How NNs can be used to solve search
    and optimization problems is described in part 5 of this book. Tabu search (explained
    in chapter 6) is based on evolving memory (adaptive memory and responsive exploration),
    which is studied in behavioral psychology (the science of behavior and mind).
    Reinforcement learning is a branch of machine learning that draws inspiration
    from several sources such as psychology, neuroscience, and control theory, and
    it can be used to solve search and optimization problems, as described in the
    last chapter of the book.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Other nature-inspired search and optimization algorithms include, but are not
    limited to, bacterial foraging optimization algorithm (BFO), bacterial swarming
    algorithm (BSA), biogeography-based optimization (BBO), invasive weed optimization
    (IWO), flower pollination algorithm (FPA), forest optimization algorithm (FOA),
    water flow-like algorithm (WFA), water cycle algorithm (WCA), brainstorm optimization
    algorithm (BSO), stochastic diffusion search (SDS), alliance algorithm (AA), black
    hole algorithm (BH), black hole mechanics optimization (BHMO), adaptive black
    hole algorithm (BHA), improved black hole algorithm (IBH), levy flight black hole
    (LBH), multiple population levy black hole (MLBH), spiral galaxy-based search
    algorithm (GbSA), galaxy-based search algorithm (GSA), big-bang big-crunch (BBBC),
    ray optimization (RO), quantum annealing (QA), quantum-inspired genetic algorithm
    (QGA), quantum-inspired evolutionary algorithm (QEA), quantum swarm evolutionary
    algorithm (QSE), and quantum-inspired particle swarm optimization (QPSO). For
    a comprehensive list of metaheuristic algorithms, see S.M. Almufti’s “Historical
    survey on metaheuristics algorithms” [8].
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'In the five parts of this book, we’ll explore five primary categories of search
    and optimization algorithms: graph search algorithms, trajectory-based optimization,
    evolutionary computing, swarm intelligence algorithms, and machine learning methods.
    The following algorithms are covered within these categories:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Graph search methods (blind or uninformed search and informed search algorithms)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulated annealing (SA)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tab search (TS)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genetic algorithm (GA)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle swarm optimization (PSO)
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ant colony optimization (ACO)
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial bee colony (ABC)
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph convolutional network (GCN)
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph Attention Network (GAT)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-organizing map (SOM)
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actor-Critic (A2C) architecture
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proximal policy optimization (PPO)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-armed bandit (MAB)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contextual multi-armed bandit (CMAB)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this book, we’ll look at several real-world problems and see how
    these algorithms can be applied.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Search and optimization problems can be classified based on the number of decision
    variables (univariate and multivariate problems), the types of decision variables
    (continuous, discrete, or mixed-integer), the number of objective functions (mono-objective,
    multi-objective, or constraint-satisfaction problems), the landscape of the objective
    function (unimodal, multimodal, or deceptive), the number of constraints (unconstrained
    and constrained problems), and the linearity of the objective functions and constraints
    (linear problems and nonlinear problems).
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the expected quality of the solutions and the search time permitted
    to find the solutions, optimization problems can also be categorized as design
    problems (strategic functions), planning problems (tactical functions), or control
    problems (operational functions).
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search and optimization algorithms can be classified based on the way the search
    space is explored (local versus global search), on their optimization speeds (online
    versus offline optimization), and the determinism of the algorithm (deterministic
    versus stochastic).
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heuristics (also known as *mental shortcuts* or *rules of thumb*) facilitate
    finding acceptable (optimal or near-optimal) solutions to complex problems in
    a reasonably practical time.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaheuristics are high-level strategies used to guide and modify other heuristics
    to enhance their performance.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nature-inspired algorithms are computational models that mimic or reverse engineer
    the intelligent behaviors observed in nature to solve complex ill-structured problems.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
