<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Creating Your Database"><div class="chapter" id="chapter_3">
<h1><span class="label">Chapter 3. </span>Creating Your Database</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
  <p>“You don’t seem to give much thought to the matter in hand,” I said at last, interrupting Holmes’ musical disquisition.</p>
  <p>“No data yet,” he answered. “It is a capital mistake to theorize before you have all the evidence. It biases the judgement.”</p>
  <p>“You will have your data soon,” I remarked.</p>
  <p data-type="attribution">Sir Arthur Conan Doyle, <em>A Study in Scarlet</em> (Ward Lock &amp; Co., 1887) </p>
</blockquote>

<p>In <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, you designed the API architecture and set up your GitHub Codespace environment. In this chapter, you will create the database and the Python code to read from it.</p>

<p>Since you are creating a data API, this chapter is important. It will walk you through the process of designing your database structures, creating them in the SQLite database, creating Python code to read the database, and creating unit tests to verify all of these pieces work together.</p>

<p>If you are in a rush to see how this code works,<a data-type="indexterm" data-primary="resources online" data-secondary="chapter code" data-tertiary="chapter 3 complete" id="id713"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="code online" id="id714"/> you can use the files in the <em>chapter3/complete</em> folder, and come back later to follow the instructions step by step.</p>






<section data-type="sect1" data-pdf-bookmark="Components of Your API"><div class="sect1" id="id165">
<h1>Components of Your API</h1>

<p>In the previous chapter, <a data-type="xref" href="ch02.html#future_state_architecture_ch2">Figure 2-2</a> showed the application architecture you are implementing. <a data-type="indexterm" data-primary="future state architecture of SWC website" data-secondary="software implementing API components" id="id715"/><a data-type="indexterm" data-primary="SportsWorldCentral (SWC)" data-secondary="website API" data-tertiary="technology architecture" id="id716"/><a data-type="indexterm" data-primary="APIs" data-secondary="architecture of" data-tertiary="technology architecture" id="id717"/><a data-type="indexterm" data-primary="APIs" data-secondary="architecture of" data-tertiary="components of API" id="id718"/><a data-type="indexterm" data-primary="architecture of APIs" data-secondary="website architecture and" data-tertiary="components of API" id="id719"/><a data-type="indexterm" data-primary="architecture of SWC website" data-secondary="API technology architecture" id="id720"/><a data-type="indexterm" data-primary="APIs" data-secondary="architecture of" data-tertiary="components of API and software  implementing" id="id721"/><a data-type="indexterm" data-primary="architecture of APIs" data-secondary="website architecture and" data-tertiary="software implementing API components" id="id722"/><a data-type="indexterm" data-primary="architecture of SWC website" data-secondary="software implementing API components" id="id723"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="API components" id="id724"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="API components" data-tertiary="software implementing" id="ch3-compsof"/>The API in that diagram is made up of several components. <a data-type="xref" href="#application_components_ch3">Figure 3-1</a> shows these components and the software you will use to implement them.</p>

<figure><div id="application_components_ch3" class="figure">
<img src="assets/haad_0301.png" alt="API components" width="1387" height="286"/>
<h6><span class="label">Figure 3-1. </span>API components</h6>
</div></figure>

<p>There are four major subcomponents of the API. The data transfer and validation components are used to ensure that the API requests and responses have valid data and conform to their definitions. You will create these with Pydantic. You will create the API controller with FastAPI. It handles all of the processing of the API along with other functions you will learn. You will create the database classes using SQLAlchemy. These classes handle querying the database and storing the data in Python classes. Since SQLite is a file-based database and you’ll deploy it along with your API code, the diagram shows it as a fourth component of the API.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Software Used in This Chapter"><div class="sect1" id="id166">
<h1>Software Used in This Chapter</h1>

<p>The software introduced in this chapter will focus on databases: creating them, reading data from them, and testing them (see <a data-type="xref" href="#tools_table_chapter_3">Table 3-1</a>).<a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLite" data-tertiary="about" id="id725"/><a data-type="indexterm" data-primary="SQLite" data-secondary="about" id="id726"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="about" id="id727"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="about" id="id728"/><a data-type="indexterm" data-primary="pytest" data-secondary="about" id="id729"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="pytest" data-tertiary="about" id="id730"/></p>
<table id="tools_table_chapter_3">
<caption><span class="label">Table 3-1. </span>New tools or services used in this chapter</caption>
<thead>
<tr>
<th>Software name</th>
<th>Version</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>pytest</p></td>
<td><p>8</p></td>
<td><p>Unit-testing library</p></td>
</tr>
<tr>
<td><p>SQLAlchemy</p></td>
<td><p>2</p></td>
<td><p>Object-Relational Mapping (ORM) library to connect Python to SQLite</p></td>
</tr>
<tr>
<td><p>SQLite</p></td>
<td><p>3</p></td>
<td><p>Stores the data used by the APIs</p></td>
</tr>
</tbody>
</table>








<section data-type="sect2" data-pdf-bookmark="SQLite"><div class="sect2" id="id23">
<h2>SQLite</h2>

<p>As shown in <a data-type="xref" href="#application_components_ch3">Figure 3-1</a>, the <a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLite" id="id731"/><a data-type="indexterm" data-primary="SQLite" id="id732"/>API uses the read replica database, which is a read-only copy of the website database that receives quick updates from the website database. The SWC website contains large amounts of data about fantasy teams, NFL players, managers, scoring, and numerous other data points that used by a fantasy football league host.</p>

<p>For your project, you will simulate this with a condensed database using SQLite. SQLite is well suited for learning projects because it is file based and the entire database can easily be stored in a Git repository like the one you’ll be using.</p>

<p class="less_space pagebreak-before">Although considered a lightweight database, SQLite supports all the SQL commands that you will use and is fully supported by SQLAlchemy, which you’ll use for Python database work. It is a great choice to begin the prototyping of a project. You might replace it with a traditional database such as PostgreSQL or MySQL as the application or API develops. But it is used in many production applications as well.</p>

<p>You will use SQLite 3 for your project.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="SQLAlchemy"><div class="sect2" id="id24">
<h2>SQLAlchemy</h2>

<p>SQLAlchemy is a popular Python <a data-type="indexterm" data-primary="SQLAlchemy" id="id733"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" id="id734"/><a data-type="indexterm" data-primary="object-relational mapping (ORM)" data-secondary="SQLAlchemy" id="id735"/>database toolkit and ORM. It works nicely with FastAPI, which will be introduced in <a data-type="xref" href="#chapter_3">Chapter 3</a>. Here are a few of the jobs that SQLAlchemy does for Python developers:</p>

<ul>
<li>
<p>It provides query access to databases using Python, without using SQL.</p>
</li>
<li>
<p>It populates Python objects with the data from the source database without requiring any conversion of data types.</p>
</li>
<li>
<p>It supports a variety of databases.</p>
</li>
<li>
<p>It allows the same Python code to be used with different underlying databases.</p>
</li>
<li>
<p>It creates queries as prepared statements, which combat SQL injection attacks.</p>
</li>
</ul>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><em>SQL injection</em> is a serious vulnerability<a data-type="indexterm" data-primary="SQL injection" id="id736"/> in any software that accepts input from users and queries a database with it, including web applications and APIs. It occurs when bad actors insert malicious code into inputs that are intended for data values.</p>

<p>Using <em>prepared statements</em> (also known as parameterized statements) instead<a data-type="indexterm" data-primary="prepared statements in SQL" id="id737"/><a data-type="indexterm" data-primary="SQL injection" data-secondary="prepared statements reducing risk" id="id738"/><a data-type="indexterm" data-primary="parameterized statements in SQL" id="id739"/> of raw SQL queries is one technique to reduce the risk of SQL injection. <a data-type="indexterm" data-primary="SQL injection" data-secondary="OWASP article online" id="id740"/><a data-type="indexterm" data-primary="OWASP article on SQL injection online" id="id741"/><a data-type="indexterm" data-primary="resources online" data-secondary="SQL injection article by OWASP" id="id742"/>For more information, reference <a href="https://oreil.ly/24SAy">OWASP’s article on SQL injection</a>.</p>
</div>

<p>You will be using SQLAlchemy 2 for your project.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="pytest"><div class="sect2" id="id25">
<h2>pytest</h2>

<p>You will be using  pytest, a Python testing library, <a data-type="indexterm" data-primary="pytest" id="id743"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="pytest" id="id744"/> throughout Part I to create tests for the Python code you write. You will create <em>unit tests</em> to verify that individual parts of your code work as intended. You will also use it to <em>regression-test</em> your code as you make changes or update libraries.</p>

<p>You will be using pytest 8 for your project.<a data-type="indexterm" data-startref="ch3-compsof" id="id745"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id746">
<h1>You Can Start from Here</h1>
<p>The instructions in this chapter assume that you completed <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a> already. If you’re starting your coding in this chapter, you will need to create a GitHub Codespace from the book’s GitHub repository. Full instructions are available in <a data-type="xref" href="ch02.html#getting_started_GHcodespace">“Getting Started with Your GitHub Codespace”</a>.</p>
</div></aside>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Creating Your SQLite Database"><div class="sect1" id="id167">
<h1>Creating Your SQLite Database</h1>

<p>Change to <em>chapter3</em> and open SQLite with a new database:<a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" id="ch3-cre8db"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLite" data-tertiary="creating database" id="ch3-cre8db2"/><a data-type="indexterm" data-primary="SQLite" data-secondary="creating database" id="ch3-cre8db3"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" data-tertiary="about" id="id747"/><a data-type="indexterm" data-primary="SQLite" data-secondary="creating database" data-tertiary="about" id="id748"/></p>

<pre data-type="programlisting" data-code-language="shell">.../portfolio-project (main) $ cd chapter3
.../chapter3 (main) $ sqlite3 fantasy_data.db
SQLite version 3.45.3 2024-04-15 13:34:05
Enter ".help" for usage hints.
sqlite&gt;</pre>

<p>The version of SQLite may differ from what is shown, because it is automatically included in your Codespace.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>To save screen real estate,<a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="terminal window" data-tertiary="trimming prompt directory listing" id="id749"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="terminal window prompt trimmed" id="id750"/><a data-type="indexterm" data-primary="terminal window of GitHub Codespace" data-secondary="trimming prompt directory listing" id="id751"/> I have trimmed the directory listing in the terminal prompt of my Codespace. You can configure this by editing the <em>/home/codespace/.bashrc</em> file in VS Code. Find the <code>export PROMPT_DIRTRIM</code> statement and set it to <code>export PROMPT_DIRTRIM=1</code>. Then, execute this terminal command: <strong><code>source ~/.bashrc</code></strong>.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Creating Database Tables"><div class="sect2" id="id26">
<h2>Creating Database Tables</h2>

<p>For this project, you will create<a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" data-tertiary="tables created" id="ch3tblcr8"/><a data-type="indexterm" data-primary="SQLite" data-secondary="creating database" data-tertiary="tables created" id="ch3tblcr82"/><a data-type="indexterm" data-primary="SQL" data-secondary="database tables created" id="ch3tblcr83"/><a data-type="indexterm" data-primary="CREATE TABLE (SQL)" data-secondary="database tables created" id="ch3tblcr84"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="creating tables" id="ch3tblcr85"/> several tables and load them with data. <a data-type="xref" href="#database_structure_ch3">Figure 3-2</a> displays the structure of the tables you will create.</p>

<p>You will create these tables by executing Structured Query Language (SQL) statements. As mentioned previously, SQL is a language used frequently by data scientists. This book does not teach the syntax of SQL, but the scripts used are fairly basic. <a data-type="indexterm" data-primary="SQL" data-secondary="books for learning" id="id752"/><a data-type="indexterm" data-primary="Learning SQL, 3rd Edition (Beaulieu)" id="id753"/><a data-type="indexterm" data-primary="Beaulieu, Alan" id="id754"/>To learn more about SQL, I recommend <em>Learning SQL: Generate, Manipulate, and Retrieve Data, 3rd Edition</em>, by Alan Beaulieu (O’Reilly, 2020).</p>

<figure><div id="database_structure_ch3" class="figure">
<img src="assets/haad_0302.png" alt="Database table structure" width="1437" height="727"/>
<h6><span class="label">Figure 3-2. </span>Database table structure</h6>
</div></figure>

<p>Be sure you are still at the <code>sqlite</code> prompt, and one-by-one execute the following SQL statements, one by one:<a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" data-tertiary="gsis_id" id="id755"/><a data-type="indexterm" data-primary="gsis_id" data-secondary="creating SQLite database" id="id756"/></p>

<pre data-type="programlisting" data-code-language="sql">CREATE TABLE player (
        player_id INTEGER NOT NULL, 
        gsis_id VARCHAR, 
        first_name VARCHAR NOT NULL, 
        last_name VARCHAR NOT NULL, 
        position VARCHAR NOT NULL,
        last_changed_date DATE NOT NULL, 
        PRIMARY KEY (player_id)
);

CREATE TABLE performance (
        performance_id INTEGER NOT NULL, 
        week_number VARCHAR NOT NULL, 
        fantasy_points FLOAT NOT NULL, 
        player_id INTEGER NOT NULL, 
        last_changed_date DATE NOT NULL,
        PRIMARY KEY (performance_id), 
        FOREIGN KEY(player_id) REFERENCES player (player_id)
);

CREATE TABLE league (
        league_id INTEGER NOT NULL, 
        league_name VARCHAR NOT NULL, 
        scoring_type VARCHAR NOT NULL,
        last_changed_date DATE NOT NULL,  
        PRIMARY KEY (league_id)
);

CREATE TABLE team (
        team_id INTEGER NOT NULL, 
        team_name VARCHAR NOT NULL, 
        league_id INTEGER NOT NULL, 
        last_changed_date DATE NOT NULL, 
        PRIMARY KEY (team_id), 
        FOREIGN KEY(league_id) REFERENCES league (league_id)
);

CREATE TABLE team_player (
        team_id INTEGER NOT NULL, 
        player_id INTEGER NOT NULL, 
        last_changed_date DATE NOT NULL, 
        PRIMARY KEY (team_id, player_id), 
        FOREIGN KEY(team_id) REFERENCES team (team_id), 
        FOREIGN KEY(player_id) REFERENCES player (player_id)
);</pre>

<p>Here is a breakdown of one of the statements:<a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" data-tertiary="gsis_id" id="id757"/><a data-type="indexterm" data-primary="gsis_id" data-secondary="creating SQLite database" id="id758"/></p>

<pre data-type="programlisting" data-code-language="sql">CREATE TABLE player ( <a class="co" id="co_creating_your_database_CO1-1" href="#callout_creating_your_database_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a>
        player_id INTEGER NOT NULL, <a class="co" id="co_creating_your_database_CO1-2" href="#callout_creating_your_database_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a>
        gsis_id VARCHAR,
        first_name VARCHAR NOT NULL,
        last_name VARCHAR NOT NULL,
        position VARCHAR NOT NULL,
        last_changed_date DATE NOT NULL,
        PRIMARY KEY (player_id) <a class="co" id="co_creating_your_database_CO1-3" href="#callout_creating_your_database_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a>
);</pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_creating_your_database_CO1-1" href="#co_creating_your_database_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p><code>CREATE TABLE</code> is standard SQL syntax, and <code>player</code> is the name for this table.</p></dd>
<dt><a class="co" id="callout_creating_your_database_CO1-2" href="#co_creating_your_database_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <code>player_id</code> is the name of a single column with a data type of <code>INTEGER</code> that is a required field. If you insert a row in this table with this value, an error will occur.</p></dd>
<dt><a class="co" id="callout_creating_your_database_CO1-3" href="#co_creating_your_database_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>After all the columns are defined,<a data-type="indexterm" data-primary="CREATE TABLE (SQL)" data-secondary="primary key" id="id759"/><a data-type="indexterm" data-primary="primary key" id="id760"/> the <code>player_id</code> value is defined as the <em>primary key</em>, which is the value in this table that will always be unique and can be used to join to other tables.</p></dd>
</dl>

<p>To verify that all five tables were created, enter <strong><code>.tables</code></strong>, resulting in the following:<a data-type="indexterm" data-primary="SQLite" data-secondary="creating database" data-tertiary="listing tables" id="id761"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" data-tertiary="listing tables" id="id762"/><a data-type="indexterm" data-startref="ch3tblcr8" id="id763"/><a data-type="indexterm" data-startref="ch3tblcr82" id="id764"/><a data-type="indexterm" data-startref="ch3tblcr83" id="id765"/><a data-type="indexterm" data-startref="ch3tblcr84" id="id766"/><a data-type="indexterm" data-startref="ch3tblcr85" id="id767"/></p>

<pre data-type="programlisting" data-code-language="sqlite3">sqlite&gt; .tables
league       performance  player       team         team_player
sqlite&gt;</pre>
<aside data-type="sidebar" epub:type="sidebar" class="less_space pagebreak-before"><div class="sidebar" id="id768">
<h1>Including an External Identifier in Your API</h1>
<p>When data scientists use your API,<a data-type="indexterm" data-primary="external identifiers provided" id="id769"/><a data-type="indexterm" data-primary="datasets" data-secondary="external identifiers provided" id="id770"/><a data-type="indexterm" data-primary="datasets" data-secondary="external identifiers provided" data-tertiary="standardized" id="id771"/><a data-type="indexterm" data-primary="external identifiers provided" data-secondary="standardized" id="id772"/><a data-type="indexterm" data-primary="building APIs" data-secondary="external identifiers provided" id="id773"/><a data-type="indexterm" data-primary="building APIs" data-secondary="external identifiers provided" data-tertiary="standardized" id="id774"/> they would like to combine your data with other sources for richer analytics products and models. To accomplish this, you need to provide them a standard external identifier that will be present in other data sources. For NFL player data, each data provider and fantasy website uses a different identifier.
The most comprehensive identifier is generated by the NFL’s Game Statistics and Information System (GSIS). You will include the GSIS ID in your API to meet the needs of data scientists. Not every player has a GSID ID assigned, so it will allow nulls.</p>
</div></aside>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Understanding Table Structure"><div class="sect2" id="id27">
<h2>Understanding Table Structure</h2>

<p>The first thing to notice about<a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" data-tertiary="table structure explained" id="id775"/><a data-type="indexterm" data-primary="SQLite" data-secondary="creating database" data-tertiary="table structure explained" id="id776"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="structure of tables explained" id="id777"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="structure of tables explained" data-tertiary="datatypes" id="id778"/><a data-type="indexterm" data-primary="datatypes" data-secondary="structure of tables explained" id="id779"/> the tables is that each column has a data type defined. The data types used are <code>INTEGER</code> for identifier values, <code>VARCHAR</code> for names and text fields, <code>DATE</code> for date fields, and <code>FLOAT</code> for scoring value fields that have a decimal. All fields have a <code>NOT NULL</code> statement because they are required. Each table has a <code>PRIMARY KEY()</code> constraint on the table’s identifier field. This ensures that these values are unique in each table.</p>

<p>In <a data-type="xref" href="ch01.html#designing_APIs_data_scientists">“Designing APIs for Data Scientists”</a>, I recommended<a data-type="indexterm" data-primary="query parameters" data-secondary="last changed date" data-tertiary="enabling in table data" id="id780"/><a data-type="indexterm" data-primary="last changed date query parameter" data-secondary="enabling in table data" id="id781"/><a data-type="indexterm" data-primary="data pipelines" data-secondary="last changed date query parameter" data-tertiary="enabling in table data" id="id782"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="structure of tables explained" data-tertiary="last changed date queries enabled" id="id783"/> that APIs support querying by the last changed date. This allows them to use APIs in data pipelines and only retrieve records that have changed since a point in time. (This is a major time-saver.) You will enable this by populating the <code>last_changed_date</code> column in each table.</p>

<p>As shown in <a data-type="xref" href="#database_structure_ch3">Figure 3-2</a>, each<a data-type="indexterm" data-primary="FOREIGN KEY (SQL)" id="id784"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="structure of tables explained" data-tertiary="FOREIGN KEY statements" id="id785"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="association tables" data-tertiary="FOREIGN KEY statements" id="id786"/> table is related to at least one other table. This is accomplished using <code>FOREIGN KEY</code> statements in the child table, which references the primary key in the parent table. For an example, look at the definition of the <code>team</code> table:</p>

<pre data-type="programlisting" data-code-language="sql">CREATE TABLE team (
        team_id INTEGER NOT NULL,
        team_name VARCHAR NOT NULL,
        league_id INTEGER NOT NULL,
        last_changed_date DATE NOT NULL,
        PRIMARY KEY (team_id),
        FOREIGN KEY(league_id) REFERENCES league (league_id)
);</pre>

<p>The <code>FOREIGN KEY</code> statement inserts a column named <code>league_id</code> into the child table (<code>team</code>), which links it to a matching record in the parent table (<code>league</code>).</p>

<p>The <code>team_player</code> is the only table that has two foreign keys, as shown:</p>

<pre data-type="programlisting" data-code-language="sql">CREATE TABLE team_player (
        team_id INTEGER NOT NULL,
        player_id INTEGER NOT NULL,
        last_changed_date DATE NOT NULL,
        PRIMARY KEY (team_id, player_id),
        FOREIGN KEY(team_id) REFERENCES team (team_id),
        FOREIGN KEY(player_id) REFERENCES player (player_id)
);</pre>

<p>It has two foreign keys <a data-type="indexterm" data-primary="association tables" id="id787"/><a data-type="indexterm" data-primary="FOREIGN KEY (SQL)" data-secondary="association tables with two" id="id788"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="association tables" id="id789"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="association tables" data-tertiary="many-to-many relationships" id="id790"/><a data-type="indexterm" data-primary="FOREIGN KEY (SQL)" data-secondary="association tables with two" data-tertiary="many-to-many relationships" id="id791"/><a data-type="indexterm" data-primary="association tables" data-secondary="many-to-many relationships" id="id792"/><a data-type="indexterm" data-primary="many-to-many relationships" id="id793"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="structure of tables explained" data-tertiary="many-to-many relationships" id="id794"/>because it is an <em>association table</em>, which serves as a child that associates two separate parent tables. In your database, a player can be on many fantasy teams and a team can have many fantasy players. The <code>team_player</code> table enables this <em>many-to-many relationship</em>. Later, this relationship will be reflected in the Python classes that are mapped to these tables.</p>

<p>The rest of the tables follow a similar design, with data fields that serve the purpose of the data they are storing. You are ready to load data into the tables.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Loading Your Data"><div class="sect2" id="load_your_data">
<h2>Loading Your Data</h2>

<p>Now that the tables are created, <a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" data-tertiary="loading data" id="id795"/><a data-type="indexterm" data-primary="SQLite" data-secondary="creating database" data-tertiary="loading data" id="id796"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="loading data" id="id797"/><a data-type="indexterm" data-primary="comma-separated values (CSV)" data-secondary="loading data into tables" id="id798"/>you will populate them with football data. You will use SQLite’s <code>.import</code> tool to load data files that are in CSV format. You will find data files in this chapter’s <em>/data</em> directory.</p>

<p>Before you execute the import, <a data-type="indexterm" data-primary="database creation and access" data-secondary="creating SQLite database" data-tertiary="foreign key enforcement enabled" id="id799"/><a data-type="indexterm" data-primary="FOREIGN KEY (SQL)" data-secondary="foreign key enforcement enabled" id="id800"/><a data-type="indexterm" data-primary="SQLite" data-secondary="creating database" data-tertiary="foreign key enforcement enabled" id="id801"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="foreign key enforcement enabled" id="id802"/>you need to configure SQLite to enforce foreign keys. This means that if you try to insert a record into a child table (a table containing the <code>FOREIGN KEY</code> statement) that doesn’t match a record in the parent table (the table named in the <code>REFERENCES</code> of a foreign key), an error will occur and the record won’t be imported. For example, when foreign keys are enforced, you can’t insert a record in the <code>performance</code> table that uses a <code>player_id</code> value that isn’t in the <code>player</code> table.</p>

<p>Turn on foreign key enforcement with the following statement:</p>

<pre data-type="programlisting" data-code-language="sqlite3">sqlite&gt; PRAGMA foreign_keys = ON;</pre>

<p>Prepare the import statement to recognize CSV format with the following command:</p>

<pre data-type="programlisting" data-code-language="sqlite3">sqlite&gt; .mode csv</pre>

<p>Run the following commands from the <code>sqlite</code> prompt to load the data. Run them in the order shown here:</p>

<pre data-type="programlisting" data-code-language="sqlite3">sqlite&gt; PRAGMA foreign_keys = ON;
sqlite&gt; .mode csv
sqlite&gt; .import --skip 1 data/player_data.csv player
sqlite&gt; .import --skip 1 data/performance_data.csv performance
sqlite&gt; .import --skip 1 data/league_data.csv league
sqlite&gt; .import --skip 1 data/team_data.csv team
sqlite&gt; .import --skip 1 data/team_player_data.csv team_player
sqlite&gt;</pre>

<p class="less_space pagebreak-before">Use the following commands to verify that the correct number of records was loaded into each table. The <code>performance</code> table has been loaded with records using two <span class="keep-together">different</span>  <code>last_changed_date</code> values so that you can verify date searching functions are working correctly:</p>

<pre data-type="programlisting" data-code-language="sqlite3">sqlite&gt; select count(*) from player;
1018
sqlite&gt; select count(*) from performance;
17306
sqlite&gt; select count(*) from performance where last_changed_date &gt; '2024-04-01';
2711
sqlite&gt; select count(*) from league;
5
sqlite&gt; select count(*) from team;
20
sqlite&gt; select count(*) from team_player;
140</pre>

<p>To exit the SQLite application, type <strong><code>.exit</code></strong>:<a data-type="indexterm" data-primary="SQLite" data-secondary="exiting the application" id="id803"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLite" data-tertiary="exiting the application" id="id804"/></p>

<pre data-type="programlisting" data-code-language="shell">sqlite&gt; .exit
$</pre>

<p>You have loaded sample data in your database, which represents the data from the SWC website data. Now you’ll start using it with Python.<a data-type="indexterm" data-startref="ch3-cre8db" id="id805"/><a data-type="indexterm" data-startref="ch3-cre8db2" id="id806"/><a data-type="indexterm" data-startref="ch3-cre8db3" id="id807"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Accessing Your Data Using Python"><div class="sect1" id="id29">
<h1>Accessing Your Data Using Python</h1>

<p>There are several ways to access<a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" id="ch3-accda"/><a data-type="indexterm" data-primary="querying the database via Python" id="ch3-accda2"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="about" id="id808"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="about" id="id809"/> this data in Python. For example, you could create a connection to the database and execute SQL queries directly. This sounds simple, but you would quickly run into several issues, such as mapping the SQLite data types into Python objects. You would also need to take steps to avoid SQL injection attacks when you accept input from your API users.</p>

<p>To avoid this manual work, <a data-type="indexterm" data-primary="object-relational mapping (ORM)" id="id810"/>you will use an ORM, which handles the process of reading database tables and creating Python objects from them. You will be using a very common Python ORM: SQLAlchemy.</p>








<section data-type="sect2" data-pdf-bookmark="Installing SQLAlchemy in Your Environment"><div class="sect2" id="id30">
<h2>Installing SQLAlchemy in Your Environment</h2>

<p>SQLAlchemy is the first Python library<a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="SQLAlchemy installation" id="id811"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="installation" id="id812"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="installation" id="id813"/><a data-type="indexterm" data-primary="pip3 package manager" data-secondary="requirements.txt file" data-seealso="requirements.txt file for pip" id="id814"/><a data-type="indexterm" data-primary="requirements.txt file for pip" id="id815"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="SQLAlchemy installation" id="id816"/> that you will need to install directly in your Codespace. You want to be certain of the version of SQLAlchemy installed, so first create a <code>pip</code> requirements file in the directory with your Python code.</p>

<p>In your editor, create a file named <em>requirements.txt</em> with the following contents, and save the file:</p>

<pre data-type="programlisting" data-code-language="shell">SQLAlchemy&gt;=2.0.0</pre>

<p class="less_space pagebreak-before">This file will be used to install libraries from the <code>pip</code> Python package manager. These libraries are stored on the internet, and <code>pip</code> will automatically download them to your Codespace.</p>

<p>Throughout the book, you will add<a data-type="indexterm" data-primary="libraries via pip and import" id="id817"/><a data-type="indexterm" data-primary="external libraries via pip and import" id="id818"/><a data-type="indexterm" data-primary="pip3 package manager" data-secondary="installing external libraries" id="id819"/> additional Python libraries to your Codespace. Using the requirements file is a convenient way to install multiple libraries and make sure the versions of the libraries are all compatible with one another.</p>

<p>To install the library, execute the following command:</p>

<pre data-type="programlisting" data-code-language="shell">pip3 install -r requirements.txt</pre>

<p>You should see a message that says SQLAlchemy 2.0 or higher has been successfully installed or was “already satisfied.” To verify the installation, type <strong><code>pip3 show SQLAlchemy</code></strong> and you will receive a confirmation similar to the following:</p>

<pre data-type="programlisting" data-code-language="shell">Name: SQLAlchemy
Version: 2.0.29
Summary: Database Abstraction Library
Home-page: https://www.sqlalchemy.org
Author: Mike Bayer
Author-email: mike_mp@zzzcomputing.com
License: MIT</pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id820">
<h1>Selecting and Updating Open Source Library Versions</h1>
<p>When you use open source libraries,<a data-type="indexterm" data-primary="open source library versions" id="id821"/><a data-type="indexterm" data-primary="patch versions of semantic versioning" data-secondary="open source library versions" id="id822"/><a data-type="indexterm" data-primary="versions of open source libraries" id="id823"/><a data-type="indexterm" data-primary="library version testing" id="id824"/> you need to plan and test which versions of each library to use. Because many libraries have dependencies on each other, it can be tricky at times to find library versions that all work together. In addition, you have to frequently review the versions of each library when patches are needed or versions stop being maintained. <a data-type="indexterm" data-primary="regression testing" data-secondary="open source library version testing" id="id825"/>How can you verify your code will still work if you update a library? Two key items will help: virtual environments and regression tests.</p>

<p>Codespaces are an ideal <a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="open source library version testing" id="id826"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="open source library version testing" id="id827"/><a data-type="indexterm" data-primary="requirements.txt file for pip" data-secondary="open source library version testing" id="id828"/>virtual environment for testing. You can create a new Codespace from your code repository, uninstall the existing libraries, and reinstall the new ones using the <em>requirements.txt</em> file.</p>

<p>You will create basic unit tests in this chapter and <a data-type="xref" href="ch04.html#chapter_4">Chapter 4</a> to verify your database and API code. Run these tests in the new virtual environment with the new libraries and see if any errors or warnings occur that require coding changes. <a data-type="indexterm" data-primary="regression testing" id="id829"/>This is <em>regression testing</em>: finding what you broke when updating your code or libraries. The more code you cover with tests, the more confident you can be when updating libraries.</p>

<p>In general, using a library with a major version of 1 or higher indicates the library will be maintained and patched for a while when a newer version is released. Keep in mind that open source libraries generally are provided without any warranty from the volunteer maintainers.</p>
</div></aside>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating Python Files for Database Access"><div class="sect2" id="id31">
<h2>Creating Python Files for Database Access</h2>

<p>You will now create the files<a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="creating Python files for" id="ch3-pythacc"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="creating Python files for" id="ch3-pythacc2"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" id="ch3-pythacc3"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="about" id="id830"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="models.py" id="ch3-models"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="models.py" id="ch3-models2"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="models.py" id="ch3-models3"/><a data-type="indexterm" data-primary="models.py for database access" id="ch3-models4"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="classes defined in models.py" id="ch3-models5"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="SQLAlchemy classes in models.py" id="ch3-models6"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="SQLAlchemy classes in models.py" id="ch3-models7"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="classes defined in models.py" id="ch3-models8"/> that are required to query the database using Python. <a data-type="xref" href="#file_table_chapter_3">Table 3-2</a> explains the purpose of all the files you will have when this chapter is <span class="keep-together">complete.</span><a data-type="indexterm" data-primary="models.py for database access" data-secondary="about" id="id831"/><a data-type="indexterm" data-primary="crud.py for database access" data-secondary="about" id="id832"/><a data-type="indexterm" data-primary="database.py for database access" data-secondary="about" id="id833"/><a data-type="indexterm" data-primary="requirements.txt file for pip" data-secondary="about" id="id834"/><a data-type="indexterm" data-primary="test_crud.py" data-secondary="about" id="id835"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="crud.py" id="id836"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="crud.py" id="id837"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="crud.py" id="id838"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="database.py" id="id839"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="database.py" id="id840"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="database.py" id="id841"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="test_crud.py" id="id842"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="test_crud.py" id="id843"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="test_crud.py" id="id844"/></p>
<table id="file_table_chapter_3">
<caption><span class="label">Table 3-2. </span>Purpose of the Chapter 3 files</caption>
<thead>
<tr>
<th>Filename</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><em>crud.py</em></p></td>
<td><p>Helper function to query the database</p></td>
</tr>
<tr>
<td><p><em>database.py</em></p></td>
<td><p>Configures SQLAlchemy to use the SQLite database</p></td>
</tr>
<tr>
<td><p><em>models.py</em></p></td>
<td><p>Defines the SQLAlchemy classes related to the database tables</p></td>
</tr>
<tr>
<td><p><em>requirements.txt</em></p></td>
<td><p>Used to install specific versions of libraries with the <code>pip</code> package manager</p></td>
</tr>
<tr>
<td><p>test_crud.py</p></td>
<td><p>The pytest file to unit-test your SQLAlchemy files</p></td>
</tr>
</tbody>
</table>

<p>The file named <em>models.py</em> will contain the Python representation of the data. The classes in this file will be used when you query databases in Python.</p>

<p>Here are the two tasks that you need to perform in this file:</p>

<ul>
<li>
<p>Define the SQLAlchemy classes to store information from database tables.</p>
</li>
<li>
<p>Describe the relationship between these tables so that the Python code can access the related tables.</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>The term <em>model</em> is used<a data-type="indexterm" data-primary="model as term" id="id845"/> in a lot of different ways in this book, which is unavoidable but confusing. In this instance, the SQLAlchemy model is a Python representation of the data from the SQLite database.</p>
</div>

<p>Create a file with the following contents, and name it <em>models.py</em>:<a data-type="indexterm" data-primary="gsis_id" data-secondary="models.py" id="id846"/></p>

<pre data-type="programlisting" data-code-language="python">"""SQLAlchemy models"""
from sqlalchemy import Column, ForeignKey, Integer, String, Float, Date
from sqlalchemy.orm import relationship

from database import Base


class Player(Base):
    __tablename__ = "player"

    player_id = Column(Integer, primary_key=True, index=True)
    gsis_id = Column(String, nullable=True)
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    position = Column(String, nullable=False)
    last_changed_date = Column(Date, nullable=False)

    performances = relationship("Performance", back_populates="player")


    # Many-to-many relationship between Player and Team tables
   teams = relationship("Team", secondary="team_player",
                        back_populates="players")   


class Performance(Base):
    __tablename__ = "performance"

    performance_id = Column(Integer, primary_key=True, index=True)
    week_number = Column(String, nullable=False)
    fantasy_points = Column(Float, nullable=False)
    last_changed_date = Column(Date, nullable=False)

    player_id = Column(Integer, ForeignKey("player.player_id"))

    player = relationship("Player", back_populates="performances")


class League(Base):
    __tablename__ = "league"

    league_id = Column(Integer, primary_key=True, index=True)
    league_name = Column(String, nullable=False)
    scoring_type = Column(String, nullable=False)
    last_changed_date = Column(Date, nullable=False)

    teams = relationship("Team", back_populates="league")


class Team(Base):
    __tablename__ = "team"

    team_id = Column(Integer, primary_key=True, index=True)
    team_name = Column(String, nullable=False)
    last_changed_date = Column(Date, nullable=False)    

    league_id = Column(Integer, ForeignKey("league.league_id"))

    league = relationship("League", back_populates="teams")

   players = relationship("Player", secondary="team_player",
                          back_populates="teams")

class TeamPlayer(Base):
    __tablename__ = "team_player"

   team_id = Column(Integer, ForeignKey("team.team_id"),
                    primary_key=True, index=True)
   player_id = Column(Integer, ForeignKey("player.player_id"),
                      primary_key=True, index=True)    
last_changed_date = Column(Date, nullable=False)</pre>

<p>Take a look at <em>models.py</em> piece by piece. <a data-type="indexterm" data-primary="Python" data-secondary="import statement" id="id847"/><a data-type="indexterm" data-primary="Python" data-secondary="import statement" data-tertiary="placing at top of files" id="id848"/><a data-type="indexterm" data-primary="import statement (Python)" data-secondary="placing at top of files" id="id849"/><a data-type="indexterm" data-primary="import statement (Python)" id="id850"/><a data-type="indexterm" data-primary="libraries via pip and import" id="id851"/><a data-type="indexterm" data-primary="external libraries via pip and import" id="id852"/><a data-type="indexterm" data-primary="pip3 package manager" data-secondary="installing external libraries" id="id853"/>At the top of most Python files, you will find <code>import</code> statements. The power of the Python ecosystem comes from the variety of external libraries you can use. The process you will use in this book is to install the libraries using the <code>pip</code> package manager, and then reference them in your code using import statements:</p>

<pre data-type="programlisting" data-code-language="python">from sqlalchemy import Column, ForeignKey, Integer, String, Float, Date <a class="co" id="co_creating_your_database_CO2-1" href="#callout_creating_your_database_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a>
from sqlalchemy.orm import relationship <a class="co" id="co_creating_your_database_CO2-2" href="#callout_creating_your_database_CO2-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a>

from database import Base <a class="co" id="co_creating_your_database_CO2-3" href="#callout_creating_your_database_CO2-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_creating_your_database_CO2-1" href="#co_creating_your_database_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Because this file will create Python representations of the database tables, you first import the <a data-type="indexterm" data-primary="datatypes" data-secondary="SQLAlchemy" id="id854"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="datatypes" id="id855"/><a data-type="indexterm" data-primary="resources online" data-secondary="SQLAlchemy" data-tertiary="datatypes" id="id856"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="datatypes" id="id857"/>data types that SQLAlchemy will use for the database fields. For more information about SQLAlchemy data types, reference the <a href="https://oreil.ly/Z1jfo">SQLAlchemy Type Hierarchy</a>.</p></dd>
<dt><a class="co" id="callout_creating_your_database_CO2-2" href="#co_creating_your_database_CO2-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Next, you import SQLAlchemy’s relationship functionality, which enables foreign key relationships between tables.</p></dd>
<dt><a class="co" id="callout_creating_your_database_CO2-3" href="#co_creating_your_database_CO2-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The <code>database</code> import refers<a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="database.py" id="id858"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="database.py" id="id859"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="database.py" id="id860"/><a data-type="indexterm" data-primary="database.py for database access" data-secondary="models.py referencing" id="id861"/> to the <em>database.py</em> file with the SQLAlchemy configuration. You are using the <code>Base</code> class, which is a standard template you’ll use for the classes in the <em>models.py</em> file.</p></dd>
</dl>

<p>Now it’s time to begin the definition of the <code>Player</code> class, which is the Python class you’ll use to store data from the SQLite <code>player</code> table. You do this using the <code>class</code> statement, stating the name of the class and specifying that it will be a subclass of the <code>Base</code> template imported from the <em>database.py</em> file. Use the magic command <code><em>tablename</em></code> to tell SQLAlchemy to reference the <code>player</code> table. Because of this statement, when you ask SQLAlchemy to query <code>Player</code>, it will know behind the scenes to access the <code>player</code> table in the database. This is one of the key benefits of an ORM—mapping the Python code automatically to the underlying database:</p>

<pre data-type="programlisting" data-code-language="python">class Player(Base):
    __tablename__ = "player"</pre>

<p>The rest of the <code>Player</code> class definition maps additional details about the database table. Each statement defines one attribute in the class using the <code>Column</code> method provided by SQLAlchemy:<a data-type="indexterm" data-primary="gsis_id" data-secondary="models.py" id="id862"/></p>

<pre data-type="programlisting" data-code-language="python">    player_id = Column(Integer, primary_key=True, index=True)
    gsis_id = Column(String, nullable=True)
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    position = Column(String, nullable=False)
    last_changed_date = Column(Date, nullable=False)</pre>

<p>Here are a few things to notice about the definitions:</p>

<ul>
<li>
<p>The attribute names are automatically matched to the column names in the <span class="keep-together">database. </span></p>
</li>
<li>
<p>The data types used<a data-type="indexterm" data-primary="datatypes" data-secondary="SQLAlchemy" id="id863"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="datatypes" id="id864"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="datatypes" id="id865"/> (e.g., <code>String</code>, <code>Integer</code>) are SQLAlchemy data types that you specified in your <code>import</code> statement at the beginning of the file.</p>
</li>
<li>
<p>The <code>primary_key</code> definition provides<a data-type="indexterm" data-primary="primary key" data-secondary="SQLAlchemy" id="id866"/> several benefits from SQLAlchemy, such as query optimization, enforcing uniqueness, and enabling relationships between classes.</p>
</li>
</ul>

<p>Along with the definition of the tables,<a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="SQLAlchemy foreign key relationship" id="id867"/><a data-type="indexterm" data-primary="foreign key relationship in SQLAlchemy" id="id868"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="foreign key relationship" id="id869"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="foreign key relationship" id="id870"/> you define the foreign key relationship between the tables using the <code>relationship()</code> function. This results in a <code>Player​.per⁠formances</code> attribute that will return all the related rows from the <code>performance</code> table for each row in the <code>player</code> table:</p>

<pre data-type="programlisting" data-code-language="python">    performances = relationship("Performance", back_populates="player")</pre>

<p>There is another kind of relationship,<a data-type="indexterm" data-primary="association tables" data-secondary="many-to-many relationships" id="id871"/><a data-type="indexterm" data-primary="tables in SQLite database" data-secondary="association tables" data-tertiary="many-to-many relationships" id="id872"/><a data-type="indexterm" data-primary="many-to-many relationships" id="id873"/> which uses the <code>team_player</code> association table to connect <code>player</code> to <code>team</code>. By defining <code>secondary="team_player"</code>, this relationship allows a <code>Player</code> record to have an attribute named <code>Player.teams</code>. This is the many-to-many relationship that was discussed when creating the database tables:</p>

<pre data-type="programlisting" data-code-language="python">   players = relationship("Player", secondary="team_player",
                          back_populates="teams")</pre>

<p>Next is the definition for the <code>Performance</code> class:</p>

<pre data-type="programlisting" data-code-language="python">class Performance(Base):
    __tablename__ = "performance"

    performance_id = Column(Integer, primary_key=True, index=True)
    week_number = Column(String, nullable=False)
    fantasy_points = Column(Float, nullable=False)
    last_changed_date = Column(Date, nullable=False)

    player_id = Column(Integer, ForeignKey("player.player_id"))

    player = relationship("Player", back_populates="performances")</pre>

<p>This class has a <code>player</code> relationship that is the mirror image of the <code>performances</code> relationship in the <code>player</code> table. When you look at these two relationships together, you can see that the <code>back_populates</code> statement in one refers to the variable assigned in the other. Together these allow a two-way relationship between the parent (<code>player</code>) and child (<code>performance</code>).</p>

<p>Next up is the <code>League</code> class:</p>

<pre data-type="programlisting" data-code-language="python">class League(Base):
    __tablename__ = "league"

    league_id = Column(Integer, primary_key=True, index=True)
    league_name = Column(String, nullable=False)
    scoring_type = Column(String, nullable=False)
    last_changed_date = Column(Date, nullable=False)

    teams = relationship("Team", back_populates="league")</pre>

<p><code>League</code> is going to be the topmost parent class in your code, as was reflected in <a data-type="xref" href="#database_structure_ch3">Figure 3-2</a>. The <code>teams</code> relationship will be used to enable <code>League.teams</code> in this class and has a matching relationship in the <code>Team</code> class.</p>

<p>Look at the next block of code, which defines the <code>Team</code> class:</p>

<pre data-type="programlisting" data-code-language="python">class Team(Base):
    __tablename__ = "team"

    team_id = Column(Integer, primary_key=True, index=True)
    team_name = Column(String, nullable=False)

    league_id = Column(Integer, ForeignKey("league.league_id"))

    league = relationship("League", back_populates="teams")

   players = relationship("Player", secondary="team_player",
                          back_populates="teams")</pre>

<p>Notice that this file has matching relationships to connect with the <code>league</code> table and indirectly to the <code>player</code> table.</p>

<p>The last class definition is for the <code>team-player</code> table:</p>

<pre data-type="programlisting" data-code-language="python">class TeamPlayer(Base):
    __tablename__ = "team_player"

 team_id = Column(Integer, ForeignKey("team.team_id"),
                    primary_key=True, index=True)
 player_id = Column(Integer, ForeignKey("player.player_id"),
                      primary_key=True, index=True</pre>

<p>The <code>TeamPlayer</code> class is created without any relationships, because those are defined on the <code>Team</code> and <code>Player</code> classes. You have now defined all of the SQLAlchemy models needed for the new database tables and the necessary database configuration file. Excellent progress!<a data-type="indexterm" data-startref="ch3-models" id="id874"/><a data-type="indexterm" data-startref="ch3-models2" id="id875"/><a data-type="indexterm" data-startref="ch3-models3" id="id876"/><a data-type="indexterm" data-startref="ch3-models4" id="id877"/><a data-type="indexterm" data-startref="ch3-models5" id="id878"/><a data-type="indexterm" data-startref="ch3-models6" id="id879"/><a data-type="indexterm" data-startref="ch3-models7" id="id880"/><a data-type="indexterm" data-startref="ch3-models8" id="id881"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating the Database Configuration File"><div class="sect2" id="id32">
<h2>Creating the Database Configuration File</h2>

<p>Next, a file named <em>database.py</em> will set<a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="database configuration file" id="id882"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="database.py" id="id883"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="database configuration file" id="id884"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="database.py" id="id885"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="database configuration file" id="id886"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="database.py" id="id887"/><a data-type="indexterm" data-primary="database.py for database access" data-secondary="creating" id="id888"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="database configuration file" id="id889"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="database configuration file" id="id890"/> up the SQLAlchemy configuration to connect to the SQLite database, along with some other Python objects that you’ll use for database work. The tasks that you need to accomplish in this file are the following:</p>

<ul>
<li>
<p>Create a database connection that points to the SQLite database and has the correct settings.</p>
</li>
<li>
<p>Create a parent class that you’ll use to define the Python table classes:</p>
</li>
</ul>

<p>Create a file with the following contents, and name it <em>database.py</em>:</p>

<pre data-type="programlisting" data-code-language="python">"""Database configuration"""
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./fantasy_data.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()</pre>

<p>Take a look at this file piece by piece. <a data-type="indexterm" data-primary="import statement (Python)" data-secondary="functions versus entire libraries" id="id891"/><a data-type="indexterm" data-primary="Python" data-secondary="import statement" data-tertiary="functions versus entire libraries" id="id892"/>Three specific functions are imported from the SQLAlchemy libraries. Although it would be possible to import the entire SQLAlchemy library all at once, it is better to import specific functions to limit possible conflicts between duplicate functions in multiple libraries:</p>

<pre data-type="programlisting" data-code-language="python">from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker</pre>

<p>The next three steps work together<a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="session object" id="id893"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="session object" id="id894"/><a data-type="indexterm" data-primary="session object of SQLAlchemy" id="id895"/> to get the <em>session</em>, which is a SQLAlchemy object that manages the conversation with the database. Create a database URL that tells SQLAlchemy what type of database you’ll be using (SQLite) and where to find the file (in the same folder as this file, with the name <em>fantasy_data.db</em>):</p>

<pre data-type="programlisting" data-code-language="python">SQLALCHEMY_DATABASE_URL = "sqlite:///./fantasy_data.db"</pre>

<p>Using this database URL, create an <code>engine</code> object, with one configuration setting that allows multiple connections to this database without an error being thrown:</p>

<pre data-type="programlisting" data-code-language="python">engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)</pre>

<p class="less_space pagebreak-before">Then, use the <code>engine</code> object to create a session named <code>SessionLocal</code> that points to that engine and adds a couple of more configuration settings:</p>

<pre data-type="programlisting" data-code-language="python">SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)</pre>

<p>The last command in this file creates a <code>Base</code> class. This is a standard template SQLAlchemy provides for the models you will create in the <em>models.py</em> file:</p>

<pre data-type="programlisting" data-code-language="python">Base = declarative_base()</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating SQLAlchemy Helper Functions"><div class="sect2" id="id33">
<h2>Creating SQLAlchemy Helper Functions</h2>

<p>The files created so far give you<a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="query functions" id="ch3crud"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="query functions" id="ch3crud2"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="query functions" id="ch3crud3"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="crud.py" id="ch3crud4"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="crud.py" id="ch3crud5"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="crud.py" id="ch3crud6"/><a data-type="indexterm" data-primary="crud.py for database access" id="ch3crud7"/> a connection to the database and classes that represent database tables. Next, you will create the file  <em>crud.py</em> that contains query functions. This strange-sounding name stands for Create, Read, Update, Delete (CRUD).</p>

<p>Create a file with the following contents, and name it <em>crud.py</em>:</p>

<pre data-type="programlisting" data-code-language="python">"""SQLAlchemy Query Functions"""
from sqlalchemy.orm import Session
from sqlalchemy.orm import joinedload
from datetime import date


import models


def get_player(db: Session, player_id: int):
   return db.query(models.Player).filter(
       models.Player.player_id == player_id).first()


def get_players(db: Session, skip: int = 0, limit: int = 100,
               min_last_changed_date: date = None,
               last_name : str = None, first_name : str = None, ):
   query = db.query(models.Player)
   if min_last_changed_date:
       query = query.filter(
           models.Player.last_changed_date &gt;= min_last_changed_date)
   if first_name:
       query = query.filter(models.Player.first_name == first_name)
   if last_name:
       query = query.filter(models.Player.last_name == last_name)
   return query.offset(skip).limit(limit).all()


def get_performances(db: Session, skip: int = 0, limit: int = 100,
                    min_last_changed_date: date = None):
   query = db.query(models.Performance)
   if min_last_changed_date:
       query = query.filter(
           models.Performance.last_changed_date &gt;= min_last_changed_date)
   return query.offset(skip).limit(limit).all()


def get_league(db: Session, league_id: int = None):
   return db.query(models.League).filter(
       models.League.league_id == league_id).first()


def get_leagues(db: Session, skip: int = 0, limit: int = 100,
                min_last_changed_date: date = None,league_name: str = None):
   query = db.query(models.League
                   ).options(joinedload(models.League.teams))
   if min_last_changed_date:
       query = query.filter(
           models.League.last_changed_date &gt;= min_last_changed_date)                             
   if league_name:
       query = query.filter(models.League.league_name == league_name)    
   return query.offset(skip).limit(limit).all()


def get_teams(db: Session, skip: int = 0, limit: int = 100,
             min_last_changed_date: date = None,
             team_name: str = None, league_id: int = None):
   query = db.query(models.Team)
   if min_last_changed_date:
       query = query.filter(
           models.Team.last_changed_date &gt;= min_last_changed_date)
   if team_name:
       query = query.filter(models.Team.team_name == team_name)
   if league_id:
       query = query.filter(models.Team.league_id == league_id)
   return query.offset(skip).limit(limit).all()   


#analytics queries
def get_player_count(db: Session):
   query = db.query(models.Player)
   return query.count()


def get_team_count(db: Session):
   query = db.query(models.Team)
   return query.count()


def get_league_count(db: Session):
   query = db.query(models.League)
   return query.count()</pre>

<p class="less_space pagebreak-before">Let’s look at the import statements in <em>crud.py</em>:</p>

<pre data-type="programlisting" data-code-language="python">from sqlalchemy.orm import Session <a class="co" id="co_creating_your_database_CO3-1" href="#callout_creating_your_database_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a>
from sqlalchemy.orm import joinedload
from datetime import date <a class="co" id="co_creating_your_database_CO3-2" href="#callout_creating_your_database_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a>

import models <a class="co" id="co_creating_your_database_CO3-3" href="#callout_creating_your_database_CO3-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_creating_your_database_CO3-1" href="#co_creating_your_database_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p><code>Session</code> and <code>joinedload</code> are used by the query functions.</p></dd>
<dt><a class="co" id="callout_creating_your_database_CO3-2" href="#co_creating_your_database_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <code>date</code> will be an important data type to allow you to filter by date.</p></dd>
<dt><a class="co" id="callout_creating_your_database_CO3-3" href="#co_creating_your_database_CO3-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>This import lets you reference the model file that you created. These functions reference the classes that you created in <em>models.py</em> and use SQLAlchemy built-in functions to retrieve data using prepared SQL statements.</p></dd>
</dl>

<p>Take a look at the first query:</p>

<pre data-type="programlisting" data-code-language="python">def get_player(db: Session, player_id: int):
   return db.query(models.Player).filter(
       models.Player.player_id == player_id).first()</pre>

<p>The parameters in this function include a database session, which the function will use to connect to the database, and a specific <code>player_id</code> value. By using <span class="keep-together"><code>filter(models.Player.player_id == player_id).first()</code></span>, this function looks up a specific <code>Player.player_id</code> value and returns the first matching instance. Because you have defined <code>player_id</code> as a primary key in the <em>models.py</em> file and the SQLite database, this query will return a single result.</p>

<p>The signature of the next function adds several new parameters to the <code>.query()</code> <span class="keep-together">statement:</span></p>

<pre data-type="programlisting" data-code-language="python">def get_players(db: Session, skip: int = 0, limit: int = 100,
               min_last_changed_date: date = None,
               last_name : str = None, first_name : str = None, ):</pre>

<p>The <code>skip</code> and <code>limit</code> parameters will be used for <em>pagination</em>, which allows the user to specify a set of records in chunks rather than a full list. The <code>min_last_changed_date</code> parameter will be used to exclude records older than a specified date.</p>

<p>The <code>int = 0</code> on the <code>skip</code> parameter sets a default value of zero. If this parameter isn’t sent in a call to this function, <code>skip</code> will default to zero. The <code>limit</code> has a default of 100. There is no default given for <code>min_last_changed_date</code>, <code>first_name</code>, and <code>last_name</code>, so those default to null.</p>

<p class="less_space pagebreak-before">The body of the function uses the queries to filter the results:</p>

<pre data-type="programlisting" data-code-language="python">query = db.query(models.Player)
   if min_last_changed_date:
       query = query.filter(
           models.Player.last_changed_date &gt;= min_last_changed_date)
   if first_name:
       query = query.filter(models.Player.first_name == first_name)
   if last_name:
       query = query.filter(models.Player.last_name == last_name)</pre>

<p>The last statement applies the <code>skip</code> and <code>limit</code> parameters:</p>

<pre data-type="programlisting" data-code-language="python">    return query.offset(skip).limit(limit).all()</pre>

<p>This statement applies the <code>skip</code> and <code>limit</code> parameters to grab a specific chunk of records from the query results. The <code>skip</code> instructs the query to skip a number of records from the beginning of the results, and <code>limit</code> instructs the query to return only a certain number of records. For instance, a user might begin by skipping zero and limiting 20. This would return the first 20 records. They could call it again, this time skipping 20 and limiting 20. This would grab the next 20.</p>

<p>The <code>get_leagues</code> function uses a new statement, so it is worth a closer look:</p>

<pre data-type="programlisting" data-code-language="python">def get_leagues(db: Session, skip: int = 0, limit: int = 100,
                min_last_changed_date: date = None,league_name: str = None):
   query = db.query(models.League
                   ).options(joinedload(models.League.teams))
   if min_last_changed_date:
       query = query.filter(
           models.League.last_changed_date &gt;= min_last_changed_date)
   if league_name:
       query = query.filter(models.League.league_name == league_name)
   return query.offset(skip).limit(limit).all()</pre>

<p>This function uses the <code>.options(joinedload(models.League.teams))</code> statement. This is a type of <em>eager loading</em>, which causes SQLAlchemy to retrieve the joined <code>team</code> data when it retrieves the <code>league</code> data.</p>

<p>The final set of queries are designed<a data-type="indexterm" data-primary="LLMs (large language models)" data-secondary="queries in crud.py" id="id896"/><a data-type="indexterm" data-primary="AI (artificial intelligence)" data-secondary="queries in crud.py" id="id897"/><a data-type="indexterm" data-primary="endpoints of APIs" data-secondary="queries in crud.py" id="id898"/><a data-type="indexterm" data-primary="API endpoints" data-secondary="queries in crud.py" id="id899"/><a data-type="indexterm" data-primary="LLMs (large language models)" data-secondary="API design tips" data-tertiary="separate endpoint for analytics questions" id="id900"/><a data-type="indexterm" data-primary="endpoints of APIs" data-secondary="generative AI calling APIs" data-tertiary="separate endpoint for analytics questions" id="id901"/><a data-type="indexterm" data-primary="generative AI" data-secondary="separate endpoint for analytics questions" id="id902"/><a data-type="indexterm" data-primary="API endpoints" data-secondary="generative AI calling APIs" data-tertiary="separate endpoint for analytics questions" id="id903"/> to support AI and large language models, based on the recommendation to provide a separate endpoint for analytics questions. You will create endpoints that provide counts for users, leagues, and teams. This will help the AI use the pagination functions, and it will answer questions about the number of records without making large API calls:</p>

<pre data-type="programlisting" data-code-language="python">#analytics queries
def get_player_count(db: Session):
    query = db.query(models.Player)
    return query.count()

def get_team_count(db: Session):
    query = db.query(models.Team)
    return query.count()

def get_league_count(db: Session):
    query = db.query(models.League)
    return query.count()</pre>

<p>You have created all the SQLAlchemy classes and helper functions. Since all of the functions in <em>crud.py</em> are reading (querying) data, you have only implemented the “r” in CRUD. That is appropriate, because all of your user stories require read-only functionality. If you were developing an API that allowed creating, updating, or deleting records, this file could be extended with additional functions. Now it is time to unit-test these queries with pytest.<a data-type="indexterm" data-startref="ch3-pythacc" id="id904"/><a data-type="indexterm" data-startref="ch3-pythacc2" id="id905"/><a data-type="indexterm" data-startref="ch3-pythacc3" id="id906"/><a data-type="indexterm" data-startref="ch3crud" id="id907"/><a data-type="indexterm" data-startref="ch3crud2" id="id908"/><a data-type="indexterm" data-startref="ch3crud3" id="id909"/><a data-type="indexterm" data-startref="ch3crud4" id="id910"/><a data-type="indexterm" data-startref="ch3crud5" id="id911"/><a data-type="indexterm" data-startref="ch3crud6" id="id912"/><a data-type="indexterm" data-startref="ch3crud7" id="id913"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Installing pytest in Your Environment"><div class="sect2" id="id168">
<h2>Installing pytest in Your Environment</h2>

<p>Now that all the database code is written,<a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="pytest installation" id="id914"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="pytest installation" id="id915"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="pytest installation" id="id916"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="pytest" data-tertiary="installation" id="id917"/><a data-type="indexterm" data-primary="pytest" data-secondary="installation" id="id918"/><a data-type="indexterm" data-primary="requirements.txt file for pip" data-secondary="pytest installation" id="id919"/> you are ready to test it. You will use the pytest library for this task. First, add an entry to the <em>requirements.txt</em> file for pytest. The updated file should look like the following:</p>

<pre data-type="programlisting" data-code-language="shell">SQLAlchemy&gt;=2.0.0
Pytest&gt;=8.1.0</pre>

<p>To install pytest, execute the following command again:</p>

<pre data-type="programlisting"><strong>pip3 install -r requirements.txt</strong></pre>

<p>You should see a message that says pytest 8.1.0 or higher has been successfully installed or was “already satisfied.” To verify the installation, type <strong><code>pip3 show Pytest</code></strong> and you will receive a confirmation similar to the following:</p>

<pre data-type="programlisting" data-code-language="shell">$ pip3 show Pytest
Name: pytest
Version: 8.1.1
Summary: pytest: simple powerful testing with Python
Home-page:
Author: Holger Krekel, Bruno Oliveira, Ronny Pfannschmidt, Floris Bruynooghe,
Brianna Laugher, Florian Bruhin, Others (See AUTHORS)
Author-email:
License: MIT</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Testing Your SQLAchemy Code"><div class="sect2" id="id34">
<h2>Testing Your SQLAchemy Code</h2>

<p>As the library’s summary says,<a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="testing SQLAlchemy code" id="ch3test"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="testing SQLAlchemy code" id="ch3test2"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="testing SQLAlchemy code" id="ch3test3"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="pytest" data-tertiary="testing SQLAlchemy code" id="ch3test4"/><a data-type="indexterm" data-primary="pytest" data-secondary="testing SQLAlchemy code" id="ch3test5"/><a data-type="indexterm" data-primary="Python" data-secondary="database access files" data-tertiary="test_crud.py" id="ch3test6"/><a data-type="indexterm" data-primary="querying the database via Python" data-secondary="test_crud.py" id="ch3test7"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="accessing data via Python" data-tertiary="test_crud.py" id="ch3test8"/><a data-type="indexterm" data-primary="test_crud.py" id="ch3test9"/> pytest is simple to use. There are a couple of naming conventions that pytest expects. Any file that contains tests will have a filename beginning with <em>test</em> followed by an underscore or ending with an underscore followed by <em>test</em>. Inside the test file, pytest will execute any function name beginning with <em>test</em>.</p>

<p>Inside the test functions, you will include an <code>assert</code> statement. If it returns true, the flow continues. If all assertions evaluate as true in the test, the test returns with a <span class="keep-together">success</span> status. If an assertion evaluates as false, the code raises an <code>AssertionError</code> and the test evaluates as false.</p>

<p>Your unit tests will be very basic: they will check that the row counts returned from your SQLAlchemy classes match the values you checked in the previous SQL query.</p>

<p>Create a file named <em>test_crud.py</em> with the following contents:</p>

<pre data-type="programlisting" data-code-language="python">"""Testing SQLAlchemy Helper Functions"""
import pytest
from datetime import date

import crud
from database import SessionLocal

# use a test date of 4/1/2024 to test the min_last_changed_date.
test_date = date(2024,4,1)

@pytest.fixture(scope="function")
def db_session():
    """This starts a database session and closes it when done"""
    session = SessionLocal()
    yield session
    session.close()

def test_get_player(db_session):
    """Tests you can get the first player"""
    player = crud.get_player(db_session, player_id = 1001)
    assert player.player_id == 1001

def test_get_players(db_session):
    """Tests that the count of players in the database is what is expected"""
   players = crud.get_players(db_session, skip=0, limit=10000,
                               min_last_changed_date=test_date)
    assert len(players) == 1018

def test_get_players_by_name(db_session):
    """Tests that the count of players in the database is what is expected"""
    players = crud.get_players(db_session, first_name="Bryce", last_name="Young")
    assert len(players) == 1
    assert players[0].player_id == 2009


def test_get_all_performances(db_session):
 """Tests that the count of performances in the database is
   what is expected - all the performances"""
    performances = crud.get_performances(db_session, skip=0, limit=18000)
    assert len(performances) == 17306

def test_get_new_performances(db_session):
"""Tests that the count of performances in the database is
   what is expected"""
   performances = crud.get_performances(db_session, skip=0, limit=18000,
                                        min_last_changed_date=test_date)


#test the count functions
def test_get_player_count(db_session):
    player_count = crud.get_player_count(db_session)
    assert player_count == 1018</pre>

<p>First, look at how this file follows the conventions expected by pytest. The file is named <em>test_crud.py</em>, so it will be recognized as a test file automatically. The file contains six function names beginning with <em>test_</em>. These will be executed when the file runs. Each of these test functions ends with an <code>assert</code> statement.</p>

<p>The first function needs a bit of explanation.<a data-type="indexterm" data-primary="database creation and access" data-secondary="pytest" data-tertiary="fixtures" id="id920"/><a data-type="indexterm" data-primary="pytest" data-secondary="fixtures" id="id921"/> On top of the function is the decorator <code>@pytest.fixture(scope="function")</code>. A fixture is used during the <em>arrange</em> phase, which prepares the testing setup. This fixture uses session scope, which means it will run once for each function:</p>

<pre data-type="programlisting" data-code-language="python">@pytest.fixture(scope="function")</pre>

<p>The body of the <code>db_session()</code> function creates a database session, pauses while the test function uses the session (through the <code>yield</code> statement), and then closes the session when the test completes:</p>

<pre data-type="programlisting" data-code-language="python">def db_session():
    """This starts a database session and closes it when done"""
    session = SessionLocal()
    yield session
    session.close()</pre>

<p>To verify the date-based queries are working correctly, the queries for <code>performance</code> check the full results and then results that are limited using <code>last_changed_date</code>. First remember that in the SQL queries earlier you got the following results for the <code>performance</code> table:</p>

<pre data-type="programlisting" data-code-language="sqlite3">sqlite&gt; select count(*) from performance;
17306
sqlite&gt; select count(*) from performance where last_changed_date &gt; '2024-04-01';
2711</pre>

<p>To verify the first result using pytest, this function does not include a data parameter:</p>

<pre data-type="programlisting" data-code-language="python">def test_get_all_performances(db_session):
   """Tests that the count of performances in the database is
   what is expected - all the performances"""
    performances = crud.get_performances(db_session, skip=0, limit=18000)
    assert len(performances) == 17306</pre>

<p>To verify the second result, the next function uses a <code>last_changed_date</code> value of <code>2024_04_01</code>, set in the <code>test_date</code> variable at the top of the testing code. That date is earlier that all by 2,711 records:</p>

<pre data-type="programlisting" data-code-language="python"> """Tests that the count of performances in the database is
   what is expected"""
   performances = crud.get_performances(db_session, skip=0, limit=10000,
                                        min_last_changed_date=test_date)
    assert len(performances) == 2711</pre>

<p>The last test verifies one of the analytics queries:</p>

<pre data-type="programlisting" data-code-language="python">def test_get_player_count(db_session):
    player_count = crud.get_player_count(db_session)
    assert player_count == 1018</pre>

<p>To execute the tests, enter the <strong><code>pytest test_crud.py</code></strong> command and you should see an output that looks similar to this:</p>

<pre data-type="programlisting" data-code-language="shell">$ pytest test_crud.py
================== test session starts ===========================
platform linux -- Python 3.10.13, pytest-8.1.2, pluggy-1.5.0
rootdir: /workspaces/adding-more-data/chapter3
plugins: anyio-4.4.0
collected 5 items


test_crud.py                                              [100%]

=================== 5 passed in 0.22s ============================</pre>

<p>You have verified that your SQLAlchemy classes and a few helper functions work <span class="keep-together">correctly—way</span> to go! The database work is done.<a data-type="indexterm" data-startref="ch3-accda" id="id922"/><a data-type="indexterm" data-startref="ch3-accda2" id="id923"/><a data-type="indexterm" data-startref="ch3test" id="id924"/><a data-type="indexterm" data-startref="ch3test2" id="id925"/><a data-type="indexterm" data-startref="ch3test3" id="id926"/><a data-type="indexterm" data-startref="ch3test4" id="id927"/><a data-type="indexterm" data-startref="ch3test5" id="id928"/><a data-type="indexterm" data-startref="ch3test6" id="id929"/><a data-type="indexterm" data-startref="ch3test7" id="id930"/><a data-type="indexterm" data-startref="ch3test8" id="id931"/><a data-type="indexterm" data-startref="ch3test9" id="id932"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Additional Resources"><div class="sect1" id="id35">
<h1>Additional Resources</h1>

<p>SQL is one of the essential skills for data professionals. The number of resources available is limitless, but here are a couple to start:<a data-type="indexterm" data-primary="SQL" data-secondary="books for learning" id="id933"/><a data-type="indexterm" data-primary="Learning SQL, 3rd Edition (Beaulieu)" id="id934"/><a data-type="indexterm" data-primary="Beaulieu, Alan" id="id935"/><a data-type="indexterm" data-primary="SQL Pocket Guide, 4th Edition (Zhao)" id="id936"/><a data-type="indexterm" data-primary="Zhao, Alice" id="id937"/></p>

<ul>
<li>
<p><em>Learning SQL, 3rd Edition</em>, by Alan Beaulieu (O’Reilly, 2020)</p>
</li>
<li>
<p><em>SQL Pocket Guide, 4th Edition</em>, by Alice Zhao (O’Reilly, 2021)</p>
</li>
</ul>

<p>To learn more about SQLAlchemy,<a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="documentation online" id="id938"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="documentation online" id="id939"/><a data-type="indexterm" data-primary="resources online" data-secondary="SQLAlchemy" data-tertiary="documentation" id="id940"/> check out <a href="https://oreil.ly/PhsUf">the official SQLAlchemy 2 documentation</a>.</p>
<aside data-type="sidebar" epub:type="sidebar" class="less_space pagebreak-before"><div class="sidebar" id="id941">
<h1>Extending Your Portfolio Project</h1>
<p>This script tested several of<a data-type="indexterm" data-primary="portfolio projects" data-secondary="database portfolio project extended" id="id942"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="portfolio project extended" id="id943"/> the database helper functions. Create more scripts to get <em>full test coverage</em>, which means each part of the program’s code has been tested. (You never know where a typo is going to occur.) You can see additional tests in the <em>chapter3/complete/test_crud.py</em> file.</p>

<p>If you identified a different portfolio project in <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, use the following techniques to continue it:</p>

<ul>
<li>
<p>Select a primary user, and extend your database to add necessary tables to support the tasks they want to perform or resolve their pain points.</p>
</li>
<li>
<p>Model a parent–child relationship of two or more tables that would store data related to your idea.</p>
</li>
<li>
<p>Create a new GitHub repository for this project and launch a new Codespace.</p>
</li>
<li>
<p>Create a SQLite database using DDL scripts and data loading scripts to populate it with sample data.</p>
</li>
<li>
<p>Using this chapter’s code as a template, create Python code to represent your database using SQLAlchemy, and retrieve data from your database tables.</p>
</li>
</ul>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id379">
<h1>Summary</h1>

<p>In this chapter, you created your database and the SQLAlchemy code to read it. Here is what you accomplished in this chapter:</p>

<ul>
<li>
<p>You designed your database tables and their relationships.</p>
</li>
<li>
<p>You created a database using SQLite and created all of your tables using SQL commands.</p>
</li>
<li>
<p>You imported data from CSV files to load your tables.</p>
</li>
<li>
<p>You created the Python model files and database configuration files.</p>
</li>
<li>
<p>You created helper functions to query your database.</p>
</li>
<li>
<p>You unit-tested the end-to-end database functionality using pytest.</p>
</li>
</ul>

<p>In <a data-type="xref" href="ch04.html#chapter_4">Chapter 4</a>, you will create the FastAPI code to use this data and publish it as a REST API.</p>
</div></section>
</div></section></div>
</div>
</body></html>