<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Beyond the 70%: Maximizing Human Contribution"><div class="chapter" id="ch04_beyond_the_70_maximizing_human_contribution_1752630043401362">
<h1><span class="label">Chapter 4. </span>Beyond the 70%: Maximizing <span class="keep-together">Human Contribution</span></h1>

<p>You’ve seen how AI coding assistants like Cursor, Cline, Copilot, and Windsurf have transformed how software is built, shouldering much of the grunt work and boilerplate—about 70%.<sup><a data-type="noteref" id="id534-marker" href="ch04.html#id534">1</a></sup> But what about<a contenteditable="false" data-primary="70% problem" data-primary-sortas="seventy" data-secondary="maximizing human contribution in remaining 30%" data-type="indexterm" id="id535"/> that last “30%” of the job<a contenteditable="false" data-primary="human contribution, maximizing" data-type="indexterm" id="ix_hmncnt"/> that separates a toy solution from a production-ready system? This gap includes the hard parts: understanding complex requirements, architecting maintainable systems, handling edge cases, and ensuring code correctness. In other words, while AI can generate <em>code</em>, it often struggles with <em>engineering</em>.</p>

<p>Tim O’Reilly, <a href="https://oreil.ly/BYrNh">reflecting on decades of technology shifts</a>, reminds us that each leap in automation has changed <em>how</em> we program but not <em>why</em> we need skilled programmers. We’re not facing the end of programming but rather “the end of programming as we know it today,” meaning developers’ roles are evolving, not evaporating.<a contenteditable="false" data-primary="developers" data-secondary="roles evolving, not disappearing" data-type="indexterm" id="id536"/></p>

<p>The challenge for today’s engineers is to embrace AI for what it does best (the first 70%) while doubling down on the durable skills and insights needed for the remaining 30%. This article dives into expert insights to identify which human skills remain crucial. We’ll explore what senior and midlevel developers should continue to leverage and what junior developers must invest in to thrive alongside AI.</p>

<p>This chapter’s goal, then, is to offer you pragmatic guidance for maximizing the value of that irreplaceable 30%, with actionable takeaways for engineers at every level.</p>

<section data-type="sect1" data-pdf-bookmark="Senior Engineers and Developers: Leverage Your Experience with AI"><div class="sect1" id="ch04_senior_engineers_and_developers_leverage_your_exp_1752630043401527">
<h1>Senior Engineers and Developers: <span class="keep-together">Leverage Your Experience with AI</span></h1>

<p>If you’re a senior engineer, you should see the advent <a contenteditable="false" data-primary="engineers" data-secondary="senior engineers and developers, leveraging experience with AI" data-type="indexterm" id="ix_engnsen"/>of<a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="senior engineers and developers, leveraging experience with AI" data-type="indexterm" id="ix_hmncntseneng"/> AI coding tools as an opportunity to amplify your impact—if you leverage your experience in the right ways. Senior developers typically possess deep domain knowledge, intuition for what could go wrong, and the ability to make high-level technical decisions.<a contenteditable="false" data-primary="senior engineers" data-see="engineers" data-type="indexterm" id="id537"/></p>

<p>These strengths are part of the 30% that AI can’t handle alone. This section looks at how seasoned developers can maximize their value.</p>

<section data-type="sect2" data-pdf-bookmark="Be the Architect and the Editor in Chief"><div class="sect2" id="ch04_be_the_architect_and_the_editor_in_chief_1752630043401588">
<h2>Be the Architect and the Editor in Chief</h2>

<p>Let AI handle the first draft of code while you focus on architecting the solution and then refining the AI’s output.<a contenteditable="false" data-primary="architect and editor, senior engineers and developers as" data-type="indexterm" id="id538"/><a contenteditable="false" data-primary="engineers" data-secondary="senior engineers and developers, leveraging experience with AI" data-tertiary="being the architect and editor in chief" data-type="indexterm" id="id539"/> In many organizations, <a href="https://oreil.ly/QtJ7_">Steve Yegge</a> writes that we may see a shift where teams need “only senior associates” who “(a) describe the tasks to be done; i.e., create the prompts, and (b) review the resulting work for accuracy and correctness.” Embrace that model. As a senior dev, you can translate complex requirements into effective prompts or specifications for an AI assistant, then use your critical eye to vet every line produced.<a contenteditable="false" data-primary="human-AI pair programming" data-type="indexterm" id="id540"/> You are effectively pair programming with the AI—it’s the fast typer, but you’re the brain.</p>

<p>Maintain high standards during review: ensure the code meets your organization’s quality, security, and performance benchmarks. By acting as architect and editor, you prevent the “high review burden” from overwhelming you. (A cautionary note: if junior staff simply throw raw AI output over the wall to you, push back—instill a process where they must verify AI-generated work first, so you’re not the sole safety net.)</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Use AI as a Force Multiplier for Big Initiatives"><div class="sect2" id="ch04_use_ai_as_a_force_multiplier_for_big_initiatives_1752630043401648">
<h2>Use AI as a Force Multiplier for Big Initiatives</h2>

<p>Senior engineers often drive large projects or tackle hairy refactors that juniors can’t approach alone.<a contenteditable="false" data-primary="engineers" data-secondary="senior engineers and developers, leveraging experience with AI" data-tertiary="using AI as force multiplier for big initiatives" data-type="indexterm" id="id541"/> AI can supercharge these efforts by handling a lot of mechanical changes or exploring alternatives under your guidance. Yegge introduced the term <a href="https://oreil.ly/QtJ7_"><em>chat-oriented programming</em> (CHOP)</a> for this style of working—“coding via iterative prompt refinement,” with the AI as a collaborator. <a contenteditable="false" data-primary="chat-oriented programming (CHOP)" data-type="indexterm" id="id542"/>Leverage CHOP to be more ambitious in what you take on.</p>

<p>Having AI assistance lowers the bar for when a project is worth investing time in at all since what might have taken days can now be done in hours. Senior devs can thus attempt those “Wouldn’t it be nice if…?” projects that always seemed slightly out of reach.</p>

<p>The key is to remain the guiding mind: you decide which tools or approaches to pursue, and you integrate the pieces into a cohesive whole. Your experience allows you to sift the AI’s suggestions—accepting those that fit, rejecting those that don’t.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Mentor and Set Standards"><div class="sect2" id="ch04_mentor_and_set_standards_1752630043401701">
<h2>Mentor and Set Standards</h2>

<p>Another crucial role for senior engineers is to coach less-experienced team members on effective use of AI and on the timeless best practices.<a contenteditable="false" data-primary="mentorship" data-secondary="senior engineers mentoring and setting standards" data-type="indexterm" id="id543"/><a contenteditable="false" data-primary="engineers" data-secondary="senior engineers and developers, leveraging experience with AI" data-tertiary="mentoring and setting standards" data-type="indexterm" id="id544"/> You likely have hard-won knowledge of pitfalls that juniors may not see, like memory leaks, off-by-one errors, and concurrency hazards.</p>

<p>With juniors now potentially generating code via AI, it’s important to teach them how to self-review and test that code. Set an example by demonstrating how to thoroughly test AI contributions, and encourage a culture of questioning and verifying machine output. Some organizations (including even law firms) have instituted rules that if someone uses an AI to generate code or writing, they must <em>disclose it and verify the results themselves</em>—not just assume a senior colleague will catch mistakes.</p>

<p>As a senior engineer, champion such norms on your team: AI is welcome, but diligence is required. By mentoring juniors in this way, you offload some of the oversight burden and help them grow into that 30% skill set more quickly.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Continue to Cultivate Domain Mastery and Foresight"><div class="sect2" id="ch04_continue_to_cultivate_domain_mastery_and_foresight_1752630043401769">
<h2>Continue to Cultivate Domain Mastery and Foresight</h2>

<p>Your broad experience and context are more important than ever. <a contenteditable="false" data-primary="engineers" data-secondary="senior engineers and developers, leveraging experience with AI" data-tertiary="cultivating domain mastery and foresight" data-type="indexterm" id="id545"/><a contenteditable="false" data-primary="domain mastery and foresight, cultivating" data-type="indexterm" id="id546"/>Senior developers often have historical knowledge of why things in the company are built a certain way or how an industry operates. This domain mastery lets you catch AI’s missteps that a newcomer wouldn’t.</p>

<p>Continue investing in understanding the problem domain deeply. That might mean staying up-to-date with the business’s needs, user feedback, or new regulations that affect the software. AI won’t automatically incorporate these considerations unless you tell it to. When you combine your domain insight with AI’s speed, you get the best outcomes.</p>

<p>Also, use your foresight to steer AI.<a contenteditable="false" data-primary="foresight, using to steer AI" data-type="indexterm" id="id547"/> For instance, if you know that a quick fix will create maintenance pain down the line, you can instruct the AI to implement a more sustainable solution. Trust the instincts you’ve honed over the years—if a code snippet looks “off” or too good to be true, dig in. Nine times out of ten, your intuition has spotted something that the AI didn’t account for. Being able to foresee the second- and third-order effects of code is a hallmark of senior engineers; don’t let the convenience of AI blunt that habit. Instead, apply it to whatever the AI produces.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Hone Your Soft Skills and Leadership"><div class="sect2" id="ch04_hone_your_soft_skills_and_leadership_1752630043401821">
<h2>Hone Your Soft Skills and Leadership</h2>

<p class="fix_tracking">With AI shouldering some coding, senior developers can spend more energy on the human side of engineering:<a contenteditable="false" data-primary="engineers" data-secondary="senior engineers and developers, leveraging experience with AI" data-tertiary="honing soft skills and leadership" data-type="indexterm" id="id548"/><a contenteditable="false" data-primary="soft skills and leadership, honing" data-type="indexterm" id="id549"/> communicating with stakeholders, leading design meetings, and making judgment calls that align technology with business strategy. <a href="https://oreil.ly/rbIKm">Tim O’Reilly and others</a> suggest that as rote coding becomes easier, the value shifts to deciding <em>what</em> to build and <em>how to orchestrate</em> complex systems.</p>

<p>Senior engineers are often the ones orchestrating and seeing the big picture. Step up to that role. Volunteer to write that architecture roadmap, to evaluate which tools (AI or otherwise) to adopt, or to define your org’s AI coding guidelines. These are tasks AI can’t do—they require experience, human discretion, and, often, cross-team consensus building.<a contenteditable="false" data-primary="leadership and soft skills, honing" data-type="indexterm" id="id550"/> By amplifying your leadership presence, you ensure that you’re not just a code generator (replaceable by another tool) but an indispensable technical leader guiding the team.</p>

<p>In short, continue doing what seasoned developers do best: seeing the forest for the trees. AI will help you chop a lot more trees, but someone still needs to decide <em>which</em> trees to cut and <em>how</em> to build a stable house from the lumber. Your judgment, strategic thinking, and mentorship are now even more critical. A senior developer who harnesses AI effectively can be dramatically more productive than one who doesn’t—but the ones who truly excel will be those who apply their human strengths to amplify the AI’s output, not just let it run wild.<a contenteditable="false" data-primary="programming" data-secondary="AI as force multiplier" data-type="indexterm" id="id551"/><a contenteditable="false" data-primary="force multiplier, AI as" data-type="indexterm" id="id552"/></p>

<p>As one Redditor <a href="https://oreil.ly/HulC9">observed</a>, “AI is a programming force multiplier” that “greatly increases the productivity of senior programmers.” The multiplier effect is real, but it’s your expertise that’s being multiplied. Keep that expertise sharp and at the center of the development process.<a contenteditable="false" data-primary="engineers" data-secondary="senior engineers and developers, leveraging experience with AI" data-startref="ix_engnsen" data-type="indexterm" id="id553"/><a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="senior engineers and developers, leveraging experience with AI" data-startref="ix_hmncntseneng" data-type="indexterm" id="id554"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Midlevel Engineers: Adapt and Specialize"><div class="sect1" id="ch04_midlevel_engineers_adapt_and_specialize_1752630043401887">
<h1>Midlevel Engineers: Adapt and Specialize</h1>

<p>Midlevel engineers face perhaps the most significant pressure to evolve. <a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-type="indexterm" id="ix_engnmid"/><a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="midlevel engineers, adapting and specializing" data-type="indexterm" id="ix_hmncntmid"/>Many of the tasks that traditionally occupied your time—implementing features, writing tests, debugging straightforward issues—are becoming increasingly automatable.<a contenteditable="false" data-primary="midlevel engineers" data-see="engineers" data-type="indexterm" id="id555"/></p> 

<p>This doesn’t mean obsolescence; it means elevation. The focus shifts from writing code to more building specialized knowledge, which the following sections explore.</p>

<section data-type="sect2" data-pdf-bookmark="Learn to Manage Systems Integration and Boundaries"><div class="sect2" id="ch04_learn_to_manage_systems_integration_and_boundaries_1752630043401945">
<h2>Learn to Manage Systems Integration and Boundaries</h2>

<p>As systems become more complex, understanding and managing the boundaries between components becomes crucial. <a contenteditable="false" data-primary="systems integration and boundaries, managing" data-type="indexterm" id="id556"/><a contenteditable="false" data-primary="boundaries between system components, managing" data-type="indexterm" id="id557"/><a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="managing systems integration and boundaries" data-type="indexterm" id="id558"/>This includes API design, event schemas, and data models—all requiring careful consideration of business requirements and future flexibility. Deepen your computer science fundamentals, including gaining an advanced understanding of disciplines like:</p>

<ul>
	<li>
	<p>Data structures and algorithms</p>
	</li>
	<li>
	<p>Distributed-systems principles</p>
	</li>
	<li class="pagebreak-before less_space">
	<p>Database internals and query optimization</p>
	</li>
	<li>
	<p>Network protocols and security</p>
	</li>
</ul>

<p>This knowledge helps you understand the implications of AI-generated code and make better architectural decisions.</p>

<p>Learn to handle edge cases and ambiguity too. Real-world software is rife with oddball scenarios and changing requirements. AI tends to solve the general case by default. It’s up to the developer to ask “What if…?” and probe for weaknesses.</p>

<p>The durable <a contenteditable="false" data-primary="foresight, using to steer AI" data-type="indexterm" id="id559"/>skills here<a contenteditable="false" data-primary="critical thinking and foresight" data-type="indexterm" id="id560"/> are critical thinking and foresight—enumerating edge cases, anticipating failures, and addressing them in code or design. This might mean thinking of null input, network outages, unusual user actions, or integration with other systems.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Build Your Domain Expertise"><div class="sect2" id="ch04_build_your_domain_expertise_1752630043401993">
<h2>Build Your Domain Expertise</h2>

<p>Understanding the business context or the user’s environment will reveal edge cases that a generic AI simply doesn’t know about.<a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="building domain expertise" data-type="indexterm" id="id561"/><a contenteditable="false" data-primary="domain expertise, building" data-type="indexterm" id="id562"/> Experienced engineers habitually consider these scenarios. Practice systematically testing boundaries and questioning assumptions. Specialize in complex domains where human understanding remains crucial. Generic domains include:</p>

<ul>
	<li>
	<p>Financial systems with regulatory requirements</p>
	</li>
	<li>
	<p>Healthcare systems with privacy concerns</p>
	</li>
	<li>
	<p>Real-time systems with strict performance requirements</p>
	</li>
	<li>
	<p>Machine learning infrastructure</p>
	</li>
</ul>

<p>Software-engineering-specific<a contenteditable="false" data-primary="domains, software-engineering-specific" data-type="indexterm" id="id563"/> domains include frontend and backend engineering, mobile development, DevOps, and security engineering, to name a few. Domain expertise provides context that current AI tools lack and helps you make better decisions about where and how to apply them.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Master Performance Optimization and DevOps"><div class="sect2" id="ch04_master_performance_optimization_and_devops_1752630043402043">
<h2>Master Performance Optimization and DevOps</h2>

<p>While LLMs can suggest basic <a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="performance optimization and DevOps" data-type="indexterm" id="id564"/>optimizations, identifying<a contenteditable="false" data-primary="performance" data-secondary="midlevel engineers mastering performance optimization" data-type="indexterm" id="id565"/> and <a contenteditable="false" data-primary="DevOps" data-secondary="midlevel engineers mastering" data-type="indexterm" id="id566"/>resolving system-wide performance issues requires a deep understanding of the entire stack, from database query patterns to frontend rendering strategies. Understanding how systems run in production becomes more valuable as code generation becomes more automated.</p> 

<p>Focus on fields like the following:</p>

<ul>
	<li>
	<p>Monitoring and observability</p>
	</li>
	<li>
	<p>Performance profiling and optimization</p>
	</li>
	<li>
	<p>Security practices and compliance</p>
	</li>
	<li>
	<p>Cost management and optimization</p>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Focus on Code Review and Quality Assurance"><div class="sect2" id="ch04_focus_on_code_review_and_quality_assurance_1752630043402092">
<h2>Focus on Code Review and Quality Assurance</h2>

<p>With AI<a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="focusing on code review and quality assurance" data-type="indexterm" id="id567"/> writing <a contenteditable="false" data-primary="code reviews" data-secondary="midlevel engineers focusing on" data-type="indexterm" id="id568"/>lots of code, the ability<a contenteditable="false" data-primary="quality assurance" data-secondary="midlevel engineers focusing on" data-type="indexterm" id="id569"/> to rigorously review and test that code becomes even more critical. “Everyone will need to get a lot more serious about testing and reviewing code,” Yegge <a href="https://oreil.ly/QtJ7_">emphasizes</a>. Treat AI-generated code as you would a human junior developer’s output: you are the code reviewer responsible for catching bugs, security flaws, or sloppy implementations. This means strengthening your skills in unit testing, integration testing, and debugging.<a contenteditable="false" data-primary="testing" data-secondary="critical importance for AI-generated code" data-type="indexterm" id="id570"/></p>

<p>Writing good tests is a durable skill that forces you to understand the spec and verify correctness. It’s wise to assume nothing works until proven otherwise. AI often yields functional but unoptimized code until you guide it through iterative improvement. This can be due to a number of reasons, including that the training data coding models are trained on don’t reflect all best practices as completely as they could.</p>

<p>Cultivate a testing mindset: verify every critical logic path, use static analysis or linters, and don’t shy away from rewriting AI-given code if it doesn’t meet your quality bar. Even if you’re following the “AI as validator” pattern discussed in the previous chapter, quality assurance is not an area to simply outsource to AI—it’s where human diligence shines. When software doesn’t work as expected, you need real problem-solving chops to diagnose and fix it. AI can assist with debugging (for example, by suggesting possible causes), but it lacks true understanding of the specific context in which your application runs. Human testers possess domain-specific knowledge and an understanding of user expectations that AI currently lacks. This insight is vital when assessing the relevance and impact of potential issues. Diagnosing complex bugs often requires creative problem solving and the ability to consider a broad range of factors—skills that are inherently human. And evaluating the ethical implications of software behavior, such as fairness and accessibility, requires human sensitivity and judgment.</p>

<p>Being able to reason through a complex bug—reproducing it, isolating the cause, understanding the underlying systems (OS, databases, libraries)—is a timeless engineering skill.<a contenteditable="false" data-primary="debugging" data-secondary="as timeless engineering skill" data-secondary-sortas="timeless" data-type="indexterm" id="id571"/> This often requires a strong grasp of fundamentals (how memory and state work, concurrency, etc.) that junior developers must learn through practice. Use AI as a helper (it might explain error messages or suggest fixes), but <em>don’t rely on it thoughtlessly</em>. The skill to methodically troubleshoot and apply first principles when debugging sets great developers apart. It’s also a feedback loop: debugging AI-written code will teach you to prompt the AI better next time or avoid certain patterns.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Learn Systems Thinking"><div class="sect2" id="ch04_learn_systems_thinking_1752630043402139">
<h2>Learn Systems Thinking</h2>

<p>Software projects are not just isolated coding tasks; they exist within a larger context of user needs, timelines, legacy code, and team processes.<a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="learning systems thinking" data-type="indexterm" id="id572"/><a contenteditable="false" data-primary="systems" data-secondary="learning systems thinking" data-type="indexterm" id="id573"/> AI has no innate sense of the big picture, like your project’s history or the rationale behind certain decisions (unless you explicitly feed all that into the prompt, which is often impractical). Humans need to carry that context.</p>

<p>The durable skill here is systems thinking—understanding how a change in one part of the system might impact another, how the software serves the business objectives, and how all the moving pieces connect.<sup><a data-type="noteref" id="id574-marker" href="ch04.html#id574">2</a></sup> This holistic perspective lets you use AI outputs appropriately. For example, if an AI suggests a clever shortcut that contradicts a regulatory requirement or company convention, you’ll catch it because you know the context. Make it a point to learn the background of your projects and read design docs, so you can develop your judgment about what fits and what doesn’t.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Be Adaptable—and Never Stop Learning"><div class="sect2" id="ch04_be_adaptable_and_never_stop_learning_1752630043402190">
<h2>Be Adaptable—and Never Stop Learning</h2>

<p>Finally, a metaskill: the ability to learn new tools and adapt to change.<a contenteditable="false" data-primary="learning, importance of" data-type="indexterm" id="id575"/><a contenteditable="false" data-primary="adaptability and learning, importance of" data-type="indexterm" id="id576"/><a contenteditable="false" data-primary="change, adapting to" data-type="indexterm" id="id577"/><a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="learning new tools and adapting to change" data-type="indexterm" id="id578"/> The field of AI-assisted development is evolving rapidly. Engineers who keep an open mind and learn how to effectively use new AI features will remain ahead of the curve—Tim O’Reilly <a href="https://oreil.ly/BYrNh">suggests that</a> developers who are “eager to learn new skills” will see the biggest productivity boosts from AI. Invest in learning the <em>fundamentals</em> deeply and staying curious about new techniques. This combination enables you to harness AI as a tool without becoming dependent on it.</p>

<p>It’s a balancing act: use AI to accelerate your growth, but also occasionally practice without it to ensure you’re not skipping core learning (some developers do an <a href="https://oreil.ly/XFPqu">“AI detox”</a> periodically to keep their raw coding skills sharp). In short, be the engineer who learns constantly—that’s a career-proof skill in any era.<a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-startref="ix_engnmid" data-type="indexterm" id="id579"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Get Good at Cross-Functional Communication"><div class="sect2" id="ch04_get_good_at_cross_functional_communication_1752630043402241">
<h2>Get Good at Cross-Functional Communication</h2>

<p>The ability to translate<a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="cross-functional communication" data-type="indexterm" id="id580"/> between<a contenteditable="false" data-primary="communication" data-secondary="cross-functional, getting good at" data-type="indexterm" id="id581"/> business requirements and technical solutions becomes more valuable as implementation time decreases. Engineers who can effectively communicate with product managers, designers, and other stakeholders will become increasingly valuable. Good areas of focus here include:</p>

<ul>
	<li>
	<p>Requirements gathering and analysis</p>
	</li>
	<li>
	<p>Technical writing and documentation</p>
	</li>
	<li>
	<p>Project planning and estimation</p>
	</li>
	<li>
	<p>Team leadership and mentoring</p>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Learn System Design and Architecture"><div class="sect2" id="ch04_learn_system_design_and_architecture_1752630043402289">
<h2>Learn System Design and Architecture</h2>

<p>Instead of spending days implementing a new feature, midlevel engineers might spend that time designing robust systems that gracefully handle scale and failure modes. <a contenteditable="false" data-primary="architecture" data-secondary="midlevel engineers learning system architecture" data-type="indexterm" id="id582"/><a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="learning system design and architecture" data-type="indexterm" id="id583"/><a contenteditable="false" data-primary="systems" data-secondary="learning system design and architecture" data-type="indexterm" id="id584"/>This requires deep understanding of distributed systems principles, database internals, and cloud infrastructure—areas where LLMs currently provide limited value.</p>

<p>Practice designing systems that solve real-world problems at scale.<a contenteditable="false" data-primary="design" data-secondary="learning system design" data-type="indexterm" id="id585"/> These skills remain valuable regardless of how code is generated, as they require understanding business requirements and engineering trade-offs.</p>

<p>Designing a coherent system requires understanding trade-offs, constraints, and the “big picture” beyond writing a few functions. AI can generate code but won’t automatically choose the best architecture for a complex problem.</p>

<p>The overall design—how components interact, how data flows, how to ensure scalability and security—is part of that 30% that demands human insight; this includes the following:</p>

<ul>
	<li>
	<p>Load balancing<a contenteditable="false" data-primary="load balancing" data-type="indexterm" id="id586"/> and<a contenteditable="false" data-primary="caching" data-type="indexterm" id="id587"/> caching strategies</p>
	</li>
	<li>
	<p>Data partitioning <a contenteditable="false" data-primary="data partitioning and replication" data-type="indexterm" id="id588"/>and replication</p>
	</li>
	<li>
	<p>Failure modes <a contenteditable="false" data-primary="failure modes and recovery procedures" data-type="indexterm" id="id589"/>and recovery procedures</p>
	</li>
	<li>
	<p>Cost optimization <a contenteditable="false" data-primary="cost optimization" data-type="indexterm" id="id590"/>and <a contenteditable="false" data-primary="resource management" data-type="indexterm" id="id591"/>resource management</p>
	</li>
</ul>

<p>Senior developers have long honed this skill, and midlevel and junior devs should actively cultivate it. Think in terms of patterns and principles (like separation of concerns and modularity)—these guide an AI-generated solution toward maintainability. <a contenteditable="false" data-primary="architecture" data-secondary="solid architecture needing human oversight" data-type="indexterm" id="id592"/>Remember, <em>solid architecture doesn’t emerge by accident</em>; it needs an experienced human hand on the wheel.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Use AI!"><div class="sect2" id="ch04_use_ai_1752630043402336">
<h2>Use AI!</h2>

<p>Remember that AI should be an integral part of your workflow—it’s not something to resist.<a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="midlevel engineers using" data-type="indexterm" id="id593"/><a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="using AI" data-type="indexterm" id="id594"/> Practical ways to incorporate AI into your daily work include:</p>

<ul>
	<li>
	<p>Scaffolding initial code structures</p>
	</li>
	<li>
	<p>Quick prototypes and proof of concepts</p>
	</li>
	<li>
	<p>Pair programming for faster debugging and problem solving</p>
	</li>
	<li>
	<p>Suggesting optimizations and alternative approaches</p>
	</li>
	<li>
	<p>Handling repetitive code patterns while you focus on architecture and design decisions<a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="midlevel engineers, adapting and specializing" data-startref="ix_hmncntmid" data-type="indexterm" id="id595"/></p>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Venture into UI and UX Design"><div class="sect2" id="ch04_venture_into_ui_and_ux_design_1752630043402385">
<h2>Venture into UI and UX Design</h2>

<p>There’s a growing narrative<a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-tertiary="venturing into UI and UX design" data-type="indexterm" id="id596"/> that midlevel software<a contenteditable="false" data-primary="UI and UX design" data-secondary="midlevel engineers venturing into" data-type="indexterm" id="id597"/> engineers<a contenteditable="false" data-primary="design" data-secondary="UI and UX, midlevel engineers venturing into" data-type="indexterm" id="id598"/> should “just quit”—that pure engineering skills will become obsolete as AI handles the implementation details. While the conclusion is overstated, the discourse about the importance of skills beyond engineering (like design) deserves examination. In a representative exchange on X in December 2024, <a href="https://oreil.ly/BokTH">@fchollet wrote</a>:</p>

<blockquote>
<p>We’ll soon be in a world where you can turn test-time compute into competence—for the first time in the history of software, marginal cost will become critical.</p>
</blockquote>

<p>To which @garrytan replied:</p>

<blockquote>
<p>UX, design, actual dedication to the craft will take center stage in this next moment.</p>
</blockquote>

<p>Actually make something people want. Software and coding won’t be the gating factor. It is the ability to be a polymath and smart/effective in many domains together that creates great software.</p>

<p>Successful software creation has always required more than just coding ability. What’s changing is not the death of engineering but rather the lowering of pure implementation barriers. This shift actually makes engineering judgment and design thinking more crucial, not less.</p>

<p>Consider what makes applications like Figma, Notion, or VSCode successful. It’s not just technical excellence—it’s the deep understanding of user needs, workflows, and pain points. This understanding comes from the following:</p>

<ul>
	<li>
	<p>User experience design thinking</p>
	</li>
	<li>
	<p>Deep domain knowledge</p>
	</li>
	<li>
	<p>Understanding of human psychology and behavior</p>
	</li>
	<li>
	<p>System design that considers performance, reliability, and scalability</p>
	</li>
	<li>
	<p>Business model alignment</p>
	</li>
</ul>

<p>The best engineers have always been more than just coders. They’ve been problem solvers who understand both technical constraints and human needs. As AI tools reduce the friction of implementation, this holistic understanding becomes even more valuable.</p>

<p>However, this doesn’t mean every engineer needs to become a UX designer. Instead, it means developing stronger product thinking abilities and building better collaboration skills with designers and product managers. It means thinking more about users, understanding their psychology and behavior patterns, and learning to make technical decisions that support user experience goals. You’re at the point of achieving technical elegance: now balance it out with close attention to practical user needs.</p>

<p>Tan went on to post:</p>

<blockquote>
<p>UX, design, actual dedication to the craft will take center stage in this next moment.</p>
</blockquote>

<p>Actually make something people want. Software and coding won’t be the gating factor. It is the ability to be a polymath and smart/effective in many domains together that creates great software.</p>

<p>The future belongs to engineers who can bridge the gap between human needs and technical solutions—whether that’s through developing better design sensibilities themselves or through more effective collaboration with dedicated designers.<a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="midlevel engineers, adapting and specializing" data-startref="ix_hmncntmid" data-type="indexterm" id="id599"/><a contenteditable="false" data-primary="engineers" data-secondary="midlevel engineers, adapting and specializing" data-startref="ix_engnmid" data-type="indexterm" id="id600"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Junior Developers: Thrive Alongside AI"><div class="sect1" id="ch04_junior_developers_thrive_alongside_ai_1752630043402438">
<h1>Junior Developers: Thrive Alongside AI</h1>

<p>If you’re a junior or less-experienced developer, you might feel a mix of excitement and anxiety about AI.<a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="junior developers thriving along with AI" data-type="indexterm" id="ix_hmncntjnr"/><a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-type="indexterm" id="ix_devjnrAI"/> AI assistants can write code that you might not know how to write yourself, potentially accelerating your learning.<a contenteditable="false" data-primary="death of the junior developer" data-type="indexterm" id="id601"/><a contenteditable="false" data-primary="junior developers" data-see="developers" data-type="indexterm" id="id602"/> Yet there are headlines about the <a href="https://oreil.ly/QtJ7_">“death of the junior developer”</a>, suggesting entry-level coding jobs are at risk. Contrary to popular speculation, while AI is significantly changing the early-career experience, junior developers <em>are not obsolete</em>.</p>

<p>You need to be proactive in developing skills that ensure you’re contributing value beyond what an AI can churn out. The traditional path of learning through implementing basic CRUD applications and simple features will evolve as these tasks become increasingly automated.</p>

<p>Consider a typical junior task: implementing a new API endpoint following existing patterns. <a contenteditable="false" data-primary="APIs" data-secondary="junior developers implementing new endpoint following patterns" data-type="indexterm" id="id603"/>Previously, this might have taken a day of coding and testing. With AI assistance, the implementation time might drop to an hour, but the crucial skills become:</p>

<ul>
	<li>
	<p>Understanding the existing system architecture well enough to specify the requirement correctly</p>
	</li>
	<li>
	<p>Reviewing the generated code for security implications and edge cases</p>
	</li>
	<li>
	<p>Ensuring the implementation maintains consistency with existing patterns</p>
	</li>
	<li>
	<p>Writing comprehensive tests that verify business logic</p>
	</li>
</ul>

<p>These skills can’t be learned purely through tutorial following or AI prompting—they require hands-on experience with production systems and mentorship from senior engineers.</p>

<p>This evolution presents both challenges and opportunities for early-career developers. The bar for entry-level positions may rise, requiring stronger fundamental knowledge to effectively review and validate AI-generated code. However, this shift also means junior engineers can potentially tackle more interesting problems earlier in their careers.</p>

<p>Here’s how to invest in yourself to handle that 30% gap effectively.</p>

<section data-type="sect2" data-pdf-bookmark="Learn the Fundamentals—Don’t Skip the “Why”"><div class="sect2" id="ch04_learn_the_fundamentals_don_t_skip_the_why_1752630043402494">
<h2>Learn the Fundamentals—Don’t Skip the “Why”</h2>

<p>It’s tempting to lean on AI for answers to every question (“How do I do X in Python?”) and never truly absorb the underlying concepts.<a contenteditable="false" data-primary="fundamentals" data-secondary="importance of learning by junior developers" data-type="indexterm" id="id604"/> <a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-tertiary="learning the fundamentals" data-type="indexterm" id="id605"/>Resist that urge. Use AI as a tutor, not just an answer vending machine. For example, when AI gives you a piece of code, ask <em>why</em> it chose that approach, or have it explain the code line by line.</p>

<p>Make sure you understand<a contenteditable="false" data-primary="data structures" data-type="indexterm" id="id606"/> concepts like<a contenteditable="false" data-primary="algorithms" data-secondary="junior developers' understanding of" data-type="indexterm" id="id607"/> data structures, algorithms, memory management, and concurrency without always deferring to AI.<a contenteditable="false" data-primary="concurrency" data-type="indexterm" id="id608"/><a contenteditable="false" data-primary="memory management" data-type="indexterm" id="id609"/> The reason is simple: when the AI’s output is wrong or incomplete, you need your own mental model to recognize and fix it. If you’re not actively engaging with why the AI is generating certain code, you might actually learn less, hindering your growth. So take time to read documentation, write small programs from scratch, and solidify your core knowledge. These fundamentals are durable; they’ll serve you even as the tools around you change.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Practice Problem Solving and Debugging Without the AI Safety Net"><div class="sect2" id="ch04_practice_problem_solving_and_debugging_without_the_1752630043402545">
<h2>Practice Problem Solving and Debugging Without the AI Safety Net</h2>

<p>To build real confidence, sometimes you have to fly solo.<a contenteditable="false" data-primary="debugging" data-secondary="junior developers practicing without AI" data-type="indexterm" id="id610"/><a contenteditable="false" data-primary="problem solving" data-secondary="junior developers practicing without AI" data-type="indexterm" id="id611"/><a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-tertiary="practicing problem solving and debugging without AI" data-type="indexterm" id="id612"/> Many developers advocate doing an “AI-free day” or otherwise limiting AI assistance periodically. This ensures you can still solve problems with just your own skills, which is important for avoiding skill atrophy.<a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="practicing problem solving and debugging without using AI" data-type="indexterm" id="id613"/> You’ll find it forces you to truly think through a problem’s logic, which in turn makes you better at using AI (since you can direct it more intelligently).</p>

<p>Additionally, whenever you encounter a bug or error in AI-generated code, jump in and debug it <em>yourself</em> before asking the AI to fix it. You’ll learn much more by stepping through a debugger or adding print statements to see what’s going wrong.</p>

<p>Consider AI suggestions as hints, not final answers. Over time, tackling those last tricky bits of a task will build your skill in the very areas AI struggles—exactly what makes you valuable.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Focus on Testing and Verification"><div class="sect2" id="ch04_focus_on_testing_and_verification_1752630043402594">
<h2>Focus on Testing and Verification</h2>

<p>As a junior dev, one of the best habits you can develop is writing tests for your code. This is doubly true if you use AI to generate code.<a contenteditable="false" data-primary="verification" data-secondary="of AI-generated code, focusing on" data-secondary-sortas="AI-generated" data-type="indexterm" id="id614"/><a contenteditable="false" data-primary="testing" data-secondary="junior developers focusing on" data-type="indexterm" id="id615"/><a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-tertiary="focusing on testing and verification" data-type="indexterm" id="id616"/></p>

<p>When you get a chunk of code from an LLM, don’t assume it’s correct—challenge it. Write unit tests (or use manual tests) to see if it truly handles the requirements and edge cases. This accomplishes two things: it catches issues in the AI’s output, and it trains you to think about expected behavior before trusting an implementation.</p>

<p>You might even use the AI to help write tests, but <em>you</em> define what to test. <a href="https://oreil.ly/QtJ7_">Yegge’s advice</a> about taking testing and code review seriously applies at all levels. If you cultivate a reputation for carefully verifying your work (AI-assisted or not), senior colleagues will trust you more, and you’ll avoid the scenario where they feel you’re just “dumping” questionable code on them.</p>

<p>In practical terms, start treating testing as an integral part of development, not an afterthought. Learn how to use testing frameworks, how to do exploratory manual testing, and how to systematically reproduce bugs. These skills not only make you better at the 30% work, but they also accelerate your understanding of how the code really works.</p>

<p>Remember: if you catch a bug that the AI introduced, <em>you</em> just did something the AI couldn’t—that’s added value.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Build an Eye for Maintainability"><div class="sect2" id="ch04_build_an_eye_for_maintainability_1752630043402644">
<h2>Build an Eye for Maintainability</h2>

<p>Junior devs often focus on “getting it to work.” But in the AI era, getting a basic working version is easy—the AI can do that. <a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-tertiary="developing eye for maintainability" data-type="indexterm" id="id617"/><a contenteditable="false" data-primary="maintainability" data-secondary="junior developers developing eye for" data-type="indexterm" id="id618"/>The harder part (and what you should focus on) is making code that’s readable, maintainable, and clean.</p>

<p>Start developing an eye for good code structure and style. Compare the AI’s output with best practices you know of; if the AI code is messy or overly complex, take the initiative to refactor it. For instance, if an LLM gives you a 50-line function that does too many things, you can split it into smaller functions. If variable names are unclear, rename them.</p>

<p>Essentially, pretend you’re reviewing a peer’s code, and improve the AI’s code as if a peer wrote it. This will help you internalize good design principles. Over time, you’ll start prompting the AI in ways that yield cleaner code to begin with (because you’ll specify the style you want). Software maintainers (often working months or years later) will thank you, and you’ll prove that you’re thinking beyond just “make it run”⁠—you’re thinking like an engineer. Keeping things maintainable is exactly in that human-driven 30%, so make it your concern from the start of your career.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Develop Your Prompting and Tooling Skills (Wisely)"><div class="sect2" id="ch04_develop_your_prompting_and_tooling_skills_wisely_1752630043402692">
<h2>Develop Your Prompting and Tooling Skills (Wisely)</h2>

<p>There’s no denying that “prompt engineering”—the skill of interacting with AI tools effectively—is useful. <a contenteditable="false" data-primary="tools" data-secondary="junior developers building AI tooling skills" data-type="indexterm" id="id619"/><a contenteditable="false" data-primary="prompts" data-secondary="junior developers developing skills in" data-type="indexterm" id="id620"/><a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-tertiary="developing prompting and tooling skills" data-type="indexterm" id="id621"/>As a junior dev, you should absolutely learn how to phrase questions to AI, how to give it proper context, and how to iterate on prompts to improve the output (<a data-type="xref" href="ch02.html#ch02_the_art_of_the_prompt_communicating_effectively_w_1752630042971067">Chapter 2</a> of this book is a good place to start). These are new skills that can set you apart (many experienced devs are still figuring this out too!). However, remember that prompting well is often a proxy for understanding the problem well. If you find you can’t get the AI to do what you want, it might be because <em>you</em> need to clarify your own understanding first. Use that as a signal.</p>

<p>One strategy is to outline a solution in plain English yourself before asking the AI to implement it. Also, experiment with different AI tools (Copilot, Claude, etc.) to see their strengths and weaknesses. The more fluent you are with these assistants, the more productive you can be—but never treat their output as infallible. Think of AI like a super-charged Stack Overflow: an aid, not an authority.</p>

<p>You might even build small personal projects using AI to push your limits (“Can I build a simple web app with AI’s help?”). Doing so will teach you how to integrate AI into a development workflow, which is a great skill to bring into a team. Just balance it with periods of working without the net, as mentioned earlier.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Seek Feedback and Mentorship"><div class="sect2" id="ch04_seek_feedback_and_mentorship_1752630043402741">
<h2>Seek Feedback and Mentorship</h2>

<p>Lastly, one durable skill that will accelerate your growth is the ability to seek out feedback and learn from others. <a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-tertiary="seeking feedback and mentorship" data-type="indexterm" id="id622"/><a contenteditable="false" data-primary="feedback" data-secondary="junior developers seeking from team members" data-type="indexterm" id="id623"/>An AI won’t get offended if you ignore its advice, but your human teammates and mentors are invaluable for your development—especially when it comes to soft skills, leadership, communication, and navigating office <span class="keep-together">politics</span>.<a contenteditable="false" data-primary="mentorship" data-secondary="junior developers seeking from team members" data-type="indexterm" id="id624"/></p>

<p>Don’t hesitate to ask a senior developer why they prefer one solution over another, especially if it differs from what an AI suggested. Discuss design decisions and trade-offs with more experienced colleagues—these conversations reveal how seasoned engineers think, and that’s gold for you. In code reviews, be extra receptive to comments about your AI-written code. If a reviewer points out that “this function isn’t thread-safe” or “this approach will have scaling issues,” take the time to understand the root issue. These are exactly the kinds of things an AI might miss, and you want to learn to catch them. Over time, you’ll build a mental checklist of considerations.</p>

<p>Additionally, find opportunities to pair program (even if remotely). <a contenteditable="false" data-primary="human-human pair programming" data-secondary="junior developers with senior mentors" data-type="indexterm" id="id625"/><a contenteditable="false" data-primary="pair programming" data-secondary="junior developers with senior mentors" data-type="indexterm" id="id626"/>Perhaps you can “pair” with a senior who uses AI in their workflow—you’ll observe how they prompt the AI and how they correct it. But even more important, you’ll see how they communicate, lead discussions, and handle delicate team dynamics. Being open to feedback and actively asking for guidance will help you mature from doing tasks that an AI could do to performing the high-value tasks that only humans can do. In a sense, you’re trying to acquire the wisdom that usually comes with experience, as efficiently as you can. That makes you more than just another coder in the room—it makes you the kind of engineer teams are eager to keep and promote.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Communicate and Collaborate"><div class="sect2" id="ch04_communicate_and_collaborate_1752630043402790">
<h2>Communicate and Collaborate</h2>

<p class="fix_tracking">Building software is a team sport. AI doesn’t attend meetings (thank goodness)—humans still must talk to other humans to clarify requirements, discuss trade-offs, and coordinate work.<a contenteditable="false" data-primary="communication" data-secondary="junior developers communicating with team members" data-type="indexterm" id="id627"/><a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-tertiary="communicating and collaborating" data-type="indexterm" id="id628"/> Strong communication skills are as valuable as ever. Practice asking good questions and describing problems clearly (both to colleagues and to AI).</p>

<p>Interestingly, prompting an AI is itself a form of <a contenteditable="false" data-primary="prompts" data-secondary="prompting AI as form of communication" data-type="indexterm" id="id629"/>communication; it requires you to precisely express what you want.<a contenteditable="false" data-primary="requirements analysis" data-type="indexterm" id="id630"/> This overlaps with a core engineering skill: <em>requirements analysis</em>.<sup><a data-type="noteref" id="id631-marker" href="ch04.html#id631">3</a></sup> If you can formulate a clear prompt or spec, it means you’ve thought through the problem.</p>

<p>Additionally, sharing <a contenteditable="false" data-primary="collaboration" data-secondary="junior developers collaborating with team members" data-type="indexterm" id="id632"/>knowledge, writing documentation, and reviewing others’ code are collaborative skills that AI cannot replace. In the future, as developers work “with” AI, the human-to-human collaboration in a team—making sure the right problems are being solved—stays vital. One emerging trend is that developers may focus more on high-level design discussions (often with AI as a participant) and on coordinating tasks, essentially taking on more of a conductor role. Communication and leadership skills will serve you well in that conductor’s seat.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Shift Your Mindset: From Consuming to Creating"><div class="sect2" id="ch04_shift_your_mindset_from_consuming_to_creating_1752630043402840">
<h2>Shift Your Mindset: From Consuming to Creating</h2>

<p>It’s worth noting a mindset shift for juniors in the AI era: you need to move from just <em>consuming solutions to creating understanding</em>. <a contenteditable="false" data-primary="solutions" data-secondary="shifting mindset from consuming to creating" data-type="indexterm" id="id633"/><a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-tertiary="shifting mindset from consuming to creating solutions" data-type="indexterm" id="id634"/>In the past, you might have struggled through documentation to eventually write a feature; now an AI can hand you a solution on a platter. If you simply consume it (copy-paste and move on), you haven’t grown much.</p>

<p>Instead, use each AI-given solution as a learning case. Dissect it, experiment with it, and consider how you might have arrived at it yourself. By treating AI outputs not as answers to end all questions but as interactive learning material, you ensure that you⁠—the human—are continuously leveling up. This way, rather than replacing your growth, AI accelerates it.</p>

<p>Many experts believe that while AI might reduce the need for large teams of junior “coder-grinders,” it also <em>raises the bar</em> for what it means to be a junior developer. The role is shifting to someone who can work effectively with AI and quickly climb the value chain. If you adopt the habits discussed in this section, you’ll distinguish yourself as a junior developer who doesn’t just bring what an AI could bring (any company can get that via a subscription) but who brings insight, reliability, and continuous improvement—traits of a future senior developer.<a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="junior developers thriving along with AI" data-startref="ix_hmncntjnr" data-type="indexterm" id="id635"/><a contenteditable="false" data-primary="developers" data-secondary="junior developers thriving along with AI" data-startref="ix_devjnrAI" data-type="indexterm" id="id636"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Summary and Next Steps"><div class="sect1" id="ch04_future_proof_your_career_with_durable_engineering_1752630043402901">
<h1>Summary and Next Steps</h1>

<p>To thrive <a contenteditable="false" data-primary="future-proofing your career with durable engineering skills" data-type="indexterm" id="id637"/>in an AI-enhanced <a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="future-proofing your career with durable engineering skills" data-type="indexterm" id="id638"/>development <a contenteditable="false" data-primary="engineers" data-secondary="future-proofing your career with durable engineering skills" data-type="indexterm" id="id639"/>world, engineers at all levels should double down on the enduring skills and practices that AI cannot (yet) replicate.<a contenteditable="false" data-primary="skills" data-secondary="durable engineering skills that future-proof your career" data-type="indexterm" id="id640"/> These capabilities will remain crucial no matter how advanced our tools become. In particular, focus on these areas:</p>

<ul>
	<li>
	<p>Strengthening your system <a contenteditable="false" data-primary="systems" data-secondary="durable engineering skills to future-proof your career" data-type="indexterm" id="id641"/>design and architecture expertise</p>
	</li>
	<li>
	<p>Practicing systems thinking and maintaining a contextual understanding of the big picture</p>
	</li>
	<li>
	<p>Honing your skills in critical thinking, problem solving, and foresight</p>
	</li>
	<li>
	<p>Building expertise in specialized domains</p>
	</li>
	<li>
	<p>Reviewing code, testing, debugging, and quality assurance</p>
	</li>
	<li>
	<p>Improving your communication and collaboration skills</p>
	</li>
	<li>
	<p>Adapting to change</p>
	</li>
	<li>
	<p>Continuously learning, keeping your fundamentals strong while gaining new skills and updating your knowledge</p>
	</li>
	<li>
	<p>Using AI</p>
	</li>
</ul>

<p>These skills form the human advantage in software engineering. They are durable because they don’t expire with the next framework or tooling change; if anything, AI’s rise makes them more pronounced. Simon Willison has <a href="https://oreil.ly/5F3O7">argued that</a> AI assistance actually makes strong programming skills <em>more</em> valuable, not less, because those with expertise can leverage the tools to far greater effect.</p>

<p>A powerful machine in unskilled hands can be dangerous or wasted, but in capable hands it’s transformative. In the AI era, an experienced engineer is like a seasoned pilot with a new advanced copilot: the journey can go faster and farther, but the pilot must still navigate the storms and ensure a safe landing.</p>

<p>Software engineering has always been a<a contenteditable="false" data-primary="software engineering" data-secondary="continuous change in" data-type="indexterm" id="id642"/> field of continuous change—from assembly language to high-level programming, from on-prem servers to the cloud, and now from manual coding to AI-assisted development. Each leap has automated some aspect of programming, yet each time, developers have adapted and found even more to do. In response to a Tim O’Reilly <a href="https://oreil.ly/BYrNh">note</a>, one HN commenter <a href="https://oreil.ly/OewGO">remarked</a> that past innovations “almost always resulted in more work, more growth, more opportunities” for developers. <a contenteditable="false" data-primary="developers" data-secondary="innovations resulting in more growth and opportunities for" data-type="indexterm" id="id643"/>The rise of AI is no different. Rather than making developers irrelevant, it is reshaping the skill set needed to succeed. The mundane 70% of coding is getting easier; the challenging 30% becomes an even larger part of our value.</p>

<p>To maximize that human 30%, focus on the timeless engineering skills: understanding problems deeply, designing clean solutions, scrutinizing code for quality, and considering the users and context. Experienced programmers are gaining more from AI because they know how to guide it and what to do when it falters. Those who combine these skills with AI tools will outperform those who have only one or the other.<a contenteditable="false" data-primary="LLMs (large language models)" data-secondary="as power tools meant for power users" data-secondary-sortas="power" data-type="indexterm" id="id644"/> In fact, the <a href="https://oreil.ly/5gfvc">consensus emerging among experts</a> is that AI is a tool for the skilled: that “LLMs are power tools meant for power users.” This means the onus is on each of us to become that “power user”—to cultivate the expertise that lets us wield these new tools effectively.</p>

<p>Ultimately, the craft of software engineering is more than writing code that works. It’s about writing code that <em>works well</em>—in a real-world environment, over time, and under evolving requirements. Today’s AI models can assist with writing code but cannot yet ensure the code works well in all those dimensions. That’s the developer’s job.</p>

<p>By doubling down on the skills just outlined, senior developers can continue to lead and innovate, midlevel developers can deepen their expertise, and junior developers can accelerate their journey to mastery. AI will handle more and more of the routine, but your creativity, intuition, and thoughtful engineering will turn that raw output into something truly valuable. AI is a powerful tool, but it’s all about how we use it. Good engineering practices, human judgment, and a willingness to learn will remain essential.</p>

<p>In practical terms, whether you are pair programming with an “eager junior” AI that writes your functions or reviewing a diff full of AI-generated code, never forget to apply your uniquely human lens. Ask, Does this solve the <em>right</em> problem? Will others be able to understand and maintain this? What are the risks and edge cases? Those questions are your responsibility. The future of programming will indeed involve less typing every semicolon by hand and more directing and curating—but it will still require developers at the helm who have the wisdom to do it right.</p>

<p>In the end, great software engineering has always been about problem solving, not just code slinging. AI doesn’t change that: it simply challenges us to elevate our problem solving to the next level. Embrace that challenge, and you’ll thrive in this new chapter of our industry.<a contenteditable="false" data-primary="human contribution, maximizing" data-startref="ix_hmncnt" data-type="indexterm" id="id645"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id534"><sup><a href="ch04.html#id534-marker">1</a></sup> This chapter is based on two essays I first published on my Substack newsletter: Addy Osmani, <a href="https://oreil.ly/PMFsp">“Beyond the 70%: Maximizing the Human 30% of AI-Assisted Coding”</a>, <em>Elevate with Addy Osmani</em>, March 13, 2025; and Addy Osmani, <a href="https://oreil.ly/1EoW8">“Future-Proofing Your Software Engineering Career”</a>, <em>Elevate with Addy Osmani</em>, December 23, 2024. </p><p data-type="footnote" id="id574"><sup><a href="ch04.html#id574-marker">2</a></sup> To learn more about systems thinking, check out Donella H. Meadows, <em>Thinking in Systems: A Primer</em>, 2nd edition (Rizzoli, 2008); and Peter M. Senge, <em>The Fifth Discipline: The Art and Practice of the Learning Organization</em> (Crown, 2010). </p><p data-type="footnote" id="id631"><sup><a href="ch04.html#id631-marker">3</a></sup> For more on this topic, see Mark Richards and Neal Ford, <em>Fundamentals of Software Architecture</em>, 2nd edition (O’Reilly, 2025); and Mark Richards, Neal Ford, and Raju Gandhi, <em>Head First Software Architecture</em> (O’Reilly, 2024).</p></div></div></section></div></div></body></html>